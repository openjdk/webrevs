{"files":[{"patch":"@@ -69,1 +69,1 @@\n-      uses: actions\/upload-artifact@v3\n+      uses: actions\/upload-artifact@v4\n@@ -77,1 +77,1 @@\n-      uses: actions\/github-script@v6\n+      uses: actions\/github-script@v7\n","filename":".github\/actions\/do-build\/action.yml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-      uses: actions\/cache@v3\n+      uses: actions\/cache@v4\n","filename":".github\/actions\/get-bootjdk\/action.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-      uses: actions\/download-artifact@v3\n+      uses: actions\/download-artifact@v4\n@@ -58,1 +58,1 @@\n-      uses: actions\/download-artifact@v3\n+      uses: actions\/download-artifact@v4\n","filename":".github\/actions\/get-bundles\/action.yml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-      uses: actions\/cache@v3\n+      uses: actions\/cache@v4\n","filename":".github\/actions\/get-jtreg\/action.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n-      # use a specific release of msys2\/setup-msys2 to prevent jtreg build failures on newer release\n-      uses: msys2\/setup-msys2@7efe20baefed56359985e327d329042cde2434ff\n+      uses: msys2\/setup-msys2@v2.22.0\n","filename":".github\/actions\/get-msys2\/action.yml","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-      uses: actions\/upload-artifact@v3\n+      uses: actions\/upload-artifact@v4\n","filename":".github\/actions\/upload-bundles\/action.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+            tolerate-sysroot-errors: false\n@@ -69,0 +70,1 @@\n+            tolerate-sysroot-errors: false\n@@ -75,0 +77,1 @@\n+            tolerate-sysroot-errors: false\n@@ -80,0 +83,1 @@\n+            tolerate-sysroot-errors: false\n@@ -85,0 +89,1 @@\n+            tolerate-sysroot-errors: true\n@@ -96,7 +101,0 @@\n-        # Use linux-x64 JDK bundle as build JDK\n-      - name: 'Get build JDK'\n-        id: buildjdk\n-        uses: .\/.github\/actions\/get-bundles\n-        with:\n-          platform: linux-x64\n-\n@@ -123,1 +121,1 @@\n-        uses: actions\/cache@v3\n+        uses: actions\/cache@v4\n@@ -133,0 +131,1 @@\n+        id: create-sysroot\n@@ -143,0 +142,1 @@\n+        continue-on-error: ${{ matrix.tolerate-sysroot-errors }}\n@@ -154,1 +154,6 @@\n-        if: steps.get-cached-sysroot.outputs.cache-hit != 'true'\n+        if: steps.create-sysroot.outcome == 'success' && steps.get-cached-sysroot.outputs.cache-hit != 'true'\n+\n+      - name: 'Remove broken sysroot'\n+        run: |\n+          sudo rm -rf sysroot\/\n+        if: steps.create-sysroot.outcome != 'success' && steps.get-cached-sysroot.outputs.cache-hit != 'true'\n@@ -168,1 +173,0 @@\n-          --with-build-jdk=${{ steps.buildjdk.outputs.jdk-path }}\n@@ -176,0 +180,1 @@\n+        if: steps.create-sysroot.outcome == 'success' || steps.get-cached-sysroot.outputs.cache-hit == 'true'\n@@ -183,0 +188,1 @@\n+        if: steps.create-sysroot.outcome == 'success' || steps.get-cached-sysroot.outputs.cache-hit == 'true'\n","filename":".github\/workflows\/build-cross-compile.yml","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -135,2 +135,1 @@\n-    # The linux-x64 jdk bundle is used as buildjdk for the cross-compile job\n-    if: needs.select.outputs.linux-x64 == 'true' || needs.select.outputs.linux-cross-compile == 'true'\n+    if: needs.select.outputs.linux-x64 == 'true'\n@@ -216,1 +215,0 @@\n-      - build-linux-x64\n@@ -370,1 +368,1 @@\n-        uses: actions\/github-script@v6\n+        uses: actions\/github-script@v7\n","filename":".github\/workflows\/main.yml","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-        uses: actions\/upload-artifact@v3\n+        uses: actions\/upload-artifact@v4\n@@ -232,1 +232,1 @@\n-        uses: actions\/github-script@v6\n+        uses: actions\/github-script@v7\n","filename":".github\/workflows\/test.yml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-version=21.0.3\n+version=21.0.4\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-###############################################################################\n+################################################################################\n@@ -40,1 +40,4 @@\n-    SET_EXECUTABLE_ORIGIN='-Wl,-rpath,\\$$ORIGIN[$]1'\n+    # --disable-new-dtags forces use of RPATH instead of RUNPATH for rpaths.\n+    # This protects internal library dependencies within the JDK from being\n+    # overridden using LD_LIBRARY_PATH. See JDK-8326891 for more information.\n+    SET_EXECUTABLE_ORIGIN='-Wl,-rpath,\\$$ORIGIN[$]1 -Wl,--disable-new-dtags'\n@@ -66,0 +69,3 @@\n+      if test \"x$OPENJDK_TARGET_OS\" = xlinux; then\n+        SET_EXECUTABLE_ORIGIN=\"$SET_EXECUTABLE_ORIGIN -Wl,--disable-new-dtags\"\n+      fi\n@@ -125,0 +131,5 @@\n+\n+            # Add debug prefix map for OUTPUTDIR to handle the scenario when\n+            # it is not located within WORKSPACE_ROOT\n+            outputdir_slash=\"${OUTPUTDIR%\/}\/\"\n+            DEBUG_PREFIX_CFLAGS=\"$DEBUG_PREFIX_CFLAGS -fdebug-prefix-map=${outputdir_slash}=\"\n@@ -488,1 +499,1 @@\n-    CFLAGS_OS_DEF_JVM=\"-DAIX\"\n+    CFLAGS_OS_DEF_JVM=\"-DAIX -D_LARGE_FILES\"\n","filename":"make\/autoconf\/flags-cflags.m4","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,0 +155,4 @@\n+  ifneq ($$(findstring $$(LOG_LEVEL), debug trace),)\n+    SHELL := $$(SHELL) -x\n+  endif\n+\n","filename":"make\/common\/MakeBase.gmk","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-DEFAULT_VERSION_UPDATE=3\n+DEFAULT_VERSION_UPDATE=4\n@@ -36,1 +36,1 @@\n-DEFAULT_VERSION_DATE=2024-04-16\n+DEFAULT_VERSION_DATE=2024-07-16\n","filename":"make\/conf\/version-numbers.conf","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  ADLC_CFLAGS += $(ADLC_LANGSTD_CXXFLAG)\n+  ADLC_CFLAGS += $(ADLC_LANGSTD_CXXFLAGS)\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -870,1 +870,1 @@\n-  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libTestPsig.c libnativeStack.c exeGetCreatedJavaVMs.c\n+  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libMonitorWithDeadObjectTest.c libTestPsig.c libnativeStack.c exeGetCreatedJavaVMs.c\n@@ -1511,0 +1511,1 @@\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libMonitorWithDeadObjectTest += -lpthread\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,17 @@\n+\n+ifndef SOURCE\n+export SOURCE := 7\n+endif\n+ifndef TARGET\n+export TARGET := 7\n+endif\n+ifndef JAVAC\n+export JAVAC := javac\n+endif\n+ifndef JAVA\n+export JAVA := java\n+endif\n+ifndef JAR\n+export JAR := jar\n+endif\n+\n@@ -83,1 +100,1 @@\n-\tjava -jar $(DIST)\/J2DBench.jar\n+\t$(JAVA) -jar $(DIST)\/J2DBench.jar\n@@ -86,1 +103,1 @@\n-\tjava -jar $(DIST)\/J2DAnalyzer.jar\n+\t$(JAVA) -jar $(DIST)\/J2DAnalyzer.jar\n@@ -91,1 +108,1 @@\n-\tjar cvmf $(CLASSES)\/j2dbench.manifest $(DIST)\/J2DBench.jar -C $(CLASSES) j2dbench\n+\t$(JAR) cvmf $(CLASSES)\/j2dbench.manifest $(DIST)\/J2DBench.jar -C $(CLASSES) j2dbench\n@@ -94,1 +111,1 @@\n-\tjar cvmf $(CLASSES)\/j2danalyzer.manifest \\\n+\t$(JAR) cvmf $(CLASSES)\/j2danalyzer.manifest \\\n@@ -123,1 +140,1 @@\n-\tjavac -g:none -source 1.7 -target 1.7 -d $(CLASSES) -sourcepath $(SOURCEPATH) $<\n+\t$(JAVAC) -g:none -source $(SOURCE) -target $(TARGET) -d $(CLASSES) -sourcepath $(SOURCEPATH) $<\n","filename":"src\/demo\/share\/java2d\/J2DBench\/Makefile","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+Yo can use TARGET\/SOURCE of makefile and -Dtarget\/surce to set them up for your convinience.\n+Similarly you can set JAVA\/JAVAC\/JAR and -Djava\/javac to select diffferent java\/javac then is on yoru PATH\n+Unluckily in ant, you can not set jar, but ant should honor JAVA_HOME\n","filename":"src\/demo\/share\/java2d\/J2DBench\/README","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,21 @@\n+  <condition property=\"source\" value=\"7\">\n+     <not>\n+        <isset property=\"source\"\/>\n+     <\/not>\n+  <\/condition>\n+  <condition property=\"target\" value=\"7\">\n+     <not>\n+        <isset property=\"target\"\/>\n+     <\/not>\n+  <\/condition>\n+  <condition property=\"java\" value=\"java\">\n+     <not>\n+        <isset property=\"java\"\/>\n+     <\/not>\n+  <\/condition>\n+  <condition property=\"javac\" value=\"javac\">\n+     <not>\n+        <isset property=\"javac\"\/>\n+     <\/not>\n+  <\/condition>\n+\n@@ -52,1 +73,1 @@\n-    <javac debug=\"off\" source=\"1.7\" target=\"1.7\" srcdir=\"${src}\" destdir=\"${build}\"\/>\n+    <javac debug=\"off\" source=\"${source}\" target=\"${target}\" srcdir=\"${src}\" destdir=\"${build}\" fork=\"true\" executable=\"${javac}\"\/>\n@@ -59,0 +80,1 @@\n+       jvm=\"${java}\"\n@@ -67,0 +89,1 @@\n+       jvm=\"${java}\"\n","filename":"src\/demo\/share\/java2d\/J2DBench\/build.xml","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -190,0 +190,20 @@\n+\/\/ This encoding is similar (but not quite identical) to the encoding used\n+\/\/ by literal ld\/st. see JDK-8324123.\n+\/\/ PRFM does not support writeback or pre\/post index.\n+void Assembler::prfm(const Address &adr, prfop pfop) {\n+  Address::mode mode = adr.getMode();\n+  \/\/ PRFM does not support pre\/post index\n+  guarantee((mode != Address::pre) && (mode != Address::post), \"prfm does not support pre\/post indexing\");\n+  if (mode == Address::literal) {\n+    starti;\n+    f(0b11, 31, 30), f(0b011, 29, 27), f(0b000, 26, 24);\n+    f(pfop, 4, 0);\n+    int64_t offset = (adr.target() - pc()) >> 2;\n+    sf(offset, 23, 5);\n+  } else {\n+    assert((mode == Address::base_plus_offset)\n+            || (mode == Address::base_plus_offset_reg), \"must be base_plus_offset\/base_plus_offset_reg\");\n+    ld_st2(as_Register(pfop), adr, 0b11, 0b10);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -798,0 +798,2 @@\n+  void prfm(const Address &adr, prfop pfop = PLDL1KEEP);\n+\n@@ -1575,11 +1577,0 @@\n-#define INSN(NAME, size, op)                                    \\\n-  void NAME(const Address &adr, prfop pfop = PLDL1KEEP) {       \\\n-    ld_st2(as_Register(pfop), adr, size, op);                   \\\n-  }\n-\n-  INSN(prfm, 0b11, 0b10); \/\/ FIXME: PRFM should not be used with\n-                          \/\/ writeback modes, but the assembler\n-                          \/\/ doesn't enfore that.\n-\n-#undef INSN\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-  uint stk_args = 0; \/\/ inc by 2 each time\n+  uint stk_args = 0;\n@@ -325,0 +325,1 @@\n+        stk_args = align_up(stk_args, 2);\n@@ -326,1 +327,1 @@\n-        stk_args += 2;\n+        stk_args += 1;\n@@ -343,0 +344,1 @@\n+        stk_args = align_up(stk_args, 2);\n@@ -351,0 +353,1 @@\n+        stk_args = align_up(stk_args, 2);\n@@ -352,1 +355,1 @@\n-        stk_args += 2;\n+        stk_args += 1;\n@@ -360,0 +363,1 @@\n+        stk_args = align_up(stk_args, 2);\n@@ -370,1 +374,1 @@\n-  return align_up(stk_args, 2);\n+  return stk_args;\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -147,2 +147,4 @@\n-  \/\/ Ampere CPUs: Ampere-1 and Ampere-1A\n-  if (_cpu == CPU_AMPERE && ((_model == CPU_MODEL_AMPERE_1) || (_model == CPU_MODEL_AMPERE_1A))) {\n+  \/\/ Ampere CPUs\n+  if (_cpu == CPU_AMPERE && ((_model == CPU_MODEL_AMPERE_1)  ||\n+                             (_model == CPU_MODEL_AMPERE_1A) ||\n+                             (_model == CPU_MODEL_AMPERE_1B))) {\n@@ -152,0 +154,6 @@\n+    if (FLAG_IS_DEFAULT(OnSpinWaitInst)) {\n+      FLAG_SET_DEFAULT(OnSpinWaitInst, \"isb\");\n+    }\n+    if (FLAG_IS_DEFAULT(OnSpinWaitInstCount)) {\n+      FLAG_SET_DEFAULT(OnSpinWaitInstCount, 2);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -113,1 +113,2 @@\n-    CPU_MODEL_AMPERE_1A = 0xac4  \/* CPU implementer is CPU_AMPERE *\/\n+    CPU_MODEL_AMPERE_1A = 0xac4, \/* CPU implementer is CPU_AMPERE *\/\n+    CPU_MODEL_AMPERE_1B = 0xac5  \/* AMPERE_1B core Implements ARMv8.7 with CSSC, MTE, SM3\/SM4 extensions *\/\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -447,1 +447,0 @@\n-  if (slot & 1) slot++;\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -459,0 +459,3 @@\n+  if (ce->compilation()->bailed_out()) {\n+    return; \/\/ CodeCache is full\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_CodeStubs_ppc.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2065,1 +2065,4 @@\n-  if (base == NULL) return 0; \/\/ CodeBuffer::expand failed\n+  if (base == nullptr) {\n+    ciEnv::current()->record_failure(\"CodeCache is full\");\n+    return 0;  \/\/ CodeBuffer::expand failed\n+  }\n@@ -2082,1 +2085,4 @@\n-  if (base == NULL) return 0; \/\/ CodeBuffer::expand failed\n+  if (base == nullptr) {\n+    ciEnv::current()->record_failure(\"CodeCache is full\");\n+    return 0;  \/\/ CodeBuffer::expand failed\n+  }\n@@ -2801,0 +2807,1 @@\n+    RelocationHolder r; \/\/ Initializes type to none.\n@@ -2803,1 +2810,1 @@\n-      AddressLiteral a = __ allocate_oop_address((jobject)val);\n+      AddressLiteral a = __ constant_oop_address((jobject)val);\n@@ -2805,1 +2812,1 @@\n-      __ relocate(a.rspec());\n+      r = a.rspec();\n@@ -2807,0 +2814,1 @@\n+      \/\/ Notify OOP recorder (don't need the relocation)\n@@ -2809,1 +2817,0 @@\n-      __ relocate(a.rspec());\n@@ -2819,0 +2826,1 @@\n+    __ relocate(r); \/\/ If set above.\n@@ -2832,0 +2840,1 @@\n+      RelocationHolder r; \/\/ Initializes type to none.\n@@ -2834,1 +2843,1 @@\n-        AddressLiteral a = __ allocate_oop_address((jobject)val);\n+        AddressLiteral a = __ constant_oop_address((jobject)val);\n@@ -2836,1 +2845,1 @@\n-        __ relocate(a.rspec());\n+        r = a.rspec();\n@@ -2838,0 +2847,1 @@\n+        \/\/ Notify OOP recorder (don't need the relocation)\n@@ -2840,1 +2850,0 @@\n-        __ relocate(a.rspec());\n@@ -2850,0 +2859,1 @@\n+      __ relocate(r); \/\/ If set above.\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -737,1 +737,1 @@\n-  return align_up(stk, 2);\n+  return stk;\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -269,1 +269,1 @@\n-  uint stk_args = 0; \/\/ inc by 2 each time\n+  uint stk_args = 0;\n@@ -281,0 +281,1 @@\n+          stk_args = align_up(stk_args, 2);\n@@ -282,1 +283,1 @@\n-          stk_args += 2;\n+          stk_args += 1;\n@@ -298,0 +299,1 @@\n+          stk_args = align_up(stk_args, 2);\n@@ -306,0 +308,1 @@\n+          stk_args = align_up(stk_args, 2);\n@@ -307,1 +310,1 @@\n-          stk_args += 2;\n+          stk_args += 1;\n@@ -315,0 +318,1 @@\n+          stk_args = align_up(stk_args, 2);\n@@ -324,1 +328,1 @@\n-  return align_up(stk_args, 2);\n+  return stk_args;\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -758,1 +758,1 @@\n-  return align_up(stk, 2);\n+  return stk;\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -531,2 +531,1 @@\n-  \/\/ return value can be odd number of VMRegImpl stack slots make multiple of 2\n-  return align_up(stack, 2);\n+  return stack;\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -500,1 +500,1 @@\n-  uint stk_args = 0; \/\/ inc by 2 each time\n+  uint stk_args = 0;\n@@ -512,0 +512,1 @@\n+        stk_args = align_up(stk_args, 2);\n@@ -513,1 +514,1 @@\n-        stk_args += 2;\n+        stk_args += 1;\n@@ -530,0 +531,1 @@\n+        stk_args = align_up(stk_args, 2);\n@@ -538,0 +540,1 @@\n+        stk_args = align_up(stk_args, 2);\n@@ -539,1 +542,1 @@\n-        stk_args += 2;\n+        stk_args += 1;\n@@ -547,0 +550,1 @@\n+        stk_args = align_up(stk_args, 2);\n@@ -557,1 +561,1 @@\n-  return align_up(stk_args, 2);\n+  return stk_args;\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -480,1 +480,1 @@\n-  struct stat64 st;\n+  struct stat st;\n@@ -487,1 +487,1 @@\n-  RESTARTABLE(::stat64(fn, &st), ret);\n+  RESTARTABLE(::stat(fn, &st), ret);\n@@ -507,2 +507,2 @@\n-  struct stat64 st;\n-  ret = stat64(AixAttachListener::path(), &st);\n+  struct stat st;\n+  ret = stat(AixAttachListener::path(), &st);\n@@ -547,1 +547,1 @@\n-  struct stat64 st;\n+  struct stat st;\n@@ -549,1 +549,1 @@\n-  RESTARTABLE(::stat64(fn, &st), ret);\n+  RESTARTABLE(::stat(fn, &st), ret);\n@@ -554,1 +554,1 @@\n-    RESTARTABLE(::stat64(fn, &st), ret);\n+    RESTARTABLE(::stat(fn, &st), ret);\n","filename":"src\/hotspot\/os\/aix\/attachListener_aix.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -116,0 +116,4 @@\n+#ifndef _LARGE_FILES\n+#error Hotspot on AIX must be compiled with -D_LARGE_FILES\n+#endif\n+\n@@ -1105,1 +1109,1 @@\n-void *os::dll_load(const char *filename, char *ebuf, int ebuflen) {\n+static void* dll_load_library(const char *filename, char *ebuf, int ebuflen) {\n@@ -1108,1 +1112,0 @@\n-\n@@ -1154,0 +1157,20 @@\n+\/\/ Load library named <filename>\n+\/\/ If filename matches <name>.so, and loading fails, repeat with <name>.a.\n+void *os::dll_load(const char *filename, char *ebuf, int ebuflen) {\n+  void* result = nullptr;\n+  char* const file_path = strdup(filename);\n+  char* const pointer_to_dot = strrchr(file_path, '.');\n+  const char old_extension[] = \".so\";\n+  const char new_extension[] = \".a\";\n+  STATIC_ASSERT(sizeof(old_extension) >= sizeof(new_extension));\n+  \/\/ First try to load the existing file.\n+  result = dll_load_library(filename, ebuf, ebuflen);\n+  \/\/ If the load fails,we try to reload by changing the extension to .a for .so files only.\n+  \/\/ Shared object in .so format dont have braces, hence they get removed for archives with members.\n+  if (result == nullptr && pointer_to_dot != nullptr && strcmp(pointer_to_dot, old_extension) == 0) {\n+    snprintf(pointer_to_dot, sizeof(old_extension), \"%s\", new_extension);\n+    result = dll_load_library(file_path, ebuf, ebuflen);\n+  }\n+  FREE_C_HEAP_ARRAY(char, file_path);\n+  return result;\n+}\n@@ -2498,1 +2521,1 @@\n-  int fd = ::open64(path, oflag_with_o_cloexec, mode);\n+  int fd = ::open(path, oflag_with_o_cloexec, mode);\n@@ -2501,1 +2524,1 @@\n-    fd = ::open64(path, oflag, mode);\n+    fd = ::open(path, oflag, mode);\n@@ -2509,2 +2532,2 @@\n-    struct stat64 buf64;\n-    int ret = ::fstat64(fd, &buf64);\n+    struct stat buf64;\n+    int ret = ::fstat(fd, &buf64);\n@@ -2564,1 +2587,1 @@\n-  return ::open64(path, oflags, S_IREAD | S_IWRITE);\n+  return ::open(path, oflags, S_IREAD | S_IWRITE);\n@@ -2569,1 +2592,1 @@\n-  return (jlong)::lseek64(fd, (off64_t)0, SEEK_CUR);\n+  return (jlong)::lseek(fd, (off_t)0, SEEK_CUR);\n@@ -2574,1 +2597,1 @@\n-  return (jlong)::lseek64(fd, (off64_t)offset, SEEK_SET);\n+  return (jlong)::lseek(fd, (off_t)offset, SEEK_SET);\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":32,"deletions":9,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+  #include <sys\/times.h>\n@@ -50,1 +51,1 @@\n-  uint64_t _total_cpu_nanos;\n+  uint64_t _jvm_real;\n@@ -52,2 +53,2 @@\n-  uint64_t _jvm_user_nanos;\n-  uint64_t _jvm_system_nanos;\n+  uint64_t _jvm_user;\n+  uint64_t _jvm_system;\n@@ -89,1 +90,1 @@\n-  _total_cpu_nanos= 0;\n+  _jvm_real = 0;\n@@ -92,2 +93,2 @@\n-  _jvm_user_nanos = 0;\n-  _jvm_system_nanos = 0;\n+  _jvm_user = 0;\n+  _jvm_system = 0;\n@@ -155,5 +156,4 @@\n-  mach_port_t task = mach_task_self();\n-  mach_msg_type_number_t task_info_count = TASK_INFO_MAX;\n-  task_info_data_t task_info_data;\n-  kern_return_t kr = task_info(task, TASK_ABSOLUTETIME_INFO, (task_info_t)task_info_data, &task_info_count);\n-  if (kr != KERN_SUCCESS) {\n+\n+  struct tms buf;\n+  clock_t jvm_real = times(&buf);\n+  if (jvm_real == (clock_t) (-1)) {\n@@ -162,1 +162,0 @@\n-  task_absolutetime_info_t absolutetime_info = (task_absolutetime_info_t)task_info_data;\n@@ -165,7 +164,2 @@\n-  uint64_t jvm_user_nanos = absolutetime_info->total_user;\n-  uint64_t jvm_system_nanos = absolutetime_info->total_system;\n-\n-  uint64_t total_cpu_nanos;\n-  if(!now_in_nanos(&total_cpu_nanos)) {\n-    return OS_ERR;\n-  }\n+  uint64_t jvm_user = buf.tms_utime;\n+  uint64_t jvm_system = buf.tms_stime;\n@@ -173,2 +167,2 @@\n-  if (_total_cpu_nanos == 0 || active_processor_count != _active_processor_count) {\n-    \/\/ First call or change in active processor count\n+  if (active_processor_count != _active_processor_count) {\n+    \/\/ Change in active processor count\n@@ -177,2 +171,2 @@\n-    uint64_t delta_nanos = active_processor_count * (total_cpu_nanos - _total_cpu_nanos);\n-    if (delta_nanos == 0) {\n+    uint64_t delta = active_processor_count * (jvm_real - _jvm_real);\n+    if (delta == 0) {\n@@ -183,2 +177,2 @@\n-    *pjvmUserLoad = normalize((double)(jvm_user_nanos - _jvm_user_nanos)\/delta_nanos);\n-    *pjvmKernelLoad = normalize((double)(jvm_system_nanos - _jvm_system_nanos)\/delta_nanos);\n+    *pjvmUserLoad = normalize((double)(jvm_user - _jvm_user) \/ delta);\n+    *pjvmKernelLoad = normalize((double)(jvm_system - _jvm_system) \/ delta);\n@@ -188,3 +182,3 @@\n-  _total_cpu_nanos = total_cpu_nanos;\n-  _jvm_user_nanos = jvm_user_nanos;\n-  _jvm_system_nanos = jvm_system_nanos;\n+  _jvm_real = jvm_real;\n+  _jvm_user = jvm_user;\n+  _jvm_system = jvm_system;\n","filename":"src\/hotspot\/os\/bsd\/os_perf_bsd.cpp","additions":23,"deletions":29,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -86,0 +86,2 @@\n+# include <ctype.h>\n+# include <stdlib.h>\n@@ -312,0 +314,23 @@\n+void os::Linux::kernel_version(long* major, long* minor) {\n+  *major = -1;\n+  *minor = -1;\n+\n+  struct utsname buffer;\n+  int ret = uname(&buffer);\n+  if (ret != 0) {\n+    log_warning(os)(\"uname(2) failed to get kernel version: %s\", os::errno_name(ret));\n+    return;\n+  }\n+\n+  char* walker = buffer.release;\n+  long* set_v = major;\n+  while (*minor == -1 && walker != nullptr) {\n+    if (isdigit(walker[0])) {\n+      *set_v = strtol(walker, &walker, 10);\n+      set_v = minor;\n+    } else {\n+      ++walker;\n+    }\n+  }\n+}\n+\n@@ -2148,0 +2173,2 @@\n+  _print_ascii_file_h(\"\/proc\/sys\/vm\/swappiness (control to define how aggressively the kernel swaps out anonymous memory)\",\n+                      \"\/proc\/sys\/vm\/swappiness\", st);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -112,0 +112,2 @@\n+  static void kernel_version(long* major, long* minor);\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/os.hpp\"\n+#include \"os_linux.hpp\"\n@@ -73,0 +73,12 @@\n+#if defined(RISCV)\n+\/\/ RISCV port was introduced in kernel 4.4.\n+\/\/ 4.4 also made membar private expedited mandatory.\n+\/\/ But RISCV actually don't support it until 6.9.\n+  long major, minor;\n+  os::Linux::kernel_version(&major, &minor);\n+  if (!(major > 6 || (major == 6 && minor >= 9))) {\n+    log_info(os)(\"Linux kernel %ld.%ld does not support MEMBARRIER PRIVATE_EXPEDITED on RISC-V.\",\n+                 major, minor);\n+    return false;\n+  }\n+#endif\n","filename":"src\/hotspot\/os\/linux\/systemMemoryBarrier_linux.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -756,1 +756,1 @@\n-  return (jlong) AIX_ONLY(::lseek64) NOT_AIX(::lseek)(fd, offset, whence);\n+  return (jlong) ::lseek(fd, offset, whence);\n@@ -760,1 +760,1 @@\n-   return AIX_ONLY(::ftruncate64) NOT_AIX(::ftruncate)(fd, length);\n+   return ::ftruncate(fd, length);\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -212,1 +212,1 @@\n-    assert(allocates2(pc),     \"relocation addr must be in this section\");\n+    assert(allocates2(pc),     \"relocation addr \" INTPTR_FORMAT \" must be in this section from \" INTPTR_FORMAT \" to \" INTPTR_FORMAT, p2i(pc), p2i(_start), p2i(_limit));\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  intptr_t out_preserve = SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs);\n+  intptr_t out_preserve = align_up(SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs), 2);\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1989,2 +1989,2 @@\n-  switch (state) {\n-    case NEW :\n+  switch (state & ~SUSPENDED) {\n+    case NEW:\n@@ -1993,6 +1993,7 @@\n-    case STARTED :\n-    case RUNNABLE :\n-    case RUNNABLE_SUSPENDED :\n-    case RUNNING :\n-    case PARKING :\n-    case YIELDING :\n+    case STARTED:\n+    case RUNNING:\n+    case PARKING:\n+    case TIMED_PARKING:\n+    case UNPARKED:\n+    case YIELDING:\n+    case YIELDED:\n@@ -2001,3 +2002,2 @@\n-    case PARKED :\n-    case PARKED_SUSPENDED :\n-    case PINNED :\n+    case PARKED:\n+    case PINNED:\n@@ -2006,1 +2006,5 @@\n-    case TERMINATED :\n+    case TIMED_PARKED:\n+    case TIMED_PINNED:\n+      status = JavaThreadStatus::PARKED_TIMED;\n+      break;\n+    case TERMINATED:\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -522,14 +522,16 @@\n-    NEW          = 0,\n-    STARTED      = 1,\n-    RUNNABLE     = 2,\n-    RUNNING      = 3,\n-    PARKING      = 4,\n-    PARKED       = 5,\n-    PINNED       = 6,\n-    YIELDING     = 7,\n-    TERMINATED   = 99,\n-\n-    \/\/ can be suspended from scheduling when unmounted\n-    SUSPENDED    = 1 << 8,\n-    RUNNABLE_SUSPENDED = (RUNNABLE | SUSPENDED),\n-    PARKED_SUSPENDED   = (PARKED | SUSPENDED)\n+    NEW           = 0,\n+    STARTED       = 1,\n+    RUNNING       = 2,\n+    PARKING       = 3,\n+    PARKED        = 4,\n+    PINNED        = 5,\n+    TIMED_PARKING = 6,\n+    TIMED_PARKED  = 7,\n+    TIMED_PINNED  = 8,\n+    UNPARKED      = 9,\n+    YIELDING      = 10,\n+    YIELDED       = 11,\n+    TERMINATED    = 99,\n+\n+    \/\/ additional state bits\n+    SUSPENDED    = 1 << 8,   \/\/ suspended when unmounted\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -3062,1 +3062,1 @@\n-      intptr_t out_preserve = SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs);\n+      SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+      size_t pretouch_page_size = UseLargePages ? page_size : os::vm_page_size();\n@@ -124,1 +125,1 @@\n-                             page_size, pretouch_workers);\n+                             pretouch_page_size, pretouch_workers);\n@@ -127,1 +128,1 @@\n-                             page_size, pretouch_workers);\n+                             pretouch_page_size, pretouch_workers);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -75,4 +75,3 @@\n-bool AgeTable::is_clear() {\n-  size_t total = 0;\n-  for (size_t* p = sizes; p < sizes + table_size; ++p) {\n-    total += *p;\n+bool AgeTable::is_clear() const {\n+  for (const size_t* p = sizes; p < sizes + table_size; ++p) {\n+    if (*p != 0) return false;\n@@ -80,1 +79,1 @@\n-  return total == 0;\n+  return true;\n","filename":"src\/hotspot\/share\/gc\/shared\/ageTable.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+\n+#ifndef PRODUCT\n@@ -57,1 +59,2 @@\n-  bool is_clear() PRODUCT_RETURN0;\n+  bool is_clear() const;\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/gc\/shared\/ageTable.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -389,0 +389,6 @@\n+        \"array_partition_stub\",\n+        { { TypeFunc::Parms, ShenandoahStore }, { TypeFunc::Parms+4, ShenandoahStore },   { -1, ShenandoahNone },\n+          { -1, ShenandoahNone },                { -1, ShenandoahNone },                  { -1, ShenandoahNone } },\n+        \"arraysort_stub\",\n+        { { TypeFunc::Parms, ShenandoahStore },  { -1, ShenandoahNone },                  { -1, ShenandoahNone },\n+          { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },\n@@ -1732,0 +1738,15 @@\n+bool ShenandoahBarrierC2Support::merge_point_safe(Node* region) {\n+  for (DUIterator_Fast imax, i = region->fast_outs(imax); i < imax; i++) {\n+    Node* n = region->fast_out(i);\n+    if (n->is_LoadStore()) {\n+      \/\/ Splitting a LoadStore node through phi, causes it to lose its SCMemProj: the split if code doesn't have support\n+      \/\/ for a LoadStore at the region the if is split through because that's not expected to happen (LoadStore nodes\n+      \/\/ should be between barrier nodes). It does however happen with Shenandoah though because barriers can get\n+      \/\/ expanded around a LoadStore node.\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+\n@@ -1736,1 +1757,1 @@\n-    if (phase->can_split_if(n_ctrl)) {\n+    if (phase->can_split_if(n_ctrl) && merge_point_safe(n_ctrl)) {\n@@ -2156,1 +2177,1 @@\n-              assert(c->is_Loop() && j == LoopNode::LoopBackControl || _phase->C->has_irreducible_loop() || has_never_branch(_phase->C->root()), \"\");\n+              assert((c->is_Loop() && j == LoopNode::LoopBackControl) || _phase->C->has_irreducible_loop() || has_never_branch(_phase->C->root()), \"\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+  static bool merge_point_safe(Node* region);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -33,0 +33,1 @@\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n@@ -43,1 +44,1 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  auto heap = ShenandoahGenerationalHeap::heap();\n@@ -151,2 +152,2 @@\n-  heap->reserve_promotable_humongous_regions(humongous_regions_promoted);\n-  heap->reserve_promotable_regular_regions(regular_regions_promoted_in_place);\n+  heap->old_generation()->set_expected_humongous_region_promotions(humongous_regions_promoted);\n+  heap->old_generation()->set_expected_regular_region_promotions(regular_regions_promoted_in_place);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGenerationalHeuristics.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -82,1 +82,1 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  auto heap = ShenandoahGenerationalHeap::heap();\n@@ -89,1 +89,3 @@\n-  size_t max_young_cset = (size_t) (heap->get_young_evac_reserve() \/ ShenandoahEvacWaste);\n+  size_t young_evac_reserve = heap->young_generation()->get_evacuation_reserve();\n+  size_t old_evac_reserve = heap->old_generation()->get_evacuation_reserve();\n+  size_t max_young_cset = (size_t) (young_evac_reserve \/ ShenandoahEvacWaste);\n@@ -91,1 +93,1 @@\n-  size_t max_old_cset = (size_t) (heap->get_old_evac_reserve() \/ ShenandoahOldEvacWaste);\n+  size_t max_old_cset = (size_t) (old_evac_reserve \/ ShenandoahOldEvacWaste);\n@@ -171,2 +173,2 @@\n-    heap->set_young_evac_reserve(heap->get_young_evac_reserve() - regions_transferred_to_old * region_size_bytes);\n-    heap->set_old_evac_reserve(heap->get_old_evac_reserve() + regions_transferred_to_old * region_size_bytes);\n+    heap->young_generation()->set_evacuation_reserve(young_evac_reserve - regions_transferred_to_old * region_size_bytes);\n+    heap->old_generation()->set_evacuation_reserve(old_evac_reserve + regions_transferred_to_old * region_size_bytes);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGlobalHeuristics.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -157,0 +157,3 @@\n+\n+  \/\/ This indicates whether or not the current cycle should unload classes.\n+  \/\/ It does NOT indicate that a cycle should be started.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n-#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n-#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -35,3 +34,0 @@\n-#define BYTES_FORMAT    SIZE_FORMAT \"%s\"\n-#define FORMAT_BYTES(b) byte_size_in_proper_unit(b), proper_unit_for_byte_size(b)\n-\n@@ -75,1 +71,1 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  auto heap = ShenandoahGenerationalHeap::heap();\n@@ -91,1 +87,2 @@\n-  size_t old_evacuation_budget = (size_t) ((double) heap->get_old_evac_reserve() \/ ShenandoahOldEvacWaste);\n+  const size_t old_evacuation_reserve = heap->old_generation()->get_evacuation_reserve();\n+  const size_t old_evacuation_budget = (size_t) ((double) old_evacuation_reserve \/ ShenandoahOldEvacWaste);\n@@ -224,2 +221,2 @@\n-                   \"Old evacuation budget: \" BYTES_FORMAT \", Remaining evacuation budget: \" BYTES_FORMAT\n-                   \", Lost capacity: \" BYTES_FORMAT\n+                   \"Old evacuation budget: \" PROPERFMT \", Remaining evacuation budget: \" PROPERFMT\n+                   \", Lost capacity: \" PROPERFMT\n@@ -227,3 +224,3 @@\n-                   FORMAT_BYTES(heap->get_old_evac_reserve()),\n-                   FORMAT_BYTES(remaining_old_evacuation_budget),\n-                   FORMAT_BYTES(lost_evacuation_capacity),\n+                   PROPERFMTARGS(old_evacuation_reserve),\n+                   PROPERFMTARGS(remaining_old_evacuation_budget),\n+                   PROPERFMTARGS(lost_evacuation_capacity),\n@@ -312,0 +309,1 @@\n+  const size_t num_regions = heap->num_regions();\n@@ -314,1 +312,0 @@\n-  size_t num_regions = heap->num_regions();\n@@ -426,2 +423,2 @@\n-    size_t first_unselected_old_region = candidates[_last_old_collection_candidate]._region->index();\n-    size_t last_unselected_old_region = candidates[cand_idx - 1]._region->index();\n+    const size_t first_unselected_old_region = candidates[_last_old_collection_candidate]._region->index();\n+    const size_t last_unselected_old_region = candidates[cand_idx - 1]._region->index();\n@@ -433,1 +430,1 @@\n-    size_t bound_on_additional_regions = cand_idx \/ MAX_FRACTION_OF_HUMONGOUS_DEFRAG_REGIONS;\n+    const size_t bound_on_additional_regions = cand_idx \/ MAX_FRACTION_OF_HUMONGOUS_DEFRAG_REGIONS;\n@@ -441,2 +438,2 @@\n-      size_t region_garbage = candidates[_last_old_collection_candidate]._region->garbage();\n-      size_t region_free = r->free();\n+      const size_t region_garbage = candidates[_last_old_collection_candidate]._region->garbage();\n+      const size_t region_free = r->free();\n@@ -456,3 +453,3 @@\n-  size_t collectable_garbage = immediate_garbage + candidates_garbage;\n-  size_t old_candidates = _last_old_collection_candidate;\n-  size_t mixed_evac_live = old_candidates * region_size_bytes - (candidates_garbage + unfragmented);\n+  const size_t collectable_garbage = immediate_garbage + candidates_garbage;\n+  const size_t old_candidates = _last_old_collection_candidate;\n+  const size_t mixed_evac_live = old_candidates * region_size_bytes - (candidates_garbage + unfragmented);\n@@ -559,3 +556,3 @@\n-    size_t old_gen_capacity = _old_generation->max_capacity();\n-    size_t heap_capacity = heap->capacity();\n-    double percent = percent_of(old_gen_capacity, heap_capacity);\n+    const size_t old_gen_capacity = _old_generation->max_capacity();\n+    const size_t heap_capacity = heap->capacity();\n+    const double percent = percent_of(old_gen_capacity, heap_capacity);\n@@ -568,2 +565,2 @@\n-    size_t used = _old_generation->used();\n-    size_t used_regions_size = _old_generation->used_regions_size();\n+    const size_t used = _old_generation->used();\n+    const size_t used_regions_size = _old_generation->used_regions_size();\n@@ -572,1 +569,1 @@\n-    size_t used_regions = _old_generation->used_regions();\n+    const size_t used_regions = _old_generation->used_regions();\n@@ -578,2 +575,2 @@\n-    size_t span_of_old_regions = (last_old_region >= first_old_region)? last_old_region + 1 - first_old_region: 0;\n-    size_t fragmented_free = used_regions_size - used;\n+    const size_t span_of_old_regions = (last_old_region >= first_old_region)? last_old_region + 1 - first_old_region: 0;\n+    const size_t fragmented_free = used_regions_size - used;\n@@ -592,3 +589,4 @@\n-    size_t current_usage = _old_generation->used();\n-    size_t trigger_threshold = _old_generation->usage_trigger_threshold();\n-    size_t heap_size = heap->capacity();\n+    const size_t current_usage = _old_generation->used();\n+    const size_t trigger_threshold = _old_generation->usage_trigger_threshold();\n+    const size_t heap_size = heap->capacity();\n+    const size_t ignore_threshold = (ShenandoahIgnoreOldGrowthBelowPercentage * heap_size) \/ 100;\n@@ -596,1 +594,0 @@\n-    size_t ignore_threshold = (ShenandoahIgnoreOldGrowthBelowPercentage * heap_size) \/ 100;\n@@ -607,2 +604,2 @@\n-      size_t live_at_previous_old = _old_generation->get_live_bytes_after_last_mark();\n-      double percent_growth = percent_of(current_usage - live_at_previous_old, live_at_previous_old);\n+      const size_t live_at_previous_old = _old_generation->get_live_bytes_after_last_mark();\n+      const double percent_growth = percent_of(current_usage - live_at_previous_old, live_at_previous_old);\n@@ -658,4 +655,0 @@\n-\n-\n-#undef BYTES_FORMAT\n-#undef FORMAT_BYTES\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":32,"deletions":39,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -32,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n@@ -81,1 +82,1 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  auto heap = ShenandoahGenerationalHeap::heap();\n@@ -90,1 +91,1 @@\n-  size_t max_cset = (size_t) (heap->get_young_evac_reserve() \/ ShenandoahEvacWaste);\n+  size_t max_cset = (size_t) (heap->young_generation()->get_evacuation_reserve() \/ ShenandoahEvacWaste);\n@@ -126,1 +127,1 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  auto heap = ShenandoahGenerationalHeap::heap();\n@@ -130,1 +131,1 @@\n-  if (ShenandoahMinimumOldMarkTimeMs > 0 && ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress()) {\n+  if (ShenandoahMinimumOldMarkTimeMs > 0 && heap->is_concurrent_old_mark_in_progress()) {\n@@ -148,1 +149,1 @@\n-  size_t promo_potential = heap->get_promotion_potential();\n+  size_t promo_potential = heap->old_generation()->get_promotion_potential();\n@@ -178,1 +179,1 @@\n-  size_t capacity = _space_info->soft_max_capacity();\n+  size_t capacity = _space_info->max_capacity();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -186,0 +186,1 @@\n+#ifndef PRODUCT\n@@ -215,0 +216,1 @@\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -181,0 +181,1 @@\n+#ifndef PRODUCT\n@@ -184,0 +185,1 @@\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,0 +126,10 @@\n+  \/\/ Disable support for dynamic number of GC threads. We do not let the runtime\n+  \/\/ heuristics to misjudge how many threads we need during the heavy concurrent phase\n+  \/\/ or a GC pause.\n+  if (UseDynamicNumberOfGCThreads) {\n+    if (FLAG_IS_CMDLINE(UseDynamicNumberOfGCThreads)) {\n+      warning(\"Shenandoah does not support UseDynamicNumberOfGCThreads, disabling\");\n+    }\n+    FLAG_SET_DEFAULT(UseDynamicNumberOfGCThreads, false);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -405,1 +405,1 @@\n-        assert(obj != fwd || _heap->cancelled_gc(), \"must be forwarded\");\n+        shenandoah_assert_forwarded_except(elem_ptr, obj, _heap->cancelled_gc());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        assert(obj != fwd || _heap->cancelled_gc(), \"must be forwarded\");\n+        shenandoah_assert_forwarded_except(p, obj, _heap->cancelled_gc());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSetClone.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,4 +59,0 @@\n-  CardValue* guard_card = &_byte_map[num_cards];\n-  assert(is_aligned(guard_card, _page_size), \"must be on its own OS page\");\n-  _guard_region = MemRegion((HeapWord*)guard_card, _page_size);\n-\n@@ -89,4 +85,0 @@\n-  \/\/ If we choose to modify the mutator write barrier so that we can swap _read_byte_map_base and\n-  \/\/ _write_byte_map_base pointers, we may also have to figure out certain details about how the\n-  \/\/ _guard_region is implemented so that we can replicate the read and write versions of this region.\n-  \/\/\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardTable.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-  _mixed_gcs(0),\n@@ -37,3 +36,0 @@\n-  _abbreviated_degenerated_gcs(0),\n-  _success_old_gcs(0),\n-  _interrupted_old_gcs(0),\n@@ -41,0 +37,1 @@\n+  _abbreviated_degenerated_gcs(0),\n@@ -42,1 +39,0 @@\n-  _consecutive_young_gcs(0),\n@@ -44,0 +40,4 @@\n+  _consecutive_young_gcs(0),\n+  _mixed_gcs(0),\n+  _success_old_gcs(0),\n+  _interrupted_old_gcs(0),\n@@ -46,6 +46,1 @@\n-  _alloc_failure_full(0),\n-  _explicit_concurrent(0),\n-  _explicit_full(0),\n-  _implicit_concurrent(0),\n-  _implicit_full(0),\n-  _cycle_counter(0) {\n+  _alloc_failure_full(0) {\n@@ -53,1 +48,2 @@\n-  Copy::zero_to_bytes(_degen_points, sizeof(size_t) * ShenandoahGC::_DEGENERATED_LIMIT);\n+  Copy::zero_to_bytes(_degen_point_counts, sizeof(size_t) * ShenandoahGC::_DEGENERATED_LIMIT);\n+  Copy::zero_to_bytes(_collection_cause_counts, sizeof(size_t) * GCCause::_last_gc_cause);\n@@ -56,1 +52,0 @@\n-\n@@ -59,14 +54,3 @@\n-void ShenandoahCollectorPolicy::record_explicit_to_concurrent() {\n-  _explicit_concurrent++;\n-}\n-\n-void ShenandoahCollectorPolicy::record_explicit_to_full() {\n-  _explicit_full++;\n-}\n-\n-void ShenandoahCollectorPolicy::record_implicit_to_concurrent() {\n-  _implicit_concurrent++;\n-}\n-\n-void ShenandoahCollectorPolicy::record_implicit_to_full() {\n-  _implicit_full++;\n+void ShenandoahCollectorPolicy::record_collection_cause(GCCause::Cause cause) {\n+  assert(cause < GCCause::_last_gc_cause, \"Invalid GCCause\");\n+  _collection_cause_counts[cause]++;\n@@ -82,1 +66,1 @@\n-  _degen_points[point]++;\n+  _degen_point_counts[point]++;\n@@ -138,8 +122,0 @@\n-size_t ShenandoahCollectorPolicy::cycle_counter() const {\n-  return _cycle_counter;\n-}\n-\n-void ShenandoahCollectorPolicy::record_cycle_start() {\n-  _cycle_counter++;\n-}\n-\n@@ -154,0 +130,43 @@\n+bool is_explicit_gc(GCCause::Cause cause) {\n+  return GCCause::is_user_requested_gc(cause)\n+      || GCCause::is_serviceability_requested_gc(cause);\n+}\n+\n+bool is_implicit_gc(GCCause::Cause cause) {\n+  return cause != GCCause::_no_gc\n+      && cause != GCCause::_shenandoah_concurrent_gc\n+      && cause != GCCause::_allocation_failure\n+      && !is_explicit_gc(cause);\n+}\n+\n+#ifdef ASSERT\n+bool is_valid_request(GCCause::Cause cause) {\n+  return is_explicit_gc(cause)\n+      || cause == GCCause::_metadata_GC_clear_soft_refs\n+      || cause == GCCause::_codecache_GC_aggressive\n+      || cause == GCCause::_codecache_GC_threshold\n+      || cause == GCCause::_full_gc_alot\n+      || cause == GCCause::_wb_young_gc\n+      || cause == GCCause::_wb_full_gc\n+      || cause == GCCause::_wb_breakpoint\n+      || cause == GCCause::_scavenge_alot;\n+}\n+#endif\n+\n+bool ShenandoahCollectorPolicy::is_requested_gc(GCCause::Cause cause) {\n+  return is_explicit_gc(cause) || is_implicit_gc(cause);\n+}\n+\n+bool ShenandoahCollectorPolicy::should_run_full_gc(GCCause::Cause cause) {\n+  return is_explicit_gc(cause) ? !ExplicitGCInvokesConcurrent : !ShenandoahImplicitGCInvokesConcurrent;\n+}\n+\n+bool ShenandoahCollectorPolicy::should_handle_requested_gc(GCCause::Cause cause) {\n+  assert(is_valid_request(cause), \"only requested GCs here: %s\", GCCause::to_string(cause));\n+\n+  if (DisableExplicitGC) {\n+    return !is_explicit_gc(cause);\n+  }\n+  return true;\n+}\n+\n@@ -164,4 +183,26 @@\n-  out->print_cr(SIZE_FORMAT_W(5) \" Successful Concurrent GCs (%.2f%%)\",  _success_concurrent_gcs, percent_of(_success_concurrent_gcs, completed_gcs));\n-  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" invoked explicitly (%.2f%%)\",    _explicit_concurrent, percent_of(_explicit_concurrent, _success_concurrent_gcs));\n-  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" invoked implicitly (%.2f%%)\",    _implicit_concurrent, percent_of(_implicit_concurrent, _success_concurrent_gcs));\n-  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" abbreviated (%.2f%%)\",           _abbreviated_concurrent_gcs, percent_of(_abbreviated_concurrent_gcs, _success_concurrent_gcs));\n+\n+  size_t explicit_requests = 0;\n+  size_t implicit_requests = 0;\n+  for (int c = 0; c < GCCause::_last_gc_cause; c++) {\n+    size_t cause_count = _collection_cause_counts[c];\n+    if (cause_count > 0) {\n+      auto cause = (GCCause::Cause) c;\n+      if (is_explicit_gc(cause)) {\n+        explicit_requests += cause_count;\n+      } else if (is_implicit_gc(cause)) {\n+        implicit_requests += cause_count;\n+      }\n+      const char* desc = GCCause::to_string(cause);\n+      out->print_cr(\"  \" SIZE_FORMAT_W(5) \" caused by %s (%.2f%%)\", cause_count, desc, percent_of(cause_count, completed_gcs));\n+    }\n+  }\n+\n+  out->cr();\n+  out->print_cr(SIZE_FORMAT_W(5) \" Successful Concurrent GCs (%.2f%%)\", _success_concurrent_gcs, percent_of(_success_concurrent_gcs, completed_gcs));\n+  if (ExplicitGCInvokesConcurrent) {\n+    out->print_cr(\"  \" SIZE_FORMAT_W(5) \" invoked explicitly (%.2f%%)\", explicit_requests, percent_of(explicit_requests, _success_concurrent_gcs));\n+  }\n+  if (ShenandoahImplicitGCInvokesConcurrent) {\n+    out->print_cr(\"  \" SIZE_FORMAT_W(5) \" invoked implicitly (%.2f%%)\", implicit_requests, percent_of(implicit_requests, _success_concurrent_gcs));\n+  }\n+  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" abbreviated (%.2f%%)\",  _abbreviated_concurrent_gcs, percent_of(_abbreviated_concurrent_gcs, _success_concurrent_gcs));\n@@ -183,1 +224,1 @@\n-    if (_degen_points[c] > 0) {\n+    if (_degen_point_counts[c] > 0) {\n@@ -185,1 +226,1 @@\n-      out->print_cr(\"    \" SIZE_FORMAT_W(5) \" happened at %s\",         _degen_points[c], desc);\n+      out->print_cr(\"    \" SIZE_FORMAT_W(5) \" happened at %s\", _degen_point_counts[c], desc);\n@@ -190,3 +231,7 @@\n-  out->print_cr(SIZE_FORMAT_W(5) \" Full GCs (%.2f%%)\",                          _success_full_gcs, percent_of(_success_full_gcs, completed_gcs));\n-  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" invoked explicitly (%.2f%%)\",           _explicit_full, percent_of(_explicit_full, _success_full_gcs));\n-  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" invoked implicitly (%.2f%%)\",           _implicit_full, percent_of(_implicit_full, _success_full_gcs));\n+  out->print_cr(SIZE_FORMAT_W(5) \" Full GCs (%.2f%%)\", _success_full_gcs, percent_of(_success_full_gcs, completed_gcs));\n+  if (!ExplicitGCInvokesConcurrent) {\n+    out->print_cr(\"  \" SIZE_FORMAT_W(5) \" invoked explicitly (%.2f%%)\", explicit_requests, percent_of(explicit_requests, _success_concurrent_gcs));\n+  }\n+  if (!ShenandoahImplicitGCInvokesConcurrent) {\n+    out->print_cr(\"  \" SIZE_FORMAT_W(5) \" invoked implicitly (%.2f%%)\", implicit_requests, percent_of(implicit_requests, _success_concurrent_gcs));\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.cpp","additions":90,"deletions":45,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-  size_t _mixed_gcs;\n@@ -45,3 +44,0 @@\n-  size_t _abbreviated_degenerated_gcs;\n-  size_t _success_old_gcs;\n-  size_t _interrupted_old_gcs;\n@@ -49,0 +45,1 @@\n+  size_t _abbreviated_degenerated_gcs;\n@@ -51,1 +48,0 @@\n-  volatile size_t _consecutive_young_gcs;\n@@ -53,0 +49,4 @@\n+  volatile size_t _consecutive_young_gcs;\n+  size_t _mixed_gcs;\n+  size_t _success_old_gcs;\n+  size_t _interrupted_old_gcs;\n@@ -56,6 +56,2 @@\n-  size_t _explicit_concurrent;\n-  size_t _explicit_full;\n-  size_t _implicit_concurrent;\n-  size_t _implicit_full;\n-  size_t _cycle_counter;\n-  size_t _degen_points[ShenandoahGC::_DEGENERATED_LIMIT];\n+  size_t _collection_cause_counts[GCCause::_last_gc_cause];\n+  size_t _degen_point_counts[ShenandoahGC::_DEGENERATED_LIMIT];\n@@ -70,4 +66,0 @@\n-  \/\/ TODO: This is different from gc_end: that one encompasses one VM operation.\n-  \/\/ These two encompass the entire cycle.\n-  void record_cycle_start();\n-\n@@ -75,2 +67,0 @@\n-\n-  void record_success_concurrent(bool is_young, bool is_abbreviated);\n@@ -79,0 +69,7 @@\n+\n+  \/\/ A collection cycle may be \"abbreviated\" if Shenandoah finds a sufficient percentage\n+  \/\/ of regions that contain no live objects (ShenandoahImmediateThreshold). These cycles\n+  \/\/ end after final mark, skipping the evacuation and reference-updating phases. Such\n+  \/\/ cycles are very efficient and are worth tracking. Note that both degenerated and\n+  \/\/ concurrent cycles can be abbreviated.\n+  void record_success_concurrent(bool is_young, bool is_abbreviated);\n@@ -84,4 +81,1 @@\n-  void record_explicit_to_concurrent();\n-  void record_explicit_to_full();\n-  void record_implicit_to_concurrent();\n-  void record_implicit_to_full();\n+  void record_collection_cause(GCCause::Cause cause);\n@@ -94,2 +88,0 @@\n-  size_t cycle_counter() const;\n-\n@@ -102,4 +94,3 @@\n-  inline size_t consecutive_young_gc_count() const {\n-    return _consecutive_young_gcs;\n-  }\n-\n+  \/\/ If the heuristics find that the number of consecutive degenerated cycles is above\n+  \/\/ ShenandoahFullGCThreshold, then they will initiate a Full GC upon an allocation\n+  \/\/ failure.\n@@ -110,0 +101,8 @@\n+  static bool is_requested_gc(GCCause::Cause cause);\n+  static bool should_run_full_gc(GCCause::Cause cause);\n+  static bool should_handle_requested_gc(GCCause::Cause cause);\n+\n+  inline size_t consecutive_young_gc_count() const {\n+    return _consecutive_young_gcs;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.hpp","additions":26,"deletions":27,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -233,5 +234,2 @@\n-    bool success;\n-    size_t region_xfer;\n-    const char* region_destination;\n-    ShenandoahYoungGeneration* young_gen = heap->young_generation();\n-    ShenandoahGeneration* old_gen = heap->old_generation();\n+\n+    ShenandoahGenerationalHeap::TransferResult result;\n@@ -239,25 +237,5 @@\n-      ShenandoahHeapLocker locker(heap->lock());\n-\n-      size_t old_region_surplus = heap->get_old_region_surplus();\n-      size_t old_region_deficit = heap->get_old_region_deficit();\n-      if (old_region_surplus) {\n-        success = heap->generation_sizer()->transfer_to_young(old_region_surplus);\n-        region_destination = \"young\";\n-        region_xfer = old_region_surplus;\n-      } else if (old_region_deficit) {\n-        success = heap->generation_sizer()->transfer_to_old(old_region_deficit);\n-        region_destination = \"old\";\n-        region_xfer = old_region_deficit;\n-        if (!success) {\n-          ((ShenandoahOldHeuristics *) old_gen->heuristics())->trigger_cannot_expand();\n-        }\n-      } else {\n-        region_destination = \"none\";\n-        region_xfer = 0;\n-        success = true;\n-      }\n-      heap->set_old_region_surplus(0);\n-      heap->set_old_region_deficit(0);\n-      heap->set_young_evac_reserve(0);\n-      heap->set_old_evac_reserve(0);\n-      heap->set_promoted_reserve(0);\n+      ShenandoahGenerationalHeap* gen_heap = ShenandoahGenerationalHeap::heap();\n+      ShenandoahHeapLocker locker(gen_heap->lock());\n+\n+      result = gen_heap->balance_generations();\n+      gen_heap->reset_generation_reserves();\n@@ -266,8 +244,5 @@\n-    \/\/ Report outside the heap lock\n-    size_t young_available = young_gen->available();\n-    size_t old_available = old_gen->available();\n-    log_info(gc, ergo)(\"After cleanup, %s \" SIZE_FORMAT \" regions to %s to prepare for next gc, old available: \"\n-                       SIZE_FORMAT \"%s, young_available: \" SIZE_FORMAT \"%s\",\n-                       success? \"successfully transferred\": \"failed to transfer\", region_xfer, region_destination,\n-                       byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n-                       byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n+    LogTarget(Info, gc, ergo) lt;\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      result.print_on(\"Concurrent GC\", &ls);\n+    }\n@@ -768,3 +743,1 @@\n-      size_t humongous_regions_promoted = heap->get_promotable_humongous_regions();\n-      size_t regular_regions_promoted_in_place = heap->get_regular_regions_promoted_in_place();\n-      if (!heap->collection_set()->is_empty() || (humongous_regions_promoted + regular_regions_promoted_in_place > 0)) {\n+      if (!heap->collection_set()->is_empty() || heap->old_generation()->has_in_place_promotions()) {\n@@ -822,1 +795,1 @@\n-        LogTarget(Info, gc, ergo) lt;\n+        LogTarget(Debug, gc, ergo) lt;\n@@ -962,0 +935,1 @@\n+      shenandoah_assert_not_in_cset_except(p, resolved, _heap->cancelled_gc());\n@@ -963,3 +937,0 @@\n-      assert(_heap->cancelled_gc() ||\n-             _mark_context->is_marked(resolved) && !_heap->in_collection_set(resolved),\n-             \"Sanity\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+\n+  \/\/ Return true if this cycle found enough immediate garbage to skip evacuation\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-\n@@ -70,2 +69,1 @@\n-    _cm->mark_loop(GENERATION, worker_id, _terminator, rp,\n-                   true \/*cancellable*\/,\n+    _cm->mark_loop(worker_id, _terminator, rp, GENERATION, true \/*cancellable*\/,\n@@ -99,1 +97,1 @@\n-template<ShenandoahGenerationType GENERATION>\n+template <ShenandoahGenerationType GENERATION>\n@@ -133,2 +131,1 @@\n-    _cm->mark_loop(GENERATION, worker_id, _terminator, rp,\n-                   false \/*not cancellable*\/,\n+    _cm->mark_loop(worker_id, _terminator, rp, GENERATION, false \/*not cancellable*\/,\n@@ -145,1 +142,1 @@\n-template<ShenandoahGenerationType GENERATION>\n+template <ShenandoahGenerationType GENERATION>\n@@ -163,1 +160,1 @@\n-template<ShenandoahGenerationType GENERATION>\n+template <ShenandoahGenerationType GENERATION>\n@@ -177,1 +174,1 @@\n-template<ShenandoahGenerationType GENERATION>\n+template <ShenandoahGenerationType GENERATION>\n@@ -201,1 +198,1 @@\n-    case GLOBAL_GEN: {\n+    case GLOBAL: {\n@@ -203,2 +200,2 @@\n-      ShenandoahMarkConcurrentRootsTask<GLOBAL_GEN> task(task_queues(), nullptr, rp,\n-                                                         ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n+      ShenandoahMarkConcurrentRootsTask<GLOBAL> task(task_queues(), nullptr, rp,\n+                                                     ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n@@ -208,1 +205,1 @@\n-    case GLOBAL_NON_GEN: {\n+    case NON_GEN: {\n@@ -210,2 +207,2 @@\n-      ShenandoahMarkConcurrentRootsTask<GLOBAL_NON_GEN> task(task_queues(), nullptr, rp,\n-                                                         ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n+      ShenandoahMarkConcurrentRootsTask<NON_GEN> task(task_queues(), nullptr, rp,\n+                                                      ShenandoahPhaseTimings::conc_mark_roots, workers->active_workers());\n@@ -263,1 +260,1 @@\n-      case GLOBAL_GEN: {\n+      case GLOBAL: {\n@@ -268,1 +265,1 @@\n-        ShenandoahConcurrentMarkingTask<GLOBAL_GEN> task(this, &terminator);\n+        ShenandoahConcurrentMarkingTask<GLOBAL> task(this, &terminator);\n@@ -272,1 +269,1 @@\n-      case GLOBAL_NON_GEN: {\n+      case NON_GEN: {\n@@ -274,1 +271,1 @@\n-        ShenandoahConcurrentMarkingTask<GLOBAL_NON_GEN> task(this, &terminator);\n+        ShenandoahConcurrentMarkingTask<NON_GEN> task(this, &terminator);\n@@ -340,2 +337,2 @@\n-    case GLOBAL_GEN:{\n-      ShenandoahFinalMarkingTask<GLOBAL_GEN> task(this, &terminator, ShenandoahStringDedup::is_enabled());\n+    case GLOBAL:{\n+      ShenandoahFinalMarkingTask<GLOBAL> task(this, &terminator, ShenandoahStringDedup::is_enabled());\n@@ -345,2 +342,2 @@\n-    case GLOBAL_NON_GEN:{\n-      ShenandoahFinalMarkingTask<GLOBAL_NON_GEN> task(this, &terminator, ShenandoahStringDedup::is_enabled());\n+    case NON_GEN:{\n+      ShenandoahFinalMarkingTask<NON_GEN> task(this, &terminator, ShenandoahStringDedup::is_enabled());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":20,"deletions":23,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationType.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,1 +4,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -32,1 +31,0 @@\n-#include \"gc\/shenandoah\/shenandoahEvacTracker.hpp\"\n@@ -36,4 +34,0 @@\n-#include \"gc\/shenandoah\/shenandoahGlobalGeneration.hpp\"\n-#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n-#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n-#include \"gc\/shenandoah\/shenandoahPhaseTimings.hpp\"\n@@ -41,1 +35,0 @@\n-#include \"gc\/shenandoah\/shenandoahMark.inline.hpp\"\n@@ -43,3 +36,1 @@\n-#include \"gc\/shenandoah\/shenandoahOopClosures.inline.hpp\"\n-#include \"gc\/shenandoah\/shenandoahOldGC.hpp\"\n-#include \"gc\/shenandoah\/shenandoahRootProcessor.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahPacer.inline.hpp\"\n@@ -47,2 +38,0 @@\n-#include \"gc\/shenandoah\/shenandoahVMOperations.hpp\"\n-#include \"gc\/shenandoah\/shenandoahWorkerPolicy.hpp\"\n@@ -52,1 +41,0 @@\n-#include \"memory\/iterator.hpp\"\n@@ -55,2 +43,0 @@\n-#include \"memory\/universe.hpp\"\n-#include \"runtime\/atomic.hpp\"\n@@ -59,12 +45,3 @@\n-  ConcurrentGCThread(),\n-  _alloc_failure_waiters_lock(Mutex::safepoint - 2, \"ShenandoahAllocFailureGC_lock\", true),\n-  _gc_waiters_lock(Mutex::safepoint - 2, \"ShenandoahRequestedGC_lock\", true),\n-  _control_lock(Mutex::nosafepoint - 2, \"ShenandoahControlGC_lock\", true),\n-  _regulator_lock(Mutex::nosafepoint - 2, \"ShenandoahRegulatorGC_lock\", true),\n-  _periodic_task(this),\n-  _requested_gc_cause(GCCause::_no_gc),\n-  _requested_generation(select_global_generation()),\n-  _degen_point(ShenandoahGC::_degenerated_outside_cycle),\n-  _degen_generation(nullptr),\n-  _allocs_seen(0),\n-  _mode(none) {\n+  ShenandoahController(),\n+  _requested_gc_cause(GCCause::_no_cause_specified),\n+  _degen_point(ShenandoahGC::_degenerated_outside_cycle) {\n@@ -72,1 +49,0 @@\n-  reset_gc_id();\n@@ -74,18 +50,0 @@\n-  _periodic_task.enroll();\n-  if (ShenandoahPacing) {\n-    _periodic_pacer_notify_task.enroll();\n-  }\n-}\n-\n-ShenandoahControlThread::~ShenandoahControlThread() {\n-  \/\/ This is here so that super is called.\n-}\n-\n-void ShenandoahPeriodicTask::task() {\n-  _thread->handle_force_counters_update();\n-  _thread->handle_counters_update();\n-}\n-\n-void ShenandoahPeriodicPacerNotify::task() {\n-  assert(ShenandoahPacing, \"Should not be here otherwise\");\n-  ShenandoahHeap::heap()->pacer()->notify_waiters();\n@@ -98,1 +56,2 @@\n-  ShenandoahGenerationType generation = select_global_generation();\n+  const GCCause::Cause default_cause = GCCause::_shenandoah_concurrent_gc;\n+  int sleep = ShenandoahControlIntervalMin;\n@@ -101,1 +60,1 @@\n-  uint age_period = 0;\n+  double last_sleep_adjust_time = os::elapsedTime();\n@@ -110,6 +69,1 @@\n-\n-  \/\/ Heuristics are notified of allocation failures here and other outcomes\n-  \/\/ of the cycle. They're also used here to control whether the Nth consecutive\n-  \/\/ degenerated cycle should be 'promoted' to a full cycle. The decision to\n-  \/\/ trigger a cycle or not is evaluated on the regulator thread.\n-  ShenandoahHeuristics* global_heuristics = heap->global_generation()->heuristics();\n+  ShenandoahHeuristics* const heuristics = heap->heuristics();\n@@ -119,1 +73,2 @@\n-    const bool humongous_alloc_failure_pending = _humongous_alloc_failure_gc.is_set();\n+    const bool is_gc_requested = _gc_requested.is_set();\n+    const GCCause::Cause requested_gc_cause = _requested_gc_cause;\n@@ -121,7 +76,2 @@\n-    GCCause::Cause cause = Atomic::xchg(&_requested_gc_cause, GCCause::_no_gc);\n-\n-    const bool explicit_gc_requested = is_explicit_gc(cause);\n-    const bool implicit_gc_requested = is_implicit_gc(cause);\n-\n-    \/\/ This control loop iteration have seen this much allocations.\n-    const size_t allocs_seen = Atomic::xchg(&_allocs_seen, (size_t)0, memory_order_relaxed);\n+    \/\/ This control loop iteration has seen this much allocation.\n+    const size_t allocs_seen = reset_allocs_seen();\n@@ -130,1 +80,1 @@\n-    const bool soft_max_changed = check_soft_max_changed();\n+    const bool soft_max_changed = heap->check_soft_max_changed();\n@@ -133,1 +83,2 @@\n-    set_gc_mode(none);\n+    GCMode mode = none;\n+    GCCause::Cause cause = GCCause::_last_gc_cause;\n@@ -146,14 +97,1 @@\n-      if (degen_point == ShenandoahGC::_degenerated_outside_cycle) {\n-        _degen_generation = heap->mode()->is_generational() ?\n-                heap->young_generation() : heap->global_generation();\n-      } else {\n-        assert(_degen_generation != nullptr, \"Need to know which generation to resume\");\n-      }\n-\n-      ShenandoahHeuristics* heuristics = _degen_generation->heuristics();\n-      generation = _degen_generation->type();\n-      bool old_gen_evacuation_failed = heap->clear_old_evacuation_failure();\n-\n-      \/\/ Do not bother with degenerated cycle if old generation evacuation failed or if humongous allocation failed\n-      if (ShenandoahDegeneratedGC && heuristics->should_degenerate_cycle() &&\n-          !old_gen_evacuation_failed && !humongous_alloc_failure_pending) {\n+      if (ShenandoahDegeneratedGC && heuristics->should_degenerate_cycle()) {\n@@ -162,1 +100,1 @@\n-        set_gc_mode(stw_degenerated);\n+        mode = stw_degenerated;\n@@ -164,7 +102,0 @@\n-        \/\/ TODO: if humongous_alloc_failure_pending, there might be value in trying a \"compacting\" degen before\n-        \/\/ going all the way to full.  But it's a lot of work to implement this, and it may not provide value.\n-        \/\/ A compacting degen can move young regions around without doing full old-gen mark (relying upon the\n-        \/\/ remembered set scan), so it might be faster than a full gc.\n-        \/\/\n-        \/\/ Longer term, think about how to defragment humongous memory concurrently.\n-\n@@ -173,2 +104,1 @@\n-        generation = select_global_generation();\n-        set_gc_mode(stw_full);\n+        mode = stw_full;\n@@ -176,3 +106,4 @@\n-    } else if (explicit_gc_requested) {\n-      generation = select_global_generation();\n-      log_info(gc)(\"Trigger: Explicit GC request (%s)\", GCCause::to_string(cause));\n+    } else if (is_gc_requested) {\n+      cause = requested_gc_cause;\n+      log_info(gc)(\"Trigger: GC request (%s)\", GCCause::to_string(cause));\n+      heuristics->record_requested_gc();\n@@ -180,7 +111,2 @@\n-      global_heuristics->record_requested_gc();\n-\n-      if (ExplicitGCInvokesConcurrent) {\n-        policy->record_explicit_to_concurrent();\n-        set_gc_mode(default_mode);\n-        \/\/ Unload and clean up everything\n-        heap->set_unload_classes(global_heuristics->can_unload_classes());\n+      if (ShenandoahCollectorPolicy::should_run_full_gc(cause)) {\n+        mode = stw_full;\n@@ -188,13 +114,1 @@\n-        policy->record_explicit_to_full();\n-        set_gc_mode(stw_full);\n-      }\n-    } else if (implicit_gc_requested) {\n-      generation = select_global_generation();\n-      log_info(gc)(\"Trigger: Implicit GC request (%s)\", GCCause::to_string(cause));\n-\n-      global_heuristics->record_requested_gc();\n-\n-      if (ShenandoahImplicitGCInvokesConcurrent) {\n-        policy->record_implicit_to_concurrent();\n-        set_gc_mode(default_mode);\n-\n+        mode = default_mode;\n@@ -202,4 +116,1 @@\n-        heap->set_unload_classes(global_heuristics->can_unload_classes());\n-      } else {\n-        policy->record_implicit_to_full();\n-        set_gc_mode(stw_full);\n+        heap->set_unload_classes(heuristics->can_unload_classes());\n@@ -208,20 +119,5 @@\n-      \/\/ We should only be here if the regulator requested a cycle or if\n-      \/\/ there is an old generation mark in progress.\n-      if (cause == GCCause::_shenandoah_concurrent_gc) {\n-        if (_requested_generation == OLD && heap->doing_mixed_evacuations()) {\n-          \/\/ If a request to start an old cycle arrived while an old cycle was running, but _before_\n-          \/\/ it chose any regions for evacuation we don't want to start a new old cycle. Rather, we want\n-          \/\/ the heuristic to run a young collection so that we can evacuate some old regions.\n-          assert(!heap->is_concurrent_old_mark_in_progress(), \"Should not be running mixed collections and concurrent marking\");\n-          generation = YOUNG;\n-        } else {\n-          generation = _requested_generation;\n-        }\n-\n-        \/\/ preemption was requested or this is a regular cycle\n-        set_gc_mode(default_mode);\n-\n-        \/\/ Don't start a new old marking if there is one already in progress\n-        if (generation == OLD && heap->is_concurrent_old_mark_in_progress()) {\n-          set_gc_mode(servicing_old);\n-        }\n+      \/\/ Potential normal cycle: ask heuristics if it wants to act\n+      if (heuristics->should_start_gc()) {\n+        mode = default_mode;\n+        cause = default_cause;\n+      }\n@@ -229,11 +125,3 @@\n-        if (generation == select_global_generation()) {\n-          heap->set_unload_classes(global_heuristics->should_unload_classes());\n-        } else {\n-          heap->set_unload_classes(false);\n-        }\n-      } else if (heap->is_concurrent_old_mark_in_progress() || heap->is_prepare_for_old_mark_in_progress()) {\n-        \/\/ Nobody asked us to do anything, but we have an old-generation mark or old-generation preparation for\n-        \/\/ mixed evacuation in progress, so resume working on that.\n-        log_info(gc)(\"Resume old GC: marking is%s in progress, preparing is%s in progress\",\n-                     heap->is_concurrent_old_mark_in_progress() ? \"\" : \" NOT\",\n-                     heap->is_prepare_for_old_mark_in_progress() ? \"\" : \" NOT\");\n+      \/\/ Ask policy if this cycle wants to process references or unload classes\n+      heap->set_unload_classes(heuristics->should_unload_classes());\n+    }\n@@ -241,5 +129,4 @@\n-        cause = GCCause::_shenandoah_concurrent_gc;\n-        generation = OLD;\n-        set_gc_mode(servicing_old);\n-        heap->set_unload_classes(false);\n-      }\n+    \/\/ Blow all soft references on this cycle, if handling allocation failure,\n+    \/\/ either implicit or explicit GC request,  or we are requested to do so unconditionally.\n+    if (alloc_failure_pending || is_gc_requested || ShenandoahAlwaysClearSoftRefs) {\n+      heap->soft_ref_policy()->set_should_clear_all_soft_refs(true);\n@@ -248,2 +135,2 @@\n-    const bool gc_requested = (gc_mode() != none);\n-    assert (!gc_requested || cause != GCCause::_no_gc, \"GC cause should be set\");\n+    const bool gc_requested = (mode != none);\n+    assert (!gc_requested || cause != GCCause::_last_gc_cause, \"GC cause should be set\");\n@@ -252,6 +139,0 @@\n-      \/\/ Blow away all soft references on this cycle, if handling allocation failure,\n-      \/\/ either implicit or explicit GC request, or we are requested to do so unconditionally.\n-      if (generation == select_global_generation() && (alloc_failure_pending || implicit_gc_requested || explicit_gc_requested || ShenandoahAlwaysClearSoftRefs)) {\n-        heap->soft_ref_policy()->set_should_clear_all_soft_refs(true);\n-      }\n-\n@@ -267,1 +148,1 @@\n-      set_forced_counters_update(true);\n+      heap->set_forced_counters_update(true);\n@@ -274,3 +155,0 @@\n-      \/\/ In case this is a degenerated cycle, remember whether original cycle was aging.\n-      const bool was_aging_cycle = heap->is_aging_cycle();\n-      heap->set_aging_cycle(false);\n@@ -278,12 +156,3 @@\n-      switch (gc_mode()) {\n-        case concurrent_normal: {\n-          \/\/ At this point:\n-          \/\/  if (generation == YOUNG), this is a normal YOUNG cycle\n-          \/\/  if (generation == OLD), this is a bootstrap OLD cycle\n-          \/\/  if (generation == GLOBAL), this is a GLOBAL cycle triggered by System.gc()\n-          \/\/ In all three cases, we want to age old objects if this is an aging cycle\n-          if (age_period-- == 0) {\n-             heap->set_aging_cycle(true);\n-             age_period = ShenandoahAgingCyclePeriod - 1;\n-          }\n-          service_concurrent_normal_cycle(heap, generation, cause);\n+      switch (mode) {\n+        case concurrent_normal:\n+          service_concurrent_normal_cycle(cause);\n@@ -291,3 +160,1 @@\n-        }\n-        case stw_degenerated: {\n-          heap->set_aging_cycle(was_aging_cycle);\n+        case stw_degenerated:\n@@ -296,6 +163,1 @@\n-        }\n-        case stw_full: {\n-          if (age_period-- == 0) {\n-            heap->set_aging_cycle(true);\n-            age_period = ShenandoahAgingCyclePeriod - 1;\n-          }\n+        case stw_full:\n@@ -304,7 +166,0 @@\n-        }\n-        case servicing_old: {\n-          assert(generation == OLD, \"Expected old generation here\");\n-          GCIdMark gc_id_mark;\n-          service_concurrent_old_cycle(heap, cause);\n-          break;\n-        }\n@@ -316,1 +171,1 @@\n-      if (explicit_gc_requested || implicit_gc_requested) {\n+      if (is_gc_requested) {\n@@ -334,1 +189,1 @@\n-        Universe::heap()->update_capacity_and_used_at_gc();\n+        heap->update_capacity_and_used_at_gc();\n@@ -337,1 +192,1 @@\n-        Universe::heap()->record_whole_heap_examined_timestamp();\n+        heap->record_whole_heap_examined_timestamp();\n@@ -342,2 +197,2 @@\n-      handle_force_counters_update();\n-      set_forced_counters_update(false);\n+      heap->handle_force_counters_update();\n+      heap->set_forced_counters_update(false);\n@@ -350,1 +205,20 @@\n-        global_heuristics->clear_metaspace_oom();\n+        heuristics->clear_metaspace_oom();\n+      }\n+\n+      \/\/ Commit worker statistics to cycle data\n+      heap->phase_timings()->flush_par_workers_to_cycle();\n+      if (ShenandoahPacing) {\n+        heap->pacer()->flush_stats_to_cycle();\n+      }\n+\n+      \/\/ Print GC stats for current cycle\n+      {\n+        LogTarget(Info, gc, stats) lt;\n+        if (lt.is_enabled()) {\n+          ResourceMark rm;\n+          LogStream ls(lt);\n+          heap->phase_timings()->print_cycle_on(&ls);\n+          if (ShenandoahPacing) {\n+            heap->pacer()->print_cycle_on(&ls);\n+          }\n+        }\n@@ -353,1 +227,2 @@\n-      process_phase_timings(heap);\n+      \/\/ Commit statistics to globals\n+      heap->phase_timings()->flush_cycle_to_global();\n@@ -363,1 +238,1 @@\n-      \/\/ Allow pacer to know we have seen this many allocations\n+      \/\/ Report to pacer that we have seen this many words allocated\n@@ -369,1 +244,1 @@\n-    double current = os::elapsedTime();\n+    const double current = os::elapsedTime();\n@@ -371,1 +246,1 @@\n-    if (ShenandoahUncommit && (explicit_gc_requested || soft_max_changed || (current - last_shrink_time > shrink_period))) {\n+    if (ShenandoahUncommit && (is_gc_requested || soft_max_changed || (current - last_shrink_time > shrink_period))) {\n@@ -376,1 +251,1 @@\n-      double shrink_before = (explicit_gc_requested || soft_max_changed) ?\n+      double shrink_before = (is_gc_requested || soft_max_changed) ?\n@@ -384,1 +259,1 @@\n-      service_uncommit(shrink_before, shrink_until);\n+      heap->maybe_uncommit(shrink_before, shrink_until);\n@@ -389,6 +264,8 @@\n-    \/\/ Wait for ShenandoahControlIntervalMax unless there was an allocation failure or another request was made mid-cycle.\n-    if (!is_alloc_failure_gc() && _requested_gc_cause == GCCause::_no_gc) {\n-      \/\/ The timed wait is necessary because this thread has a responsibility to send\n-      \/\/ 'alloc_words' to the pacer when it does not perform a GC.\n-      MonitorLocker lock(&_control_lock, Mutex::_no_safepoint_check_flag);\n-      lock.wait(ShenandoahControlIntervalMax);\n+    \/\/ Wait before performing the next action. If allocation happened during this wait,\n+    \/\/ we exit sooner, to let heuristics re-evaluate new conditions. If we are at idle,\n+    \/\/ back off exponentially.\n+    if (heap->has_changed()) {\n+      sleep = ShenandoahControlIntervalMin;\n+    } else if ((current - last_sleep_adjust_time) * 1000 > ShenandoahControlIntervalAdjustPeriod){\n+      sleep = MIN2<int>(ShenandoahControlIntervalMax, MAX2(1, sleep * 2));\n+      last_sleep_adjust_time = current;\n@@ -396,0 +273,1 @@\n+    os::naked_short_sleep(sleep);\n@@ -404,226 +282,1 @@\n-void ShenandoahControlThread::process_phase_timings(const ShenandoahHeap* heap) {\n-  \/\/ Commit worker statistics to cycle data\n-  heap->phase_timings()->flush_par_workers_to_cycle();\n-  if (ShenandoahPacing) {\n-    heap->pacer()->flush_stats_to_cycle();\n-  }\n-\n-  ShenandoahEvacuationTracker* evac_tracker = heap->evac_tracker();\n-  ShenandoahCycleStats         evac_stats   = evac_tracker->flush_cycle_to_global();\n-\n-  \/\/ Print GC stats for current cycle\n-  {\n-    LogTarget(Info, gc, stats) lt;\n-    if (lt.is_enabled()) {\n-      ResourceMark rm;\n-      LogStream ls(lt);\n-      heap->phase_timings()->print_cycle_on(&ls);\n-      evac_tracker->print_evacuations_on(&ls, &evac_stats.workers,\n-                                              &evac_stats.mutators);\n-      if (ShenandoahPacing) {\n-        heap->pacer()->print_cycle_on(&ls);\n-      }\n-    }\n-  }\n-\n-  \/\/ Commit statistics to globals\n-  heap->phase_timings()->flush_cycle_to_global();\n-}\n-\n-\/\/ Young and old concurrent cycles are initiated by the regulator. Implicit\n-\/\/ and explicit GC requests are handled by the controller thread and always\n-\/\/ run a global cycle (which is concurrent by default, but may be overridden\n-\/\/ by command line options). Old cycles always degenerate to a global cycle.\n-\/\/ Young cycles are degenerated to complete the young cycle.  Young\n-\/\/ and old degen may upgrade to Full GC.  Full GC may also be\n-\/\/ triggered directly by a System.gc() invocation.\n-\/\/\n-\/\/\n-\/\/      +-----+ Idle +-----+-----------+---------------------+\n-\/\/      |         +        |           |                     |\n-\/\/      |         |        |           |                     |\n-\/\/      |         |        v           |                     |\n-\/\/      |         |  Bootstrap Old +-- | ------------+       |\n-\/\/      |         |   +                |             |       |\n-\/\/      |         |   |                |             |       |\n-\/\/      |         v   v                v             v       |\n-\/\/      |    Resume Old <----------+ Young +--> Young Degen  |\n-\/\/      |     +  +   ^                            +  +       |\n-\/\/      v     |  |   |                            |  |       |\n-\/\/   Global <-+  |   +----------------------------+  |       |\n-\/\/      +        |                                   |       |\n-\/\/      |        v                                   v       |\n-\/\/      +--->  Global Degen +--------------------> Full <----+\n-\/\/\n-void ShenandoahControlThread::service_concurrent_normal_cycle(ShenandoahHeap* heap,\n-                                                              const ShenandoahGenerationType generation,\n-                                                              GCCause::Cause cause) {\n-  GCIdMark gc_id_mark;\n-  ShenandoahGeneration* the_generation = nullptr;\n-  switch (generation) {\n-    case YOUNG: {\n-      \/\/ Run a young cycle. This might or might not, have interrupted an ongoing\n-      \/\/ concurrent mark in the old generation. We need to think about promotions\n-      \/\/ in this case. Promoted objects should be above the TAMS in the old regions\n-      \/\/ they end up in, but we have to be sure we don't promote into any regions\n-      \/\/ that are in the cset.\n-      log_info(gc, ergo)(\"Start GC cycle (YOUNG)\");\n-      the_generation = heap->young_generation();\n-      service_concurrent_cycle(the_generation, cause, false);\n-      break;\n-    }\n-    case OLD: {\n-      log_info(gc, ergo)(\"Start GC cycle (OLD)\");\n-      the_generation = heap->old_generation();\n-      service_concurrent_old_cycle(heap, cause);\n-      break;\n-    }\n-    case GLOBAL_GEN: {\n-      log_info(gc, ergo)(\"Start GC cycle (GLOBAL)\");\n-      the_generation = heap->global_generation();\n-      service_concurrent_cycle(the_generation, cause, false);\n-      break;\n-    }\n-    case GLOBAL_NON_GEN: {\n-      log_info(gc, ergo)(\"Start GC cycle\");\n-      the_generation = heap->global_generation();\n-      service_concurrent_cycle(the_generation, cause, false);\n-      break;\n-    }\n-    default:\n-      ShouldNotReachHere();\n-  }\n-}\n-\n-void ShenandoahControlThread::service_concurrent_old_cycle(ShenandoahHeap* heap, GCCause::Cause &cause) {\n-  ShenandoahOldGeneration* old_generation = heap->old_generation();\n-  ShenandoahYoungGeneration* young_generation = heap->young_generation();\n-  ShenandoahOldGeneration::State original_state = old_generation->state();\n-\n-  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n-\n-  switch (original_state) {\n-    case ShenandoahOldGeneration::FILLING: {\n-      _allow_old_preemption.set();\n-      old_generation->entry_coalesce_and_fill();\n-      _allow_old_preemption.unset();\n-\n-      \/\/ Before bootstrapping begins, we must acknowledge any cancellation request.\n-      \/\/ If the gc has not been cancelled, this does nothing. If it has been cancelled,\n-      \/\/ this will clear the cancellation request and exit before starting the bootstrap\n-      \/\/ phase. This will allow the young GC cycle to proceed normally. If we do not\n-      \/\/ acknowledge the cancellation request, the subsequent young cycle will observe\n-      \/\/ the request and essentially cancel itself.\n-      if (check_cancellation_or_degen(ShenandoahGC::_degenerated_outside_cycle)) {\n-        log_info(gc)(\"Preparation for old generation cycle was cancelled\");\n-        return;\n-      }\n-\n-      \/\/ Coalescing threads completed and nothing was cancelled. it is safe to transition from this state.\n-      old_generation->transition_to(ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP);\n-      return;\n-    }\n-    case ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP:\n-      old_generation->transition_to(ShenandoahOldGeneration::BOOTSTRAPPING);\n-    case ShenandoahOldGeneration::BOOTSTRAPPING: {\n-      \/\/ Configure the young generation's concurrent mark to put objects in\n-      \/\/ old regions into the concurrent mark queues associated with the old\n-      \/\/ generation. The young cycle will run as normal except that rather than\n-      \/\/ ignore old references it will mark and enqueue them in the old concurrent\n-      \/\/ task queues but it will not traverse them.\n-      set_gc_mode(bootstrapping_old);\n-      young_generation->set_old_gen_task_queues(old_generation->task_queues());\n-      ShenandoahGCSession session(cause, young_generation);\n-      service_concurrent_cycle(heap, young_generation, cause, true);\n-      process_phase_timings(heap);\n-      if (heap->cancelled_gc()) {\n-        \/\/ Young generation bootstrap cycle has failed. Concurrent mark for old generation\n-        \/\/ is going to resume after degenerated bootstrap cycle completes.\n-        log_info(gc)(\"Bootstrap cycle for old generation was cancelled\");\n-        return;\n-      }\n-\n-      \/\/ Reset the degenerated point. Normally this would happen at the top\n-      \/\/ of the control loop, but here we have just completed a young cycle\n-      \/\/ which has bootstrapped the old concurrent marking.\n-      _degen_point = ShenandoahGC::_degenerated_outside_cycle;\n-\n-      \/\/ From here we will 'resume' the old concurrent mark. This will skip reset\n-      \/\/ and init mark for the concurrent mark. All of that work will have been\n-      \/\/ done by the bootstrapping young cycle.\n-      set_gc_mode(servicing_old);\n-      old_generation->transition_to(ShenandoahOldGeneration::MARKING);\n-    }\n-    case ShenandoahOldGeneration::MARKING: {\n-      ShenandoahGCSession session(cause, old_generation);\n-      bool marking_complete = resume_concurrent_old_cycle(old_generation, cause);\n-      if (marking_complete) {\n-        assert(old_generation->state() != ShenandoahOldGeneration::MARKING, \"Should not still be marking\");\n-        if (original_state == ShenandoahOldGeneration::MARKING) {\n-          heap->mmu_tracker()->record_old_marking_increment(true);\n-          heap->log_heap_status(\"At end of Concurrent Old Marking finishing increment\");\n-        }\n-      } else if (original_state == ShenandoahOldGeneration::MARKING) {\n-        heap->mmu_tracker()->record_old_marking_increment(false);\n-        heap->log_heap_status(\"At end of Concurrent Old Marking increment\");\n-      }\n-      break;\n-    }\n-    default:\n-      fatal(\"Unexpected state for old GC: %s\", ShenandoahOldGeneration::state_name(old_generation->state()));\n-  }\n-}\n-\n-bool ShenandoahControlThread::resume_concurrent_old_cycle(ShenandoahGeneration* generation, GCCause::Cause cause) {\n-  assert(ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress(), \"Old mark should be in progress\");\n-  log_debug(gc)(\"Resuming old generation with \" UINT32_FORMAT \" marking tasks queued\", generation->task_queues()->tasks());\n-\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n-  \/\/ We can only tolerate being cancelled during concurrent marking or during preparation for mixed\n-  \/\/ evacuation. This flag here (passed by reference) is used to control precisely where the regulator\n-  \/\/ is allowed to cancel a GC.\n-  ShenandoahOldGC gc(generation, _allow_old_preemption);\n-  if (gc.collect(cause)) {\n-    generation->record_success_concurrent(false);\n-  }\n-\n-  if (heap->cancelled_gc()) {\n-    \/\/ It's possible the gc cycle was cancelled after the last time\n-    \/\/ the collection checked for cancellation. In which case, the\n-    \/\/ old gc cycle is still completed, and we have to deal with this\n-    \/\/ cancellation. We set the degeneration point to be outside\n-    \/\/ the cycle because if this is an allocation failure, that is\n-    \/\/ what must be done (there is no degenerated old cycle). If the\n-    \/\/ cancellation was due to a heuristic wanting to start a young\n-    \/\/ cycle, then we are not actually going to a degenerated cycle,\n-    \/\/ so the degenerated point doesn't matter here.\n-    check_cancellation_or_degen(ShenandoahGC::_degenerated_outside_cycle);\n-    if (_requested_gc_cause == GCCause::_shenandoah_concurrent_gc) {\n-      heap->shenandoah_policy()->record_interrupted_old();\n-    }\n-    return false;\n-  }\n-  return true;\n-}\n-\n-bool ShenandoahControlThread::check_soft_max_changed() const {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  size_t new_soft_max = Atomic::load(&SoftMaxHeapSize);\n-  size_t old_soft_max = heap->soft_max_capacity();\n-  if (new_soft_max != old_soft_max) {\n-    new_soft_max = MAX2(heap->min_capacity(), new_soft_max);\n-    new_soft_max = MIN2(heap->max_capacity(), new_soft_max);\n-    if (new_soft_max != old_soft_max) {\n-      log_info(gc)(\"Soft Max Heap Size: \" SIZE_FORMAT \"%s -> \" SIZE_FORMAT \"%s\",\n-                   byte_size_in_proper_unit(old_soft_max), proper_unit_for_byte_size(old_soft_max),\n-                   byte_size_in_proper_unit(new_soft_max), proper_unit_for_byte_size(new_soft_max)\n-      );\n-      heap->set_soft_max_capacity(new_soft_max);\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-void ShenandoahControlThread::service_concurrent_cycle(ShenandoahGeneration* generation, GCCause::Cause cause, bool do_old_gc_bootstrap) {\n+void ShenandoahControlThread::service_concurrent_normal_cycle(GCCause::Cause cause) {\n@@ -665,0 +318,1 @@\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -667,3 +321,2 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  ShenandoahGCSession session(cause, generation);\n-  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+  GCIdMark gc_id_mark;\n+  ShenandoahGCSession session(cause, heap->global_generation());\n@@ -671,2 +324,1 @@\n-  service_concurrent_cycle(heap, generation, cause, do_old_gc_bootstrap);\n-}\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n@@ -674,5 +326,1 @@\n-void ShenandoahControlThread::service_concurrent_cycle(ShenandoahHeap* heap,\n-                                                       ShenandoahGeneration* generation,\n-                                                       GCCause::Cause& cause,\n-                                                       bool do_old_gc_bootstrap) {\n-  ShenandoahConcurrentGC gc(generation, do_old_gc_bootstrap);\n+  ShenandoahConcurrentGC gc(heap->global_generation(), false);\n@@ -681,1 +329,3 @@\n-    generation->record_success_concurrent(gc.abbreviated());\n+    heap->global_generation()->heuristics()->record_success_concurrent(gc.abbreviated());\n+    heap->shenandoah_policy()->record_success_concurrent(false, gc.abbreviated());\n+    heap->log_heap_status(\"At end of GC\");\n@@ -685,4 +335,1 @@\n-    assert(!generation->is_old(), \"Old GC takes a different control path\");\n-    \/\/ Concurrent young-gen collection degenerates to young\n-    \/\/ collection.  Same for global collections.\n-    _degen_generation = generation;\n+    heap->log_heap_status(\"At end of cancelled GC\");\n@@ -690,35 +337,0 @@\n-  const char* msg;\n-  if (heap->mode()->is_generational()) {\n-    ShenandoahMmuTracker* mmu_tracker = heap->mmu_tracker();\n-    if (generation->is_young()) {\n-      if (heap->cancelled_gc()) {\n-        msg = (do_old_gc_bootstrap) ? \"At end of Interrupted Concurrent Bootstrap GC\":\n-                                      \"At end of Interrupted Concurrent Young GC\";\n-      } else {\n-        \/\/ We only record GC results if GC was successful\n-        msg = (do_old_gc_bootstrap) ? \"At end of Concurrent Bootstrap GC\":\n-                                      \"At end of Concurrent Young GC\";\n-        if (heap->collection_set()->has_old_regions()) {\n-          mmu_tracker->record_mixed(get_gc_id());\n-        } else if (do_old_gc_bootstrap) {\n-          mmu_tracker->record_bootstrap(get_gc_id());\n-        } else {\n-          mmu_tracker->record_young(get_gc_id());\n-        }\n-      }\n-    } else {\n-      assert(generation->is_global(), \"If not young, must be GLOBAL\");\n-      assert(!do_old_gc_bootstrap, \"Do not bootstrap with GLOBAL GC\");\n-      if (heap->cancelled_gc()) {\n-        msg = \"At end of Interrupted Concurrent GLOBAL GC\";\n-      } else {\n-        \/\/ We only record GC results if GC was successful\n-        msg = \"At end of Concurrent Global GC\";\n-        mmu_tracker->record_global(get_gc_id());\n-      }\n-    }\n-  } else {\n-    msg = heap->cancelled_gc() ? \"At end of cancelled GC\" :\n-                                 \"At end of GC\";\n-  }\n-  heap->log_heap_status(msg);\n@@ -729,28 +341,7 @@\n-  if (!heap->cancelled_gc()) {\n-    return false;\n-  }\n-\n-  if (in_graceful_shutdown()) {\n-    return true;\n-  }\n-\n-  assert(_degen_point == ShenandoahGC::_degenerated_outside_cycle,\n-         \"Should not be set yet: %s\", ShenandoahGC::degen_point_to_string(_degen_point));\n-\n-  if (is_alloc_failure_gc()) {\n-    _degen_point = point;\n-    _preemption_requested.unset();\n-    return true;\n-  }\n-\n-  if (_preemption_requested.is_set()) {\n-    assert(_requested_generation == YOUNG, \"Only young GCs may preempt old.\");\n-    _preemption_requested.unset();\n-\n-    \/\/ Old generation marking is only cancellable during concurrent marking.\n-    \/\/ Once final mark is complete, the code does not check again for cancellation.\n-    \/\/ If old generation was cancelled for an allocation failure, we wouldn't\n-    \/\/ make it to this case. The calling code is responsible for forcing a\n-    \/\/ cancellation due to allocation failure into a degenerated cycle.\n-    _degen_point = point;\n-    heap->clear_cancelled_gc(false \/* clear oom handler *\/);\n+  if (heap->cancelled_gc()) {\n+    assert (is_alloc_failure_gc() || in_graceful_shutdown(), \"Cancel GC either for alloc failure GC, or gracefully exiting\");\n+    if (!in_graceful_shutdown()) {\n+      assert (_degen_point == ShenandoahGC::_degenerated_outside_cycle,\n+              \"Should not be set yet: %s\", ShenandoahGC::degen_point_to_string(_degen_point));\n+      _degen_point = point;\n+    }\n@@ -759,2 +350,0 @@\n-\n-  fatal(\"Cancel GC either for alloc failure GC, or gracefully exiting, or to pause old generation marking\");\n@@ -770,1 +359,0 @@\n-\n@@ -778,3 +366,2 @@\n-void ShenandoahControlThread::service_stw_degenerated_cycle(GCCause::Cause cause,\n-                                                            ShenandoahGC::ShenandoahDegenPoint point) {\n-  assert(point != ShenandoahGC::_degenerated_unset, \"Degenerated point should be set\");\n+void ShenandoahControlThread::service_stw_degenerated_cycle(GCCause::Cause cause, ShenandoahGC::ShenandoahDegenPoint point) {\n+  assert (point != ShenandoahGC::_degenerated_unset, \"Degenerated point should be set\");\n@@ -782,1 +369,0 @@\n-\n@@ -784,1 +370,1 @@\n-  ShenandoahGCSession session(cause, _degen_generation);\n+  ShenandoahGCSession session(cause, heap->global_generation());\n@@ -786,1 +372,1 @@\n-  ShenandoahDegenGC gc(point, _degen_generation);\n+  ShenandoahDegenGC gc(point, heap->global_generation());\n@@ -788,46 +374,0 @@\n-\n-  assert(heap->young_generation()->task_queues()->is_empty(), \"Unexpected young generation marking tasks\");\n-  if (_degen_generation->is_global()) {\n-    assert(heap->old_generation()->task_queues()->is_empty(), \"Unexpected old generation marking tasks\");\n-    assert(heap->global_generation()->task_queues()->is_empty(), \"Unexpected global generation marking tasks\");\n-  } else {\n-    assert(_degen_generation->is_young(), \"Expected degenerated young cycle, if not global.\");\n-    ShenandoahOldGeneration* old = heap->old_generation();\n-    if (old->state() == ShenandoahOldGeneration::BOOTSTRAPPING) {\n-      old->transition_to(ShenandoahOldGeneration::MARKING);\n-    }\n-  }\n-}\n-\n-void ShenandoahControlThread::service_uncommit(double shrink_before, size_t shrink_until) {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n-  \/\/ Determine if there is work to do. This avoids taking heap lock if there is\n-  \/\/ no work available, avoids spamming logs with superfluous logging messages,\n-  \/\/ and minimises the amount of work while locks are taken.\n-\n-  if (heap->committed() <= shrink_until) return;\n-\n-  bool has_work = false;\n-  for (size_t i = 0; i < heap->num_regions(); i++) {\n-    ShenandoahHeapRegion *r = heap->get_region(i);\n-    if (r->is_empty_committed() && (r->empty_time() < shrink_before)) {\n-      has_work = true;\n-      break;\n-    }\n-  }\n-\n-  if (has_work) {\n-    heap->entry_uncommit(shrink_before, shrink_until);\n-  }\n-}\n-\n-bool ShenandoahControlThread::is_explicit_gc(GCCause::Cause cause) const {\n-  return GCCause::is_user_requested_gc(cause) ||\n-         GCCause::is_serviceability_requested_gc(cause);\n-}\n-\n-bool ShenandoahControlThread::is_implicit_gc(GCCause::Cause cause) const {\n-  return !is_explicit_gc(cause)\n-      && cause != GCCause::_shenandoah_concurrent_gc\n-      && cause != GCCause::_no_gc;\n@@ -837,17 +377,1 @@\n-  assert(GCCause::is_user_requested_gc(cause) ||\n-         GCCause::is_serviceability_requested_gc(cause) ||\n-         cause == GCCause::_metadata_GC_clear_soft_refs ||\n-         cause == GCCause::_codecache_GC_aggressive ||\n-         cause == GCCause::_codecache_GC_threshold ||\n-         cause == GCCause::_full_gc_alot ||\n-         cause == GCCause::_wb_young_gc ||\n-         cause == GCCause::_wb_full_gc ||\n-         cause == GCCause::_wb_breakpoint ||\n-         cause == GCCause::_scavenge_alot,\n-         \"only requested GCs here: %s\", GCCause::to_string(cause));\n-\n-  if (is_explicit_gc(cause)) {\n-    if (!DisableExplicitGC) {\n-      handle_requested_gc(cause);\n-    }\n-  } else {\n+  if (ShenandoahCollectorPolicy::should_handle_requested_gc(cause)) {\n@@ -858,63 +382,0 @@\n-bool ShenandoahControlThread::request_concurrent_gc(ShenandoahGenerationType generation) {\n-  if (_preemption_requested.is_set() || _requested_gc_cause != GCCause::_no_gc || ShenandoahHeap::heap()->cancelled_gc()) {\n-    \/\/ Ignore subsequent requests from the heuristics\n-    log_debug(gc, thread)(\"Reject request for concurrent gc: preemption_requested: %s, gc_requested: %s, gc_cancelled: %s\",\n-                          BOOL_TO_STR(_preemption_requested.is_set()),\n-                          GCCause::to_string(_requested_gc_cause),\n-                          BOOL_TO_STR(ShenandoahHeap::heap()->cancelled_gc()));\n-    return false;\n-  }\n-\n-  if (gc_mode() == none) {\n-    GCCause::Cause existing = Atomic::cmpxchg(&_requested_gc_cause, GCCause::_no_gc, GCCause::_shenandoah_concurrent_gc);\n-    if (existing != GCCause::_no_gc) {\n-      log_debug(gc, thread)(\"Reject request for concurrent gc because another gc is pending: %s\", GCCause::to_string(existing));\n-      return false;\n-    }\n-\n-    _requested_generation = generation;\n-    notify_control_thread();\n-\n-    MonitorLocker ml(&_regulator_lock, Mutex::_no_safepoint_check_flag);\n-    while (gc_mode() == none) {\n-      ml.wait();\n-    }\n-    return true;\n-  }\n-\n-  if (preempt_old_marking(generation)) {\n-    assert(gc_mode() == servicing_old, \"Expected to be servicing old, but was: %s.\", gc_mode_name(gc_mode()));\n-    GCCause::Cause existing = Atomic::cmpxchg(&_requested_gc_cause, GCCause::_no_gc, GCCause::_shenandoah_concurrent_gc);\n-    if (existing != GCCause::_no_gc) {\n-      log_debug(gc, thread)(\"Reject request to interrupt old gc because another gc is pending: %s\", GCCause::to_string(existing));\n-      return false;\n-    }\n-\n-    log_info(gc)(\"Preempting old generation mark to allow %s GC\", shenandoah_generation_name(generation));\n-    _requested_generation = generation;\n-    _preemption_requested.set();\n-    ShenandoahHeap::heap()->cancel_gc(GCCause::_shenandoah_concurrent_gc);\n-    notify_control_thread();\n-\n-    MonitorLocker ml(&_regulator_lock, Mutex::_no_safepoint_check_flag);\n-    while (gc_mode() == servicing_old) {\n-      ml.wait();\n-    }\n-    return true;\n-  }\n-\n-  log_debug(gc, thread)(\"Reject request for concurrent gc: mode: %s, allow_old_preemption: %s\",\n-                        gc_mode_name(gc_mode()),\n-                        BOOL_TO_STR(_allow_old_preemption.is_set()));\n-  return false;\n-}\n-\n-void ShenandoahControlThread::notify_control_thread() {\n-  MonitorLocker locker(&_control_lock, Mutex::_no_safepoint_check_flag);\n-  _control_lock.notify();\n-}\n-\n-bool ShenandoahControlThread::preempt_old_marking(ShenandoahGenerationType generation) {\n-  return (generation == YOUNG) && _allow_old_preemption.try_unset();\n-}\n-\n@@ -935,7 +396,5 @@\n-    \/\/ This races with the regulator thread to start a concurrent gc and the\n-    \/\/ control thread to clear it at the start of a cycle. Threads here are\n-    \/\/ allowed to escalate a heuristic's request for concurrent gc.\n-    GCCause::Cause existing = Atomic::xchg(&_requested_gc_cause, cause);\n-    if (existing != GCCause::_no_gc) {\n-      log_debug(gc, thread)(\"GC request supersedes existing request: %s\", GCCause::to_string(existing));\n-    }\n+    \/\/ Although setting gc request is under _gc_waiters_lock, but read side (run_service())\n+    \/\/ does not take the lock. We need to enforce following order, so that read side sees\n+    \/\/ latest requested gc cause when the flag is set.\n+    _requested_gc_cause = cause;\n+    _gc_requested.set();\n@@ -943,1 +402,0 @@\n-    notify_control_thread();\n@@ -951,53 +409,0 @@\n-void ShenandoahControlThread::handle_alloc_failure(ShenandoahAllocRequest& req) {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n-  assert(current()->is_Java_thread(), \"expect Java thread here\");\n-  bool is_humongous = req.size() > ShenandoahHeapRegion::region_size_words();\n-\n-  if (try_set_alloc_failure_gc(is_humongous)) {\n-    \/\/ Only report the first allocation failure\n-    log_info(gc)(\"Failed to allocate %s, \" SIZE_FORMAT \"%s\",\n-                 req.type_string(),\n-                 byte_size_in_proper_unit(req.size() * HeapWordSize), proper_unit_for_byte_size(req.size() * HeapWordSize));\n-    \/\/ Now that alloc failure GC is scheduled, we can abort everything else\n-    heap->cancel_gc(GCCause::_allocation_failure);\n-  }\n-\n-  MonitorLocker ml(&_alloc_failure_waiters_lock);\n-  while (is_alloc_failure_gc()) {\n-    ml.wait();\n-  }\n-}\n-\n-void ShenandoahControlThread::handle_alloc_failure_evac(size_t words) {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  bool is_humongous = (words > ShenandoahHeapRegion::region_size_words());\n-\n-  if (try_set_alloc_failure_gc(is_humongous)) {\n-    \/\/ Only report the first allocation failure\n-    log_info(gc)(\"Failed to allocate \" SIZE_FORMAT \"%s for evacuation\",\n-                 byte_size_in_proper_unit(words * HeapWordSize), proper_unit_for_byte_size(words * HeapWordSize));\n-  }\n-\n-  \/\/ Forcefully report allocation failure\n-  heap->cancel_gc(GCCause::_shenandoah_allocation_failure_evac);\n-}\n-\n-void ShenandoahControlThread::notify_alloc_failure_waiters() {\n-  _alloc_failure_gc.unset();\n-  _humongous_alloc_failure_gc.unset();\n-  MonitorLocker ml(&_alloc_failure_waiters_lock);\n-  ml.notify_all();\n-}\n-\n-bool ShenandoahControlThread::try_set_alloc_failure_gc(bool is_humongous) {\n-  if (is_humongous) {\n-    _humongous_alloc_failure_gc.try_set();\n-  }\n-  return _alloc_failure_gc.try_set();\n-}\n-\n-bool ShenandoahControlThread::is_alloc_failure_gc() {\n-  return _alloc_failure_gc.is_set();\n-}\n-\n@@ -1005,0 +410,1 @@\n+  _gc_requested.unset();\n@@ -1008,86 +414,0 @@\n-\n-void ShenandoahControlThread::handle_counters_update() {\n-  if (_do_counters_update.is_set()) {\n-    _do_counters_update.unset();\n-    ShenandoahHeap::heap()->monitoring_support()->update_counters();\n-  }\n-}\n-\n-void ShenandoahControlThread::handle_force_counters_update() {\n-  if (_force_counters_update.is_set()) {\n-    _do_counters_update.unset(); \/\/ reset these too, we do update now!\n-    ShenandoahHeap::heap()->monitoring_support()->update_counters();\n-  }\n-}\n-\n-void ShenandoahControlThread::notify_heap_changed() {\n-  \/\/ This is called from allocation path, and thus should be fast.\n-\n-  \/\/ Update monitoring counters when we took a new region. This amortizes the\n-  \/\/ update costs on slow path.\n-  if (_do_counters_update.is_unset()) {\n-    _do_counters_update.set();\n-  }\n-}\n-\n-void ShenandoahControlThread::pacing_notify_alloc(size_t words) {\n-  assert(ShenandoahPacing, \"should only call when pacing is enabled\");\n-  Atomic::add(&_allocs_seen, words, memory_order_relaxed);\n-}\n-\n-void ShenandoahControlThread::set_forced_counters_update(bool value) {\n-  _force_counters_update.set_cond(value);\n-}\n-\n-void ShenandoahControlThread::reset_gc_id() {\n-  Atomic::store(&_gc_id, (size_t)0);\n-}\n-\n-void ShenandoahControlThread::update_gc_id() {\n-  Atomic::inc(&_gc_id);\n-}\n-\n-size_t ShenandoahControlThread::get_gc_id() {\n-  return Atomic::load(&_gc_id);\n-}\n-\n-void ShenandoahControlThread::start() {\n-  create_and_start();\n-}\n-\n-void ShenandoahControlThread::prepare_for_graceful_shutdown() {\n-  _graceful_shutdown.set();\n-}\n-\n-bool ShenandoahControlThread::in_graceful_shutdown() {\n-  return _graceful_shutdown.is_set();\n-}\n-\n-const char* ShenandoahControlThread::gc_mode_name(ShenandoahControlThread::GCMode mode) {\n-  switch (mode) {\n-    case none:              return \"idle\";\n-    case concurrent_normal: return \"normal\";\n-    case stw_degenerated:   return \"degenerated\";\n-    case stw_full:          return \"full\";\n-    case servicing_old:     return \"old\";\n-    case bootstrapping_old: return \"bootstrap\";\n-    default:                return \"unknown\";\n-  }\n-}\n-\n-void ShenandoahControlThread::set_gc_mode(ShenandoahControlThread::GCMode new_mode) {\n-  if (_mode != new_mode) {\n-    log_info(gc)(\"Transition from: %s to: %s\", gc_mode_name(_mode), gc_mode_name(new_mode));\n-    MonitorLocker ml(&_regulator_lock, Mutex::_no_safepoint_check_flag);\n-    _mode = new_mode;\n-    ml.notify_all();\n-  }\n-}\n-\n-ShenandoahGenerationType ShenandoahControlThread::select_global_generation() {\n-  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n-    return GLOBAL_GEN;\n-  } else {\n-    return GLOBAL_NON_GEN;\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":115,"deletions":795,"binary":false,"changes":910,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -32,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationType.hpp\"\n@@ -35,2 +35,0 @@\n-#include \"runtime\/task.hpp\"\n-#include \"utilities\/ostream.hpp\"\n@@ -38,20 +36,1 @@\n-\/\/ Periodic task is useful for doing asynchronous things that do not require (heap) locks,\n-\/\/ or synchronization with other parts of collector. These could run even when ShenandoahConcurrentThread\n-\/\/ is busy driving the GC cycle.\n-class ShenandoahPeriodicTask : public PeriodicTask {\n-private:\n-  ShenandoahControlThread* _thread;\n-public:\n-  ShenandoahPeriodicTask(ShenandoahControlThread* thread) :\n-          PeriodicTask(100), _thread(thread) {}\n-  virtual void task();\n-};\n-\n-\/\/ Periodic task to notify blocked paced waiters.\n-class ShenandoahPeriodicPacerNotify : public PeriodicTask {\n-public:\n-  ShenandoahPeriodicPacerNotify() : PeriodicTask(PeriodicTask::min_interval) {}\n-  virtual void task();\n-};\n-\n-class ShenandoahControlThread: public ConcurrentGCThread {\n+class ShenandoahControlThread: public ShenandoahController {\n@@ -61,11 +40,0 @@\n-  \/\/ While we could have a single lock for these, it may risk unblocking\n-  \/\/ GC waiters when alloc failure GC cycle finishes. We want instead\n-  \/\/ to make complete explicit cycle for demanding customers.\n-  Monitor _alloc_failure_waiters_lock;\n-  Monitor _gc_waiters_lock;\n-  Monitor _control_lock;\n-  Monitor _regulator_lock;\n-  ShenandoahPeriodicTask _periodic_task;\n-  ShenandoahPeriodicPacerNotify _periodic_pacer_notify_task;\n-\n-public:\n@@ -76,3 +44,1 @@\n-    stw_full,\n-    bootstrapping_old,\n-    servicing_old\n+    stw_full\n@@ -81,2 +47,3 @@\n-  void run_service();\n-  void stop_service();\n+  ShenandoahSharedFlag _gc_requested;\n+  GCCause::Cause       _requested_gc_cause;\n+  ShenandoahGC::ShenandoahDegenPoint _degen_point;\n@@ -84,1 +51,2 @@\n-  size_t get_gc_id();\n+public:\n+  ShenandoahControlThread();\n@@ -86,8 +54,2 @@\n-private:\n-  ShenandoahSharedFlag _allow_old_preemption;\n-  ShenandoahSharedFlag _preemption_requested;\n-  ShenandoahSharedFlag _alloc_failure_gc;\n-  ShenandoahSharedFlag _humongous_alloc_failure_gc;\n-  ShenandoahSharedFlag _graceful_shutdown;\n-  ShenandoahSharedFlag _do_counters_update;\n-  ShenandoahSharedFlag _force_counters_update;\n+  void run_service() override;\n+  void stop_service() override;\n@@ -95,4 +57,1 @@\n-  GCCause::Cause  _requested_gc_cause;\n-  volatile ShenandoahGenerationType _requested_generation;\n-  ShenandoahGC::ShenandoahDegenPoint _degen_point;\n-  ShenandoahGeneration* _degen_generation;\n+  void request_gc(GCCause::Cause cause) override;\n@@ -100,7 +59,1 @@\n-  shenandoah_padding(0);\n-  volatile size_t _allocs_seen;\n-  shenandoah_padding(1);\n-  volatile size_t _gc_id;\n-  shenandoah_padding(2);\n-  volatile GCMode _mode;\n-  shenandoah_padding(3);\n+private:\n@@ -108,1 +61,0 @@\n-  \/\/ Returns true if the cycle has been cancelled or degenerated.\n@@ -110,4 +62,1 @@\n-\n-  \/\/ Returns true if the old generation marking completed (i.e., final mark executed for old generation).\n-  bool resume_concurrent_old_cycle(ShenandoahGeneration* generation, GCCause::Cause cause);\n-  void service_concurrent_cycle(ShenandoahGeneration* generation, GCCause::Cause cause, bool reset_old_bitmap_specially);\n+  void service_concurrent_normal_cycle(GCCause::Cause cause);\n@@ -116,13 +65,0 @@\n-  void service_uncommit(double shrink_before, size_t shrink_until);\n-\n-  \/\/ Return true if setting the flag which indicates allocation failure succeeds.\n-  bool try_set_alloc_failure_gc(bool is_humongous);\n-\n-  \/\/ Notify threads waiting for GC to complete.\n-  void notify_alloc_failure_waiters();\n-\n-  \/\/ True if allocation failure flag has been set.\n-  bool is_alloc_failure_gc();\n-\n-  void reset_gc_id();\n-  void update_gc_id();\n@@ -135,64 +71,0 @@\n-\n-  bool is_explicit_gc(GCCause::Cause cause) const;\n-  bool is_implicit_gc(GCCause::Cause cause) const;\n-\n-  \/\/ Returns true if the old generation marking was interrupted to allow a young cycle.\n-  bool preempt_old_marking(ShenandoahGenerationType generation);\n-\n-  \/\/ Returns true if the soft maximum heap has been changed using management APIs.\n-  bool check_soft_max_changed() const;\n-\n-  void process_phase_timings(const ShenandoahHeap* heap);\n-\n-public:\n-  \/\/ Constructor\n-  ShenandoahControlThread();\n-  ~ShenandoahControlThread();\n-\n-  \/\/ Handle allocation failure from normal allocation.\n-  \/\/ Blocks until memory is available.\n-  void handle_alloc_failure(ShenandoahAllocRequest& req);\n-\n-  \/\/ Handle allocation failure from evacuation path.\n-  \/\/ Optionally blocks while collector is handling the failure.\n-  void handle_alloc_failure_evac(size_t words);\n-\n-  void request_gc(GCCause::Cause cause);\n-  \/\/ Return true if the request to start a concurrent GC for the given generation succeeded.\n-  bool request_concurrent_gc(ShenandoahGenerationType generation);\n-\n-  void handle_counters_update();\n-  void handle_force_counters_update();\n-  void set_forced_counters_update(bool value);\n-\n-  void notify_heap_changed();\n-\n-  void pacing_notify_alloc(size_t words);\n-\n-  void start();\n-  void prepare_for_graceful_shutdown();\n-  bool in_graceful_shutdown();\n-\n-  void service_concurrent_normal_cycle(ShenandoahHeap* heap,\n-                                       const ShenandoahGenerationType generation,\n-                                       GCCause::Cause cause);\n-\n-  void service_concurrent_old_cycle(ShenandoahHeap* heap,\n-                                    GCCause::Cause &cause);\n-\n-  void set_gc_mode(GCMode new_mode);\n-  GCMode gc_mode() {\n-    return _mode;\n-  }\n-\n-  static ShenandoahGenerationType select_global_generation();\n-\n- private:\n-  static const char* gc_mode_name(GCMode mode);\n-  void notify_control_thread();\n-\n-  void service_concurrent_cycle(ShenandoahHeap* heap,\n-                                ShenandoahGeneration* generation,\n-                                GCCause::Cause &cause,\n-                                bool do_old_gc_bootstrap);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":13,"deletions":141,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shenandoah\/shenandoahController.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+\n+void ShenandoahController::pacing_notify_alloc(size_t words) {\n+  assert(ShenandoahPacing, \"should only call when pacing is enabled\");\n+  Atomic::add(&_allocs_seen, words, memory_order_relaxed);\n+}\n+\n+size_t ShenandoahController::reset_allocs_seen() {\n+  return Atomic::xchg(&_allocs_seen, (size_t)0, memory_order_relaxed);\n+}\n+\n+void ShenandoahController::prepare_for_graceful_shutdown() {\n+  _graceful_shutdown.set();\n+}\n+\n+bool ShenandoahController::in_graceful_shutdown() {\n+  return _graceful_shutdown.is_set();\n+}\n+\n+void ShenandoahController::update_gc_id() {\n+  Atomic::inc(&_gc_id);\n+}\n+\n+size_t ShenandoahController::get_gc_id() {\n+  return Atomic::load(&_gc_id);\n+}\n+\n+void ShenandoahController::handle_alloc_failure(ShenandoahAllocRequest& req, bool block) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  assert(current()->is_Java_thread(), \"expect Java thread here\");\n+  bool is_humongous = req.size() > ShenandoahHeapRegion::humongous_threshold_words();\n+\n+  if (try_set_alloc_failure_gc(is_humongous)) {\n+    \/\/ Only report the first allocation failure\n+    log_info(gc)(\"Failed to allocate %s, \" SIZE_FORMAT \"%s\",\n+                 req.type_string(),\n+                 byte_size_in_proper_unit(req.size() * HeapWordSize), proper_unit_for_byte_size(req.size() * HeapWordSize));\n+\n+    \/\/ Now that alloc failure GC is scheduled, we can abort everything else\n+    heap->cancel_gc(GCCause::_allocation_failure);\n+  }\n+\n+\n+  if (block) {\n+    MonitorLocker ml(&_alloc_failure_waiters_lock);\n+    while (is_alloc_failure_gc()) {\n+      ml.wait();\n+    }\n+  }\n+}\n+\n+void ShenandoahController::handle_alloc_failure_evac(size_t words) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  bool is_humongous = (words > ShenandoahHeapRegion::region_size_words());\n+\n+  if (try_set_alloc_failure_gc(is_humongous)) {\n+    \/\/ Only report the first allocation failure\n+    log_info(gc)(\"Failed to allocate \" SIZE_FORMAT \"%s for evacuation\",\n+                 byte_size_in_proper_unit(words * HeapWordSize), proper_unit_for_byte_size(words * HeapWordSize));\n+  }\n+\n+  \/\/ Forcefully report allocation failure\n+  heap->cancel_gc(GCCause::_shenandoah_allocation_failure_evac);\n+}\n+\n+void ShenandoahController::notify_alloc_failure_waiters() {\n+  _alloc_failure_gc.unset();\n+  _humongous_alloc_failure_gc.unset();\n+  MonitorLocker ml(&_alloc_failure_waiters_lock);\n+  ml.notify_all();\n+}\n+\n+bool ShenandoahController::try_set_alloc_failure_gc(bool is_humongous) {\n+  if (is_humongous) {\n+    _humongous_alloc_failure_gc.try_set();\n+  }\n+  return _alloc_failure_gc.try_set();\n+}\n+\n+bool ShenandoahController::is_alloc_failure_gc() {\n+  return _alloc_failure_gc.is_set();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.cpp","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef LINUX_X86_64_SERVER_SLOWDEBUG_SHENANDOAHCONTROLLER_HPP\n+#define LINUX_X86_64_SERVER_SLOWDEBUG_SHENANDOAHCONTROLLER_HPP\n+\n+#include \"gc\/shared\/gcCause.hpp\"\n+#include \"gc\/shared\/concurrentGCThread.hpp\"\n+#include \"gc\/shenandoah\/shenandoahAllocRequest.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n+\n+\/**\n+ * This interface exposes methods necessary for the heap to interact\n+ * with the threads responsible for driving the collection cycle.\n+ *\/\n+class ShenandoahController: public ConcurrentGCThread {\n+private:\n+  ShenandoahSharedFlag _graceful_shutdown;\n+\n+  shenandoah_padding(0);\n+  volatile size_t _allocs_seen;\n+  shenandoah_padding(1);\n+  volatile size_t _gc_id;\n+  shenandoah_padding(2);\n+\n+protected:\n+  ShenandoahSharedFlag _alloc_failure_gc;\n+  ShenandoahSharedFlag _humongous_alloc_failure_gc;\n+\n+  \/\/ While we could have a single lock for these, it may risk unblocking\n+  \/\/ GC waiters when alloc failure GC cycle finishes. We want instead\n+  \/\/ to make complete explicit cycle for demanding customers.\n+  Monitor _alloc_failure_waiters_lock;\n+  Monitor _gc_waiters_lock;\n+\n+public:\n+  ShenandoahController():\n+    ConcurrentGCThread(),\n+    _allocs_seen(0),\n+    _gc_id(0),\n+    _alloc_failure_waiters_lock(Mutex::safepoint-2, \"ShenandoahAllocFailureGC_lock\", true),\n+    _gc_waiters_lock(Mutex::safepoint-2, \"ShenandoahRequestedGC_lock\", true)\n+  { }\n+\n+  \/\/ Request a collection cycle. This handles \"explicit\" gc requests\n+  \/\/ like System.gc and \"implicit\" gc requests, like metaspace oom.\n+  virtual void request_gc(GCCause::Cause cause) = 0;\n+\n+  \/\/ This cancels the collection cycle and has an option to block\n+  \/\/ until another cycle runs and clears the alloc failure gc flag.\n+  void handle_alloc_failure(ShenandoahAllocRequest& req, bool block);\n+\n+  \/\/ Invoked for allocation failures during evacuation. This cancels\n+  \/\/ the collection cycle without blocking.\n+  void handle_alloc_failure_evac(size_t words);\n+\n+  \/\/ Return true if setting the flag which indicates allocation failure succeeds.\n+  bool try_set_alloc_failure_gc(bool is_humongous);\n+\n+  \/\/ Notify threads waiting for GC to complete.\n+  void notify_alloc_failure_waiters();\n+\n+  \/\/ True if allocation failure flag has been set.\n+  bool is_alloc_failure_gc();\n+\n+  \/\/ This is called for every allocation. The control thread accumulates\n+  \/\/ this value when idle. During the gc cycle, the control resets it\n+  \/\/ and reports it to the pacer.\n+  void pacing_notify_alloc(size_t words);\n+  size_t reset_allocs_seen();\n+\n+  \/\/ These essentially allows to cancel a collection cycle for the\n+  \/\/ purpose of shutting down the JVM, without trying to start a degenerated\n+  \/\/ cycle.\n+  void prepare_for_graceful_shutdown();\n+  bool in_graceful_shutdown();\n+\n+\n+  \/\/ Returns the internal gc count used by the control thread. Probably\n+  \/\/ doesn't need to be exposed.\n+  size_t get_gc_id();\n+  void update_gc_id();\n+};\n+#endif \/\/LINUX_X86_64_SERVER_SLOWDEBUG_SHENANDOAHCONTROLLER_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.hpp","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -293,20 +294,5 @@\n-        size_t old_region_surplus = heap->get_old_region_surplus();\n-        size_t old_region_deficit = heap->get_old_region_deficit();\n-        bool success;\n-        size_t region_xfer;\n-        const char* region_destination;\n-        if (old_region_surplus) {\n-          region_xfer = old_region_surplus;\n-          region_destination = \"young\";\n-          success = heap->generation_sizer()->transfer_to_young(old_region_surplus);\n-        } else if (old_region_deficit) {\n-          region_xfer = old_region_surplus;\n-          region_destination = \"old\";\n-          success = heap->generation_sizer()->transfer_to_old(old_region_deficit);\n-          if (!success) {\n-            heap->old_heuristics()->trigger_cannot_expand();\n-          }\n-        } else {\n-          region_destination = \"none\";\n-          region_xfer = 0;\n-          success = true;\n+        auto result = ShenandoahGenerationalHeap::heap()->balance_generations();\n+        LogTarget(Info, gc, ergo) lt;\n+        if (lt.is_enabled()) {\n+          LogStream ls(lt);\n+          result.print_on(\"Degenerated GC\", &ls);\n@@ -314,11 +300,0 @@\n-\n-        size_t young_available = heap->young_generation()->available();\n-        size_t old_available = heap->old_generation()->available();\n-        log_info(gc, ergo)(\"After cleanup, %s \" SIZE_FORMAT \" regions to %s to prepare for next gc, old available: \"\n-                           SIZE_FORMAT \"%s, young_available: \" SIZE_FORMAT \"%s\",\n-                           success? \"successfully transferred\": \"failed to transfer\", region_xfer, region_destination,\n-                           byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n-                           byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n-\n-        heap->set_old_region_surplus(0);\n-        heap->set_old_region_deficit(0);\n@@ -334,3 +309,1 @@\n-    heap->set_young_evac_reserve(0);\n-    heap->set_old_evac_reserve(0);\n-    heap->set_promoted_reserve(0);\n+    ShenandoahGenerationalHeap::heap()->reset_generation_reserves();\n@@ -400,3 +373,1 @@\n-  size_t humongous_regions_promoted = heap->get_promotable_humongous_regions();\n-  size_t regular_regions_promoted_in_place = heap->get_regular_regions_promoted_in_place();\n-  if (!heap->collection_set()->is_empty() || (humongous_regions_promoted + regular_regions_promoted_in_place > 0)) {\n+  if (!heap->collection_set()->is_empty() || heap->old_generation()->has_in_place_promotions()) {\n@@ -506,1 +477,1 @@\n-  log_info(gc)(\"Degenerate GC upgrading to Full GC\");\n+  log_info(gc)(\"Degenerated GC upgrading to Full GC\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":9,"deletions":38,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+  \/\/ Turns this degenerated cycle into a full gc without leaving the safepoint\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -167,7 +167,3 @@\n-  assert (((region_capacity <= _region_size_bytes) &&\n-           ((orig_set == Mutator) && (new_set == Collector)) ||\n-           ((orig_set == Collector) && (new_set == Mutator))) ||\n-          ((region_capacity == _region_size_bytes) &&\n-           ((orig_set == Mutator) && (new_set == Collector)) ||\n-           ((orig_set == OldCollector) && (new_set == Mutator)) ||\n-           (new_set == OldCollector)), \"Unexpected movement between sets\");\n+  assert((region_capacity <= _region_size_bytes && ((orig_set == Mutator && new_set == Collector) || (orig_set == Collector && new_set == Mutator)))\n+      || (region_capacity == _region_size_bytes && ((orig_set == Mutator && new_set == Collector) || (orig_set == OldCollector && new_set == Mutator) || new_set == OldCollector)),\n+      \"Unexpected movement between sets\");\n@@ -471,1 +467,1 @@\n-    _heap->augment_promo_reserve(capacity);\n+    _heap->old_generation()->augment_promoted_reserve(capacity);\n@@ -1006,1 +1002,1 @@\n-  _heap->augment_old_evac_reserve(region_capacity);\n+  _heap->old_generation()->augment_evacuation_reserve(region_capacity);\n@@ -1168,1 +1164,1 @@\n-void ShenandoahFreeSet::rebuild(size_t young_cset_regions, size_t old_cset_regions) {\n+void ShenandoahFreeSet::rebuild(size_t young_cset_regions, size_t old_cset_regions, bool have_evacuation_reserves) {\n@@ -1173,6 +1169,8 @@\n-  size_t old_capacity = _heap->old_generation()->max_capacity();\n-  size_t old_available = _heap->old_generation()->available();\n-  size_t old_unaffiliated_regions = _heap->old_generation()->free_unaffiliated_regions();\n-  size_t young_capacity = _heap->young_generation()->max_capacity();\n-  size_t young_available = _heap->young_generation()->available();\n-  size_t young_unaffiliated_regions = _heap->young_generation()->free_unaffiliated_regions();\n+  ShenandoahOldGeneration* old_generation = _heap->old_generation();\n+  size_t old_capacity = old_generation->max_capacity();\n+  size_t old_available = old_generation->available();\n+  size_t old_unaffiliated_regions = old_generation->free_unaffiliated_regions();\n+  ShenandoahYoungGeneration* young_generation = _heap->young_generation();\n+  size_t young_capacity = young_generation->max_capacity();\n+  size_t young_available = young_generation->available();\n+  size_t young_unaffiliated_regions = young_generation->free_unaffiliated_regions();\n@@ -1187,2 +1185,2 @@\n-  size_t old_region_surplus = _heap->get_old_region_surplus();\n-  size_t old_region_deficit = _heap->get_old_region_deficit();\n+  size_t old_region_surplus = old_generation->get_region_surplus();\n+  size_t old_region_deficit = old_generation->get_region_deficit();\n@@ -1220,1 +1218,1 @@\n-    if (_heap->has_evacuation_reserve_quantities()) {\n+    if (have_evacuation_reserves) {\n@@ -1222,2 +1220,5 @@\n-      young_reserve = _heap->get_young_evac_reserve();\n-      old_reserve = _heap->get_promoted_reserve() + _heap->get_old_evac_reserve();\n+\n+      size_t promoted_reserve = old_generation->get_promoted_reserve();\n+      size_t old_evac_reserve = old_generation->get_evacuation_reserve();\n+      young_reserve = young_generation->get_evacuation_reserve();\n+      old_reserve = promoted_reserve + old_evac_reserve;\n@@ -1226,1 +1227,1 @@\n-             _heap->get_promoted_reserve(), _heap->get_old_evac_reserve(), old_available);\n+             promoted_reserve, old_evac_reserve, old_available);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":23,"deletions":22,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -195,1 +195,15 @@\n-  void rebuild(size_t young_cset_regions, size_t old_cset_regions);\n+\n+  \/\/ At the end of final mark, but before we begin evacuating, heuristics calculate how much memory is required to\n+  \/\/ hold the results of evacuating to young-gen and to old-gen.  These quantities, stored in reserves for their,\n+  \/\/ respective generations, are consulted prior to rebuilding the free set (ShenandoahFreeSet) in preparation for\n+  \/\/ evacuation.  When the free set is rebuilt, we make sure to reserve sufficient memory in the collector and\n+  \/\/ old_collector sets to hold evacuations, if have_evacuation_reserves is true.  The other time we rebuild the free\n+  \/\/ set is at the end of GC, as we prepare to idle GC until the next trigger.  In this case, have_evacuation_reserves\n+  \/\/ is false because we don't yet know how much memory will need to be evacuated in the next GC cycle.  When\n+  \/\/ have_evacuation_reserves is false, the free set rebuild operation reserves for the collector and old_collector sets\n+  \/\/ based on alternative mechanisms, such as ShenandoahEvacReserve, ShenandoahOldEvacReserve, and\n+  \/\/ ShenandoahOldCompactionReserve.  In a future planned enhancement, the reserve for old_collector set when the\n+  \/\/ evacuation reserves are unknown, is based in part on anticipated promotion as determined by analysis of live data\n+  \/\/ found during the previous GC pass which is one less than the current tenure age.\n+  void rebuild(size_t young_cset_regions, size_t old_cset_regions, bool have_evacuation_reserves = false);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalFullGC.hpp\"\n@@ -49,1 +51,0 @@\n-#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n@@ -58,1 +59,0 @@\n-#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n@@ -63,1 +63,0 @@\n-#include \"runtime\/javaThread.hpp\"\n@@ -70,63 +69,0 @@\n-\/\/ After Full GC is done, reconstruct the remembered set by iterating over OLD regions,\n-\/\/ registering all objects between bottom() and top(), and setting remembered set cards to\n-\/\/ DIRTY if they hold interesting pointers.\n-class ShenandoahReconstructRememberedSetTask : public WorkerTask {\n-private:\n-  ShenandoahRegionIterator _regions;\n-\n-public:\n-  ShenandoahReconstructRememberedSetTask() :\n-    WorkerTask(\"Shenandoah Reset Bitmap\") { }\n-\n-  void work(uint worker_id) {\n-    ShenandoahParallelWorkerSession worker_session(worker_id);\n-    ShenandoahHeapRegion* r = _regions.next();\n-    ShenandoahHeap* heap = ShenandoahHeap::heap();\n-    RememberedScanner* scanner = heap->card_scan();\n-    ShenandoahSetRememberedCardsToDirtyClosure dirty_cards_for_interesting_pointers;\n-\n-    while (r != nullptr) {\n-      if (r->is_old() && r->is_active()) {\n-        HeapWord* obj_addr = r->bottom();\n-        if (r->is_humongous_start()) {\n-          \/\/ First, clear the remembered set\n-          oop obj = cast_to_oop(obj_addr);\n-          size_t size = obj->size();\n-\n-          \/\/ First, clear the remembered set for all spanned humongous regions\n-          size_t num_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);\n-          size_t region_span = num_regions * ShenandoahHeapRegion::region_size_words();\n-          scanner->reset_remset(r->bottom(), region_span);\n-          size_t region_index = r->index();\n-          ShenandoahHeapRegion* humongous_region = heap->get_region(region_index);\n-          while (num_regions-- != 0) {\n-            scanner->reset_object_range(humongous_region->bottom(), humongous_region->end());\n-            region_index++;\n-            humongous_region = heap->get_region(region_index);\n-          }\n-\n-          \/\/ Then register the humongous object and DIRTY relevant remembered set cards\n-          scanner->register_object_without_lock(obj_addr);\n-          obj->oop_iterate(&dirty_cards_for_interesting_pointers);\n-        } else if (!r->is_humongous()) {\n-          \/\/ First, clear the remembered set\n-          scanner->reset_remset(r->bottom(), ShenandoahHeapRegion::region_size_words());\n-          scanner->reset_object_range(r->bottom(), r->end());\n-\n-          \/\/ Then iterate over all objects, registering object and DIRTYing relevant remembered set cards\n-          HeapWord* t = r->top();\n-          while (obj_addr < t) {\n-            oop obj = cast_to_oop(obj_addr);\n-            size_t size = obj->size();\n-            scanner->register_object_without_lock(obj_addr);\n-            obj_addr += obj->oop_iterate_size(&dirty_cards_for_interesting_pointers);\n-          }\n-        } \/\/ else, ignore humongous continuation region\n-      }\n-      \/\/ else, this region is FREE or YOUNG or inactive and we can ignore it.\n-      \/\/ TODO: Assert this.\n-      r = _regions.next();\n-    }\n-  }\n-};\n-\n@@ -170,1 +106,0 @@\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n@@ -177,1 +112,2 @@\n-  metrics.snap_after();\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+\n@@ -179,25 +115,1 @@\n-    \/\/ Full GC should reset time since last gc for young and old heuristics\n-    heap->young_generation()->heuristics()->record_cycle_end();\n-    heap->old_generation()->heuristics()->record_cycle_end();\n-\n-    heap->mmu_tracker()->record_full(GCId::current());\n-    heap->log_heap_status(\"At end of Full GC\");\n-\n-    assert(heap->old_generation()->state() == ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP,\n-           \"After full GC, old generation should be waiting for bootstrap.\");\n-\n-    \/\/ Since we allow temporary violation of these constraints during Full GC, we want to enforce that the assertions are\n-    \/\/ made valid by the time Full GC completes.\n-    assert(heap->old_generation()->used_regions_size() <= heap->old_generation()->max_capacity(),\n-           \"Old generation affiliated regions must be less than capacity\");\n-    assert(heap->young_generation()->used_regions_size() <= heap->young_generation()->max_capacity(),\n-           \"Young generation affiliated regions must be less than capacity\");\n-\n-    assert((heap->young_generation()->used() + heap->young_generation()->get_humongous_waste())\n-           <= heap->young_generation()->used_regions_size(), \"Young consumed can be no larger than span of affiliated regions\");\n-    assert((heap->old_generation()->used() + heap->old_generation()->get_humongous_waste())\n-           <= heap->old_generation()->used_regions_size(), \"Old consumed can be no larger than span of affiliated regions\");\n-\n-    \/\/ Establish baseline for next old-has-grown trigger.\n-    heap->old_generation()->set_live_bytes_after_last_mark(heap->old_generation()->used() +\n-                                                           heap->old_generation()->get_humongous_waste());\n+    ShenandoahGenerationalFullGC::handle_completion(heap);\n@@ -205,0 +117,3 @@\n+\n+  metrics.snap_after();\n+\n@@ -206,1 +121,1 @@\n-    ShenandoahHeap::heap()->notify_gc_progress();\n+    heap->notify_gc_progress();\n@@ -210,1 +125,1 @@\n-    ShenandoahHeap::heap()->notify_gc_no_progress();\n+    heap->notify_gc_no_progress();\n@@ -220,2 +135,0 @@\n-  \/\/ Since we may arrive here from degenerated GC failure of either young or old, establish generation as GLOBAL.\n-  heap->set_gc_generation(heap->global_generation());\n@@ -224,7 +137,1 @@\n-    \/\/ No need for old_gen->increase_used() as this was done when plabs were allocated.\n-    heap->set_young_evac_reserve(0);\n-    heap->set_old_evac_reserve(0);\n-    heap->set_promoted_reserve(0);\n-\n-    \/\/ Full GC supersedes any marking or coalescing in old generation.\n-    heap->cancel_old_gc();\n+    ShenandoahGenerationalFullGC::prepare();\n@@ -277,0 +184,1 @@\n+      \/\/ TODO: Send cancel_concurrent_mark upstream? Does it really not have it already?\n@@ -299,6 +207,1 @@\n-      for (size_t i = 0; i < heap->num_regions(); i++) {\n-        ShenandoahHeapRegion* r = heap->get_region(i);\n-        if (r->get_top_before_promote() != nullptr) {\n-          r->restore_top_before_promote();\n-        }\n-      }\n+      ShenandoahGenerationalFullGC::restore_top_before_promote(heap);\n@@ -355,13 +258,0 @@\n-  {\n-    \/\/ Epilogue\n-    \/\/ TODO: Merge with phase5_epilog?\n-    _preserved_marks->restore(heap->workers());\n-    _preserved_marks->reclaim();\n-\n-    if (heap->mode()->is_generational()) {\n-      ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_reconstruct_remembered_set);\n-      ShenandoahReconstructRememberedSetTask task;\n-      heap->workers()->run_task(&task);\n-    }\n-  }\n-\n@@ -403,0 +293,1 @@\n+    \/\/ TODO: Add API to heap to skip free regions\n@@ -431,6 +322,2 @@\n-  size_t live_bytes_in_old = 0;\n-  for (size_t i = 0; i < heap->num_regions(); i++) {\n-    ShenandoahHeapRegion* r = heap->get_region(i);\n-    if (r->is_old()) {\n-      live_bytes_in_old += r->get_live_data_bytes();\n-    }\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    ShenandoahGenerationalFullGC::log_live_in_old(heap);\n@@ -438,1 +325,0 @@\n-  log_info(gc)(\"Live bytes in old after STW mark: \" PROPERFMT, PROPERFMTARGS(live_bytes_in_old));\n@@ -441,235 +327,0 @@\n-class ShenandoahPrepareForCompactionTask : public WorkerTask {\n-private:\n-  PreservedMarksSet*        const _preserved_marks;\n-  ShenandoahHeap*           const _heap;\n-  ShenandoahHeapRegionSet** const _worker_slices;\n-  size_t                    const _num_workers;\n-\n-public:\n-  ShenandoahPrepareForCompactionTask(PreservedMarksSet *preserved_marks,\n-                                     ShenandoahHeapRegionSet **worker_slices,\n-                                     size_t num_workers);\n-\n-  static bool is_candidate_region(ShenandoahHeapRegion* r) {\n-    \/\/ Empty region: get it into the slice to defragment the slice itself.\n-    \/\/ We could have skipped this without violating correctness, but we really\n-    \/\/ want to compact all live regions to the start of the heap, which sometimes\n-    \/\/ means moving them into the fully empty regions.\n-    if (r->is_empty()) return true;\n-\n-    \/\/ Can move the region, and this is not the humongous region. Humongous\n-    \/\/ moves are special cased here, because their moves are handled separately.\n-    return r->is_stw_move_allowed() && !r->is_humongous();\n-  }\n-\n-  void work(uint worker_id);\n-};\n-\n-class ShenandoahPrepareForGenerationalCompactionObjectClosure : public ObjectClosure {\n-private:\n-  PreservedMarks*          const _preserved_marks;\n-  ShenandoahHeap*          const _heap;\n-  uint                           _tenuring_threshold;\n-\n-  \/\/ _empty_regions is a thread-local list of heap regions that have been completely emptied by this worker thread's\n-  \/\/ compaction efforts.  The worker thread that drives these efforts adds compacted regions to this list if the\n-  \/\/ region has not been compacted onto itself.\n-  GrowableArray<ShenandoahHeapRegion*>& _empty_regions;\n-  int _empty_regions_pos;\n-  ShenandoahHeapRegion*          _old_to_region;\n-  ShenandoahHeapRegion*          _young_to_region;\n-  ShenandoahHeapRegion*          _from_region;\n-  ShenandoahAffiliation          _from_affiliation;\n-  HeapWord*                      _old_compact_point;\n-  HeapWord*                      _young_compact_point;\n-  uint                           _worker_id;\n-\n-public:\n-  ShenandoahPrepareForGenerationalCompactionObjectClosure(PreservedMarks* preserved_marks,\n-                                                          GrowableArray<ShenandoahHeapRegion*>& empty_regions,\n-                                                          ShenandoahHeapRegion* old_to_region,\n-                                                          ShenandoahHeapRegion* young_to_region, uint worker_id) :\n-      _preserved_marks(preserved_marks),\n-      _heap(ShenandoahHeap::heap()),\n-      _tenuring_threshold(0),\n-      _empty_regions(empty_regions),\n-      _empty_regions_pos(0),\n-      _old_to_region(old_to_region),\n-      _young_to_region(young_to_region),\n-      _from_region(nullptr),\n-      _old_compact_point((old_to_region != nullptr)? old_to_region->bottom(): nullptr),\n-      _young_compact_point((young_to_region != nullptr)? young_to_region->bottom(): nullptr),\n-      _worker_id(worker_id) {\n-    if (_heap->mode()->is_generational()) {\n-      _tenuring_threshold = _heap->age_census()->tenuring_threshold();\n-    }\n-  }\n-\n-  void set_from_region(ShenandoahHeapRegion* from_region) {\n-    _from_region = from_region;\n-    _from_affiliation = from_region->affiliation();\n-    if (_from_region->has_live()) {\n-      if (_from_affiliation == ShenandoahAffiliation::OLD_GENERATION) {\n-        if (_old_to_region == nullptr) {\n-          _old_to_region = from_region;\n-          _old_compact_point = from_region->bottom();\n-        }\n-      } else {\n-        assert(_from_affiliation == ShenandoahAffiliation::YOUNG_GENERATION, \"from_region must be OLD or YOUNG\");\n-        if (_young_to_region == nullptr) {\n-          _young_to_region = from_region;\n-          _young_compact_point = from_region->bottom();\n-        }\n-      }\n-    } \/\/ else, we won't iterate over this _from_region so we don't need to set up to region to hold copies\n-  }\n-\n-  void finish() {\n-    finish_old_region();\n-    finish_young_region();\n-  }\n-\n-  void finish_old_region() {\n-    if (_old_to_region != nullptr) {\n-      log_debug(gc)(\"Planned compaction into Old Region \" SIZE_FORMAT \", used: \" SIZE_FORMAT \" tabulated by worker %u\",\n-                    _old_to_region->index(), _old_compact_point - _old_to_region->bottom(), _worker_id);\n-      _old_to_region->set_new_top(_old_compact_point);\n-      _old_to_region = nullptr;\n-    }\n-  }\n-\n-  void finish_young_region() {\n-    if (_young_to_region != nullptr) {\n-      log_debug(gc)(\"Worker %u planned compaction into Young Region \" SIZE_FORMAT \", used: \" SIZE_FORMAT,\n-                    _worker_id, _young_to_region->index(), _young_compact_point - _young_to_region->bottom());\n-      _young_to_region->set_new_top(_young_compact_point);\n-      _young_to_region = nullptr;\n-    }\n-  }\n-\n-  bool is_compact_same_region() {\n-    return (_from_region == _old_to_region) || (_from_region == _young_to_region);\n-  }\n-\n-  int empty_regions_pos() {\n-    return _empty_regions_pos;\n-  }\n-\n-  void do_object(oop p) {\n-    assert(_from_region != nullptr, \"must set before work\");\n-    assert((_from_region->bottom() <= cast_from_oop<HeapWord*>(p)) && (cast_from_oop<HeapWord*>(p) < _from_region->top()),\n-           \"Object must reside in _from_region\");\n-    assert(_heap->complete_marking_context()->is_marked(p), \"must be marked\");\n-    assert(!_heap->complete_marking_context()->allocated_after_mark_start(p), \"must be truly marked\");\n-\n-    size_t obj_size = p->size();\n-    uint from_region_age = _from_region->age();\n-    uint object_age = p->age();\n-\n-    bool promote_object = false;\n-    if ((_from_affiliation == ShenandoahAffiliation::YOUNG_GENERATION) &&\n-        (from_region_age + object_age >= _tenuring_threshold)) {\n-      if ((_old_to_region != nullptr) && (_old_compact_point + obj_size > _old_to_region->end())) {\n-        finish_old_region();\n-        _old_to_region = nullptr;\n-      }\n-      if (_old_to_region == nullptr) {\n-        if (_empty_regions_pos < _empty_regions.length()) {\n-          ShenandoahHeapRegion* new_to_region = _empty_regions.at(_empty_regions_pos);\n-          _empty_regions_pos++;\n-          new_to_region->set_affiliation(OLD_GENERATION);\n-          _old_to_region = new_to_region;\n-          _old_compact_point = _old_to_region->bottom();\n-          promote_object = true;\n-        }\n-        \/\/ Else this worker thread does not yet have any empty regions into which this aged object can be promoted so\n-        \/\/ we leave promote_object as false, deferring the promotion.\n-      } else {\n-        promote_object = true;\n-      }\n-    }\n-\n-    if (promote_object || (_from_affiliation == ShenandoahAffiliation::OLD_GENERATION)) {\n-      assert(_old_to_region != nullptr, \"_old_to_region should not be nullptr when evacuating to OLD region\");\n-      if (_old_compact_point + obj_size > _old_to_region->end()) {\n-        ShenandoahHeapRegion* new_to_region;\n-\n-        log_debug(gc)(\"Worker %u finishing old region \" SIZE_FORMAT \", compact_point: \" PTR_FORMAT \", obj_size: \" SIZE_FORMAT\n-                      \", &compact_point[obj_size]: \" PTR_FORMAT \", region end: \" PTR_FORMAT,  _worker_id, _old_to_region->index(),\n-                      p2i(_old_compact_point), obj_size, p2i(_old_compact_point + obj_size), p2i(_old_to_region->end()));\n-\n-        \/\/ Object does not fit.  Get a new _old_to_region.\n-        finish_old_region();\n-        if (_empty_regions_pos < _empty_regions.length()) {\n-          new_to_region = _empty_regions.at(_empty_regions_pos);\n-          _empty_regions_pos++;\n-          new_to_region->set_affiliation(OLD_GENERATION);\n-        } else {\n-          \/\/ If we've exhausted the previously selected _old_to_region, we know that the _old_to_region is distinct\n-          \/\/ from _from_region.  That's because there is always room for _from_region to be compacted into itself.\n-          \/\/ Since we're out of empty regions, let's use _from_region to hold the results of its own compaction.\n-          new_to_region = _from_region;\n-        }\n-\n-        assert(new_to_region != _old_to_region, \"must not reuse same OLD to-region\");\n-        assert(new_to_region != nullptr, \"must not be nullptr\");\n-        _old_to_region = new_to_region;\n-        _old_compact_point = _old_to_region->bottom();\n-      }\n-\n-      \/\/ Object fits into current region, record new location:\n-      assert(_old_compact_point + obj_size <= _old_to_region->end(), \"must fit\");\n-      shenandoah_assert_not_forwarded(nullptr, p);\n-      _preserved_marks->push_if_necessary(p, p->mark());\n-      p->forward_to(cast_to_oop(_old_compact_point));\n-      _old_compact_point += obj_size;\n-    } else {\n-      assert(_from_affiliation == ShenandoahAffiliation::YOUNG_GENERATION,\n-             \"_from_region must be OLD_GENERATION or YOUNG_GENERATION\");\n-      assert(_young_to_region != nullptr, \"_young_to_region should not be nullptr when compacting YOUNG _from_region\");\n-\n-      \/\/ After full gc compaction, all regions have age 0.  Embed the region's age into the object's age in order to preserve\n-      \/\/ tenuring progress.\n-      if (_heap->is_aging_cycle()) {\n-        _heap->increase_object_age(p, from_region_age + 1);\n-      } else {\n-        _heap->increase_object_age(p, from_region_age);\n-      }\n-\n-      if (_young_compact_point + obj_size > _young_to_region->end()) {\n-        ShenandoahHeapRegion* new_to_region;\n-\n-        log_debug(gc)(\"Worker %u finishing young region \" SIZE_FORMAT \", compact_point: \" PTR_FORMAT \", obj_size: \" SIZE_FORMAT\n-                      \", &compact_point[obj_size]: \" PTR_FORMAT \", region end: \" PTR_FORMAT,  _worker_id, _young_to_region->index(),\n-                      p2i(_young_compact_point), obj_size, p2i(_young_compact_point + obj_size), p2i(_young_to_region->end()));\n-\n-        \/\/ Object does not fit.  Get a new _young_to_region.\n-        finish_young_region();\n-        if (_empty_regions_pos < _empty_regions.length()) {\n-          new_to_region = _empty_regions.at(_empty_regions_pos);\n-          _empty_regions_pos++;\n-          new_to_region->set_affiliation(YOUNG_GENERATION);\n-        } else {\n-          \/\/ If we've exhausted the previously selected _young_to_region, we know that the _young_to_region is distinct\n-          \/\/ from _from_region.  That's because there is always room for _from_region to be compacted into itself.\n-          \/\/ Since we're out of empty regions, let's use _from_region to hold the results of its own compaction.\n-          new_to_region = _from_region;\n-        }\n-\n-        assert(new_to_region != _young_to_region, \"must not reuse same OLD to-region\");\n-        assert(new_to_region != nullptr, \"must not be nullptr\");\n-        _young_to_region = new_to_region;\n-        _young_compact_point = _young_to_region->bottom();\n-      }\n-\n-      \/\/ Object fits into current region, record new location:\n-      assert(_young_compact_point + obj_size <= _young_to_region->end(), \"must fit\");\n-      shenandoah_assert_not_forwarded(nullptr, p);\n-      _preserved_marks->push_if_necessary(p, p->mark());\n-      p->forward_to(cast_to_oop(_young_compact_point));\n-      _young_compact_point += obj_size;\n-    }\n-  }\n-};\n-\n-\n@@ -702,1 +353,1 @@\n-  void finish_region() {\n+  void finish() {\n@@ -704,1 +355,0 @@\n-    assert(!_heap->mode()->is_generational(), \"Generational GC should use different Closure\");\n@@ -723,1 +373,1 @@\n-      finish_region();\n+      finish();\n@@ -741,1 +391,1 @@\n-    \/\/ Object fits into current region, record new location:\n+    \/\/ Object fits into current region, record new location, if object does not move:\n@@ -744,2 +394,4 @@\n-    _preserved_marks->push_if_necessary(p, p->mark());\n-    p->forward_to(cast_to_oop(_compact_point));\n+    if (_compact_point != cast_from_oop<HeapWord*>(p)) {\n+      _preserved_marks->push_if_necessary(p, p->mark());\n+      p->forward_to(cast_to_oop(_compact_point));\n+    }\n@@ -750,0 +402,5 @@\n+class ShenandoahPrepareForCompactionTask : public WorkerTask {\n+private:\n+  PreservedMarksSet*        const _preserved_marks;\n+  ShenandoahHeap*           const _heap;\n+  ShenandoahHeapRegionSet** const _worker_slices;\n@@ -751,3 +408,2 @@\n-ShenandoahPrepareForCompactionTask::ShenandoahPrepareForCompactionTask(PreservedMarksSet *preserved_marks,\n-                                                                       ShenandoahHeapRegionSet **worker_slices,\n-                                                                       size_t num_workers) :\n+public:\n+  ShenandoahPrepareForCompactionTask(PreservedMarksSet *preserved_marks, ShenandoahHeapRegionSet **worker_slices) :\n@@ -755,2 +411,10 @@\n-    _preserved_marks(preserved_marks), _heap(ShenandoahHeap::heap()),\n-    _worker_slices(worker_slices), _num_workers(num_workers) { }\n+    _preserved_marks(preserved_marks),\n+    _heap(ShenandoahHeap::heap()), _worker_slices(worker_slices) {\n+  }\n+\n+  static bool is_candidate_region(ShenandoahHeapRegion* r) {\n+    \/\/ Empty region: get it into the slice to defragment the slice itself.\n+    \/\/ We could have skipped this without violating correctness, but we really\n+    \/\/ want to compact all live regions to the start of the heap, which sometimes\n+    \/\/ means moving them into the fully empty regions.\n+    if (r->is_empty()) return true;\n@@ -758,0 +422,13 @@\n+    \/\/ Can move the region, and this is not the humongous region. Humongous\n+    \/\/ moves are special cased here, because their moves are handled separately.\n+    return r->is_stw_move_allowed() && !r->is_humongous();\n+  }\n+\n+  void work(uint worker_id) override;\n+private:\n+  template<typename ClosureType>\n+  void prepare_for_compaction(ClosureType& cl,\n+                              GrowableArray<ShenandoahHeapRegion*>& empty_regions,\n+                              ShenandoahHeapRegionSetIterator& it,\n+                              ShenandoahHeapRegion* from_region);\n+};\n@@ -776,2 +453,0 @@\n-    ShenandoahHeapRegion* old_to_region = (from_region->is_old())? from_region: nullptr;\n-    ShenandoahHeapRegion* young_to_region = (from_region->is_young())? from_region: nullptr;\n@@ -779,25 +454,2 @@\n-                                                               empty_regions,\n-                                                               old_to_region, young_to_region,\n-                                                               worker_id);\n-    while (from_region != nullptr) {\n-      assert(is_candidate_region(from_region), \"Sanity\");\n-      log_debug(gc)(\"Worker %u compacting %s Region \" SIZE_FORMAT \" which had used \" SIZE_FORMAT \" and %s live\",\n-                    worker_id, from_region->affiliation_name(),\n-                    from_region->index(), from_region->used(), from_region->has_live()? \"has\": \"does not have\");\n-      cl.set_from_region(from_region);\n-      if (from_region->has_live()) {\n-        _heap->marked_object_iterate(from_region, &cl);\n-      }\n-      \/\/ Compacted the region to somewhere else? From-region is empty then.\n-      if (!cl.is_compact_same_region()) {\n-        empty_regions.append(from_region);\n-      }\n-      from_region = it.next();\n-    }\n-    cl.finish();\n-\n-    \/\/ Mark all remaining regions as empty\n-    for (int pos = cl.empty_regions_pos(); pos < empty_regions.length(); ++pos) {\n-      ShenandoahHeapRegion* r = empty_regions.at(pos);\n-      r->set_new_top(r->bottom());\n-    }\n+                                                               empty_regions, from_region, worker_id);\n+    prepare_for_compaction(cl, empty_regions, it, from_region);\n@@ -806,6 +458,3 @@\n-    while (from_region != nullptr) {\n-      assert(is_candidate_region(from_region), \"Sanity\");\n-      cl.set_from_region(from_region);\n-      if (from_region->has_live()) {\n-        _heap->marked_object_iterate(from_region, &cl);\n-      }\n+    prepare_for_compaction(cl, empty_regions, it, from_region);\n+  }\n+}\n@@ -813,5 +462,10 @@\n-      \/\/ Compacted the region to somewhere else? From-region is empty then.\n-      if (!cl.is_compact_same_region()) {\n-        empty_regions.append(from_region);\n-      }\n-      from_region = it.next();\n+template<typename ClosureType>\n+void ShenandoahPrepareForCompactionTask::prepare_for_compaction(ClosureType& cl,\n+                                                                GrowableArray<ShenandoahHeapRegion*>& empty_regions,\n+                                                                ShenandoahHeapRegionSetIterator& it,\n+                                                                ShenandoahHeapRegion* from_region) {\n+  while (from_region != nullptr) {\n+    assert(is_candidate_region(from_region), \"Sanity\");\n+    cl.set_from_region(from_region);\n+    if (from_region->has_live()) {\n+      _heap->marked_object_iterate(from_region, &cl);\n@@ -819,1 +473,0 @@\n-    cl.finish_region();\n@@ -821,4 +474,3 @@\n-    \/\/ Mark all remaining regions as empty\n-    for (int pos = cl.empty_regions_pos(); pos < empty_regions.length(); ++pos) {\n-      ShenandoahHeapRegion* r = empty_regions.at(pos);\n-      r->set_new_top(r->bottom());\n+    \/\/ Compacted the region to somewhere else? From-region is empty then.\n+    if (!cl.is_compact_same_region()) {\n+      empty_regions.append(from_region);\n@@ -826,0 +478,8 @@\n+    from_region = it.next();\n+  }\n+  cl.finish();\n+\n+  \/\/ Mark all remaining regions as empty\n+  for (int pos = cl.empty_regions_pos(); pos < empty_regions.length(); ++pos) {\n+    ShenandoahHeapRegion* r = empty_regions.at(pos);\n+    r->set_new_top(r->bottom());\n@@ -924,3 +584,1 @@\n-               \"Humongous Start %s Region \" SIZE_FORMAT \" is not marked, should not have live\",\n-               r->affiliation_name(),  r->index());\n-        log_debug(gc)(\"Trashing immediate humongous region \" SIZE_FORMAT \" because not marked\", r->index());\n+               \"Region \" SIZE_FORMAT \" is not marked, should not have live\", r->index());\n@@ -930,1 +588,1 @@\n-               \"Humongous Start %s Region \" SIZE_FORMAT \" should have live\", r->affiliation_name(),  r->index());\n+               \"Region \" SIZE_FORMAT \" should have live\", r->index());\n@@ -935,1 +593,1 @@\n-             \"Humongous Continuation %s Region \" SIZE_FORMAT \" should have live\", r->affiliation_name(),  r->index());\n+             \"Region \" SIZE_FORMAT \" should have live\", r->index());\n@@ -938,1 +596,0 @@\n-        log_debug(gc)(\"Trashing immediate regular region \" SIZE_FORMAT \" because has no live\", r->index());\n@@ -1119,2 +776,1 @@\n-    size_t num_workers = heap->max_workers();\n-\n+    \/\/ TODO: This is ResourceMark is missing upstream.\n@@ -1122,1 +778,1 @@\n-    ShenandoahPrepareForCompactionTask task(_preserved_marks, worker_slices, num_workers);\n+    ShenandoahPrepareForCompactionTask task(_preserved_marks, worker_slices);\n@@ -1196,6 +852,2 @@\n-      if (r->is_pinned() && r->is_old() && r->is_active() && !r->is_humongous()) {\n-        \/\/ Pinned regions are not compacted so they may still hold unmarked objects with\n-        \/\/ reference to reclaimed memory. Remembered set scanning will crash if it attempts\n-        \/\/ to iterate the oops in these objects.\n-        r->begin_preemptible_coalesce_and_fill();\n-        r->oop_fill_and_coalesce_without_cancel();\n+      if (_heap->mode()->is_generational()) {\n+        ShenandoahGenerationalFullGC::maybe_coalesce_and_fill_region(r);\n@@ -1265,0 +917,1 @@\n+      assert(compact_from != compact_to, \"Forwarded object should move\");\n@@ -1303,17 +956,0 @@\n-static void account_for_region(ShenandoahHeapRegion* r, size_t &region_count, size_t &region_usage, size_t &humongous_waste) {\n-  region_count++;\n-  region_usage += r->used();\n-  if (r->is_humongous_start()) {\n-    \/\/ For each humongous object, we take this path once regardless of how many regions it spans.\n-    HeapWord* obj_addr = r->bottom();\n-    oop obj = cast_to_oop(obj_addr);\n-    size_t word_size = obj->size();\n-    size_t region_size_words = ShenandoahHeapRegion::region_size_words();\n-    size_t overreach = word_size % region_size_words;\n-    if (overreach != 0) {\n-      humongous_waste += (region_size_words - overreach) * HeapWordSize;\n-    }\n-    \/\/ else, this humongous object aligns exactly on region size, so no waste.\n-  }\n-}\n-\n@@ -1377,1 +1013,1 @@\n-        account_for_region(r, _old_regions, _old_usage, _old_humongous_waste);\n+        ShenandoahGenerationalFullGC::account_for_region(r, _old_regions, _old_usage, _old_humongous_waste);\n@@ -1379,1 +1015,1 @@\n-        account_for_region(r, _young_regions, _young_usage, _young_humongous_waste);\n+        ShenandoahGenerationalFullGC::account_for_region(r, _young_regions, _young_usage, _young_humongous_waste);\n@@ -1431,7 +1067,3 @@\n-      ContinuationGCSupport::relativize_stack_chunk(cast_to_oop<HeapWord*>(heap->get_region(old_start)->bottom()));\n-      log_debug(gc)(\"Full GC compaction moves humongous object from region \" SIZE_FORMAT \" to region \" SIZE_FORMAT,\n-                    old_start, new_start);\n-\n-      Copy::aligned_conjoint_words(heap->get_region(old_start)->bottom(),\n-                                   heap->get_region(new_start)->bottom(),\n-                                   words_size);\n+      log_debug(gc)(\"Full GC compaction moves humongous object from region \" SIZE_FORMAT \" to region \" SIZE_FORMAT, old_start, new_start);\n+      Copy::aligned_conjoint_words(r->bottom(), heap->get_region(new_start)->bottom(), words_size);\n+      ContinuationGCSupport::relativize_stack_chunk(cast_to_oop<HeapWord*>(r->bottom()));\n@@ -1542,14 +1174,0 @@\n-    if (heap->mode()->is_generational()) {\n-      size_t old_usage = heap->old_generation()->used_regions_size();\n-      size_t old_capacity = heap->old_generation()->max_capacity();\n-\n-      assert(old_usage % ShenandoahHeapRegion::region_size_bytes() == 0, \"Old usage must aligh with region size\");\n-      assert(old_capacity % ShenandoahHeapRegion::region_size_bytes() == 0, \"Old capacity must aligh with region size\");\n-\n-      if (old_capacity > old_usage) {\n-        size_t excess_old_regions = (old_capacity - old_usage) \/ ShenandoahHeapRegion::region_size_bytes();\n-        heap->generation_sizer()->transfer_to_young(excess_old_regions);\n-      } else if (old_capacity < old_usage) {\n-        size_t old_regions_deficit = (old_usage - old_capacity) \/ ShenandoahHeapRegion::region_size_bytes();\n-        heap->generation_sizer()->force_transfer_to_old(old_regions_deficit);\n-      }\n@@ -1557,3 +1175,2 @@\n-      log_info(gc)(\"FullGC done: young usage: \" SIZE_FORMAT \"%s, old usage: \" SIZE_FORMAT \"%s\",\n-                   byte_size_in_proper_unit(heap->young_generation()->used()), proper_unit_for_byte_size(heap->young_generation()->used()),\n-                   byte_size_in_proper_unit(heap->old_generation()->used()),   proper_unit_for_byte_size(heap->old_generation()->used()));\n+    if (heap->mode()->is_generational()) {\n+      ShenandoahGenerationalFullGC::balance_generations_after_gc(heap);\n@@ -1561,0 +1178,1 @@\n+\n@@ -1574,2 +1192,0 @@\n-    \/\/ In case this Full GC resulted from degeneration, clear the tally on anticipated promotion.\n-    heap->clear_promotion_potential();\n@@ -1578,2 +1194,1 @@\n-      \/\/ Invoke this in case we are able to transfer memory from OLD to YOUNG.\n-      heap->adjust_generation_sizes_for_next_cycle(0, 0, 0);\n+      ShenandoahGenerationalFullGC::compute_balances();\n@@ -1581,0 +1196,1 @@\n+\n@@ -1586,33 +1202,2 @@\n-      bool success;\n-      size_t region_xfer;\n-      const char* region_destination;\n-      ShenandoahYoungGeneration* young_gen = heap->young_generation();\n-      ShenandoahGeneration* old_gen = heap->old_generation();\n-\n-      size_t old_region_surplus = heap->get_old_region_surplus();\n-      size_t old_region_deficit = heap->get_old_region_deficit();\n-      if (old_region_surplus) {\n-        success = heap->generation_sizer()->transfer_to_young(old_region_surplus);\n-        region_destination = \"young\";\n-        region_xfer = old_region_surplus;\n-      } else if (old_region_deficit) {\n-        success = heap->generation_sizer()->transfer_to_old(old_region_deficit);\n-        region_destination = \"old\";\n-        region_xfer = old_region_deficit;\n-        if (!success) {\n-          ((ShenandoahOldHeuristics *) old_gen->heuristics())->trigger_cannot_expand();\n-        }\n-      } else {\n-        region_destination = \"none\";\n-        region_xfer = 0;\n-        success = true;\n-      }\n-      heap->set_old_region_surplus(0);\n-      heap->set_old_region_deficit(0);\n-      size_t young_available = young_gen->available();\n-      size_t old_available = old_gen->available();\n-      log_info(gc, ergo)(\"After cleanup, %s \" SIZE_FORMAT \" regions to %s to prepare for next gc, old available: \"\n-                         SIZE_FORMAT \"%s, young_available: \" SIZE_FORMAT \"%s\",\n-                         success? \"successfully transferred\": \"failed to transfer\", region_xfer, region_destination,\n-                         byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n-                         byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n+      ShenandoahGenerationalFullGC::balance_generations_after_rebuilding_free_set();\n+      ShenandoahGenerationalFullGC::rebuild_remembered_set(heap);\n@@ -1622,0 +1207,3 @@\n+\n+  _preserved_marks->restore(heap->workers());\n+  _preserved_marks->reclaim();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":102,"deletions":514,"binary":false,"changes":616,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -154,0 +154,12 @@\n+void ShenandoahGeneration::set_evacuation_reserve(size_t new_val) {\n+  _evacuation_reserve = new_val;\n+}\n+\n+size_t ShenandoahGeneration::get_evacuation_reserve() const {\n+  return _evacuation_reserve;\n+}\n+\n+void ShenandoahGeneration::augment_evacuation_reserve(size_t increment) {\n+  _evacuation_reserve += increment;\n+}\n+\n@@ -234,1 +246,1 @@\n-  ShenandoahGeneration* const old_generation = heap->old_generation();\n+  ShenandoahOldGeneration* const old_generation = heap->old_generation();\n@@ -338,4 +350,3 @@\n-\n-  heap->set_young_evac_reserve(young_evacuation_reserve);\n-  heap->set_old_evac_reserve(old_evacuation_reserve);\n-  heap->set_promoted_reserve(consumed_by_advance_promotion);\n+  young_generation->set_evacuation_reserve(young_evacuation_reserve);\n+  old_generation->set_evacuation_reserve(old_evacuation_reserve);\n+  old_generation->set_promoted_reserve(consumed_by_advance_promotion);\n@@ -367,2 +378,2 @@\n-  const ShenandoahOldGeneration* const old_generation = heap->old_generation();\n-  const ShenandoahYoungGeneration* const young_generation = heap->young_generation();\n+  ShenandoahOldGeneration* const old_generation = heap->old_generation();\n+  ShenandoahYoungGeneration* const young_generation = heap->young_generation();\n@@ -372,1 +383,1 @@\n-  size_t old_evacuation_reserve = heap->get_old_evac_reserve();\n+  size_t old_evacuation_reserve = old_generation->get_evacuation_reserve();\n@@ -384,1 +395,1 @@\n-    heap->set_old_evac_reserve(old_evacuation_reserve);\n+    old_generation->set_evacuation_reserve(old_evacuation_reserve);\n@@ -395,1 +406,1 @@\n-  heap->set_young_evac_reserve(young_evacuated_reserve_used);\n+  young_generation->set_evacuation_reserve(young_evacuated_reserve_used);\n@@ -460,2 +471,2 @@\n-  heap->set_promoted_reserve(total_promotion_reserve);\n-  heap->reset_promoted_expended();\n+  old_generation->set_promoted_reserve(total_promotion_reserve);\n+  old_generation->reset_promoted_expended();\n@@ -511,2 +522,1 @@\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n-  assert(heap->mode()->is_generational(), \"Only in generational mode\");\n+  auto const heap = ShenandoahGenerationalHeap::heap();\n@@ -637,2 +647,3 @@\n-  heap->set_pad_for_promote_in_place(promote_in_place_pad);\n-  heap->set_promotion_potential(promo_potential);\n+\n+  heap->old_generation()->set_pad_for_promote_in_place(promote_in_place_pad);\n+  heap->old_generation()->set_promotion_potential(promo_potential);\n@@ -735,2 +746,1 @@\n-  \/\/ Freeset construction uses reserve quantities if they are valid\n-  heap->set_evacuation_reserve_quantities(true);\n+\n@@ -746,1 +756,2 @@\n-    heap->free_set()->rebuild(young_cset_regions, old_cset_regions);\n+    \/\/ Free set construction uses reserve quantities, because they are known to be valid here\n+    heap->free_set()->rebuild(young_cset_regions, old_cset_regions, true);\n@@ -748,1 +759,0 @@\n-  heap->set_evacuation_reserve_quantities(false);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":31,"deletions":21,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -62,0 +62,3 @@\n+  \/\/ Bytes reserved within this generation to hold evacuated objects from the collection set\n+  size_t _evacuation_reserve;\n+\n@@ -108,1 +111,6 @@\n-  bool is_global() const { return _type == GLOBAL_GEN || _type == GLOBAL_NON_GEN; }\n+  bool is_global() const { return _type == GLOBAL || _type == NON_GEN; }\n+\n+  \/\/ see description in field declaration\n+  void set_evacuation_reserve(size_t new_val);\n+  size_t get_evacuation_reserve() const;\n+  void augment_evacuation_reserve(size_t increment);\n@@ -126,0 +134,3 @@\n+  size_t used_including_humongous_waste() const {\n+    return used() + get_humongous_waste();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,4 +29,4 @@\n-    GLOBAL_NON_GEN,  \/\/ Global, non-generational\n-    GLOBAL_GEN,      \/\/ Global, generational\n-    YOUNG,           \/\/ Young,  generational\n-    OLD              \/\/ Old,    generational\n+    NON_GEN,         \/\/ non-generational\n+    GLOBAL,          \/\/ generational: Global\n+    YOUNG,           \/\/ generational: Young\n+    OLD              \/\/ generational: Old\n@@ -37,3 +37,3 @@\n-    case GLOBAL_NON_GEN:\n-      return \"\";\n-    case GLOBAL_GEN:\n+    case NON_GEN:\n+      return \"Non-Generational\";\n+    case GLOBAL:\n@@ -47,1 +47,1 @@\n-      return \"?\";\n+      return \"Unknown\";\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationType.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,841 @@\n+\/*\n+ * Copyright (c) 2013, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n+#include \"gc\/shenandoah\/shenandoahAsserts.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n+#include \"gc\/shenandoah\/shenandoahConcurrentGC.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalControlThread.hpp\"\n+#include \"gc\/shenandoah\/shenandoahDegeneratedGC.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahFullGC.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGC.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMonitoringSupport.hpp\"\n+#include \"gc\/shenandoah\/shenandoahPacer.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/metaspaceUtils.hpp\"\n+#include \"memory\/metaspaceStats.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+ShenandoahGenerationalControlThread::ShenandoahGenerationalControlThread() :\n+  ShenandoahController(),\n+  _control_lock(Mutex::nosafepoint - 2, \"ShenandoahControlGC_lock\", true),\n+  _regulator_lock(Mutex::nosafepoint - 2, \"ShenandoahRegulatorGC_lock\", true),\n+  _requested_gc_cause(GCCause::_no_gc),\n+  _requested_generation(GLOBAL),\n+  _degen_point(ShenandoahGC::_degenerated_outside_cycle),\n+  _degen_generation(nullptr),\n+  _mode(none) {\n+  shenandoah_assert_generational();\n+  set_name(\"Shenandoah Control Thread\");\n+  create_and_start();\n+}\n+\n+void ShenandoahGenerationalControlThread::run_service() {\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+\n+  const GCMode default_mode = concurrent_normal;\n+  ShenandoahGenerationType generation = GLOBAL;\n+\n+  double last_shrink_time = os::elapsedTime();\n+  uint age_period = 0;\n+\n+  \/\/ Shrink period avoids constantly polling regions for shrinking.\n+  \/\/ Having a period 10x lower than the delay would mean we hit the\n+  \/\/ shrinking with lag of less than 1\/10-th of true delay.\n+  \/\/ ShenandoahUncommitDelay is in msecs, but shrink_period is in seconds.\n+  const double shrink_period = (double)ShenandoahUncommitDelay \/ 1000 \/ 10;\n+\n+  ShenandoahCollectorPolicy* const policy = heap->shenandoah_policy();\n+\n+  \/\/ Heuristics are notified of allocation failures here and other outcomes\n+  \/\/ of the cycle. They're also used here to control whether the Nth consecutive\n+  \/\/ degenerated cycle should be 'promoted' to a full cycle. The decision to\n+  \/\/ trigger a cycle or not is evaluated on the regulator thread.\n+  ShenandoahHeuristics* global_heuristics = heap->global_generation()->heuristics();\n+  while (!in_graceful_shutdown() && !should_terminate()) {\n+    \/\/ Figure out if we have pending requests.\n+    const bool alloc_failure_pending = _alloc_failure_gc.is_set();\n+    const bool humongous_alloc_failure_pending = _humongous_alloc_failure_gc.is_set();\n+\n+    GCCause::Cause cause = Atomic::xchg(&_requested_gc_cause, GCCause::_no_gc);\n+\n+    const bool is_gc_requested = ShenandoahCollectorPolicy::is_requested_gc(cause);\n+\n+    \/\/ This control loop iteration has seen this much allocation.\n+    const size_t allocs_seen = reset_allocs_seen();\n+\n+    \/\/ Check if we have seen a new target for soft max heap size.\n+    const bool soft_max_changed = heap->check_soft_max_changed();\n+\n+    \/\/ Choose which GC mode to run in. The block below should select a single mode.\n+    set_gc_mode(none);\n+    ShenandoahGC::ShenandoahDegenPoint degen_point = ShenandoahGC::_degenerated_unset;\n+\n+    if (alloc_failure_pending) {\n+      \/\/ Allocation failure takes precedence: we have to deal with it first thing\n+      log_info(gc)(\"Trigger: Handle Allocation Failure\");\n+\n+      cause = GCCause::_allocation_failure;\n+\n+      \/\/ Consume the degen point, and seed it with default value\n+      degen_point = _degen_point;\n+      _degen_point = ShenandoahGC::_degenerated_outside_cycle;\n+\n+      if (degen_point == ShenandoahGC::_degenerated_outside_cycle) {\n+        _degen_generation = heap->young_generation();\n+      } else {\n+        assert(_degen_generation != nullptr, \"Need to know which generation to resume\");\n+      }\n+\n+      ShenandoahHeuristics* heuristics = _degen_generation->heuristics();\n+      generation = _degen_generation->type();\n+      bool old_gen_evacuation_failed = heap->old_generation()->clear_failed_evacuation();\n+\n+      \/\/ Do not bother with degenerated cycle if old generation evacuation failed or if humongous allocation failed\n+      if (ShenandoahDegeneratedGC && heuristics->should_degenerate_cycle() &&\n+          !old_gen_evacuation_failed && !humongous_alloc_failure_pending) {\n+        heuristics->record_allocation_failure_gc();\n+        policy->record_alloc_failure_to_degenerated(degen_point);\n+        set_gc_mode(stw_degenerated);\n+      } else {\n+        \/\/ TODO: if humongous_alloc_failure_pending, there might be value in trying a \"compacting\" degen before\n+        \/\/ going all the way to full.  But it's a lot of work to implement this, and it may not provide value.\n+        \/\/ A compacting degen can move young regions around without doing full old-gen mark (relying upon the\n+        \/\/ remembered set scan), so it might be faster than a full gc.\n+        \/\/\n+        \/\/ Longer term, think about how to defragment humongous memory concurrently.\n+\n+        heuristics->record_allocation_failure_gc();\n+        policy->record_alloc_failure_to_full();\n+        generation = GLOBAL;\n+        set_gc_mode(stw_full);\n+      }\n+    } else if (is_gc_requested) {\n+      generation = GLOBAL;\n+      log_info(gc)(\"Trigger: GC request (%s)\", GCCause::to_string(cause));\n+      global_heuristics->record_requested_gc();\n+\n+      if (ShenandoahCollectorPolicy::should_run_full_gc(cause)) {\n+        set_gc_mode(stw_full);\n+      } else {\n+        set_gc_mode(default_mode);\n+        \/\/ Unload and clean up everything\n+        heap->set_unload_classes(global_heuristics->can_unload_classes());\n+      }\n+    } else {\n+      \/\/ We should only be here if the regulator requested a cycle or if\n+      \/\/ there is an old generation mark in progress.\n+      if (cause == GCCause::_shenandoah_concurrent_gc) {\n+        if (_requested_generation == OLD && heap->doing_mixed_evacuations()) {\n+          \/\/ If a request to start an old cycle arrived while an old cycle was running, but _before_\n+          \/\/ it chose any regions for evacuation we don't want to start a new old cycle. Rather, we want\n+          \/\/ the heuristic to run a young collection so that we can evacuate some old regions.\n+          assert(!heap->is_concurrent_old_mark_in_progress(), \"Should not be running mixed collections and concurrent marking\");\n+          generation = YOUNG;\n+        } else {\n+          generation = _requested_generation;\n+        }\n+\n+        \/\/ preemption was requested or this is a regular cycle\n+        set_gc_mode(default_mode);\n+\n+        \/\/ Don't start a new old marking if there is one already in progress\n+        if (generation == OLD && heap->is_concurrent_old_mark_in_progress()) {\n+          set_gc_mode(servicing_old);\n+        }\n+\n+        if (generation == GLOBAL) {\n+          heap->set_unload_classes(global_heuristics->should_unload_classes());\n+        } else {\n+          heap->set_unload_classes(false);\n+        }\n+      } else if (heap->is_concurrent_old_mark_in_progress() || heap->is_prepare_for_old_mark_in_progress()) {\n+        \/\/ Nobody asked us to do anything, but we have an old-generation mark or old-generation preparation for\n+        \/\/ mixed evacuation in progress, so resume working on that.\n+        log_info(gc)(\"Resume old GC: marking is%s in progress, preparing is%s in progress\",\n+                     heap->is_concurrent_old_mark_in_progress() ? \"\" : \" NOT\",\n+                     heap->is_prepare_for_old_mark_in_progress() ? \"\" : \" NOT\");\n+\n+        cause = GCCause::_shenandoah_concurrent_gc;\n+        generation = OLD;\n+        set_gc_mode(servicing_old);\n+        heap->set_unload_classes(false);\n+      }\n+    }\n+\n+    const bool gc_requested = (gc_mode() != none);\n+    assert (!gc_requested || cause != GCCause::_no_gc, \"GC cause should be set\");\n+\n+    if (gc_requested) {\n+      \/\/ Blow away all soft references on this cycle, if handling allocation failure,\n+      \/\/ either implicit or explicit GC request, or we are requested to do so unconditionally.\n+      if (generation == GLOBAL && (alloc_failure_pending || is_gc_requested || ShenandoahAlwaysClearSoftRefs)) {\n+        heap->soft_ref_policy()->set_should_clear_all_soft_refs(true);\n+      }\n+\n+      \/\/ GC is starting, bump the internal ID\n+      update_gc_id();\n+\n+      heap->reset_bytes_allocated_since_gc_start();\n+\n+      MetaspaceCombinedStats meta_sizes = MetaspaceUtils::get_combined_statistics();\n+\n+      \/\/ If GC was requested, we are sampling the counters even without actual triggers\n+      \/\/ from allocation machinery. This captures GC phases more accurately.\n+      heap->set_forced_counters_update(true);\n+\n+      \/\/ If GC was requested, we better dump freeset data for performance debugging\n+      {\n+        ShenandoahHeapLocker locker(heap->lock());\n+        heap->free_set()->log_status();\n+      }\n+      \/\/ In case this is a degenerated cycle, remember whether original cycle was aging.\n+      const bool was_aging_cycle = heap->is_aging_cycle();\n+      heap->set_aging_cycle(false);\n+\n+      switch (gc_mode()) {\n+        case concurrent_normal: {\n+          \/\/ At this point:\n+          \/\/  if (generation == YOUNG), this is a normal YOUNG cycle\n+          \/\/  if (generation == OLD), this is a bootstrap OLD cycle\n+          \/\/  if (generation == GLOBAL), this is a GLOBAL cycle triggered by System.gc()\n+          \/\/ In all three cases, we want to age old objects if this is an aging cycle\n+          if (age_period-- == 0) {\n+             heap->set_aging_cycle(true);\n+             age_period = ShenandoahAgingCyclePeriod - 1;\n+          }\n+          service_concurrent_normal_cycle(heap, generation, cause);\n+          break;\n+        }\n+        case stw_degenerated: {\n+          heap->set_aging_cycle(was_aging_cycle);\n+          service_stw_degenerated_cycle(cause, degen_point);\n+          break;\n+        }\n+        case stw_full: {\n+          if (age_period-- == 0) {\n+            heap->set_aging_cycle(true);\n+            age_period = ShenandoahAgingCyclePeriod - 1;\n+          }\n+          service_stw_full_cycle(cause);\n+          break;\n+        }\n+        case servicing_old: {\n+          assert(generation == OLD, \"Expected old generation here\");\n+          GCIdMark gc_id_mark;\n+          service_concurrent_old_cycle(heap, cause);\n+          break;\n+        }\n+        default:\n+          ShouldNotReachHere();\n+      }\n+\n+      \/\/ If this was the requested GC cycle, notify waiters about it\n+      if (is_gc_requested) {\n+        notify_gc_waiters();\n+      }\n+\n+      \/\/ If this was the allocation failure GC cycle, notify waiters about it\n+      if (alloc_failure_pending) {\n+        notify_alloc_failure_waiters();\n+      }\n+\n+      \/\/ Report current free set state at the end of cycle, whether\n+      \/\/ it is a normal completion, or the abort.\n+      {\n+        ShenandoahHeapLocker locker(heap->lock());\n+        heap->free_set()->log_status();\n+\n+        \/\/ Notify Universe about new heap usage. This has implications for\n+        \/\/ global soft refs policy, and we better report it every time heap\n+        \/\/ usage goes down.\n+        heap->update_capacity_and_used_at_gc();\n+\n+        \/\/ Signal that we have completed a visit to all live objects.\n+        heap->record_whole_heap_examined_timestamp();\n+      }\n+\n+      \/\/ Disable forced counters update, and update counters one more time\n+      \/\/ to capture the state at the end of GC session.\n+      heap->handle_force_counters_update();\n+      heap->set_forced_counters_update(false);\n+\n+      \/\/ Retract forceful part of soft refs policy\n+      heap->soft_ref_policy()->set_should_clear_all_soft_refs(false);\n+\n+      \/\/ Clear metaspace oom flag, if current cycle unloaded classes\n+      if (heap->unload_classes()) {\n+        global_heuristics->clear_metaspace_oom();\n+      }\n+\n+      process_phase_timings(heap);\n+\n+      \/\/ Print Metaspace change following GC (if logging is enabled).\n+      MetaspaceUtils::print_metaspace_change(meta_sizes);\n+\n+      \/\/ GC is over, we are at idle now\n+      if (ShenandoahPacing) {\n+        heap->pacer()->setup_for_idle();\n+      }\n+    } else {\n+      \/\/ Report to pacer that we have seen this many words allocated\n+      if (ShenandoahPacing && (allocs_seen > 0)) {\n+        heap->pacer()->report_alloc(allocs_seen);\n+      }\n+    }\n+\n+    const double current = os::elapsedTime();\n+\n+    if (ShenandoahUncommit && (is_gc_requested || soft_max_changed || (current - last_shrink_time > shrink_period))) {\n+      \/\/ Explicit GC tries to uncommit everything down to min capacity.\n+      \/\/ Soft max change tries to uncommit everything down to target capacity.\n+      \/\/ Periodic uncommit tries to uncommit suitable regions down to min capacity.\n+\n+      double shrink_before = (is_gc_requested || soft_max_changed) ?\n+                             current :\n+                             current - (ShenandoahUncommitDelay \/ 1000.0);\n+\n+      size_t shrink_until = soft_max_changed ?\n+                             heap->soft_max_capacity() :\n+                             heap->min_capacity();\n+\n+      heap->maybe_uncommit(shrink_before, shrink_until);\n+      heap->phase_timings()->flush_cycle_to_global();\n+      last_shrink_time = current;\n+    }\n+\n+    \/\/ Wait for ShenandoahControlIntervalMax unless there was an allocation failure or another request was made mid-cycle.\n+    if (!is_alloc_failure_gc() && _requested_gc_cause == GCCause::_no_gc) {\n+      \/\/ The timed wait is necessary because this thread has a responsibility to send\n+      \/\/ 'alloc_words' to the pacer when it does not perform a GC.\n+      MonitorLocker lock(&_control_lock, Mutex::_no_safepoint_check_flag);\n+      lock.wait(ShenandoahControlIntervalMax);\n+    }\n+  }\n+\n+  \/\/ Wait for the actual stop(), can't leave run_service() earlier.\n+  while (!should_terminate()) {\n+    os::naked_short_sleep(ShenandoahControlIntervalMin);\n+  }\n+}\n+\n+void ShenandoahGenerationalControlThread::process_phase_timings(const ShenandoahHeap* heap) {\n+  \/\/ Commit worker statistics to cycle data\n+  heap->phase_timings()->flush_par_workers_to_cycle();\n+  if (ShenandoahPacing) {\n+    heap->pacer()->flush_stats_to_cycle();\n+  }\n+\n+  ShenandoahEvacuationTracker* evac_tracker = heap->evac_tracker();\n+  ShenandoahCycleStats         evac_stats   = evac_tracker->flush_cycle_to_global();\n+\n+  \/\/ Print GC stats for current cycle\n+  {\n+    LogTarget(Info, gc, stats) lt;\n+    if (lt.is_enabled()) {\n+      ResourceMark rm;\n+      LogStream ls(lt);\n+      heap->phase_timings()->print_cycle_on(&ls);\n+      evac_tracker->print_evacuations_on(&ls, &evac_stats.workers,\n+                                              &evac_stats.mutators);\n+      if (ShenandoahPacing) {\n+        heap->pacer()->print_cycle_on(&ls);\n+      }\n+    }\n+  }\n+\n+  \/\/ Commit statistics to globals\n+  heap->phase_timings()->flush_cycle_to_global();\n+}\n+\n+\/\/ Young and old concurrent cycles are initiated by the regulator. Implicit\n+\/\/ and explicit GC requests are handled by the controller thread and always\n+\/\/ run a global cycle (which is concurrent by default, but may be overridden\n+\/\/ by command line options). Old cycles always degenerate to a global cycle.\n+\/\/ Young cycles are degenerated to complete the young cycle.  Young\n+\/\/ and old degen may upgrade to Full GC.  Full GC may also be\n+\/\/ triggered directly by a System.gc() invocation.\n+\/\/\n+\/\/\n+\/\/      +-----+ Idle +-----+-----------+---------------------+\n+\/\/      |         +        |           |                     |\n+\/\/      |         |        |           |                     |\n+\/\/      |         |        v           |                     |\n+\/\/      |         |  Bootstrap Old +-- | ------------+       |\n+\/\/      |         |   +                |             |       |\n+\/\/      |         |   |                |             |       |\n+\/\/      |         v   v                v             v       |\n+\/\/      |    Resume Old <----------+ Young +--> Young Degen  |\n+\/\/      |     +  +   ^                            +  +       |\n+\/\/      v     |  |   |                            |  |       |\n+\/\/   Global <-+  |   +----------------------------+  |       |\n+\/\/      +        |                                   |       |\n+\/\/      |        v                                   v       |\n+\/\/      +--->  Global Degen +--------------------> Full <----+\n+\/\/\n+void ShenandoahGenerationalControlThread::service_concurrent_normal_cycle(ShenandoahHeap* heap,\n+                                                              const ShenandoahGenerationType generation,\n+                                                              GCCause::Cause cause) {\n+  GCIdMark gc_id_mark;\n+  switch (generation) {\n+    case YOUNG: {\n+      \/\/ Run a young cycle. This might or might not, have interrupted an ongoing\n+      \/\/ concurrent mark in the old generation. We need to think about promotions\n+      \/\/ in this case. Promoted objects should be above the TAMS in the old regions\n+      \/\/ they end up in, but we have to be sure we don't promote into any regions\n+      \/\/ that are in the cset.\n+      log_info(gc, ergo)(\"Start GC cycle (YOUNG)\");\n+      service_concurrent_cycle(heap->young_generation(), cause, false);\n+      break;\n+    }\n+    case OLD: {\n+      log_info(gc, ergo)(\"Start GC cycle (OLD)\");\n+      service_concurrent_old_cycle(heap, cause);\n+      break;\n+    }\n+    case GLOBAL: {\n+      log_info(gc, ergo)(\"Start GC cycle (GLOBAL)\");\n+      service_concurrent_cycle(heap->global_generation(), cause, false);\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void ShenandoahGenerationalControlThread::service_concurrent_old_cycle(ShenandoahHeap* heap, GCCause::Cause &cause) {\n+  ShenandoahOldGeneration* old_generation = heap->old_generation();\n+  ShenandoahYoungGeneration* young_generation = heap->young_generation();\n+  ShenandoahOldGeneration::State original_state = old_generation->state();\n+\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+\n+  switch (original_state) {\n+    case ShenandoahOldGeneration::FILLING: {\n+      _allow_old_preemption.set();\n+      old_generation->entry_coalesce_and_fill();\n+      _allow_old_preemption.unset();\n+\n+      \/\/ Before bootstrapping begins, we must acknowledge any cancellation request.\n+      \/\/ If the gc has not been cancelled, this does nothing. If it has been cancelled,\n+      \/\/ this will clear the cancellation request and exit before starting the bootstrap\n+      \/\/ phase. This will allow the young GC cycle to proceed normally. If we do not\n+      \/\/ acknowledge the cancellation request, the subsequent young cycle will observe\n+      \/\/ the request and essentially cancel itself.\n+      if (check_cancellation_or_degen(ShenandoahGC::_degenerated_outside_cycle)) {\n+        log_info(gc)(\"Preparation for old generation cycle was cancelled\");\n+        return;\n+      }\n+\n+      \/\/ Coalescing threads completed and nothing was cancelled. it is safe to transition from this state.\n+      old_generation->transition_to(ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP);\n+      return;\n+    }\n+    case ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP:\n+      old_generation->transition_to(ShenandoahOldGeneration::BOOTSTRAPPING);\n+    case ShenandoahOldGeneration::BOOTSTRAPPING: {\n+      \/\/ Configure the young generation's concurrent mark to put objects in\n+      \/\/ old regions into the concurrent mark queues associated with the old\n+      \/\/ generation. The young cycle will run as normal except that rather than\n+      \/\/ ignore old references it will mark and enqueue them in the old concurrent\n+      \/\/ task queues but it will not traverse them.\n+      set_gc_mode(bootstrapping_old);\n+      young_generation->set_old_gen_task_queues(old_generation->task_queues());\n+      ShenandoahGCSession session(cause, young_generation);\n+      service_concurrent_cycle(heap, young_generation, cause, true);\n+      process_phase_timings(heap);\n+      if (heap->cancelled_gc()) {\n+        \/\/ Young generation bootstrap cycle has failed. Concurrent mark for old generation\n+        \/\/ is going to resume after degenerated bootstrap cycle completes.\n+        log_info(gc)(\"Bootstrap cycle for old generation was cancelled\");\n+        return;\n+      }\n+\n+      \/\/ Reset the degenerated point. Normally this would happen at the top\n+      \/\/ of the control loop, but here we have just completed a young cycle\n+      \/\/ which has bootstrapped the old concurrent marking.\n+      _degen_point = ShenandoahGC::_degenerated_outside_cycle;\n+\n+      \/\/ From here we will 'resume' the old concurrent mark. This will skip reset\n+      \/\/ and init mark for the concurrent mark. All of that work will have been\n+      \/\/ done by the bootstrapping young cycle.\n+      set_gc_mode(servicing_old);\n+      old_generation->transition_to(ShenandoahOldGeneration::MARKING);\n+    }\n+    case ShenandoahOldGeneration::MARKING: {\n+      ShenandoahGCSession session(cause, old_generation);\n+      bool marking_complete = resume_concurrent_old_cycle(old_generation, cause);\n+      if (marking_complete) {\n+        assert(old_generation->state() != ShenandoahOldGeneration::MARKING, \"Should not still be marking\");\n+        if (original_state == ShenandoahOldGeneration::MARKING) {\n+          heap->mmu_tracker()->record_old_marking_increment(true);\n+          heap->log_heap_status(\"At end of Concurrent Old Marking finishing increment\");\n+        }\n+      } else if (original_state == ShenandoahOldGeneration::MARKING) {\n+        heap->mmu_tracker()->record_old_marking_increment(false);\n+        heap->log_heap_status(\"At end of Concurrent Old Marking increment\");\n+      }\n+      break;\n+    }\n+    default:\n+      fatal(\"Unexpected state for old GC: %s\", ShenandoahOldGeneration::state_name(old_generation->state()));\n+  }\n+}\n+\n+bool ShenandoahGenerationalControlThread::resume_concurrent_old_cycle(ShenandoahGeneration* generation, GCCause::Cause cause) {\n+  assert(ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress(), \"Old mark should be in progress\");\n+  log_debug(gc)(\"Resuming old generation with \" UINT32_FORMAT \" marking tasks queued\", generation->task_queues()->tasks());\n+\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  \/\/ We can only tolerate being cancelled during concurrent marking or during preparation for mixed\n+  \/\/ evacuation. This flag here (passed by reference) is used to control precisely where the regulator\n+  \/\/ is allowed to cancel a GC.\n+  ShenandoahOldGC gc(generation, _allow_old_preemption);\n+  if (gc.collect(cause)) {\n+    generation->record_success_concurrent(false);\n+  }\n+\n+  if (heap->cancelled_gc()) {\n+    \/\/ It's possible the gc cycle was cancelled after the last time\n+    \/\/ the collection checked for cancellation. In which case, the\n+    \/\/ old gc cycle is still completed, and we have to deal with this\n+    \/\/ cancellation. We set the degeneration point to be outside\n+    \/\/ the cycle because if this is an allocation failure, that is\n+    \/\/ what must be done (there is no degenerated old cycle). If the\n+    \/\/ cancellation was due to a heuristic wanting to start a young\n+    \/\/ cycle, then we are not actually going to a degenerated cycle,\n+    \/\/ so the degenerated point doesn't matter here.\n+    check_cancellation_or_degen(ShenandoahGC::_degenerated_outside_cycle);\n+    if (_requested_gc_cause == GCCause::_shenandoah_concurrent_gc) {\n+      heap->shenandoah_policy()->record_interrupted_old();\n+    }\n+    return false;\n+  }\n+  return true;\n+}\n+\n+void ShenandoahGenerationalControlThread::service_concurrent_cycle(ShenandoahGeneration* generation, GCCause::Cause cause, bool do_old_gc_bootstrap) {\n+  \/\/ Normal cycle goes via all concurrent phases. If allocation failure (af) happens during\n+  \/\/ any of the concurrent phases, it first degrades to Degenerated GC and completes GC there.\n+  \/\/ If second allocation failure happens during Degenerated GC cycle (for example, when GC\n+  \/\/ tries to evac something and no memory is available), cycle degrades to Full GC.\n+  \/\/\n+  \/\/ There are also a shortcut through the normal cycle: immediate garbage shortcut, when\n+  \/\/ heuristics says there are no regions to compact, and all the collection comes from immediately\n+  \/\/ reclaimable regions.\n+  \/\/\n+  \/\/ ................................................................................................\n+  \/\/\n+  \/\/                                    (immediate garbage shortcut)                Concurrent GC\n+  \/\/                             \/-------------------------------------------\\\n+  \/\/                             |                                           |\n+  \/\/                             |                                           |\n+  \/\/                             |                                           |\n+  \/\/                             |                                           v\n+  \/\/ [START] ----> Conc Mark ----o----> Conc Evac --o--> Conc Update-Refs ---o----> [END]\n+  \/\/                   |                    |                 |              ^\n+  \/\/                   | (af)               | (af)            | (af)         |\n+  \/\/ ..................|....................|.................|..............|.......................\n+  \/\/                   |                    |                 |              |\n+  \/\/                   |                    |                 |              |      Degenerated GC\n+  \/\/                   v                    v                 v              |\n+  \/\/               STW Mark ----------> STW Evac ----> STW Update-Refs ----->o\n+  \/\/                   |                    |                 |              ^\n+  \/\/                   | (af)               | (af)            | (af)         |\n+  \/\/ ..................|....................|.................|..............|.......................\n+  \/\/                   |                    |                 |              |\n+  \/\/                   |                    v                 |              |      Full GC\n+  \/\/                   \\------------------->o<----------------\/              |\n+  \/\/                                        |                                |\n+  \/\/                                        v                                |\n+  \/\/                                      Full GC  --------------------------\/\n+  \/\/\n+  if (check_cancellation_or_degen(ShenandoahGC::_degenerated_outside_cycle)) return;\n+\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahGCSession session(cause, generation);\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+\n+  service_concurrent_cycle(heap, generation, cause, do_old_gc_bootstrap);\n+}\n+\n+void ShenandoahGenerationalControlThread::service_concurrent_cycle(ShenandoahHeap* heap,\n+                                                       ShenandoahGeneration* generation,\n+                                                       GCCause::Cause& cause,\n+                                                       bool do_old_gc_bootstrap) {\n+  assert(!generation->is_old(), \"Old GC takes a different control path\");\n+\n+  ShenandoahConcurrentGC gc(generation, do_old_gc_bootstrap);\n+  if (gc.collect(cause)) {\n+    \/\/ Cycle is complete\n+    generation->record_success_concurrent(gc.abbreviated());\n+  } else {\n+    assert(heap->cancelled_gc(), \"Must have been cancelled\");\n+    check_cancellation_or_degen(gc.degen_point());\n+\n+    \/\/ Concurrent young-gen collection degenerates to young\n+    \/\/ collection.  Same for global collections.\n+    _degen_generation = generation;\n+  }\n+  const char* msg;\n+  ShenandoahMmuTracker* mmu_tracker = heap->mmu_tracker();\n+  if (generation->is_young()) {\n+    if (heap->cancelled_gc()) {\n+      msg = (do_old_gc_bootstrap) ? \"At end of Interrupted Concurrent Bootstrap GC\" :\n+            \"At end of Interrupted Concurrent Young GC\";\n+    } else {\n+      \/\/ We only record GC results if GC was successful\n+      msg = (do_old_gc_bootstrap) ? \"At end of Concurrent Bootstrap GC\" :\n+            \"At end of Concurrent Young GC\";\n+      if (heap->collection_set()->has_old_regions()) {\n+        mmu_tracker->record_mixed(get_gc_id());\n+      } else if (do_old_gc_bootstrap) {\n+        mmu_tracker->record_bootstrap(get_gc_id());\n+      } else {\n+        mmu_tracker->record_young(get_gc_id());\n+      }\n+    }\n+  } else {\n+    assert(generation->is_global(), \"If not young, must be GLOBAL\");\n+    assert(!do_old_gc_bootstrap, \"Do not bootstrap with GLOBAL GC\");\n+    if (heap->cancelled_gc()) {\n+      msg = \"At end of Interrupted Concurrent GLOBAL GC\";\n+    } else {\n+      \/\/ We only record GC results if GC was successful\n+      msg = \"At end of Concurrent Global GC\";\n+      mmu_tracker->record_global(get_gc_id());\n+    }\n+  }\n+  heap->log_heap_status(msg);\n+}\n+\n+bool ShenandoahGenerationalControlThread::check_cancellation_or_degen(ShenandoahGC::ShenandoahDegenPoint point) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (!heap->cancelled_gc()) {\n+    return false;\n+  }\n+\n+  if (in_graceful_shutdown()) {\n+    return true;\n+  }\n+\n+  assert(_degen_point == ShenandoahGC::_degenerated_outside_cycle,\n+         \"Should not be set yet: %s\", ShenandoahGC::degen_point_to_string(_degen_point));\n+\n+  if (is_alloc_failure_gc()) {\n+    _degen_point = point;\n+    _preemption_requested.unset();\n+    return true;\n+  }\n+\n+  if (_preemption_requested.is_set()) {\n+    assert(_requested_generation == YOUNG, \"Only young GCs may preempt old.\");\n+    _preemption_requested.unset();\n+\n+    \/\/ Old generation marking is only cancellable during concurrent marking.\n+    \/\/ Once final mark is complete, the code does not check again for cancellation.\n+    \/\/ If old generation was cancelled for an allocation failure, we wouldn't\n+    \/\/ make it to this case. The calling code is responsible for forcing a\n+    \/\/ cancellation due to allocation failure into a degenerated cycle.\n+    _degen_point = point;\n+    heap->clear_cancelled_gc(false \/* clear oom handler *\/);\n+    return true;\n+  }\n+\n+  fatal(\"Cancel GC either for alloc failure GC, or gracefully exiting, or to pause old generation marking\");\n+  return false;\n+}\n+\n+void ShenandoahGenerationalControlThread::stop_service() {\n+  \/\/ Nothing to do here.\n+}\n+\n+void ShenandoahGenerationalControlThread::service_stw_full_cycle(GCCause::Cause cause) {\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+\n+  GCIdMark gc_id_mark;\n+  ShenandoahGCSession session(cause, heap->global_generation());\n+\n+  ShenandoahFullGC gc;\n+  gc.collect(cause);\n+}\n+\n+void ShenandoahGenerationalControlThread::service_stw_degenerated_cycle(GCCause::Cause cause,\n+                                                            ShenandoahGC::ShenandoahDegenPoint point) {\n+  assert(point != ShenandoahGC::_degenerated_unset, \"Degenerated point should be set\");\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+\n+  GCIdMark gc_id_mark;\n+  ShenandoahGCSession session(cause, _degen_generation);\n+\n+  ShenandoahDegenGC gc(point, _degen_generation);\n+  gc.collect(cause);\n+\n+  assert(heap->young_generation()->task_queues()->is_empty(), \"Unexpected young generation marking tasks\");\n+  if (_degen_generation->is_global()) {\n+    assert(heap->old_generation()->task_queues()->is_empty(), \"Unexpected old generation marking tasks\");\n+    assert(heap->global_generation()->task_queues()->is_empty(), \"Unexpected global generation marking tasks\");\n+  } else {\n+    assert(_degen_generation->is_young(), \"Expected degenerated young cycle, if not global.\");\n+    ShenandoahOldGeneration* old = heap->old_generation();\n+    if (old->state() == ShenandoahOldGeneration::BOOTSTRAPPING) {\n+      old->transition_to(ShenandoahOldGeneration::MARKING);\n+    }\n+  }\n+}\n+\n+void ShenandoahGenerationalControlThread::request_gc(GCCause::Cause cause) {\n+  if (ShenandoahCollectorPolicy::should_handle_requested_gc(cause)) {\n+    handle_requested_gc(cause);\n+  }\n+}\n+\n+bool ShenandoahGenerationalControlThread::request_concurrent_gc(ShenandoahGenerationType generation) {\n+  if (_preemption_requested.is_set() || _requested_gc_cause != GCCause::_no_gc || ShenandoahHeap::heap()->cancelled_gc()) {\n+    \/\/ Ignore subsequent requests from the heuristics\n+    log_debug(gc, thread)(\"Reject request for concurrent gc: preemption_requested: %s, gc_requested: %s, gc_cancelled: %s\",\n+                          BOOL_TO_STR(_preemption_requested.is_set()),\n+                          GCCause::to_string(_requested_gc_cause),\n+                          BOOL_TO_STR(ShenandoahHeap::heap()->cancelled_gc()));\n+    return false;\n+  }\n+\n+  if (gc_mode() == none) {\n+    GCCause::Cause existing = Atomic::cmpxchg(&_requested_gc_cause, GCCause::_no_gc, GCCause::_shenandoah_concurrent_gc);\n+    if (existing != GCCause::_no_gc) {\n+      log_debug(gc, thread)(\"Reject request for concurrent gc because another gc is pending: %s\", GCCause::to_string(existing));\n+      return false;\n+    }\n+\n+    _requested_generation = generation;\n+    notify_control_thread();\n+\n+    MonitorLocker ml(&_regulator_lock, Mutex::_no_safepoint_check_flag);\n+    while (gc_mode() == none) {\n+      ml.wait();\n+    }\n+    return true;\n+  }\n+\n+  if (preempt_old_marking(generation)) {\n+    assert(gc_mode() == servicing_old, \"Expected to be servicing old, but was: %s.\", gc_mode_name(gc_mode()));\n+    GCCause::Cause existing = Atomic::cmpxchg(&_requested_gc_cause, GCCause::_no_gc, GCCause::_shenandoah_concurrent_gc);\n+    if (existing != GCCause::_no_gc) {\n+      log_debug(gc, thread)(\"Reject request to interrupt old gc because another gc is pending: %s\", GCCause::to_string(existing));\n+      return false;\n+    }\n+\n+    log_info(gc)(\"Preempting old generation mark to allow %s GC\", shenandoah_generation_name(generation));\n+    _requested_generation = generation;\n+    _preemption_requested.set();\n+    ShenandoahHeap::heap()->cancel_gc(GCCause::_shenandoah_concurrent_gc);\n+    notify_control_thread();\n+\n+    MonitorLocker ml(&_regulator_lock, Mutex::_no_safepoint_check_flag);\n+    while (gc_mode() == servicing_old) {\n+      ml.wait();\n+    }\n+    return true;\n+  }\n+\n+  log_debug(gc, thread)(\"Reject request for concurrent gc: mode: %s, allow_old_preemption: %s\",\n+                        gc_mode_name(gc_mode()),\n+                        BOOL_TO_STR(_allow_old_preemption.is_set()));\n+  return false;\n+}\n+\n+void ShenandoahGenerationalControlThread::notify_control_thread() {\n+  MonitorLocker locker(&_control_lock, Mutex::_no_safepoint_check_flag);\n+  _control_lock.notify();\n+}\n+\n+bool ShenandoahGenerationalControlThread::preempt_old_marking(ShenandoahGenerationType generation) {\n+  return (generation == YOUNG) && _allow_old_preemption.try_unset();\n+}\n+\n+void ShenandoahGenerationalControlThread::handle_requested_gc(GCCause::Cause cause) {\n+  \/\/ Make sure we have at least one complete GC cycle before unblocking\n+  \/\/ from the explicit GC request.\n+  \/\/\n+  \/\/ This is especially important for weak references cleanup and\/or native\n+  \/\/ resources (e.g. DirectByteBuffers) machinery: when explicit GC request\n+  \/\/ comes very late in the already running cycle, it would miss lots of new\n+  \/\/ opportunities for cleanup that were made available before the caller\n+  \/\/ requested the GC.\n+\n+  MonitorLocker ml(&_gc_waiters_lock);\n+  size_t current_gc_id = get_gc_id();\n+  size_t required_gc_id = current_gc_id + 1;\n+  while (current_gc_id < required_gc_id) {\n+    \/\/ This races with the regulator thread to start a concurrent gc and the\n+    \/\/ control thread to clear it at the start of a cycle. Threads here are\n+    \/\/ allowed to escalate a heuristic's request for concurrent gc.\n+    GCCause::Cause existing = Atomic::xchg(&_requested_gc_cause, cause);\n+    if (existing != GCCause::_no_gc) {\n+      log_debug(gc, thread)(\"GC request supersedes existing request: %s\", GCCause::to_string(existing));\n+    }\n+\n+    notify_control_thread();\n+    if (cause != GCCause::_wb_breakpoint) {\n+      ml.wait();\n+    }\n+    current_gc_id = get_gc_id();\n+  }\n+}\n+\n+void ShenandoahGenerationalControlThread::notify_gc_waiters() {\n+  MonitorLocker ml(&_gc_waiters_lock);\n+  ml.notify_all();\n+}\n+\n+const char* ShenandoahGenerationalControlThread::gc_mode_name(ShenandoahGenerationalControlThread::GCMode mode) {\n+  switch (mode) {\n+    case none:              return \"idle\";\n+    case concurrent_normal: return \"normal\";\n+    case stw_degenerated:   return \"degenerated\";\n+    case stw_full:          return \"full\";\n+    case servicing_old:     return \"old\";\n+    case bootstrapping_old: return \"bootstrap\";\n+    default:                return \"unknown\";\n+  }\n+}\n+\n+void ShenandoahGenerationalControlThread::set_gc_mode(ShenandoahGenerationalControlThread::GCMode new_mode) {\n+  if (_mode != new_mode) {\n+    log_info(gc)(\"Transition from: %s to: %s\", gc_mode_name(_mode), gc_mode_name(new_mode));\n+    MonitorLocker ml(&_regulator_lock, Mutex::_no_safepoint_check_flag);\n+    _mode = new_mode;\n+    ml.notify_all();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":841,"deletions":0,"binary":false,"changes":841,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2013, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONALCONTROLTHREAD_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONALCONTROLTHREAD_HPP\n+\n+#include \"gc\/shared\/gcCause.hpp\"\n+#include \"gc\/shenandoah\/shenandoahController.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGC.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahPadding.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n+\n+class ShenandoahGenerationalControlThread: public ShenandoahController {\n+  friend class VMStructs;\n+\n+public:\n+  typedef enum {\n+    none,\n+    concurrent_normal,\n+    stw_degenerated,\n+    stw_full,\n+    bootstrapping_old,\n+    servicing_old\n+  } GCMode;\n+\n+private:\n+  Monitor _control_lock;\n+  Monitor _regulator_lock;\n+\n+  ShenandoahSharedFlag _allow_old_preemption;\n+  ShenandoahSharedFlag _preemption_requested;\n+\n+  GCCause::Cause  _requested_gc_cause;\n+  volatile ShenandoahGenerationType _requested_generation;\n+  ShenandoahGC::ShenandoahDegenPoint _degen_point;\n+  ShenandoahGeneration* _degen_generation;\n+\n+  shenandoah_padding(0);\n+  volatile GCMode _mode;\n+  shenandoah_padding(1);\n+\n+public:\n+  ShenandoahGenerationalControlThread();\n+\n+  void run_service() override;\n+  void stop_service() override;\n+\n+  void request_gc(GCCause::Cause cause) override;\n+\n+  \/\/ Return true if the request to start a concurrent GC for the given generation succeeded.\n+  bool request_concurrent_gc(ShenandoahGenerationType generation);\n+\n+  GCMode gc_mode() {\n+    return _mode;\n+  }\n+private:\n+\n+  \/\/ Returns true if the cycle has been cancelled or degenerated.\n+  bool check_cancellation_or_degen(ShenandoahGC::ShenandoahDegenPoint point);\n+\n+  \/\/ Returns true if the old generation marking completed (i.e., final mark executed for old generation).\n+  bool resume_concurrent_old_cycle(ShenandoahGeneration* generation, GCCause::Cause cause);\n+  void service_concurrent_cycle(ShenandoahGeneration* generation, GCCause::Cause cause, bool reset_old_bitmap_specially);\n+  void service_stw_full_cycle(GCCause::Cause cause);\n+  void service_stw_degenerated_cycle(GCCause::Cause cause, ShenandoahGC::ShenandoahDegenPoint point);\n+\n+  void notify_gc_waiters();\n+\n+  \/\/ Handle GC request.\n+  \/\/ Blocks until GC is over.\n+  void handle_requested_gc(GCCause::Cause cause);\n+\n+  bool is_explicit_gc(GCCause::Cause cause) const;\n+  bool is_implicit_gc(GCCause::Cause cause) const;\n+\n+  \/\/ Returns true if the old generation marking was interrupted to allow a young cycle.\n+  bool preempt_old_marking(ShenandoahGenerationType generation);\n+\n+  void process_phase_timings(const ShenandoahHeap* heap);\n+\n+  void service_concurrent_normal_cycle(ShenandoahHeap* heap,\n+                                       ShenandoahGenerationType generation,\n+                                       GCCause::Cause cause);\n+\n+  void service_concurrent_old_cycle(ShenandoahHeap* heap,\n+                                    GCCause::Cause &cause);\n+\n+  void set_gc_mode(GCMode new_mode);\n+\n+  static const char* gc_mode_name(GCMode mode);\n+\n+  void notify_control_thread();\n+\n+  void service_concurrent_cycle(ShenandoahHeap* heap,\n+                                ShenandoahGeneration* generation,\n+                                GCCause::Cause &cause,\n+                                bool do_old_gc_bootstrap);\n+\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONALCONTROLTHREAD_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.hpp","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,378 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shared\/preservedMarks.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalFullGC.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n+\n+#ifdef ASSERT\n+void assert_regions_used_not_more_than_capacity(ShenandoahGeneration* generation) {\n+  assert(generation->used_regions_size() <= generation->max_capacity(),\n+         \"%s generation affiliated regions must be less than capacity\", generation->name());\n+}\n+\n+void assert_usage_not_more_than_regions_used(ShenandoahGeneration* generation) {\n+  assert(generation->used_including_humongous_waste() <= generation->used_regions_size(),\n+         \"%s consumed can be no larger than span of affiliated regions\", generation->name());\n+}\n+#else\n+void assert_regions_used_not_more_than_capacity(ShenandoahGeneration* generation) {}\n+void assert_usage_not_more_than_regions_used(ShenandoahGeneration* generation) {}\n+#endif\n+\n+\n+void ShenandoahGenerationalFullGC::prepare() {\n+  auto heap = ShenandoahGenerationalHeap::heap();\n+  \/\/ Since we may arrive here from degenerated GC failure of either young or old, establish generation as GLOBAL.\n+  heap->set_gc_generation(heap->global_generation());\n+\n+  \/\/ No need for old_gen->increase_used() as this was done when plabs were allocated.\n+  heap->reset_generation_reserves();\n+\n+  \/\/ Full GC supersedes any marking or coalescing in old generation.\n+  heap->cancel_old_gc();\n+}\n+\n+void ShenandoahGenerationalFullGC::handle_completion(ShenandoahHeap* heap) {\n+  \/\/ Full GC should reset time since last gc for young and old heuristics\n+  ShenandoahYoungGeneration* young = heap->young_generation();\n+  ShenandoahOldGeneration* old = heap->old_generation();\n+  young->heuristics()->record_cycle_end();\n+  old->heuristics()->record_cycle_end();\n+\n+  heap->mmu_tracker()->record_full(GCId::current());\n+  heap->log_heap_status(\"At end of Full GC\");\n+\n+  assert(old->state() == ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP,\n+         \"After full GC, old generation should be waiting for bootstrap.\");\n+\n+  \/\/ Since we allow temporary violation of these constraints during Full GC, we want to enforce that the assertions are\n+  \/\/ made valid by the time Full GC completes.\n+  assert_regions_used_not_more_than_capacity(old);\n+  assert_regions_used_not_more_than_capacity(young);\n+  assert_usage_not_more_than_regions_used(old);\n+  assert_usage_not_more_than_regions_used(young);\n+\n+  \/\/ Establish baseline for next old-has-grown trigger.\n+  old->set_live_bytes_after_last_mark(old->used_including_humongous_waste());\n+}\n+\n+void ShenandoahGenerationalFullGC::rebuild_remembered_set(ShenandoahHeap* heap) {\n+  ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_reconstruct_remembered_set);\n+  ShenandoahRegionIterator regions;\n+  ShenandoahReconstructRememberedSetTask task(&regions);\n+  heap->workers()->run_task(&task);\n+}\n+\n+void ShenandoahGenerationalFullGC::balance_generations_after_gc(ShenandoahHeap* heap) {\n+  size_t old_usage = heap->old_generation()->used_regions_size();\n+  size_t old_capacity = heap->old_generation()->max_capacity();\n+\n+  assert(old_usage % ShenandoahHeapRegion::region_size_bytes() == 0, \"Old usage must align with region size\");\n+  assert(old_capacity % ShenandoahHeapRegion::region_size_bytes() == 0, \"Old capacity must align with region size\");\n+\n+  if (old_capacity > old_usage) {\n+    size_t excess_old_regions = (old_capacity - old_usage) \/ ShenandoahHeapRegion::region_size_bytes();\n+    heap->generation_sizer()->transfer_to_young(excess_old_regions);\n+  } else if (old_capacity < old_usage) {\n+    size_t old_regions_deficit = (old_usage - old_capacity) \/ ShenandoahHeapRegion::region_size_bytes();\n+    heap->generation_sizer()->force_transfer_to_old(old_regions_deficit);\n+  }\n+\n+  log_info(gc)(\"FullGC done: young usage: \" PROPERFMT \", old usage: \" PROPERFMT,\n+               PROPERFMTARGS(heap->young_generation()->used()),\n+               PROPERFMTARGS(heap->old_generation()->used()));\n+}\n+\n+void ShenandoahGenerationalFullGC::balance_generations_after_rebuilding_free_set() {\n+  auto result = ShenandoahGenerationalHeap::heap()->balance_generations();\n+  LogTarget(Info, gc, ergo) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    result.print_on(\"Full GC\", &ls);\n+  }\n+}\n+\n+void ShenandoahGenerationalFullGC::log_live_in_old(ShenandoahHeap* heap) {\n+  LogTarget(Info, gc) lt;\n+  if (lt.is_enabled()) {\n+    size_t live_bytes_in_old = 0;\n+    for (size_t i = 0; i < heap->num_regions(); i++) {\n+      ShenandoahHeapRegion* r = heap->get_region(i);\n+      if (r->is_old()) {\n+        live_bytes_in_old += r->get_live_data_bytes();\n+      }\n+    }\n+    log_info(gc)(\"Live bytes in old after STW mark: \" PROPERFMT, PROPERFMTARGS(live_bytes_in_old));\n+  }\n+}\n+\n+void ShenandoahGenerationalFullGC::restore_top_before_promote(ShenandoahHeap* heap) {\n+  for (size_t i = 0; i < heap->num_regions(); i++) {\n+    ShenandoahHeapRegion* r = heap->get_region(i);\n+    if (r->get_top_before_promote() != nullptr) {\n+      r->restore_top_before_promote();\n+    }\n+  }\n+}\n+\n+void ShenandoahGenerationalFullGC::account_for_region(ShenandoahHeapRegion* r, size_t &region_count, size_t &region_usage, size_t &humongous_waste) {\n+  region_count++;\n+  region_usage += r->used();\n+  if (r->is_humongous_start()) {\n+    \/\/ For each humongous object, we take this path once regardless of how many regions it spans.\n+    HeapWord* obj_addr = r->bottom();\n+    oop obj = cast_to_oop(obj_addr);\n+    size_t word_size = obj->size();\n+    size_t region_size_words = ShenandoahHeapRegion::region_size_words();\n+    size_t overreach = word_size % region_size_words;\n+    if (overreach != 0) {\n+      humongous_waste += (region_size_words - overreach) * HeapWordSize;\n+    }\n+    \/\/ else, this humongous object aligns exactly on region size, so no waste.\n+  }\n+}\n+\n+void ShenandoahGenerationalFullGC::maybe_coalesce_and_fill_region(ShenandoahHeapRegion* r) {\n+  if (r->is_pinned() && r->is_old() && r->is_active() && !r->is_humongous()) {\n+    r->begin_preemptible_coalesce_and_fill();\n+    r->oop_fill_and_coalesce_without_cancel();\n+  }\n+}\n+\n+void ShenandoahGenerationalFullGC::compute_balances() {\n+  auto heap = ShenandoahGenerationalHeap::heap();\n+\n+  \/\/ In case this Full GC resulted from degeneration, clear the tally on anticipated promotion.\n+  heap->old_generation()->set_promotion_potential(0);\n+  \/\/ Invoke this in case we are able to transfer memory from OLD to YOUNG.\n+  heap->compute_old_generation_balance(0, 0);\n+}\n+\n+ShenandoahPrepareForGenerationalCompactionObjectClosure::ShenandoahPrepareForGenerationalCompactionObjectClosure(PreservedMarks* preserved_marks,\n+                                                          GrowableArray<ShenandoahHeapRegion*>& empty_regions,\n+                                                          ShenandoahHeapRegion* from_region, uint worker_id) :\n+        _preserved_marks(preserved_marks),\n+        _heap(ShenandoahHeap::heap()),\n+        _tenuring_threshold(0),\n+        _empty_regions(empty_regions),\n+        _empty_regions_pos(0),\n+        _old_to_region(nullptr),\n+        _young_to_region(nullptr),\n+        _from_region(nullptr),\n+        _from_affiliation(ShenandoahAffiliation::FREE),\n+        _old_compact_point(nullptr),\n+        _young_compact_point(nullptr),\n+        _worker_id(worker_id) {\n+  assert(from_region != nullptr, \"Worker needs from_region\");\n+  \/\/ assert from_region has live?\n+  if (from_region->is_old()) {\n+    _old_to_region = from_region;\n+    _old_compact_point = from_region->bottom();\n+  } else if (from_region->is_young()) {\n+    _young_to_region = from_region;\n+    _young_compact_point = from_region->bottom();\n+  }\n+\n+  _tenuring_threshold = _heap->age_census()->tenuring_threshold();\n+}\n+\n+void ShenandoahPrepareForGenerationalCompactionObjectClosure::set_from_region(ShenandoahHeapRegion* from_region) {\n+  log_debug(gc)(\"Worker %u compacting %s Region \" SIZE_FORMAT \" which had used \" SIZE_FORMAT \" and %s live\",\n+                _worker_id, from_region->affiliation_name(),\n+                from_region->index(), from_region->used(), from_region->has_live()? \"has\": \"does not have\");\n+\n+  _from_region = from_region;\n+  _from_affiliation = from_region->affiliation();\n+  if (_from_region->has_live()) {\n+    if (_from_affiliation == ShenandoahAffiliation::OLD_GENERATION) {\n+      if (_old_to_region == nullptr) {\n+        _old_to_region = from_region;\n+        _old_compact_point = from_region->bottom();\n+      }\n+    } else {\n+      assert(_from_affiliation == ShenandoahAffiliation::YOUNG_GENERATION, \"from_region must be OLD or YOUNG\");\n+      if (_young_to_region == nullptr) {\n+        _young_to_region = from_region;\n+        _young_compact_point = from_region->bottom();\n+      }\n+    }\n+  } \/\/ else, we won't iterate over this _from_region so we don't need to set up to region to hold copies\n+}\n+\n+void ShenandoahPrepareForGenerationalCompactionObjectClosure::finish() {\n+  finish_old_region();\n+  finish_young_region();\n+}\n+\n+void ShenandoahPrepareForGenerationalCompactionObjectClosure::finish_old_region() {\n+  if (_old_to_region != nullptr) {\n+    log_debug(gc)(\"Planned compaction into Old Region \" SIZE_FORMAT \", used: \" SIZE_FORMAT \" tabulated by worker %u\",\n+            _old_to_region->index(), _old_compact_point - _old_to_region->bottom(), _worker_id);\n+    _old_to_region->set_new_top(_old_compact_point);\n+    _old_to_region = nullptr;\n+  }\n+}\n+\n+void ShenandoahPrepareForGenerationalCompactionObjectClosure::finish_young_region() {\n+  if (_young_to_region != nullptr) {\n+    log_debug(gc)(\"Worker %u planned compaction into Young Region \" SIZE_FORMAT \", used: \" SIZE_FORMAT,\n+            _worker_id, _young_to_region->index(), _young_compact_point - _young_to_region->bottom());\n+    _young_to_region->set_new_top(_young_compact_point);\n+    _young_to_region = nullptr;\n+  }\n+}\n+\n+bool ShenandoahPrepareForGenerationalCompactionObjectClosure::is_compact_same_region() {\n+  return (_from_region == _old_to_region) || (_from_region == _young_to_region);\n+}\n+\n+void ShenandoahPrepareForGenerationalCompactionObjectClosure::do_object(oop p) {\n+  assert(_from_region != nullptr, \"must set before work\");\n+  assert((_from_region->bottom() <= cast_from_oop<HeapWord*>(p)) && (cast_from_oop<HeapWord*>(p) < _from_region->top()),\n+         \"Object must reside in _from_region\");\n+  assert(_heap->complete_marking_context()->is_marked(p), \"must be marked\");\n+  assert(!_heap->complete_marking_context()->allocated_after_mark_start(p), \"must be truly marked\");\n+\n+  size_t obj_size = p->size();\n+  uint from_region_age = _from_region->age();\n+  uint object_age = p->age();\n+\n+  bool promote_object = false;\n+  if ((_from_affiliation == ShenandoahAffiliation::YOUNG_GENERATION) &&\n+      (from_region_age + object_age >= _tenuring_threshold)) {\n+    if ((_old_to_region != nullptr) && (_old_compact_point + obj_size > _old_to_region->end())) {\n+      finish_old_region();\n+      _old_to_region = nullptr;\n+    }\n+    if (_old_to_region == nullptr) {\n+      if (_empty_regions_pos < _empty_regions.length()) {\n+        ShenandoahHeapRegion* new_to_region = _empty_regions.at(_empty_regions_pos);\n+        _empty_regions_pos++;\n+        new_to_region->set_affiliation(OLD_GENERATION);\n+        _old_to_region = new_to_region;\n+        _old_compact_point = _old_to_region->bottom();\n+        promote_object = true;\n+      }\n+      \/\/ Else this worker thread does not yet have any empty regions into which this aged object can be promoted so\n+      \/\/ we leave promote_object as false, deferring the promotion.\n+    } else {\n+      promote_object = true;\n+    }\n+  }\n+\n+  if (promote_object || (_from_affiliation == ShenandoahAffiliation::OLD_GENERATION)) {\n+    assert(_old_to_region != nullptr, \"_old_to_region should not be nullptr when evacuating to OLD region\");\n+    if (_old_compact_point + obj_size > _old_to_region->end()) {\n+      ShenandoahHeapRegion* new_to_region;\n+\n+      log_debug(gc)(\"Worker %u finishing old region \" SIZE_FORMAT \", compact_point: \" PTR_FORMAT \", obj_size: \" SIZE_FORMAT\n+      \", &compact_point[obj_size]: \" PTR_FORMAT \", region end: \" PTR_FORMAT,  _worker_id, _old_to_region->index(),\n+              p2i(_old_compact_point), obj_size, p2i(_old_compact_point + obj_size), p2i(_old_to_region->end()));\n+\n+      \/\/ Object does not fit.  Get a new _old_to_region.\n+      finish_old_region();\n+      if (_empty_regions_pos < _empty_regions.length()) {\n+        new_to_region = _empty_regions.at(_empty_regions_pos);\n+        _empty_regions_pos++;\n+        new_to_region->set_affiliation(OLD_GENERATION);\n+      } else {\n+        \/\/ If we've exhausted the previously selected _old_to_region, we know that the _old_to_region is distinct\n+        \/\/ from _from_region.  That's because there is always room for _from_region to be compacted into itself.\n+        \/\/ Since we're out of empty regions, let's use _from_region to hold the results of its own compaction.\n+        new_to_region = _from_region;\n+      }\n+\n+      assert(new_to_region != _old_to_region, \"must not reuse same OLD to-region\");\n+      assert(new_to_region != nullptr, \"must not be nullptr\");\n+      _old_to_region = new_to_region;\n+      _old_compact_point = _old_to_region->bottom();\n+    }\n+\n+    \/\/ Object fits into current region, record new location, if object does not move:\n+    assert(_old_compact_point + obj_size <= _old_to_region->end(), \"must fit\");\n+    shenandoah_assert_not_forwarded(nullptr, p);\n+    if (_old_compact_point != cast_from_oop<HeapWord*>(p)) {\n+      _preserved_marks->push_if_necessary(p, p->mark());\n+      p->forward_to(cast_to_oop(_old_compact_point));\n+    }\n+    _old_compact_point += obj_size;\n+  } else {\n+    assert(_from_affiliation == ShenandoahAffiliation::YOUNG_GENERATION,\n+           \"_from_region must be OLD_GENERATION or YOUNG_GENERATION\");\n+    assert(_young_to_region != nullptr, \"_young_to_region should not be nullptr when compacting YOUNG _from_region\");\n+\n+    \/\/ After full gc compaction, all regions have age 0.  Embed the region's age into the object's age in order to preserve\n+    \/\/ tenuring progress.\n+    if (_heap->is_aging_cycle()) {\n+      ShenandoahHeap::increase_object_age(p, from_region_age + 1);\n+    } else {\n+      ShenandoahHeap::increase_object_age(p, from_region_age);\n+    }\n+\n+    if (_young_compact_point + obj_size > _young_to_region->end()) {\n+      ShenandoahHeapRegion* new_to_region;\n+\n+      log_debug(gc)(\"Worker %u finishing young region \" SIZE_FORMAT \", compact_point: \" PTR_FORMAT \", obj_size: \" SIZE_FORMAT\n+      \", &compact_point[obj_size]: \" PTR_FORMAT \", region end: \" PTR_FORMAT,  _worker_id, _young_to_region->index(),\n+              p2i(_young_compact_point), obj_size, p2i(_young_compact_point + obj_size), p2i(_young_to_region->end()));\n+\n+      \/\/ Object does not fit.  Get a new _young_to_region.\n+      finish_young_region();\n+      if (_empty_regions_pos < _empty_regions.length()) {\n+        new_to_region = _empty_regions.at(_empty_regions_pos);\n+        _empty_regions_pos++;\n+        new_to_region->set_affiliation(YOUNG_GENERATION);\n+      } else {\n+        \/\/ If we've exhausted the previously selected _young_to_region, we know that the _young_to_region is distinct\n+        \/\/ from _from_region.  That's because there is always room for _from_region to be compacted into itself.\n+        \/\/ Since we're out of empty regions, let's use _from_region to hold the results of its own compaction.\n+        new_to_region = _from_region;\n+      }\n+\n+      assert(new_to_region != _young_to_region, \"must not reuse same OLD to-region\");\n+      assert(new_to_region != nullptr, \"must not be nullptr\");\n+      _young_to_region = new_to_region;\n+      _young_compact_point = _young_to_region->bottom();\n+    }\n+\n+    \/\/ Object fits into current region, record new location, if object does not move:\n+    assert(_young_compact_point + obj_size <= _young_to_region->end(), \"must fit\");\n+    shenandoah_assert_not_forwarded(nullptr, p);\n+\n+    if (_young_compact_point != cast_from_oop<HeapWord*>(p)) {\n+      _preserved_marks->push_if_necessary(p, p->mark());\n+      p->forward_to(cast_to_oop(_young_compact_point));\n+    }\n+    _young_compact_point += obj_size;\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":378,"deletions":0,"binary":false,"changes":378,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONALFULLGC_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONALFULLGC_HPP\n+\n+#include \"gc\/shared\/preservedMarks.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+class ShenandoahHeap;\n+class ShenandoahHeapRegion;\n+\n+class ShenandoahGenerationalFullGC {\n+public:\n+  \/\/ Prepares the generational mode heap for a full collection.\n+  static void prepare();\n+\n+  \/\/ Full GC may have compacted objects in the old generation, so we need to rebuild the card tables.\n+  static void rebuild_remembered_set(ShenandoahHeap* heap);\n+\n+  \/\/ Records end of cycle for young and old and establishes size of live bytes in old\n+  static void handle_completion(ShenandoahHeap* heap);\n+\n+  \/\/ Full GC may have promoted regions and may have temporarily violated constraints on the usage and\n+  \/\/ capacity of the old generation. This method will balance the accounting of regions between the\n+  \/\/ young and old generations. This is somewhat vestigial, but the outcome of this method is used\n+  \/\/ when rebuilding the free sets.\n+  static void balance_generations_after_gc(ShenandoahHeap* heap);\n+\n+  \/\/ This will compute the target size for the old generation. It will be expressed in terms of\n+  \/\/ a region surplus and deficit, which will be redistributed accordingly after rebuilding the\n+  \/\/ free set.\n+  static void compute_balances();\n+\n+  \/\/ Rebuilding the free set may have resulted in regions being pulled in to the old generation\n+  \/\/ evacuation reserve. For this reason, we must update the usage and capacity of the generations\n+  \/\/ again. In the distant past, the free set did not know anything about generations, so we had\n+  \/\/ a layer built above it to represent how much young\/old memory was available. This layer is\n+  \/\/ redundant and adds complexity. We would like to one day remove it. Until then, we must keep it\n+  \/\/ synchronized with the free set's view of things.\n+  static void balance_generations_after_rebuilding_free_set();\n+\n+  \/\/ Logs the number of live bytes marked in the old generation. This is _not_ the same\n+  \/\/ value used as the baseline for the old generation _after_ the full gc is complete.\n+  \/\/ The value reported in the logs does not include objects and regions that may be\n+  \/\/ promoted during the full gc.\n+  static void log_live_in_old(ShenandoahHeap* heap);\n+\n+  \/\/ This is used to tally the number, usage and space wasted by humongous objects for each generation.\n+  static void account_for_region(ShenandoahHeapRegion* r, size_t &region_count, size_t &region_usage, size_t &humongous_waste);\n+\n+  \/\/ Regions which are scheduled for in-place promotion during evacuation temporarily\n+  \/\/ have their top set to their end to prevent new objects from being allocated in them\n+  \/\/ before they are promoted. If the full GC encounters such a region, it means the\n+  \/\/ in-place promotion did not happen, and we must restore the original value of top.\n+  static void restore_top_before_promote(ShenandoahHeap* heap);\n+\n+  \/\/ Pinned regions are not compacted, so they may still hold unmarked objects with\n+  \/\/ references to reclaimed memory. Remembered set scanning will crash if it attempts\n+  \/\/ to iterate the oops in these objects. This method fills in dead objects for pinned,\n+  \/\/ old regions.\n+  static void maybe_coalesce_and_fill_region(ShenandoahHeapRegion* r);\n+};\n+\n+class ShenandoahPrepareForGenerationalCompactionObjectClosure : public ObjectClosure {\n+private:\n+  PreservedMarks*          const _preserved_marks;\n+  ShenandoahHeap*          const _heap;\n+  uint                           _tenuring_threshold;\n+\n+  \/\/ _empty_regions is a thread-local list of heap regions that have been completely emptied by this worker thread's\n+  \/\/ compaction efforts.  The worker thread that drives these efforts adds compacted regions to this list if the\n+  \/\/ region has not been compacted onto itself.\n+  GrowableArray<ShenandoahHeapRegion*>& _empty_regions;\n+  int _empty_regions_pos;\n+  ShenandoahHeapRegion*          _old_to_region;\n+  ShenandoahHeapRegion*          _young_to_region;\n+  ShenandoahHeapRegion*          _from_region;\n+  ShenandoahAffiliation          _from_affiliation;\n+  HeapWord*                      _old_compact_point;\n+  HeapWord*                      _young_compact_point;\n+  uint                           _worker_id;\n+\n+public:\n+  ShenandoahPrepareForGenerationalCompactionObjectClosure(PreservedMarks* preserved_marks,\n+                                                          GrowableArray<ShenandoahHeapRegion*>& empty_regions,\n+                                                          ShenandoahHeapRegion* from_region, uint worker_id);\n+\n+  void set_from_region(ShenandoahHeapRegion* from_region);\n+  void finish();\n+  void finish_old_region();\n+  void finish_young_region();\n+  bool is_compact_same_region();\n+  int empty_regions_pos() const { return _empty_regions_pos; }\n+\n+  void do_object(oop p) override;\n+};\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONALFULLGC_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.hpp","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahMemoryPool.hpp\"\n@@ -31,0 +33,1 @@\n+#include \"gc\/shenandoah\/shenandoahRegulatorThread.hpp\"\n@@ -48,2 +51,2 @@\n-    log_info(gc, init)(\"Young Generation Soft Size: \" PROPERFMT, PROPERFMTARGS(young->soft_max_capacity()));\n-    log_info(gc, init)(\"Young Generation Max: \" PROPERFMT, PROPERFMTARGS(young->max_capacity()));\n+    log_info(gc, init)(\"Young Generation Soft Size: \" EXACTFMT, EXACTFMTARGS(young->soft_max_capacity()));\n+    log_info(gc, init)(\"Young Generation Max: \" EXACTFMT, EXACTFMTARGS(young->max_capacity()));\n@@ -52,2 +55,2 @@\n-    log_info(gc, init)(\"Old Generation Soft Size: \" PROPERFMT, PROPERFMTARGS(old->soft_max_capacity()));\n-    log_info(gc, init)(\"Old Generation Max: \" PROPERFMT, PROPERFMTARGS(old->max_capacity()));\n+    log_info(gc, init)(\"Old Generation Soft Size: \" EXACTFMT, EXACTFMTARGS(old->soft_max_capacity()));\n+    log_info(gc, init)(\"Old Generation Max: \" EXACTFMT, EXACTFMTARGS(old->max_capacity()));\n@@ -67,0 +70,1 @@\n+  shenandoah_assert_generational();\n@@ -71,0 +75,4 @@\n+ShenandoahGenerationalHeap::ShenandoahGenerationalHeap(ShenandoahCollectorPolicy* policy) :\n+  ShenandoahHeap(policy),\n+  _regulator_thread(nullptr) { }\n+\n@@ -75,0 +83,186 @@\n+\n+void ShenandoahGenerationalHeap::initialize_serviceability() {\n+  assert(mode()->is_generational(), \"Only for the generational mode\");\n+  _young_gen_memory_pool = new ShenandoahYoungGenMemoryPool(this);\n+  _old_gen_memory_pool = new ShenandoahOldGenMemoryPool(this);\n+  cycle_memory_manager()->add_pool(_young_gen_memory_pool);\n+  cycle_memory_manager()->add_pool(_old_gen_memory_pool);\n+  stw_memory_manager()->add_pool(_young_gen_memory_pool);\n+  stw_memory_manager()->add_pool(_old_gen_memory_pool);\n+}\n+\n+GrowableArray<MemoryPool*> ShenandoahGenerationalHeap::memory_pools() {\n+  assert(mode()->is_generational(), \"Only for the generational mode\");\n+  GrowableArray<MemoryPool*> memory_pools(2);\n+  memory_pools.append(_young_gen_memory_pool);\n+  memory_pools.append(_old_gen_memory_pool);\n+  return memory_pools;\n+}\n+\n+void ShenandoahGenerationalHeap::initialize_controller() {\n+  auto control_thread = new ShenandoahGenerationalControlThread();\n+  _control_thread = control_thread;\n+  _regulator_thread = new ShenandoahRegulatorThread(control_thread);\n+}\n+\n+void ShenandoahGenerationalHeap::gc_threads_do(ThreadClosure* tcl) const {\n+  if (!shenandoah_policy()->is_at_shutdown()) {\n+    ShenandoahHeap::gc_threads_do(tcl);\n+    tcl->do_thread(regulator_thread());\n+  }\n+}\n+\n+void ShenandoahGenerationalHeap::stop() {\n+  regulator_thread()->stop();\n+  ShenandoahHeap::stop();\n+}\n+\n+ShenandoahGenerationalHeap::TransferResult ShenandoahGenerationalHeap::balance_generations() {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+\n+  ShenandoahOldGeneration* old_gen = old_generation();\n+  const size_t old_region_surplus = old_gen->get_region_surplus();\n+  const size_t old_region_deficit = old_gen->get_region_deficit();\n+  old_gen->set_region_surplus(0);\n+  old_gen->set_region_deficit(0);\n+\n+  if (old_region_surplus) {\n+    bool success = generation_sizer()->transfer_to_young(old_region_surplus);\n+    return TransferResult {\n+      success, old_region_surplus, \"young\"\n+    };\n+  }\n+\n+  if (old_region_deficit) {\n+    const bool success = generation_sizer()->transfer_to_old(old_region_deficit);\n+    if (!success) {\n+      old_gen->handle_failed_transfer();\n+    }\n+    return TransferResult {\n+      success, old_region_deficit, \"old\"\n+    };\n+  }\n+\n+  return TransferResult {true, 0, \"none\"};\n+}\n+\n+\/\/ Make sure old-generation is large enough, but no larger than is necessary, to hold mixed evacuations\n+\/\/ and promotions, if we anticipate either. Any deficit is provided by the young generation, subject to\n+\/\/ xfer_limit, and any surplus is transferred to the young generation.\n+\/\/ xfer_limit is the maximum we're able to transfer from young to old.\n+void ShenandoahGenerationalHeap::compute_old_generation_balance(size_t old_xfer_limit, size_t old_cset_regions) {\n+\n+  \/\/ We can limit the old reserve to the size of anticipated promotions:\n+  \/\/ max_old_reserve is an upper bound on memory evacuated from old and promoted to old,\n+  \/\/ clamped by the old generation space available.\n+  \/\/\n+  \/\/ Here's the algebra.\n+  \/\/ Let SOEP = ShenandoahOldEvacRatioPercent,\n+  \/\/     OE = old evac,\n+  \/\/     YE = young evac, and\n+  \/\/     TE = total evac = OE + YE\n+  \/\/ By definition:\n+  \/\/            SOEP\/100 = OE\/TE\n+  \/\/                     = OE\/(OE+YE)\n+  \/\/  => SOEP\/(100-SOEP) = OE\/((OE+YE)-OE)      \/\/ componendo-dividendo: If a\/b = c\/d, then a\/(b-a) = c\/(d-c)\n+  \/\/                     = OE\/YE\n+  \/\/  =>              OE = YE*SOEP\/(100-SOEP)\n+\n+  \/\/ We have to be careful in the event that SOEP is set to 100 by the user.\n+  assert(ShenandoahOldEvacRatioPercent <= 100, \"Error\");\n+  const size_t old_available = old_generation()->available();\n+  \/\/ The free set will reserve this amount of memory to hold young evacuations\n+  const size_t young_reserve = (young_generation()->max_capacity() * ShenandoahEvacReserve) \/ 100;\n+\n+  \/\/ In the case that ShenandoahOldEvacRatioPercent equals 100, max_old_reserve is limited only by xfer_limit.\n+\n+  const size_t bound_on_old_reserve = old_available + old_xfer_limit + young_reserve;\n+  const size_t max_old_reserve = (ShenandoahOldEvacRatioPercent == 100)?\n+                                 bound_on_old_reserve: MIN2((young_reserve * ShenandoahOldEvacRatioPercent) \/ (100 - ShenandoahOldEvacRatioPercent),\n+                                                            bound_on_old_reserve);\n+\n+  const size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+\n+  \/\/ Decide how much old space we should reserve for a mixed collection\n+  size_t reserve_for_mixed = 0;\n+  const size_t mixed_candidates = old_heuristics()->unprocessed_old_collection_candidates();\n+  const bool doing_mixed = (mixed_candidates > 0);\n+  if (doing_mixed) {\n+    \/\/ We want this much memory to be unfragmented in order to reliably evacuate old.  This is conservative because we\n+    \/\/ may not evacuate the entirety of unprocessed candidates in a single mixed evacuation.\n+    const size_t max_evac_need = (size_t)\n+            (old_heuristics()->unprocessed_old_collection_candidates_live_memory() * ShenandoahOldEvacWaste);\n+    assert(old_available >= old_generation()->free_unaffiliated_regions() * region_size_bytes,\n+           \"Unaffiliated available must be less than total available\");\n+    const size_t old_fragmented_available =\n+            old_available - old_generation()->free_unaffiliated_regions() * region_size_bytes;\n+    reserve_for_mixed = max_evac_need + old_fragmented_available;\n+    if (reserve_for_mixed > max_old_reserve) {\n+      reserve_for_mixed = max_old_reserve;\n+    }\n+  }\n+\n+  \/\/ Decide how much space we should reserve for promotions from young\n+  size_t reserve_for_promo = 0;\n+  const size_t promo_load = old_generation()->get_promotion_potential();\n+  const bool doing_promotions = promo_load > 0;\n+  if (doing_promotions) {\n+    \/\/ We're promoting and have a bound on the maximum amount that can be promoted\n+    assert(max_old_reserve >= reserve_for_mixed, \"Sanity\");\n+    const size_t available_for_promotions = max_old_reserve - reserve_for_mixed;\n+    reserve_for_promo = MIN2((size_t)(promo_load * ShenandoahPromoEvacWaste), available_for_promotions);\n+  }\n+\n+  \/\/ This is the total old we want to ideally reserve\n+  const size_t old_reserve = reserve_for_mixed + reserve_for_promo;\n+  assert(old_reserve <= max_old_reserve, \"cannot reserve more than max for old evacuations\");\n+\n+  \/\/ We now check if the old generation is running a surplus or a deficit.\n+  size_t old_region_deficit = 0;\n+  size_t old_region_surplus = 0;\n+\n+  const size_t max_old_available = old_generation()->available() + old_cset_regions * region_size_bytes;\n+  if (max_old_available >= old_reserve) {\n+    \/\/ We are running a surplus, so the old region surplus can go to young\n+    const size_t old_surplus = max_old_available - old_reserve;\n+    old_region_surplus = old_surplus \/ region_size_bytes;\n+    const size_t unaffiliated_old_regions = old_generation()->free_unaffiliated_regions() + old_cset_regions;\n+    old_region_surplus = MIN2(old_region_surplus, unaffiliated_old_regions);\n+  } else {\n+    \/\/ We are running a deficit which we'd like to fill from young.\n+    \/\/ Ignore that this will directly impact young_generation()->max_capacity(),\n+    \/\/ indirectly impacting young_reserve and old_reserve.  These computations are conservative.\n+    const size_t old_need = old_reserve - max_old_available;\n+    \/\/ The old region deficit (rounded up) will come from young\n+    old_region_deficit = (old_need + region_size_bytes - 1) \/ region_size_bytes;\n+\n+    \/\/ Round down the regions we can transfer from young to old. If we're running short\n+    \/\/ on young-gen memory, we restrict the xfer. Old-gen collection activities will be\n+    \/\/ curtailed if the budget is restricted.\n+    const size_t max_old_region_xfer = old_xfer_limit \/ region_size_bytes;\n+    old_region_deficit = MIN2(old_region_deficit, max_old_region_xfer);\n+  }\n+  assert(old_region_deficit == 0 || old_region_surplus == 0, \"Only surplus or deficit, never both\");\n+\n+  old_generation()->set_region_surplus(old_region_surplus);\n+  old_generation()->set_region_deficit(old_region_deficit);\n+}\n+\n+void ShenandoahGenerationalHeap::reset_generation_reserves() {\n+  young_generation()->set_evacuation_reserve(0);\n+  old_generation()->set_evacuation_reserve(0);\n+  old_generation()->set_promoted_reserve(0);\n+}\n+\n+void ShenandoahGenerationalHeap::TransferResult::print_on(const char* when, outputStream* ss) const {\n+  auto heap = ShenandoahGenerationalHeap::heap();\n+  ShenandoahYoungGeneration* const young_gen = heap->young_generation();\n+  ShenandoahOldGeneration* const old_gen = heap->old_generation();\n+  const size_t young_available = young_gen->available();\n+  const size_t old_available = old_gen->available();\n+  ss->print_cr(\"After %s, %s \" SIZE_FORMAT \" regions to %s to prepare for next gc, old available: \"\n+                     PROPERFMT \", young_available: \" PROPERFMT,\n+                     when,\n+                     success? \"successfully transferred\": \"failed to transfer\", region_count, region_destination,\n+                     PROPERFMTARGS(old_available), PROPERFMTARGS(young_available));\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":198,"deletions":4,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+class ShenandoahRegulatorThread;\n+class ShenandoahGenerationalControlThread;\n+\n@@ -32,1 +35,1 @@\n-  explicit ShenandoahGenerationalHeap(ShenandoahCollectorPolicy* policy) : ShenandoahHeap(policy) {}\n+  explicit ShenandoahGenerationalHeap(ShenandoahCollectorPolicy* policy);\n@@ -37,0 +40,38 @@\n+\n+  \/\/ ---------- Serviceability\n+  \/\/\n+  void initialize_serviceability() override;\n+  GrowableArray<MemoryPool*> memory_pools() override;\n+\n+  ShenandoahRegulatorThread* regulator_thread() const { return _regulator_thread;  }\n+\n+  void gc_threads_do(ThreadClosure* tcl) const override;\n+\n+  void stop() override;\n+\n+  \/\/ Used for logging the result of a region transfer outside of the heap lock\n+  struct TransferResult {\n+    bool success;\n+    size_t region_count;\n+    const char* region_destination;\n+\n+    void print_on(const char* when, outputStream* ss) const;\n+  };\n+\n+  \/\/ Zeros out the evacuation and promotion reserves\n+  void reset_generation_reserves();\n+\n+  \/\/ Computes the optimal size for the old generation, represented as a surplus or deficit of old regions\n+  void compute_old_generation_balance(size_t old_xfer_limit, size_t old_cset_regions);\n+\n+  \/\/ Transfers surplus old regions to young, or takes regions from young to satisfy old region deficit\n+  TransferResult balance_generations();\n+\n+\n+private:\n+  void initialize_controller() override;\n+\n+  ShenandoahRegulatorThread* _regulator_thread;\n+\n+  MemoryPool* _young_gen_memory_pool;\n+  MemoryPool* _old_gen_memory_pool;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":42,"deletions":1,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  : ShenandoahGeneration(generational ? GLOBAL_GEN : GLOBAL_NON_GEN, max_queues, max_capacity, soft_max_capacity) { }\n+  : ShenandoahGeneration(generational ? GLOBAL : NON_GEN, max_queues, max_capacity, soft_max_capacity) { }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -51,1 +52,0 @@\n-#include \"gc\/shenandoah\/shenandoahRegulatorThread.hpp\"\n@@ -481,2 +481,0 @@\n-  } else {\n-    _pacer = nullptr;\n@@ -485,2 +483,1 @@\n-  _control_thread = new ShenandoahControlThread();\n-  _regulator_thread = new ShenandoahRegulatorThread(_control_thread);\n+  initialize_controller();\n@@ -493,0 +490,4 @@\n+void ShenandoahHeap::initialize_controller() {\n+  _control_thread = new ShenandoahControlThread();\n+}\n+\n@@ -503,2 +504,2 @@\n-    case GLOBAL_GEN:\n-    case GLOBAL_NON_GEN:\n+    case GLOBAL:\n+    case NON_GEN:\n@@ -518,2 +519,2 @@\n-    case GLOBAL_GEN:\n-    case GLOBAL_NON_GEN:\n+    case GLOBAL:\n+    case NON_GEN:\n@@ -585,1 +586,0 @@\n-  _promotion_potential(0),\n@@ -595,3 +595,2 @@\n-  _promoted_reserve(0),\n-  _old_evac_reserve(0),\n-  _young_evac_reserve(0),\n+  _gc_state_changed(false),\n+  _gc_no_progress_count(0),\n@@ -599,1 +598,0 @@\n-  _has_evacuation_reserve_quantities(false),\n@@ -605,1 +603,0 @@\n-  _regulator_thread(nullptr),\n@@ -616,2 +613,0 @@\n-  _young_gen_memory_pool(nullptr),\n-  _old_gen_memory_pool(nullptr),\n@@ -623,2 +618,0 @@\n-  _old_regions_surplus(0),\n-  _old_regions_deficit(0),\n@@ -880,0 +873,27 @@\n+void ShenandoahHeap::maybe_uncommit(double shrink_before, size_t shrink_until) {\n+  assert (ShenandoahUncommit, \"should be enabled\");\n+\n+  \/\/ Determine if there is work to do. This avoids taking heap lock if there is\n+  \/\/ no work available, avoids spamming logs with superfluous logging messages,\n+  \/\/ and minimises the amount of work while locks are taken.\n+\n+  if (committed() <= shrink_until) return;\n+\n+  bool has_work = false;\n+  for (size_t i = 0; i < num_regions(); i++) {\n+    ShenandoahHeapRegion* r = get_region(i);\n+    if (r->is_empty_committed() && (r->empty_time() < shrink_before)) {\n+      has_work = true;\n+      break;\n+    }\n+  }\n+\n+  if (has_work) {\n+    static const char* msg = \"Concurrent uncommit\";\n+    ShenandoahConcurrentPhase gcPhase(msg, ShenandoahPhaseTimings::conc_uncommit, true \/* log_heap_usage *\/);\n+    EventMark em(\"%s\", msg);\n+\n+    op_uncommit(shrink_before, shrink_until);\n+  }\n+}\n+\n@@ -906,2 +926,18 @@\n-    control_thread()->notify_heap_changed();\n-    regulator_thread()->notify_heap_changed();\n+    notify_heap_changed();\n+  }\n+}\n+\n+bool ShenandoahHeap::check_soft_max_changed() {\n+  size_t new_soft_max = Atomic::load(&SoftMaxHeapSize);\n+  size_t old_soft_max = soft_max_capacity();\n+  if (new_soft_max != old_soft_max) {\n+    new_soft_max = MAX2(min_capacity(), new_soft_max);\n+    new_soft_max = MIN2(max_capacity(), new_soft_max);\n+    if (new_soft_max != old_soft_max) {\n+      log_info(gc)(\"Soft Max Heap Size: \" SIZE_FORMAT \"%s -> \" SIZE_FORMAT \"%s\",\n+                   byte_size_in_proper_unit(old_soft_max), proper_unit_for_byte_size(old_soft_max),\n+                   byte_size_in_proper_unit(new_soft_max), proper_unit_for_byte_size(new_soft_max)\n+      );\n+      set_soft_max_capacity(new_soft_max);\n+      return true;\n+    }\n@@ -909,0 +945,1 @@\n+  return false;\n@@ -911,14 +948,5 @@\n-void ShenandoahHeap::handle_old_evacuation(HeapWord* obj, size_t words, bool promotion) {\n-  \/\/ Only register the copy of the object that won the evacuation race.\n-  card_scan()->register_object_without_lock(obj);\n-\n-  \/\/ Mark the entire range of the evacuated object as dirty.  At next remembered set scan,\n-  \/\/ we will clear dirty bits that do not hold interesting pointers.  It's more efficient to\n-  \/\/ do this in batch, in a background GC thread than to try to carefully dirty only cards\n-  \/\/ that hold interesting pointers right now.\n-  card_scan()->mark_range_as_dirty(obj, words);\n-\n-  if (promotion) {\n-    \/\/ This evacuation was a promotion, track this as allocation against old gen\n-    old_generation()->increase_allocated(words * HeapWordSize);\n-  }\n+void ShenandoahHeap::notify_heap_changed() {\n+  \/\/ Update monitoring counters when we took a new region. This amortizes the\n+  \/\/ update costs on slow path.\n+  monitoring_support()->notify_heap_changed();\n+  _heap_changed.set();\n@@ -927,4 +955,2 @@\n-void ShenandoahHeap::handle_old_evacuation_failure() {\n-  if (_old_gen_oom_evac.try_set()) {\n-    log_info(gc)(\"Old gen evac failure.\");\n-  }\n+void ShenandoahHeap::set_forced_counters_update(bool value) {\n+  monitoring_support()->set_forced_counters_update(value);\n@@ -933,40 +959,2 @@\n-void ShenandoahHeap::report_promotion_failure(Thread* thread, size_t size) {\n-  \/\/ We squelch excessive reports to reduce noise in logs.\n-  const size_t MaxReportsPerEpoch = 4;\n-  static size_t last_report_epoch = 0;\n-  static size_t epoch_report_count = 0;\n-\n-  size_t promotion_reserve;\n-  size_t promotion_expended;\n-\n-  size_t gc_id = control_thread()->get_gc_id();\n-\n-  if ((gc_id != last_report_epoch) || (epoch_report_count++ < MaxReportsPerEpoch)) {\n-    {\n-      \/\/ Promotion failures should be very rare.  Invest in providing useful diagnostic info.\n-      ShenandoahHeapLocker locker(lock());\n-      promotion_reserve = get_promoted_reserve();\n-      promotion_expended = get_promoted_expended();\n-    }\n-    PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n-    size_t words_remaining = (plab == nullptr)? 0: plab->words_remaining();\n-    const char* promote_enabled = ShenandoahThreadLocalData::allow_plab_promotions(thread)? \"enabled\": \"disabled\";\n-    ShenandoahGeneration* old_gen = old_generation();\n-    size_t old_capacity = old_gen->max_capacity();\n-    size_t old_usage = old_gen->used();\n-    size_t old_free_regions = old_gen->free_unaffiliated_regions();\n-\n-    log_info(gc, ergo)(\"Promotion failed, size \" SIZE_FORMAT \", has plab? %s, PLAB remaining: \" SIZE_FORMAT\n-                       \", plab promotions %s, promotion reserve: \" SIZE_FORMAT \", promotion expended: \" SIZE_FORMAT\n-                       \", old capacity: \" SIZE_FORMAT \", old_used: \" SIZE_FORMAT \", old unaffiliated regions: \" SIZE_FORMAT,\n-                       size * HeapWordSize, plab == nullptr? \"no\": \"yes\",\n-                       words_remaining * HeapWordSize, promote_enabled, promotion_reserve, promotion_expended,\n-                       old_capacity, old_usage, old_free_regions);\n-\n-    if ((gc_id == last_report_epoch) && (epoch_report_count >= MaxReportsPerEpoch)) {\n-      log_info(gc, ergo)(\"Squelching additional promotion failure reports for current epoch\");\n-    } else if (gc_id != last_report_epoch) {\n-      last_report_epoch = gc_id;\n-      epoch_report_count = 1;\n-    }\n-  }\n+void ShenandoahHeap::handle_force_counters_update() {\n+  monitoring_support()->handle_force_counters_update();\n@@ -1139,1 +1127,1 @@\n-    unexpend_promoted(not_promoted);\n+    old_generation()->unexpend_promoted(not_promoted);\n@@ -1180,103 +1168,0 @@\n-\/\/ Make sure old-generation is large enough, but no larger than is necessary, to hold mixed evacuations\n-\/\/ and promotions, if we anticipate either. Any deficit is provided by the young generation, subject to\n-\/\/ xfer_limit, and any excess is transferred to the young generation.\n-\/\/ xfer_limit is the maximum we're able to transfer from young to old.\n-void ShenandoahHeap::adjust_generation_sizes_for_next_cycle(\n-  size_t xfer_limit, size_t young_cset_regions, size_t old_cset_regions) {\n-\n-  \/\/ We can limit the old reserve to the size of anticipated promotions:\n-  \/\/ max_old_reserve is an upper bound on memory evacuated from old and promoted to old,\n-  \/\/ clamped by the old generation space available.\n-  \/\/\n-  \/\/ Here's the algebra.\n-  \/\/ Let SOEP = ShenandoahOldEvacRatioPercent,\n-  \/\/     OE = old evac,\n-  \/\/     YE = young evac, and\n-  \/\/     TE = total evac = OE + YE\n-  \/\/ By definition:\n-  \/\/            SOEP\/100 = OE\/TE\n-  \/\/                     = OE\/(OE+YE)\n-  \/\/  => SOEP\/(100-SOEP) = OE\/((OE+YE)-OE)      \/\/ componendo-dividendo: If a\/b = c\/d, then a\/(b-a) = c\/(d-c)\n-  \/\/                     = OE\/YE\n-  \/\/  =>              OE = YE*SOEP\/(100-SOEP)\n-\n-  \/\/ We have to be careful in the event that SOEP is set to 100 by the user.\n-  assert(ShenandoahOldEvacRatioPercent <= 100, \"Error\");\n-  const size_t old_available = old_generation()->available();\n-  \/\/ The free set will reserve this amount of memory to hold young evacuations\n-  const size_t young_reserve = (young_generation()->max_capacity() * ShenandoahEvacReserve) \/ 100;\n-\n-  \/\/ In the case that ShenandoahOldEvacRatioPercent equals 100, max_old_reserve is limited only by xfer_limit.\n-\n-  const size_t bound_on_old_reserve = old_available + xfer_limit + young_reserve;\n-  const size_t max_old_reserve = (ShenandoahOldEvacRatioPercent == 100)?\n-    bound_on_old_reserve: MIN2((young_reserve * ShenandoahOldEvacRatioPercent) \/ (100 - ShenandoahOldEvacRatioPercent),\n-                               bound_on_old_reserve);\n-\n-  const size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-\n-  \/\/ Decide how much old space we should reserve for a mixed collection\n-  size_t reserve_for_mixed = 0;\n-  const size_t mixed_candidates = old_heuristics()->unprocessed_old_collection_candidates();\n-  const bool doing_mixed = (mixed_candidates > 0);\n-  if (doing_mixed) {\n-    \/\/ We want this much memory to be unfragmented in order to reliably evacuate old.  This is conservative because we\n-    \/\/ may not evacuate the entirety of unprocessed candidates in a single mixed evacuation.\n-    size_t max_evac_need = (size_t)\n-      (old_heuristics()->unprocessed_old_collection_candidates_live_memory() * ShenandoahOldEvacWaste);\n-    assert(old_available >= old_generation()->free_unaffiliated_regions() * region_size_bytes,\n-           \"Unaffiliated available must be less than total available\");\n-    size_t old_fragmented_available =\n-      old_available - old_generation()->free_unaffiliated_regions() * region_size_bytes;\n-    reserve_for_mixed = max_evac_need + old_fragmented_available;\n-    if (reserve_for_mixed > max_old_reserve) {\n-      reserve_for_mixed = max_old_reserve;\n-    }\n-  }\n-\n-  \/\/ Decide how much space we should reserve for promotions from young\n-  size_t reserve_for_promo = 0;\n-  const size_t promo_load = get_promotion_potential();\n-  const bool doing_promotions = promo_load > 0;\n-  if (doing_promotions) {\n-    \/\/ We're promoting and have a bound on the maximum amount that can be promoted\n-    assert(max_old_reserve >= reserve_for_mixed, \"Sanity\");\n-    const size_t available_for_promotions = max_old_reserve - reserve_for_mixed;\n-    reserve_for_promo = MIN2((size_t)(promo_load * ShenandoahPromoEvacWaste), available_for_promotions);\n-  }\n-\n-  \/\/ This is the total old we want to ideally reserve\n-  const size_t old_reserve = reserve_for_mixed + reserve_for_promo;\n-  assert(old_reserve <= max_old_reserve, \"cannot reserve more than max for old evacuations\");\n-\n-  \/\/ We now check if the old generation is running a surplus or a deficit.\n-  size_t old_region_deficit = 0;\n-  size_t old_region_surplus = 0;\n-\n-  const size_t max_old_available = old_generation()->available() + old_cset_regions * region_size_bytes;\n-  if (max_old_available >= old_reserve) {\n-    \/\/ We are running a surplus, so the old region surplus can go to young\n-    const size_t old_surplus = max_old_available - old_reserve;\n-    old_region_surplus = old_surplus \/ region_size_bytes;\n-    const size_t unaffiliated_old_regions = old_generation()->free_unaffiliated_regions() + old_cset_regions;\n-    old_region_surplus = MIN2(old_region_surplus, unaffiliated_old_regions);\n-  } else {\n-    \/\/ We are running a deficit which we'd like to fill from young.\n-    \/\/ Ignore that this will directly impact young_generation()->max_capacity(),\n-    \/\/ indirectly impacting young_reserve and old_reserve.  These computations are conservative.\n-    const size_t old_need = old_reserve - max_old_available;\n-    \/\/ The old region deficit (rounded up) will come from young\n-    old_region_deficit = (old_need + region_size_bytes - 1) \/ region_size_bytes;\n-\n-    \/\/ Round down the regions we can transfer from young to old. If we're running short\n-    \/\/ on young-gen memory, we restrict the xfer. Old-gen collection activities will be\n-    \/\/ curtailed if the budget is restricted.\n-    const size_t max_old_region_xfer = xfer_limit \/ region_size_bytes;\n-    old_region_deficit = MIN2(old_region_deficit, max_old_region_xfer);\n-  }\n-  assert(old_region_deficit == 0 || old_region_surplus == 0, \"Only surplus or deficit, never both\");\n-\n-  set_old_region_surplus(old_region_surplus);\n-  set_old_region_deficit(old_region_deficit);\n-}\n-\n@@ -1347,1 +1232,13 @@\n-    \/\/ Allocation failed, block until control thread reacted, then retry allocation.\n+    \/\/ Check that gc overhead is not exceeded.\n+    \/\/\n+    \/\/ Shenandoah will grind along for quite a while allocating one\n+    \/\/ object at a time using shared (non-tlab) allocations. This check\n+    \/\/ is testing that the GC overhead limit has not been exceeded.\n+    \/\/ This will notify the collector to start a cycle, but will raise\n+    \/\/ an OOME to the mutator if the last Full GCs have not made progress.\n+    if (result == nullptr && !req.is_lab_alloc() && get_gc_no_progress_count() > ShenandoahNoProgressThreshold) {\n+      control_thread()->handle_alloc_failure(req, false);\n+      return nullptr;\n+    }\n+\n+    \/\/ Block until control thread reacted, then retry allocation.\n@@ -1356,2 +1253,2 @@\n-        && (_progress_last_gc.is_set() || original_count == shenandoah_policy()->full_gc_count())) {\n-      control_thread()->handle_alloc_failure(req);\n+        && (get_gc_no_progress_count() == 0 || original_count == shenandoah_policy()->full_gc_count())) {\n+      control_thread()->handle_alloc_failure(req, true);\n@@ -1361,0 +1258,6 @@\n+    if (log_is_enabled(Debug, gc, alloc)) {\n+      ResourceMark rm;\n+      log_debug(gc, alloc)(\"Thread: %s, Result: \" PTR_FORMAT \", Request: %s, Size: \" SIZE_FORMAT \", Original: \" SIZE_FORMAT \", Latest: \" SIZE_FORMAT,\n+                           Thread::current()->name(), p2i(result), req.type_string(), req.size(), original_count, get_gc_no_progress_count());\n+    }\n+\n@@ -1369,2 +1272,1 @@\n-    control_thread()->notify_heap_changed();\n-    regulator_thread()->notify_heap_changed();\n+    notify_heap_changed();\n@@ -1412,1 +1314,6 @@\n-    ShenandoahHeapLocker locker(lock());\n+\n+    \/\/ If we are dealing with mutator allocation, then we may need to block for safepoint.\n+    \/\/ We cannot block for safepoint for GC allocations, because there is a high chance\n+    \/\/ we are already running at safepoint or from stack watermark machinery, and we cannot\n+    \/\/ block again.\n+    ShenandoahHeapLocker locker(lock(), req.is_mutator_alloc());\n@@ -1436,2 +1343,2 @@\n-          size_t promotion_avail = get_promoted_reserve();\n-          size_t promotion_expended = get_promoted_expended();\n+          size_t promotion_avail = old_generation()->get_promoted_reserve();\n+          size_t promotion_expended = old_generation()->get_promoted_expended();\n@@ -1440,1 +1347,1 @@\n-            if (get_old_evac_reserve() == 0) {\n+            if (old_generation()->get_evacuation_reserve() == 0) {\n@@ -1451,2 +1358,2 @@\n-          size_t promotion_avail = get_promoted_reserve();\n-          size_t promotion_expended = get_promoted_expended();\n+          size_t promotion_avail = old_generation()->get_promoted_reserve();\n+          size_t promotion_expended = old_generation()->get_promoted_expended();\n@@ -1483,1 +1390,1 @@\n-              if (get_promoted_expended() + actual_size <= get_promoted_reserve()) {\n+              if (old_generation()->get_promoted_expended() + actual_size <= old_generation()->get_promoted_reserve()) {\n@@ -1487,2 +1394,1 @@\n-                expend_promoted(actual_size);\n-                assert(get_promoted_expended() <= get_promoted_reserve(), \"Do not expend more promotion than budgeted\");\n+                old_generation()->expend_promoted(actual_size);\n@@ -1503,2 +1409,1 @@\n-            expend_promoted(requested_bytes);\n-            assert(get_promoted_expended() <= get_promoted_reserve(), \"Do not expend more promotion than budgeted\");\n+            old_generation()->expend_promoted(requested_bytes);\n@@ -1793,0 +1698,177 @@\n+\/\/ try_evacuate_object registers the object and dirties the associated remembered set information when evacuating\n+\/\/ to OLD_GENERATION.\n+oop ShenandoahHeap::try_evacuate_object(oop p, Thread* thread, ShenandoahHeapRegion* from_region,\n+                                               ShenandoahAffiliation target_gen) {\n+  bool alloc_from_lab = true;\n+  bool has_plab = false;\n+  HeapWord* copy = nullptr;\n+  size_t size = p->size();\n+  bool is_promotion = (target_gen == OLD_GENERATION) && from_region->is_young();\n+\n+#ifdef ASSERT\n+  if (ShenandoahOOMDuringEvacALot &&\n+      (os::random() & 1) == 0) { \/\/ Simulate OOM every ~2nd slow-path call\n+    copy = nullptr;\n+  } else {\n+#endif\n+    if (UseTLAB) {\n+      switch (target_gen) {\n+        case YOUNG_GENERATION: {\n+          copy = allocate_from_gclab(thread, size);\n+          if ((copy == nullptr) && (size < ShenandoahThreadLocalData::gclab_size(thread))) {\n+            \/\/ GCLAB allocation failed because we are bumping up against the limit on young evacuation reserve.  Try resetting\n+            \/\/ the desired GCLAB size and retry GCLAB allocation to avoid cascading of shared memory allocations.\n+            ShenandoahThreadLocalData::set_gclab_size(thread, PLAB::min_size());\n+            copy = allocate_from_gclab(thread, size);\n+            \/\/ If we still get nullptr, we'll try a shared allocation below.\n+          }\n+          break;\n+        }\n+        case OLD_GENERATION: {\n+          PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n+          if (plab != nullptr) {\n+            has_plab = true;\n+          }\n+          copy = allocate_from_plab(thread, size, is_promotion);\n+          if ((copy == nullptr) && (size < ShenandoahThreadLocalData::plab_size(thread)) &&\n+              ShenandoahThreadLocalData::plab_retries_enabled(thread)) {\n+            \/\/ PLAB allocation failed because we are bumping up against the limit on old evacuation reserve or because\n+            \/\/ the requested object does not fit within the current plab but the plab still has an \"abundance\" of memory,\n+            \/\/ where abundance is defined as >= PLAB::min_size().  In the former case, we try resetting the desired\n+            \/\/ PLAB size and retry PLAB allocation to avoid cascading of shared memory allocations.\n+\n+            \/\/ In this situation, PLAB memory is precious.  We'll try to preserve our existing PLAB by forcing\n+            \/\/ this particular allocation to be shared.\n+            if (plab->words_remaining() < PLAB::min_size()) {\n+              ShenandoahThreadLocalData::set_plab_size(thread, PLAB::min_size());\n+              copy = allocate_from_plab(thread, size, is_promotion);\n+              \/\/ If we still get nullptr, we'll try a shared allocation below.\n+              if (copy == nullptr) {\n+                \/\/ If retry fails, don't continue to retry until we have success (probably in next GC pass)\n+                ShenandoahThreadLocalData::disable_plab_retries(thread);\n+              }\n+            }\n+            \/\/ else, copy still equals nullptr.  this causes shared allocation below, preserving this plab for future needs.\n+          }\n+          break;\n+        }\n+        default: {\n+          ShouldNotReachHere();\n+          break;\n+        }\n+      }\n+    }\n+\n+    if (copy == nullptr) {\n+      \/\/ If we failed to allocate in LAB, we'll try a shared allocation.\n+      if (!is_promotion || !has_plab || (size > PLAB::min_size())) {\n+        ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(size, target_gen);\n+        copy = allocate_memory(req, is_promotion);\n+        alloc_from_lab = false;\n+      }\n+      \/\/ else, we leave copy equal to nullptr, signaling a promotion failure below if appropriate.\n+      \/\/ We choose not to promote objects smaller than PLAB::min_size() by way of shared allocations, as this is too\n+      \/\/ costly.  Instead, we'll simply \"evacuate\" to young-gen memory (using a GCLAB) and will promote in a future\n+      \/\/ evacuation pass.  This condition is denoted by: is_promotion && has_plab && (size <= PLAB::min_size())\n+    }\n+#ifdef ASSERT\n+  }\n+#endif\n+\n+  if (copy == nullptr) {\n+    if (target_gen == OLD_GENERATION) {\n+      assert(mode()->is_generational(), \"Should only be here in generational mode.\");\n+      if (from_region->is_young()) {\n+        \/\/ Signal that promotion failed. Will evacuate this old object somewhere in young gen.\n+        old_generation()->handle_failed_promotion(thread, size);\n+        return nullptr;\n+      } else {\n+        \/\/ Remember that evacuation to old gen failed. We'll want to trigger a full gc to recover from this\n+        \/\/ after the evacuation threads have finished.\n+        old_generation()->handle_failed_evacuation();\n+      }\n+    }\n+\n+    control_thread()->handle_alloc_failure_evac(size);\n+\n+    _oom_evac_handler.handle_out_of_memory_during_evacuation();\n+\n+    return ShenandoahBarrierSet::resolve_forwarded(p);\n+  }\n+\n+  \/\/ Copy the object:\n+  _evac_tracker->begin_evacuation(thread, size * HeapWordSize);\n+  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(p), copy, size);\n+\n+  oop copy_val = cast_to_oop(copy);\n+\n+  if (mode()->is_generational() && target_gen == YOUNG_GENERATION && is_aging_cycle()) {\n+    ShenandoahHeap::increase_object_age(copy_val, from_region->age() + 1);\n+  }\n+\n+  \/\/ Try to install the new forwarding pointer.\n+  ContinuationGCSupport::relativize_stack_chunk(copy_val);\n+\n+  oop result = ShenandoahForwarding::try_update_forwardee(p, copy_val);\n+  if (result == copy_val) {\n+    \/\/ Successfully evacuated. Our copy is now the public one!\n+    _evac_tracker->end_evacuation(thread, size * HeapWordSize);\n+    if (mode()->is_generational()) {\n+      if (target_gen == OLD_GENERATION) {\n+        old_generation()->handle_evacuation(copy, size, from_region->is_young());\n+      } else {\n+        \/\/ When copying to the old generation above, we don't care\n+        \/\/ about recording object age in the census stats.\n+        assert(target_gen == YOUNG_GENERATION, \"Error\");\n+        \/\/ We record this census only when simulating pre-adaptive tenuring behavior, or\n+        \/\/ when we have been asked to record the census at evacuation rather than at mark\n+        if (ShenandoahGenerationalCensusAtEvac || !ShenandoahGenerationalAdaptiveTenuring) {\n+          _evac_tracker->record_age(thread, size * HeapWordSize, ShenandoahHeap::get_object_age(copy_val));\n+        }\n+      }\n+    }\n+    shenandoah_assert_correct(nullptr, copy_val);\n+    return copy_val;\n+  }  else {\n+    \/\/ Failed to evacuate. We need to deal with the object that is left behind. Since this\n+    \/\/ new allocation is certainly after TAMS, it will be considered live in the next cycle.\n+    \/\/ But if it happens to contain references to evacuated regions, those references would\n+    \/\/ not get updated for this stale copy during this cycle, and we will crash while scanning\n+    \/\/ it the next cycle.\n+    if (alloc_from_lab) {\n+      \/\/ For LAB allocations, it is enough to rollback the allocation ptr. Either the next\n+      \/\/ object will overwrite this stale copy, or the filler object on LAB retirement will\n+      \/\/ do this.\n+      switch (target_gen) {\n+        case YOUNG_GENERATION: {\n+          ShenandoahThreadLocalData::gclab(thread)->undo_allocation(copy, size);\n+          break;\n+        }\n+        case OLD_GENERATION: {\n+          ShenandoahThreadLocalData::plab(thread)->undo_allocation(copy, size);\n+          if (is_promotion) {\n+            ShenandoahThreadLocalData::subtract_from_plab_promoted(thread, size * HeapWordSize);\n+          } else {\n+            ShenandoahThreadLocalData::subtract_from_plab_evacuated(thread, size * HeapWordSize);\n+          }\n+          break;\n+        }\n+        default: {\n+          ShouldNotReachHere();\n+          break;\n+        }\n+      }\n+    } else {\n+      \/\/ For non-LAB allocations, we have no way to retract the allocation, and\n+      \/\/ have to explicitly overwrite the copy with the filler object. With that overwrite,\n+      \/\/ we have to keep the fwdptr initialized and pointing to our (stale) copy.\n+      assert(size >= ShenandoahHeap::min_fill_size(), \"previously allocated object known to be larger than min_size\");\n+      fill_with_object(copy, size);\n+      shenandoah_assert_correct(nullptr, copy_val);\n+      \/\/ For non-LAB allocations, the object has already been registered\n+    }\n+    shenandoah_assert_correct(nullptr, result);\n+    return result;\n+  }\n+}\n+\n@@ -1942,2 +2024,1 @@\n-    \/\/ Return the max allowed size, and let the allocation path\n-    \/\/ figure out the safe size for current allocation.\n+    \/\/ Return the max allowed size, and let the allocation path figure out the safe size for current allocation.\n@@ -1989,2 +2070,4 @@\n-  tcl->do_thread(_control_thread);\n-  tcl->do_thread(_regulator_thread);\n+  if (_control_thread != nullptr) {\n+    tcl->do_thread(_control_thread);\n+  }\n+\n@@ -2020,0 +2103,2 @@\n+  shenandoah_policy()->record_collection_cause(cause);\n+\n@@ -2023,1 +2108,0 @@\n-  shenandoah_policy()->record_cycle_start();\n@@ -2402,3 +2486,8 @@\n-void ShenandoahHeap::set_gc_state_all_threads(char state) {\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {\n-    ShenandoahThreadLocalData::set_gc_state(t, state);\n+void ShenandoahHeap::propagate_gc_state_to_java_threads() {\n+  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Must be at Shenandoah safepoint\");\n+  if (_gc_state_changed) {\n+    _gc_state_changed = false;\n+    char state = gc_state();\n+    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {\n+      ShenandoahThreadLocalData::set_gc_state(t, state);\n+    }\n@@ -2408,2 +2497,2 @@\n-void ShenandoahHeap::set_gc_state_mask(uint mask, bool value) {\n-  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Should really be Shenandoah safepoint\");\n+void ShenandoahHeap::set_gc_state(uint mask, bool value) {\n+  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Must be at Shenandoah safepoint\");\n@@ -2411,5 +2500,1 @@\n-  set_gc_state_all_threads(_gc_state.raw_value());\n-}\n-\n-void ShenandoahHeap::set_evacuation_reserve_quantities(bool is_valid) {\n-  _has_evacuation_reserve_quantities = is_valid;\n+  _gc_state_changed = true;\n@@ -2429,1 +2514,1 @@\n-  set_gc_state_mask(mask, in_progress);\n+  set_gc_state(mask, in_progress);\n@@ -2445,1 +2530,1 @@\n-    set_gc_state_mask(OLD_MARKING, in_progress);\n+    set_gc_state(OLD_MARKING, in_progress);\n@@ -2447,1 +2532,1 @@\n-    set_gc_state_mask(MARKING | OLD_MARKING, in_progress);\n+    set_gc_state(MARKING | OLD_MARKING, in_progress);\n@@ -2478,1 +2563,1 @@\n-  set_gc_state_mask(EVACUATION, in_progress);\n+  set_gc_state(EVACUATION, in_progress);\n@@ -2490,1 +2575,1 @@\n-  set_gc_state_mask(WEAK_ROOTS, cond);\n+  set_gc_state(WEAK_ROOTS, cond);\n@@ -2533,4 +2618,1 @@\n-  \/\/ Step 2. Stop requesting collections.\n-  regulator_thread()->stop();\n-\n-  \/\/ Step 3. Notify control thread that we are in shutdown.\n+  \/\/ Step 2. Notify control thread that we are in shutdown.\n@@ -2541,1 +2623,1 @@\n-  \/\/ Step 4. Notify GC workers that we are cancelling GC.\n+  \/\/ Step 3. Notify GC workers that we are cancelling GC.\n@@ -2544,1 +2626,1 @@\n-  \/\/ Step 5. Wait until GC worker exits normally.\n+  \/\/ Step 4. Wait until GC worker exits normally.\n@@ -2621,1 +2703,1 @@\n-  set_gc_state_mask(HAS_FORWARDED, cond);\n+  set_gc_state(HAS_FORWARDED, cond);\n@@ -2661,1 +2743,1 @@\n-  set_gc_state_mask(UPDATEREFS, in_progress);\n+  set_gc_state(UPDATEREFS, in_progress);\n@@ -2743,6 +2825,3 @@\n-    if (UseDynamicNumberOfGCThreads) {\n-      assert(nworkers <= ParallelGCThreads, \"Cannot use more than it has\");\n-    } else {\n-      \/\/ Use ParallelGCThreads inside safepoints\n-      assert(nworkers == ParallelGCThreads, \"Use ParallelGCThreads within safepoints\");\n-    }\n+    \/\/ Use ParallelGCThreads inside safepoints\n+    assert(nworkers == ParallelGCThreads, \"Use ParallelGCThreads (%u) within safepoint, not %u\",\n+           ParallelGCThreads, nworkers);\n@@ -2750,6 +2829,3 @@\n-    if (UseDynamicNumberOfGCThreads) {\n-      assert(nworkers <= ConcGCThreads, \"Cannot use more than it has\");\n-    } else {\n-      \/\/ Use ConcGCThreads outside safepoints\n-      assert(nworkers == ConcGCThreads, \"Use ConcGCThreads outside safepoints\");\n-    }\n+    \/\/ Use ConcGCThreads outside safepoints\n+    assert(nworkers == ConcGCThreads, \"Use ConcGCThreads (%u) outside safepoints, %u\",\n+           ConcGCThreads, nworkers);\n@@ -3096,1 +3172,1 @@\n-    adjust_generation_sizes_for_next_cycle(allocation_runway, young_cset_regions, old_cset_regions);\n+    ShenandoahGenerationalHeap::heap()->compute_old_generation_balance(allocation_runway, old_cset_regions);\n@@ -3242,8 +3318,0 @@\n-void ShenandoahHeap::entry_uncommit(double shrink_before, size_t shrink_until) {\n-  static const char *msg = \"Concurrent uncommit\";\n-  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_uncommit, true \/* log_heap_usage *\/);\n-  EventMark em(\"%s\", msg);\n-\n-  op_uncommit(shrink_before, shrink_until);\n-}\n-\n@@ -3265,12 +3333,3 @@\n-  if (mode()->is_generational()) {\n-    _young_gen_memory_pool = new ShenandoahYoungGenMemoryPool(this);\n-    _old_gen_memory_pool = new ShenandoahOldGenMemoryPool(this);\n-    _cycle_memory_manager.add_pool(_young_gen_memory_pool);\n-    _cycle_memory_manager.add_pool(_old_gen_memory_pool);\n-    _stw_memory_manager.add_pool(_young_gen_memory_pool);\n-    _stw_memory_manager.add_pool(_old_gen_memory_pool);\n-  } else {\n-    _memory_pool = new ShenandoahMemoryPool(this);\n-    _cycle_memory_manager.add_pool(_memory_pool);\n-    _stw_memory_manager.add_pool(_memory_pool);\n-  }\n+  _memory_pool = new ShenandoahMemoryPool(this);\n+  _cycle_memory_manager.add_pool(_memory_pool);\n+  _stw_memory_manager.add_pool(_memory_pool);\n@@ -3288,6 +3347,1 @@\n-  if (mode()->is_generational()) {\n-    memory_pools.append(_young_gen_memory_pool);\n-    memory_pools.append(_old_gen_memory_pool);\n-  } else {\n-    memory_pools.append(_memory_pool);\n-  }\n+  memory_pools.append(_memory_pool);\n@@ -3386,1 +3440,1 @@\n-void ShenandoahGenerationRegionClosure<GLOBAL_GEN>::heap_region_do(ShenandoahHeapRegion* region) {\n+void ShenandoahGenerationRegionClosure<GLOBAL>::heap_region_do(ShenandoahHeapRegion* region) {\n@@ -3391,1 +3445,1 @@\n-void ShenandoahGenerationRegionClosure<GLOBAL_NON_GEN>::heap_region_do(ShenandoahHeapRegion* region) {\n+void ShenandoahGenerationRegionClosure<NON_GEN>::heap_region_do(ShenandoahHeapRegion* region) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":323,"deletions":269,"binary":false,"changes":592,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"gc\/shenandoah\/shenandoahController.hpp\"\n@@ -57,1 +58,0 @@\n-class ShenandoahControlThread;\n@@ -152,0 +152,1 @@\n+\n@@ -225,4 +226,0 @@\n-  size_t _promotion_potential;\n-  size_t _pad_for_promote_in_place;    \/\/ bytes of filler\n-  size_t _promotable_humongous_regions;\n-  size_t _regular_regions_promoted_in_place;\n@@ -258,0 +255,9 @@\n+\/\/ ---------- Periodic Tasks\n+\/\/\n+private:\n+  void notify_heap_changed();\n+\n+public:\n+  void set_forced_counters_update(bool value);\n+  void handle_force_counters_update();\n+\n@@ -265,0 +271,2 @@\n+  virtual void initialize_controller();\n+\n@@ -347,0 +355,1 @@\n+  bool _gc_state_changed;\n@@ -348,0 +357,1 @@\n+  ShenandoahSharedFlag   _heap_changed;\n@@ -351,1 +361,0 @@\n-  ShenandoahSharedFlag   _progress_last_gc;\n@@ -354,8 +363,1 @@\n-  \/\/ TODO: Revisit the following comment.  It may not accurately represent the true behavior when evacuations fail due to\n-  \/\/ difficulty finding memory to hold evacuated objects.\n-  \/\/\n-  \/\/ Note that the typical total expenditure on evacuation is less than the associated evacuation reserve because we generally\n-  \/\/ reserve ShenandoahEvacWaste (> 1.0) times the anticipated evacuation need.  In the case that there is an excessive amount\n-  \/\/ of waste, it may be that one thread fails to grab a new GCLAB, this does not necessarily doom the associated evacuation\n-  \/\/ effort.  If this happens, the requesting thread blocks until some other thread manages to evacuate the offending object.\n-  \/\/ Only after \"all\" threads fail to evacuate an object do we consider the evacuation effort to have failed.\n+  size_t _gc_no_progress_count;\n@@ -363,5 +365,2 @@\n-  size_t _promoted_reserve;            \/\/ Bytes reserved within old-gen to hold the results of promotion\n-  volatile size_t _promoted_expended;  \/\/ Bytes of old-gen memory expended on promotions\n-\n-  size_t _old_evac_reserve;            \/\/ Bytes reserved within old-gen to hold evacuated objects from old-gen collection set\n-  size_t _young_evac_reserve;          \/\/ Bytes reserved within young-gen to hold evacuated objects from young-gen collection set\n+  \/\/ This updates the singlular, global gc state. This must happen on a safepoint.\n+  void set_gc_state(uint mask, bool value);\n@@ -371,17 +370,0 @@\n-  \/\/ At the end of final mark, but before we begin evacuating, heuristics calculate how much memory is required to\n-  \/\/ hold the results of evacuating to young-gen and to old-gen.  These quantitites, stored in _promoted_reserve,\n-  \/\/ _old_evac_reserve, and _young_evac_reserve, are consulted prior to rebuilding the free set (ShenandoahFreeSet)\n-  \/\/ in preparation for evacuation.  When the free set is rebuilt, we make sure to reserve sufficient memory in the\n-  \/\/ collector and old_collector sets to hold if _has_evacuation_reserve_quantities is true.  The other time we\n-  \/\/ rebuild the freeset is at the end of GC, as we prepare to idle GC until the next trigger.  In this case,\n-  \/\/ _has_evacuation_reserve_quantities is false because we don't yet know how much memory will need to be evacuated\n-  \/\/ in the next GC cycle.  When _has_evacuation_reserve_quantities is false, the free set rebuild operation reserves\n-  \/\/ for the collector and old_collector sets based on alternative mechanisms, such as ShenandoahEvacReserve,\n-  \/\/ ShenandoahOldEvacReserve, and ShenandoahOldCompactionReserve.  In a future planned enhancement, the reserve\n-  \/\/ for old_collector set when not _has_evacuation_reserve_quantities is based in part on anticipated promotion as\n-  \/\/ determined by analysis of live data found during the previous GC pass which is one less than the current tenure age.\n-  bool _has_evacuation_reserve_quantities;\n-\n-  void set_gc_state_all_threads(char state);\n-  void set_gc_state_mask(uint mask, bool value);\n-\n@@ -391,1 +373,14 @@\n-  void set_evacuation_reserve_quantities(bool is_valid);\n+  \/\/ This copies the global gc state into a thread local variable for java threads.\n+  \/\/ It is primarily intended to support quick access at barriers.\n+  void propagate_gc_state_to_java_threads();\n+\n+  \/\/ This is public to support assertions that the state hasn't been changed off of\n+  \/\/ a safepoint and that any changes were propagated to java threads after the safepoint.\n+  bool has_gc_state_changed() const { return _gc_state_changed; }\n+\n+  \/\/ Returns true if allocations have occurred in new regions or if regions have been\n+  \/\/ uncommitted since the previous calls. This call will reset the flag to false.\n+  bool has_changed() {\n+    return _heap_changed.try_unset();\n+  }\n+\n@@ -407,1 +402,1 @@\n-  inline bool has_evacuation_reserve_quantities() const;\n+\n@@ -424,32 +419,0 @@\n-  inline void clear_promotion_potential() { _promotion_potential = 0; };\n-  inline void set_promotion_potential(size_t val) { _promotion_potential = val; };\n-  inline size_t get_promotion_potential() { return _promotion_potential; };\n-\n-  inline void set_pad_for_promote_in_place(size_t pad) { _pad_for_promote_in_place = pad; }\n-  inline size_t get_pad_for_promote_in_place() { return _pad_for_promote_in_place; }\n-\n-  inline void reserve_promotable_humongous_regions(size_t region_count) { _promotable_humongous_regions = region_count; }\n-  inline void reserve_promotable_regular_regions(size_t region_count) { _regular_regions_promoted_in_place = region_count; }\n-\n-  inline size_t get_promotable_humongous_regions() { return _promotable_humongous_regions; }\n-  inline size_t get_regular_regions_promoted_in_place() { return _regular_regions_promoted_in_place; }\n-\n-  \/\/ Returns previous value\n-  inline size_t set_promoted_reserve(size_t new_val);\n-  inline size_t get_promoted_reserve() const;\n-  inline void augment_promo_reserve(size_t increment);\n-\n-  inline void reset_promoted_expended();\n-  inline size_t expend_promoted(size_t increment);\n-  inline size_t unexpend_promoted(size_t decrement);\n-  inline size_t get_promoted_expended();\n-\n-  \/\/ Returns previous value\n-  inline size_t set_old_evac_reserve(size_t new_val);\n-  inline size_t get_old_evac_reserve() const;\n-  inline void augment_old_evac_reserve(size_t increment);\n-\n-  \/\/ Returns previous value\n-  inline size_t set_young_evac_reserve(size_t new_val);\n-  inline size_t get_young_evac_reserve() const;\n-\n@@ -491,2 +454,3 @@\n-  \/\/ Elastic heap support\n-  void entry_uncommit(double shrink_before, size_t shrink_until);\n+  \/\/ These will uncommit empty regions if heap::committed > shrink_until\n+  \/\/ and there exists at least one region which was made empty before shrink_before.\n+  void maybe_uncommit(double shrink_before, size_t shrink_until);\n@@ -495,0 +459,3 @@\n+  \/\/ Returns true if the soft maximum heap has been changed using management APIs.\n+  bool check_soft_max_changed();\n+\n@@ -514,2 +481,3 @@\n-  void notify_gc_progress()    { _progress_last_gc.set();   }\n-  void notify_gc_no_progress() { _progress_last_gc.unset(); }\n+  void notify_gc_progress();\n+  void notify_gc_no_progress();\n+  size_t get_gc_no_progress_count() const;\n@@ -524,2 +492,4 @@\n-  ShenandoahControlThread*   _control_thread;\n-  ShenandoahRegulatorThread* _regulator_thread;\n+protected:\n+  ShenandoahController*  _control_thread;\n+\n+private:\n@@ -537,2 +507,0 @@\n-  ShenandoahRegulatorThread* regulator_thread()        { return _regulator_thread;  }\n-\n@@ -540,1 +508,2 @@\n-  ShenandoahControlThread*   control_thread()          { return _control_thread;    }\n+  ShenandoahController*   control_thread() { return _control_thread; }\n+\n@@ -556,1 +525,1 @@\n-  ShenandoahEvacuationTracker* evac_tracker()    const { return  _evac_tracker;     }\n+  ShenandoahEvacuationTracker* evac_tracker()    const { return _evac_tracker;      }\n@@ -568,3 +537,0 @@\n-  MemoryPool*                  _young_gen_memory_pool;\n-  MemoryPool*                  _old_gen_memory_pool;\n-\n@@ -689,4 +655,0 @@\n-  \/\/ How many bytes to transfer between old and young after we have finished recycling collection set regions?\n-  size_t _old_regions_surplus;\n-  size_t _old_regions_deficit;\n-\n@@ -724,6 +686,0 @@\n-  inline void set_old_region_surplus(size_t surplus) { _old_regions_surplus = surplus; };\n-  inline void set_old_region_deficit(size_t deficit) { _old_regions_deficit = deficit; };\n-\n-  inline size_t get_old_region_surplus() { return _old_regions_surplus; };\n-  inline size_t get_old_region_deficit() { return _old_regions_deficit; };\n-\n@@ -783,5 +739,0 @@\n-  ShenandoahSharedFlag _old_gen_oom_evac;\n-\n-  inline oop try_evacuate_object(oop src, Thread* thread, ShenandoahHeapRegion* from_region, ShenandoahAffiliation target_gen);\n-  void handle_old_evacuation(HeapWord* obj, size_t words, bool promotion);\n-  void handle_old_evacuation_failure();\n@@ -789,0 +740,1 @@\n+  oop try_evacuate_object(oop src, Thread* thread, ShenandoahHeapRegion* from_region, ShenandoahAffiliation target_gen);\n@@ -790,1 +742,0 @@\n-  void report_promotion_failure(Thread* thread, size_t size);\n@@ -810,2 +761,0 @@\n-  inline bool clear_old_evacuation_failure();\n-\n@@ -825,2 +774,0 @@\n-  void adjust_generation_sizes_for_next_cycle(size_t old_xfer_limit, size_t young_cset_regions, size_t old_cset_regions);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":50,"deletions":103,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-#include \"gc\/shenandoah\/shenandoahControlThread.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalControlThread.hpp\"\n@@ -46,1 +46,0 @@\n-#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n@@ -81,0 +80,12 @@\n+inline void ShenandoahHeap::notify_gc_progress() {\n+  Atomic::store(&_gc_no_progress_count, (size_t) 0);\n+\n+}\n+inline void ShenandoahHeap::notify_gc_no_progress() {\n+  Atomic::inc(&_gc_no_progress_count);\n+}\n+\n+inline size_t ShenandoahHeap::get_gc_no_progress_count() const {\n+  return Atomic::load(&_gc_no_progress_count);\n+}\n+\n@@ -363,177 +374,0 @@\n-\/\/ try_evacuate_object registers the object and dirties the associated remembered set information when evacuating\n-\/\/ to OLD_GENERATION.\n-inline oop ShenandoahHeap::try_evacuate_object(oop p, Thread* thread, ShenandoahHeapRegion* from_region,\n-                                               ShenandoahAffiliation target_gen) {\n-  bool alloc_from_lab = true;\n-  bool has_plab = false;\n-  HeapWord* copy = nullptr;\n-  size_t size = p->size();\n-  bool is_promotion = (target_gen == OLD_GENERATION) && from_region->is_young();\n-\n-#ifdef ASSERT\n-  if (ShenandoahOOMDuringEvacALot &&\n-      (os::random() & 1) == 0) { \/\/ Simulate OOM every ~2nd slow-path call\n-        copy = nullptr;\n-  } else {\n-#endif\n-    if (UseTLAB) {\n-      switch (target_gen) {\n-        case YOUNG_GENERATION: {\n-           copy = allocate_from_gclab(thread, size);\n-           if ((copy == nullptr) && (size < ShenandoahThreadLocalData::gclab_size(thread))) {\n-             \/\/ GCLAB allocation failed because we are bumping up against the limit on young evacuation reserve.  Try resetting\n-             \/\/ the desired GCLAB size and retry GCLAB allocation to avoid cascading of shared memory allocations.\n-             ShenandoahThreadLocalData::set_gclab_size(thread, PLAB::min_size());\n-             copy = allocate_from_gclab(thread, size);\n-             \/\/ If we still get nullptr, we'll try a shared allocation below.\n-           }\n-           break;\n-        }\n-        case OLD_GENERATION: {\n-           PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n-           if (plab != nullptr) {\n-             has_plab = true;\n-           }\n-           copy = allocate_from_plab(thread, size, is_promotion);\n-           if ((copy == nullptr) && (size < ShenandoahThreadLocalData::plab_size(thread)) &&\n-               ShenandoahThreadLocalData::plab_retries_enabled(thread)) {\n-             \/\/ PLAB allocation failed because we are bumping up against the limit on old evacuation reserve or because\n-             \/\/ the requested object does not fit within the current plab but the plab still has an \"abundance\" of memory,\n-             \/\/ where abundance is defined as >= PLAB::min_size().  In the former case, we try resetting the desired\n-             \/\/ PLAB size and retry PLAB allocation to avoid cascading of shared memory allocations.\n-\n-             \/\/ In this situation, PLAB memory is precious.  We'll try to preserve our existing PLAB by forcing\n-             \/\/ this particular allocation to be shared.\n-             if (plab->words_remaining() < PLAB::min_size()) {\n-               ShenandoahThreadLocalData::set_plab_size(thread, PLAB::min_size());\n-               copy = allocate_from_plab(thread, size, is_promotion);\n-               \/\/ If we still get nullptr, we'll try a shared allocation below.\n-               if (copy == nullptr) {\n-                 \/\/ If retry fails, don't continue to retry until we have success (probably in next GC pass)\n-                 ShenandoahThreadLocalData::disable_plab_retries(thread);\n-               }\n-             }\n-             \/\/ else, copy still equals nullptr.  this causes shared allocation below, preserving this plab for future needs.\n-           }\n-           break;\n-        }\n-        default: {\n-          ShouldNotReachHere();\n-          break;\n-        }\n-      }\n-    }\n-\n-    if (copy == nullptr) {\n-      \/\/ If we failed to allocate in LAB, we'll try a shared allocation.\n-      if (!is_promotion || !has_plab || (size > PLAB::min_size())) {\n-        ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(size, target_gen);\n-        copy = allocate_memory(req, is_promotion);\n-        alloc_from_lab = false;\n-      }\n-      \/\/ else, we leave copy equal to nullptr, signaling a promotion failure below if appropriate.\n-      \/\/ We choose not to promote objects smaller than PLAB::min_size() by way of shared allocations, as this is too\n-      \/\/ costly.  Instead, we'll simply \"evacuate\" to young-gen memory (using a GCLAB) and will promote in a future\n-      \/\/ evacuation pass.  This condition is denoted by: is_promotion && has_plab && (size <= PLAB::min_size())\n-    }\n-#ifdef ASSERT\n-  }\n-#endif\n-\n-  if (copy == nullptr) {\n-    if (target_gen == OLD_GENERATION) {\n-      assert(mode()->is_generational(), \"Should only be here in generational mode.\");\n-      if (from_region->is_young()) {\n-        \/\/ Signal that promotion failed. Will evacuate this old object somewhere in young gen.\n-        report_promotion_failure(thread, size);\n-        return nullptr;\n-      } else {\n-        \/\/ Remember that evacuation to old gen failed. We'll want to trigger a full gc to recover from this\n-        \/\/ after the evacuation threads have finished.\n-        handle_old_evacuation_failure();\n-      }\n-    }\n-\n-    control_thread()->handle_alloc_failure_evac(size);\n-\n-    _oom_evac_handler.handle_out_of_memory_during_evacuation();\n-\n-    return ShenandoahBarrierSet::resolve_forwarded(p);\n-  }\n-\n-  \/\/ Copy the object:\n-  _evac_tracker->begin_evacuation(thread, size * HeapWordSize);\n-  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(p), copy, size);\n-\n-  oop copy_val = cast_to_oop(copy);\n-\n-  if (mode()->is_generational() && target_gen == YOUNG_GENERATION && is_aging_cycle()) {\n-    ShenandoahHeap::increase_object_age(copy_val, from_region->age() + 1);\n-  }\n-\n-  \/\/ Try to install the new forwarding pointer.\n-  ContinuationGCSupport::relativize_stack_chunk(copy_val);\n-\n-  oop result = ShenandoahForwarding::try_update_forwardee(p, copy_val);\n-  if (result == copy_val) {\n-    \/\/ Successfully evacuated. Our copy is now the public one!\n-    _evac_tracker->end_evacuation(thread, size * HeapWordSize);\n-    if (mode()->is_generational()) {\n-      if (target_gen == OLD_GENERATION) {\n-        handle_old_evacuation(copy, size, from_region->is_young());\n-      } else {\n-        \/\/ When copying to the old generation above, we don't care\n-        \/\/ about recording object age in the census stats.\n-        assert(target_gen == YOUNG_GENERATION, \"Error\");\n-        \/\/ We record this census only when simulating pre-adaptive tenuring behavior, or\n-        \/\/ when we have been asked to record the census at evacuation rather than at mark\n-        if (ShenandoahGenerationalCensusAtEvac || !ShenandoahGenerationalAdaptiveTenuring) {\n-          _evac_tracker->record_age(thread, size * HeapWordSize, ShenandoahHeap::get_object_age(copy_val));\n-        }\n-      }\n-    }\n-    shenandoah_assert_correct(nullptr, copy_val);\n-    return copy_val;\n-  }  else {\n-    \/\/ Failed to evacuate. We need to deal with the object that is left behind. Since this\n-    \/\/ new allocation is certainly after TAMS, it will be considered live in the next cycle.\n-    \/\/ But if it happens to contain references to evacuated regions, those references would\n-    \/\/ not get updated for this stale copy during this cycle, and we will crash while scanning\n-    \/\/ it the next cycle.\n-    if (alloc_from_lab) {\n-       \/\/ For LAB allocations, it is enough to rollback the allocation ptr. Either the next\n-       \/\/ object will overwrite this stale copy, or the filler object on LAB retirement will\n-       \/\/ do this.\n-       switch (target_gen) {\n-         case YOUNG_GENERATION: {\n-             ShenandoahThreadLocalData::gclab(thread)->undo_allocation(copy, size);\n-            break;\n-         }\n-         case OLD_GENERATION: {\n-            ShenandoahThreadLocalData::plab(thread)->undo_allocation(copy, size);\n-            if (is_promotion) {\n-              ShenandoahThreadLocalData::subtract_from_plab_promoted(thread, size * HeapWordSize);\n-            } else {\n-              ShenandoahThreadLocalData::subtract_from_plab_evacuated(thread, size * HeapWordSize);\n-            }\n-            break;\n-         }\n-         default: {\n-           ShouldNotReachHere();\n-           break;\n-         }\n-       }\n-    } else {\n-      \/\/ For non-LAB allocations, we have no way to retract the allocation, and\n-      \/\/ have to explicitly overwrite the copy with the filler object. With that overwrite,\n-      \/\/ we have to keep the fwdptr initialized and pointing to our (stale) copy.\n-      assert(size >= ShenandoahHeap::min_fill_size(), \"previously allocated object known to be larger than min_size\");\n-      fill_with_object(copy, size);\n-      shenandoah_assert_correct(nullptr, copy_val);\n-      \/\/ For non-LAB allocations, the object has already been registered\n-    }\n-    shenandoah_assert_correct(nullptr, result);\n-    return result;\n-  }\n-}\n-\n@@ -588,4 +422,0 @@\n-inline bool ShenandoahHeap::clear_old_evacuation_failure() {\n-  return _old_gen_oom_evac.try_unset();\n-}\n-\n@@ -700,4 +530,0 @@\n-inline bool ShenandoahHeap::has_evacuation_reserve_quantities() const {\n-  return _has_evacuation_reserve_quantities;\n-}\n-\n@@ -756,54 +582,0 @@\n-inline size_t ShenandoahHeap::set_promoted_reserve(size_t new_val) {\n-  size_t orig = _promoted_reserve;\n-  _promoted_reserve = new_val;\n-  return orig;\n-}\n-\n-inline size_t ShenandoahHeap::get_promoted_reserve() const {\n-  return _promoted_reserve;\n-}\n-\n-inline size_t ShenandoahHeap::set_old_evac_reserve(size_t new_val) {\n-  size_t orig = _old_evac_reserve;\n-  _old_evac_reserve = new_val;\n-  return orig;\n-}\n-\n-inline size_t ShenandoahHeap::get_old_evac_reserve() const {\n-  return _old_evac_reserve;\n-}\n-\n-inline void ShenandoahHeap::augment_old_evac_reserve(size_t increment) {\n-  _old_evac_reserve += increment;\n-}\n-\n-inline void ShenandoahHeap::augment_promo_reserve(size_t increment) {\n-  _promoted_reserve += increment;\n-}\n-\n-inline void ShenandoahHeap::reset_promoted_expended() {\n-  Atomic::store(&_promoted_expended, (size_t) 0);\n-}\n-\n-inline size_t ShenandoahHeap::expend_promoted(size_t increment) {\n-  return Atomic::add(&_promoted_expended, increment);\n-}\n-\n-inline size_t ShenandoahHeap::unexpend_promoted(size_t decrement) {\n-  return Atomic::sub(&_promoted_expended, decrement);\n-}\n-\n-inline size_t ShenandoahHeap::get_promoted_expended() {\n-  return Atomic::load(&_promoted_expended);\n-}\n-\n-inline size_t ShenandoahHeap::set_young_evac_reserve(size_t new_val) {\n-  size_t orig = _young_evac_reserve;\n-  _young_evac_reserve = new_val;\n-  return orig;\n-}\n-\n-inline size_t ShenandoahHeap::get_young_evac_reserve() const {\n-  return _young_evac_reserve;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":13,"deletions":241,"binary":false,"changes":254,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"gc\/shenandoah\/shenandoahPacer.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -160,2 +160,2 @@\n-    case GLOBAL_NON_GEN:\n-    case GLOBAL_GEN:\n+    case NON_GEN:\n+    case GLOBAL:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionCounters.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,3 +44,3 @@\n-  log_info(gc, init)(\"Heap Region Size: \" PROPERFMT, PROPERFMTARGS(ShenandoahHeapRegion::region_size_bytes()));\n-  log_info(gc, init)(\"TLAB Size Max: \" PROPERFMT, PROPERFMTARGS(ShenandoahHeapRegion::max_tlab_size_bytes()));\n-  log_info(gc, init)(\"Humongous Object Threshold: \" PROPERFMT, PROPERFMTARGS(ShenandoahHeapRegion::humongous_threshold_bytes()));\n+  log_info(gc, init)(\"Heap Region Size: \" EXACTFMT, EXACTFMTARGS(ShenandoahHeapRegion::region_size_bytes()));\n+  log_info(gc, init)(\"TLAB Size Max: \" EXACTFMT, EXACTFMTARGS(ShenandoahHeapRegion::max_tlab_size_bytes()));\n+  log_info(gc, init)(\"Humongous Object Threshold: \" EXACTFMT, EXACTFMTARGS(ShenandoahHeapRegion::humongous_threshold_bytes()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahInitLogger.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -34,0 +35,37 @@\n+\/\/ These are inline variants of Thread::SpinAcquire with optional blocking in VM.\n+\n+class ShenandoahNoBlockOp : public StackObj {\n+public:\n+  ShenandoahNoBlockOp(JavaThread* java_thread) {\n+    assert(java_thread == nullptr, \"Should not pass anything\");\n+  }\n+};\n+\n+void ShenandoahLock::contended_lock(bool allow_block_for_safepoint) {\n+  Thread* thread = Thread::current();\n+  if (allow_block_for_safepoint && thread->is_Java_thread()) {\n+    contended_lock_internal<ThreadBlockInVM>(JavaThread::cast(thread));\n+  } else {\n+    contended_lock_internal<ShenandoahNoBlockOp>(nullptr);\n+  }\n+}\n+\n+template<typename BlockOp>\n+void ShenandoahLock::contended_lock_internal(JavaThread* java_thread) {\n+  int ctr = 0;\n+  int yields = 0;\n+  while (Atomic::cmpxchg(&_state, unlocked, locked) != unlocked) {\n+    if ((++ctr & 0xFFF) == 0) {\n+      BlockOp block(java_thread);\n+      if (yields > 5) {\n+        os::naked_short_sleep(1);\n+      } else {\n+        os::naked_yield();\n+        yields++;\n+      }\n+    } else {\n+      SpinPause();\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  volatile int _state;\n+  volatile LockState _state;\n@@ -43,0 +43,3 @@\n+  template<typename BlockOp>\n+  void contended_lock_internal(JavaThread* java_thread);\n+\n@@ -46,10 +49,11 @@\n-  void lock() {\n-#ifdef ASSERT\n-    assert(_owner != Thread::current(), \"reentrant locking attempt, would deadlock\");\n-#endif\n-    Thread::SpinAcquire(&_state, \"Shenandoah Heap Lock\");\n-#ifdef ASSERT\n-    assert(_state == locked, \"must be locked\");\n-    assert(_owner == nullptr, \"must not be owned\");\n-    _owner = Thread::current();\n-#endif\n+  void lock(bool allow_block_for_safepoint) {\n+    assert(Atomic::load(&_owner) != Thread::current(), \"reentrant locking attempt, would deadlock\");\n+\n+    \/\/ Try to lock fast, or dive into contended lock handling.\n+    if (Atomic::cmpxchg(&_state, unlocked, locked) != unlocked) {\n+      contended_lock(allow_block_for_safepoint);\n+    }\n+\n+    assert(Atomic::load(&_state) == locked, \"must be locked\");\n+    assert(Atomic::load(&_owner) == nullptr, \"must not be owned\");\n+    DEBUG_ONLY(Atomic::store(&_owner, Thread::current());)\n@@ -59,5 +63,4 @@\n-#ifdef ASSERT\n-    assert (_owner == Thread::current(), \"sanity\");\n-    _owner = nullptr;\n-#endif\n-    Thread::SpinRelease(&_state);\n+    assert(Atomic::load(&_owner) == Thread::current(), \"sanity\");\n+    DEBUG_ONLY(Atomic::store(&_owner, (Thread*)nullptr);)\n+    OrderAccess::fence();\n+    Atomic::store(&_state, unlocked);\n@@ -66,0 +69,2 @@\n+  void contended_lock(bool allow_block_for_safepoint);\n+\n@@ -80,1 +85,1 @@\n-  ShenandoahLocker(ShenandoahLock* lock) : _lock(lock) {\n+  ShenandoahLocker(ShenandoahLock* lock, bool allow_block_for_safepoint = false) : _lock(lock) {\n@@ -82,1 +87,1 @@\n-      _lock->lock();\n+      _lock->lock(allow_block_for_safepoint);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.hpp","additions":23,"deletions":18,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -91,1 +91,2 @@\n-void ShenandoahMark::mark_loop(ShenandoahGenerationType generation, uint worker_id, TaskTerminator* terminator, ShenandoahReferenceProcessor *rp, StringDedup::Requests* const req) {\n+void ShenandoahMark::mark_loop(uint worker_id, TaskTerminator* terminator, ShenandoahReferenceProcessor *rp,\n+                               ShenandoahGenerationType generation, StringDedup::Requests* const req) {\n@@ -101,2 +102,2 @@\n-    case GLOBAL_GEN:\n-      mark_loop_prework<GLOBAL_GEN, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, rp, req, update_refs);\n+    case GLOBAL:\n+      mark_loop_prework<GLOBAL, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, rp, req, update_refs);\n@@ -104,2 +105,2 @@\n-    case GLOBAL_NON_GEN:\n-      mark_loop_prework<GLOBAL_NON_GEN, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, rp, req, update_refs);\n+    case NON_GEN:\n+      mark_loop_prework<NON_GEN, CANCELLABLE, STRING_DEDUP>(worker_id, terminator, rp, req, update_refs);\n@@ -113,2 +114,2 @@\n-void ShenandoahMark::mark_loop(ShenandoahGenerationType generation, uint worker_id, TaskTerminator* terminator, ShenandoahReferenceProcessor *rp,\n-                               bool cancellable, StringDedupMode dedup_mode, StringDedup::Requests* const req) {\n+void ShenandoahMark::mark_loop(uint worker_id, TaskTerminator* terminator, ShenandoahReferenceProcessor *rp,\n+                               ShenandoahGenerationType generation, bool cancellable, StringDedupMode dedup_mode, StringDedup::Requests* const req) {\n@@ -118,1 +119,1 @@\n-        mark_loop<true, NO_DEDUP>(generation, worker_id, terminator, rp, req);\n+        mark_loop<true, NO_DEDUP>(worker_id, terminator, rp, generation, req);\n@@ -121,1 +122,1 @@\n-        mark_loop<true, ENQUEUE_DEDUP>(generation, worker_id, terminator, rp, req);\n+        mark_loop<true, ENQUEUE_DEDUP>(worker_id, terminator, rp, generation, req);\n@@ -124,1 +125,1 @@\n-        mark_loop<true, ALWAYS_DEDUP>(generation, worker_id, terminator, rp, req);\n+        mark_loop<true, ALWAYS_DEDUP>(worker_id, terminator, rp, generation, req);\n@@ -130,1 +131,1 @@\n-        mark_loop<false, NO_DEDUP>(generation, worker_id, terminator, rp, req);\n+        mark_loop<false, NO_DEDUP>(worker_id, terminator, rp, generation, req);\n@@ -133,1 +134,1 @@\n-        mark_loop<false, ENQUEUE_DEDUP>(generation, worker_id, terminator, rp, req);\n+        mark_loop<false, ENQUEUE_DEDUP>(worker_id, terminator, rp, generation, req);\n@@ -136,1 +137,1 @@\n-        mark_loop<false, ALWAYS_DEDUP>(generation, worker_id, terminator, rp, req);\n+        mark_loop<false, ALWAYS_DEDUP>(worker_id, terminator, rp, generation, req);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.cpp","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -32,1 +32,3 @@\n-#include \"gc\/shenandoah\/shenandoahOopClosures.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationType.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -35,0 +37,9 @@\n+enum StringDedupMode {\n+  NO_DEDUP,      \/\/ Do not do anything for String deduplication\n+  ENQUEUE_DEDUP, \/\/ Enqueue candidate Strings for deduplication, if meet age threshold\n+  ALWAYS_DEDUP   \/\/ Enqueue Strings for deduplication\n+};\n+\n+class ShenandoahMarkingContext;\n+class ShenandoahReferenceProcessor;\n+\n@@ -98,2 +109,2 @@\n-  void mark_loop(ShenandoahGenerationType generation, uint worker_id, TaskTerminator* terminator, ShenandoahReferenceProcessor *rp,\n-                 StringDedup::Requests* const req);\n+  void mark_loop(uint worker_id, TaskTerminator* terminator, ShenandoahReferenceProcessor *rp,\n+                 ShenandoahGenerationType generation, StringDedup::Requests* const req);\n@@ -101,2 +112,2 @@\n-  void mark_loop(ShenandoahGenerationType generation, uint worker_id, TaskTerminator* terminator, ShenandoahReferenceProcessor *rp,\n-                 bool cancellable, StringDedupMode dedup_mode, StringDedup::Requests* const req);\n+  void mark_loop(uint worker_id, TaskTerminator* terminator, ShenandoahReferenceProcessor *rp,\n+                 ShenandoahGenerationType generation, bool cancellable, StringDedupMode dedup_mode, StringDedup::Requests* const req);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.hpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/shenandoah\/shenandoahOopClosures.inline.hpp\"\n@@ -118,1 +119,1 @@\n-  if (GENERATION == YOUNG || (GENERATION == GLOBAL_GEN && region->is_young())) {\n+  if (GENERATION == YOUNG || (GENERATION == GLOBAL && region->is_young())) {\n@@ -284,1 +285,1 @@\n-  } else if (GENERATION == GLOBAL_GEN || GENERATION == GLOBAL_NON_GEN) {\n+  } else if (GENERATION == GLOBAL || GENERATION == NON_GEN) {\n@@ -306,1 +307,1 @@\n-      \/\/ TODO: As implemented herein, GLOBAL_GEN collections reconstruct the card table during GLOBAL_GEN concurrent\n+      \/\/ TODO: As implemented herein, GLOBAL collections reconstruct the card table during GLOBAL concurrent\n@@ -314,1 +315,1 @@\n-      } else if (GENERATION == GLOBAL_GEN && heap->is_in_old(p) && heap->is_in_young(obj)) {\n+      } else if (GENERATION == GLOBAL && heap->is_in_old(p) && heap->is_in_young(obj)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.inline.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  virtual void update_all() {\n+  void update_all() override {\n@@ -49,1 +49,1 @@\n-  ShenandoahGenerationCounters(ShenandoahHeap* heap) :\n+  explicit ShenandoahGenerationCounters(ShenandoahHeap* heap) :\n@@ -54,1 +54,1 @@\n-  virtual void update_all() {\n+  void update_all() override {\n@@ -61,1 +61,2 @@\n-        _full_counters(nullptr)\n+        _full_counters(nullptr),\n+        _counters_update_task(this)\n@@ -74,0 +75,2 @@\n+\n+  _counters_update_task.enroll();\n@@ -106,0 +109,41 @@\n+\n+void ShenandoahMonitoringSupport::notify_heap_changed() {\n+  _counters_update_task.notify_heap_changed();\n+}\n+\n+void ShenandoahMonitoringSupport::set_forced_counters_update(bool value) {\n+  _counters_update_task.set_forced_counters_update(value);\n+}\n+\n+void ShenandoahMonitoringSupport::handle_force_counters_update() {\n+  _counters_update_task.handle_force_counters_update();\n+}\n+\n+void ShenandoahPeriodicCountersUpdateTask::task() {\n+  handle_force_counters_update();\n+  handle_counters_update();\n+}\n+\n+void ShenandoahPeriodicCountersUpdateTask::handle_counters_update() {\n+  if (_do_counters_update.is_set()) {\n+    _do_counters_update.unset();\n+    _monitoring_support->update_counters();\n+  }\n+}\n+\n+void ShenandoahPeriodicCountersUpdateTask::handle_force_counters_update() {\n+  if (_force_counters_update.is_set()) {\n+    _do_counters_update.unset(); \/\/ reset these too, we do update now!\n+    _monitoring_support->update_counters();\n+  }\n+}\n+\n+void ShenandoahPeriodicCountersUpdateTask::notify_heap_changed() {\n+  if (_do_counters_update.is_unset()) {\n+    _do_counters_update.set();\n+  }\n+}\n+\n+void ShenandoahPeriodicCountersUpdateTask::set_forced_counters_update(bool value) {\n+  _force_counters_update.set_cond(value);\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMonitoringSupport.cpp","additions":48,"deletions":4,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"runtime\/task.hpp\"\n@@ -35,0 +37,20 @@\n+class ShenandoahMonitoringSupport;\n+\n+class ShenandoahPeriodicCountersUpdateTask : public PeriodicTask {\n+private:\n+  ShenandoahSharedFlag _do_counters_update;\n+  ShenandoahSharedFlag _force_counters_update;\n+  ShenandoahMonitoringSupport* const _monitoring_support;\n+\n+public:\n+  explicit ShenandoahPeriodicCountersUpdateTask(ShenandoahMonitoringSupport* monitoring_support) :\n+    PeriodicTask(100),\n+    _monitoring_support(monitoring_support) { }\n+\n+  void task() override;\n+\n+  void handle_counters_update();\n+  void handle_force_counters_update();\n+  void set_forced_counters_update(bool value);\n+  void notify_heap_changed();\n+};\n@@ -47,0 +69,1 @@\n+  ShenandoahPeriodicCountersUpdateTask _counters_update_task;\n@@ -49,6 +72,11 @@\n- ShenandoahMonitoringSupport(ShenandoahHeap* heap);\n- CollectorCounters* stw_collection_counters();\n- CollectorCounters* full_stw_collection_counters();\n- CollectorCounters* concurrent_collection_counters();\n- CollectorCounters* partial_collection_counters();\n- void update_counters();\n+  explicit ShenandoahMonitoringSupport(ShenandoahHeap* heap);\n+  CollectorCounters* stw_collection_counters();\n+  CollectorCounters* full_stw_collection_counters();\n+  CollectorCounters* concurrent_collection_counters();\n+  CollectorCounters* partial_collection_counters();\n+\n+  void notify_heap_changed();\n+  void set_forced_counters_update(bool value);\n+  void handle_force_counters_update();\n+\n+  void update_counters();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMonitoringSupport.hpp","additions":34,"deletions":6,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -40,2 +41,0 @@\n-\n-\n@@ -88,1 +87,1 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  auto heap = ShenandoahGenerationalHeap::heap();\n@@ -151,1 +150,1 @@\n-  \/\/ We do not rebuild_free following increments of old marking because memory has not been reclaimed..  However, we may\n+  \/\/ We do not rebuild_free following increments of old marking because memory has not been reclaimed. However, we may\n@@ -154,1 +153,1 @@\n-  heap->adjust_generation_sizes_for_next_cycle(allocation_runway, 0, 0);\n+  heap->compute_old_generation_balance(allocation_runway, 0);\n@@ -156,5 +155,1 @@\n-  bool success;\n-  size_t region_xfer;\n-  const char* region_destination;\n-  ShenandoahYoungGeneration* young_gen = heap->young_generation();\n-  ShenandoahGeneration* old_gen = heap->old_generation();\n+  ShenandoahGenerationalHeap::TransferResult result;\n@@ -163,21 +158,1 @@\n-\n-    size_t old_region_surplus = heap->get_old_region_surplus();\n-    size_t old_region_deficit = heap->get_old_region_deficit();\n-    if (old_region_surplus) {\n-      success = heap->generation_sizer()->transfer_to_young(old_region_surplus);\n-      region_destination = \"young\";\n-      region_xfer = old_region_surplus;\n-    } else if (old_region_deficit) {\n-      success = heap->generation_sizer()->transfer_to_old(old_region_deficit);\n-      region_destination = \"old\";\n-      region_xfer = old_region_deficit;\n-      if (!success) {\n-        ((ShenandoahOldHeuristics *) old_gen->heuristics())->trigger_cannot_expand();\n-      }\n-    } else {\n-      region_destination = \"none\";\n-      region_xfer = 0;\n-      success = true;\n-    }\n-    heap->set_old_region_surplus(0);\n-    heap->set_old_region_deficit(0);\n+    result = heap->balance_generations();\n@@ -186,8 +161,5 @@\n-  \/\/ Report outside the heap lock\n-  size_t young_available = young_gen->available();\n-  size_t old_available = old_gen->available();\n-  log_info(gc, ergo)(\"After old marking finished, %s \" SIZE_FORMAT \" regions to %s to prepare for next gc, old available: \"\n-                     SIZE_FORMAT \"%s, young_available: \" SIZE_FORMAT \"%s\",\n-                     success? \"successfully transferred\": \"failed to transfer\", region_xfer, region_destination,\n-                     byte_size_in_proper_unit(old_available), proper_unit_for_byte_size(old_available),\n-                     byte_size_in_proper_unit(young_available), proper_unit_for_byte_size(young_available));\n+  LogTarget(Info, gc, ergo) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    result.print_on(\"Old Mark\", &ls);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":11,"deletions":39,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -30,3 +30,0 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp\"\n-#include \"gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.hpp\"\n-#include \"gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.hpp\"\n@@ -34,1 +31,0 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.hpp\"\n@@ -37,0 +33,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -41,1 +38,0 @@\n-#include \"gc\/shenandoah\/shenandoahMark.inline.hpp\"\n@@ -46,1 +42,0 @@\n-#include \"gc\/shenandoah\/shenandoahStringDedup.hpp\"\n@@ -50,1 +45,0 @@\n-#include \"prims\/jvmtiTagMap.hpp\"\n@@ -177,0 +171,9 @@\n+    _old_heuristics(nullptr),\n+    _region_surplus(0),\n+    _region_deficit(0),\n+    _promoted_reserve(0),\n+    _promoted_expended(0),\n+    _promotion_potential(0),\n+    _pad_for_promote_in_place(0),\n+    _promotable_humongous_regions(0),\n+    _promotable_regular_regions(0),\n@@ -186,0 +189,33 @@\n+void ShenandoahOldGeneration::set_promoted_reserve(size_t new_val) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  _promoted_reserve = new_val;\n+}\n+\n+size_t ShenandoahOldGeneration::get_promoted_reserve() const {\n+  return _promoted_reserve;\n+}\n+\n+void ShenandoahOldGeneration::augment_promoted_reserve(size_t increment) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  _promoted_reserve += increment;\n+}\n+\n+void ShenandoahOldGeneration::reset_promoted_expended() {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  Atomic::store(&_promoted_expended, (size_t) 0);\n+}\n+\n+size_t ShenandoahOldGeneration::expend_promoted(size_t increment) {\n+  shenandoah_assert_heaplocked_or_safepoint();\n+  assert(get_promoted_expended() + increment <= get_promoted_reserve(), \"Do not expend more promotion than budgeted\");\n+  return Atomic::add(&_promoted_expended, increment);\n+}\n+\n+size_t ShenandoahOldGeneration::unexpend_promoted(size_t decrement) {\n+  return Atomic::sub(&_promoted_expended, decrement);\n+}\n+\n+size_t ShenandoahOldGeneration::get_promoted_expended() {\n+  return Atomic::load(&_promoted_expended);\n+}\n+\n@@ -198,0 +234,4 @@\n+void ShenandoahOldGeneration::handle_failed_transfer() {\n+  _old_heuristics->trigger_cannot_expand();\n+}\n+\n@@ -469,0 +509,64 @@\n+\n+void ShenandoahOldGeneration::handle_failed_evacuation() {\n+  if (_failed_evacuation.try_set()) {\n+    log_info(gc)(\"Old gen evac failure.\");\n+  }\n+}\n+\n+void ShenandoahOldGeneration::handle_failed_promotion(Thread* thread, size_t size) {\n+  \/\/ We squelch excessive reports to reduce noise in logs.\n+  const size_t MaxReportsPerEpoch = 4;\n+  static size_t last_report_epoch = 0;\n+  static size_t epoch_report_count = 0;\n+  auto heap = ShenandoahGenerationalHeap::heap();\n+\n+  size_t promotion_reserve;\n+  size_t promotion_expended;\n+\n+  const size_t gc_id = heap->control_thread()->get_gc_id();\n+\n+  if ((gc_id != last_report_epoch) || (epoch_report_count++ < MaxReportsPerEpoch)) {\n+    {\n+      \/\/ Promotion failures should be very rare.  Invest in providing useful diagnostic info.\n+      ShenandoahHeapLocker locker(heap->lock());\n+      promotion_reserve = get_promoted_reserve();\n+      promotion_expended = get_promoted_expended();\n+    }\n+    PLAB* const plab = ShenandoahThreadLocalData::plab(thread);\n+    const size_t words_remaining = (plab == nullptr)? 0: plab->words_remaining();\n+    const char* promote_enabled = ShenandoahThreadLocalData::allow_plab_promotions(thread)? \"enabled\": \"disabled\";\n+\n+    log_info(gc, ergo)(\"Promotion failed, size \" SIZE_FORMAT \", has plab? %s, PLAB remaining: \" SIZE_FORMAT\n+                       \", plab promotions %s, promotion reserve: \" SIZE_FORMAT \", promotion expended: \" SIZE_FORMAT\n+                       \", old capacity: \" SIZE_FORMAT \", old_used: \" SIZE_FORMAT \", old unaffiliated regions: \" SIZE_FORMAT,\n+                       size * HeapWordSize, plab == nullptr? \"no\": \"yes\",\n+                       words_remaining * HeapWordSize, promote_enabled, promotion_reserve, promotion_expended,\n+                       max_capacity(), used(), free_unaffiliated_regions());\n+\n+    if ((gc_id == last_report_epoch) && (epoch_report_count >= MaxReportsPerEpoch)) {\n+      log_info(gc, ergo)(\"Squelching additional promotion failure reports for current epoch\");\n+    } else if (gc_id != last_report_epoch) {\n+      last_report_epoch = gc_id;\n+      epoch_report_count = 1;\n+    }\n+  }\n+}\n+\n+void ShenandoahOldGeneration::handle_evacuation(HeapWord* obj, size_t words, bool promotion) {\n+  auto heap = ShenandoahGenerationalHeap::heap();\n+  auto card_scan = heap->card_scan();\n+\n+  \/\/ Only register the copy of the object that won the evacuation race.\n+  card_scan->register_object_without_lock(obj);\n+\n+  \/\/ Mark the entire range of the evacuated object as dirty.  At next remembered set scan,\n+  \/\/ we will clear dirty bits that do not hold interesting pointers.  It's more efficient to\n+  \/\/ do this in batch, in a background GC thread than to try to carefully dirty only cards\n+  \/\/ that hold interesting pointers right now.\n+  card_scan->mark_range_as_dirty(obj, words);\n+\n+  if (promotion) {\n+    \/\/ This evacuation was a promotion, track this as allocation against old gen\n+    increase_allocated(words * HeapWordSize);\n+  }\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":111,"deletions":7,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n@@ -39,0 +40,39 @@\n+  \/\/ After determining the desired size of the old generation (see compute_old_generation_balance), these\n+  \/\/ quantities represent the number of regions above (surplus) or below (deficit) that size.\n+  \/\/ These values are computed prior to the actual exchange of any regions. These may never both\n+  \/\/ be positive simultaneously.\n+  size_t _region_surplus;\n+  size_t _region_deficit;\n+\n+  \/\/ Set when evacuation in the old generation fails. When this is set, the control thread will initiate a\n+  \/\/ full GC instead of a futile degenerated cycle.\n+  ShenandoahSharedFlag _failed_evacuation;\n+\n+  \/\/ Bytes reserved within old-gen to hold the results of promotion. This is separate from\n+  \/\/ and in addition to the evacuation reserve for intra-generation evacuations (ShenandoahGeneration::_evacuation_reserve).\n+  size_t _promoted_reserve;\n+\n+  \/\/ Bytes of old-gen memory expended on promotions. This may be modified concurrently\n+  \/\/ by mutators and gc workers when promotion LABs are retired during evacuation. It\n+  \/\/ is therefore always accessed through atomic operations. This is increased when a\n+  \/\/ PLAB is allocated for promotions. The value is decreased by the amount of memory\n+  \/\/ remaining in a PLAB when it is retired.\n+  size_t _promoted_expended;\n+\n+  \/\/ Represents the quantity of live bytes we expect to promote in place during the next\n+  \/\/ evacuation cycle. This value is used by the young heuristic to trigger mixed collections.\n+  \/\/ It is also used when computing the optimum size for the old generation.\n+  size_t _promotion_potential;\n+\n+  \/\/ When a region is selected to be promoted in place, the remaining free memory is filled\n+  \/\/ in to prevent additional allocations (preventing premature promotion of newly allocated\n+  \/\/ objects. This field records the total amount of padding used for such regions.\n+  size_t _pad_for_promote_in_place;\n+\n+  \/\/ During construction of the collection set, we keep track of regions that are eligible\n+  \/\/ for promotion in place. These fields track the count of those humongous and regular regions.\n+  \/\/ This data is used to force the evacuation phase even when the collection set is otherwise\n+  \/\/ empty.\n+  size_t _promotable_humongous_regions;\n+  size_t _promotable_regular_regions;\n+\n@@ -50,0 +90,55 @@\n+  \/\/ See description in field declaration\n+  void set_promoted_reserve(size_t new_val);\n+  size_t get_promoted_reserve() const;\n+\n+  \/\/ The promotion reserve is increased when rebuilding the free set transfers a region to the old generation\n+  void augment_promoted_reserve(size_t increment);\n+\n+  \/\/ This zeros out the expended promotion count after the promotion reserve is computed\n+  void reset_promoted_expended();\n+\n+  \/\/ This is incremented when allocations are made to copy promotions into the old generation\n+  size_t expend_promoted(size_t increment);\n+\n+  \/\/ This is used to return unused memory from a retired promotion LAB\n+  size_t unexpend_promoted(size_t decrement);\n+\n+  \/\/ This is used on the allocation path to gate promotions that would exceed the reserve\n+  size_t get_promoted_expended();\n+\n+  \/\/ See description in field declaration\n+  void set_region_surplus(size_t surplus) { _region_surplus = surplus; };\n+  void set_region_deficit(size_t deficit) { _region_deficit = deficit; };\n+  size_t get_region_surplus() const { return _region_surplus; };\n+  size_t get_region_deficit() const { return _region_deficit; };\n+\n+  \/\/ See description in field declaration\n+  void set_promotion_potential(size_t val) { _promotion_potential = val; };\n+  size_t get_promotion_potential() const { return _promotion_potential; };\n+\n+  \/\/ See description in field declaration\n+  void set_pad_for_promote_in_place(size_t pad) { _pad_for_promote_in_place = pad; }\n+  size_t get_pad_for_promote_in_place() const { return _pad_for_promote_in_place; }\n+\n+  \/\/ See description in field declaration\n+  void set_expected_humongous_region_promotions(size_t region_count) { _promotable_humongous_regions = region_count; }\n+  void set_expected_regular_region_promotions(size_t region_count) { _promotable_regular_regions = region_count; }\n+  bool has_in_place_promotions() const { return (_promotable_humongous_regions + _promotable_regular_regions) > 0; }\n+\n+  \/\/ This will signal the heuristic to trigger an old generation collection\n+  void handle_failed_transfer();\n+\n+  \/\/ This will signal the control thread to run a full GC instead of a futile degenerated gc\n+  void handle_failed_evacuation();\n+\n+  \/\/ This logs that an evacuation to the old generation has failed\n+  void handle_failed_promotion(Thread* thread, size_t size);\n+\n+  \/\/ A successful evacuation re-dirties the cards and registers the object with the remembered set\n+  void handle_evacuation(HeapWord* obj, size_t words, bool promotion);\n+\n+  \/\/ Clear the flag after it is consumed by the control thread\n+  bool clear_failed_evacuation() {\n+    return _failed_evacuation.try_unset();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":95,"deletions":0,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationType.hpp\"\n@@ -37,6 +38,0 @@\n-enum StringDedupMode {\n-  NO_DEDUP,      \/\/ Do not do anything for String deduplication\n-  ENQUEUE_DEDUP, \/\/ Enqueue candidate Strings for deduplication, if meet age threshold\n-  ALWAYS_DEDUP   \/\/ Enqueue Strings for deduplication\n-};\n-\n@@ -148,17 +143,0 @@\n-class ShenandoahSetRememberedCardsToDirtyClosure : public BasicOopIterateClosure {\n-protected:\n-  ShenandoahHeap*    const _heap;\n-  RememberedScanner* const _scanner;\n-\n-public:\n-  ShenandoahSetRememberedCardsToDirtyClosure() :\n-      _heap(ShenandoahHeap::heap()),\n-      _scanner(_heap->card_scan()) {}\n-\n-  template<class T>\n-  inline void work(T* p);\n-\n-  virtual void do_oop(narrowOop* p) { work(p); }\n-  virtual void do_oop(oop* p)       { work(p); }\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.hpp","additions":1,"deletions":23,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -58,12 +58,0 @@\n-template<class T>\n-inline void ShenandoahSetRememberedCardsToDirtyClosure::work(T* p) {\n-  T o = RawAccess<>::oop_load(p);\n-  if (!CompressedOops::is_null(o)) {\n-    oop obj = CompressedOops::decode_not_null(o);\n-    if (_heap->is_in_young(obj)) {\n-      \/\/ Found interesting pointer.  Mark the containing card as dirty.\n-      _scanner->mark_card_as_dirty((HeapWord*) p);\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.inline.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -341,0 +341,5 @@\n+\n+void ShenandoahPeriodicPacerNotifyTask::task() {\n+  assert(ShenandoahPacing, \"Should not be here otherwise\");\n+  _pacer->notify_waiters();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/task.hpp\"\n@@ -34,0 +35,15 @@\n+class ShenandoahPacer;\n+\n+\n+\/\/ Periodic task to notify blocked paced waiters.\n+class ShenandoahPeriodicPacerNotifyTask : public PeriodicTask {\n+private:\n+  ShenandoahPacer* const _pacer;\n+public:\n+  explicit ShenandoahPeriodicPacerNotifyTask(ShenandoahPacer* pacer) :\n+    PeriodicTask(PeriodicTask::min_interval),\n+    _pacer(pacer) { }\n+\n+  void task() override;\n+};\n+\n@@ -51,0 +67,1 @@\n+  ShenandoahPeriodicPacerNotifyTask _notify_waiters_task;\n@@ -67,1 +84,1 @@\n-  ShenandoahPacer(ShenandoahHeap* heap) :\n+  explicit ShenandoahPacer(ShenandoahHeap* heap) :\n@@ -72,0 +89,1 @@\n+          _notify_waiters_task(this),\n@@ -75,1 +93,3 @@\n-          _progress(PACING_PROGRESS_UNINIT) {}\n+          _progress(PACING_PROGRESS_UNINIT) {\n+    _notify_waiters_task.enroll();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.hpp","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-#include \"gc\/shenandoah\/shenandoahControlThread.hpp\"\n+#include \"gc\/shenandoah\/shenandoahAsserts.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalControlThread.hpp\"\n@@ -35,5 +36,1 @@\n-static ShenandoahHeuristics* get_heuristics(ShenandoahGeneration* nullable) {\n-  return nullable != nullptr ? nullable->heuristics() : nullptr;\n-}\n-\n-ShenandoahRegulatorThread::ShenandoahRegulatorThread(ShenandoahControlThread* control_thread) :\n+ShenandoahRegulatorThread::ShenandoahRegulatorThread(ShenandoahGenerationalControlThread* control_thread) :\n@@ -44,1 +41,1 @@\n-\n+  shenandoah_assert_generational();\n@@ -46,3 +43,3 @@\n-  _old_heuristics = get_heuristics(heap->old_generation());\n-  _young_heuristics = get_heuristics(heap->young_generation());\n-  _global_heuristics = get_heuristics(heap->global_generation());\n+  _old_heuristics = heap->old_generation()->heuristics();\n+  _young_heuristics = heap->young_generation()->heuristics();\n+  _global_heuristics = heap->global_generation()->heuristics();\n@@ -50,0 +47,1 @@\n+  set_name(\"Shenandoah Regulator Thread\");\n@@ -54,6 +52,2 @@\n-  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n-    if (ShenandoahAllowOldMarkingPreemption) {\n-      regulate_young_and_old_cycles();\n-    } else {\n-      regulate_young_and_global_cycles();\n-    }\n+  if (ShenandoahAllowOldMarkingPreemption) {\n+    regulate_young_and_old_cycles();\n@@ -61,1 +55,1 @@\n-    regulate_global_cycles();\n+    regulate_young_and_global_cycles();\n@@ -68,3 +62,0 @@\n-  assert(_young_heuristics != nullptr, \"Need young heuristics.\");\n-  assert(_old_heuristics != nullptr, \"Need old heuristics.\");\n-\n@@ -72,2 +63,2 @@\n-    ShenandoahControlThread::GCMode mode = _control_thread->gc_mode();\n-    if (mode == ShenandoahControlThread::none) {\n+    ShenandoahGenerationalControlThread::GCMode mode = _control_thread->gc_mode();\n+    if (mode == ShenandoahGenerationalControlThread::none) {\n@@ -75,1 +66,1 @@\n-        if (request_concurrent_gc(ShenandoahControlThread::select_global_generation())) {\n+        if (request_concurrent_gc(GLOBAL)) {\n@@ -89,1 +80,1 @@\n-    } else if (mode == ShenandoahControlThread::servicing_old) {\n+    } else if (mode == ShenandoahGenerationalControlThread::servicing_old) {\n@@ -101,3 +92,0 @@\n-  assert(_young_heuristics != nullptr, \"Need young heuristics.\");\n-  assert(_global_heuristics != nullptr, \"Need global heuristics.\");\n-\n@@ -105,1 +93,1 @@\n-    if (_control_thread->gc_mode() == ShenandoahControlThread::none) {\n+    if (_control_thread->gc_mode() == ShenandoahGenerationalControlThread::none) {\n@@ -117,14 +105,0 @@\n-void ShenandoahRegulatorThread::regulate_global_cycles() {\n-  assert(_global_heuristics != nullptr, \"Need global heuristics.\");\n-\n-  while (!should_terminate()) {\n-    if (_control_thread->gc_mode() == ShenandoahControlThread::none) {\n-      if (start_global_cycle()) {\n-        log_info(gc)(\"Heuristics request for global collection accepted.\");\n-      }\n-    }\n-\n-    regulator_sleep();\n-  }\n-}\n-\n@@ -137,1 +111,1 @@\n-  if (_heap_changed.try_unset()) {\n+  if (ShenandoahHeap::heap()->has_changed()) {\n@@ -140,1 +114,1 @@\n-    _sleep = MIN2<int>(ShenandoahControlIntervalMax, MAX2(1, _sleep * 2));\n+    _sleep = MIN2<uint>(ShenandoahControlIntervalMax, MAX2(1u, _sleep * 2));\n@@ -163,1 +137,1 @@\n-  return _global_heuristics->should_start_gc() && request_concurrent_gc(ShenandoahControlThread::select_global_generation());\n+  return _global_heuristics->should_start_gc() && request_concurrent_gc(GLOBAL);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":19,"deletions":45,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-#include \"gc\/shared\/gcCause.hpp\"\n-#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n-#include \"runtime\/mutex.hpp\"\n@@ -33,1 +30,1 @@\n-class ShenandoahControlThread;\n+class ShenandoahGenerationalControlThread;\n@@ -51,11 +48,1 @@\n-  explicit ShenandoahRegulatorThread(ShenandoahControlThread* control_thread);\n-\n-  const char* name() const { return \"ShenandoahRegulatorThread\";}\n-\n-  \/\/ This is called from allocation path, and thus should be fast.\n-  void notify_heap_changed() {\n-    \/\/ Notify that something had changed.\n-    if (_heap_changed.is_unset()) {\n-      _heap_changed.set();\n-    }\n-  }\n+  explicit ShenandoahRegulatorThread(ShenandoahGenerationalControlThread* control_thread);\n@@ -64,2 +51,2 @@\n-  void run_service();\n-  void stop_service();\n+  void run_service() override;\n+  void stop_service() override;\n@@ -72,2 +59,0 @@\n-  \/\/ Default behavior for other modes (single generation).\n-  void regulate_global_cycles();\n@@ -90,2 +75,1 @@\n-  ShenandoahSharedFlag _heap_changed;\n-  ShenandoahControlThread* _control_thread;\n+  ShenandoahGenerationalControlThread* _control_thread;\n@@ -96,1 +80,1 @@\n-  int _sleep;\n+  uint _sleep;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.hpp","additions":6,"deletions":22,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSATBMarkQueueSet.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationType.hpp\"\n@@ -150,2 +151,2 @@\n-    case GLOBAL_NON_GEN: {\n-      ShenandoahInitMarkRootsClosure<GLOBAL_NON_GEN> init_mark(task_queues()->queue(worker_id));\n+    case NON_GEN: {\n+      ShenandoahInitMarkRootsClosure<NON_GEN> init_mark(task_queues()->queue(worker_id));\n@@ -155,2 +156,2 @@\n-    case GLOBAL_GEN: {\n-      ShenandoahInitMarkRootsClosure<GLOBAL_GEN> init_mark(task_queues()->queue(worker_id));\n+    case GLOBAL: {\n+      ShenandoahInitMarkRootsClosure<GLOBAL> init_mark(task_queues()->queue(worker_id));\n@@ -165,0 +166,1 @@\n+    case OLD:\n@@ -176,3 +178,2 @@\n-  mark_loop(_generation->type(),\n-            worker_id, &_terminator, rp,\n-            false \/* not cancellable *\/,\n+  mark_loop(worker_id, &_terminator, rp,\n+            _generation->type(), false \/* not cancellable *\/,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shenandoah\/shenandoahRootProcessor.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,30 @@\n+\/\/ A closure that takes an oop in the old generation and, if it's pointing\n+\/\/ into the young generation, dirties the corresponding remembered set entry.\n+\/\/ This is only used to rebuild the remembered set after a full GC.\n+class ShenandoahDirtyRememberedSetClosure : public BasicOopIterateClosure {\n+protected:\n+  ShenandoahHeap*    const _heap;\n+  RememberedScanner* const _scanner;\n+\n+public:\n+  ShenandoahDirtyRememberedSetClosure() :\n+          _heap(ShenandoahHeap::heap()),\n+          _scanner(_heap->card_scan()) {}\n+\n+  template<class T>\n+  inline void work(T* p) {\n+    assert(_heap->is_in_old(p), \"Expecting to get an old gen address\");\n+    T o = RawAccess<>::oop_load(p);\n+    if (!CompressedOops::is_null(o)) {\n+      oop obj = CompressedOops::decode_not_null(o);\n+      if (_heap->is_in_young(obj)) {\n+        \/\/ Dirty the card containing the cross-generational pointer.\n+        _scanner->mark_card_as_dirty((HeapWord*) p);\n+      }\n+    }\n+  }\n+\n+  virtual void do_oop(narrowOop* p) { work(p); }\n+  virtual void do_oop(oop* p)       { work(p); }\n+};\n+\n@@ -374,0 +404,54 @@\n+\n+ShenandoahReconstructRememberedSetTask::ShenandoahReconstructRememberedSetTask(ShenandoahRegionIterator* regions)\n+  : WorkerTask(\"Shenandoah Reset Bitmap\")\n+  , _regions(regions) { }\n+\n+void ShenandoahReconstructRememberedSetTask::work(uint worker_id) {\n+  ShenandoahParallelWorkerSession worker_session(worker_id);\n+  ShenandoahHeapRegion* r = _regions->next();\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  RememberedScanner* scanner = heap->card_scan();\n+  ShenandoahDirtyRememberedSetClosure dirty_cards_for_cross_generational_pointers;\n+\n+  while (r != nullptr) {\n+    if (r->is_old() && r->is_active()) {\n+      HeapWord* obj_addr = r->bottom();\n+      if (r->is_humongous_start()) {\n+        \/\/ First, clear the remembered set\n+        oop obj = cast_to_oop(obj_addr);\n+        size_t size = obj->size();\n+\n+        \/\/ First, clear the remembered set for all spanned humongous regions\n+        size_t num_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);\n+        size_t region_span = num_regions * ShenandoahHeapRegion::region_size_words();\n+        scanner->reset_remset(r->bottom(), region_span);\n+        size_t region_index = r->index();\n+        ShenandoahHeapRegion* humongous_region = heap->get_region(region_index);\n+        while (num_regions-- != 0) {\n+          scanner->reset_object_range(humongous_region->bottom(), humongous_region->end());\n+          region_index++;\n+          humongous_region = heap->get_region(region_index);\n+        }\n+\n+        \/\/ Then register the humongous object and DIRTY relevant remembered set cards\n+        scanner->register_object_without_lock(obj_addr);\n+        obj->oop_iterate(&dirty_cards_for_cross_generational_pointers);\n+      } else if (!r->is_humongous()) {\n+        \/\/ First, clear the remembered set\n+        scanner->reset_remset(r->bottom(), ShenandoahHeapRegion::region_size_words());\n+        scanner->reset_object_range(r->bottom(), r->end());\n+\n+        \/\/ Then iterate over all objects, registering object and DIRTYing relevant remembered set cards\n+        HeapWord* t = r->top();\n+        while (obj_addr < t) {\n+          oop obj = cast_to_oop(obj_addr);\n+          size_t size = obj->size();\n+          scanner->register_object_without_lock(obj_addr);\n+          obj_addr += obj->oop_iterate_size(&dirty_cards_for_cross_generational_pointers);\n+        }\n+      } \/\/ else, ignore humongous continuation region\n+    }\n+    \/\/ else, this region is FREE or YOUNG or inactive and we can ignore it.\n+    r = _regions->next();\n+  }\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -177,1 +177,0 @@\n-#include <stdint.h>\n@@ -1050,0 +1049,12 @@\n+\/\/ After Full GC is done, reconstruct the remembered set by iterating over OLD regions,\n+\/\/ registering all objects between bottom() and top(), and dirtying the cards containing\n+\/\/ cross-generational pointers.\n+class ShenandoahReconstructRememberedSetTask : public WorkerTask {\n+private:\n+  ShenandoahRegionIterator* _regions;\n+\n+public:\n+  explicit ShenandoahReconstructRememberedSetTask(ShenandoahRegionIterator* regions);\n+\n+  void work(uint worker_id) override;\n+};\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+    assert(thread->is_Java_thread(), \"GC state is only synchronized to java threads\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-      ClassLoaderDataGraph::purge(\/*at_safepoint*\/false);\n+      ClassLoaderDataGraph::purge(false \/* at_safepoint *\/);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUnload.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUtils.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,3 +49,3 @@\n-    case GLOBAL_NON_GEN:                                                  \\\n-      return prefix \"\" postfix;                                           \\\n-    case GLOBAL_GEN:                                                      \\\n+    case NON_GEN:                                                         \\\n+      return prefix \" (NON-GENERATIONAL)\" postfix;                        \\\n+    case GLOBAL:                                                          \\\n@@ -59,1 +59,1 @@\n-      return prefix \" (?)\" postfix;                                       \\\n+      return prefix \" (UNKNOWN)\" postfix;                                 \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUtils.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,0 +39,9 @@\n+bool VM_ShenandoahOperation::doit_prologue() {\n+  assert(!ShenandoahHeap::heap()->has_gc_state_changed(), \"GC State can only be changed on a safepoint.\");\n+  return true;\n+}\n+\n+void VM_ShenandoahOperation::doit_epilogue() {\n+  assert(!ShenandoahHeap::heap()->has_gc_state_changed(), \"GC State was not synchronized to java threads.\");\n+}\n+\n@@ -40,0 +49,1 @@\n+  VM_ShenandoahOperation::doit_prologue();\n@@ -45,0 +55,1 @@\n+  VM_ShenandoahOperation::doit_epilogue();\n@@ -55,0 +66,1 @@\n+  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n@@ -60,0 +72,1 @@\n+  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n@@ -65,0 +78,1 @@\n+  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n@@ -70,0 +84,1 @@\n+  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n@@ -75,0 +90,1 @@\n+  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n@@ -80,0 +96,1 @@\n+  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n@@ -85,0 +102,1 @@\n+  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -50,1 +50,3 @@\n-  virtual bool skip_thread_oop_barriers() const { return true; }\n+  bool skip_thread_oop_barriers() const override { return true; }\n+  bool doit_prologue() override;\n+  void doit_epilogue() override;\n@@ -56,2 +58,2 @@\n-  bool doit_prologue();\n-  void doit_epilogue();\n+  bool doit_prologue() override;\n+  void doit_epilogue() override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -414,1 +414,1 @@\n-      size_t pad = ShenandoahHeap::heap()->get_pad_for_promote_in_place();\n+      size_t pad = heap->old_generation()->get_pad_for_promote_in_place();\n@@ -787,0 +787,2 @@\n+  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n+\n@@ -862,1 +864,1 @@\n-      heap_used = _heap->used() + _heap->get_pad_for_promote_in_place();\n+      heap_used = _heap->used() + _heap->old_generation()->get_pad_for_promote_in_place();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/shared\/workerPolicy.hpp\"\n@@ -30,15 +29,0 @@\n-#include \"runtime\/javaThread.hpp\"\n-#include \"runtime\/threads.hpp\"\n-\n-uint ShenandoahWorkerPolicy::_prev_par_marking     = 0;\n-uint ShenandoahWorkerPolicy::_prev_conc_marking    = 0;\n-uint ShenandoahWorkerPolicy::_prev_conc_rs_scanning = 0;\n-uint ShenandoahWorkerPolicy::_prev_conc_evac       = 0;\n-uint ShenandoahWorkerPolicy::_prev_conc_root_proc  = 0;\n-uint ShenandoahWorkerPolicy::_prev_conc_refs_proc  = 0;\n-uint ShenandoahWorkerPolicy::_prev_fullgc          = 0;\n-uint ShenandoahWorkerPolicy::_prev_degengc         = 0;\n-uint ShenandoahWorkerPolicy::_prev_conc_update_ref = 0;\n-uint ShenandoahWorkerPolicy::_prev_par_update_ref  = 0;\n-uint ShenandoahWorkerPolicy::_prev_conc_cleanup    = 0;\n-uint ShenandoahWorkerPolicy::_prev_conc_reset      = 0;\n@@ -47,7 +31,1 @@\n-  uint active_workers = (_prev_par_marking == 0) ? ParallelGCThreads : _prev_par_marking;\n-\n-  _prev_par_marking =\n-    WorkerPolicy::calc_active_workers(ParallelGCThreads,\n-                                      active_workers,\n-                                      Threads::number_of_non_daemon_threads());\n-  return _prev_par_marking;\n+  return ParallelGCThreads;\n@@ -57,6 +35,1 @@\n-  uint active_workers = (_prev_conc_marking == 0) ?  ConcGCThreads : _prev_conc_marking;\n-  _prev_conc_marking =\n-    WorkerPolicy::calc_active_conc_workers(ConcGCThreads,\n-                                           active_workers,\n-                                           Threads::number_of_non_daemon_threads());\n-  return _prev_conc_marking;\n+  return ConcGCThreads;\n@@ -66,6 +39,1 @@\n-  uint active_workers = (_prev_conc_rs_scanning == 0) ? ConcGCThreads : _prev_conc_rs_scanning;\n-  _prev_conc_rs_scanning =\n-    WorkerPolicy::calc_active_conc_workers(ConcGCThreads,\n-                                           active_workers,\n-                                           Threads::number_of_non_daemon_threads());\n-  return _prev_conc_rs_scanning;\n+  return ConcGCThreads;\n@@ -74,1 +42,0 @@\n-\/\/ Reuse the calculation result from init marking\n@@ -76,1 +43,1 @@\n-  return _prev_par_marking;\n+  return ParallelGCThreads;\n@@ -79,1 +46,0 @@\n-\/\/ Calculate workers for concurrent refs processing\n@@ -81,6 +47,1 @@\n-  uint active_workers = (_prev_conc_refs_proc == 0) ? ConcGCThreads : _prev_conc_refs_proc;\n-  _prev_conc_refs_proc =\n-    WorkerPolicy::calc_active_conc_workers(ConcGCThreads,\n-                                           active_workers,\n-                                           Threads::number_of_non_daemon_threads());\n-  return _prev_conc_refs_proc;\n+  return ConcGCThreads;\n@@ -89,1 +50,0 @@\n-\/\/ Calculate workers for concurrent root processing\n@@ -91,6 +51,1 @@\n-  uint active_workers = (_prev_conc_root_proc == 0) ? ConcGCThreads : _prev_conc_root_proc;\n-  _prev_conc_root_proc =\n-          WorkerPolicy::calc_active_conc_workers(ConcGCThreads,\n-                                                 active_workers,\n-                                                 Threads::number_of_non_daemon_threads());\n-  return _prev_conc_root_proc;\n+  return ConcGCThreads;\n@@ -99,1 +54,0 @@\n-\/\/ Calculate workers for concurrent evacuation (concurrent GC)\n@@ -101,6 +55,1 @@\n-  uint active_workers = (_prev_conc_evac == 0) ? ConcGCThreads : _prev_conc_evac;\n-  _prev_conc_evac =\n-    WorkerPolicy::calc_active_conc_workers(ConcGCThreads,\n-                                           active_workers,\n-                                           Threads::number_of_non_daemon_threads());\n-  return _prev_conc_evac;\n+  return ConcGCThreads;\n@@ -109,1 +58,0 @@\n-\/\/ Calculate workers for parallel fullgc\n@@ -111,6 +59,1 @@\n-  uint active_workers = (_prev_fullgc == 0) ?  ParallelGCThreads : _prev_fullgc;\n-  _prev_fullgc =\n-    WorkerPolicy::calc_active_workers(ParallelGCThreads,\n-                                      active_workers,\n-                                      Threads::number_of_non_daemon_threads());\n-  return _prev_fullgc;\n+  return ParallelGCThreads;\n@@ -119,1 +62,0 @@\n-\/\/ Calculate workers for parallel degenerated gc\n@@ -121,6 +63,1 @@\n-  uint active_workers = (_prev_degengc == 0) ?  ParallelGCThreads : _prev_degengc;\n-  _prev_degengc =\n-    WorkerPolicy::calc_active_workers(ParallelGCThreads,\n-                                      active_workers,\n-                                      Threads::number_of_non_daemon_threads());\n-  return _prev_degengc;\n+  return ParallelGCThreads;\n@@ -129,1 +66,0 @@\n-\/\/ Calculate workers for concurrent reference update\n@@ -131,6 +67,1 @@\n-  uint active_workers = (_prev_conc_update_ref == 0) ? ConcGCThreads : _prev_conc_update_ref;\n-  _prev_conc_update_ref =\n-    WorkerPolicy::calc_active_conc_workers(ConcGCThreads,\n-                                           active_workers,\n-                                           Threads::number_of_non_daemon_threads());\n-  return _prev_conc_update_ref;\n+  return ConcGCThreads;\n@@ -139,1 +70,0 @@\n-\/\/ Calculate workers for parallel reference update\n@@ -141,15 +71,1 @@\n-  uint active_workers = (_prev_par_update_ref == 0) ? ParallelGCThreads : _prev_par_update_ref;\n-  _prev_par_update_ref =\n-    WorkerPolicy::calc_active_workers(ParallelGCThreads,\n-                                      active_workers,\n-                                      Threads::number_of_non_daemon_threads());\n-  return _prev_par_update_ref;\n-}\n-\n-uint ShenandoahWorkerPolicy::calc_workers_for_conc_cleanup() {\n-  uint active_workers = (_prev_conc_cleanup == 0) ? ConcGCThreads : _prev_conc_cleanup;\n-  _prev_conc_cleanup =\n-          WorkerPolicy::calc_active_conc_workers(ConcGCThreads,\n-                                                 active_workers,\n-                                                 Threads::number_of_non_daemon_threads());\n-  return _prev_conc_cleanup;\n+  return ParallelGCThreads;\n@@ -159,6 +75,1 @@\n-  uint active_workers = (_prev_conc_reset == 0) ? ConcGCThreads : _prev_conc_reset;\n-  _prev_conc_reset =\n-          WorkerPolicy::calc_active_conc_workers(ConcGCThreads,\n-                                                 active_workers,\n-                                                 Threads::number_of_non_daemon_threads());\n-  return _prev_conc_reset;\n+  return ConcGCThreads;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahWorkerPolicy.cpp","additions":12,"deletions":101,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -31,14 +31,0 @@\n-private:\n-  static uint _prev_par_marking;\n-  static uint _prev_conc_marking;\n-  static uint _prev_conc_rs_scanning;\n-  static uint _prev_conc_root_proc;\n-  static uint _prev_conc_refs_proc;\n-  static uint _prev_conc_evac;\n-  static uint _prev_fullgc;\n-  static uint _prev_degengc;\n-  static uint _prev_conc_update_ref;\n-  static uint _prev_par_update_ref;\n-  static uint _prev_conc_cleanup;\n-  static uint _prev_conc_reset;\n-\n@@ -79,3 +65,0 @@\n-  \/\/ Calculate workers for concurrent cleanup\n-  static uint calc_workers_for_conc_cleanup();\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahWorkerPolicy.hpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -499,3 +499,4 @@\n-  product(uintx, ShenandoahOOMGCRetries, 3, EXPERIMENTAL,                   \\\n-          \"How many GCs should happen before we throw OutOfMemoryException \"\\\n-          \"for allocation request, including at least one Full GC.\")        \\\n+  product(uintx, ShenandoahNoProgressThreshold, 5, EXPERIMENTAL,            \\\n+          \"After this number of consecutive Full GCs fail to make \"         \\\n+          \"progress, Shenandoah will raise out of memory errors. Note \"     \\\n+          \"that progress is determined by ShenandoahCriticalFreeThreshold\") \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -743,1 +743,1 @@\n-    <Field type=\"int\" name=\"arrayElements\" label=\"Array Elements\" description=\"If the object is an array, the number of elements, or -1 if it is not an array\" \/>\n+    <Field type=\"int\" name=\"arrayElements\" label=\"Array Elements\" description=\"If the object is an array, the number of elements, or minimum value for the type int if it is not an array\" \/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,0 +141,1 @@\n+  bool _vthread;\n@@ -143,1 +144,0 @@\n-  bool _vthread;\n@@ -168,2 +168,3 @@\n-    _cont_entry(JfrThreadLocal::is_vthread(jt) ? jt->last_continuation() : nullptr),\n-    _async_mode(async_mode), _vthread(JfrThreadLocal::is_vthread(jt)) {\n+    _vthread(JfrThreadLocal::is_vthread(jt)),\n+    _cont_entry(_vthread ? jt->last_continuation() : nullptr),\n+    _async_mode(async_mode) {\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -398,1 +398,1 @@\n-  if (!t->is_Java_thread() || !Atomic::load_acquire(&tl->_vthread)) {\n+  if (!t->is_Java_thread()) {\n@@ -401,1 +401,0 @@\n-  \/\/ virtual thread\n@@ -403,0 +402,4 @@\n+  if (!is_vthread(jt)) {\n+    return jvm_thread_id(t, tl);\n+  }\n+  \/\/ virtual thread\n@@ -459,1 +462,1 @@\n-  return Atomic::load_acquire(&jt->jfr_thread_local()->_vthread);\n+  return Atomic::load_acquire(&jt->jfr_thread_local()->_vthread) && jt->last_continuation() != nullptr;\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -447,1 +447,2 @@\n-  int num_stack_arg_slots() const { return constMethod()->num_stack_arg_slots(); }\n+  int num_stack_arg_slots(bool rounded = true) const {\n+    return rounded ? align_up(constMethod()->num_stack_arg_slots(), 2) : constMethod()->num_stack_arg_slots(); }\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-  inline BitMap::idx_t bit_index_for(intptr_t* p) const;\n+  inline BitMap::idx_t bit_index_for(address p) const;\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -259,1 +259,1 @@\n-inline BitMap::idx_t stackChunkOopDesc::bit_index_for(intptr_t* p) const {\n+inline BitMap::idx_t stackChunkOopDesc::bit_index_for(address p) const {\n@@ -265,0 +265,1 @@\n+  assert(is_aligned(p, alignof(OopT)), \"should be aligned: \" PTR_FORMAT, p2i(p));\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"oops\/symbolHandle.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+Symbol* volatile TempSymbolCleanupDelayer::_queue[QueueSize] = {};\n+volatile uint TempSymbolCleanupDelayer::_index = 0;\n+\n+\/\/ Keep this symbol alive for some time to allow for reuse.\n+\/\/ Temp symbols for the same string can often be created in quick succession,\n+\/\/ and this queue allows them to be reused instead of churning.\n+void TempSymbolCleanupDelayer::delay_cleanup(Symbol* sym) {\n+  assert(sym != nullptr, \"precondition\");\n+  sym->increment_refcount();\n+  uint i = Atomic::add(&_index, 1u) % QueueSize;\n+  Symbol* old = Atomic::xchg(&_queue[i], sym);\n+  Symbol::maybe_decrement_refcount(old);\n+}\n+\n+void TempSymbolCleanupDelayer::drain_queue() {\n+  for (uint i = 0; i < QueueSize; i++) {\n+    Symbol* sym = Atomic::xchg(&_queue[i], (Symbol*) nullptr);\n+    Symbol::maybe_decrement_refcount(sym);\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/symbolHandle.cpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -31,0 +31,10 @@\n+class TempSymbolCleanupDelayer : AllStatic {\n+  static Symbol* volatile _queue[];\n+  static volatile uint _index;\n+\n+public:\n+  static const uint QueueSize = 128;\n+  static void delay_cleanup(Symbol* s);\n+  static void drain_queue();\n+};\n+\n@@ -52,1 +62,0 @@\n-  \/\/ Does not increment the current reference count if temporary.\n@@ -56,0 +65,8 @@\n+      return;\n+    }\n+\n+    \/\/ Delay cleanup for temp symbols. Refcount is incremented while in\n+    \/\/ queue. But don't requeue existing entries, or entries that are held\n+    \/\/ elsewhere - it's a waste of effort.\n+    if (s != nullptr && s->refcount() == 1) {\n+      TempSymbolCleanupDelayer::delay_cleanup(s);\n","filename":"src\/hotspot\/share\/oops\/symbolHandle.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -295,1 +295,1 @@\n-  LRG &lrgs(uint idx) const { assert(idx < _maxlrg, \"oob\"); return _lrgs[idx]; }\n+  LRG &lrgs(uint idx) const { assert(idx < _maxlrg, \"oob: index %u not smaller than %u\", idx, _maxlrg); return _lrgs[idx]; }\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -524,2 +524,2 @@\n-  \/\/ but not if I2 is a constant.\n-  if (n_op == Op_AddP) {\n+  \/\/ but not if I2 is a constant. Skip for irreducible loops.\n+  if (n_op == Op_AddP && n_loop->_head->is_Loop()) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3339,0 +3339,1 @@\n+          assert(!trailing_load_store(), \"load store node can't be eliminated\");\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -173,1 +173,1 @@\n-  int slots = SharedRuntime::java_calling_convention(sig_bt, vm_regs, num_args);\n+  int slots = align_up(SharedRuntime::java_calling_convention(sig_bt, vm_regs, num_args), 2);\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -991,1 +991,1 @@\n-  ObjectSynchronizer::monitors_iterate(&jmc, java_thread);\n+  ObjectSynchronizer::owned_monitors_iterate(&jmc, java_thread);\n@@ -1018,1 +1018,1 @@\n-  ObjectSynchronizer::monitors_iterate(&jmc, java_thread);\n+  ObjectSynchronizer::owned_monitors_iterate(&jmc, java_thread);\n@@ -2181,0 +2181,7 @@\n+\n+  if (obj == nullptr) {\n+    \/\/ This can happen if JNI code drops all references to the\n+    \/\/ owning object.\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1836,1 +1836,1 @@\n-  return ObjectSynchronizer::request_deflate_idle_monitors();\n+  return ObjectSynchronizer::request_deflate_idle_monitors_from_wb();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1744,1 +1744,1 @@\n-  void clear_bitmap_bits(intptr_t* start, int range);\n+  void clear_bitmap_bits(address start, address end);\n@@ -2125,1 +2125,4 @@\n-void ThawBase::clear_bitmap_bits(intptr_t* start, int range) {\n+void ThawBase::clear_bitmap_bits(address start, address end) {\n+  assert(is_aligned(start, wordSize), \"should be aligned: \" PTR_FORMAT, p2i(start));\n+  assert(is_aligned(end, VMRegImpl::stack_slot_size), \"should be aligned: \" PTR_FORMAT, p2i(end));\n+\n@@ -2127,2 +2130,8 @@\n-  \/\/ or they will keep objects that are otherwise unreachable alive\n-  log_develop_trace(continuations)(\"clearing bitmap for \" INTPTR_FORMAT \" - \" INTPTR_FORMAT, p2i(start), p2i(start+range));\n+  \/\/ or they will keep objects that are otherwise unreachable alive.\n+\n+  \/\/ Align `end` if UseCompressedOops is not set to avoid UB when calculating the bit index, since\n+  \/\/ `end` could be at an odd number of stack slots from `start`, i.e might not be oop aligned.\n+  \/\/ If that's the case the bit range corresponding to the last stack slot should not have bits set\n+  \/\/ anyways and we assert that before returning.\n+  address effective_end = UseCompressedOops ? end : align_down(end, wordSize);\n+  log_develop_trace(continuations)(\"clearing bitmap for \" INTPTR_FORMAT \" - \" INTPTR_FORMAT, p2i(start), p2i(effective_end));\n@@ -2130,2 +2139,2 @@\n-  chunk->bitmap().clear_range(chunk->bit_index_for(start),\n-                              chunk->bit_index_for(start+range));\n+  chunk->bitmap().clear_range(chunk->bit_index_for(start), chunk->bit_index_for(effective_end));\n+  assert(effective_end == end || !chunk->bitmap().at(chunk->bit_index_for(effective_end)), \"bit should not be set\");\n@@ -2184,1 +2193,3 @@\n-    clear_bitmap_bits(heap_frame_bottom - locals, locals);\n+    address start = (address)(heap_frame_bottom - locals);\n+    address end = (address)heap_frame_bottom;\n+    clear_bitmap_bits(start, end);\n@@ -2257,1 +2268,4 @@\n-    clear_bitmap_bits(heap_frame_top + ContinuationHelper::CompiledFrame::size(hf) + frame::metadata_words_at_top, added_argsize);\n+    address start = (address)(heap_frame_top + ContinuationHelper::CompiledFrame::size(hf) + frame::metadata_words_at_top);\n+    int stack_args_slots = f.cb()->as_compiled_method()->method()->num_stack_arg_slots(false \/* rounded *\/);\n+    int argsize_in_bytes = stack_args_slots * VMRegImpl::stack_slot_size;\n+    clear_bitmap_bits(start, start + argsize_in_bytes);\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1442,1 +1442,1 @@\n-      assert(stack_arg_slots ==  m->num_stack_arg_slots(), \"\");\n+      assert(stack_arg_slots ==  m->num_stack_arg_slots(false \/* rounded *\/), \"\");\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -735,0 +735,4 @@\n+  product(intx, MonitorUnlinkBatch, 500, DIAGNOSTIC,                        \\\n+          \"The maximum number of monitors to unlink in one batch. \")        \\\n+          range(1, max_jint)                                                \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -412,0 +412,1 @@\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-    (void)ObjectSynchronizer::deflate_idle_monitors(\/* ObjectMonitorsHashtable is not needed here *\/ nullptr);\n+    (void)ObjectSynchronizer::deflate_idle_monitors();\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -512,10 +512,0 @@\n-  if (ObjectSynchronizer::is_final_audit() && owner_is_DEFLATER_MARKER()) {\n-    \/\/ The final audit can see an already deflated ObjectMonitor on the\n-    \/\/ in-use list because MonitorList::unlink_deflated() might have\n-    \/\/ blocked for the final safepoint before unlinking all the deflated\n-    \/\/ monitors.\n-    assert(contentions() < 0, \"must be negative: contentions=%d\", contentions());\n-    \/\/ Already returned 'true' when it was originally deflated.\n-    return false;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1994,1 +1994,1 @@\n-  int comp_args_on_stack = java_calling_convention(sig_bt, regs_without_member_name, total_args_passed - 1);\n+  java_calling_convention(sig_bt, regs_without_member_name, total_args_passed - 1);\n@@ -3092,1 +3092,1 @@\n-      int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed);\n+      SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -181,1 +181,0 @@\n-  _stack_arg_slots = align_up(_stack_arg_slots, 2);\n@@ -238,1 +237,0 @@\n-#if defined(PPC64) || defined(S390)\n@@ -242,0 +240,4 @@\n+#if defined(PPC64) || defined(S390)\n+      _stack_arg_slots += 1;\n+#else\n+      _stack_arg_slots = align_up(_stack_arg_slots, 2);\n@@ -243,0 +245,1 @@\n+#endif \/\/ defined(PPC64) || defined(S390)\n@@ -245,1 +248,0 @@\n-#endif \/\/ defined(PPC64) || defined(S390)\n@@ -253,2 +255,1 @@\n-      PPC64_ONLY(_stack_arg_slots = align_up(_stack_arg_slots, 2));\n-      S390_ONLY(_stack_arg_slots = align_up(_stack_arg_slots, 2));\n+      _stack_arg_slots = align_up(_stack_arg_slots, 2);\n@@ -259,1 +260,0 @@\n-#if defined(PPC64) || defined(S390)\n@@ -263,0 +263,4 @@\n+#if defined(PPC64) || defined(S390)\n+      _stack_arg_slots += 1;\n+#else\n+      _stack_arg_slots = align_up(_stack_arg_slots, 2);\n@@ -264,0 +268,1 @@\n+#endif \/\/ defined(PPC64) || defined(S390)\n@@ -266,1 +271,0 @@\n-#endif \/\/ defined(PPC64) || defined(S390)\n@@ -271,2 +275,1 @@\n-      PPC64_ONLY(_stack_arg_slots = align_up(_stack_arg_slots, 2));\n-      S390_ONLY(_stack_arg_slots = align_up(_stack_arg_slots, 2));\n+      _stack_arg_slots = align_up(_stack_arg_slots, 2);\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -66,39 +66,0 @@\n-class ObjectMonitorsHashtable::PtrList :\n-  public LinkedListImpl<ObjectMonitor*,\n-                        AnyObj::C_HEAP, mtThread,\n-                        AllocFailStrategy::RETURN_NULL> {};\n-\n-class CleanupObjectMonitorsHashtable: StackObj {\n- public:\n-  bool do_entry(void*& key, ObjectMonitorsHashtable::PtrList*& list) {\n-    list->clear();  \/\/ clear the LinkListNodes\n-    delete list;    \/\/ then delete the LinkedList\n-    return true;\n-  }\n-};\n-\n-ObjectMonitorsHashtable::~ObjectMonitorsHashtable() {\n-  CleanupObjectMonitorsHashtable cleanup;\n-  _ptrs->unlink(&cleanup);  \/\/ cleanup the LinkedLists\n-  delete _ptrs;             \/\/ then delete the hash table\n-}\n-\n-void ObjectMonitorsHashtable::add_entry(void* key, ObjectMonitor* om) {\n-  ObjectMonitorsHashtable::PtrList* list = get_entry(key);\n-  if (list == nullptr) {\n-    \/\/ Create new list and add it to the hash table:\n-    list = new (mtThread) ObjectMonitorsHashtable::PtrList;\n-    add_entry(key, list);\n-  }\n-  list->add(om);  \/\/ Add the ObjectMonitor to the list.\n-  _om_count++;\n-}\n-\n-bool ObjectMonitorsHashtable::has_entry(void* key, ObjectMonitor* om) {\n-  ObjectMonitorsHashtable::PtrList* list = get_entry(key);\n-  if (list == nullptr || list->find(om) == nullptr) {\n-    return false;\n-  }\n-  return true;\n-}\n-\n@@ -126,2 +87,2 @@\n-\/\/ Walk the in-use list and unlink (at most MonitorDeflationMax) deflated\n-\/\/ ObjectMonitors. Returns the number of unlinked ObjectMonitors.\n+\/\/ Walk the in-use list and unlink deflated ObjectMonitors.\n+\/\/ Returns the number of unlinked ObjectMonitors.\n@@ -130,0 +91,1 @@\n+                                    size_t deflated_count,\n@@ -133,2 +95,2 @@\n-  ObjectMonitor* head = Atomic::load_acquire(&_head);\n-  ObjectMonitor* m = head;\n+  ObjectMonitor* m = Atomic::load_acquire(&_head);\n+\n@@ -138,1 +100,3 @@\n-      \/\/ Find next live ObjectMonitor.\n+      \/\/ Find next live ObjectMonitor. Batch up the unlinkable monitors, so we can\n+      \/\/ modify the list once per batch. The batch starts at \"m\".\n+      size_t unlinked_batch = 0;\n@@ -140,0 +104,4 @@\n+      \/\/ Look for at most MonitorUnlinkBatch monitors, or the number of\n+      \/\/ deflated and not unlinked monitors, whatever comes first.\n+      assert(deflated_count >= unlinked_count, \"Sanity: underflow\");\n+      size_t unlinked_batch_limit = MIN2<size_t>(deflated_count - unlinked_count, MonitorUnlinkBatch);\n@@ -142,1 +110,1 @@\n-        unlinked_count++;\n+        unlinked_batch++;\n@@ -145,2 +113,8 @@\n-        if (unlinked_count >= (size_t)MonitorDeflationMax) {\n-          \/\/ Reached the max so bail out on the gathering loop.\n+        if (unlinked_batch >= unlinked_batch_limit) {\n+          \/\/ Reached the max batch, so bail out of the gathering loop.\n+          break;\n+        }\n+        if (prev == nullptr && Atomic::load(&_head) != m) {\n+          \/\/ Current batch used to be at head, but it is not at head anymore.\n+          \/\/ Bail out and figure out where we currently are. This avoids long\n+          \/\/ walks searching for new prev during unlink under heavy list inserts.\n@@ -150,0 +124,2 @@\n+\n+      \/\/ Unlink the found batch.\n@@ -151,3 +127,5 @@\n-        ObjectMonitor* prev_head = Atomic::cmpxchg(&_head, head, next);\n-        if (prev_head != head) {\n-          \/\/ Find new prev ObjectMonitor that just got inserted.\n+        \/\/ The current batch is the first batch, so there is a chance that it starts at head.\n+        \/\/ Optimistically assume no inserts happened, and try to unlink the entire batch from the head.\n+        ObjectMonitor* prev_head = Atomic::cmpxchg(&_head, m, next);\n+        if (prev_head != m) {\n+          \/\/ Something must have updated the head. Figure out the actual prev for this batch.\n@@ -157,0 +135,1 @@\n+          assert(prev != nullptr, \"Should have found the prev for the current batch\");\n@@ -160,0 +139,3 @@\n+        \/\/ The current batch is preceded by another batch. This guarantees the current batch\n+        \/\/ does not start at head. Unlink the entire current batch without updating the head.\n+        assert(Atomic::load(&_head) != m, \"Sanity\");\n@@ -162,2 +144,5 @@\n-      if (unlinked_count >= (size_t)MonitorDeflationMax) {\n-        \/\/ Reached the max so bail out on the searching loop.\n+\n+      unlinked_count += unlinked_batch;\n+      if (unlinked_count >= deflated_count) {\n+        \/\/ Reached the max so bail out of the searching loop.\n+        \/\/ There should be no more deflated monitors left.\n@@ -179,0 +164,14 @@\n+\n+#ifdef ASSERT\n+  \/\/ Invariant: the code above should unlink all deflated monitors.\n+  \/\/ The code that runs after this unlinking does not expect deflated monitors.\n+  \/\/ Notably, attempting to deflate the already deflated monitor would break.\n+  {\n+    ObjectMonitor* m = Atomic::load_acquire(&_head);\n+    while (m != nullptr) {\n+      assert(!m->is_being_async_deflated(), \"All deflated monitors should be unlinked\");\n+      m = m->next_om();\n+    }\n+  }\n+#endif\n+\n@@ -1102,6 +1101,3 @@\n-\/\/ Iterate ObjectMonitors where the owner == thread; this does NOT include\n-\/\/ ObjectMonitors where owner is set to a stack-lock address in thread.\n-\/\/\n-\/\/ This version of monitors_iterate() works with the in-use monitor list.\n-\/\/\n-void ObjectSynchronizer::monitors_iterate(MonitorClosure* closure, JavaThread* thread) {\n+\/\/ Iterate over all ObjectMonitors.\n+template <typename Function>\n+void ObjectSynchronizer::monitors_iterate(Function function) {\n@@ -1110,17 +1106,2 @@\n-    ObjectMonitor* mid = iter.next();\n-    if (mid->owner() != thread) {\n-      \/\/ Not owned by the target thread and intentionally skips when owner\n-      \/\/ is set to a stack-lock address in the target thread.\n-      continue;\n-    }\n-    if (!mid->is_being_async_deflated() && mid->object_peek() != nullptr) {\n-      \/\/ Only process with closure if the object is set.\n-\n-      \/\/ monitors_iterate() is only called at a safepoint or when the\n-      \/\/ target thread is suspended or when the target thread is\n-      \/\/ operating on itself. The current closures in use today are\n-      \/\/ only interested in an owned ObjectMonitor and ownership\n-      \/\/ cannot be dropped under the calling contexts so the\n-      \/\/ ObjectMonitor cannot be async deflated.\n-      closure->do_monitor(mid);\n-    }\n+    ObjectMonitor* monitor = iter.next();\n+    function(monitor);\n@@ -1130,21 +1111,15 @@\n-\/\/ This version of monitors_iterate() works with the specified linked list.\n-\/\/\n-void ObjectSynchronizer::monitors_iterate(MonitorClosure* closure,\n-                                          ObjectMonitorsHashtable::PtrList* list,\n-                                          JavaThread* thread) {\n-  typedef LinkedListIterator<ObjectMonitor*> ObjectMonitorIterator;\n-  ObjectMonitorIterator iter(list->head());\n-  while (!iter.is_empty()) {\n-    ObjectMonitor* mid = *iter.next();\n-    \/\/ Owner set to a stack-lock address in thread should never be seen here:\n-    assert(mid->owner() == thread, \"must be\");\n-    if (!mid->is_being_async_deflated() && mid->object_peek() != nullptr) {\n-      \/\/ Only process with closure if the object is set.\n-\n-      \/\/ monitors_iterate() is only called at a safepoint or when the\n-      \/\/ target thread is suspended or when the target thread is\n-      \/\/ operating on itself. The current closures in use today are\n-      \/\/ only interested in an owned ObjectMonitor and ownership\n-      \/\/ cannot be dropped under the calling contexts so the\n-      \/\/ ObjectMonitor cannot be async deflated.\n-      closure->do_monitor(mid);\n+\/\/ Iterate ObjectMonitors owned by any thread and where the owner `filter`\n+\/\/ returns true.\n+template <typename OwnerFilter>\n+void ObjectSynchronizer::owned_monitors_iterate_filtered(MonitorClosure* closure, OwnerFilter filter) {\n+  monitors_iterate([&](ObjectMonitor* monitor) {\n+    \/\/ This function is only called at a safepoint or when the\n+    \/\/ target thread is suspended or when the target thread is\n+    \/\/ operating on itself. The current closures in use today are\n+    \/\/ only interested in an owned ObjectMonitor and ownership\n+    \/\/ cannot be dropped under the calling contexts so the\n+    \/\/ ObjectMonitor cannot be async deflated.\n+    if (monitor->has_owner() && filter(monitor->owner_raw())) {\n+      assert(!monitor->is_being_async_deflated(), \"Owned monitors should not be deflating\");\n+\n+      closure->do_monitor(monitor);\n@@ -1152,1 +1127,14 @@\n-  }\n+  });\n+}\n+\n+\/\/ Iterate ObjectMonitors where the owner == thread; this does NOT include\n+\/\/ ObjectMonitors where owner is set to a stack-lock address in thread.\n+void ObjectSynchronizer::owned_monitors_iterate(MonitorClosure* closure, JavaThread* thread) {\n+  auto thread_filter = [&](void* owner) { return owner == thread; };\n+  return owned_monitors_iterate_filtered(closure, thread_filter);\n+}\n+\n+\/\/ Iterate ObjectMonitors owned by any thread.\n+void ObjectSynchronizer::owned_monitors_iterate(MonitorClosure* closure) {\n+  auto all_filter = [&](void* owner) { return true; };\n+  return owned_monitors_iterate_filtered(closure, all_filter);\n@@ -1259,1 +1247,7 @@\n-bool ObjectSynchronizer::request_deflate_idle_monitors() {\n+void ObjectSynchronizer::request_deflate_idle_monitors() {\n+  MonitorLocker ml(MonitorDeflation_lock, Mutex::_no_safepoint_check_flag);\n+  set_is_async_deflation_requested(true);\n+  ml.notify_all();\n+}\n+\n+bool ObjectSynchronizer::request_deflate_idle_monitors_from_wb() {\n@@ -1264,5 +1258,3 @@\n-  set_is_async_deflation_requested(true);\n-  {\n-    MonitorLocker ml(MonitorDeflation_lock, Mutex::_no_safepoint_check_flag);\n-    ml.notify_all();\n-  }\n+\n+  request_deflate_idle_monitors();\n+\n@@ -1585,7 +1577,0 @@\n-\/\/ If table != nullptr, we gather owned ObjectMonitors indexed by the\n-\/\/ owner in the table. Please note that ObjectMonitors where the owner\n-\/\/ is set to a stack-lock address are NOT associated with the JavaThread\n-\/\/ that holds that stack-lock. All of the current consumers of\n-\/\/ ObjectMonitorsHashtable info only care about JNI locked monitors and\n-\/\/ those do not have the owner set to a stack-lock address.\n-\/\/\n@@ -1593,2 +1578,1 @@\n-                                                elapsedTimer* timer_p,\n-                                                ObjectMonitorsHashtable* table) {\n+                                                elapsedTimer* timer_p) {\n@@ -1605,12 +1589,0 @@\n-    } else if (table != nullptr) {\n-      \/\/ The caller is interested in the owned ObjectMonitors. This does\n-      \/\/ not include when owner is set to a stack-lock address in thread.\n-      \/\/ This also does not capture unowned ObjectMonitors that cannot be\n-      \/\/ deflated because of a waiter.\n-      void* key = mid->owner();\n-      \/\/ Since deflate_idle_monitors() and deflate_monitor_list() can be\n-      \/\/ called more than once, we have to make sure the entry has not\n-      \/\/ already been added.\n-      if (key != nullptr && !table->has_entry(key, mid)) {\n-        table->add_entry(key, mid);\n-      }\n@@ -1666,3 +1638,2 @@\n-\/\/ ObjectMonitors. It is also called via do_final_audit_and_print_stats()\n-\/\/ and VM_ThreadDump::doit() by the VMThread.\n-size_t ObjectSynchronizer::deflate_idle_monitors(ObjectMonitorsHashtable* table) {\n+\/\/ ObjectMonitors.\n+size_t ObjectSynchronizer::deflate_idle_monitors() {\n@@ -1693,1 +1664,1 @@\n-  size_t deflated_count = deflate_monitor_list(current, ls, &timer, table);\n+  size_t deflated_count = deflate_monitor_list(current, ls, &timer);\n@@ -1696,5 +1667,2 @@\n-  if (deflated_count > 0 || is_final_audit()) {\n-    \/\/ There are ObjectMonitors that have been deflated or this is the\n-    \/\/ final audit and all the remaining ObjectMonitors have been\n-    \/\/ deflated, BUT the MonitorDeflationThread blocked for the final\n-    \/\/ safepoint during unlinking.\n+  if (deflated_count > 0) {\n+    \/\/ There are ObjectMonitors that have been deflated.\n@@ -1705,1 +1673,1 @@\n-    unlinked_count = _in_use_list.unlink_deflated(current, ls, &timer, &delete_list);\n+    unlinked_count = _in_use_list.unlink_deflated(current, ls, &timer, deflated_count, &delete_list);\n@@ -1752,4 +1720,0 @@\n-    if (table != nullptr) {\n-      ls->print_cr(\"ObjectMonitorsHashtable: key_count=\" SIZE_FORMAT \", om_count=\" SIZE_FORMAT,\n-                   table->key_count(), table->om_count());\n-    }\n@@ -1808,1 +1772,1 @@\n-  ObjectSynchronizer::monitors_iterate(&rjmc, current);\n+  ObjectSynchronizer::owned_monitors_iterate(&rjmc, current);\n@@ -1862,6 +1826,0 @@\n-    \/\/ Do deflations in order to reduce the in-use monitor population\n-    \/\/ that is reported by ObjectSynchronizer::log_in_use_monitor_details()\n-    \/\/ which is called by ObjectSynchronizer::audit_and_print_stats().\n-    while (deflate_idle_monitors(\/* ObjectMonitorsHashtable is not needed here *\/ nullptr) > 0) {\n-      ; \/\/ empty\n-    }\n@@ -1916,1 +1874,1 @@\n-    log_in_use_monitor_details(ls);\n+    log_in_use_monitor_details(ls, !on_exit \/* log_all *\/);\n@@ -1962,3 +1920,1 @@\n-    \/\/ This should not happen, but if it does, it is not fatal.\n-    out->print_cr(\"WARNING: monitor=\" INTPTR_FORMAT \": in-use monitor is \"\n-                  \"deflated.\", p2i(n));\n+    \/\/ This could happen when monitor deflation blocks for a safepoint.\n@@ -1967,0 +1923,1 @@\n+\n@@ -1996,2 +1953,1 @@\n-void ObjectSynchronizer::log_in_use_monitor_details(outputStream* out) {\n-  stringStream ss;\n+void ObjectSynchronizer::log_in_use_monitor_details(outputStream* out, bool log_all) {\n@@ -1999,0 +1955,1 @@\n+    stringStream ss;\n@@ -2004,12 +1961,18 @@\n-    MonitorList::Iterator iter = _in_use_list.iterator();\n-    while (iter.has_next()) {\n-      ObjectMonitor* mid = iter.next();\n-      const oop obj = mid->object_peek();\n-      const markWord mark = mid->header();\n-      ResourceMark rm;\n-      out->print(INTPTR_FORMAT \"  %d%d%d  \" INTPTR_FORMAT \"  %s\", p2i(mid),\n-                 mid->is_busy(), mark.hash() != 0, mid->owner() != nullptr,\n-                 p2i(obj), obj == nullptr ? \"\" : obj->klass()->external_name());\n-      if (mid->is_busy()) {\n-        out->print(\" (%s)\", mid->is_busy_to_string(&ss));\n-        ss.reset();\n+\n+    auto is_interesting = [&](ObjectMonitor* monitor) {\n+      return log_all || monitor->has_owner() || monitor->is_busy();\n+    };\n+\n+    monitors_iterate([&](ObjectMonitor* monitor) {\n+      if (is_interesting(monitor)) {\n+        const oop obj = monitor->object_peek();\n+        const markWord mark = monitor->header();\n+        ResourceMark rm;\n+        out->print(INTPTR_FORMAT \"  %d%d%d  \" INTPTR_FORMAT \"  %s\", p2i(monitor),\n+                   monitor->is_busy(), mark.hash() != 0, monitor->owner() != nullptr,\n+                   p2i(obj), obj == nullptr ? \"\" : obj->klass()->external_name());\n+        if (monitor->is_busy()) {\n+          out->print(\" (%s)\", monitor->is_busy_to_string(&ss));\n+          ss.reset();\n+        }\n+        out->cr();\n@@ -2017,2 +1980,1 @@\n-      out->cr();\n-    }\n+    });\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":127,"deletions":165,"binary":false,"changes":292,"status":"modified"},{"patch":"@@ -39,49 +39,0 @@\n-\/\/ Hash table of void* to a list of ObjectMonitor* owned by the JavaThread.\n-\/\/ The JavaThread's owner key is either a JavaThread* or a stack lock\n-\/\/ address in the JavaThread so we use \"void*\".\n-\/\/\n-class ObjectMonitorsHashtable {\n- private:\n-  static unsigned int ptr_hash(void* const& s1) {\n-    \/\/ 2654435761 = 2^32 * Phi (golden ratio)\n-    return (unsigned int)(((uint32_t)(uintptr_t)s1) * 2654435761u);\n-  }\n-\n- public:\n-  class PtrList;\n-\n- private:\n-  \/\/ ResourceHashtable SIZE is specified at compile time so we\n-  \/\/ use 1031 which is the first prime after 1024.\n-  typedef ResourceHashtable<void*, PtrList*, 1031, AnyObj::C_HEAP, mtThread,\n-                            &ObjectMonitorsHashtable::ptr_hash> PtrTable;\n-  PtrTable* _ptrs;\n-  size_t _key_count;\n-  size_t _om_count;\n-\n- public:\n-  \/\/ ResourceHashtable is passed to various functions and populated in\n-  \/\/ different places so we allocate it using C_HEAP to make it immune\n-  \/\/ from any ResourceMarks that happen to be in the code paths.\n-  ObjectMonitorsHashtable() : _ptrs(new (mtThread) PtrTable), _key_count(0), _om_count(0) {}\n-\n-  ~ObjectMonitorsHashtable();\n-\n-  void add_entry(void* key, ObjectMonitor* om);\n-\n-  void add_entry(void* key, PtrList* list) {\n-    _ptrs->put(key, list);\n-    _key_count++;\n-  }\n-\n-  PtrList* get_entry(void* key) {\n-    PtrList** listpp = _ptrs->get(key);\n-    return (listpp == nullptr) ? nullptr : *listpp;\n-  }\n-\n-  bool has_entry(void* key, ObjectMonitor* om);\n-\n-  size_t key_count() { return _key_count; }\n-  size_t om_count() { return _om_count; }\n-};\n-\n@@ -99,0 +50,1 @@\n+                         size_t deflated_count,\n@@ -175,0 +127,9 @@\n+  \/\/ Iterate over all ObjectMonitors.\n+  template <typename Function>\n+  static void monitors_iterate(Function function);\n+\n+  \/\/ Iterate ObjectMonitors owned by any thread and where the owner `filter`\n+  \/\/ returns true.\n+  template <typename OwnerFilter>\n+  static void owned_monitors_iterate_filtered(MonitorClosure* closure, OwnerFilter filter);\n+\n@@ -176,8 +137,5 @@\n-  \/\/ ObjectMonitors where owner is set to a stack lock address in thread:\n-  \/\/\n-  \/\/ This version of monitors_iterate() works with the in-use monitor list.\n-  static void monitors_iterate(MonitorClosure* m, JavaThread* thread);\n-  \/\/ This version of monitors_iterate() works with the specified linked list.\n-  static void monitors_iterate(MonitorClosure* closure,\n-                               ObjectMonitorsHashtable::PtrList* list,\n-                               JavaThread* thread);\n+  \/\/ ObjectMonitors where owner is set to a stack lock address in thread.\n+  static void owned_monitors_iterate(MonitorClosure* m, JavaThread* thread);\n+\n+  \/\/ Iterate ObjectMonitors owned by any thread.\n+  static void owned_monitors_iterate(MonitorClosure* closure);\n@@ -188,3 +146,3 @@\n-  \/\/ GC: we currently use aggressive monitor deflation policy\n-  \/\/ Basically we try to deflate all monitors that are not busy.\n-  static size_t deflate_idle_monitors(ObjectMonitorsHashtable* table);\n+  \/\/ We currently use aggressive monitor deflation policy;\n+  \/\/ basically we try to deflate all monitors that are not busy.\n+  static size_t deflate_idle_monitors();\n@@ -196,2 +154,1 @@\n-  static size_t deflate_monitor_list(Thread* current, LogStream* ls, elapsedTimer* timer_p,\n-                                     ObjectMonitorsHashtable* table);\n+  static size_t deflate_monitor_list(Thread* current, LogStream* ls, elapsedTimer* timer_p);\n@@ -207,1 +164,2 @@\n-  static bool request_deflate_idle_monitors();  \/\/ for whitebox test support\n+  static void request_deflate_idle_monitors();\n+  static bool request_deflate_idle_monitors_from_wb();  \/\/ for whitebox test support\n@@ -217,1 +175,1 @@\n-  static void log_in_use_monitor_details(outputStream* out);\n+  static void log_in_use_monitor_details(outputStream* out, bool log_all);\n@@ -255,0 +213,7 @@\n+\/\/ Interface to visit monitors\n+class ObjectMonitorsView {\n+public:\n+  \/\/ Visit monitors that belong to the given thread\n+  virtual void visit(MonitorClosure* closure, JavaThread* thread) = 0;\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":29,"deletions":64,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/objectMonitor.inline.hpp\"\n@@ -52,0 +53,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -268,0 +270,105 @@\n+\/\/ Hash table of void* to a list of ObjectMonitor* owned by the JavaThread.\n+\/\/ The JavaThread's owner key is either a JavaThread* or a stack lock\n+\/\/ address in the JavaThread so we use \"void*\".\n+\/\/\n+class ObjectMonitorsDump : public MonitorClosure, public ObjectMonitorsView {\n+ private:\n+  static unsigned int ptr_hash(void* const& s1) {\n+    \/\/ 2654435761 = 2^32 * Phi (golden ratio)\n+    return (unsigned int)(((uint32_t)(uintptr_t)s1) * 2654435761u);\n+  }\n+\n+ private:\n+  class ObjectMonitorLinkedList :\n+    public LinkedListImpl<ObjectMonitor*,\n+                          AnyObj::C_HEAP, mtThread,\n+                          AllocFailStrategy::RETURN_NULL> {};\n+\n+  \/\/ ResourceHashtable SIZE is specified at compile time so we\n+  \/\/ use 1031 which is the first prime after 1024.\n+  typedef ResourceHashtable<void*, ObjectMonitorLinkedList*, 1031, AnyObj::C_HEAP, mtThread,\n+                            &ObjectMonitorsDump::ptr_hash> PtrTable;\n+  PtrTable* _ptrs;\n+  size_t _key_count;\n+  size_t _om_count;\n+\n+  void add_list(void* key, ObjectMonitorLinkedList* list) {\n+    _ptrs->put(key, list);\n+    _key_count++;\n+  }\n+\n+  ObjectMonitorLinkedList* get_list(void* key) {\n+    ObjectMonitorLinkedList** listpp = _ptrs->get(key);\n+    return (listpp == nullptr) ? nullptr : *listpp;\n+  }\n+\n+  void add(ObjectMonitor* monitor) {\n+    void* key = monitor->owner();\n+\n+    ObjectMonitorLinkedList* list = get_list(key);\n+    if (list == nullptr) {\n+      \/\/ Create new list and add it to the hash table:\n+      list = new (mtThread) ObjectMonitorLinkedList;\n+      _ptrs->put(key, list);\n+      _key_count++;\n+    }\n+\n+    assert(list->find(monitor) == nullptr, \"Should not contain duplicates\");\n+    list->add(monitor);  \/\/ Add the ObjectMonitor to the list.\n+    _om_count++;\n+  }\n+\n+ public:\n+  \/\/ ResourceHashtable is passed to various functions and populated in\n+  \/\/ different places so we allocate it using C_HEAP to make it immune\n+  \/\/ from any ResourceMarks that happen to be in the code paths.\n+  ObjectMonitorsDump() : _ptrs(new (mtThread) PtrTable), _key_count(0), _om_count(0) {}\n+\n+  ~ObjectMonitorsDump() {\n+    class CleanupObjectMonitorsDump: StackObj {\n+     public:\n+      bool do_entry(void*& key, ObjectMonitorLinkedList*& list) {\n+        list->clear();  \/\/ clear the LinkListNodes\n+        delete list;    \/\/ then delete the LinkedList\n+        return true;\n+      }\n+    } cleanup;\n+\n+    _ptrs->unlink(&cleanup);  \/\/ cleanup the LinkedLists\n+    delete _ptrs;             \/\/ then delete the hash table\n+  }\n+\n+  \/\/ Implements MonitorClosure used to collect all owned monitors in the system\n+  void do_monitor(ObjectMonitor* monitor) override {\n+    assert(monitor->has_owner(), \"Expects only owned monitors\");\n+\n+    if (monitor->is_owner_anonymous()) {\n+      \/\/ There's no need to collect anonymous owned monitors\n+      \/\/ because the caller of this code is only interested\n+      \/\/ in JNI owned monitors.\n+      return;\n+    }\n+\n+    if (monitor->object_peek() == nullptr) {\n+      \/\/ JNI code doesn't necessarily keep the monitor object\n+      \/\/ alive. Filter out monitors with dead objects.\n+      return;\n+    }\n+\n+    add(monitor);\n+  }\n+\n+  \/\/ Implements the ObjectMonitorsView interface\n+  void visit(MonitorClosure* closure, JavaThread* thread) override {\n+    ObjectMonitorLinkedList* list = get_list(thread);\n+    LinkedListIterator<ObjectMonitor*> iter(list != nullptr ? list->head() : nullptr);\n+    while (!iter.is_empty()) {\n+      ObjectMonitor* monitor = *iter.next();\n+      closure->do_monitor(monitor);\n+    }\n+  }\n+\n+  size_t key_count() { return _key_count; }\n+  size_t om_count() { return _om_count; }\n+};\n+\n@@ -282,2 +389,1 @@\n-  ObjectMonitorsHashtable table;\n-  ObjectMonitorsHashtable* tablep = nullptr;\n+  ObjectMonitorsDump object_monitors;\n@@ -285,7 +391,12 @@\n-    \/\/ The caller wants locked monitor information and that's expensive to gather\n-    \/\/ when there are a lot of inflated monitors. So we deflate idle monitors and\n-    \/\/ gather information about owned monitors at the same time.\n-    tablep = &table;\n-    while (ObjectSynchronizer::deflate_idle_monitors(tablep) > 0) {\n-      ; \/* empty *\/\n-    }\n+    \/\/ Gather information about owned monitors.\n+    ObjectSynchronizer::owned_monitors_iterate(&object_monitors);\n+\n+    \/\/ If there are many object monitors in the system then the above iteration\n+    \/\/ can start to take time. Be friendly to following thread dumps by telling\n+    \/\/ the MonitorDeflationThread to deflate monitors.\n+    \/\/\n+    \/\/ This is trying to be somewhat backwards compatible with the previous\n+    \/\/ implementation, which performed monitor deflation right here. We might\n+    \/\/ want to reconsider the need to trigger monitor deflation from the thread\n+    \/\/ dumping and instead maybe tweak the deflation heuristics.\n+    ObjectSynchronizer::request_deflate_idle_monitors();\n@@ -308,1 +419,1 @@\n-      snapshot_thread(jt, tcl, tablep);\n+      snapshot_thread(jt, tcl, &object_monitors);\n@@ -343,1 +454,1 @@\n-      snapshot_thread(jt, tcl, tablep);\n+      snapshot_thread(jt, tcl, &object_monitors);\n@@ -349,1 +460,1 @@\n-                                    ObjectMonitorsHashtable* table) {\n+                                    ObjectMonitorsView* monitors) {\n@@ -351,1 +462,1 @@\n-  snapshot->dump_stack_at_safepoint(_max_depth, _with_locked_monitors, table, false);\n+  snapshot->dump_stack_at_safepoint(_max_depth, _with_locked_monitors, monitors, false);\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":124,"deletions":13,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-class ObjectMonitorsHashtable;\n+class ObjectMonitorsView;\n@@ -207,1 +207,1 @@\n-                       ObjectMonitorsHashtable* table);\n+                       ObjectMonitorsView* monitors);\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -690,1 +691,1 @@\n-void ThreadStackTrace::dump_stack_at_safepoint(int maxDepth, ObjectMonitorsHashtable* table, bool full) {\n+void ThreadStackTrace::dump_stack_at_safepoint(int maxDepth, ObjectMonitorsView* monitors, bool full) {\n@@ -726,11 +727,1 @@\n-    if (table != nullptr) {\n-      \/\/ Get the ObjectMonitors locked by the target thread, if any,\n-      \/\/ and does not include any where owner is set to a stack lock\n-      \/\/ address in the target thread:\n-      ObjectMonitorsHashtable::PtrList* list = table->get_entry(_thread);\n-      if (list != nullptr) {\n-        ObjectSynchronizer::monitors_iterate(&imc, list, _thread);\n-      }\n-    } else {\n-      ObjectSynchronizer::monitors_iterate(&imc, _thread);\n-    }\n+    monitors->visit(&imc, _thread);\n@@ -991,1 +982,1 @@\n-                                             ObjectMonitorsHashtable* table, bool full) {\n+                                             ObjectMonitorsView* monitors, bool full) {\n@@ -993,1 +984,1 @@\n-  _stack_trace->dump_stack_at_safepoint(max_depth, table, full);\n+  _stack_trace->dump_stack_at_safepoint(max_depth, monitors, full);\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-class ObjectMonitorsHashtable;\n+class ObjectMonitorsView;\n@@ -267,1 +267,1 @@\n-                                      ObjectMonitorsHashtable* table, bool full);\n+                                      ObjectMonitorsView* monitors, bool full);\n@@ -290,1 +290,1 @@\n-  void            dump_stack_at_safepoint(int max_depth, ObjectMonitorsHashtable* table, bool full);\n+  void            dump_stack_at_safepoint(int max_depth, ObjectMonitorsView* monitors, bool full);\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,4 @@\n+import jdk.internal.access.JavaIOPrintStreamAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.InternalLock;\n+import jdk.internal.vm.Continuation;\n@@ -45,1 +49,2 @@\n-    static final StackWalker STACK_WALKER;\n+    private static final JavaIOPrintStreamAccess JIOPSA = SharedSecrets.getJavaIOPrintStreamAccess();\n+    private static final StackWalker STACK_WALKER;\n@@ -89,1 +94,10 @@\n-     * Prints the continuation stack trace.\n+     * Returns true if the frame is native, a class initializer, or holds monitors.\n+     *\/\n+    private static boolean isInterestingFrame(LiveStackFrame f) {\n+        return f.isNativeMethod()\n+                || \"<clinit>\".equals(f.getMethodName())\n+                || (f.getMonitors().length > 0);\n+    }\n+\n+    \/**\n+     * Prints the current thread's stack trace.\n@@ -94,1 +108,1 @@\n-    static void printStackTrace(PrintStream out, boolean printAll) {\n+    static void printStackTrace(PrintStream out, Continuation.Pinned reason, boolean printAll) {\n@@ -100,0 +114,15 @@\n+        Object lockObj = JIOPSA.lock(out);\n+        if (lockObj instanceof InternalLock lock && lock.tryLock()) {\n+            try {\n+                \/\/ find the closest frame that is causing the thread to be pinned\n+                stack.stream()\n+                    .filter(f -> isInterestingFrame(f))\n+                    .map(LiveStackFrame::getDeclaringClass)\n+                    .findFirst()\n+                    .ifPresentOrElse(klass -> {\n+                        \/\/ print the stack trace if not already seen\n+                        int hash = hash(stack);\n+                        if (HASHES.get(klass).add(hash)) {\n+                            printStackTrace(out, reason, stack, printAll);\n+                        }\n+                    }, () -> printStackTrace(out, reason, stack, true));  \/\/ not found\n@@ -101,15 +130,4 @@\n-        \/\/ find the closest frame that is causing the thread to be pinned\n-        stack.stream()\n-            .filter(f -> (f.isNativeMethod() || f.getMonitors().length > 0))\n-            .map(LiveStackFrame::getDeclaringClass)\n-            .findFirst()\n-            .ifPresentOrElse(klass -> {\n-                int hash = hash(stack);\n-                Hashes hashes = HASHES.get(klass);\n-                synchronized (hashes) {\n-                    \/\/ print the stack trace if not already seen\n-                    if (hashes.add(hash)) {\n-                        printStackTrace(stack, out, printAll);\n-                    }\n-                }\n-            }, () -> printStackTrace(stack, out, true));  \/\/ not found\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n@@ -118,2 +136,3 @@\n-    private static void printStackTrace(List<LiveStackFrame> stack,\n-                                        PrintStream out,\n+    private static void printStackTrace(PrintStream out,\n+                                        Continuation.Pinned reason,\n+                                        List<LiveStackFrame> stack,\n@@ -121,1 +140,1 @@\n-        out.println(Thread.currentThread());\n+        out.format(\"%s reason:%s%n\", Thread.currentThread(), reason);\n@@ -127,1 +146,1 @@\n-            } else if (frame.isNativeMethod() || printAll) {\n+            } else if (printAll || isInterestingFrame(frame)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/PinnedThreadPrinter.java","additions":42,"deletions":23,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -577,1 +577,1 @@\n-                byte[] buf = new byte[length << 1];\n+                byte[] buf = StringUTF16.newBytesFor(length);\n@@ -587,1 +587,1 @@\n-                byte[] dst = new byte[length << 1];\n+                byte[] dst = StringUTF16.newBytesFor(length);\n@@ -608,1 +608,1 @@\n-                byte[] dst = new byte[length << 1];\n+                byte[] dst = StringUTF16.newBytesFor(length);\n@@ -753,1 +753,1 @@\n-                dst = new byte[length << 1];\n+                dst = StringUTF16.newBytesFor(length);\n@@ -755,1 +755,1 @@\n-                byte[] buf = new byte[length << 1];\n+                byte[] buf = StringUTF16.newBytesFor(length);\n@@ -761,1 +761,1 @@\n-            dst = new byte[length << 1];\n+            dst = StringUTF16.newBytesFor(length);\n@@ -1307,1 +1307,1 @@\n-        byte[] dst = new byte[val.length << 1];\n+        byte[] dst = StringUTF16.newBytesFor(val.length);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-     * Virtual thread state and transitions:\n+     * Virtual thread state transitions:\n@@ -91,1 +91,1 @@\n-     *      NEW -> STARTED         \/\/ Thread.start\n+     *      NEW -> STARTED         \/\/ Thread.start, schedule to run\n@@ -94,0 +94,1 @@\n+     *  RUNNING -> TERMINATED      \/\/ done\n@@ -95,6 +96,6 @@\n-     *  RUNNING -> PARKING         \/\/ Thread attempts to park\n-     *  PARKING -> PARKED          \/\/ cont.yield successful, thread is parked\n-     *  PARKING -> PINNED          \/\/ cont.yield failed, thread is pinned\n-     *\n-     *   PARKED -> RUNNABLE        \/\/ unpark or interrupted\n-     *   PINNED -> RUNNABLE        \/\/ unpark or interrupted\n+     *  RUNNING -> PARKING         \/\/ Thread parking with LockSupport.park\n+     *  PARKING -> PARKED          \/\/ cont.yield successful, parked indefinitely\n+     *  PARKING -> PINNED          \/\/ cont.yield failed, parked indefinitely on carrier\n+     *   PARKED -> UNPARKED        \/\/ unparked, may be scheduled to continue\n+     *   PINNED -> RUNNING         \/\/ unparked, continue execution on same carrier\n+     * UNPARKED -> RUNNING         \/\/ continue execution after park\n@@ -102,1 +103,5 @@\n-     * RUNNABLE -> RUNNING         \/\/ continue execution\n+     *       RUNNING -> TIMED_PARKING   \/\/ Thread parking with LockSupport.parkNanos\n+     * TIMED_PARKING -> TIMED_PARKED    \/\/ cont.yield successful, timed-parked\n+     * TIMED_PARKING -> TIMED_PINNED    \/\/ cont.yield failed, timed-parked on carrier\n+     *  TIMED_PARKED -> UNPARKED        \/\/ unparked, may be scheduled to continue\n+     *  TIMED_PINNED -> RUNNING         \/\/ unparked, continue execution on same carrier\n@@ -105,4 +110,3 @@\n-     * YIELDING -> RUNNABLE        \/\/ yield successful\n-     * YIELDING -> RUNNING         \/\/ yield failed\n-     *\n-     *  RUNNING -> TERMINATED      \/\/ done\n+     * YIELDING -> YIELDED         \/\/ cont.yield successful, may be scheduled to continue\n+     * YIELDING -> RUNNING         \/\/ cont.yield failed\n+     *  YIELDED -> RUNNING         \/\/ continue execution after Thread.yield\n@@ -112,6 +116,15 @@\n-    private static final int RUNNABLE = 2;     \/\/ runnable-unmounted\n-    private static final int RUNNING  = 3;     \/\/ runnable-mounted\n-    private static final int PARKING  = 4;\n-    private static final int PARKED   = 5;     \/\/ unmounted\n-    private static final int PINNED   = 6;     \/\/ mounted\n-    private static final int YIELDING = 7;     \/\/ Thread.yield\n+    private static final int RUNNING  = 2;     \/\/ runnable-mounted\n+\n+    \/\/ untimed and timed parking\n+    private static final int PARKING       = 3;\n+    private static final int PARKED        = 4;     \/\/ unmounted\n+    private static final int PINNED        = 5;     \/\/ mounted\n+    private static final int TIMED_PARKING = 6;\n+    private static final int TIMED_PARKED  = 7;     \/\/ unmounted\n+    private static final int TIMED_PINNED  = 8;     \/\/ mounted\n+    private static final int UNPARKED      = 9;     \/\/ unmounted but runnable\n+\n+    \/\/ Thread.yield\n+    private static final int YIELDING = 10;\n+    private static final int YIELDED  = 11;         \/\/ unmounted but runnable\n+\n@@ -122,2 +135,0 @@\n-    private static final int RUNNABLE_SUSPENDED = (RUNNABLE | SUSPENDED);\n-    private static final int PARKED_SUSPENDED   = (PARKED | SUSPENDED);\n@@ -183,1 +194,9 @@\n-                PinnedThreadPrinter.printStackTrace(System.out, printAll);\n+                VirtualThread vthread = (VirtualThread) Thread.currentThread();\n+                int oldState = vthread.state();\n+                try {\n+                    \/\/ avoid printing when in transition states\n+                    vthread.setState(RUNNING);\n+                    PinnedThreadPrinter.printStackTrace(System.out, reason, printAll);\n+                } finally {\n+                    vthread.setState(oldState);\n+                }\n@@ -197,1 +216,3 @@\n-     * Runs or continues execution of the continuation on the current thread.\n+     * Runs or continues execution on the current thread. The virtual thread is mounted\n+     * on the current thread before the task runs or continues. It unmounts when the\n+     * task completes or yields.\n@@ -199,0 +220,1 @@\n+    @ChangesCurrentThread\n@@ -207,5 +229,9 @@\n-        if (initialState == STARTED && compareAndSetState(STARTED, RUNNING)) {\n-            \/\/ first run\n-        } else if (initialState == RUNNABLE && compareAndSetState(RUNNABLE, RUNNING)) {\n-            \/\/ consume parking permit\n-            setParkPermit(false);\n+        if (initialState == STARTED || initialState == UNPARKED || initialState == YIELDED) {\n+            \/\/ newly started or continue after parking\/blocking\/Thread.yield\n+            if (!compareAndSetState(initialState, RUNNING)) {\n+                return;\n+            }\n+            \/\/ consume parking permit when continuing after parking\n+            if (initialState == UNPARKED) {\n+                setParkPermit(false);\n+            }\n@@ -217,3 +243,1 @@\n-        \/\/ notify JVMTI before mount\n-        notifyJvmtiMount(\/*hide*\/true);\n-\n+        mount();\n@@ -223,0 +247,1 @@\n+            unmount();\n@@ -224,1 +249,1 @@\n-                afterTerminate();\n+                afterDone();\n@@ -234,2 +259,1 @@\n-     * otherwise it will be pushed to a submission queue.\n-     *\n+     * otherwise it will be pushed to an external submission queue.\n@@ -248,1 +272,1 @@\n-     * Submits the runContinuation task to the scheduler with a lazy submit.\n+     * Submits the runContinuation task to given scheduler with a lazy submit.\n@@ -262,1 +286,1 @@\n-     * Submits the runContinuation task to the scheduler as an external submit.\n+     * Submits the runContinuation task to the given scheduler as an external submit.\n@@ -288,3 +312,1 @@\n-     * Runs a task in the context of this virtual thread. The virtual thread is\n-     * mounted on the current (carrier) thread before the task runs. It unmounts\n-     * from its carrier thread when the task completes.\n+     * Runs a task in the context of this virtual thread.\n@@ -292,1 +314,0 @@\n-    @ChangesCurrentThread\n@@ -294,1 +315,1 @@\n-        assert state == RUNNING;\n+        assert Thread.currentThread() == this && state == RUNNING;\n@@ -296,2 +317,1 @@\n-        \/\/ first mount\n-        mount();\n+        \/\/ notify JVMTI, may post VirtualThreadStart event\n@@ -325,1 +345,1 @@\n-                \/\/ last unmount\n+                \/\/ notify JVMTI, may post VirtualThreadEnd event\n@@ -327,4 +347,0 @@\n-                unmount();\n-\n-                \/\/ final state\n-                setState(TERMINATED);\n@@ -342,0 +358,3 @@\n+        \/\/ notify JVMTI before mount\n+        notifyJvmtiMount(\/*hide*\/true);\n+\n@@ -378,0 +397,3 @@\n+\n+        \/\/ notify JVMTI after unmount\n+        notifyJvmtiUnmount(\/*hide*\/false);\n@@ -420,3 +442,2 @@\n-     * Unmounts this virtual thread, invokes Continuation.yield, and re-mounts the\n-     * thread when continued. When enabled, JVMTI must be notified from this method.\n-     * @return true if the yield was successful\n+     * Invokes Continuation.yield, notifying JVMTI (if enabled) to hide frames until\n+     * the continuation continues.\n@@ -425,1 +446,0 @@\n-    @ChangesCurrentThread\n@@ -427,1 +447,0 @@\n-        \/\/ unmount\n@@ -429,1 +448,0 @@\n-        unmount();\n@@ -433,2 +451,0 @@\n-            \/\/ re-mount\n-            mount();\n@@ -445,2 +461,1 @@\n-        int s = state();\n-        assert (s == PARKING || s == YIELDING) && (carrierThread == null);\n+        assert carrierThread == null;\n@@ -448,2 +463,1 @@\n-        if (s == PARKING) {\n-            setState(PARKED);\n+        int s = state();\n@@ -451,2 +465,4 @@\n-            \/\/ notify JVMTI that unmount has completed, thread is parked\n-            notifyJvmtiUnmount(\/*hide*\/false);\n+        \/\/ LockSupport.park\/parkNanos\n+        if (s == PARKING || s == TIMED_PARKING) {\n+            int newState = (s == PARKING) ? PARKED : TIMED_PARKED;\n+            setState(newState);\n@@ -455,1 +471,1 @@\n-            if (parkPermit && compareAndSetState(PARKED, RUNNABLE)) {\n+            if (parkPermit && compareAndSetState(newState, UNPARKED)) {\n@@ -464,2 +480,2 @@\n-        } else if (s == YIELDING) {   \/\/ Thread.yield\n-            setState(RUNNABLE);\n+            return;\n+        }\n@@ -467,2 +483,3 @@\n-            \/\/ notify JVMTI that unmount has completed, thread is runnable\n-            notifyJvmtiUnmount(\/*hide*\/false);\n+        \/\/ Thread.yield\n+        if (s == YIELDING) {\n+            setState(YIELDED);\n@@ -476,0 +493,1 @@\n+            return;\n@@ -477,0 +495,2 @@\n+\n+        assert false;\n@@ -480,2 +500,1 @@\n-     * Invoked after the thread terminates execution. It notifies anyone\n-     * waiting for the thread to terminate.\n+     * Invoked after the continuation completes.\n@@ -483,2 +502,2 @@\n-    private void afterTerminate() {\n-        afterTerminate(true, true);\n+    private void afterDone() {\n+        afterDone(true);\n@@ -488,2 +507,2 @@\n-     * Invoked after the thread terminates (or start failed). This method\n-     * notifies anyone waiting for the thread to terminate.\n+     * Invoked after the continuation completes (or start failed). Sets the thread\n+     * state to TERMINATED and notifies anyone waiting for the thread to terminate.\n@@ -492,1 +511,0 @@\n-     * @param executed true if the thread executed, false if it failed to start\n@@ -494,6 +512,3 @@\n-    private void afterTerminate(boolean notifyContainer, boolean executed) {\n-        assert (state() == TERMINATED) && (carrierThread == null);\n-\n-        if (executed) {\n-            notifyJvmtiUnmount(\/*hide*\/false);\n-        }\n+    private void afterDone(boolean notifyContainer) {\n+        assert carrierThread == null;\n+        setState(TERMINATED);\n@@ -549,2 +564,1 @@\n-                setState(TERMINATED);\n-                afterTerminate(addedToContainer, \/*executed*\/false);\n+                afterDone(addedToContainer);\n@@ -618,2 +632,2 @@\n-            Future<?> unparker = scheduleUnpark(this::unpark, nanos);\n-            setState(PARKING);\n+            Future<?> unparker = scheduleUnpark(nanos);  \/\/ may throw OOME\n+            setState(TIMED_PARKING);\n@@ -625,1 +639,1 @@\n-                    assert state() == PARKING;\n+                    assert state() == TIMED_PARKING;\n@@ -657,1 +671,1 @@\n-        setState(PINNED);\n+        setState(timed ? TIMED_PINNED : PINNED);\n@@ -683,1 +697,1 @@\n-     * Schedule an unpark task to run after a given delay.\n+     * Schedule this virtual thread to be unparked after a given delay.\n@@ -686,1 +700,2 @@\n-    private Future<?> scheduleUnpark(Runnable unparker, long nanos) {\n+    private Future<?> scheduleUnpark(long nanos) {\n+        assert Thread.currentThread() == this;\n@@ -690,1 +705,1 @@\n-            return UNPARKER.schedule(unparker, nanos, NANOSECONDS);\n+            return UNPARKER.schedule(this::unpark, nanos, NANOSECONDS);\n@@ -725,1 +740,2 @@\n-            if (s == PARKED && compareAndSetState(PARKED, RUNNABLE)) {\n+            boolean parked = (s == PARKED) || (s == TIMED_PARKED);\n+            if (parked && compareAndSetState(s, UNPARKED)) {\n@@ -736,2 +752,2 @@\n-            } else if (s == PINNED) {\n-                \/\/ unpark carrier thread when pinned.\n+            } else if ((s == PINNED) || (s == TIMED_PINNED)) {\n+                \/\/ unpark carrier thread when pinned\n@@ -740,1 +756,1 @@\n-                    if (carrier != null && state() == PINNED) {\n+                    if (carrier != null && ((s = state()) == PINNED || s == TIMED_PINNED)) {\n@@ -877,1 +893,2 @@\n-        switch (state()) {\n+        int s = state();\n+        switch (s & ~SUSPENDED) {\n@@ -887,2 +904,2 @@\n-            case RUNNABLE:\n-            case RUNNABLE_SUSPENDED:\n+            case UNPARKED:\n+            case YIELDED:\n@@ -902,0 +919,1 @@\n+            case TIMED_PARKING:\n@@ -903,1 +921,1 @@\n-                \/\/ runnable, mounted, not yet waiting\n+                \/\/ runnable, in transition\n@@ -906,1 +924,0 @@\n-            case PARKED_SUSPENDED:\n@@ -908,1 +925,4 @@\n-                return Thread.State.WAITING;\n+                return State.WAITING;\n+            case TIMED_PARKED:\n+            case TIMED_PINNED:\n+                return State.TIMED_WAITING;\n@@ -943,1 +963,1 @@\n-     * Returns null if the thread is in another state.\n+     * Returns null if the thread is mounted or in transition.\n@@ -946,22 +966,10 @@\n-        int initialState = state();\n-        return switch (initialState) {\n-            case RUNNABLE, PARKED -> {\n-                int suspendedState = initialState | SUSPENDED;\n-                if (compareAndSetState(initialState, suspendedState)) {\n-                    try {\n-                        yield cont.getStackTrace();\n-                    } finally {\n-                        assert state == suspendedState;\n-                        setState(initialState);\n-\n-                        \/\/ re-submit if runnable\n-                        \/\/ re-submit if unparked while suspended\n-                        if (initialState == RUNNABLE\n-                            || (parkPermit && compareAndSetState(PARKED, RUNNABLE))) {\n-                            try {\n-                                submitRunContinuation();\n-                            } catch (RejectedExecutionException ignore) { }\n-                        }\n-                    }\n-                }\n-                yield null;\n+        int initialState = state() & ~SUSPENDED;\n+        switch (initialState) {\n+            case NEW, STARTED, TERMINATED -> {\n+                return new StackTraceElement[0];  \/\/ unmounted, empty stack\n+            }\n+            case RUNNING, PINNED, TIMED_PINNED -> {\n+                return null;   \/\/ mounted\n+            }\n+            case PARKED, TIMED_PARKED -> {\n+                \/\/ unmounted, not runnable\n@@ -969,2 +977,33 @@\n-            case NEW, STARTED, TERMINATED ->  new StackTraceElement[0];  \/\/ empty stack\n-            default -> null;\n+            case UNPARKED, YIELDED -> {\n+                \/\/ unmounted, runnable\n+            }\n+            case PARKING, TIMED_PARKING, YIELDING -> {\n+                return null;  \/\/ in transition\n+            }\n+            default -> throw new InternalError(\"\" + initialState);\n+        }\n+\n+        \/\/ thread is unmounted, prevent it from continuing\n+        int suspendedState = initialState | SUSPENDED;\n+        if (!compareAndSetState(initialState, suspendedState)) {\n+            return null;\n+        }\n+\n+        \/\/ get stack trace and restore state\n+        StackTraceElement[] stack;\n+        try {\n+            stack = cont.getStackTrace();\n+        } finally {\n+            assert state == suspendedState;\n+            setState(initialState);\n+        }\n+        boolean resubmit = switch (initialState) {\n+            case UNPARKED, YIELDED -> {\n+                \/\/ resubmit as task may have run while suspended\n+                yield true;\n+            }\n+            case PARKED, TIMED_PARKED -> {\n+                \/\/ resubmit if unparked while suspended\n+                yield parkPermit && compareAndSetState(initialState, UNPARKED);\n+            }\n+            default -> throw new InternalError();\n@@ -972,0 +1011,4 @@\n+        if (resubmit) {\n+            submitRunContinuation();\n+        }\n+        return stack;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":167,"deletions":124,"binary":false,"changes":291,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import javax.security.auth.login.Configuration;\n@@ -31,0 +32,1 @@\n+import java.security.cert.CertStoreParameters;\n@@ -1559,1 +1561,1 @@\n-        final String constructorParameterClassName;\n+        final Class<?> constructorParameterClass;\n@@ -1561,1 +1563,1 @@\n-        EngineDescription(String name, boolean sp, String paramName) {\n+        EngineDescription(String name, boolean sp, Class<?> constructorParameterClass) {\n@@ -1564,1 +1566,1 @@\n-            this.constructorParameterClassName = paramName;\n+            this.constructorParameterClass = constructorParameterClass;\n@@ -1571,2 +1573,2 @@\n-    private static void addEngine(String name, boolean sp, String paramName) {\n-        EngineDescription ed = new EngineDescription(name, sp, paramName);\n+    private static void addEngine(String name, boolean sp, Class<?> constructorParameterClass) {\n+        EngineDescription ed = new EngineDescription(name, sp, constructorParameterClass);\n@@ -1588,1 +1590,1 @@\n-                \"java.security.SecureRandomParameters\");\n+                SecureRandomParameters.class);\n@@ -1594,1 +1596,1 @@\n-                            \"java.security.cert.CertStoreParameters\");\n+                CertStoreParameters.class);\n@@ -1613,0 +1615,2 @@\n+        @SuppressWarnings(\"removal\")\n+        Class<Policy.Parameters> policyParams = Policy.Parameters.class;\n@@ -1614,1 +1618,1 @@\n-                            \"java.security.Policy$Parameters\");\n+                policyParams);\n@@ -1617,1 +1621,1 @@\n-                            \"javax.security.auth.login.Configuration$Parameters\");\n+                Configuration.Parameters.class);\n@@ -1624,1 +1628,1 @@\n-                            \"java.lang.Object\");\n+                            Object.class);\n@@ -1898,2 +1902,1 @@\n-                    ctrParamClz = cap.constructorParameterClassName == null?\n-                        null : Class.forName(cap.constructorParameterClassName);\n+                    ctrParamClz = cap.constructorParameterClass;\n@@ -1910,1 +1913,1 @@\n-                                    + cap.constructorParameterClassName.replace('$', '.')\n+                                    + cap.constructorParameterClass.getName().replace('$', '.')\n","filename":"src\/java.base\/share\/classes\/java\/security\/Provider.java","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -204,0 +204,4 @@\n+        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            SSLLogger.finest(\"X509KeyManager class: \" +\n+                    km.getClass().getName());\n+        }\n@@ -273,0 +277,4 @@\n+        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            SSLLogger.finest(\"X509KeyManager class: \" +\n+                    km.getClass().getName());\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509Authentication.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## zlib v1.2.13\n+## zlib v1.3.1\n@@ -6,1 +6,1 @@\n-Copyright (C) 1995-2022 Jean-loup Gailly and Mark Adler\n+Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n","filename":"src\/java.base\/share\/legal\/zlib.md","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,0 +4,103 @@\n+Changes in 1.3.1 (22 Jan 2024)\n+- Reject overflows of zip header fields in minizip\n+- Fix bug in inflateSync() for data held in bit buffer\n+- Add LIT_MEM define to use more memory for a small deflate speedup\n+- Fix decision on the emission of Zip64 end records in minizip\n+- Add bounds checking to ERR_MSG() macro, used by zError()\n+- Neutralize zip file traversal attacks in miniunz\n+- Fix a bug in ZLIB_DEBUG compiles in check_match()\n+- Various portability and appearance improvements\n+\n+Changes in 1.3 (18 Aug 2023)\n+- Remove K&R function definitions and zlib2ansi\n+- Fix bug in deflateBound() for level 0 and memLevel 9\n+- Fix bug when gzungetc() is used immediately after gzopen()\n+- Fix bug when using gzflush() with a very small buffer\n+- Fix crash when gzsetparams() attempted for transparent write\n+- Fix test\/example.c to work with FORCE_STORED\n+- Rewrite of zran in examples (see zran.c version history)\n+- Fix minizip to allow it to open an empty zip file\n+- Fix reading disk number start on zip64 files in minizip\n+- Fix logic error in minizip argument processing\n+- Add minizip testing to Makefile\n+- Read multiple bytes instead of byte-by-byte in minizip unzip.c\n+- Add memory sanitizer to configure (--memory)\n+- Various portability improvements\n+- Various documentation improvements\n+- Various spelling and typo corrections\n+\n+Changes in 1.2.13 (13 Oct 2022)\n+- Fix configure issue that discarded provided CC definition\n+- Correct incorrect inputs provided to the CRC functions\n+- Repair prototypes and exporting of new CRC functions\n+- Fix inflateBack to detect invalid input with distances too far\n+- Have infback() deliver all of the available output up to any error\n+- Fix a bug when getting a gzip header extra field with inflate()\n+- Fix bug in block type selection when Z_FIXED used\n+- Tighten deflateBound bounds\n+- Remove deleted assembler code references\n+- Various portability and appearance improvements\n+\n+Changes in 1.2.12 (27 Mar 2022)\n+- Cygwin does not have _wopen(), so do not create gzopen_w() there\n+- Permit a deflateParams() parameter change as soon as possible\n+- Limit hash table inserts after switch from stored deflate\n+- Fix bug when window full in deflate_stored()\n+- Fix CLEAR_HASH macro to be usable as a single statement\n+- Avoid a conversion error in gzseek when off_t type too small\n+- Have Makefile return non-zero error code on test failure\n+- Avoid some conversion warnings in gzread.c and gzwrite.c\n+- Update use of errno for newer Windows CE versions\n+- Small speedup to inflate [psumbera]\n+- Return an error if the gzputs string length can't fit in an int\n+- Add address checking in clang to -w option of configure\n+- Don't compute check value for raw inflate if asked to validate\n+- Handle case where inflateSync used when header never processed\n+- Avoid the use of ptrdiff_t\n+- Avoid an undefined behavior of memcpy() in gzappend()\n+- Avoid undefined behaviors of memcpy() in gz*printf()\n+- Avoid an undefined behavior of memcpy() in _tr_stored_block()\n+- Make the names in functions declarations identical to definitions\n+- Remove old assembler code in which bugs have manifested\n+- Fix deflateEnd() to not report an error at start of raw deflate\n+- Add legal disclaimer to README\n+- Emphasize the need to continue decompressing gzip members\n+- Correct the initialization requirements for deflateInit2()\n+- Fix a bug that can crash deflate on some input when using Z_FIXED\n+- Assure that the number of bits for deflatePrime() is valid\n+- Use a structure to make globals in enough.c evident\n+- Use a macro for the printf format of big_t in enough.c\n+- Clean up code style in enough.c, update version\n+- Use inline function instead of macro for index in enough.c\n+- Clarify that prefix codes are counted in enough.c\n+- Show all the codes for the maximum tables size in enough.c\n+- Add gznorm.c example, which normalizes gzip files\n+- Fix the zran.c example to work on a multiple-member gzip file\n+- Add tables for crc32_combine(), to speed it up by a factor of 200\n+- Add crc32_combine_gen() and crc32_combine_op() for fast combines\n+- Speed up software CRC-32 computation by a factor of 1.5 to 3\n+- Use atomic test and set, if available, for dynamic CRC tables\n+- Don't bother computing check value after successful inflateSync()\n+- Correct comment in crc32.c\n+- Add use of the ARMv8 crc32 instructions when requested\n+- Use ARM crc32 instructions if the ARM architecture has them\n+- Explicitly note that the 32-bit check values are 32 bits\n+- Avoid adding empty gzip member after gzflush with Z_FINISH\n+- Fix memory leak on error in gzlog.c\n+- Fix error in comment on the polynomial representation of a byte\n+- Clarify gz* function interfaces, referring to parameter names\n+- Change macro name in inflate.c to avoid collision in VxWorks\n+- Correct typo in blast.c\n+- Improve portability of contrib\/minizip\n+- Fix indentation in minizip's zip.c\n+- Replace black\/white with allow\/block. (theresa-m)\n+- minizip warning fix if MAXU32 already defined. (gvollant)\n+- Fix unztell64() in minizip to work past 4GB. (Danil Hrchner)\n+- Clean up minizip to reduce warnings for testing\n+- Add fallthrough comments for gcc\n+- Eliminate use of ULL constants\n+- Separate out address sanitizing from warnings in configure\n+- Remove destructive aspects of make distclean\n+- Check for cc masquerading as gcc or clang in configure\n+- Fix crc32.c to compile local functions only if used\n+\n@@ -99,1 +202,1 @@\n-- Suport i686 and amd64 assembler builds in CMakeLists.txt\n+- Support i686 and amd64 assembler builds in CMakeLists.txt\n@@ -299,1 +402,1 @@\n-- Improve inflateSync() documentation to note indeterminancy\n+- Improve inflateSync() documentation to note indeterminacy\n@@ -306,2 +409,2 @@\n-- Add debug records in assmebler code [Londer]\n-- Update RFC references to use https:\/\/tools.ietf.org\/html\/... [Li]\n+- Add debug records in assembler code [Londer]\n+- Update RFC references to use http:\/\/tools.ietf.org\/html\/... [Li]\n@@ -514,1 +617,1 @@\n-- Moved nintendods directory from contrib to .\n+- Moved nintendods directory from contrib to root\n@@ -688,1 +791,1 @@\n-  discovering the vulnerability and providing test cases.\n+  discovering the vulnerability and providing test cases\n@@ -724,1 +827,1 @@\n-  fitblk.c, gzlog.[ch], gzjoin.c, and zlib_how.html.\n+  fitblk.c, gzlog.[ch], gzjoin.c, and zlib_how.html\n@@ -795,1 +898,1 @@\n-- Add a note to puff.c on no distance codes case.\n+- Add a note to puff.c on no distance codes case\n@@ -973,1 +1076,1 @@\n-- Enchance comments in zlib.h on what happens if gzprintf() tries to\n+- Enhance comments in zlib.h on what happens if gzprintf() tries to\n@@ -1039,1 +1142,1 @@\n-- ZFREE was repeated on same allocation on some error conditions.\n+- ZFREE was repeated on same allocation on some error conditions\n@@ -1044,1 +1147,1 @@\n-  less than 32K.\n+  less than 32K\n@@ -1046,1 +1149,1 @@\n-  of 256 bytes. (A complete fix will be available in 1.1.5).\n+  of 256 bytes. (A complete fix will be available in 1.1.5)\n@@ -1120,1 +1223,1 @@\n-  matches in deflate_slow.\n+  matches in deflate_slow\n@@ -1151,1 +1254,1 @@\n-  the declaration of FAR (Gilles VOllant)\n+  the declaration of FAR (Gilles Vollant)\n@@ -1165,1 +1268,1 @@\n-  trees.h, compile with GEN_TREES_H and run \"make test\".\n+  trees.h, compile with GEN_TREES_H and run \"make test\"\n@@ -1204,2 +1307,2 @@\n-  Andy Buckler for finding this one).\n-- In minigzip, pass transparently also the first byte for .Z files.\n+  Andy Buckler for finding this one)\n+- In minigzip, pass transparently also the first byte for .Z files\n@@ -1209,1 +1312,1 @@\n-- make static libraries by default in configure, add --shared option.\n+- make static libraries by default in configure, add --shared option\n@@ -1221,1 +1324,1 @@\n-        386 asm code replacing longest_match().\n+        386 asm code replacing longest_match()\n@@ -1229,1 +1332,1 @@\n-        How to use compress(), uncompress() and the gz* functions from VB.\n+        How to use compress(), uncompress() and the gz* functions from VB\n@@ -1238,2 +1341,2 @@\n-- Allow compilation of gzio with -DNO_DEFLATE to avoid the compression code.\n-- Use default memcpy for Symantec MSDOS compiler.\n+- Allow compilation of gzio with -DNO_DEFLATE to avoid the compression code\n+- Use default memcpy for Symantec MSDOS compiler\n@@ -1252,1 +1355,1 @@\n-- use variable z_verbose for tracing in debug mode (L. Peter Deutsch).\n+- use variable z_verbose for tracing in debug mode (L. Peter Deutsch)\n@@ -1262,1 +1365,1 @@\n-- Avoid expanded $Id$. Use \"rcs -kb\" or \"cvs admin -kb\" to avoid Id expansion.\n+- Avoid expanded $Id$. Use \"rcs -kb\" or \"cvs admin -kb\" to avoid Id expansion\n@@ -1283,1 +1386,1 @@\n-  on to attempt decompressing extra garbage data. This affected minigzip too.\n+  on to attempt decompressing extra garbage data. This affected minigzip too\n@@ -1313,1 +1416,1 @@\n-- fix deflateParams() which could generate bad compressed data.\n+- fix deflateParams() which could generate bad compressed data\n@@ -1334,1 +1437,1 @@\n-  and compression strategy.\n+  and compression strategy\n@@ -1373,1 +1476,1 @@\n-- use STDC instead of __GO32__ to avoid redeclaring exit, calloc, etc...\n+- use STDC instead of __GO32__ to avoid redeclaring exit, calloc, etc.\n@@ -1376,1 +1479,1 @@\n-- allow \"a\" as mode in gzopen.\n+- allow \"a\" as mode in gzopen\n@@ -1382,1 +1485,1 @@\n-- added a dimension to all arrays (Borland C can't count).\n+- added a dimension to all arrays (Borland C can't count)\n@@ -1385,1 +1488,1 @@\n-- Watcom C pretends to be Microsoft C small model even in 32 bit mode.\n+- Watcom C pretends to be Microsoft C small model even in 32 bit mode\n@@ -1388,1 +1491,1 @@\n-     (what's wrong with far data in far model?).\n+     (what's wrong with far data in far model?)\n@@ -1395,1 +1498,1 @@\n-  not completely flushed in rare occasions).\n+  not completely flushed in rare occasions)\n@@ -1397,1 +1500,1 @@\n-  (it's now sufficient to set MAX_WBITS in zconf.h).\n+  (it's now sufficient to set MAX_WBITS in zconf.h)\n@@ -1399,1 +1502,1 @@\n-  typedefs and because voidnp was not near in large model).\n+  typedefs and because voidnp was not near in large model)\n@@ -1408,1 +1511,1 @@\n-- For deflate with flush, flush even if no more input is provided.\n+- For deflate with flush, flush even if no more input is provided\n@@ -1413,1 +1516,1 @@\n-- allow renaming of Byte, uInt, etc... with #define.\n+- allow renaming of Byte, uInt, etc... with #define\n@@ -1432,1 +1535,1 @@\n-- optimized inflate on stored blocks.\n+- optimized inflate on stored blocks\n@@ -1450,1 +1553,1 @@\n-- moved MAX_WBITS to zconf.h because users might want to change that.\n+- moved MAX_WBITS to zconf.h because users might want to change that\n@@ -1459,1 +1562,1 @@\n-  is incompatible with previous versions of zlib which returned Z_OK.\n+  is incompatible with previous versions of zlib which returned Z_OK\n@@ -1469,1 +1572,1 @@\n-  TurboC large model.\n+  TurboC large model\n@@ -1472,1 +1575,1 @@\n-- Added full inflate support.\n+- Added full inflate support\n@@ -1475,1 +1578,1 @@\n-  incompatible with previous versions; see zlib.h for the new usage.\n+  incompatible with previous versions; see zlib.h for the new usage\n@@ -1478,1 +1581,1 @@\n-- workaround for a bug in TurboC. example and minigzip now work on MSDOS.\n+- workaround for a bug in TurboC. example and minigzip now work on MSDOS\n@@ -1483,1 +1586,1 @@\n-- added transparent reading of non-gziped files in gzread.\n+- added transparent reading of non-gziped files in gzread\n@@ -1485,1 +1588,1 @@\n-- fixed bug in destroy (gzio.c) (don't return Z_STREAM_END for gzclose).\n+- fixed bug in destroy (gzio.c) (don't return Z_STREAM_END for gzclose)\n@@ -1491,1 +1594,1 @@\n-  not yet Z_FULL_FLUSH.\n+  not yet Z_FULL_FLUSH\n@@ -1493,1 +1596,1 @@\n-- added opaque object for zalloc and zfree.\n+- added opaque object for zalloc and zfree\n@@ -1495,3 +1598,3 @@\n-- added a variable zlib_version for consistency checking.\n-- renamed the 'filter' parameter of deflateInit2 as 'strategy'.\n-  Added Z_FILTERED and Z_HUFFMAN_ONLY constants.\n+- added a variable zlib_version for consistency checking\n+- renamed the 'filter' parameter of deflateInit2 as 'strategy'\n+  Added Z_FILTERED and Z_HUFFMAN_ONLY constants\n@@ -1500,1 +1603,1 @@\n-- avoid \"zip\" everywhere, use zlib instead of ziplib.\n+- avoid \"zip\" everywhere, use zlib instead of ziplib\n@@ -1502,1 +1605,1 @@\n-  if compression method == 8.\n+  if compression method == 8\n@@ -1505,1 +1608,1 @@\n-- added the method parameter for deflateInit2.\n+- added the method parameter for deflateInit2\n@@ -1507,1 +1610,1 @@\n-- simplied considerably deflateInit and inflateInit by not supporting\n+- simplified considerably deflateInit and inflateInit by not supporting\n@@ -1509,1 +1612,1 @@\n-  and inflateInit2.\n+  and inflateInit2\n@@ -1513,1 +1616,1 @@\n-- use Z_FINISH instead of deflateEnd to finish compression.\n+- use Z_FINISH instead of deflateEnd to finish compression\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/ChangeLog","additions":160,"deletions":57,"binary":false,"changes":217,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-zlib 1.2.13 is a general purpose data compression library.  All the code is\n+zlib 1.3.1 is a general purpose data compression library.  All the code is\n@@ -32,1 +32,1 @@\n-http:\/\/marknelson.us\/1997\/01\/01\/zlib-engine\/ .\n+https:\/\/marknelson.us\/posts\/1997\/01\/01\/zlib-engine.html .\n@@ -34,1 +34,1 @@\n-The changes made in version 1.2.13 are documented in the file ChangeLog.\n+The changes made in version 1.3.1 are documented in the file ChangeLog.\n@@ -38,2 +38,2 @@\n-zlib is available in Java using the java.util.zip package, documented at\n-http:\/\/java.sun.com\/developer\/technicalArticles\/Programming\/compression\/ .\n+zlib is available in Java using the java.util.zip package. Follow the API\n+Documentation link at: https:\/\/docs.oracle.com\/search\/?q=java.util.zip .\n@@ -41,3 +41,2 @@\n-A Perl interface to zlib written by Paul Marquess <pmqs@cpan.org> is available\n-at CPAN (Comprehensive Perl Archive Network) sites, including\n-http:\/\/search.cpan.org\/~pmqs\/IO-Compress-Zlib\/ .\n+A Perl interface to zlib and bzip2 written by Paul Marquess <pmqs@cpan.org>\n+can be found at https:\/\/github.com\/pmqs\/IO-Compress .\n@@ -67,1 +66,1 @@\n-- On Digital Unix 4.0D (formely OSF\/1) on AlphaServer, the cc option -std1 is\n+- On Digital Unix 4.0D (formerly OSF\/1) on AlphaServer, the cc option -std1 is\n@@ -87,1 +86,1 @@\n- (C) 1995-2022 Jean-loup Gailly and Mark Adler\n+ (C) 1995-2024 Jean-loup Gailly and Mark Adler\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/README","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -46,7 +46,2 @@\n-int ZEXPORT compress2(dest, destLen, source, sourceLen, level)\n-    Bytef *dest;\n-    uLongf *destLen;\n-    const Bytef *source;\n-    uLong sourceLen;\n-    int level;\n-{\n+int ZEXPORT compress2(Bytef *dest, uLongf *destLen, const Bytef *source,\n+                      uLong sourceLen, int level) {\n@@ -92,6 +87,2 @@\n-int ZEXPORT compress(dest, destLen, source, sourceLen)\n-    Bytef *dest;\n-    uLongf *destLen;\n-    const Bytef *source;\n-    uLong sourceLen;\n-{\n+int ZEXPORT compress(Bytef *dest, uLongf *destLen, const Bytef *source,\n+                     uLong sourceLen) {\n@@ -105,3 +96,1 @@\n-uLong ZEXPORT compressBound(sourceLen)\n-    uLong sourceLen;\n-{\n+uLong ZEXPORT compressBound(uLong sourceLen) {\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/compress.c","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2022 Jean-loup Gailly and Mark Adler\n+ * Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n@@ -79,1 +79,1 @@\n-   \" deflate 1.2.13 Copyright 1995-2022 Jean-loup Gailly and Mark Adler \";\n+   \" deflate 1.3.1 Copyright 1995-2024 Jean-loup Gailly and Mark Adler \";\n@@ -87,3 +87,0 @@\n-\/* ===========================================================================\n- *  Function prototypes.\n- *\/\n@@ -97,1 +94,1 @@\n-typedef block_state (*compress_func) OF((deflate_state *s, int flush));\n+typedef block_state (*compress_func)(deflate_state *s, int flush);\n@@ -100,5 +97,2 @@\n-local int deflateStateCheck      OF((z_streamp strm));\n-local void slide_hash     OF((deflate_state *s));\n-local void fill_window    OF((deflate_state *s));\n-local block_state deflate_stored OF((deflate_state *s, int flush));\n-local block_state deflate_fast   OF((deflate_state *s, int flush));\n+local block_state deflate_stored(deflate_state *s, int flush);\n+local block_state deflate_fast(deflate_state *s, int flush);\n@@ -106,13 +100,1 @@\n-local block_state deflate_slow   OF((deflate_state *s, int flush));\n-#endif\n-local block_state deflate_rle    OF((deflate_state *s, int flush));\n-local block_state deflate_huff   OF((deflate_state *s, int flush));\n-local void lm_init        OF((deflate_state *s));\n-local void putShortMSB    OF((deflate_state *s, uInt b));\n-local void flush_pending  OF((z_streamp strm));\n-local unsigned read_buf   OF((z_streamp strm, Bytef *buf, unsigned size));\n-local uInt longest_match  OF((deflate_state *s, IPos cur_match));\n-\n-#ifdef ZLIB_DEBUG\n-local  void check_match OF((deflate_state *s, IPos start, IPos match,\n-                            int length));\n+local block_state deflate_slow(deflate_state *s, int flush);\n@@ -120,0 +102,2 @@\n+local block_state deflate_rle(deflate_state *s, int flush);\n+local block_state deflate_huff(deflate_state *s, int flush);\n@@ -222,3 +206,6 @@\n-local void slide_hash(s)\n-    deflate_state *s;\n-{\n+#if defined(__has_feature)\n+#  if __has_feature(memory_sanitizer)\n+     __attribute__((no_sanitize(\"memory\")))\n+#  endif\n+#endif\n+local void slide_hash(deflate_state *s) {\n@@ -248,0 +235,159 @@\n+\/* ===========================================================================\n+ * Read a new buffer from the current input stream, update the adler32\n+ * and total number of bytes read.  All deflate() input goes through\n+ * this function so some applications may wish to modify it to avoid\n+ * allocating a large strm->next_in buffer and copying from it.\n+ * (See also flush_pending()).\n+ *\/\n+local unsigned read_buf(z_streamp strm, Bytef *buf, unsigned size) {\n+    unsigned len = strm->avail_in;\n+\n+    if (len > size) len = size;\n+    if (len == 0) return 0;\n+\n+    strm->avail_in  -= len;\n+\n+    zmemcpy(buf, strm->next_in, len);\n+    if (strm->state->wrap == 1) {\n+        strm->adler = adler32(strm->adler, buf, len);\n+    }\n+#ifdef GZIP\n+    else if (strm->state->wrap == 2) {\n+        strm->adler = crc32(strm->adler, buf, len);\n+    }\n+#endif\n+    strm->next_in  += len;\n+    strm->total_in += len;\n+\n+    return len;\n+}\n+\n+\/* ===========================================================================\n+ * Fill the window when the lookahead becomes insufficient.\n+ * Updates strstart and lookahead.\n+ *\n+ * IN assertion: lookahead < MIN_LOOKAHEAD\n+ * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n+ *    At least one byte has been read, or avail_in == 0; reads are\n+ *    performed for at least two bytes (required for the zip translate_eol\n+ *    option -- not supported here).\n+ *\/\n+local void fill_window(deflate_state *s) {\n+    unsigned n;\n+    unsigned more;    \/* Amount of free space at the end of the window. *\/\n+    uInt wsize = s->w_size;\n+\n+    Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n+\n+    do {\n+        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);\n+\n+        \/* Deal with !@#$% 64K limit: *\/\n+        if (sizeof(int) <= 2) {\n+            if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n+                more = wsize;\n+\n+            } else if (more == (unsigned)(-1)) {\n+                \/* Very unlikely, but possible on 16 bit machine if\n+                 * strstart == 0 && lookahead == 1 (input done a byte at time)\n+                 *\/\n+                more--;\n+            }\n+        }\n+\n+        \/* If the window is almost full and there is insufficient lookahead,\n+         * move the upper half to the lower one to make room in the upper half.\n+         *\/\n+        if (s->strstart >= wsize + MAX_DIST(s)) {\n+\n+            zmemcpy(s->window, s->window + wsize, (unsigned)wsize - more);\n+            s->match_start -= wsize;\n+            s->strstart    -= wsize; \/* we now have strstart >= MAX_DIST *\/\n+            s->block_start -= (long) wsize;\n+            if (s->insert > s->strstart)\n+                s->insert = s->strstart;\n+            slide_hash(s);\n+            more += wsize;\n+        }\n+        if (s->strm->avail_in == 0) break;\n+\n+        \/* If there was no sliding:\n+         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n+         *    more == window_size - lookahead - strstart\n+         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n+         * => more >= window_size - 2*WSIZE + 2\n+         * In the BIG_MEM or MMAP case (not yet supported),\n+         *   window_size == input_size + MIN_LOOKAHEAD  &&\n+         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n+         * Otherwise, window_size == 2*WSIZE so more >= 2.\n+         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n+         *\/\n+        Assert(more >= 2, \"more < 2\");\n+\n+        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);\n+        s->lookahead += n;\n+\n+        \/* Initialize the hash value now that we have some input: *\/\n+        if (s->lookahead + s->insert >= MIN_MATCH) {\n+            uInt str = s->strstart - s->insert;\n+            s->ins_h = s->window[str];\n+            UPDATE_HASH(s, s->ins_h, s->window[str + 1]);\n+#if MIN_MATCH != 3\n+            Call UPDATE_HASH() MIN_MATCH-3 more times\n+#endif\n+            while (s->insert) {\n+                UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);\n+#ifndef FASTEST\n+                s->prev[str & s->w_mask] = s->head[s->ins_h];\n+#endif\n+                s->head[s->ins_h] = (Pos)str;\n+                str++;\n+                s->insert--;\n+                if (s->lookahead + s->insert < MIN_MATCH)\n+                    break;\n+            }\n+        }\n+        \/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n+         * but this is not important since only literal bytes will be emitted.\n+         *\/\n+\n+    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);\n+\n+    \/* If the WIN_INIT bytes after the end of the current data have never been\n+     * written, then zero those bytes in order to avoid memory check reports of\n+     * the use of uninitialized (or uninitialised as Julian writes) bytes by\n+     * the longest match routines.  Update the high water mark for the next\n+     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n+     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n+     *\/\n+    if (s->high_water < s->window_size) {\n+        ulg curr = s->strstart + (ulg)(s->lookahead);\n+        ulg init;\n+\n+        if (s->high_water < curr) {\n+            \/* Previous high water mark below current data -- zero WIN_INIT\n+             * bytes or up to end of window, whichever is less.\n+             *\/\n+            init = s->window_size - curr;\n+            if (init > WIN_INIT)\n+                init = WIN_INIT;\n+            zmemzero(s->window + curr, (unsigned)init);\n+            s->high_water = curr + init;\n+        }\n+        else if (s->high_water < (ulg)curr + WIN_INIT) {\n+            \/* High water mark at or above current data, but below current data\n+             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n+             * to end of window, whichever is less.\n+             *\/\n+            init = (ulg)curr + WIN_INIT - s->high_water;\n+            if (init > s->window_size - s->high_water)\n+                init = s->window_size - s->high_water;\n+            zmemzero(s->window + s->high_water, (unsigned)init);\n+            s->high_water += init;\n+        }\n+    }\n+\n+    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n+           \"not enough room for search\");\n+}\n+\n@@ -249,6 +395,2 @@\n-int ZEXPORT deflateInit_(strm, level, version, stream_size)\n-    z_streamp strm;\n-    int level;\n-    const char *version;\n-    int stream_size;\n-{\n+int ZEXPORT deflateInit_(z_streamp strm, int level, const char *version,\n+                         int stream_size) {\n@@ -261,11 +403,3 @@\n-int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,\n-                  version, stream_size)\n-    z_streamp strm;\n-    int  level;\n-    int  method;\n-    int  windowBits;\n-    int  memLevel;\n-    int  strategy;\n-    const char *version;\n-    int stream_size;\n-{\n+int ZEXPORT deflateInit2_(z_streamp strm, int level, int method,\n+                          int windowBits, int memLevel, int strategy,\n+                          const char *version, int stream_size) {\n@@ -386,1 +520,1 @@\n-    s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, 4);\n+    s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, LIT_BUFS);\n@@ -396,0 +530,5 @@\n+#ifdef LIT_MEM\n+    s->d_buf = (ushf *)(s->pending_buf + (s->lit_bufsize << 1));\n+    s->l_buf = s->pending_buf + (s->lit_bufsize << 2);\n+    s->sym_end = s->lit_bufsize - 1;\n+#else\n@@ -398,0 +537,1 @@\n+#endif\n@@ -413,3 +553,1 @@\n-local int deflateStateCheck(strm)\n-    z_streamp strm;\n-{\n+local int deflateStateCheck(z_streamp strm) {\n@@ -436,5 +574,2 @@\n-int ZEXPORT deflateSetDictionary(strm, dictionary, dictLength)\n-    z_streamp strm;\n-    const Bytef *dictionary;\n-    uInt  dictLength;\n-{\n+int ZEXPORT deflateSetDictionary(z_streamp strm, const Bytef *dictionary,\n+                                 uInt  dictLength) {\n@@ -505,5 +640,2 @@\n-int ZEXPORT deflateGetDictionary(strm, dictionary, dictLength)\n-    z_streamp strm;\n-    Bytef *dictionary;\n-    uInt  *dictLength;\n-{\n+int ZEXPORT deflateGetDictionary(z_streamp strm, Bytef *dictionary,\n+                                 uInt *dictLength) {\n@@ -527,3 +659,1 @@\n-int ZEXPORT deflateResetKeep(strm)\n-    z_streamp strm;\n-{\n+int ZEXPORT deflateResetKeep(z_streamp strm) {\n@@ -564,0 +694,24 @@\n+\/* ===========================================================================\n+ * Initialize the \"longest match\" routines for a new zlib stream\n+ *\/\n+local void lm_init(deflate_state *s) {\n+    s->window_size = (ulg)2L*s->w_size;\n+\n+    CLEAR_HASH(s);\n+\n+    \/* Set the default configuration parameters:\n+     *\/\n+    s->max_lazy_match   = configuration_table[s->level].max_lazy;\n+    s->good_match       = configuration_table[s->level].good_length;\n+    s->nice_match       = configuration_table[s->level].nice_length;\n+    s->max_chain_length = configuration_table[s->level].max_chain;\n+\n+    s->strstart = 0;\n+    s->block_start = 0L;\n+    s->lookahead = 0;\n+    s->insert = 0;\n+    s->match_length = s->prev_length = MIN_MATCH-1;\n+    s->match_available = 0;\n+    s->ins_h = 0;\n+}\n+\n@@ -565,3 +719,1 @@\n-int ZEXPORT deflateReset(strm)\n-    z_streamp strm;\n-{\n+int ZEXPORT deflateReset(z_streamp strm) {\n@@ -577,4 +729,1 @@\n-int ZEXPORT deflateSetHeader(strm, head)\n-    z_streamp strm;\n-    gz_headerp head;\n-{\n+int ZEXPORT deflateSetHeader(z_streamp strm, gz_headerp head) {\n@@ -588,5 +737,1 @@\n-int ZEXPORT deflatePending(strm, pending, bits)\n-    unsigned *pending;\n-    int *bits;\n-    z_streamp strm;\n-{\n+int ZEXPORT deflatePending(z_streamp strm, unsigned *pending, int *bits) {\n@@ -602,5 +747,1 @@\n-int ZEXPORT deflatePrime(strm, bits, value)\n-    z_streamp strm;\n-    int bits;\n-    int value;\n-{\n+int ZEXPORT deflatePrime(z_streamp strm, int bits, int value) {\n@@ -612,0 +753,5 @@\n+#ifdef LIT_MEM\n+    if (bits < 0 || bits > 16 ||\n+        (uchf *)s->d_buf < s->pending_out + ((Buf_size + 7) >> 3))\n+        return Z_BUF_ERROR;\n+#else\n@@ -615,0 +761,1 @@\n+#endif\n@@ -629,5 +776,1 @@\n-int ZEXPORT deflateParams(strm, level, strategy)\n-    z_streamp strm;\n-    int level;\n-    int strategy;\n-{\n+int ZEXPORT deflateParams(z_streamp strm, int level, int strategy) {\n@@ -678,7 +821,2 @@\n-int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)\n-    z_streamp strm;\n-    int good_length;\n-    int max_lazy;\n-    int nice_length;\n-    int max_chain;\n-{\n+int ZEXPORT deflateTune(z_streamp strm, int good_length, int max_lazy,\n+                        int nice_length, int max_chain) {\n@@ -720,4 +858,1 @@\n-uLong ZEXPORT deflateBound(strm, sourceLen)\n-    z_streamp strm;\n-    uLong sourceLen;\n-{\n+uLong ZEXPORT deflateBound(z_streamp strm, uLong sourceLen) {\n@@ -779,1 +914,2 @@\n-        return (s->w_bits <= s->hash_bits ? fixedlen : storelen) + wraplen;\n+        return (s->w_bits <= s->hash_bits && s->level ? fixedlen : storelen) +\n+               wraplen;\n@@ -792,4 +928,1 @@\n-local void putShortMSB(s, b)\n-    deflate_state *s;\n-    uInt b;\n-{\n+local void putShortMSB(deflate_state *s, uInt b) {\n@@ -806,3 +939,1 @@\n-local void flush_pending(strm)\n-    z_streamp strm;\n-{\n+local void flush_pending(z_streamp strm) {\n@@ -839,4 +970,1 @@\n-int ZEXPORT deflate(strm, flush)\n-    z_streamp strm;\n-    int flush;\n-{\n+int ZEXPORT deflate(z_streamp strm, int flush) {\n@@ -1154,3 +1282,1 @@\n-int ZEXPORT deflateEnd(strm)\n-    z_streamp strm;\n-{\n+int ZEXPORT deflateEnd(z_streamp strm) {\n@@ -1180,4 +1306,1 @@\n-int ZEXPORT deflateCopy(dest, source)\n-    z_streamp dest;\n-    z_streamp source;\n-{\n+int ZEXPORT deflateCopy(z_streamp dest, z_streamp source) {\n@@ -1185,0 +1308,2 @@\n+    (void)dest;\n+    (void)source;\n@@ -1208,1 +1333,1 @@\n-    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, 4);\n+    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, LIT_BUFS);\n@@ -1219,1 +1344,1 @@\n-    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n+    zmemcpy(ds->pending_buf, ss->pending_buf, ds->lit_bufsize * LIT_BUFS);\n@@ -1222,0 +1347,4 @@\n+#ifdef LIT_MEM\n+    ds->d_buf = (ushf *)(ds->pending_buf + (ds->lit_bufsize << 1));\n+    ds->l_buf = ds->pending_buf + (ds->lit_bufsize << 2);\n+#else\n@@ -1223,0 +1352,1 @@\n+#endif\n@@ -1232,60 +1362,0 @@\n-\/* ===========================================================================\n- * Read a new buffer from the current input stream, update the adler32\n- * and total number of bytes read.  All deflate() input goes through\n- * this function so some applications may wish to modify it to avoid\n- * allocating a large strm->next_in buffer and copying from it.\n- * (See also flush_pending()).\n- *\/\n-local unsigned read_buf(strm, buf, size)\n-    z_streamp strm;\n-    Bytef *buf;\n-    unsigned size;\n-{\n-    unsigned len = strm->avail_in;\n-\n-    if (len > size) len = size;\n-    if (len == 0) return 0;\n-\n-    strm->avail_in  -= len;\n-\n-    zmemcpy(buf, strm->next_in, len);\n-    if (strm->state->wrap == 1) {\n-        strm->adler = adler32(strm->adler, buf, len);\n-    }\n-#ifdef GZIP\n-    else if (strm->state->wrap == 2) {\n-        strm->adler = crc32(strm->adler, buf, len);\n-    }\n-#endif\n-    strm->next_in  += len;\n-    strm->total_in += len;\n-\n-    return len;\n-}\n-\n-\/* ===========================================================================\n- * Initialize the \"longest match\" routines for a new zlib stream\n- *\/\n-local void lm_init(s)\n-    deflate_state *s;\n-{\n-    s->window_size = (ulg)2L*s->w_size;\n-\n-    CLEAR_HASH(s);\n-\n-    \/* Set the default configuration parameters:\n-     *\/\n-    s->max_lazy_match   = configuration_table[s->level].max_lazy;\n-    s->good_match       = configuration_table[s->level].good_length;\n-    s->nice_match       = configuration_table[s->level].nice_length;\n-    s->max_chain_length = configuration_table[s->level].max_chain;\n-\n-    s->strstart = 0;\n-    s->block_start = 0L;\n-    s->lookahead = 0;\n-    s->insert = 0;\n-    s->match_length = s->prev_length = MIN_MATCH-1;\n-    s->match_available = 0;\n-    s->ins_h = 0;\n-}\n-\n@@ -1302,4 +1372,1 @@\n-local uInt longest_match(s, cur_match)\n-    deflate_state *s;\n-    IPos cur_match;                             \/* current match *\/\n-{\n+local uInt longest_match(deflate_state *s, IPos cur_match) {\n@@ -1453,4 +1520,1 @@\n-local uInt longest_match(s, cur_match)\n-    deflate_state *s;\n-    IPos cur_match;                             \/* current match *\/\n-{\n+local uInt longest_match(deflate_state *s, IPos cur_match) {\n@@ -1517,5 +1581,1 @@\n-local void check_match(s, start, match, length)\n-    deflate_state *s;\n-    IPos start, match;\n-    int length;\n-{\n+local void check_match(deflate_state *s, IPos start, IPos match, int length) {\n@@ -1523,4 +1583,12 @@\n-    if (zmemcmp(s->window + match,\n-                s->window + start, length) != EQUAL) {\n-        fprintf(stderr, \" start %u, match %u, length %d\\n\",\n-                start, match, length);\n+    Bytef *back = s->window + (int)match, *here = s->window + start;\n+    IPos len = length;\n+    if (match == (IPos)-1) {\n+        \/* match starts one byte before the current window -- just compare the\n+           subsequent length-1 bytes *\/\n+        back++;\n+        here++;\n+        len--;\n+    }\n+    if (zmemcmp(back, here, len) != EQUAL) {\n+        fprintf(stderr, \" start %u, match %d, length %d\\n\",\n+                start, (int)match, length);\n@@ -1528,2 +1596,2 @@\n-            fprintf(stderr, \"%c%c\", s->window[match++], s->window[start++]);\n-        } while (--length != 0);\n+            fprintf(stderr, \"(%02x %02x)\", *back++, *here++);\n+        } while (--len != 0);\n@@ -1541,131 +1609,0 @@\n-\/* ===========================================================================\n- * Fill the window when the lookahead becomes insufficient.\n- * Updates strstart and lookahead.\n- *\n- * IN assertion: lookahead < MIN_LOOKAHEAD\n- * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n- *    At least one byte has been read, or avail_in == 0; reads are\n- *    performed for at least two bytes (required for the zip translate_eol\n- *    option -- not supported here).\n- *\/\n-local void fill_window(s)\n-    deflate_state *s;\n-{\n-    unsigned n;\n-    unsigned more;    \/* Amount of free space at the end of the window. *\/\n-    uInt wsize = s->w_size;\n-\n-    Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n-\n-    do {\n-        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);\n-\n-        \/* Deal with !@#$% 64K limit: *\/\n-        if (sizeof(int) <= 2) {\n-            if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n-                more = wsize;\n-\n-            } else if (more == (unsigned)(-1)) {\n-                \/* Very unlikely, but possible on 16 bit machine if\n-                 * strstart == 0 && lookahead == 1 (input done a byte at time)\n-                 *\/\n-                more--;\n-            }\n-        }\n-\n-        \/* If the window is almost full and there is insufficient lookahead,\n-         * move the upper half to the lower one to make room in the upper half.\n-         *\/\n-        if (s->strstart >= wsize + MAX_DIST(s)) {\n-\n-            zmemcpy(s->window, s->window + wsize, (unsigned)wsize - more);\n-            s->match_start -= wsize;\n-            s->strstart    -= wsize; \/* we now have strstart >= MAX_DIST *\/\n-            s->block_start -= (long) wsize;\n-            if (s->insert > s->strstart)\n-                s->insert = s->strstart;\n-            slide_hash(s);\n-            more += wsize;\n-        }\n-        if (s->strm->avail_in == 0) break;\n-\n-        \/* If there was no sliding:\n-         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n-         *    more == window_size - lookahead - strstart\n-         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n-         * => more >= window_size - 2*WSIZE + 2\n-         * In the BIG_MEM or MMAP case (not yet supported),\n-         *   window_size == input_size + MIN_LOOKAHEAD  &&\n-         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n-         * Otherwise, window_size == 2*WSIZE so more >= 2.\n-         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n-         *\/\n-        Assert(more >= 2, \"more < 2\");\n-\n-        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);\n-        s->lookahead += n;\n-\n-        \/* Initialize the hash value now that we have some input: *\/\n-        if (s->lookahead + s->insert >= MIN_MATCH) {\n-            uInt str = s->strstart - s->insert;\n-            s->ins_h = s->window[str];\n-            UPDATE_HASH(s, s->ins_h, s->window[str + 1]);\n-#if MIN_MATCH != 3\n-            Call UPDATE_HASH() MIN_MATCH-3 more times\n-#endif\n-            while (s->insert) {\n-                UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);\n-#ifndef FASTEST\n-                s->prev[str & s->w_mask] = s->head[s->ins_h];\n-#endif\n-                s->head[s->ins_h] = (Pos)str;\n-                str++;\n-                s->insert--;\n-                if (s->lookahead + s->insert < MIN_MATCH)\n-                    break;\n-            }\n-        }\n-        \/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n-         * but this is not important since only literal bytes will be emitted.\n-         *\/\n-\n-    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);\n-\n-    \/* If the WIN_INIT bytes after the end of the current data have never been\n-     * written, then zero those bytes in order to avoid memory check reports of\n-     * the use of uninitialized (or uninitialised as Julian writes) bytes by\n-     * the longest match routines.  Update the high water mark for the next\n-     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n-     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n-     *\/\n-    if (s->high_water < s->window_size) {\n-        ulg curr = s->strstart + (ulg)(s->lookahead);\n-        ulg init;\n-\n-        if (s->high_water < curr) {\n-            \/* Previous high water mark below current data -- zero WIN_INIT\n-             * bytes or up to end of window, whichever is less.\n-             *\/\n-            init = s->window_size - curr;\n-            if (init > WIN_INIT)\n-                init = WIN_INIT;\n-            zmemzero(s->window + curr, (unsigned)init);\n-            s->high_water = curr + init;\n-        }\n-        else if (s->high_water < (ulg)curr + WIN_INIT) {\n-            \/* High water mark at or above current data, but below current data\n-             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n-             * to end of window, whichever is less.\n-             *\/\n-            init = (ulg)curr + WIN_INIT - s->high_water;\n-            if (init > s->window_size - s->high_water)\n-                init = s->window_size - s->high_water;\n-            zmemzero(s->window + s->high_water, (unsigned)init);\n-            s->high_water += init;\n-        }\n-    }\n-\n-    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n-           \"not enough room for search\");\n-}\n-\n@@ -1714,4 +1651,1 @@\n-local block_state deflate_stored(s, flush)\n-    deflate_state *s;\n-    int flush;\n-{\n+local block_state deflate_stored(deflate_state *s, int flush) {\n@@ -1901,4 +1835,1 @@\n-local block_state deflate_fast(s, flush)\n-    deflate_state *s;\n-    int flush;\n-{\n+local block_state deflate_fast(deflate_state *s, int flush) {\n@@ -2003,4 +1934,1 @@\n-local block_state deflate_slow(s, flush)\n-    deflate_state *s;\n-    int flush;\n-{\n+local block_state deflate_slow(deflate_state *s, int flush) {\n@@ -2134,4 +2062,1 @@\n-local block_state deflate_rle(s, flush)\n-    deflate_state *s;\n-    int flush;\n-{\n+local block_state deflate_rle(deflate_state *s, int flush) {\n@@ -2208,4 +2133,1 @@\n-local block_state deflate_huff(s, flush)\n-    deflate_state *s;\n-    int flush;\n-{\n+local block_state deflate_huff(deflate_state *s, int flush) {\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/deflate.c","additions":267,"deletions":345,"binary":false,"changes":612,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2018 Jean-loup Gailly\n+ * Copyright (C) 1995-2024 Jean-loup Gailly\n@@ -50,0 +50,4 @@\n+\/* define LIT_MEM to slightly increase the speed of deflate (order 1% to 2%) at\n+   the cost of a larger memory footprint *\/\n+\/* #define LIT_MEM *\/\n+\n@@ -244,0 +248,6 @@\n+#ifdef LIT_MEM\n+#   define LIT_BUFS 5\n+    ushf *d_buf;          \/* buffer for distances *\/\n+    uchf *l_buf;          \/* buffer for literals\/lengths *\/\n+#else\n+#   define LIT_BUFS 4\n@@ -245,0 +255,1 @@\n+#endif\n@@ -266,1 +277,1 @@\n-    uInt sym_next;      \/* running index in sym_buf *\/\n+    uInt sym_next;      \/* running index in symbol buffer *\/\n@@ -318,8 +329,8 @@\n-void ZLIB_INTERNAL _tr_init OF((deflate_state *s));\n-int ZLIB_INTERNAL _tr_tally OF((deflate_state *s, unsigned dist, unsigned lc));\n-void ZLIB_INTERNAL _tr_flush_block OF((deflate_state *s, charf *buf,\n-                        ulg stored_len, int last));\n-void ZLIB_INTERNAL _tr_flush_bits OF((deflate_state *s));\n-void ZLIB_INTERNAL _tr_align OF((deflate_state *s));\n-void ZLIB_INTERNAL _tr_stored_block OF((deflate_state *s, charf *buf,\n-                        ulg stored_len, int last));\n+void ZLIB_INTERNAL _tr_init(deflate_state *s);\n+int ZLIB_INTERNAL _tr_tally(deflate_state *s, unsigned dist, unsigned lc);\n+void ZLIB_INTERNAL _tr_flush_block(deflate_state *s, charf *buf,\n+                                   ulg stored_len, int last);\n+void ZLIB_INTERNAL _tr_flush_bits(deflate_state *s);\n+void ZLIB_INTERNAL _tr_align(deflate_state *s);\n+void ZLIB_INTERNAL _tr_stored_block(deflate_state *s, charf *buf,\n+                                    ulg stored_len, int last);\n@@ -345,0 +356,19 @@\n+#ifdef LIT_MEM\n+# define _tr_tally_lit(s, c, flush) \\\n+  { uch cc = (c); \\\n+    s->d_buf[s->sym_next] = 0; \\\n+    s->l_buf[s->sym_next++] = cc; \\\n+    s->dyn_ltree[cc].Freq++; \\\n+    flush = (s->sym_next == s->sym_end); \\\n+   }\n+# define _tr_tally_dist(s, distance, length, flush) \\\n+  { uch len = (uch)(length); \\\n+    ush dist = (ush)(distance); \\\n+    s->d_buf[s->sym_next] = dist; \\\n+    s->l_buf[s->sym_next++] = len; \\\n+    dist--; \\\n+    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \\\n+    s->dyn_dtree[d_code(dist)].Freq++; \\\n+    flush = (s->sym_next == s->sym_end); \\\n+  }\n+#else\n@@ -364,0 +394,1 @@\n+#endif\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/deflate.h","additions":41,"deletions":10,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -35,3 +35,1 @@\n-int ZEXPORT gzclose(file)\n-    gzFile file;\n-{\n+int ZEXPORT gzclose(gzFile file) {\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/gzclose.c","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 2004-2019 Mark Adler\n+ * Copyright (C) 2004-2024 Mark Adler\n@@ -34,3 +34,2 @@\n-#  ifdef _FILE_OFFSET_BITS\n-#    undef _FILE_OFFSET_BITS\n-#  endif\n+#  undef _FILE_OFFSET_BITS\n+#  undef _TIME_BITS\n@@ -146,2 +145,2 @@\n-  extern voidp  malloc OF((uInt size));\n-  extern void   free   OF((voidpf ptr));\n+  extern voidp  malloc(uInt size);\n+  extern void   free(voidpf ptr);\n@@ -165,4 +164,4 @@\n-    ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));\n-    ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));\n-    ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));\n-    ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));\n+    ZEXTERN gzFile ZEXPORT gzopen64(const char *, const char *);\n+    ZEXTERN z_off64_t ZEXPORT gzseek64(gzFile, z_off64_t, int);\n+    ZEXTERN z_off64_t ZEXPORT gztell64(gzFile);\n+    ZEXTERN z_off64_t ZEXPORT gzoffset64(gzFile);\n@@ -230,1 +229,1 @@\n-void ZLIB_INTERNAL gz_error OF((gz_statep, int, const char *));\n+void ZLIB_INTERNAL gz_error(gz_statep, int, const char *);\n@@ -232,1 +231,1 @@\n-char ZLIB_INTERNAL *gz_strwinerror OF((DWORD error));\n+char ZLIB_INTERNAL *gz_strwinerror(DWORD error);\n@@ -238,6 +237,2 @@\n-#ifdef INT_MAX\n-#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > INT_MAX)\n-#else\n-unsigned ZLIB_INTERNAL gz_intmax OF((void));\n-#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > gz_intmax())\n-#endif\n+unsigned ZLIB_INTERNAL gz_intmax(void);\n+#define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > gz_intmax())\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/gzguts.h","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 2004-2019 Mark Adler\n+ * Copyright (C) 2004-2024 Mark Adler\n@@ -42,4 +42,0 @@\n-\/* Local functions *\/\n-local void gz_reset OF((gz_statep));\n-local gzFile gz_open OF((const void *, int, const char *));\n-\n@@ -57,3 +53,1 @@\n-char ZLIB_INTERNAL *gz_strwinerror(error)\n-     DWORD error;\n-{\n+char ZLIB_INTERNAL *gz_strwinerror(DWORD error) {\n@@ -99,3 +93,1 @@\n-local void gz_reset(state)\n-    gz_statep state;\n-{\n+local void gz_reset(gz_statep state) {\n@@ -117,5 +109,1 @@\n-local gzFile gz_open(path, fd, mode)\n-    const void *path;\n-    int fd;\n-    const char *mode;\n-{\n+local gzFile gz_open(const void *path, int fd, const char *mode) {\n@@ -296,4 +284,1 @@\n-gzFile ZEXPORT gzopen(path, mode)\n-    const char *path;\n-    const char *mode;\n-{\n+gzFile ZEXPORT gzopen(const char *path, const char *mode) {\n@@ -304,4 +289,1 @@\n-gzFile ZEXPORT gzopen64(path, mode)\n-    const char *path;\n-    const char *mode;\n-{\n+gzFile ZEXPORT gzopen64(const char *path, const char *mode) {\n@@ -312,4 +294,1 @@\n-gzFile ZEXPORT gzdopen(fd, mode)\n-    int fd;\n-    const char *mode;\n-{\n+gzFile ZEXPORT gzdopen(int fd, const char *mode) {\n@@ -333,4 +312,1 @@\n-gzFile ZEXPORT gzopen_w(path, mode)\n-    const wchar_t *path;\n-    const char *mode;\n-{\n+gzFile ZEXPORT gzopen_w(const wchar_t *path, const char *mode) {\n@@ -342,4 +318,1 @@\n-int ZEXPORT gzbuffer(file, size)\n-    gzFile file;\n-    unsigned size;\n-{\n+int ZEXPORT gzbuffer(gzFile file, unsigned size) {\n@@ -362,2 +335,2 @@\n-    if (size < 2)\n-        size = 2;               \/* need two bytes to check magic header *\/\n+    if (size < 8)\n+        size = 8;               \/* needed to behave well with flushing *\/\n@@ -369,3 +342,1 @@\n-int ZEXPORT gzrewind(file)\n-    gzFile file;\n-{\n+int ZEXPORT gzrewind(gzFile file) {\n@@ -392,5 +363,1 @@\n-z_off64_t ZEXPORT gzseek64(file, offset, whence)\n-    gzFile file;\n-    z_off64_t offset;\n-    int whence;\n-{\n+z_off64_t ZEXPORT gzseek64(gzFile file, z_off64_t offset, int whence) {\n@@ -469,5 +436,1 @@\n-z_off_t ZEXPORT gzseek(file, offset, whence)\n-    gzFile file;\n-    z_off_t offset;\n-    int whence;\n-{\n+z_off_t ZEXPORT gzseek(gzFile file, z_off_t offset, int whence) {\n@@ -481,3 +444,1 @@\n-z_off64_t ZEXPORT gztell64(file)\n-    gzFile file;\n-{\n+z_off64_t ZEXPORT gztell64(gzFile file) {\n@@ -498,3 +459,1 @@\n-z_off_t ZEXPORT gztell(file)\n-    gzFile file;\n-{\n+z_off_t ZEXPORT gztell(gzFile file) {\n@@ -508,3 +467,1 @@\n-z_off64_t ZEXPORT gzoffset64(file)\n-    gzFile file;\n-{\n+z_off64_t ZEXPORT gzoffset64(gzFile file) {\n@@ -531,3 +488,1 @@\n-z_off_t ZEXPORT gzoffset(file)\n-    gzFile file;\n-{\n+z_off_t ZEXPORT gzoffset(gzFile file) {\n@@ -541,3 +496,1 @@\n-int ZEXPORT gzeof(file)\n-    gzFile file;\n-{\n+int ZEXPORT gzeof(gzFile file) {\n@@ -558,4 +511,1 @@\n-const char * ZEXPORT gzerror(file, errnum)\n-    gzFile file;\n-    int *errnum;\n-{\n+const char * ZEXPORT gzerror(gzFile file, int *errnum) {\n@@ -579,3 +529,1 @@\n-void ZEXPORT gzclearerr(file)\n-    gzFile file;\n-{\n+void ZEXPORT gzclearerr(gzFile file) {\n@@ -605,5 +553,1 @@\n-void ZLIB_INTERNAL gz_error(state, err, msg)\n-    gz_statep state;\n-    int err;\n-    const char *msg;\n-{\n+void ZLIB_INTERNAL gz_error(gz_statep state, int err, const char *msg) {\n@@ -646,1 +590,0 @@\n-#ifndef INT_MAX\n@@ -651,5 +594,5 @@\n-unsigned ZLIB_INTERNAL gz_intmax()\n-{\n-    unsigned p, q;\n-\n-    p = 1;\n+unsigned ZLIB_INTERNAL gz_intmax(void) {\n+#ifdef INT_MAX\n+    return INT_MAX;\n+#else\n+    unsigned p = 1, q;\n@@ -662,1 +605,0 @@\n-}\n@@ -664,0 +606,1 @@\n+}\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/gzlib.c","additions":28,"deletions":85,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -32,9 +32,0 @@\n-\/* Local functions *\/\n-local int gz_load OF((gz_statep, unsigned char *, unsigned, unsigned *));\n-local int gz_avail OF((gz_statep));\n-local int gz_look OF((gz_statep));\n-local int gz_decomp OF((gz_statep));\n-local int gz_fetch OF((gz_statep));\n-local int gz_skip OF((gz_statep, z_off64_t));\n-local z_size_t gz_read OF((gz_statep, voidp, z_size_t));\n-\n@@ -45,6 +36,2 @@\n-local int gz_load(state, buf, len, have)\n-    gz_statep state;\n-    unsigned char *buf;\n-    unsigned len;\n-    unsigned *have;\n-{\n+local int gz_load(gz_statep state, unsigned char *buf, unsigned len,\n+                  unsigned *have) {\n@@ -80,3 +67,1 @@\n-local int gz_avail(state)\n-    gz_statep state;\n-{\n+local int gz_avail(gz_statep state) {\n@@ -115,3 +100,1 @@\n-local int gz_look(state)\n-    gz_statep state;\n-{\n+local int gz_look(gz_statep state) {\n@@ -197,3 +180,1 @@\n-local int gz_decomp(state)\n-    gz_statep state;\n-{\n+local int gz_decomp(gz_statep state) {\n@@ -251,3 +232,1 @@\n-local int gz_fetch(state)\n-    gz_statep state;\n-{\n+local int gz_fetch(gz_statep state) {\n@@ -281,4 +260,1 @@\n-local int gz_skip(state, len)\n-    gz_statep state;\n-    z_off64_t len;\n-{\n+local int gz_skip(gz_statep state, z_off64_t len) {\n@@ -316,5 +292,1 @@\n-local z_size_t gz_read(state, buf, len)\n-    gz_statep state;\n-    voidp buf;\n-    z_size_t len;\n-{\n+local z_size_t gz_read(gz_statep state, voidp buf, z_size_t len) {\n@@ -397,5 +369,1 @@\n-int ZEXPORT gzread(file, buf, len)\n-    gzFile file;\n-    voidp buf;\n-    unsigned len;\n-{\n+int ZEXPORT gzread(gzFile file, voidp buf, unsigned len) {\n@@ -433,6 +401,1 @@\n-z_size_t ZEXPORT gzfread(buf, size, nitems, file)\n-    voidp buf;\n-    z_size_t size;\n-    z_size_t nitems;\n-    gzFile file;\n-{\n+z_size_t ZEXPORT gzfread(voidp buf, z_size_t size, z_size_t nitems, gzFile file) {\n@@ -469,3 +432,1 @@\n-int ZEXPORT gzgetc(file)\n-    gzFile file;\n-{\n+int ZEXPORT gzgetc(gzFile file) {\n@@ -496,3 +457,1 @@\n-int ZEXPORT gzgetc_(file)\n-gzFile file;\n-{\n+int ZEXPORT gzgetc_(gzFile file) {\n@@ -503,4 +462,1 @@\n-int ZEXPORT gzungetc(c, file)\n-    int c;\n-    gzFile file;\n-{\n+int ZEXPORT gzungetc(int c, gzFile file) {\n@@ -514,0 +470,4 @@\n+    \/* in case this was just opened, set up the input buffer *\/\n+    if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)\n+        (void)gz_look(state);\n+\n@@ -563,5 +523,1 @@\n-char * ZEXPORT gzgets(file, buf, len)\n-    gzFile file;\n-    char *buf;\n-    int len;\n-{\n+char * ZEXPORT gzgets(gzFile file, char *buf, int len) {\n@@ -627,3 +583,1 @@\n-int ZEXPORT gzdirect(file)\n-    gzFile file;\n-{\n+int ZEXPORT gzdirect(gzFile file) {\n@@ -647,3 +601,1 @@\n-int ZEXPORT gzclose_r(file)\n-    gzFile file;\n-{\n+int ZEXPORT gzclose_r(gzFile file) {\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/gzread.c","additions":20,"deletions":68,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -32,6 +32,0 @@\n-\/* Local functions *\/\n-local int gz_init OF((gz_statep));\n-local int gz_comp OF((gz_statep, int));\n-local int gz_zero OF((gz_statep, z_off64_t));\n-local z_size_t gz_write OF((gz_statep, voidpc, z_size_t));\n-\n@@ -41,3 +35,1 @@\n-local int gz_init(state)\n-    gz_statep state;\n-{\n+local int gz_init(gz_statep state) {\n@@ -97,4 +89,1 @@\n-local int gz_comp(state, flush)\n-    gz_statep state;\n-    int flush;\n-{\n+local int gz_comp(gz_statep state, int flush) {\n@@ -178,4 +167,1 @@\n-local int gz_zero(state, len)\n-    gz_statep state;\n-    z_off64_t len;\n-{\n+local int gz_zero(gz_statep state, z_off64_t len) {\n@@ -211,5 +197,1 @@\n-local z_size_t gz_write(state, buf, len)\n-    gz_statep state;\n-    voidpc buf;\n-    z_size_t len;\n-{\n+local z_size_t gz_write(gz_statep state, voidpc buf, z_size_t len) {\n@@ -279,5 +261,1 @@\n-int ZEXPORT gzwrite(file, buf, len)\n-    gzFile file;\n-    voidpc buf;\n-    unsigned len;\n-{\n+int ZEXPORT gzwrite(gzFile file, voidpc buf, unsigned len) {\n@@ -307,6 +285,2 @@\n-z_size_t ZEXPORT gzfwrite(buf, size, nitems, file)\n-    voidpc buf;\n-    z_size_t size;\n-    z_size_t nitems;\n-    gzFile file;\n-{\n+z_size_t ZEXPORT gzfwrite(voidpc buf, z_size_t size, z_size_t nitems,\n+                          gzFile file) {\n@@ -337,4 +311,1 @@\n-int ZEXPORT gzputc(file, c)\n-    gzFile file;\n-    int c;\n-{\n+int ZEXPORT gzputc(gzFile file, int c) {\n@@ -385,4 +356,1 @@\n-int ZEXPORT gzputs(file, s)\n-    gzFile file;\n-    const char *s;\n-{\n+int ZEXPORT gzputs(gzFile file, const char *s) {\n@@ -415,2 +383,1 @@\n-int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)\n-{\n+int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va) {\n@@ -487,2 +454,1 @@\n-int ZEXPORTVA gzprintf(gzFile file, const char *format, ...)\n-{\n+int ZEXPORTVA gzprintf(gzFile file, const char *format, ...) {\n@@ -501,7 +467,4 @@\n-int ZEXPORTVA gzprintf(file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,\n-                       a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)\n-    gzFile file;\n-    const char *format;\n-    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,\n-        a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;\n-{\n+int ZEXPORTVA gzprintf(gzFile file, const char *format, int a1, int a2, int a3,\n+                       int a4, int a5, int a6, int a7, int a8, int a9, int a10,\n+                       int a11, int a12, int a13, int a14, int a15, int a16,\n+                       int a17, int a18, int a19, int a20) {\n@@ -589,4 +552,1 @@\n-int ZEXPORT gzflush(file, flush)\n-    gzFile file;\n-    int flush;\n-{\n+int ZEXPORT gzflush(gzFile file, int flush) {\n@@ -621,5 +581,1 @@\n-int ZEXPORT gzsetparams(file, level, strategy)\n-    gzFile file;\n-    int level;\n-    int strategy;\n-{\n+int ZEXPORT gzsetparams(gzFile file, int level, int strategy) {\n@@ -636,1 +592,1 @@\n-    if (state->mode != GZ_WRITE || state->err != Z_OK)\n+    if (state->mode != GZ_WRITE || state->err != Z_OK || state->direct)\n@@ -663,3 +619,1 @@\n-int ZEXPORT gzclose_w(file)\n-    gzFile file;\n-{\n+int ZEXPORT gzclose_w(gzFile file) {\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/gzwrite.c","additions":19,"deletions":65,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -42,3 +42,0 @@\n-\/* function prototypes *\/\n-local void fixedtables OF((struct inflate_state FAR *state));\n-\n@@ -52,7 +49,3 @@\n-int ZEXPORT inflateBackInit_(strm, windowBits, window, version, stream_size)\n-z_streamp strm;\n-int windowBits;\n-unsigned char FAR *window;\n-const char *version;\n-int stream_size;\n-{\n+int ZEXPORT inflateBackInit_(z_streamp strm, int windowBits,\n+                             unsigned char FAR *window, const char *version,\n+                             int stream_size) {\n@@ -107,3 +100,1 @@\n-local void fixedtables(state)\n-struct inflate_state FAR *state;\n-{\n+local void fixedtables(struct inflate_state FAR *state) {\n@@ -275,7 +266,2 @@\n-int ZEXPORT inflateBack(strm, in, in_desc, out, out_desc)\n-z_streamp strm;\n-in_func in;\n-void FAR *in_desc;\n-out_func out;\n-void FAR *out_desc;\n-{\n+int ZEXPORT inflateBack(z_streamp strm, in_func in, void FAR *in_desc,\n+                        out_func out, void FAR *out_desc) {\n@@ -659,3 +645,1 @@\n-int ZEXPORT inflateBackEnd(strm)\n-z_streamp strm;\n-{\n+int ZEXPORT inflateBackEnd(z_streamp strm) {\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/infback.c","additions":7,"deletions":23,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -74,4 +74,1 @@\n-void ZLIB_INTERNAL inflate_fast(strm, start)\n-z_streamp strm;\n-unsigned start;         \/* inflate()'s starting value for strm->avail_out *\/\n-{\n+void ZLIB_INTERNAL inflate_fast(z_streamp strm, unsigned start) {\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/inffast.c","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-void ZLIB_INTERNAL inflate_fast OF((z_streamp strm, unsigned start));\n+void ZLIB_INTERNAL inflate_fast(z_streamp strm, unsigned start);\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/inffast.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,14 +118,1 @@\n-\/* function prototypes *\/\n-local int inflateStateCheck OF((z_streamp strm));\n-local void fixedtables OF((struct inflate_state FAR *state));\n-local int updatewindow OF((z_streamp strm, const unsigned char FAR *end,\n-                           unsigned copy));\n-#ifdef BUILDFIXED\n-   void makefixed OF((void));\n-#endif\n-local unsigned syncsearch OF((unsigned FAR *have, const unsigned char FAR *buf,\n-                              unsigned len));\n-\n-local int inflateStateCheck(strm)\n-z_streamp strm;\n-{\n+local int inflateStateCheck(z_streamp strm) {\n@@ -143,3 +130,1 @@\n-int ZEXPORT inflateResetKeep(strm)\n-z_streamp strm;\n-{\n+int ZEXPORT inflateResetKeep(z_streamp strm) {\n@@ -169,3 +154,1 @@\n-int ZEXPORT inflateReset(strm)\n-z_streamp strm;\n-{\n+int ZEXPORT inflateReset(z_streamp strm) {\n@@ -182,4 +165,1 @@\n-int ZEXPORT inflateReset2(strm, windowBits)\n-z_streamp strm;\n-int windowBits;\n-{\n+int ZEXPORT inflateReset2(z_streamp strm, int windowBits) {\n@@ -222,6 +202,2 @@\n-int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)\n-z_streamp strm;\n-int windowBits;\n-const char *version;\n-int stream_size;\n-{\n+int ZEXPORT inflateInit2_(z_streamp strm, int windowBits,\n+                          const char *version, int stream_size) {\n@@ -266,5 +242,2 @@\n-int ZEXPORT inflateInit_(strm, version, stream_size)\n-z_streamp strm;\n-const char *version;\n-int stream_size;\n-{\n+int ZEXPORT inflateInit_(z_streamp strm, const char *version,\n+                         int stream_size) {\n@@ -274,5 +247,1 @@\n-int ZEXPORT inflatePrime(strm, bits, value)\n-z_streamp strm;\n-int bits;\n-int value;\n-{\n+int ZEXPORT inflatePrime(z_streamp strm, int bits, int value) {\n@@ -282,0 +251,2 @@\n+    if (bits == 0)\n+        return Z_OK;\n@@ -305,3 +276,1 @@\n-local void fixedtables(state)\n-struct inflate_state FAR *state;\n-{\n+local void fixedtables(struct inflate_state FAR *state) {\n@@ -369,1 +338,1 @@\n-void makefixed()\n+void makefixed(void)\n@@ -423,5 +392,1 @@\n-local int updatewindow(strm, end, copy)\n-z_streamp strm;\n-const Bytef *end;\n-unsigned copy;\n-{\n+local int updatewindow(z_streamp strm, const Bytef *end, unsigned copy) {\n@@ -649,4 +614,1 @@\n-int ZEXPORT inflate(strm, flush)\n-z_streamp strm;\n-int flush;\n-{\n+int ZEXPORT inflate(z_streamp strm, int flush) {\n@@ -1328,3 +1290,1 @@\n-int ZEXPORT inflateEnd(strm)\n-z_streamp strm;\n-{\n+int ZEXPORT inflateEnd(z_streamp strm) {\n@@ -1342,5 +1302,2 @@\n-int ZEXPORT inflateGetDictionary(strm, dictionary, dictLength)\n-z_streamp strm;\n-Bytef *dictionary;\n-uInt *dictLength;\n-{\n+int ZEXPORT inflateGetDictionary(z_streamp strm, Bytef *dictionary,\n+                                 uInt *dictLength) {\n@@ -1365,5 +1322,2 @@\n-int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)\n-z_streamp strm;\n-const Bytef *dictionary;\n-uInt dictLength;\n-{\n+int ZEXPORT inflateSetDictionary(z_streamp strm, const Bytef *dictionary,\n+                                 uInt dictLength) {\n@@ -1400,4 +1354,1 @@\n-int ZEXPORT inflateGetHeader(strm, head)\n-z_streamp strm;\n-gz_headerp head;\n-{\n+int ZEXPORT inflateGetHeader(z_streamp strm, gz_headerp head) {\n@@ -1428,5 +1379,2 @@\n-local unsigned syncsearch(have, buf, len)\n-unsigned FAR *have;\n-const unsigned char FAR *buf;\n-unsigned len;\n-{\n+local unsigned syncsearch(unsigned FAR *have, const unsigned char FAR *buf,\n+                          unsigned len) {\n@@ -1451,3 +1399,1 @@\n-int ZEXPORT inflateSync(strm)\n-z_streamp strm;\n-{\n+int ZEXPORT inflateSync(z_streamp strm) {\n@@ -1468,1 +1414,1 @@\n-        state->hold <<= state->bits & 7;\n+        state->hold >>= state->bits & 7;\n@@ -1509,3 +1455,1 @@\n-int ZEXPORT inflateSyncPoint(strm)\n-z_streamp strm;\n-{\n+int ZEXPORT inflateSyncPoint(z_streamp strm) {\n@@ -1519,4 +1463,1 @@\n-int ZEXPORT inflateCopy(dest, source)\n-z_streamp dest;\n-z_streamp source;\n-{\n+int ZEXPORT inflateCopy(z_streamp dest, z_streamp source) {\n@@ -1566,4 +1507,1 @@\n-int ZEXPORT inflateUndermine(strm, subvert)\n-z_streamp strm;\n-int subvert;\n-{\n+int ZEXPORT inflateUndermine(z_streamp strm, int subvert) {\n@@ -1584,4 +1522,1 @@\n-int ZEXPORT inflateValidate(strm, check)\n-z_streamp strm;\n-int check;\n-{\n+int ZEXPORT inflateValidate(z_streamp strm, int check) {\n@@ -1599,3 +1534,1 @@\n-long ZEXPORT inflateMark(strm)\n-z_streamp strm;\n-{\n+long ZEXPORT inflateMark(z_streamp strm) {\n@@ -1612,3 +1545,1 @@\n-unsigned long ZEXPORT inflateCodesUsed(strm)\n-z_streamp strm;\n-{\n+unsigned long ZEXPORT inflateCodesUsed(z_streamp strm) {\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/inflate.c","additions":31,"deletions":100,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2022 Mark Adler\n+ * Copyright (C) 1995-2024 Mark Adler\n@@ -36,1 +36,1 @@\n-   \" inflate 1.2.13 Copyright 1995-2022 Mark Adler \";\n+   \" inflate 1.3.1 Copyright 1995-2024 Mark Adler \";\n@@ -56,8 +56,3 @@\n-int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)\n-codetype type;\n-unsigned short FAR *lens;\n-unsigned codes;\n-code FAR * FAR *table;\n-unsigned FAR *bits;\n-unsigned short FAR *work;\n-{\n+int ZLIB_INTERNAL inflate_table(codetype type, unsigned short FAR *lens,\n+                                unsigned codes, code FAR * FAR *table,\n+                                unsigned FAR *bits, unsigned short FAR *work) {\n@@ -89,1 +84,1 @@\n-        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 194, 65};\n+        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 203, 77};\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/inftrees.c","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -68,2 +68,2 @@\n-   returns returns 852, and \"enough 30 6 15\" for distance codes returns 592.\n-   The initial root table size (9 or 6) is found in the fifth argument of the\n+   returns 852, and \"enough 30 6 15\" for distance codes returns 592. The\n+   initial root table size (9 or 6) is found in the fifth argument of the\n@@ -84,3 +84,3 @@\n-int ZLIB_INTERNAL inflate_table OF((codetype type, unsigned short FAR *lens,\n-                             unsigned codes, code FAR * FAR *table,\n-                             unsigned FAR *bits, unsigned short FAR *work));\n+int ZLIB_INTERNAL inflate_table(codetype type, unsigned short FAR *lens,\n+                                unsigned codes, code FAR * FAR *table,\n+                                unsigned FAR *bits, unsigned short FAR *work);\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/inftrees.h","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-Changes from zlib 1.2.13\n+Changes from zlib 1.3.1\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/patches\/ChangeLog_java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2021 Jean-loup Gailly\n+ * Copyright (C) 1995-2024 Jean-loup Gailly\n@@ -149,1 +149,7 @@\n-local const static_tree_desc  static_l_desc =\n+#ifdef NO_INIT_GLOBAL_POINTERS\n+#  define TCONST\n+#else\n+#  define TCONST const\n+#endif\n+\n+local TCONST static_tree_desc static_l_desc =\n@@ -152,1 +158,1 @@\n-local const static_tree_desc  static_d_desc =\n+local TCONST static_tree_desc static_d_desc =\n@@ -155,1 +161,1 @@\n-local const static_tree_desc  static_bl_desc =\n+local TCONST static_tree_desc static_bl_desc =\n@@ -159,1 +165,12 @@\n- * Local (static) routines in this file.\n+ * Output a short LSB first on the stream.\n+ * IN assertion: there is enough room in pendingBuf.\n+ *\/\n+#define put_short(s, w) { \\\n+    put_byte(s, (uch)((w) & 0xff)); \\\n+    put_byte(s, (uch)((ush)(w) >> 8)); \\\n+}\n+\n+\/* ===========================================================================\n+ * Reverse the first len bits of a code, using straightforward code (a faster\n+ * method would use a table)\n+ * IN assertion: 1 <= len <= 15\n@@ -161,0 +178,8 @@\n+local unsigned bi_reverse(unsigned code, int len) {\n+    register unsigned res = 0;\n+    do {\n+        res |= code & 1;\n+        code >>= 1, res <<= 1;\n+    } while (--len > 0);\n+    return res >> 1;\n+}\n@@ -162,17 +187,69 @@\n-local void tr_static_init OF((void));\n-local void init_block     OF((deflate_state *s));\n-local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));\n-local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));\n-local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));\n-local void build_tree     OF((deflate_state *s, tree_desc *desc));\n-local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));\n-local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));\n-local int  build_bl_tree  OF((deflate_state *s));\n-local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,\n-                              int blcodes));\n-local void compress_block OF((deflate_state *s, const ct_data *ltree,\n-                              const ct_data *dtree));\n-local int  detect_data_type OF((deflate_state *s));\n-local unsigned bi_reverse OF((unsigned code, int len));\n-local void bi_windup      OF((deflate_state *s));\n-local void bi_flush       OF((deflate_state *s));\n+\/* ===========================================================================\n+ * Flush the bit buffer, keeping at most 7 bits in it.\n+ *\/\n+local void bi_flush(deflate_state *s) {\n+    if (s->bi_valid == 16) {\n+        put_short(s, s->bi_buf);\n+        s->bi_buf = 0;\n+        s->bi_valid = 0;\n+    } else if (s->bi_valid >= 8) {\n+        put_byte(s, (Byte)s->bi_buf);\n+        s->bi_buf >>= 8;\n+        s->bi_valid -= 8;\n+    }\n+}\n+\n+\/* ===========================================================================\n+ * Flush the bit buffer and align the output on a byte boundary\n+ *\/\n+local void bi_windup(deflate_state *s) {\n+    if (s->bi_valid > 8) {\n+        put_short(s, s->bi_buf);\n+    } else if (s->bi_valid > 0) {\n+        put_byte(s, (Byte)s->bi_buf);\n+    }\n+    s->bi_buf = 0;\n+    s->bi_valid = 0;\n+#ifdef ZLIB_DEBUG\n+    s->bits_sent = (s->bits_sent + 7) & ~7;\n+#endif\n+}\n+\n+\/* ===========================================================================\n+ * Generate the codes for a given tree and bit counts (which need not be\n+ * optimal).\n+ * IN assertion: the array bl_count contains the bit length statistics for\n+ * the given tree and the field len is set for all tree elements.\n+ * OUT assertion: the field code is set for all tree elements of non\n+ *     zero code length.\n+ *\/\n+local void gen_codes(ct_data *tree, int max_code, ushf *bl_count) {\n+    ush next_code[MAX_BITS+1]; \/* next code value for each bit length *\/\n+    unsigned code = 0;         \/* running code value *\/\n+    int bits;                  \/* bit index *\/\n+    int n;                     \/* code index *\/\n+\n+    \/* The distribution counts are first used to generate the code values\n+     * without bit reversal.\n+     *\/\n+    for (bits = 1; bits <= MAX_BITS; bits++) {\n+        code = (code + bl_count[bits - 1]) << 1;\n+        next_code[bits] = (ush)code;\n+    }\n+    \/* Check that the bit counts in bl_count are consistent. The last code\n+     * must be all ones.\n+     *\/\n+    Assert (code + bl_count[MAX_BITS] - 1 == (1 << MAX_BITS) - 1,\n+            \"inconsistent bit counts\");\n+    Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n+\n+    for (n = 0;  n <= max_code; n++) {\n+        int len = tree[n].Len;\n+        if (len == 0) continue;\n+        \/* Now reverse the bits *\/\n+        tree[n].Code = (ush)bi_reverse(next_code[len]++, len);\n+\n+        Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n+            n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len] - 1));\n+    }\n+}\n@@ -181,1 +258,1 @@\n-local void gen_trees_header OF((void));\n+local void gen_trees_header(void);\n@@ -194,9 +271,0 @@\n-\/* ===========================================================================\n- * Output a short LSB first on the stream.\n- * IN assertion: there is enough room in pendingBuf.\n- *\/\n-#define put_short(s, w) { \\\n-    put_byte(s, (uch)((w) & 0xff)); \\\n-    put_byte(s, (uch)((ush)(w) >> 8)); \\\n-}\n-\n@@ -208,7 +276,1 @@\n-local void send_bits      OF((deflate_state *s, int value, int length));\n-\n-local void send_bits(s, value, length)\n-    deflate_state *s;\n-    int value;  \/* value to send *\/\n-    int length; \/* number of bits *\/\n-{\n+local void send_bits(deflate_state *s, int value, int length) {\n@@ -256,2 +318,1 @@\n-local void tr_static_init()\n-{\n+local void tr_static_init(void) {\n@@ -350,2 +411,1 @@\n-void gen_trees_header()\n-{\n+void gen_trees_header(void) {\n@@ -400,0 +460,16 @@\n+\/* ===========================================================================\n+ * Initialize a new block.\n+ *\/\n+local void init_block(deflate_state *s) {\n+    int n; \/* iterates over tree elements *\/\n+\n+    \/* Initialize the trees. *\/\n+    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;\n+    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;\n+    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;\n+\n+    s->dyn_ltree[END_BLOCK].Freq = 1;\n+    s->opt_len = s->static_len = 0L;\n+    s->sym_next = s->matches = 0;\n+}\n+\n@@ -403,3 +479,1 @@\n-void ZLIB_INTERNAL _tr_init(s)\n-    deflate_state *s;\n-{\n+void ZLIB_INTERNAL _tr_init(deflate_state *s) {\n@@ -428,18 +502,0 @@\n-\/* ===========================================================================\n- * Initialize a new block.\n- *\/\n-local void init_block(s)\n-    deflate_state *s;\n-{\n-    int n; \/* iterates over tree elements *\/\n-\n-    \/* Initialize the trees. *\/\n-    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;\n-    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;\n-    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;\n-\n-    s->dyn_ltree[END_BLOCK].Freq = 1;\n-    s->opt_len = s->static_len = 0L;\n-    s->sym_next = s->matches = 0;\n-}\n-\n@@ -475,5 +531,1 @@\n-local void pqdownheap(s, tree, k)\n-    deflate_state *s;\n-    ct_data *tree;  \/* the tree to restore *\/\n-    int k;               \/* node to move down *\/\n-{\n+local void pqdownheap(deflate_state *s, ct_data *tree, int k) {\n@@ -510,4 +562,1 @@\n-local void gen_bitlen(s, desc)\n-    deflate_state *s;\n-    tree_desc *desc;    \/* the tree descriptor *\/\n-{\n+local void gen_bitlen(deflate_state *s, tree_desc *desc) {\n@@ -588,42 +637,3 @@\n-\/* ===========================================================================\n- * Generate the codes for a given tree and bit counts (which need not be\n- * optimal).\n- * IN assertion: the array bl_count contains the bit length statistics for\n- * the given tree and the field len is set for all tree elements.\n- * OUT assertion: the field code is set for all tree elements of non\n- *     zero code length.\n- *\/\n-local void gen_codes(tree, max_code, bl_count)\n-    ct_data *tree;             \/* the tree to decorate *\/\n-    int max_code;              \/* largest code with non zero frequency *\/\n-    ushf *bl_count;            \/* number of codes at each bit length *\/\n-{\n-    ush next_code[MAX_BITS+1]; \/* next code value for each bit length *\/\n-    unsigned code = 0;         \/* running code value *\/\n-    int bits;                  \/* bit index *\/\n-    int n;                     \/* code index *\/\n-\n-    \/* The distribution counts are first used to generate the code values\n-     * without bit reversal.\n-     *\/\n-    for (bits = 1; bits <= MAX_BITS; bits++) {\n-        code = (code + bl_count[bits - 1]) << 1;\n-        next_code[bits] = (ush)code;\n-    }\n-    \/* Check that the bit counts in bl_count are consistent. The last code\n-     * must be all ones.\n-     *\/\n-    Assert (code + bl_count[MAX_BITS] - 1 == (1 << MAX_BITS) - 1,\n-            \"inconsistent bit counts\");\n-    Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n-\n-    for (n = 0;  n <= max_code; n++) {\n-        int len = tree[n].Len;\n-        if (len == 0) continue;\n-        \/* Now reverse the bits *\/\n-        tree[n].Code = (ush)bi_reverse(next_code[len]++, len);\n-\n-        Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n-            n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len] - 1));\n-    }\n-}\n+#ifdef DUMP_BL_TREE\n+#  include <stdio.h>\n+#endif\n@@ -639,4 +649,1 @@\n-local void build_tree(s, desc)\n-    deflate_state *s;\n-    tree_desc *desc; \/* the tree descriptor *\/\n-{\n+local void build_tree(deflate_state *s, tree_desc *desc) {\n@@ -727,5 +734,1 @@\n-local void scan_tree(s, tree, max_code)\n-    deflate_state *s;\n-    ct_data *tree;   \/* the tree to be scanned *\/\n-    int max_code;    \/* and its largest code of non zero frequency *\/\n-{\n+local void scan_tree(deflate_state *s, ct_data *tree, int max_code) {\n@@ -772,5 +775,1 @@\n-local void send_tree(s, tree, max_code)\n-    deflate_state *s;\n-    ct_data *tree; \/* the tree to be scanned *\/\n-    int max_code;       \/* and its largest code of non zero frequency *\/\n-{\n+local void send_tree(deflate_state *s, ct_data *tree, int max_code) {\n@@ -823,3 +822,1 @@\n-local int build_bl_tree(s)\n-    deflate_state *s;\n-{\n+local int build_bl_tree(deflate_state *s) {\n@@ -858,4 +855,2 @@\n-local void send_all_trees(s, lcodes, dcodes, blcodes)\n-    deflate_state *s;\n-    int lcodes, dcodes, blcodes; \/* number of codes for each tree *\/\n-{\n+local void send_all_trees(deflate_state *s, int lcodes, int dcodes,\n+                          int blcodes) {\n@@ -887,6 +882,2 @@\n-void ZLIB_INTERNAL _tr_stored_block(s, buf, stored_len, last)\n-    deflate_state *s;\n-    charf *buf;       \/* input block *\/\n-    ulg stored_len;   \/* length of input block *\/\n-    int last;         \/* one if this is the last block for a file *\/\n-{\n+void ZLIB_INTERNAL _tr_stored_block(deflate_state *s, charf *buf,\n+                                    ulg stored_len, int last) {\n@@ -911,3 +902,1 @@\n-void ZLIB_INTERNAL _tr_flush_bits(s)\n-    deflate_state *s;\n-{\n+void ZLIB_INTERNAL _tr_flush_bits(deflate_state *s) {\n@@ -921,3 +910,1 @@\n-void ZLIB_INTERNAL _tr_align(s)\n-    deflate_state *s;\n-{\n+void ZLIB_INTERNAL _tr_align(deflate_state *s) {\n@@ -932,0 +919,96 @@\n+\/* ===========================================================================\n+ * Send the block data compressed using the given Huffman trees\n+ *\/\n+local void compress_block(deflate_state *s, const ct_data *ltree,\n+                          const ct_data *dtree) {\n+    unsigned dist;      \/* distance of matched string *\/\n+    int lc;             \/* match length or unmatched char (if dist == 0) *\/\n+    unsigned sx = 0;    \/* running index in symbol buffers *\/\n+    unsigned code;      \/* the code to send *\/\n+    int extra;          \/* number of extra bits to send *\/\n+\n+    if (s->sym_next != 0) do {\n+#ifdef LIT_MEM\n+        dist = s->d_buf[sx];\n+        lc = s->l_buf[sx++];\n+#else\n+        dist = s->sym_buf[sx++] & 0xff;\n+        dist += (unsigned)(s->sym_buf[sx++] & 0xff) << 8;\n+        lc = s->sym_buf[sx++];\n+#endif\n+        if (dist == 0) {\n+            send_code(s, lc, ltree); \/* send a literal byte *\/\n+            Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n+        } else {\n+            \/* Here, lc is the match length - MIN_MATCH *\/\n+            code = _length_code[lc];\n+            send_code(s, code + LITERALS + 1, ltree);   \/* send length code *\/\n+            extra = extra_lbits[code];\n+            if (extra != 0) {\n+                lc -= base_length[code];\n+                send_bits(s, lc, extra);       \/* send the extra length bits *\/\n+            }\n+            dist--; \/* dist is now the match distance - 1 *\/\n+            code = d_code(dist);\n+            Assert (code < D_CODES, \"bad d_code\");\n+\n+            send_code(s, code, dtree);       \/* send the distance code *\/\n+            extra = extra_dbits[code];\n+            if (extra != 0) {\n+                dist -= (unsigned)base_dist[code];\n+                send_bits(s, dist, extra);   \/* send the extra distance bits *\/\n+            }\n+        } \/* literal or match pair ? *\/\n+\n+        \/* Check for no overlay of pending_buf on needed symbols *\/\n+#ifdef LIT_MEM\n+        Assert(s->pending < 2 * (s->lit_bufsize + sx), \"pendingBuf overflow\");\n+#else\n+        Assert(s->pending < s->lit_bufsize + sx, \"pendingBuf overflow\");\n+#endif\n+\n+    } while (sx < s->sym_next);\n+\n+    send_code(s, END_BLOCK, ltree);\n+}\n+\n+\/* ===========================================================================\n+ * Check if the data type is TEXT or BINARY, using the following algorithm:\n+ * - TEXT if the two conditions below are satisfied:\n+ *    a) There are no non-portable control characters belonging to the\n+ *       \"block list\" (0..6, 14..25, 28..31).\n+ *    b) There is at least one printable character belonging to the\n+ *       \"allow list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n+ * - BINARY otherwise.\n+ * - The following partially-portable control characters form a\n+ *   \"gray list\" that is ignored in this detection algorithm:\n+ *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n+ * IN assertion: the fields Freq of dyn_ltree are set.\n+ *\/\n+local int detect_data_type(deflate_state *s) {\n+    \/* block_mask is the bit mask of block-listed bytes\n+     * set bits 0..6, 14..25, and 28..31\n+     * 0xf3ffc07f = binary 11110011111111111100000001111111\n+     *\/\n+    unsigned long block_mask = 0xf3ffc07fUL;\n+    int n;\n+\n+    \/* Check for non-textual (\"block-listed\") bytes. *\/\n+    for (n = 0; n <= 31; n++, block_mask >>= 1)\n+        if ((block_mask & 1) && (s->dyn_ltree[n].Freq != 0))\n+            return Z_BINARY;\n+\n+    \/* Check for textual (\"allow-listed\") bytes. *\/\n+    if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0\n+            || s->dyn_ltree[13].Freq != 0)\n+        return Z_TEXT;\n+    for (n = 32; n < LITERALS; n++)\n+        if (s->dyn_ltree[n].Freq != 0)\n+            return Z_TEXT;\n+\n+    \/* There are no \"block-listed\" or \"allow-listed\" bytes:\n+     * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n+     *\/\n+    return Z_BINARY;\n+}\n+\n@@ -936,6 +1019,2 @@\n-void ZLIB_INTERNAL _tr_flush_block(s, buf, stored_len, last)\n-    deflate_state *s;\n-    charf *buf;       \/* input block, or NULL if too old *\/\n-    ulg stored_len;   \/* length of input block *\/\n-    int last;         \/* one if this is the last block for a file *\/\n-{\n+void ZLIB_INTERNAL _tr_flush_block(deflate_state *s, charf *buf,\n+                                   ulg stored_len, int last) {\n@@ -1038,5 +1117,5 @@\n-int ZLIB_INTERNAL _tr_tally(s, dist, lc)\n-    deflate_state *s;\n-    unsigned dist;  \/* distance of matched string *\/\n-    unsigned lc;    \/* match length - MIN_MATCH or unmatched char (dist==0) *\/\n-{\n+int ZLIB_INTERNAL _tr_tally(deflate_state *s, unsigned dist, unsigned lc) {\n+#ifdef LIT_MEM\n+    s->d_buf[s->sym_next] = (ush)dist;\n+    s->l_buf[s->sym_next++] = (uch)lc;\n+#else\n@@ -1046,0 +1125,1 @@\n+#endif\n@@ -1062,144 +1142,0 @@\n-\n-\/* ===========================================================================\n- * Send the block data compressed using the given Huffman trees\n- *\/\n-local void compress_block(s, ltree, dtree)\n-    deflate_state *s;\n-    const ct_data *ltree; \/* literal tree *\/\n-    const ct_data *dtree; \/* distance tree *\/\n-{\n-    unsigned dist;      \/* distance of matched string *\/\n-    int lc;             \/* match length or unmatched char (if dist == 0) *\/\n-    unsigned sx = 0;    \/* running index in sym_buf *\/\n-    unsigned code;      \/* the code to send *\/\n-    int extra;          \/* number of extra bits to send *\/\n-\n-    if (s->sym_next != 0) do {\n-        dist = s->sym_buf[sx++] & 0xff;\n-        dist += (unsigned)(s->sym_buf[sx++] & 0xff) << 8;\n-        lc = s->sym_buf[sx++];\n-        if (dist == 0) {\n-            send_code(s, lc, ltree); \/* send a literal byte *\/\n-            Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n-        } else {\n-            \/* Here, lc is the match length - MIN_MATCH *\/\n-            code = _length_code[lc];\n-            send_code(s, code + LITERALS + 1, ltree);   \/* send length code *\/\n-            extra = extra_lbits[code];\n-            if (extra != 0) {\n-                lc -= base_length[code];\n-                send_bits(s, lc, extra);       \/* send the extra length bits *\/\n-            }\n-            dist--; \/* dist is now the match distance - 1 *\/\n-            code = d_code(dist);\n-            Assert (code < D_CODES, \"bad d_code\");\n-\n-            send_code(s, code, dtree);       \/* send the distance code *\/\n-            extra = extra_dbits[code];\n-            if (extra != 0) {\n-                dist -= (unsigned)base_dist[code];\n-                send_bits(s, dist, extra);   \/* send the extra distance bits *\/\n-            }\n-        } \/* literal or match pair ? *\/\n-\n-        \/* Check that the overlay between pending_buf and sym_buf is ok: *\/\n-        Assert(s->pending < s->lit_bufsize + sx, \"pendingBuf overflow\");\n-\n-    } while (sx < s->sym_next);\n-\n-    send_code(s, END_BLOCK, ltree);\n-}\n-\n-\/* ===========================================================================\n- * Check if the data type is TEXT or BINARY, using the following algorithm:\n- * - TEXT if the two conditions below are satisfied:\n- *    a) There are no non-portable control characters belonging to the\n- *       \"block list\" (0..6, 14..25, 28..31).\n- *    b) There is at least one printable character belonging to the\n- *       \"allow list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n- * - BINARY otherwise.\n- * - The following partially-portable control characters form a\n- *   \"gray list\" that is ignored in this detection algorithm:\n- *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n- * IN assertion: the fields Freq of dyn_ltree are set.\n- *\/\n-local int detect_data_type(s)\n-    deflate_state *s;\n-{\n-    \/* block_mask is the bit mask of block-listed bytes\n-     * set bits 0..6, 14..25, and 28..31\n-     * 0xf3ffc07f = binary 11110011111111111100000001111111\n-     *\/\n-    unsigned long block_mask = 0xf3ffc07fUL;\n-    int n;\n-\n-    \/* Check for non-textual (\"block-listed\") bytes. *\/\n-    for (n = 0; n <= 31; n++, block_mask >>= 1)\n-        if ((block_mask & 1) && (s->dyn_ltree[n].Freq != 0))\n-            return Z_BINARY;\n-\n-    \/* Check for textual (\"allow-listed\") bytes. *\/\n-    if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0\n-            || s->dyn_ltree[13].Freq != 0)\n-        return Z_TEXT;\n-    for (n = 32; n < LITERALS; n++)\n-        if (s->dyn_ltree[n].Freq != 0)\n-            return Z_TEXT;\n-\n-    \/* There are no \"block-listed\" or \"allow-listed\" bytes:\n-     * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n-     *\/\n-    return Z_BINARY;\n-}\n-\n-\/* ===========================================================================\n- * Reverse the first len bits of a code, using straightforward code (a faster\n- * method would use a table)\n- * IN assertion: 1 <= len <= 15\n- *\/\n-local unsigned bi_reverse(code, len)\n-    unsigned code; \/* the value to invert *\/\n-    int len;       \/* its bit length *\/\n-{\n-    register unsigned res = 0;\n-    do {\n-        res |= code & 1;\n-        code >>= 1, res <<= 1;\n-    } while (--len > 0);\n-    return res >> 1;\n-}\n-\n-\/* ===========================================================================\n- * Flush the bit buffer, keeping at most 7 bits in it.\n- *\/\n-local void bi_flush(s)\n-    deflate_state *s;\n-{\n-    if (s->bi_valid == 16) {\n-        put_short(s, s->bi_buf);\n-        s->bi_buf = 0;\n-        s->bi_valid = 0;\n-    } else if (s->bi_valid >= 8) {\n-        put_byte(s, (Byte)s->bi_buf);\n-        s->bi_buf >>= 8;\n-        s->bi_valid -= 8;\n-    }\n-}\n-\n-\/* ===========================================================================\n- * Flush the bit buffer and align the output on a byte boundary\n- *\/\n-local void bi_windup(s)\n-    deflate_state *s;\n-{\n-    if (s->bi_valid > 8) {\n-        put_short(s, s->bi_buf);\n-    } else if (s->bi_valid > 0) {\n-        put_byte(s, (Byte)s->bi_buf);\n-    }\n-    s->bi_buf = 0;\n-    s->bi_valid = 0;\n-#ifdef ZLIB_DEBUG\n-    s->bits_sent = (s->bits_sent + 7) & ~7;\n-#endif\n-}\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/trees.c","additions":239,"deletions":303,"binary":false,"changes":542,"status":"modified"},{"patch":"@@ -51,6 +51,2 @@\n-int ZEXPORT uncompress2(dest, destLen, source, sourceLen)\n-    Bytef *dest;\n-    uLongf *destLen;\n-    const Bytef *source;\n-    uLong *sourceLen;\n-{\n+int ZEXPORT uncompress2(Bytef *dest, uLongf *destLen, const Bytef *source,\n+                        uLong *sourceLen) {\n@@ -110,6 +106,2 @@\n-int ZEXPORT uncompress(dest, destLen, source, sourceLen)\n-    Bytef *dest;\n-    uLongf *destLen;\n-    const Bytef *source;\n-    uLong sourceLen;\n-{\n+int ZEXPORT uncompress(Bytef *dest, uLongf *destLen, const Bytef *source,\n+                       uLong sourceLen) {\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/uncompr.c","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-local uLong adler32_combine_ OF((uLong adler1, uLong adler2, z_off64_t len2));\n-\n@@ -87,5 +85,1 @@\n-uLong ZEXPORT adler32_z(adler, buf, len)\n-    uLong adler;\n-    const Bytef *buf;\n-    z_size_t len;\n-{\n+uLong ZEXPORT adler32_z(uLong adler, const Bytef *buf, z_size_t len) {\n@@ -158,5 +152,1 @@\n-uLong ZEXPORT adler32(adler, buf, len)\n-    uLong adler;\n-    const Bytef *buf;\n-    uInt len;\n-{\n+uLong ZEXPORT adler32(uLong adler, const Bytef *buf, uInt len) {\n@@ -167,5 +157,1 @@\n-local uLong adler32_combine_(adler1, adler2, len2)\n-    uLong adler1;\n-    uLong adler2;\n-    z_off64_t len2;\n-{\n+local uLong adler32_combine_(uLong adler1, uLong adler2, z_off64_t len2) {\n@@ -196,5 +182,1 @@\n-uLong ZEXPORT adler32_combine(adler1, adler2, len2)\n-    uLong adler1;\n-    uLong adler2;\n-    z_off_t len2;\n-{\n+uLong ZEXPORT adler32_combine(uLong adler1, uLong adler2, z_off_t len2) {\n@@ -204,5 +186,1 @@\n-uLong ZEXPORT adler32_combine64(adler1, adler2, len2)\n-    uLong adler1;\n-    uLong adler2;\n-    z_off64_t len2;\n-{\n+uLong ZEXPORT adler32_combine64(uLong adler1, uLong adler2, z_off64_t len2) {\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/zadler32.c","additions":5,"deletions":27,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler\n+ * Copyright (C) 1995-2024 Jean-loup Gailly, Mark Adler\n@@ -268,1 +268,5 @@\n-   typedef unsigned long z_size_t;\n+#  ifdef _WIN64\n+     typedef unsigned long long z_size_t;\n+#  else\n+     typedef unsigned long z_size_t;\n+#  endif\n@@ -323,8 +327,0 @@\n-#ifndef Z_ARG \/* function prototypes for stdarg *\/\n-#  if defined(STDC) || defined(Z_HAVE_STDARG_H)\n-#    define Z_ARG(args)  args\n-#  else\n-#    define Z_ARG(args)  ()\n-#  endif\n-#endif\n-\n@@ -547,1 +543,1 @@\n-#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)\n+#  if defined(_WIN32) && !defined(__GNUC__)\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/zconf.h","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -130,13 +130,0 @@\n-\/* Local functions. *\/\n-local z_crc_t multmodp OF((z_crc_t a, z_crc_t b));\n-local z_crc_t x2nmodp OF((z_off64_t n, unsigned k));\n-\n-#if defined(W) && (!defined(ARMCRC32) || defined(DYNAMIC_CRC_TABLE))\n-    local z_word_t byte_swap OF((z_word_t word));\n-#endif\n-\n-#if defined(W) && !defined(ARMCRC32)\n-    local z_crc_t crc_word OF((z_word_t data));\n-    local z_word_t crc_word_big OF((z_word_t data));\n-#endif\n-\n@@ -150,3 +137,1 @@\n-local z_word_t byte_swap(word)\n-    z_word_t word;\n-{\n+local z_word_t byte_swap(z_word_t word) {\n@@ -173,0 +158,14 @@\n+#ifdef DYNAMIC_CRC_TABLE\n+\/* =========================================================================\n+ * Table of powers of x for combining CRC-32s, filled in by make_crc_table()\n+ * below.\n+ *\/\n+   local z_crc_t FAR x2n_table[32];\n+#else\n+\/* =========================================================================\n+ * Tables for byte-wise and braided CRC-32 calculations, and a table of powers\n+ * of x for combining CRC-32s, all made by make_crc_table().\n+ *\/\n+#  include \"crc32.h\"\n+#endif\n+\n@@ -176,1 +175,20 @@\n-#ifdef DYNAMIC_CRC_TABLE\n+\/*\n+  Return a(x) multiplied by b(x) modulo p(x), where p(x) is the CRC polynomial,\n+  reflected. For speed, this requires that a not be zero.\n+ *\/\n+local z_crc_t multmodp(z_crc_t a, z_crc_t b) {\n+    z_crc_t m, p;\n+\n+    m = (z_crc_t)1 << 31;\n+    p = 0;\n+    for (;;) {\n+        if (a & m) {\n+            p ^= b;\n+            if ((a & (m - 1)) == 0)\n+                break;\n+        }\n+        m >>= 1;\n+        b = b & 1 ? (b >> 1) ^ POLY : b >> 1;\n+    }\n+    return p;\n+}\n@@ -178,0 +196,22 @@\n+\/*\n+  Return x^(n * 2^k) modulo p(x). Requires that x2n_table[] has been\n+  initialized.\n+ *\/\n+local z_crc_t x2nmodp(z_off64_t n, unsigned k) {\n+    z_crc_t p;\n+\n+    p = (z_crc_t)1 << 31;           \/* x^0 == 1 *\/\n+    while (n) {\n+        if (n & 1)\n+            p = multmodp(x2n_table[k & 31], p);\n+        n >>= 1;\n+        k++;\n+    }\n+    return p;\n+}\n+\n+#ifdef DYNAMIC_CRC_TABLE\n+\/* =========================================================================\n+ * Build the tables for byte-wise and braided CRC-32 calculations, and a table\n+ * of powers of x for combining CRC-32s.\n+ *\/\n@@ -179,2 +219,0 @@\n-local z_crc_t FAR x2n_table[32];\n-local void make_crc_table OF((void));\n@@ -185,1 +223,1 @@\n-   local void braid OF((z_crc_t [][256], z_word_t [][256], int, int));\n+   local void braid(z_crc_t [][256], z_word_t [][256], int, int);\n@@ -188,3 +226,3 @@\n-   local void write_table OF((FILE *, const z_crc_t FAR *, int));\n-   local void write_table32hi OF((FILE *, const z_word_t FAR *, int));\n-   local void write_table64 OF((FILE *, const z_word_t FAR *, int));\n+   local void write_table(FILE *, const z_crc_t FAR *, int);\n+   local void write_table32hi(FILE *, const z_word_t FAR *, int);\n+   local void write_table64(FILE *, const z_word_t FAR *, int);\n@@ -203,1 +241,0 @@\n-local void once OF((once_t *, void (*)(void)));\n@@ -223,4 +260,1 @@\n-local void once(state, init)\n-    once_t *state;\n-    void (*init)(void);\n-{\n+local void once(once_t *state, void (*init)(void)) {\n@@ -249,4 +283,1 @@\n-local int test_and_set OF((int volatile *));\n-local int test_and_set(flag)\n-    int volatile *flag;\n-{\n+local int test_and_set(int volatile *flag) {\n@@ -261,4 +292,1 @@\n-local void once(state, init)\n-    once_t *state;\n-    void (*init)(void);\n-{\n+local void once(once_t *state, void (*init)(void)) {\n@@ -306,2 +334,1 @@\n-local void make_crc_table()\n-{\n+local void make_crc_table(void) {\n@@ -474,5 +501,1 @@\n-local void write_table(out, table, k)\n-    FILE *out;\n-    const z_crc_t FAR *table;\n-    int k;\n-{\n+local void write_table(FILE *out, const z_crc_t FAR *table, int k) {\n@@ -491,5 +514,1 @@\n-local void write_table32hi(out, table, k)\n-FILE *out;\n-const z_word_t FAR *table;\n-int k;\n-{\n+local void write_table32hi(FILE *out, const z_word_t FAR *table, int k) {\n@@ -511,5 +530,1 @@\n-local void write_table64(out, table, k)\n-    FILE *out;\n-    const z_word_t FAR *table;\n-    int k;\n-{\n+local void write_table64(FILE *out, const z_word_t FAR *table, int k) {\n@@ -525,2 +540,1 @@\n-int main()\n-{\n+int main(void) {\n@@ -538,6 +552,1 @@\n-local void braid(ltl, big, n, w)\n-    z_crc_t ltl[][256];\n-    z_word_t big[][256];\n-    int n;\n-    int w;\n-{\n+local void braid(z_crc_t ltl[][256], z_word_t big[][256], int n, int w) {\n@@ -558,6 +567,0 @@\n-#else \/* !DYNAMIC_CRC_TABLE *\/\n-\/* ========================================================================\n- * Tables for byte-wise and braided CRC-32 calculations, and a table of powers\n- * of x for combining CRC-32s, all made by make_crc_table().\n- *\/\n-#include \"crc32.h\"\n@@ -566,49 +569,0 @@\n-\/* ========================================================================\n- * Routines used for CRC calculation. Some are also required for the table\n- * generation above.\n- *\/\n-\n-\/*\n-  Return a(x) multiplied by b(x) modulo p(x), where p(x) is the CRC polynomial,\n-  reflected. For speed, this requires that a not be zero.\n- *\/\n-local z_crc_t multmodp(a, b)\n-    z_crc_t a;\n-    z_crc_t b;\n-{\n-    z_crc_t m, p;\n-\n-    m = (z_crc_t)1 << 31;\n-    p = 0;\n-    for (;;) {\n-        if (a & m) {\n-            p ^= b;\n-            if ((a & (m - 1)) == 0)\n-                break;\n-        }\n-        m >>= 1;\n-        b = b & 1 ? (b >> 1) ^ POLY : b >> 1;\n-    }\n-    return p;\n-}\n-\n-\/*\n-  Return x^(n * 2^k) modulo p(x). Requires that x2n_table[] has been\n-  initialized.\n- *\/\n-local z_crc_t x2nmodp(n, k)\n-    z_off64_t n;\n-    unsigned k;\n-{\n-    z_crc_t p;\n-\n-    p = (z_crc_t)1 << 31;           \/* x^0 == 1 *\/\n-    while (n) {\n-        if (n & 1)\n-            p = multmodp(x2n_table[k & 31], p);\n-        n >>= 1;\n-        k++;\n-    }\n-    return p;\n-}\n-\n@@ -619,2 +573,1 @@\n-const z_crc_t FAR * ZEXPORT get_crc_table()\n-{\n+const z_crc_t FAR * ZEXPORT get_crc_table(void) {\n@@ -646,5 +599,2 @@\n-unsigned long ZEXPORT crc32_z(crc, buf, len)\n-    unsigned long crc;\n-    const unsigned char FAR *buf;\n-    z_size_t len;\n-{\n+unsigned long ZEXPORT crc32_z(unsigned long crc, const unsigned char FAR *buf,\n+                              z_size_t len) {\n@@ -750,3 +700,1 @@\n-local z_crc_t crc_word(data)\n-    z_word_t data;\n-{\n+local z_crc_t crc_word(z_word_t data) {\n@@ -759,3 +707,1 @@\n-local z_word_t crc_word_big(data)\n-    z_word_t data;\n-{\n+local z_word_t crc_word_big(z_word_t data) {\n@@ -772,5 +718,2 @@\n-unsigned long ZEXPORT crc32_z(crc, buf, len)\n-    unsigned long crc;\n-    const unsigned char FAR *buf;\n-    z_size_t len;\n-{\n+unsigned long ZEXPORT crc32_z(unsigned long crc, const unsigned char FAR *buf,\n+                              z_size_t len) {\n@@ -808,2 +751,2 @@\n-           processors can change the endianess at execution time. If the\n-           compiler knows what the endianess will be, it can optimize out the\n+           processors can change the endianness at execution time. If the\n+           compiler knows what the endianness will be, it can optimize out the\n@@ -1096,5 +1039,2 @@\n-unsigned long ZEXPORT crc32(crc, buf, len)\n-    unsigned long crc;\n-    const unsigned char FAR *buf;\n-    uInt len;\n-{\n+unsigned long ZEXPORT crc32(unsigned long crc, const unsigned char FAR *buf,\n+                            uInt len) {\n@@ -1105,5 +1045,1 @@\n-uLong ZEXPORT crc32_combine64(crc1, crc2, len2)\n-    uLong crc1;\n-    uLong crc2;\n-    z_off64_t len2;\n-{\n+uLong ZEXPORT crc32_combine64(uLong crc1, uLong crc2, z_off64_t len2) {\n@@ -1117,5 +1053,1 @@\n-uLong ZEXPORT crc32_combine(crc1, crc2, len2)\n-    uLong crc1;\n-    uLong crc2;\n-    z_off_t len2;\n-{\n+uLong ZEXPORT crc32_combine(uLong crc1, uLong crc2, z_off_t len2) {\n@@ -1126,3 +1058,1 @@\n-uLong ZEXPORT crc32_combine_gen64(len2)\n-    z_off64_t len2;\n-{\n+uLong ZEXPORT crc32_combine_gen64(z_off64_t len2) {\n@@ -1136,3 +1066,1 @@\n-uLong ZEXPORT crc32_combine_gen(len2)\n-    z_off_t len2;\n-{\n+uLong ZEXPORT crc32_combine_gen(z_off_t len2) {\n@@ -1143,5 +1071,1 @@\n-uLong ZEXPORT crc32_combine_op(crc1, crc2, op)\n-    uLong crc1;\n-    uLong crc2;\n-    uLong op;\n-{\n+uLong ZEXPORT crc32_combine_op(uLong crc1, uLong crc2, uLong op) {\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/zcrc32.c","additions":86,"deletions":162,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-  version 1.2.13, October 13th, 2022\n+  version 1.3.1, January 22nd, 2024\n@@ -28,1 +28,1 @@\n-  Copyright (C) 1995-2022 Jean-loup Gailly and Mark Adler\n+  Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n@@ -64,2 +64,2 @@\n-#define ZLIB_VERSION \"1.2.13\"\n-#define ZLIB_VERNUM 0x12d0\n+#define ZLIB_VERSION \"1.3.1\"\n+#define ZLIB_VERNUM 0x1310\n@@ -67,2 +67,2 @@\n-#define ZLIB_VER_MINOR 2\n-#define ZLIB_VER_REVISION 13\n+#define ZLIB_VER_MINOR 3\n+#define ZLIB_VER_REVISION 1\n@@ -105,2 +105,2 @@\n-typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));\n-typedef void   (*free_func)  OF((voidpf opaque, voidpf address));\n+typedef voidpf (*alloc_func)(voidpf opaque, uInt items, uInt size);\n+typedef void   (*free_func)(voidpf opaque, voidpf address);\n@@ -244,1 +244,1 @@\n-ZEXTERN const char * ZEXPORT zlibVersion OF((void));\n+ZEXTERN const char * ZEXPORT zlibVersion(void);\n@@ -252,1 +252,1 @@\n-ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));\n+ZEXTERN int ZEXPORT deflateInit(z_streamp strm, int level);\n@@ -257,1 +257,1 @@\n-   allocation functions.\n+   allocation functions.  total_in, total_out, adler, and msg are initialized.\n@@ -274,1 +274,1 @@\n-ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));\n+ZEXTERN int ZEXPORT deflate(z_streamp strm, int flush);\n@@ -347,2 +347,2 @@\n-  avail_out is greater than six to avoid repeated flush markers due to\n-  avail_out == 0 on return.\n+  avail_out is greater than six when the flush marker begins, in order to avoid\n+  repeated flush markers upon calling deflate() again when avail_out == 0.\n@@ -387,1 +387,1 @@\n-ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));\n+ZEXTERN int ZEXPORT deflateEnd(z_streamp strm);\n@@ -402,1 +402,1 @@\n-ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));\n+ZEXTERN int ZEXPORT inflateInit(z_streamp strm);\n@@ -410,1 +410,2 @@\n-   them to use default allocation functions.\n+   them to use default allocation functions.  total_in, total_out, adler, and\n+   msg are initialized.\n@@ -424,1 +425,1 @@\n-ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));\n+ZEXTERN int ZEXPORT inflate(z_streamp strm, int flush);\n@@ -544,1 +545,1 @@\n-ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));\n+ZEXTERN int ZEXPORT inflateEnd(z_streamp strm);\n@@ -562,6 +563,6 @@\n-ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,\n-                                     int  level,\n-                                     int  method,\n-                                     int  windowBits,\n-                                     int  memLevel,\n-                                     int  strategy));\n+ZEXTERN int ZEXPORT deflateInit2(z_streamp strm,\n+                                 int level,\n+                                 int method,\n+                                 int windowBits,\n+                                 int memLevel,\n+                                 int strategy);\n@@ -634,3 +635,3 @@\n-ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,\n-                                             const Bytef *dictionary,\n-                                             uInt  dictLength));\n+ZEXTERN int ZEXPORT deflateSetDictionary(z_streamp strm,\n+                                         const Bytef *dictionary,\n+                                         uInt  dictLength);\n@@ -678,3 +679,3 @@\n-ZEXTERN int ZEXPORT deflateGetDictionary OF((z_streamp strm,\n-                                             Bytef *dictionary,\n-                                             uInt  *dictLength));\n+ZEXTERN int ZEXPORT deflateGetDictionary(z_streamp strm,\n+                                         Bytef *dictionary,\n+                                         uInt  *dictLength);\n@@ -700,2 +701,2 @@\n-ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,\n-                                    z_streamp source));\n+ZEXTERN int ZEXPORT deflateCopy(z_streamp dest,\n+                                z_streamp source);\n@@ -718,1 +719,1 @@\n-ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));\n+ZEXTERN int ZEXPORT deflateReset(z_streamp strm);\n@@ -723,1 +724,1 @@\n-   set unchanged.\n+   set unchanged.  total_in, total_out, adler, and msg are initialized.\n@@ -729,3 +730,3 @@\n-ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,\n-                                      int level,\n-                                      int strategy));\n+ZEXTERN int ZEXPORT deflateParams(z_streamp strm,\n+                                  int level,\n+                                  int strategy);\n@@ -756,1 +757,1 @@\n-   applied to the the data compressed after deflateParams().\n+   applied to the data compressed after deflateParams().\n@@ -767,5 +768,5 @@\n-ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,\n-                                    int good_length,\n-                                    int max_lazy,\n-                                    int nice_length,\n-                                    int max_chain));\n+ZEXTERN int ZEXPORT deflateTune(z_streamp strm,\n+                                int good_length,\n+                                int max_lazy,\n+                                int nice_length,\n+                                int max_chain);\n@@ -784,2 +785,2 @@\n-ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,\n-                                       uLong sourceLen));\n+ZEXTERN uLong ZEXPORT deflateBound(z_streamp strm,\n+                                   uLong sourceLen);\n@@ -799,3 +800,3 @@\n-ZEXTERN int ZEXPORT deflatePending OF((z_streamp strm,\n-                                       unsigned *pending,\n-                                       int *bits));\n+ZEXTERN int ZEXPORT deflatePending(z_streamp strm,\n+                                   unsigned *pending,\n+                                   int *bits);\n@@ -814,3 +815,3 @@\n-ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,\n-                                     int bits,\n-                                     int value));\n+ZEXTERN int ZEXPORT deflatePrime(z_streamp strm,\n+                                 int bits,\n+                                 int value);\n@@ -831,2 +832,2 @@\n-ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,\n-                                         gz_headerp head));\n+ZEXTERN int ZEXPORT deflateSetHeader(z_streamp strm,\n+                                     gz_headerp head);\n@@ -848,2 +849,3 @@\n-   the time set to zero, and os set to 255, with no extra, name, or comment\n-   fields.  The gzip header is returned to the default state by deflateReset().\n+   the time set to zero, and os set to the current operating system, with no\n+   extra, name, or comment fields.  The gzip header is returned to the default\n+   state by deflateReset().\n@@ -856,2 +858,2 @@\n-ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,\n-                                     int  windowBits));\n+ZEXTERN int ZEXPORT inflateInit2(z_streamp strm,\n+                                 int windowBits);\n@@ -910,3 +912,3 @@\n-ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,\n-                                             const Bytef *dictionary,\n-                                             uInt  dictLength));\n+ZEXTERN int ZEXPORT inflateSetDictionary(z_streamp strm,\n+                                         const Bytef *dictionary,\n+                                         uInt  dictLength);\n@@ -933,3 +935,3 @@\n-ZEXTERN int ZEXPORT inflateGetDictionary OF((z_streamp strm,\n-                                             Bytef *dictionary,\n-                                             uInt  *dictLength));\n+ZEXTERN int ZEXPORT inflateGetDictionary(z_streamp strm,\n+                                         Bytef *dictionary,\n+                                         uInt  *dictLength);\n@@ -948,1 +950,1 @@\n-ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));\n+ZEXTERN int ZEXPORT inflateSync(z_streamp strm);\n@@ -961,4 +963,4 @@\n-   In the success case, the application may save the current current value of\n-   total_in which indicates where valid compressed data was found.  In the\n-   error case, the application may repeatedly call inflateSync, providing more\n-   input each time, until success or end of the input data.\n+   In the success case, the application may save the current value of total_in\n+   which indicates where valid compressed data was found.  In the error case,\n+   the application may repeatedly call inflateSync, providing more input each\n+   time, until success or end of the input data.\n@@ -967,2 +969,2 @@\n-ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,\n-                                    z_streamp source));\n+ZEXTERN int ZEXPORT inflateCopy(z_streamp dest,\n+                                z_streamp source);\n@@ -983,1 +985,1 @@\n-ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));\n+ZEXTERN int ZEXPORT inflateReset(z_streamp strm);\n@@ -988,0 +990,1 @@\n+   total_in, total_out, adler, and msg are initialized.\n@@ -993,2 +996,2 @@\n-ZEXTERN int ZEXPORT inflateReset2 OF((z_streamp strm,\n-                                      int windowBits));\n+ZEXTERN int ZEXPORT inflateReset2(z_streamp strm,\n+                                  int windowBits);\n@@ -1007,3 +1010,3 @@\n-ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,\n-                                     int bits,\n-                                     int value));\n+ZEXTERN int ZEXPORT inflatePrime(z_streamp strm,\n+                                 int bits,\n+                                 int value);\n@@ -1028,1 +1031,1 @@\n-ZEXTERN long ZEXPORT inflateMark OF((z_streamp strm));\n+ZEXTERN long ZEXPORT inflateMark(z_streamp strm);\n@@ -1056,2 +1059,2 @@\n-ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,\n-                                         gz_headerp head));\n+ZEXTERN int ZEXPORT inflateGetHeader(z_streamp strm,\n+                                     gz_headerp head);\n@@ -1097,2 +1100,2 @@\n-ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,\n-                                        unsigned char FAR *window));\n+ZEXTERN int ZEXPORT inflateBackInit(z_streamp strm, int windowBits,\n+                                    unsigned char FAR *window);\n@@ -1118,3 +1121,3 @@\n-typedef unsigned (*in_func) OF((void FAR *,\n-                                z_const unsigned char FAR * FAR *));\n-typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));\n+typedef unsigned (*in_func)(void FAR *,\n+                            z_const unsigned char FAR * FAR *);\n+typedef int (*out_func)(void FAR *, unsigned char FAR *, unsigned);\n@@ -1122,3 +1125,3 @@\n-ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,\n-                                    in_func in, void FAR *in_desc,\n-                                    out_func out, void FAR *out_desc));\n+ZEXTERN int ZEXPORT inflateBack(z_streamp strm,\n+                                in_func in, void FAR *in_desc,\n+                                out_func out, void FAR *out_desc);\n@@ -1192,1 +1195,1 @@\n-ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));\n+ZEXTERN int ZEXPORT inflateBackEnd(z_streamp strm);\n@@ -1200,1 +1203,1 @@\n-ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));\n+ZEXTERN uLong ZEXPORT zlibCompileFlags(void);\n@@ -1253,2 +1256,2 @@\n-ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,\n-                                 const Bytef *source, uLong sourceLen));\n+ZEXTERN int ZEXPORT compress(Bytef *dest,   uLongf *destLen,\n+                             const Bytef *source, uLong sourceLen);\n@@ -1268,3 +1271,3 @@\n-ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,\n-                                  const Bytef *source, uLong sourceLen,\n-                                  int level));\n+ZEXTERN int ZEXPORT compress2(Bytef *dest,   uLongf *destLen,\n+                              const Bytef *source, uLong sourceLen,\n+                              int level);\n@@ -1284,1 +1287,1 @@\n-ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));\n+ZEXTERN uLong ZEXPORT compressBound(uLong sourceLen);\n@@ -1291,2 +1294,2 @@\n-ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,\n-                                   const Bytef *source, uLong sourceLen));\n+ZEXTERN int ZEXPORT uncompress(Bytef *dest,   uLongf *destLen,\n+                               const Bytef *source, uLong sourceLen);\n@@ -1309,2 +1312,2 @@\n-ZEXTERN int ZEXPORT uncompress2 OF((Bytef *dest,   uLongf *destLen,\n-                                    const Bytef *source, uLong *sourceLen));\n+ZEXTERN int ZEXPORT uncompress2(Bytef *dest,   uLongf *destLen,\n+                                const Bytef *source, uLong *sourceLen);\n@@ -1329,1 +1332,1 @@\n-ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));\n+ZEXTERN gzFile ZEXPORT gzopen(const char *path, const char *mode);\n@@ -1366,1 +1369,1 @@\n-ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));\n+ZEXTERN gzFile ZEXPORT gzdopen(int fd, const char *mode);\n@@ -1389,1 +1392,1 @@\n-ZEXTERN int ZEXPORT gzbuffer OF((gzFile file, unsigned size));\n+ZEXTERN int ZEXPORT gzbuffer(gzFile file, unsigned size);\n@@ -1405,1 +1408,1 @@\n-ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));\n+ZEXTERN int ZEXPORT gzsetparams(gzFile file, int level, int strategy);\n@@ -1416,1 +1419,1 @@\n-ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));\n+ZEXTERN int ZEXPORT gzread(gzFile file, voidp buf, unsigned len);\n@@ -1446,2 +1449,2 @@\n-ZEXTERN z_size_t ZEXPORT gzfread OF((voidp buf, z_size_t size, z_size_t nitems,\n-                                     gzFile file));\n+ZEXTERN z_size_t ZEXPORT gzfread(voidp buf, z_size_t size, z_size_t nitems,\n+                                 gzFile file);\n@@ -1472,1 +1475,1 @@\n-ZEXTERN int ZEXPORT gzwrite OF((gzFile file, voidpc buf, unsigned len));\n+ZEXTERN int ZEXPORT gzwrite(gzFile file, voidpc buf, unsigned len);\n@@ -1478,2 +1481,2 @@\n-ZEXTERN z_size_t ZEXPORT gzfwrite OF((voidpc buf, z_size_t size,\n-                                      z_size_t nitems, gzFile file));\n+ZEXTERN z_size_t ZEXPORT gzfwrite(voidpc buf, z_size_t size,\n+                                  z_size_t nitems, gzFile file);\n@@ -1492,1 +1495,1 @@\n-ZEXTERN int ZEXPORTVA gzprintf Z_ARG((gzFile file, const char *format, ...));\n+ZEXTERN int ZEXPORTVA gzprintf(gzFile file, const char *format, ...);\n@@ -1507,1 +1510,1 @@\n-ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));\n+ZEXTERN int ZEXPORT gzputs(gzFile file, const char *s);\n@@ -1515,1 +1518,1 @@\n-ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));\n+ZEXTERN char * ZEXPORT gzgets(gzFile file, char *buf, int len);\n@@ -1529,1 +1532,1 @@\n-ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));\n+ZEXTERN int ZEXPORT gzputc(gzFile file, int c);\n@@ -1535,1 +1538,1 @@\n-ZEXTERN int ZEXPORT gzgetc OF((gzFile file));\n+ZEXTERN int ZEXPORT gzgetc(gzFile file);\n@@ -1544,1 +1547,1 @@\n-ZEXTERN int ZEXPORT gzungetc OF((int c, gzFile file));\n+ZEXTERN int ZEXPORT gzungetc(int c, gzFile file);\n@@ -1556,1 +1559,1 @@\n-ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));\n+ZEXTERN int ZEXPORT gzflush(gzFile file, int flush);\n@@ -1572,2 +1575,2 @@\n-ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,\n-                                   z_off_t offset, int whence));\n+ZEXTERN z_off_t ZEXPORT gzseek(gzFile file,\n+                               z_off_t offset, int whence);\n@@ -1591,1 +1594,1 @@\n-ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));\n+ZEXTERN int ZEXPORT    gzrewind(gzFile file);\n@@ -1599,1 +1602,1 @@\n-ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));\n+ZEXTERN z_off_t ZEXPORT    gztell(gzFile file);\n@@ -1610,1 +1613,1 @@\n-ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));\n+ZEXTERN z_off_t ZEXPORT gzoffset(gzFile file);\n@@ -1619,1 +1622,1 @@\n-ZEXTERN int ZEXPORT gzeof OF((gzFile file));\n+ZEXTERN int ZEXPORT gzeof(gzFile file);\n@@ -1634,1 +1637,1 @@\n-ZEXTERN int ZEXPORT gzdirect OF((gzFile file));\n+ZEXTERN int ZEXPORT gzdirect(gzFile file);\n@@ -1655,1 +1658,1 @@\n-ZEXTERN int ZEXPORT    gzclose OF((gzFile file));\n+ZEXTERN int ZEXPORT    gzclose(gzFile file);\n@@ -1668,2 +1671,2 @@\n-ZEXTERN int ZEXPORT gzclose_r OF((gzFile file));\n-ZEXTERN int ZEXPORT gzclose_w OF((gzFile file));\n+ZEXTERN int ZEXPORT gzclose_r(gzFile file);\n+ZEXTERN int ZEXPORT gzclose_w(gzFile file);\n@@ -1680,1 +1683,1 @@\n-ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));\n+ZEXTERN const char * ZEXPORT gzerror(gzFile file, int *errnum);\n@@ -1696,1 +1699,1 @@\n-ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));\n+ZEXTERN void ZEXPORT gzclearerr(gzFile file);\n@@ -1713,1 +1716,1 @@\n-ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));\n+ZEXTERN uLong ZEXPORT adler32(uLong adler, const Bytef *buf, uInt len);\n@@ -1733,2 +1736,2 @@\n-ZEXTERN uLong ZEXPORT adler32_z OF((uLong adler, const Bytef *buf,\n-                                    z_size_t len));\n+ZEXTERN uLong ZEXPORT adler32_z(uLong adler, const Bytef *buf,\n+                                z_size_t len);\n@@ -1740,2 +1743,2 @@\n-ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,\n-                                          z_off_t len2));\n+ZEXTERN uLong ZEXPORT adler32_combine(uLong adler1, uLong adler2,\n+                                      z_off_t len2);\n@@ -1751,1 +1754,1 @@\n-ZEXTERN uLong ZEXPORT crc32 OF((uLong crc, const Bytef *buf, uInt len));\n+ZEXTERN uLong ZEXPORT crc32(uLong crc, const Bytef *buf, uInt len);\n@@ -1769,2 +1772,2 @@\n-ZEXTERN uLong ZEXPORT crc32_z OF((uLong crc, const Bytef *buf,\n-                                  z_size_t len));\n+ZEXTERN uLong ZEXPORT crc32_z(uLong crc, const Bytef *buf,\n+                              z_size_t len);\n@@ -1776,1 +1779,1 @@\n-ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));\n+ZEXTERN uLong ZEXPORT crc32_combine(uLong crc1, uLong crc2, z_off_t len2);\n@@ -1782,1 +1785,1 @@\n-   len2.\n+   len2. len2 must be non-negative.\n@@ -1786,1 +1789,1 @@\n-ZEXTERN uLong ZEXPORT crc32_combine_gen OF((z_off_t len2));\n+ZEXTERN uLong ZEXPORT crc32_combine_gen(z_off_t len2);\n@@ -1789,1 +1792,1 @@\n-   crc32_combine_op().\n+   crc32_combine_op(). len2 must be non-negative.\n@@ -1792,1 +1795,1 @@\n-ZEXTERN uLong ZEXPORT crc32_combine_op OF((uLong crc1, uLong crc2, uLong op));\n+ZEXTERN uLong ZEXPORT crc32_combine_op(uLong crc1, uLong crc2, uLong op);\n@@ -1805,14 +1808,14 @@\n-ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,\n-                                     const char *version, int stream_size));\n-ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,\n-                                     const char *version, int stream_size));\n-ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,\n-                                      int windowBits, int memLevel,\n-                                      int strategy, const char *version,\n-                                      int stream_size));\n-ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,\n-                                      const char *version, int stream_size));\n-ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,\n-                                         unsigned char FAR *window,\n-                                         const char *version,\n-                                         int stream_size));\n+ZEXTERN int ZEXPORT deflateInit_(z_streamp strm, int level,\n+                                 const char *version, int stream_size);\n+ZEXTERN int ZEXPORT inflateInit_(z_streamp strm,\n+                                 const char *version, int stream_size);\n+ZEXTERN int ZEXPORT deflateInit2_(z_streamp strm, int  level, int  method,\n+                                  int windowBits, int memLevel,\n+                                  int strategy, const char *version,\n+                                  int stream_size);\n+ZEXTERN int ZEXPORT inflateInit2_(z_streamp strm, int  windowBits,\n+                                  const char *version, int stream_size);\n+ZEXTERN int ZEXPORT inflateBackInit_(z_streamp strm, int windowBits,\n+                                     unsigned char FAR *window,\n+                                     const char *version,\n+                                     int stream_size);\n@@ -1863,1 +1866,1 @@\n-ZEXTERN int ZEXPORT gzgetc_ OF((gzFile file));  \/* backward compatibility *\/\n+ZEXTERN int ZEXPORT gzgetc_(gzFile file);       \/* backward compatibility *\/\n@@ -1880,7 +1883,7 @@\n-   ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));\n-   ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));\n-   ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));\n-   ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));\n-   ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off64_t));\n-   ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off64_t));\n-   ZEXTERN uLong ZEXPORT crc32_combine_gen64 OF((z_off64_t));\n+   ZEXTERN gzFile ZEXPORT gzopen64(const char *, const char *);\n+   ZEXTERN z_off64_t ZEXPORT gzseek64(gzFile, z_off64_t, int);\n+   ZEXTERN z_off64_t ZEXPORT gztell64(gzFile);\n+   ZEXTERN z_off64_t ZEXPORT gzoffset64(gzFile);\n+   ZEXTERN uLong ZEXPORT adler32_combine64(uLong, uLong, z_off64_t);\n+   ZEXTERN uLong ZEXPORT crc32_combine64(uLong, uLong, z_off64_t);\n+   ZEXTERN uLong ZEXPORT crc32_combine_gen64(z_off64_t);\n@@ -1908,7 +1911,7 @@\n-     ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));\n-     ZEXTERN z_off_t ZEXPORT gzseek64 OF((gzFile, z_off_t, int));\n-     ZEXTERN z_off_t ZEXPORT gztell64 OF((gzFile));\n-     ZEXTERN z_off_t ZEXPORT gzoffset64 OF((gzFile));\n-     ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));\n-     ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));\n-     ZEXTERN uLong ZEXPORT crc32_combine_gen64 OF((z_off_t));\n+     ZEXTERN gzFile ZEXPORT gzopen64(const char *, const char *);\n+     ZEXTERN z_off_t ZEXPORT gzseek64(gzFile, z_off_t, int);\n+     ZEXTERN z_off_t ZEXPORT gztell64(gzFile);\n+     ZEXTERN z_off_t ZEXPORT gzoffset64(gzFile);\n+     ZEXTERN uLong ZEXPORT adler32_combine64(uLong, uLong, z_off_t);\n+     ZEXTERN uLong ZEXPORT crc32_combine64(uLong, uLong, z_off_t);\n+     ZEXTERN uLong ZEXPORT crc32_combine_gen64(z_off_t);\n@@ -1917,7 +1920,7 @@\n-   ZEXTERN gzFile ZEXPORT gzopen OF((const char *, const char *));\n-   ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile, z_off_t, int));\n-   ZEXTERN z_off_t ZEXPORT gztell OF((gzFile));\n-   ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile));\n-   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));\n-   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));\n-   ZEXTERN uLong ZEXPORT crc32_combine_gen OF((z_off_t));\n+   ZEXTERN gzFile ZEXPORT gzopen(const char *, const char *);\n+   ZEXTERN z_off_t ZEXPORT gzseek(gzFile, z_off_t, int);\n+   ZEXTERN z_off_t ZEXPORT gztell(gzFile);\n+   ZEXTERN z_off_t ZEXPORT gzoffset(gzFile);\n+   ZEXTERN uLong ZEXPORT adler32_combine(uLong, uLong, z_off_t);\n+   ZEXTERN uLong ZEXPORT crc32_combine(uLong, uLong, z_off_t);\n+   ZEXTERN uLong ZEXPORT crc32_combine_gen(z_off_t);\n@@ -1928,3 +1931,3 @@\n-   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));\n-   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));\n-   ZEXTERN uLong ZEXPORT crc32_combine_gen OF((z_off_t));\n+   ZEXTERN uLong ZEXPORT adler32_combine(uLong, uLong, z_off_t);\n+   ZEXTERN uLong ZEXPORT crc32_combine(uLong, uLong, z_off_t);\n+   ZEXTERN uLong ZEXPORT crc32_combine_gen(z_off_t);\n@@ -1935,8 +1938,8 @@\n-ZEXTERN const char   * ZEXPORT zError           OF((int));\n-ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));\n-ZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table    OF((void));\n-ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));\n-ZEXTERN int            ZEXPORT inflateValidate OF((z_streamp, int));\n-ZEXTERN unsigned long  ZEXPORT inflateCodesUsed OF((z_streamp));\n-ZEXTERN int            ZEXPORT inflateResetKeep OF((z_streamp));\n-ZEXTERN int            ZEXPORT deflateResetKeep OF((z_streamp));\n+ZEXTERN const char   * ZEXPORT zError(int);\n+ZEXTERN int            ZEXPORT inflateSyncPoint(z_streamp);\n+ZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table(void);\n+ZEXTERN int            ZEXPORT inflateUndermine(z_streamp, int);\n+ZEXTERN int            ZEXPORT inflateValidate(z_streamp, int);\n+ZEXTERN unsigned long  ZEXPORT inflateCodesUsed(z_streamp);\n+ZEXTERN int            ZEXPORT inflateResetKeep(z_streamp);\n+ZEXTERN int            ZEXPORT deflateResetKeep(z_streamp);\n@@ -1944,2 +1947,2 @@\n-ZEXTERN gzFile         ZEXPORT gzopen_w OF((const wchar_t *path,\n-                                            const char *mode));\n+ZEXTERN gzFile         ZEXPORT gzopen_w(const wchar_t *path,\n+                                        const char *mode);\n@@ -1949,3 +1952,3 @@\n-ZEXTERN int            ZEXPORTVA gzvprintf Z_ARG((gzFile file,\n-                                                  const char *format,\n-                                                  va_list va));\n+ZEXTERN int            ZEXPORTVA gzvprintf(gzFile file,\n+                                           const char *format,\n+                                           va_list va);\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/zlib.h","additions":197,"deletions":194,"binary":false,"changes":391,"status":"modified"},{"patch":"@@ -51,2 +51,1 @@\n-const char * ZEXPORT zlibVersion()\n-{\n+const char * ZEXPORT zlibVersion(void) {\n@@ -56,2 +55,1 @@\n-uLong ZEXPORT zlibCompileFlags()\n-{\n+uLong ZEXPORT zlibCompileFlags(void) {\n@@ -148,3 +146,1 @@\n-void ZLIB_INTERNAL z_error(m)\n-    char *m;\n-{\n+void ZLIB_INTERNAL z_error(char *m) {\n@@ -159,3 +155,1 @@\n-const char * ZEXPORT zError(err)\n-    int err;\n-{\n+const char * ZEXPORT zError(int err) {\n@@ -175,5 +169,1 @@\n-void ZLIB_INTERNAL zmemcpy(dest, source, len)\n-    Bytef* dest;\n-    const Bytef* source;\n-    uInt  len;\n-{\n+void ZLIB_INTERNAL zmemcpy(Bytef* dest, const Bytef* source, uInt len) {\n@@ -186,5 +176,1 @@\n-int ZLIB_INTERNAL zmemcmp(s1, s2, len)\n-    const Bytef* s1;\n-    const Bytef* s2;\n-    uInt  len;\n-{\n+int ZLIB_INTERNAL zmemcmp(const Bytef* s1, const Bytef* s2, uInt len) {\n@@ -199,4 +185,1 @@\n-void ZLIB_INTERNAL zmemzero(dest, len)\n-    Bytef* dest;\n-    uInt  len;\n-{\n+void ZLIB_INTERNAL zmemzero(Bytef* dest, uInt len) {\n@@ -243,2 +226,1 @@\n-voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items, unsigned size)\n-{\n+voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items, unsigned size) {\n@@ -269,2 +251,1 @@\n-void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr)\n-{\n+void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr) {\n@@ -306,2 +287,1 @@\n-voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, uInt items, uInt size)\n-{\n+voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, uInt items, uInt size) {\n@@ -312,2 +292,1 @@\n-void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr)\n-{\n+void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr) {\n@@ -326,3 +305,3 @@\n-extern voidp  malloc OF((uInt size));\n-extern voidp  calloc OF((uInt items, uInt size));\n-extern void   free   OF((voidpf ptr));\n+extern voidp malloc(uInt size);\n+extern voidp calloc(uInt items, uInt size);\n+extern void free(voidpf ptr);\n@@ -331,5 +310,1 @@\n-voidpf ZLIB_INTERNAL zcalloc(opaque, items, size)\n-    voidpf opaque;\n-    unsigned items;\n-    unsigned size;\n-{\n+voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items, unsigned size) {\n@@ -341,4 +316,1 @@\n-void ZLIB_INTERNAL zcfree(opaque, ptr)\n-    voidpf opaque;\n-    voidpf ptr;\n-{\n+void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr) {\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/zutil.c","additions":16,"deletions":44,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2022 Jean-loup Gailly, Mark Adler\n+ * Copyright (C) 1995-2024 Jean-loup Gailly, Mark Adler\n@@ -83,1 +83,1 @@\n-#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]\n+#define ERR_MSG(err) z_errmsg[(err) < -6 || (err) > 2 ? 9 : 2 - (err)]\n@@ -164,1 +164,1 @@\n-#if defined(MACOS) || defined(TARGET_OS_MAC)\n+#if defined(MACOS)\n@@ -166,9 +166,0 @@\n-#  ifndef Z_SOLO\n-#    if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os\n-#      include <unix.h> \/* for fdopen *\/\n-#    else\n-#      ifndef fdopen\n-#        define fdopen(fd,mode) NULL \/* No fdopen() *\/\n-#      endif\n-#    endif\n-#  endif\n@@ -197,12 +188,0 @@\n-#if defined(_BEOS_) || defined(RISCOS)\n-#  define fdopen(fd,mode) NULL \/* No fdopen() *\/\n-#endif\n-\n-#if (defined(_MSC_VER) && (_MSC_VER > 600)) && !defined __INTERIX\n-#  if defined(_WIN32_WCE)\n-#    define fdopen(fd,mode) NULL \/* No fdopen() *\/\n-#  else\n-#    define fdopen(fd,type)  _fdopen(fd,type)\n-#  endif\n-#endif\n-\n@@ -218,3 +197,3 @@\n-    ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));\n-    ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));\n-    ZEXTERN uLong ZEXPORT crc32_combine_gen64 OF((z_off_t));\n+    ZEXTERN uLong ZEXPORT adler32_combine64(uLong, uLong, z_off_t);\n+    ZEXTERN uLong ZEXPORT crc32_combine64(uLong, uLong, z_off_t);\n+    ZEXTERN uLong ZEXPORT crc32_combine_gen64(z_off_t);\n@@ -259,3 +238,3 @@\n-   void ZLIB_INTERNAL zmemcpy OF((Bytef* dest, const Bytef* source, uInt len));\n-   int ZLIB_INTERNAL zmemcmp OF((const Bytef* s1, const Bytef* s2, uInt len));\n-   void ZLIB_INTERNAL zmemzero OF((Bytef* dest, uInt len));\n+   void ZLIB_INTERNAL zmemcpy(Bytef* dest, const Bytef* source, uInt len);\n+   int ZLIB_INTERNAL zmemcmp(const Bytef* s1, const Bytef* s2, uInt len);\n+   void ZLIB_INTERNAL zmemzero(Bytef* dest, uInt len);\n@@ -268,1 +247,1 @@\n-   extern void ZLIB_INTERNAL z_error OF((char *m));\n+   extern void ZLIB_INTERNAL z_error(char *m);\n@@ -285,3 +264,3 @@\n-   voidpf ZLIB_INTERNAL zcalloc OF((voidpf opaque, unsigned items,\n-                                    unsigned size));\n-   void ZLIB_INTERNAL zcfree  OF((voidpf opaque, voidpf ptr));\n+   voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items,\n+                                unsigned size);\n+   void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr);\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/zutil.h","additions":13,"deletions":34,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,2 +206,1 @@\n-    public NativePRNG() {\n-        super();\n+    public NativePRNG(SecureRandomParameters params) {\n@@ -211,0 +210,3 @@\n+        if (params != null) {\n+            throw new IllegalArgumentException(\"Unsupported params: \" + params.getClass());\n+        }\n@@ -254,2 +256,1 @@\n-        public Blocking() {\n-            super();\n+        public Blocking(SecureRandomParameters params) {\n@@ -259,0 +260,3 @@\n+            if (params != null) {\n+                throw new IllegalArgumentException(\"Unsupported params: \" + params.getClass());\n+            }\n@@ -303,2 +307,1 @@\n-        public NonBlocking() {\n-            super();\n+        public NonBlocking(SecureRandomParameters params) {\n@@ -309,0 +312,3 @@\n+            if (params != null) {\n+                throw new IllegalArgumentException(\"Unsupported params: \" + params.getClass());\n+            }\n","filename":"src\/java.base\/unix\/classes\/sun\/security\/provider\/NativePRNG.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+static NSInteger architecture = -1;\n@@ -61,1 +62,11 @@\n-static BOOL isValidDisplayMode(CGDisplayModeRef mode){\n+static BOOL isValidDisplayMode(CGDisplayModeRef mode) {\n+    \/\/ Workaround for apple bug FB13261205, since it only affects arm based macs\n+    \/\/ and arm support started with macOS 11 ignore the workaround for previous versions\n+    if (@available(macOS 11, *)) {\n+        if (architecture == -1) {\n+            architecture = [[NSRunningApplication currentApplication] executableArchitecture];\n+        }\n+        if (architecture == NSBundleExecutableArchitectureARM64) {\n+            return (CGDisplayModeGetPixelWidth(mode) >= 800);\n+        }\n+    }\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CGraphicsDevice.m","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.awt.IllegalComponentStateException;\n@@ -2340,1 +2341,6 @@\n-             Point parentLocation = parent.getLocationOnScreen();\n+             Point parentLocation;\n+             try {\n+                 parentLocation = parent.getLocationOnScreen();\n+             } catch (IllegalComponentStateException icse) {\n+                 return null;\n+             }\n@@ -2342,0 +2348,3 @@\n+             if (parentLocation == null || componentLocation == null) {\n+                 return null;\n+             }\n@@ -2348,1 +2357,1 @@\n-             return new Point(r.x, r.y);\n+             return r == null ? null : new Point(r.x, r.y);\n@@ -2365,1 +2374,1 @@\n-            return new Dimension(r.width, r.height);\n+            return r == null ? null : new Dimension(r.width, r.height);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTabbedPane.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Objects;\n@@ -35,0 +38,1 @@\n+import javax.print.attribute.Size2DSyntax;\n@@ -39,0 +43,1 @@\n+    private static Map<SizeNameChoiceItem, CustomMediaSizeName> customMap = new HashMap<>();\n@@ -194,0 +199,51 @@\n+    public static CustomMediaSizeName create(String name, String choice,\n+                                             float width, float length) {\n+        SizeNameChoiceItem key = new SizeNameChoiceItem(name, choice, width, length);\n+        CustomMediaSizeName value = customMap.get(key);\n+        if (value == null) {\n+            value = new CustomMediaSizeName(name, choice, width, length);\n+            customMap.put(key, value);\n+\n+            \/\/ add this new custom media size name to MediaSize array\n+            if ((width > 0.0) && (length > 0.0)) {\n+                try {\n+                    new MediaSize(width, length, Size2DSyntax.INCH, value);\n+                } catch (IllegalArgumentException e) {\n+                        \/* PDF printer in Linux for Ledger paper causes\n+                        \"IllegalArgumentException: X dimension > Y dimension\".\n+                        We rotate based on IPP spec. *\/\n+                    new MediaSize(length, width, Size2DSyntax.INCH, value);\n+                }\n+            }\n+        }\n+        return value;\n+    }\n+\n+    private static class SizeNameChoiceItem {\n+\n+        private final String name;\n+        private final String choice;\n+        private final float width;\n+        private final float length;\n+\n+        public SizeNameChoiceItem(String name, String choice, float width, float length) {\n+            this.name = name;\n+            this.choice = choice;\n+            this.width = width;\n+            this.length = length;\n+        }\n+\n+        public boolean equals(Object object) {\n+            if (this == object) return true;\n+            if (object == null || getClass() != object.getClass()) return false;\n+            SizeNameChoiceItem that = (SizeNameChoiceItem) object;\n+            return Objects.equals(this.name, that.name)\n+                    && Objects.equals(this.choice, that.choice) &&\n+                    Float.compare(this.width, that.width) == 0 &&\n+                    Float.compare(this.length, that.length) == 0;\n+        }\n+\n+        public int hashCode() {\n+            return Objects.hash(name, choice, width, length);\n+        }\n+    }\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/CustomMediaSizeName.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import java.util.Objects;\n+import java.util.Map;\n+import java.util.HashMap;\n@@ -38,0 +41,1 @@\n+    private static Map<NameChoiceItem, CustomMediaTray> customMap = new HashMap<>();\n@@ -96,0 +100,32 @@\n+    public static CustomMediaTray create(String name, String choice) {\n+        NameChoiceItem key = new NameChoiceItem(name, choice);\n+        CustomMediaTray value = customMap.get(key);\n+        if (value == null) {\n+            value = new CustomMediaTray(name, choice);\n+            customMap.put(key, value);\n+        }\n+        return value;\n+    }\n+\n+    private static class NameChoiceItem {\n+\n+        private final String name;\n+        private final String choice;\n+\n+        public NameChoiceItem(String name, String choice) {\n+            this.name = name;\n+            this.choice = choice;\n+        }\n+\n+        public boolean equals(Object object) {\n+            if (this == object) return true;\n+            if (object == null || getClass() != object.getClass()) return false;\n+            NameChoiceItem that = (NameChoiceItem) object;\n+            return Objects.equals(this.name, that.name)\n+                    && Objects.equals(this.choice, that.choice);\n+        }\n+\n+        public int hashCode() {\n+            return Objects.hash(name, choice);\n+        }\n+    }\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/CustomMediaTray.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## Little Color Management System (LCMS) v2.15\n+## Little Color Management System (LCMS) v2.16\n@@ -5,1 +5,0 @@\n-README.1ST file information\n@@ -7,1 +6,1 @@\n-LittleCMS core is released under MIT License\n+MIT License\n@@ -9,4 +8,1 @@\n----------------------------------\n-\n-Little CMS\n-Copyright (c) 1998-2023 Marti Maria Saguer\n+Copyright (C) 1998-2023 Marti Maria Saguer\n@@ -15,6 +11,5 @@\n-a copy of this software and associated documentation files (the\n-\"Software\"), to deal in the Software without restriction, including\n-without limitation the rights to use, copy, modify, merge, publish,\n-distribute, sublicense, and\/or sell copies of the Software, and to\n-permit persons to whom the Software is furnished to do so, subject\n-to the following conditions:\n+a copy of this software and associated documentation files (the \"Software\"),\n+to deal in the Software without restriction, including without limitation\n+the rights to use, copy, modify, merge, publish, distribute, sublicense,\n+and\/or sell copies of the Software, and to permit persons to whom the Software\n+is furnished to do so, subject to the following conditions:\n@@ -22,2 +17,2 @@\n-The above copyright notice and this permission notice shall be\n-included in all copies or substantial portions of the Software.\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n@@ -26,6 +21,6 @@\n-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO\n+THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n@@ -50,1 +45,0 @@\n-\n@@ -94,0 +88,1 @@\n+Diogo Teles Sant'Anna\n","filename":"src\/java.desktop\/share\/legal\/lcms.md","additions":17,"deletions":22,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,0 +191,5 @@\n+    cmsUInt32Number dwFlags = 0;\n+    if (T_EXTRA(inFormatter) > 0 && T_EXTRA(outFormatter) > 0) {\n+        dwFlags |= cmsFLAGS_COPY_ALPHA;\n+    }\n+\n@@ -192,1 +197,1 @@\n-        inFormatter, outFormatter, renderingIntent, cmsFLAGS_COPY_ALPHA);\n+        inFormatter, outFormatter, renderingIntent, dwFlags);\n","filename":"src\/java.desktop\/share\/native\/liblcms\/LCMS.c","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-void ComputeIncrementsForChunky(cmsUInt32Number Format,\n+cmsBool ComputeIncrementsForChunky(cmsUInt32Number Format,\n@@ -448,1 +448,1 @@\n-           return;\n+           return FALSE;\n@@ -485,0 +485,2 @@\n+\n+       return TRUE;\n@@ -491,1 +493,1 @@\n-void ComputeIncrementsForPlanar(cmsUInt32Number Format,\n+cmsBool ComputeIncrementsForPlanar(cmsUInt32Number Format,\n@@ -505,1 +507,1 @@\n-           return;\n+           return FALSE;\n@@ -541,0 +543,2 @@\n+\n+       return TRUE;\n@@ -547,1 +551,1 @@\n-void  ComputeComponentIncrements(cmsUInt32Number Format,\n+cmsBool ComputeComponentIncrements(cmsUInt32Number Format,\n@@ -554,1 +558,1 @@\n-              ComputeIncrementsForPlanar(Format,  BytesPerPlane, ComponentStartingOrder, ComponentPointerIncrements);\n+              return ComputeIncrementsForPlanar(Format,  BytesPerPlane, ComponentStartingOrder, ComponentPointerIncrements);\n@@ -557,1 +561,1 @@\n-              ComputeIncrementsForChunky(Format,  ComponentStartingOrder, ComponentPointerIncrements);\n+              return ComputeIncrementsForChunky(Format,  ComponentStartingOrder, ComponentPointerIncrements);\n@@ -562,2 +566,0 @@\n-\n-\n@@ -598,2 +600,4 @@\n-    ComputeComponentIncrements(p->InputFormat, Stride->BytesPerPlaneIn, SourceStartingOrder, SourceIncrements);\n-    ComputeComponentIncrements(p->OutputFormat, Stride->BytesPerPlaneOut, DestStartingOrder, DestIncrements);\n+    if (!ComputeComponentIncrements(p->InputFormat, Stride->BytesPerPlaneIn, SourceStartingOrder, SourceIncrements))\n+        return;\n+    if (!ComputeComponentIncrements(p->OutputFormat, Stride->BytesPerPlaneOut, DestStartingOrder, DestIncrements))\n+        return;\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsalpha.c","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        \/\/ Keywords\n+        \/\/ IT8 symbols\n@@ -98,1 +98,13 @@\n-        SINCLUDE\n+        SINCLUDE,\n+\n+        \/\/ Cube symbols\n+\n+        SDOMAIN_MAX,\n+        SDOMAIN_MIN,\n+        S_LUT1D_SIZE,\n+        S_LUT1D_INPUT_RANGE,\n+        S_LUT3D_SIZE,\n+        S_LUT3D_INPUT_RANGE,\n+        S_LUT_IN_VIDEO_RANGE,\n+        S_LUT_OUT_VIDEO_RANGE,\n+        STITLE\n@@ -181,0 +193,4 @@\n+        \/\/ Partser type\n+        cmsBool        IsCUBE;\n+\n+        \/\/ Tables\n@@ -240,2 +256,2 @@\n-\/\/ The keyword->symbol translation table. Sorting is required.\n-static const KEYWORD TabKeys[] = {\n+\/\/ The keyword->symbol translation tables. Sorting is required.\n+static const KEYWORD TabKeysIT8[] = {\n@@ -254,1 +270,19 @@\n-#define NUMKEYS (sizeof(TabKeys)\/sizeof(KEYWORD))\n+#define NUMKEYS_IT8 (sizeof(TabKeysIT8)\/sizeof(KEYWORD))\n+\n+static const KEYWORD TabKeysCUBE[] = {\n+\n+        {\"DOMAIN_MAX\",             SDOMAIN_MAX },\n+        {\"DOMAIN_MIN\",             SDOMAIN_MIN },\n+        {\"LUT_1D_SIZE\",            S_LUT1D_SIZE },\n+        {\"LUT_1D_INPUT_RANGE\",     S_LUT1D_INPUT_RANGE },\n+        {\"LUT_3D_SIZE\",            S_LUT3D_SIZE },\n+        {\"LUT_3D_INPUT_RANGE\",     S_LUT3D_INPUT_RANGE },\n+        {\"LUT_IN_VIDEO_RANGE\",     S_LUT_IN_VIDEO_RANGE },\n+        {\"LUT_OUT_VIDEO_RANGE\",    S_LUT_OUT_VIDEO_RANGE },\n+        {\"TITLE\",                  STITLE }\n+\n+};\n+\n+#define NUMKEYS_CUBE (sizeof(TabKeysCUBE)\/sizeof(KEYWORD))\n+\n+\n@@ -458,1 +492,1 @@\n-    return (c == ' ') || (c == '\\t') ;\n+    return (c == ' ') || (c == '\\t');\n@@ -479,1 +513,1 @@\n-     return !isdigit(c) && ismiddle(c);\n+     return c != '-' && !isdigit(c) && ismiddle(c);\n@@ -518,1 +552,1 @@\n-        strncpy(buffer, relPath, MaxLen);\n+        memcpy(buffer, relPath, MaxLen);\n@@ -524,1 +558,1 @@\n-    strncpy(buffer, basePath, MaxLen);\n+    memcpy(buffer, basePath, MaxLen);\n@@ -606,1 +640,1 @@\n-SYMBOL BinSrchKey(const char *id)\n+SYMBOL BinSrchKey(const char *id, int NumKeys, const KEYWORD* TabKeys)\n@@ -609,1 +643,1 @@\n-    int r = NUMKEYS;\n+    int r = NumKeys;\n@@ -779,1 +813,1 @@\n-\/\/ Reads a string, special case to avoid infinite resursion on .include\n+\/\/ Reads a string, special case to avoid infinite recursion on .include\n@@ -836,1 +870,3 @@\n-            key = BinSrchKey(StringPtr(it8->id));\n+            key = BinSrchKey(StringPtr(it8->id),\n+                    it8->IsCUBE ? NUMKEYS_CUBE : NUMKEYS_IT8,\n+                    it8->IsCUBE ? TabKeysCUBE : TabKeysIT8);\n@@ -945,0 +981,1 @@\n+                    StringClear(it8->id);\n@@ -974,1 +1011,1 @@\n-            if (it8 ->ch == '\\n')\n+            if (it8->ch == '\\n')\n@@ -1295,1 +1332,6 @@\n-        \/\/     return SynError(it8, \"duplicate key <%s>\", Key);\n+        if (cmsstrcasecmp(Key, \"NUMBER_OF_FIELDS\") == 0 ||\n+            cmsstrcasecmp(Key, \"NUMBER_OF_SETS\") == 0) {\n+\n+            SynError(it8, \"duplicate key <%s>\", Key);\n+            return NULL;\n+        }\n@@ -1416,0 +1458,2 @@\n+    it8->IsCUBE = FALSE;\n+\n@@ -1697,1 +1741,1 @@\n-    if (nSet >= nPatches || nField >= nSamples)\n+    if (nSet < 0 || nSet >= nPatches || nField < 0 || nField >= nSamples)\n@@ -1882,1 +1926,1 @@\n-       for (i = 0; i < nSamples; i++) {\n+       if (nSamples <= t->nSamples) {\n@@ -1884,3 +1928,6 @@\n-              WriteStr(fp, t->DataFormat[i]);\n-              WriteStr(fp, ((i == (nSamples-1)) ? \"\\n\" : \"\\t\"));\n-          }\n+           for (i = 0; i < nSamples; i++) {\n+\n+               WriteStr(fp, t->DataFormat[i]);\n+               WriteStr(fp, ((i == (nSamples - 1)) ? \"\\n\" : \"\\t\"));\n+           }\n+       }\n@@ -1896,1 +1943,1 @@\n-       int  i, j;\n+       int  i, j, nPatches;\n@@ -1903,1 +1950,1 @@\n-       t->nPatches = satoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n+       nPatches = satoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n@@ -1905,1 +1952,1 @@\n-       for (i = 0; i < t-> nPatches; i++) {\n+       if (nPatches <= t->nPatches) {\n@@ -1907,1 +1954,1 @@\n-              WriteStr(fp, \" \");\n+           for (i = 0; i < nPatches; i++) {\n@@ -1909,1 +1956,1 @@\n-              for (j = 0; j < t->nSamples; j++) {\n+               WriteStr(fp, \" \");\n@@ -1911,1 +1958,1 @@\n-                     char *ptr = t->Data[i*t->nSamples+j];\n+               for (j = 0; j < t->nSamples; j++) {\n@@ -1913,3 +1960,1 @@\n-                     if (ptr == NULL) WriteStr(fp, \"\\\"\\\"\");\n-                     else {\n-                         \/\/ If value contains whitespace, enclose within quote\n+                   char* ptr = t->Data[i * t->nSamples + j];\n@@ -1917,1 +1962,3 @@\n-                         if (strchr(ptr, ' ') != NULL) {\n+                   if (ptr == NULL) WriteStr(fp, \"\\\"\\\"\");\n+                   else {\n+                       \/\/ If value contains whitespace, enclose within quote\n@@ -1919,7 +1966,1 @@\n-                             WriteStr(fp, \"\\\"\");\n-                             WriteStr(fp, ptr);\n-                             WriteStr(fp, \"\\\"\");\n-                         }\n-                         else\n-                            WriteStr(fp, ptr);\n-                     }\n+                       if (strchr(ptr, ' ') != NULL) {\n@@ -1927,2 +1968,11 @@\n-                     WriteStr(fp, ((j == (t->nSamples-1)) ? \"\\n\" : \"\\t\"));\n-              }\n+                           WriteStr(fp, \"\\\"\");\n+                           WriteStr(fp, ptr);\n+                           WriteStr(fp, \"\\\"\");\n+                       }\n+                       else\n+                           WriteStr(fp, ptr);\n+                   }\n+\n+                   WriteStr(fp, ((j == (t->nSamples - 1)) ? \"\\n\" : \"\\t\"));\n+               }\n+           }\n@@ -1949,4 +1999,14 @@\n-            cmsIT8SetTable(hIT8, i);\n-            WriteHeader(it8, &sd);\n-            WriteDataFormat(&sd, it8);\n-            WriteData(&sd, it8);\n+        TABLE* t;\n+\n+        if (cmsIT8SetTable(hIT8, i) < 0) goto Error;\n+\n+        \/**\n+        * Check for wrong data\n+        *\/\n+        t = GetTable(it8);\n+        if (t->Data == NULL) goto Error;\n+        if (t->DataFormat == NULL) goto Error;\n+\n+        WriteHeader(it8, &sd);\n+        WriteDataFormat(&sd, it8);\n+        WriteData(&sd, it8);\n@@ -1956,1 +2016,0 @@\n-\n@@ -1958,0 +2017,5 @@\n+\n+Error:\n+    fclose(sd.stream);\n+    return FALSE;\n+\n@@ -2334,1 +2398,1 @@\n-    cmsUInt32Number nOldTable = it8 ->nTable;\n+    cmsUInt32Number nOldTable = it8->nTable;\n@@ -2336,1 +2400,1 @@\n-    for (j=0; j < it8 ->TablesCount; j++) {\n+    for (j = 0; j < it8->TablesCount; j++) {\n@@ -2338,1 +2402,1 @@\n-    TABLE* t = it8 ->Tab + j;\n+        TABLE* t = it8->Tab + j;\n@@ -2340,2 +2404,2 @@\n-    t -> SampleID = 0;\n-    it8 ->nTable = j;\n+        t->SampleID = 0;\n+        it8->nTable = j;\n@@ -2343,6 +2407,6 @@\n-    for (idField = 0; idField < t -> nSamples; idField++)\n-    {\n-        if (t ->DataFormat == NULL){\n-            SynError(it8, \"Undefined DATA_FORMAT\");\n-            return;\n-        }\n+        for (idField = 0; idField < t->nSamples; idField++)\n+        {\n+            if (t->DataFormat == NULL) {\n+                SynError(it8, \"Undefined DATA_FORMAT\");\n+                return;\n+            }\n@@ -2350,2 +2414,2 @@\n-        Fld = t->DataFormat[idField];\n-        if (!Fld) continue;\n+            Fld = t->DataFormat[idField];\n+            if (!Fld) continue;\n@@ -2354,1 +2418,1 @@\n-        if (cmsstrcasecmp(Fld, \"SAMPLE_ID\") == 0) {\n+            if (cmsstrcasecmp(Fld, \"SAMPLE_ID\") == 0) {\n@@ -2356,2 +2420,2 @@\n-            t -> SampleID = idField;\n-        }\n+                t->SampleID = idField;\n+            }\n@@ -2359,1 +2423,1 @@\n-        \/\/ \"LABEL\" is an extension. It keeps references to forward tables\n+            \/\/ \"LABEL\" is an extension. It keeps references to forward tables\n@@ -2361,1 +2425,1 @@\n-        if ((cmsstrcasecmp(Fld, \"LABEL\") == 0) || Fld[0] == '$') {\n+            if ((cmsstrcasecmp(Fld, \"LABEL\") == 0) || Fld[0] == '$') {\n@@ -2363,2 +2427,2 @@\n-            \/\/ Search for table references...\n-            for (i = 0; i < t->nPatches; i++) {\n+                \/\/ Search for table references...\n+                for (i = 0; i < t->nPatches; i++) {\n@@ -2366,1 +2430,1 @@\n-                char* Label = GetData(it8, i, idField);\n+                    char* Label = GetData(it8, i, idField);\n@@ -2368,1 +2432,1 @@\n-                if (Label) {\n+                    if (Label) {\n@@ -2370,1 +2434,1 @@\n-                    cmsUInt32Number k;\n+                        cmsUInt32Number k;\n@@ -2372,2 +2436,2 @@\n-                    \/\/ This is the label, search for a table containing\n-                    \/\/ this property\n+                        \/\/ This is the label, search for a table containing\n+                        \/\/ this property\n@@ -2375,1 +2439,1 @@\n-                    for (k = 0; k < it8->TablesCount; k++) {\n+                        for (k = 0; k < it8->TablesCount; k++) {\n@@ -2377,2 +2441,2 @@\n-                        TABLE* Table = it8->Tab + k;\n-                        KEYVALUE* p;\n+                            TABLE* Table = it8->Tab + k;\n+                            KEYVALUE* p;\n@@ -2380,1 +2444,1 @@\n-                        if (IsAvailableOnList(Table->HeaderList, Label, NULL, &p)) {\n+                            if (IsAvailableOnList(Table->HeaderList, Label, NULL, &p)) {\n@@ -2382,2 +2446,2 @@\n-                            \/\/ Available, keep type and table\n-                            char Buffer[256];\n+                                \/\/ Available, keep type and table\n+                                char Buffer[256];\n@@ -2385,2 +2449,2 @@\n-                            char* Type = p->Value;\n-                            int  nTable = (int)k;\n+                                char* Type = p->Value;\n+                                int  nTable = (int)k;\n@@ -2388,1 +2452,1 @@\n-                            snprintf(Buffer, 255, \"%s %d %s\", Label, nTable, Type);\n+                                snprintf(Buffer, 255, \"%s %d %s\", Label, nTable, Type);\n@@ -2390,1 +2454,2 @@\n-                            SetData(it8, i, idField, Buffer);\n+                                SetData(it8, i, idField, Buffer);\n+                            }\n@@ -2393,2 +2458,0 @@\n-\n-\n@@ -2396,1 +2459,0 @@\n-\n@@ -2398,2 +2460,0 @@\n-\n-\n@@ -2401,2 +2461,0 @@\n-\n-    }\n@@ -2405,1 +2463,1 @@\n-    it8 ->nTable = nOldTable;\n+    it8->nTable = nOldTable;\n@@ -2496,1 +2554,1 @@\n-        return FALSE;\n+        return NULL;\n@@ -2508,1 +2566,1 @@\n-        return FALSE;\n+        return NULL;\n@@ -2605,8 +2663,2 @@\n-        Props = (char**)AllocChunk(it8, sizeof(char*) * n);\n-        if (Props != NULL) {\n-\n-                \/\/ Pass#2 - Fill pointers\n-                n = 0;\n-                for (p = t->HeaderList; p != NULL; p = p->Next) {\n-                        Props[n++] = p->Keyword;\n-                }\n+    Props = (char**)AllocChunk(it8, sizeof(char*) * n);\n+    if (Props != NULL) {\n@@ -2614,0 +2666,4 @@\n+        \/\/ Pass#2 - Fill pointers\n+        n = 0;\n+        for (p = t->HeaderList; p != NULL; p = p->Next) {\n+            Props[n++] = p->Keyword;\n@@ -2615,1 +2671,3 @@\n-        *PropertyNames = Props;\n+\n+    }\n+    *PropertyNames = Props;\n@@ -2975,0 +3033,233 @@\n+\n+static\n+cmsBool ReadNumbers(cmsIT8* cube, int n, cmsFloat64Number* arr)\n+{\n+    int i;\n+\n+    for (i = 0; i < n; i++) {\n+\n+        if (cube->sy == SINUM)\n+            arr[i] = cube->inum;\n+        else\n+            if (cube->sy == SDNUM)\n+                arr[i] = cube->dnum;\n+            else\n+                return SynError(cube, \"Number expected\");\n+\n+        InSymbol(cube);\n+    }\n+\n+    return CheckEOLN(cube);\n+}\n+\n+static\n+cmsBool ParseCube(cmsIT8* cube, cmsStage** Shaper, cmsStage** CLUT, char title[])\n+{\n+    cmsFloat64Number domain_min[3] = { 0, 0, 0 };\n+    cmsFloat64Number domain_max[3] = { 1.0, 1.0, 1.0 };\n+    cmsFloat64Number check_0_1[2] = { 0, 1.0 };\n+    int shaper_size = 0;\n+    int lut_size = 0;\n+    int i;\n+\n+    InSymbol(cube);\n+\n+    while (cube->sy != SEOF) {\n+        switch (cube->sy)\n+        {\n+        \/\/ Set profile description\n+        case STITLE:\n+            InSymbol(cube);\n+            if (!Check(cube, SSTRING, \"Title string expected\")) return FALSE;\n+            memcpy(title, StringPtr(cube->str), MAXSTR);\n+            title[MAXSTR - 1] = 0;\n+            InSymbol(cube);\n+            break;\n+\n+        \/\/ Define domain\n+        case SDOMAIN_MIN:\n+            InSymbol(cube);\n+            if (!ReadNumbers(cube, 3, domain_min)) return FALSE;\n+            break;\n+\n+        case SDOMAIN_MAX:\n+            InSymbol(cube);\n+            if (!ReadNumbers(cube, 3, domain_max)) return FALSE;\n+            break;\n+\n+        \/\/ Define shaper\n+        case S_LUT1D_SIZE:\n+            InSymbol(cube);\n+            if (!Check(cube, SINUM, \"Shaper size expected\")) return FALSE;\n+            shaper_size = cube->inum;\n+            InSymbol(cube);\n+            break;\n+\n+        \/\/ Deefine CLUT\n+        case S_LUT3D_SIZE:\n+            InSymbol(cube);\n+            if (!Check(cube, SINUM, \"LUT size expected\")) return FALSE;\n+            lut_size = cube->inum;\n+            InSymbol(cube);\n+            break;\n+\n+        \/\/ Range. If present, has to be 0..1.0\n+        case S_LUT1D_INPUT_RANGE:\n+        case S_LUT3D_INPUT_RANGE:\n+            InSymbol(cube);\n+            if (!ReadNumbers(cube, 2, check_0_1)) return FALSE;\n+            if (check_0_1[0] != 0 || check_0_1[1] != 1.0) {\n+                return SynError(cube, \"Unsupported format\");\n+            }\n+            break;\n+\n+        case SEOLN:\n+            InSymbol(cube);\n+            break;\n+\n+        default:\n+        case S_LUT_IN_VIDEO_RANGE:\n+        case S_LUT_OUT_VIDEO_RANGE:\n+            return SynError(cube, \"Unsupported format\");\n+\n+            \/\/ Read and create tables\n+        case SINUM:\n+        case SDNUM:\n+\n+            if (shaper_size > 0) {\n+\n+                cmsToneCurve* curves[3];\n+                cmsFloat32Number* shapers = (cmsFloat32Number*)_cmsMalloc(cube->ContextID, 3 * shaper_size * sizeof(cmsFloat32Number));\n+                if (shapers == NULL) return FALSE;\n+\n+                for (i = 0; i < shaper_size; i++) {\n+\n+                    cmsFloat64Number nums[3];\n+\n+                    if (!ReadNumbers(cube, 3, nums)) return FALSE;\n+\n+                    shapers[i + 0]               = (cmsFloat32Number) ((nums[0] - domain_min[0]) \/ (domain_max[0] - domain_min[0]));\n+                    shapers[i + 1 * shaper_size] = (cmsFloat32Number) ((nums[1] - domain_min[1]) \/ (domain_max[1] - domain_min[1]));\n+                    shapers[i + 2 * shaper_size] = (cmsFloat32Number) ((nums[2] - domain_min[2]) \/ (domain_max[2] - domain_min[2]));\n+                }\n+\n+                for (i = 0; i < 3; i++) {\n+\n+                    curves[i] = cmsBuildTabulatedToneCurveFloat(cube->ContextID, shaper_size,\n+                        &shapers[i * shaper_size]);\n+                    if (curves[i] == NULL) return FALSE;\n+                }\n+\n+                *Shaper = cmsStageAllocToneCurves(cube->ContextID, 3, curves);\n+\n+                cmsFreeToneCurveTriple(curves);\n+            }\n+\n+            if (lut_size > 0) {\n+\n+                int nodes = lut_size * lut_size * lut_size;\n+\n+                cmsFloat32Number* lut_table = _cmsMalloc(cube->ContextID, nodes * 3 * sizeof(cmsFloat32Number));\n+                if (lut_table == NULL) return FALSE;\n+\n+                for (i = 0; i < nodes; i++) {\n+\n+                    cmsFloat64Number nums[3];\n+\n+                    if (!ReadNumbers(cube, 3, nums)) return FALSE;\n+\n+                    lut_table[i * 3 + 2] = (cmsFloat32Number) ((nums[0] - domain_min[0]) \/ (domain_max[0] - domain_min[0]));\n+                    lut_table[i * 3 + 1] = (cmsFloat32Number) ((nums[1] - domain_min[1]) \/ (domain_max[1] - domain_min[1]));\n+                    lut_table[i * 3 + 0] = (cmsFloat32Number) ((nums[2] - domain_min[2]) \/ (domain_max[2] - domain_min[2]));\n+                }\n+\n+                *CLUT = cmsStageAllocCLutFloat(cube->ContextID, lut_size, 3, 3, lut_table);\n+                _cmsFree(cube->ContextID, lut_table);\n+            }\n+\n+            if (!Check(cube, SEOF, \"Extra symbols found in file\")) return FALSE;\n+        }\n+    }\n+\n+    return TRUE;\n+}\n+\n+\/\/ Share the parser to read .cube format and create RGB devicelink profiles\n+cmsHPROFILE CMSEXPORT cmsCreateDeviceLinkFromCubeFileTHR(cmsContext ContextID, const char* cFileName)\n+{\n+    cmsHPROFILE hProfile = NULL;\n+    cmsIT8* cube = NULL;\n+    cmsPipeline* Pipeline = NULL;\n+    cmsStage* CLUT = NULL;\n+    cmsStage* Shaper = NULL;\n+    cmsMLU* DescriptionMLU = NULL;\n+    char title[MAXSTR];\n+\n+    _cmsAssert(cFileName != NULL);\n+\n+    cube = (cmsIT8*) cmsIT8Alloc(ContextID);\n+    if (!cube) return NULL;\n+\n+    cube->IsCUBE = TRUE;\n+    cube->FileStack[0]->Stream = fopen(cFileName, \"rt\");\n+\n+    if (!cube->FileStack[0]->Stream) goto Done;\n+\n+    strncpy(cube->FileStack[0]->FileName, cFileName, cmsMAX_PATH - 1);\n+    cube->FileStack[0]->FileName[cmsMAX_PATH - 1] = 0;\n+\n+    if (!ParseCube(cube, &Shaper, &CLUT, title)) goto Done;\n+\n+    \/\/ Success on parsing, let's create the profile\n+    hProfile = cmsCreateProfilePlaceholder(ContextID);\n+    if (!hProfile) goto Done;\n+\n+    cmsSetProfileVersion(hProfile, 4.4);\n+\n+    cmsSetDeviceClass(hProfile, cmsSigLinkClass);\n+    cmsSetColorSpace(hProfile,  cmsSigRgbData);\n+    cmsSetPCS(hProfile,         cmsSigRgbData);\n+\n+    cmsSetHeaderRenderingIntent(hProfile, INTENT_PERCEPTUAL);\n+\n+    \/\/ Creates a Pipeline to hold CLUT and shaper\n+    Pipeline = cmsPipelineAlloc(ContextID, 3, 3);\n+    if (Pipeline == NULL) goto Done;\n+\n+    \/\/ Populates the pipeline\n+    if (Shaper != NULL) {\n+        if (!cmsPipelineInsertStage(Pipeline, cmsAT_BEGIN, Shaper))\n+            goto Done;\n+    }\n+\n+    if (CLUT != NULL) {\n+        if (!cmsPipelineInsertStage(Pipeline, cmsAT_END, CLUT))\n+            goto Done;\n+    }\n+\n+    \/\/ Propagate the description. We put no copyright because we know\n+    \/\/ nothing on the copyrighted state of the .cube\n+    DescriptionMLU = cmsMLUalloc(ContextID, 1);\n+    if (!cmsMLUsetUTF8(DescriptionMLU, cmsNoLanguage, cmsNoCountry, title)) goto Done;\n+\n+    \/\/ Flush the tags\n+    if (!cmsWriteTag(hProfile, cmsSigProfileDescriptionTag, DescriptionMLU)) goto Done;\n+    if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, (void*)Pipeline)) goto Done;\n+\n+Done:\n+\n+    if (DescriptionMLU != NULL)\n+        cmsMLUfree(DescriptionMLU);\n+\n+    if (Pipeline != NULL)\n+        cmsPipelineFree(Pipeline);\n+\n+    cmsIT8Free((cmsHANDLE) cube);\n+\n+    return hProfile;\n+}\n+\n+cmsHPROFILE CMSEXPORT cmsCreateDeviceLinkFromCubeFile(const char* cFileName)\n+{\n+    return cmsCreateDeviceLinkFromCubeFileTHR(NULL, cFileName);\n+}\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmscgats.c","additions":389,"deletions":98,"binary":false,"changes":487,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-    void Temp2CHAD(cmsMAT3* Chad, cmsFloat64Number Temp)\n+void Temp2CHAD(cmsMAT3* Chad, cmsFloat64Number Temp)\n@@ -747,0 +747,10 @@\n+\n+\/\/ Check whatever the profile is a CMYK->CMYK devicelink\n+static\n+cmsBool is_cmyk_devicelink(cmsHPROFILE hProfile)\n+{\n+    return cmsGetDeviceClass(hProfile) == cmsSigLinkClass &&\n+            cmsGetColorSpace(hProfile) == cmsSigCmykData &&\n+            cmsGetColorSpace(hProfile) == cmsSigCmykData;\n+}\n+\n@@ -779,1 +789,2 @@\n-    while (lastProfilePos > 1)\n+    \/\/ Skip CMYK->CMYK devicelinks on ending\n+    while (is_cmyk_devicelink(hLastProfile))\n@@ -781,3 +792,1 @@\n-        hLastProfile = hProfiles[--lastProfilePos];\n-        if (cmsGetColorSpace(hLastProfile) != cmsSigCmykData ||\n-            cmsGetDeviceClass(hLastProfile) != cmsSigLinkClass)\n+        if (lastProfilePos < 2)\n@@ -785,0 +794,2 @@\n+\n+        hLastProfile = hProfiles[--lastProfilePos];\n@@ -787,0 +798,1 @@\n+\n@@ -803,1 +815,1 @@\n-                                     preservationProfilesCount,\n+        preservationProfilesCount,\n@@ -815,1 +827,1 @@\n-                                    preservationProfilesCount,\n+        preservationProfilesCount,\n@@ -1005,1 +1017,2 @@\n-    while (lastProfilePos > 1)\n+    \/\/ Skip CMYK->CMYK devicelinks on ending\n+    while (is_cmyk_devicelink(hLastProfile))\n@@ -1007,3 +1020,1 @@\n-        hLastProfile = hProfiles[--lastProfilePos];\n-        if (cmsGetColorSpace(hLastProfile) != cmsSigCmykData ||\n-            cmsGetDeviceClass(hLastProfile) != cmsSigLinkClass)\n+        if (lastProfilePos < 2)\n@@ -1011,0 +1022,2 @@\n+\n+        hLastProfile = hProfiles[--lastProfilePos];\n@@ -1180,2 +1193,1 @@\n-\n-    for (nIntents=0, pt = ctx->Intents; pt != NULL; pt = pt -> Next)\n+    for (nIntents=0, pt = DefaultIntents; pt != NULL; pt = pt -> Next)\n@@ -1194,1 +1206,1 @@\n-    for (nIntents=0, pt = DefaultIntents; pt != NULL; pt = pt -> Next)\n+    for (pt = ctx->Intents; pt != NULL; pt = pt -> Next)\n@@ -1206,0 +1218,1 @@\n+\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmscnvrt.c","additions":27,"deletions":14,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-\/\/ amount of memoy that can be reclaimed. This is mostly as a safety feature to prevent\n+\/\/ amount of memory that can be reclaimed. This is mostly as a safety feature to prevent\n@@ -124,1 +124,2 @@\n-    if (size > MAX_MEMORY_FOR_ALLOC) return NULL;  \/\/ Never allow over maximum\n+    \/\/ Never allow 0 or over maximum\n+    if (size == 0 || size > MAX_MEMORY_FOR_ALLOC) return NULL;\n@@ -266,1 +267,1 @@\n-    \/\/ context internal data should be malloce'd by using those functions.\n+    \/\/ context internal data should be malloc'ed by using those functions.\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmserr.c","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -332,0 +332,4 @@\n+    for (i=0; i < nSegments; i++) {\n+        if (p ->Segments && p ->Segments[i].SampledPoints) _cmsFree(ContextID, p ->Segments[i].SampledPoints);\n+        if (p ->SegInterp && p ->SegInterp[i]) _cmsFree(ContextID, p ->SegInterp[i]);\n+    }\n@@ -625,4 +629,10 @@\n-        if (e < 0)\n-            Val = Params[3];\n-        else\n-            Val = pow(e, Params[0]) + Params[3];\n+        \/\/ On gamma 1.0, don't clamp\n+        if (Params[0] == 1.0) {\n+            Val = e + Params[3];\n+        }\n+        else {\n+            if (e < 0)\n+                Val = Params[3];\n+            else\n+                Val = pow(e, Params[0]) + Params[3];\n+        }\n@@ -1523,0 +1533,1 @@\n+\/\/ Retrieve segments on tone curves\n@@ -1524,3 +1535,1 @@\n-\/\/ Retrieve parameters on one-segment tone curves\n-\n-cmsFloat64Number* CMSEXPORT cmsGetToneCurveParams(const cmsToneCurve* t)\n+const cmsCurveSegment* CMSEXPORT cmsGetToneCurveSegment(cmsInt32Number n, const cmsToneCurve* t)\n@@ -1530,2 +1539,2 @@\n-    if (t->nSegments != 1) return NULL;\n-    return t->Segments[0].Params;\n+    if (n < 0 || n >= (cmsInt32Number) t->nSegments) return NULL;\n+    return t->Segments + n;\n@@ -1533,0 +1542,1 @@\n+\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsgamma.c","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -251,1 +251,1 @@\n-    \/\/ Assume in-gamut by default.\n+    \/\/ Assume in-gamut by default. NEVER READ, USED FOR DEBUG PURPOSES.\n@@ -628,1 +628,1 @@\n-\/\/ The algorithm obtains Y from a syntetical gray R=G=B. Then least squares fitting is used to estimate gamma.\n+\/\/ The algorithm obtains Y from a synthetical gray R=G=B. Then least squares fitting is used to estimate gamma.\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsgmt.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -563,0 +563,14 @@\n+    \/\/ Set default CMM (that's me!)\n+    Icc ->CMM = lcmsSignature;\n+\n+    \/\/ Set default creator\n+    \/\/ Created by LittleCMS (that's me!)\n+    Icc ->creator = lcmsSignature;\n+\n+    \/\/ Set default platform\n+#ifdef CMS_IS_WINDOWS_\n+    Icc ->platform = cmsSigMicrosoft;\n+#else\n+    Icc ->platform = cmsSigMacintosh;\n+#endif\n+\n@@ -816,0 +830,1 @@\n+    Icc -> CMM             = _cmsAdjustEndianess32(Header.cmmId);\n@@ -821,0 +836,1 @@\n+    Icc -> platform        = (cmsPlatformSignature)_cmsAdjustEndianess32(Header.platform);\n@@ -925,1 +941,1 @@\n-    Header.cmmId       = _cmsAdjustEndianess32(lcmsSignature);\n+    Header.cmmId       = _cmsAdjustEndianess32(Icc ->CMM);\n@@ -937,5 +953,1 @@\n-#ifdef CMS_IS_WINDOWS_\n-    Header.platform    = (cmsPlatformSignature) _cmsAdjustEndianess32(cmsSigMicrosoft);\n-#else\n-    Header.platform    = (cmsPlatformSignature) _cmsAdjustEndianess32(cmsSigMacintosh);\n-#endif\n+    Header.platform    = (cmsPlatformSignature) _cmsAdjustEndianess32(Icc -> platform);\n@@ -957,2 +969,1 @@\n-    \/\/ Created by LittleCMS (that's me!)\n-    Header.creator      = _cmsAdjustEndianess32(lcmsSignature);\n+    Header.creator      = _cmsAdjustEndianess32(Icc ->creator);\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsio0.c","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -610,1 +610,1 @@\n-\/\/ Create an output MPE LUT from agiven profile. Version mismatches are handled here\n+\/\/ Create an output MPE LUT from a given profile. Version mismatches are handled here\n@@ -1059,0 +1059,10 @@\n+\n+cmsUInt32Number  CMSEXPORT cmsGetProfileInfoUTF8(cmsHPROFILE hProfile, cmsInfoType Info,\n+                                                          const char LanguageCode[3], const char CountryCode[3],\n+                                                          char* Buffer, cmsUInt32Number BufferSize)\n+{\n+    const cmsMLU* mlu = GetInfo(hProfile, Info);\n+    if (mlu == NULL) return 0;\n+\n+    return cmsMLUgetUTF8(mlu, LanguageCode, CountryCode, Buffer, BufferSize);\n+}\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsio1.c","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -507,0 +507,3 @@\n+    \/\/ Again, prevent overflow\n+    if (rv > UINT_MAX \/ 15) return 0;\n+\n@@ -846,1 +849,7 @@\n-    _cmsStageCLutData* clut = (_cmsStageCLutData*) mpe->Data;\n+    _cmsStageCLutData* clut;\n+\n+    if (mpe == NULL) return FALSE;\n+\n+    clut = (_cmsStageCLutData*)mpe->Data;\n+\n+    if (clut == NULL) return FALSE;\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmslut.c","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -232,0 +232,36 @@\n+}\n+\n+\n+\/\/ Convert from UTF8 to wchar, returns len.\n+static\n+cmsUInt32Number decodeUTF8(wchar_t* out, const char* in)\n+{\n+    cmsUInt32Number codepoint = 0;\n+    cmsUInt32Number size = 0;\n+\n+    while (*in)\n+    {\n+        cmsUInt8Number ch = (cmsUInt8Number) *in;\n+\n+        if (ch <= 0x7f)\n+        {\n+            codepoint = ch;\n+        }\n+        else if (ch <= 0xbf)\n+        {\n+            codepoint = (codepoint << 6) | (ch & 0x3f);\n+        }\n+        else if (ch <= 0xdf)\n+        {\n+            codepoint = ch & 0x1f;\n+        }\n+        else if (ch <= 0xef)\n+        {\n+            codepoint = ch & 0x0f;\n+        }\n+        else\n+        {\n+            codepoint = ch & 0x07;\n+        }\n+\n+        in++;\n@@ -233,0 +269,92 @@\n+        if (((*in & 0xc0) != 0x80) && (codepoint <= 0x10ffff))\n+        {\n+            if (sizeof(wchar_t) > 2)\n+            {\n+                if (out) *out++ = (wchar_t) codepoint;\n+                size++;\n+            }\n+            else\n+                if (codepoint > 0xffff)\n+                {\n+                    if (out)\n+                    {\n+                        *out++ = (wchar_t)(0xd800 + (codepoint >> 10));\n+                        *out++ = (wchar_t)(0xdc00 + (codepoint & 0x03ff));\n+                        size += 2;\n+                    }\n+                }\n+                else\n+                    if (codepoint < 0xd800 || codepoint >= 0xe000)\n+                    {\n+                        if (out) *out++ = (wchar_t) codepoint;\n+                        size++;\n+                    }\n+        }\n+    }\n+\n+    return size;\n+}\n+\n+\/\/ Convert from wchar_t to UTF8\n+static\n+cmsUInt32Number encodeUTF8(char* out, const wchar_t* in, cmsUInt32Number max_wchars, cmsUInt32Number max_chars)\n+{\n+    cmsUInt32Number codepoint = 0;\n+    cmsUInt32Number size = 0;\n+    cmsUInt32Number len_w = 0;\n+\n+    while (*in && len_w < max_wchars)\n+    {\n+        if (*in >= 0xd800 && *in <= 0xdbff)\n+            codepoint = ((*in - 0xd800) << 10) + 0x10000;\n+        else\n+        {\n+            if (*in >= 0xdc00 && *in <= 0xdfff)\n+                codepoint |= *in - 0xdc00;\n+            else\n+                codepoint = *in;\n+\n+            if (codepoint <= 0x7f)\n+            {\n+                if (out && (size + 1 < max_chars)) *out++ = (char)codepoint;\n+                size++;\n+            }\n+\n+            else if (codepoint <= 0x7ff)\n+            {\n+                if (out && (max_chars > 0) && (size + 2 < max_chars))\n+                {\n+                    *out++ = (char)(cmsUInt32Number)(0xc0 | ((codepoint >> 6) & 0x1f));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | (codepoint & 0x3f));\n+                }\n+                size += 2;\n+            }\n+            else if (codepoint <= 0xffff)\n+            {\n+                if (out && (max_chars > 0) && (size + 3 < max_chars))\n+                {\n+                    *out++ = (char)(cmsUInt32Number)(0xe0 | ((codepoint >> 12) & 0x0f));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | ((codepoint >> 6) & 0x3f));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | (codepoint & 0x3f));\n+                }\n+                size += 3;\n+            }\n+            else\n+            {\n+                if (out && (max_chars > 0) && (size + 4 < max_chars))\n+                {\n+                    *out++ = (char)(cmsUInt32Number)(0xf0 | ((codepoint >> 18) & 0x07));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | ((codepoint >> 12) & 0x3f));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | ((codepoint >> 6) & 0x3f));\n+                    *out++ = (char)(cmsUInt32Number)(0x80 | (codepoint & 0x3f));\n+                }\n+                size += 4;\n+            }\n+\n+            codepoint = 0;\n+        }\n+\n+        in++; len_w++;\n+    }\n+\n+    return size;\n@@ -239,1 +367,1 @@\n-    cmsUInt32Number i, len = (cmsUInt32Number) strlen(ASCIIString);\n+    cmsUInt32Number i, len = (cmsUInt32Number)strlen(ASCIIString);\n@@ -242,1 +370,1 @@\n-    cmsUInt16Number Lang  = strTo16(LanguageCode);\n+    cmsUInt16Number Lang = strTo16(LanguageCode);\n@@ -250,1 +378,2 @@\n-        len = 1;\n+        wchar_t empty = 0;\n+        return AddMLUBlock(mlu, sizeof(wchar_t), &empty, Lang, Cntry);\n@@ -253,1 +382,1 @@\n-    WStr = (wchar_t*) _cmsCalloc(mlu ->ContextID, len,  sizeof(wchar_t));\n+    WStr = (wchar_t*)_cmsCalloc(mlu->ContextID, len, sizeof(wchar_t));\n@@ -256,2 +385,2 @@\n-    for (i=0; i < len; i++)\n-        WStr[i] = (wchar_t) ASCIIString[i];\n+    for (i = 0; i < len; i++)\n+        WStr[i] = (wchar_t)ASCIIString[i];\n@@ -259,1 +388,1 @@\n-    rc = AddMLUBlock(mlu, len  * sizeof(wchar_t), WStr, Lang, Cntry);\n+    rc = AddMLUBlock(mlu, len * sizeof(wchar_t), WStr, Lang, Cntry);\n@@ -261,1 +390,1 @@\n-    _cmsFree(mlu ->ContextID, WStr);\n+    _cmsFree(mlu->ContextID, WStr);\n@@ -266,0 +395,33 @@\n+\/\/ Add an UTF8 entry. Do not add any \\0 termination (ICC1v43_2010-12.pdf page 61)\n+\/\/ In the case the user explicitly sets an empty string, we force a \\0\n+cmsBool CMSEXPORT cmsMLUsetUTF8(cmsMLU* mlu, const char LanguageCode[3], const char CountryCode[3], const char* UTF8String)\n+{\n+    cmsUInt32Number UTF8len;\n+    wchar_t* WStr;\n+    cmsBool  rc;\n+    cmsUInt16Number Lang  = strTo16(LanguageCode);\n+    cmsUInt16Number Cntry = strTo16(CountryCode);\n+\n+    if (mlu == NULL) return FALSE;\n+\n+    if (*UTF8String == '\\0')\n+    {\n+        wchar_t empty = 0;\n+        return AddMLUBlock(mlu, sizeof(wchar_t), &empty, Lang, Cntry);\n+    }\n+\n+    \/\/ Len excluding terminator 0\n+    UTF8len = decodeUTF8(NULL, UTF8String);\n+\n+    \/\/ Get space for dest\n+    WStr = (wchar_t*) _cmsCalloc(mlu ->ContextID, UTF8len,  sizeof(wchar_t));\n+    if (WStr == NULL) return FALSE;\n+\n+    decodeUTF8(WStr, UTF8String);\n+\n+    rc = AddMLUBlock(mlu, UTF8len  * sizeof(wchar_t), WStr, Lang, Cntry);\n+\n+    _cmsFree(mlu ->ContextID, WStr);\n+    return rc;\n+}\n+\n@@ -404,1 +566,1 @@\n-    return(wchar_t*) ((cmsUInt8Number*) mlu ->MemPool + v ->StrW);\n+    return (wchar_t*) ((cmsUInt8Number*) mlu ->MemPool + v ->StrW);\n@@ -442,2 +604,4 @@\n-        if (Wide[i] == 0)\n-            Buffer[i] = 0;\n+        wchar_t wc = Wide[i];\n+\n+        if (wc < 0xff)\n+            Buffer[i] = (char)wc;\n@@ -445,1 +609,1 @@\n-            Buffer[i] = (char) Wide[i];\n+            Buffer[i] = '?';\n@@ -453,0 +617,40 @@\n+\n+\/\/ Obtain a UTF8 representation of the wide string. Setting buffer to NULL returns the len\n+cmsUInt32Number CMSEXPORT cmsMLUgetUTF8(const cmsMLU* mlu,\n+                                       const char LanguageCode[3], const char CountryCode[3],\n+                                       char* Buffer, cmsUInt32Number BufferSize)\n+{\n+    const wchar_t *Wide;\n+    cmsUInt32Number  StrLen = 0;\n+    cmsUInt32Number UTF8len;\n+\n+    cmsUInt16Number Lang  = strTo16(LanguageCode);\n+    cmsUInt16Number Cntry = strTo16(CountryCode);\n+\n+    \/\/ Sanitize\n+    if (mlu == NULL) return 0;\n+\n+    \/\/ Get WideChar\n+    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);\n+    if (Wide == NULL) return 0;\n+\n+    UTF8len = encodeUTF8(NULL, Wide, StrLen \/ sizeof(wchar_t), BufferSize);\n+\n+    \/\/ Maybe we want only to know the len?\n+    if (Buffer == NULL) return UTF8len + 1; \/\/ Note the zero at the end\n+\n+    \/\/ No buffer size means no data\n+    if (BufferSize <= 0) return 0;\n+\n+    \/\/ Some clipping may be required\n+    if (BufferSize < UTF8len + 1)\n+        UTF8len = BufferSize - 1;\n+\n+    \/\/ Process it\n+    encodeUTF8(Buffer, Wide, StrLen \/ sizeof(wchar_t), BufferSize);\n+\n+    \/\/ We put a termination \"\\0\"\n+    Buffer[UTF8len] = 0;\n+    return UTF8len + 1;\n+}\n+\n@@ -473,2 +677,2 @@\n-  \/\/ No buffer size means no data\n-    if (BufferSize <= 0) return 0;\n+    \/\/ Invalid buffer size means no data\n+    if (BufferSize < sizeof(wchar_t)) return 0;\n@@ -478,1 +682,1 @@\n-        StrLen = BufferSize - + sizeof(wchar_t);\n+        StrLen = BufferSize - sizeof(wchar_t);\n@@ -846,4 +1050,11 @@\n-    for (i=0; i < pseq ->n; i++) {\n-        if (pseq ->seq[i].Manufacturer != NULL) cmsMLUfree(pseq ->seq[i].Manufacturer);\n-        if (pseq ->seq[i].Model != NULL) cmsMLUfree(pseq ->seq[i].Model);\n-        if (pseq ->seq[i].Description != NULL) cmsMLUfree(pseq ->seq[i].Description);\n+    if (pseq == NULL)\n+        return;\n+\n+    if (pseq ->seq != NULL) {\n+        for (i=0; i < pseq ->n; i++) {\n+            if (pseq ->seq[i].Manufacturer != NULL) cmsMLUfree(pseq ->seq[i].Manufacturer);\n+            if (pseq ->seq[i].Model != NULL) cmsMLUfree(pseq ->seq[i].Model);\n+            if (pseq ->seq[i].Description != NULL) cmsMLUfree(pseq ->seq[i].Description);\n+        }\n+\n+        _cmsFree(pseq ->ContextID, pseq ->seq);\n@@ -852,1 +1063,0 @@\n-    if (pseq ->seq != NULL) _cmsFree(pseq ->ContextID, pseq ->seq);\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsnamed.c","additions":230,"deletions":20,"binary":false,"changes":250,"status":"modified"},{"patch":"@@ -215,0 +215,1 @@\n+\n@@ -1145,1 +1146,4 @@\n-            Trans[t] ->Table16[i] = _cmsQuickSaturateWord(Out[t] * 65535.0);\n+        {\n+            if (Trans[t]->Table16 != NULL)\n+                Trans[t] ->Table16[i] = _cmsQuickSaturateWord(Out[t] * 65535.0);\n+        }\n@@ -1152,1 +1156,1 @@\n-    \/\/ Check for validity\n+    \/\/ Check for validity. lIsLinear is here for debug purposes\n@@ -1756,0 +1760,2 @@\n+                     if (Matrix1->InputChannels != 3 || Matrix1->OutputChannels != 3) return FALSE;\n+\n@@ -1800,1 +1806,1 @@\n-        \/\/ the cache that with the pixel handling\n+        \/\/ the cache than with the pixel handling\n@@ -1957,1 +1963,1 @@\n-        if (cmsStageType(mpe) == cmsSigNamedColorElemType) return FALSE;\n+            if (cmsStageType(mpe) == cmsSigNamedColorElemType) return FALSE;\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsopt.c","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2983,0 +2983,102 @@\n+static\n+cmsUInt8Number* PackBytesFromFloat(_cmsTRANSFORM* info,\n+                                    cmsFloat32Number wOut[],\n+                                    cmsUInt8Number* output,\n+                                    cmsUInt32Number Stride)\n+{\n+    cmsUInt32Number nChan = T_CHANNELS(info->OutputFormat);\n+    cmsUInt32Number DoSwap = T_DOSWAP(info->OutputFormat);\n+    cmsUInt32Number Reverse = T_FLAVOR(info->OutputFormat);\n+    cmsUInt32Number Extra = T_EXTRA(info->OutputFormat);\n+    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->OutputFormat);\n+    cmsUInt32Number Planar = T_PLANAR(info->OutputFormat);\n+    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n+    cmsUInt8Number* swap1 = (cmsUInt8Number*)output;\n+    cmsFloat64Number v = 0;\n+    cmsUInt8Number vv = 0;\n+    cmsUInt32Number i, start = 0;\n+\n+    if (ExtraFirst)\n+        start = Extra;\n+\n+    for (i = 0; i < nChan; i++) {\n+\n+        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n+\n+        v = wOut[index] * 65535.0;\n+\n+        if (Reverse)\n+            v = 65535.0 - v;\n+\n+        vv =  FROM_16_TO_8(_cmsQuickSaturateWord(v));\n+\n+        if (Planar)\n+            ((cmsUInt8Number*)output)[(i + start) * Stride] = vv;\n+        else\n+            ((cmsUInt8Number*)output)[i + start] = vv;\n+    }\n+\n+\n+    if (Extra == 0 && SwapFirst) {\n+\n+        memmove(swap1 + 1, swap1, (nChan - 1) * sizeof(cmsUInt8Number));\n+        *swap1 = vv;\n+    }\n+\n+    if (T_PLANAR(info->OutputFormat))\n+        return output + sizeof(cmsUInt8Number);\n+    else\n+        return output + (nChan + Extra) * sizeof(cmsUInt8Number);\n+}\n+\n+static\n+cmsUInt8Number* PackWordsFromFloat(_cmsTRANSFORM* info,\n+                                    cmsFloat32Number wOut[],\n+                                    cmsUInt8Number* output,\n+                                    cmsUInt32Number Stride)\n+{\n+    cmsUInt32Number nChan = T_CHANNELS(info->OutputFormat);\n+    cmsUInt32Number DoSwap = T_DOSWAP(info->OutputFormat);\n+    cmsUInt32Number Reverse = T_FLAVOR(info->OutputFormat);\n+    cmsUInt32Number Extra = T_EXTRA(info->OutputFormat);\n+    cmsUInt32Number SwapFirst = T_SWAPFIRST(info->OutputFormat);\n+    cmsUInt32Number Planar = T_PLANAR(info->OutputFormat);\n+    cmsUInt32Number ExtraFirst = DoSwap ^ SwapFirst;\n+    cmsUInt16Number* swap1 = (cmsUInt16Number*)output;\n+    cmsFloat64Number v = 0;\n+    cmsUInt16Number vv = 0;\n+    cmsUInt32Number i, start = 0;\n+\n+    if (ExtraFirst)\n+        start = Extra;\n+\n+    for (i = 0; i < nChan; i++) {\n+\n+        cmsUInt32Number index = DoSwap ? (nChan - i - 1) : i;\n+\n+        v = wOut[index] * 65535.0;\n+\n+        if (Reverse)\n+            v = 65535.0 - v;\n+\n+        vv = _cmsQuickSaturateWord(v);\n+\n+        if (Planar)\n+            ((cmsUInt16Number*)output)[(i + start) * Stride] = vv;\n+        else\n+            ((cmsUInt16Number*)output)[i + start] = vv;\n+    }\n+\n+    if (Extra == 0 && SwapFirst) {\n+\n+        memmove(swap1 + 1, swap1, (nChan - 1) * sizeof(cmsUInt16Number));\n+        *swap1 = vv;\n+    }\n+\n+    if (T_PLANAR(info->OutputFormat))\n+        return output + sizeof(cmsUInt16Number);\n+    else\n+        return output + (nChan + Extra) * sizeof(cmsUInt16Number);\n+}\n+\n+\n@@ -3146,0 +3248,71 @@\n+static\n+cmsUInt8Number* PackEncodedBytesLabV2FromFloat(_cmsTRANSFORM* Info,\n+                                           cmsFloat32Number wOut[],\n+                                           cmsUInt8Number* output,\n+                                           cmsUInt32Number Stride)\n+{\n+    cmsCIELab Lab;\n+    cmsUInt16Number wlab[3];\n+\n+    Lab.L = (cmsFloat64Number)(wOut[0] * 100.0);\n+    Lab.a = (cmsFloat64Number)(wOut[1] * 255.0 - 128.0);\n+    Lab.b = (cmsFloat64Number)(wOut[2] * 255.0 - 128.0);\n+\n+    cmsFloat2LabEncoded(wlab, &Lab);\n+\n+    if (T_PLANAR(Info -> OutputFormat)) {\n+\n+        Stride \/= PixelSize(Info->OutputFormat);\n+\n+        output[0]        = wlab[0] >> 8;\n+        output[Stride]   = wlab[1] >> 8;\n+        output[Stride*2] = wlab[2] >> 8;\n+\n+        return output + 1;\n+    }\n+    else {\n+\n+        output[0] = wlab[0] >> 8;\n+        output[1] = wlab[1] >> 8;\n+        output[2] = wlab[2] >> 8;\n+\n+        return output + (3 + T_EXTRA(Info ->OutputFormat));\n+    }\n+}\n+\n+static\n+cmsUInt8Number* PackEncodedWordsLabV2FromFloat(_cmsTRANSFORM* Info,\n+                                           cmsFloat32Number wOut[],\n+                                           cmsUInt8Number* output,\n+                                           cmsUInt32Number Stride)\n+{\n+    cmsCIELab Lab;\n+    cmsUInt16Number wlab[3];\n+\n+    Lab.L = (cmsFloat64Number)(wOut[0] * 100.0);\n+    Lab.a = (cmsFloat64Number)(wOut[1] * 255.0 - 128.0);\n+    Lab.b = (cmsFloat64Number)(wOut[2] * 255.0 - 128.0);\n+\n+    cmsFloat2LabEncodedV2(wlab, &Lab);\n+\n+    if (T_PLANAR(Info -> OutputFormat)) {\n+\n+        Stride \/= PixelSize(Info->OutputFormat);\n+\n+        ((cmsUInt16Number*) output)[0]        = wlab[0];\n+        ((cmsUInt16Number*) output)[Stride]   = wlab[1];\n+        ((cmsUInt16Number*) output)[Stride*2] = wlab[2];\n+\n+        return output + sizeof(cmsUInt16Number);\n+    }\n+    else {\n+\n+         ((cmsUInt16Number*) output)[0] = wlab[0];\n+         ((cmsUInt16Number*) output)[1] = wlab[1];\n+         ((cmsUInt16Number*) output)[2] = wlab[2];\n+\n+        return output + (3 + T_EXTRA(Info ->OutputFormat)) * sizeof(cmsUInt16Number);\n+    }\n+}\n+\n+\n@@ -3679,0 +3852,3 @@\n+    {     TYPE_LabV2_8,                                                ANYPLANAR|ANYEXTRA,   PackEncodedBytesLabV2FromFloat},\n+    {     TYPE_LabV2_16,                                               ANYPLANAR|ANYEXTRA,   PackEncodedWordsLabV2FromFloat},\n+\n@@ -3683,0 +3859,7 @@\n+\n+    {     BYTES_SH(2), ANYPLANAR|\n+                             ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYEXTRA|ANYCHANNELS|ANYSPACE,   PackWordsFromFloat },\n+\n+    {     BYTES_SH(1), ANYPLANAR|\n+                             ANYFLAVOR|ANYSWAPFIRST|ANYSWAP|ANYEXTRA|ANYCHANNELS|ANYSPACE,   PackBytesFromFloat },\n+\n@@ -3893,1 +4076,1 @@\n-    cmsUInt32Number nOutputChans = cmsChannelsOf(ColorSpace);\n+    cmsInt32Number  nOutputChans = cmsChannelsOfColorSpace(ColorSpace);\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmspack.c","additions":184,"deletions":1,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -396,6 +396,1 @@\n-       cmsUInt8Number  msb, lsb;\n-\n-       lsb = (cmsUInt8Number) (fixed8 & 0xff);\n-       msb = (cmsUInt8Number) (((cmsUInt16Number) fixed8 >> 8) & 0xff);\n-\n-       return (cmsFloat64Number) ((cmsFloat64Number) msb + ((cmsFloat64Number) lsb \/ 256.0));\n+    return fixed8 \/ 256.0;\n@@ -413,13 +408,1 @@\n-    cmsFloat64Number floater, sign, mid;\n-    int Whole, FracPart;\n-\n-    sign  = (fix32 < 0 ? -1 : 1);\n-    fix32 = abs(fix32);\n-\n-    Whole     = (cmsUInt16Number)(fix32 >> 16) & 0xffff;\n-    FracPart  = (cmsUInt16Number)(fix32 & 0xffff);\n-\n-    mid     = (cmsFloat64Number) FracPart \/ 65536.0;\n-    floater = (cmsFloat64Number) Whole + mid;\n-\n-    return sign * floater;\n+    return fix32 \/ 65536.0;\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsplugin.c","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -463,6 +463,0 @@\n-static\n-void EmitSafeGuardBegin(cmsIOHANDLER* m, const char* name)\n-{\n-    _cmsIOPrintf(m, \"%%LCMS2: Save previous definition of %s on the operand stack\\n\", name);\n-    _cmsIOPrintf(m, \"currentdict \/%s known { \/%s load } { null } ifelse\\n\", name, name);\n-}\n@@ -470,10 +464,0 @@\n-static\n-void EmitSafeGuardEnd(cmsIOHANDLER* m, const char* name, int depth)\n-{\n-    _cmsIOPrintf(m, \"%%LCMS2: Restore previous definition of %s\\n\", name);\n-    if (depth > 1) {\n-        \/\/ cycle topmost items on the stack to bring the previous definition to the front\n-        _cmsIOPrintf(m, \"%d -1 roll \", depth);\n-    }\n-    _cmsIOPrintf(m, \"dup null eq { pop currentdict \/%s undef } { \/%s exch def } ifelse\\n\", name, name);\n-}\n@@ -484,1 +468,1 @@\n-void Emit1Gamma(cmsIOHANDLER* m, cmsToneCurve* Table, const char* name)\n+void Emit1Gamma(cmsIOHANDLER* m, cmsToneCurve* Table)\n@@ -489,1 +473,6 @@\n-    if (Table == NULL) return; \/\/ Error\n+    \/**\n+    * On error, empty tables or lienar assume gamma 1.0\n+    *\/\n+    if (Table == NULL ||\n+        Table->nEntries <= 0 ||\n+        cmsIsToneCurveLinear(Table)) {\n@@ -491,1 +480,3 @@\n-    if (Table ->nEntries <= 0) return;  \/\/ Empty table\n+        _cmsIOPrintf(m, \"{ 1 } bind \");\n+        return;\n+    }\n@@ -493,2 +484,0 @@\n-    \/\/ Suppress whole if identity\n-    if (cmsIsToneCurveLinear(Table)) return;\n@@ -499,1 +488,1 @@\n-            _cmsIOPrintf(m, \"\/%s { %g exp } bind def\\n\", name, gamma);\n+            _cmsIOPrintf(m, \"{ %g exp } bind \", gamma);\n@@ -503,2 +492,11 @@\n-    EmitSafeGuardBegin(m, \"lcms2gammatable\");\n-    _cmsIOPrintf(m, \"\/lcms2gammatable [\");\n+    _cmsIOPrintf(m, \"{ \");\n+\n+    \/\/ Bounds check\n+    EmitRangeCheck(m);\n+\n+    \/\/ Emit intepolation code\n+\n+    \/\/ PostScript code                      Stack\n+    \/\/ ===============                      ========================\n+                                            \/\/ v\n+    _cmsIOPrintf(m, \" [\");\n@@ -512,1 +510,1 @@\n-    _cmsIOPrintf(m, \"] def\\n\");\n+    _cmsIOPrintf(m, \"] \");                        \/\/ v tab\n@@ -514,12 +512,0 @@\n-\n-    \/\/ Emit interpolation code\n-\n-    \/\/ PostScript code                            Stack\n-    \/\/ ===============                            ========================\n-                                                  \/\/ v\n-    _cmsIOPrintf(m, \"\/%s {\\n  \", name);\n-\n-    \/\/ Bounds check\n-    EmitRangeCheck(m);\n-\n-    _cmsIOPrintf(m, \"\\n  \/\/lcms2gammatable \");    \/\/ v tab\n@@ -552,3 +538,1 @@\n-    _cmsIOPrintf(m, \"} bind def\\n\");\n-\n-    EmitSafeGuardEnd(m, \"lcms2gammatable\", 1);\n+    _cmsIOPrintf(m, \" } bind \");\n@@ -571,1 +555,1 @@\n-void EmitNGamma(cmsIOHANDLER* m, cmsUInt32Number n, cmsToneCurve* g[], const char* nameprefix)\n+void EmitNGamma(cmsIOHANDLER* m, cmsUInt32Number n, cmsToneCurve* g[])\n@@ -574,1 +558,1 @@\n-    static char buffer[2048];\n+\n@@ -582,1 +566,1 @@\n-            _cmsIOPrintf(m, \"\/%s%d \/%s%d load def\\n\", nameprefix, i, nameprefix, i-1);\n+            _cmsIOPrintf(m, \"dup \");\n@@ -585,3 +569,1 @@\n-            snprintf(buffer, sizeof(buffer), \"%s%d\", nameprefix, (int) i);\n-        buffer[sizeof(buffer)-1] = '\\0';\n-            Emit1Gamma(m, g[i], buffer);\n+            Emit1Gamma(m, g[i]);\n@@ -711,1 +693,1 @@\n-    _cmsIOPrintf(m, \"[\");\n+    if (sc.Pipeline != NULL && sc.Pipeline->Params != NULL) {\n@@ -713,2 +695,1 @@\n-    for (i=0; i < sc.Pipeline->Params->nInputs; i++)\n-        _cmsIOPrintf(m, \" %d \", sc.Pipeline->Params->nSamples[i]);\n+        _cmsIOPrintf(m, \"[\");\n@@ -716,1 +697,2 @@\n-    _cmsIOPrintf(m, \" [\\n\");\n+        for (i = 0; i < sc.Pipeline->Params->nInputs; i++)\n+            _cmsIOPrintf(m, \" %d \", sc.Pipeline->Params->nSamples[i]);\n@@ -718,1 +700,1 @@\n-    cmsStageSampleCLut16bit(mpe, OutputValueSampler, (void*) &sc, SAMPLER_INSPECT);\n+        _cmsIOPrintf(m, \" [\\n\");\n@@ -720,3 +702,6 @@\n-    _cmsIOPrintf(m, PostMin);\n-    _cmsIOPrintf(m, PostMaj);\n-    _cmsIOPrintf(m, \"] \");\n+        cmsStageSampleCLut16bit(mpe, OutputValueSampler, (void*)&sc, SAMPLER_INSPECT);\n+\n+        _cmsIOPrintf(m, PostMin);\n+        _cmsIOPrintf(m, PostMaj);\n+        _cmsIOPrintf(m, \"] \");\n+    }\n@@ -736,2 +721,3 @@\n-    EmitSafeGuardBegin(m, \"lcms2gammaproc\");\n-    Emit1Gamma(m, Curve, \"lcms2gammaproc\");\n+    _cmsIOPrintf(m, \"\/DecodeA \");\n+\n+    Emit1Gamma(m, Curve);\n@@ -739,2 +725,1 @@\n-    _cmsIOPrintf(m, \"\/DecodeA \/lcms2gammaproc load\\n\");\n-    EmitSafeGuardEnd(m, \"lcms2gammaproc\", 3);\n+    _cmsIOPrintf(m, \" \\n\");\n@@ -764,0 +749,3 @@\n+    _cmsIOPrintf(m, \"\/DecodeABC [ \");\n+\n+    EmitNGamma(m, 3, CurveSet);\n@@ -765,8 +753,0 @@\n-    EmitSafeGuardBegin(m, \"lcms2gammaproc0\");\n-    EmitSafeGuardBegin(m, \"lcms2gammaproc1\");\n-    EmitSafeGuardBegin(m, \"lcms2gammaproc2\");\n-    EmitNGamma(m, 3, CurveSet, \"lcms2gammaproc\");\n-    _cmsIOPrintf(m, \"\/DecodeABC [\\n\");\n-    _cmsIOPrintf(m, \"   \/lcms2gammaproc0 load\\n\");\n-    _cmsIOPrintf(m, \"   \/lcms2gammaproc1 load\\n\");\n-    _cmsIOPrintf(m, \"   \/lcms2gammaproc2 load\\n\");\n@@ -774,3 +754,0 @@\n-    EmitSafeGuardEnd(m, \"lcms2gammaproc2\", 3);\n-    EmitSafeGuardEnd(m, \"lcms2gammaproc1\", 3);\n-    EmitSafeGuardEnd(m, \"lcms2gammaproc0\", 3);\n@@ -808,1 +785,1 @@\n-    const char* PreMin, * PostMin;\n+    const char* PreMin, *PostMin;\n@@ -810,2 +787,0 @@\n-    int i, numchans;\n-    static char buffer[2048];\n@@ -840,13 +815,2 @@\n-        numchans = (int) cmsStageOutputChannels(mpe);\n-        for (i = 0; i < numchans; ++i) {\n-            snprintf(buffer, sizeof(buffer), \"lcms2gammaproc%d\", i);\n-            buffer[sizeof(buffer) - 1] = '\\0';\n-            EmitSafeGuardBegin(m, buffer);\n-        }\n-        EmitNGamma(m, cmsStageOutputChannels(mpe), _cmsStageGetPtrToCurveSet(mpe), \"lcms2gammaproc\");\n-        _cmsIOPrintf(m, \"\/DecodeDEF [\\n\");\n-        for (i = 0; i < numchans; ++i) {\n-            snprintf(buffer, sizeof(buffer), \"  \/lcms2gammaproc%d load\\n\", i);\n-            buffer[sizeof(buffer) - 1] = '\\0';\n-            _cmsIOPrintf(m, buffer);\n-        }\n+        _cmsIOPrintf(m, \"\/DecodeDEF [ \");\n+        EmitNGamma(m, cmsStageOutputChannels(mpe), _cmsStageGetPtrToCurveSet(mpe));\n@@ -854,5 +818,0 @@\n-        for (i = numchans - 1; i >= 0; --i) {\n-            snprintf(buffer, sizeof(buffer), \"lcms2gammaproc%d\", i);\n-            buffer[sizeof(buffer) - 1] = '\\0';\n-            EmitSafeGuardEnd(m, buffer, 3);\n-        }\n@@ -860,1 +819,1 @@\n-        mpe = mpe->Next;\n+        mpe = mpe ->Next;\n@@ -865,3 +824,3 @@\n-        _cmsIOPrintf(m, \"\/Table \");\n-        WriteCLUT(m, mpe, PreMaj, PostMaj, PreMin, PostMin, FALSE, (cmsColorSpaceSignature)0);\n-        _cmsIOPrintf(m, \"]\\n\");\n+            _cmsIOPrintf(m, \"\/Table \");\n+            WriteCLUT(m, mpe, PreMaj, PostMaj, PreMin, PostMin, FALSE, (cmsColorSpaceSignature) 0);\n+            _cmsIOPrintf(m, \"]\\n\");\n@@ -1027,3 +986,3 @@\n-            rc = EmitCIEBasedABC(m, (cmsFloat64Number *)&Mat,\n-                _cmsStageGetPtrToCurveSet(Shaper),\n-                &BlackPointAdaptedToD50);\n+            rc = EmitCIEBasedABC(m,  (cmsFloat64Number *) &Mat,\n+                                _cmsStageGetPtrToCurveSet(Shaper),\n+                                 &BlackPointAdaptedToD50);\n@@ -1056,0 +1015,2 @@\n+    cmsCloseProfile(hLab);\n+\n@@ -1059,1 +1020,4 @@\n-    if (NamedColorList == NULL) return 0;\n+    if (NamedColorList == NULL) {\n+        cmsDeleteTransform(xform);\n+        return 0;\n+    }\n@@ -1068,1 +1032,0 @@\n-\n@@ -1083,2 +1046,0 @@\n-\n-\n@@ -1088,1 +1049,0 @@\n-    cmsCloseProfile(hLab);\n@@ -1342,1 +1302,1 @@\n-\n+    cmsStage* first;\n@@ -1369,1 +1329,0 @@\n-\n@@ -1377,2 +1336,4 @@\n-    if (DeviceLink == NULL) return 0;\n-\n+    if (DeviceLink == NULL) {\n+        cmsDeleteTransform(xform);\n+        return 0;\n+    }\n@@ -1380,1 +1341,1 @@\n-    \/\/ We need a CLUT\n+     \/\/ We need a CLUT\n@@ -1407,2 +1368,4 @@\n-\n-    WriteCLUT(m, cmsPipelineGetPtrToFirstStage(DeviceLink), \"<\", \">\\n\", \"\", \"\", lFixWhite, ColorSpace);\n+    first = cmsPipelineGetPtrToFirstStage(DeviceLink);\n+    if (first != NULL) {\n+        WriteCLUT(m, first, \"<\", \">\\n\", \"\", \"\", lFixWhite, ColorSpace);\n+    }\n@@ -1417,1 +1380,0 @@\n-\n@@ -1480,1 +1442,4 @@\n-    if (NamedColorList == NULL) return 0;\n+    if (NamedColorList == NULL) {\n+        cmsDeleteTransform(xform);\n+        return 0;\n+    }\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsps2.c","additions":76,"deletions":111,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-    \/\/ Force it to be neutral, check for inconsistences\n+    \/\/ Force it to be neutral, check for inconsistencies\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmssamp.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-\/\/ Return handler for a given type or NULL if not found. Shared between normal types and MPE. It first tries the additons\n+\/\/ Return handler for a given type or NULL if not found. Shared between normal types and MPE. It first tries the additions\n@@ -957,0 +957,1 @@\n+    wchar_t* UnicodeString = NULL;\n@@ -976,1 +977,1 @@\n-    mlu = cmsMLUalloc(self ->ContextID, 1);\n+    mlu = cmsMLUalloc(self ->ContextID, 2);\n@@ -1001,1 +1002,11 @@\n-    if (SizeOfTag < UnicodeCount*sizeof(cmsUInt16Number)) goto Done;\n+    if (UnicodeCount == 0 || SizeOfTag < UnicodeCount*sizeof(cmsUInt16Number)) goto Done;\n+\n+    UnicodeString = (wchar_t*)_cmsMallocZero(self->ContextID, (UnicodeCount + 1) * sizeof(wchar_t));\n+    if (UnicodeString == NULL) goto Done;\n+\n+    if (!_cmsReadWCharArray(io, UnicodeCount, UnicodeString)) {\n+        _cmsFree(self->ContextID, (void*)UnicodeString);\n+        goto Done;\n+    }\n+\n+    UnicodeString[UnicodeCount] = 0;\n@@ -1003,2 +1014,3 @@\n-    for (i=0; i < UnicodeCount; i++) {\n-        if (!io ->Read(io, &Dummy, sizeof(cmsUInt16Number), 1)) goto Done;\n+    if (!cmsMLUsetWide(mlu, cmsV2Unicode, cmsV2Unicode, UnicodeString)) {\n+        _cmsFree(self->ContextID, (void*)UnicodeString);\n+        goto Done;\n@@ -1006,0 +1018,4 @@\n+\n+    _cmsFree(self->ContextID, (void*)UnicodeString);\n+    UnicodeString = NULL;\n+\n@@ -1009,1 +1025,1 @@\n-    \/\/ data that stricttly required. We need to skip it as this type may come\n+    \/\/ data that strictly required. We need to skip it as this type may come\n@@ -1029,0 +1045,1 @@\n+    if (UnicodeString)  _cmsFree(self->ContextID, (void*)UnicodeString);\n@@ -1081,1 +1098,1 @@\n-        cmsMLUgetWide(mlu,  cmsNoLanguage, cmsNoCountry,  Wide, len * sizeof(wchar_t));\n+        cmsMLUgetWide(mlu,  cmsV2Unicode,  cmsV2Unicode,  Wide, len * sizeof(wchar_t));\n@@ -1580,2 +1597,0 @@\n-        NumOfWchar = 0;\n-\n@@ -1943,1 +1958,1 @@\n-cmsBool  Type_LUT8_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n+cmsBool Type_LUT8_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n@@ -1956,0 +1971,6 @@\n+\n+    if (mpe == NULL) {  \/\/ Should never be empty. Corrupted?\n+        cmsSignalError(self->ContextID, cmsERROR_UNKNOWN_EXTENSION, \"empty LUT8 is not supported\");\n+        return FALSE;\n+    }\n+\n@@ -2697,2 +2718,2 @@\n-        if ((Curves[i] ->nSegments == 0)||\n-            ((Curves[i]->nSegments == 2) && (Curves[i] ->Segments[1].Type == 0)) )\n+        if ((Curves[i] ->nSegments == 0) ||                                         \/\/ 16 bits tabulated\n+            ((Curves[i]->nSegments == 3) && (Curves[i] ->Segments[1].Type == 0)) )  \/\/ Floating-point tabulated\n@@ -4462,2 +4483,2 @@\n-    if (InputChans == 0) goto Error;\n-    if (OutputChans == 0) goto Error;\n+    if (InputChans == 0 || InputChans >= cmsMAXCHANNELS) goto Error;\n+    if (OutputChans == 0 || OutputChans >= cmsMAXCHANNELS) goto Error;\n@@ -5253,1 +5274,2 @@\n-    e ->Offsets[i] = Before - BaseOffset;\n+    if (e->Offsets != NULL)\n+        e ->Offsets[i] = Before - BaseOffset;\n@@ -5257,1 +5279,2 @@\n-    e ->Sizes[i] = io ->Tell(io) - Before;\n+    if (e->Sizes != NULL)\n+        e ->Sizes[i] = io ->Tell(io) - Before;\n@@ -5502,0 +5525,210 @@\n+\n+\/\/ ********************************************************************************\n+\/\/ Microsoft's MHC2 Type support\n+\/\/ ********************************************************************************\n+\n+static\n+void SetIdentity(cmsFloat64Number XYZ2XYZmatrix[3][4])\n+{\n+    XYZ2XYZmatrix[0][0] = 1.0; XYZ2XYZmatrix[0][1] = 0.0; XYZ2XYZmatrix[0][2] = 0.0; XYZ2XYZmatrix[0][3] = 0.0;\n+    XYZ2XYZmatrix[1][0] = 0.0; XYZ2XYZmatrix[1][1] = 1.0; XYZ2XYZmatrix[1][2] = 0.0; XYZ2XYZmatrix[1][3] = 0.0;\n+    XYZ2XYZmatrix[2][0] = 0.0; XYZ2XYZmatrix[2][1] = 0.0; XYZ2XYZmatrix[2][2] = 1.0; XYZ2XYZmatrix[2][3] = 0.0;\n+}\n+\n+static\n+cmsBool CloseEnough(cmsFloat64Number a, cmsFloat64Number b)\n+{\n+    return fabs(b - a) < (1.0 \/ 65535.0);\n+}\n+\n+cmsBool IsIdentity(cmsFloat64Number XYZ2XYZmatrix[3][4])\n+{\n+    cmsFloat64Number Identity[3][4];\n+    int i, j;\n+\n+    SetIdentity(Identity);\n+\n+    for (i = 0; i < 3; i++)\n+        for (j = 0; j < 4; j++)\n+            if (!CloseEnough(XYZ2XYZmatrix[i][j], Identity[i][j])) return FALSE;\n+\n+    return TRUE;\n+}\n+\n+static\n+void Type_MHC2_Free(struct _cms_typehandler_struct* self, void* Ptr)\n+{\n+    cmsMHC2Type* mhc2 = (cmsMHC2Type*)Ptr;\n+\n+    if (mhc2->RedCurve != NULL) _cmsFree(self->ContextID, mhc2->RedCurve);\n+    if (mhc2->GreenCurve != NULL) _cmsFree(self->ContextID, mhc2->GreenCurve);\n+    if (mhc2->BlueCurve != NULL) _cmsFree(self->ContextID, mhc2->BlueCurve);\n+\n+    _cmsFree(self->ContextID, Ptr);\n+}\n+\n+void* Type_MHC2_Dup(struct _cms_typehandler_struct* self, const void* Ptr, cmsUInt32Number n)\n+{\n+    cmsMHC2Type* mhc2 = _cmsDupMem(self->ContextID, Ptr, sizeof(cmsMHC2Type));\n+\n+    mhc2->RedCurve = _cmsDupMem(self->ContextID,   mhc2->RedCurve, mhc2->CurveEntries*sizeof(cmsFloat64Number));\n+    mhc2->GreenCurve = _cmsDupMem(self->ContextID, mhc2->GreenCurve, mhc2->CurveEntries * sizeof(cmsFloat64Number));\n+    mhc2->BlueCurve = _cmsDupMem(self->ContextID,  mhc2->BlueCurve, mhc2->CurveEntries * sizeof(cmsFloat64Number));\n+\n+    if (mhc2->RedCurve == NULL ||\n+        mhc2->GreenCurve == NULL ||\n+        mhc2->BlueCurve == NULL) {\n+\n+        Type_MHC2_Free(self, mhc2);\n+        return NULL;\n+    }\n+\n+    return mhc2;\n+\n+    cmsUNUSED_PARAMETER(n);\n+}\n+\n+\n+static\n+cmsBool WriteDoubles(cmsIOHANDLER* io, cmsUInt32Number n, cmsFloat64Number* Values)\n+{\n+    cmsUInt32Number i;\n+\n+    for (i = 0; i < n; i++) {\n+\n+        if (!_cmsWrite15Fixed16Number(io, *Values++)) return FALSE;\n+    }\n+\n+    return TRUE;\n+}\n+\n+static\n+cmsBool Type_MHC2_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n+{\n+    cmsMHC2Type* mhc2 = (cmsMHC2Type*)Ptr;\n+    cmsUInt32Number BaseOffset = io->Tell(io) - sizeof(_cmsTagBase);\n+    cmsUInt32Number TablesOffsetPos;\n+    cmsUInt32Number MatrixOffset;\n+    cmsUInt32Number OffsetRedTable, OffsetGreenTable, OffsetBlueTable;\n+\n+    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;\n+    if (!_cmsWriteUInt32Number(io, mhc2->CurveEntries)) return FALSE;\n+\n+    if (!_cmsWrite15Fixed16Number(io, mhc2->MinLuminance)) return FALSE;\n+    if (!_cmsWrite15Fixed16Number(io, mhc2->PeakLuminance)) return FALSE;\n+\n+    TablesOffsetPos = io->Tell(io);\n+\n+    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;    \/\/ Matrix\n+    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;    \/\/ Curve R\n+    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;    \/\/ Curve G\n+    if (!_cmsWriteUInt32Number(io, 0)) return FALSE;    \/\/ Curve B\n+\n+\n+    if (IsIdentity(mhc2->XYZ2XYZmatrix))\n+    {\n+        MatrixOffset = 0;\n+    }\n+    else\n+    {\n+        MatrixOffset = io->Tell(io) - BaseOffset;\n+        if (!WriteDoubles(io, 3 * 4, &mhc2->XYZ2XYZmatrix[0][0])) return FALSE;\n+    }\n+\n+    OffsetRedTable = io->Tell(io) - BaseOffset;\n+    if (!WriteDoubles(io, mhc2->CurveEntries, mhc2->RedCurve)) return FALSE;\n+    OffsetGreenTable = io->Tell(io) - BaseOffset;\n+    if (!WriteDoubles(io, mhc2->CurveEntries, mhc2->GreenCurve)) return FALSE;\n+    OffsetBlueTable = io->Tell(io) - BaseOffset;\n+    if (!WriteDoubles(io, mhc2->CurveEntries, mhc2->BlueCurve)) return FALSE;\n+\n+    if (!io->Seek(io, TablesOffsetPos)) return FALSE;\n+\n+    if (!_cmsWriteUInt32Number(io, MatrixOffset)) return FALSE;\n+    if (!_cmsWriteUInt32Number(io, OffsetRedTable)) return FALSE;\n+    if (!_cmsWriteUInt32Number(io, OffsetGreenTable)) return FALSE;\n+    if (!_cmsWriteUInt32Number(io, OffsetBlueTable)) return FALSE;\n+\n+    return TRUE;\n+\n+    cmsUNUSED_PARAMETER(self);\n+    cmsUNUSED_PARAMETER(nItems);\n+}\n+\n+\n+static\n+cmsBool ReadDoublesAt(cmsIOHANDLER* io, cmsUInt32Number At, cmsUInt32Number n, cmsFloat64Number* Values)\n+{\n+    cmsUInt32Number CurrentPos = io->Tell(io);\n+    cmsUInt32Number i;\n+\n+    if (!io->Seek(io, At)) return FALSE;\n+\n+    for (i = 0; i < n; i++) {\n+\n+        if (!_cmsRead15Fixed16Number(io, Values++)) return FALSE;\n+    }\n+\n+    if (!io->Seek(io, CurrentPos)) return FALSE;\n+\n+    return TRUE;\n+}\n+\n+static\n+void* Type_MHC2_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n+{\n+    cmsMHC2Type* mhc2 = NULL;\n+\n+    cmsUInt32Number BaseOffset = io->Tell(io) - sizeof(_cmsTagBase);\n+    cmsUInt32Number MatrixOffset;\n+    cmsUInt32Number OffsetRedTable, OffsetGreenTable, OffsetBlueTable;\n+\n+    if (!_cmsReadUInt32Number(io, NULL)) return NULL;\n+\n+    mhc2 = (cmsMHC2Type*)_cmsCalloc(self->ContextID, 1, sizeof(cmsMHC2Type));\n+    if (mhc2 == NULL) return NULL;\n+\n+    if (!_cmsReadUInt32Number(io,    &mhc2->CurveEntries)) goto Error;\n+\n+    if (mhc2->CurveEntries > 4096) goto Error;\n+\n+    mhc2->RedCurve = (cmsFloat64Number*)_cmsCalloc(self->ContextID, mhc2->CurveEntries, sizeof(cmsFloat64Number));\n+    mhc2->GreenCurve = (cmsFloat64Number*)_cmsCalloc(self->ContextID, mhc2->CurveEntries, sizeof(cmsFloat64Number));\n+    mhc2->BlueCurve = (cmsFloat64Number*)_cmsCalloc(self->ContextID, mhc2->CurveEntries, sizeof(cmsFloat64Number));\n+\n+    if (mhc2->RedCurve == NULL ||\n+        mhc2->GreenCurve == NULL ||\n+        mhc2->BlueCurve == NULL)  goto Error;\n+\n+    if (!_cmsRead15Fixed16Number(io, &mhc2->MinLuminance)) goto Error;\n+    if (!_cmsRead15Fixed16Number(io, &mhc2->PeakLuminance)) goto Error;\n+\n+    if (!_cmsReadUInt32Number(io, &MatrixOffset)) goto Error;\n+    if (!_cmsReadUInt32Number(io, &OffsetRedTable)) goto Error;\n+    if (!_cmsReadUInt32Number(io, &OffsetGreenTable)) goto Error;\n+    if (!_cmsReadUInt32Number(io, &OffsetBlueTable)) goto Error;\n+\n+    if (MatrixOffset == 0)\n+        SetIdentity(mhc2->XYZ2XYZmatrix);\n+    else\n+    {\n+        if (!ReadDoublesAt(io, BaseOffset + MatrixOffset, 3*4, &mhc2->XYZ2XYZmatrix[0][0])) goto Error;\n+    }\n+\n+    if (!ReadDoublesAt(io, BaseOffset + OffsetRedTable, mhc2->CurveEntries, mhc2->RedCurve)) goto Error;\n+    if (!ReadDoublesAt(io, BaseOffset + OffsetGreenTable, mhc2->CurveEntries, mhc2->GreenCurve)) goto Error;\n+    if (!ReadDoublesAt(io, BaseOffset + OffsetBlueTable, mhc2->CurveEntries, mhc2->BlueCurve)) goto Error;\n+\n+    \/\/ Success\n+    *nItems = 1;\n+    return mhc2;\n+\n+Error:\n+    Type_MHC2_Free(self, mhc2);\n+    return NULL;\n+\n+    cmsUNUSED_PARAMETER(SizeOfTag);\n+}\n+\n+\n+\n@@ -5541,1 +5774,2 @@\n-{TYPE_HANDLER(cmsSigVcgtType,                  vcgt),                NULL }\n+{TYPE_HANDLER(cmsSigVcgtType,                  vcgt),               (_cmsTagTypeLinkedList*) &SupportedTagTypes[32] },\n+{TYPE_HANDLER(cmsSigMHC2Type,                  MHC2),                NULL }\n@@ -5737,1 +5971,2 @@\n-    { cmsSigArgyllArtsTag,          { 9, 1, { cmsSigS15Fixed16ArrayType},    NULL}, NULL}\n+    { cmsSigArgyllArtsTag,          { 9, 1, { cmsSigS15Fixed16ArrayType},    NULL}, &SupportedTags[65]},\n+    { cmsSigMHC2Tag,                { 1, 1, { cmsSigMHC2Type },              NULL}, NULL}\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmstypes.c","additions":253,"deletions":18,"binary":false,"changes":271,"status":"modified"},{"patch":"@@ -438,2 +438,2 @@\n-        cmsSignalError(ContextID, cmsERROR_RANGE, \"InkLimiting: Limit should be between 0..400\");\n-        if (Limit < 0) Limit = 0;\n+        cmsSignalError(ContextID, cmsERROR_RANGE, \"InkLimiting: Limit should be between 1..400\");\n+        if (Limit < 1) Limit = 1;\n@@ -441,1 +441,0 @@\n-\n@@ -704,0 +703,121 @@\n+\/**\n+* Oklab colorspace profile (experimental)\n+*\n+* This virtual profile cannot be saved as an ICC file\n+*\/\n+cmsHPROFILE cmsCreate_OkLabProfile(cmsContext ctx)\n+{\n+    cmsStage* XYZPCS = _cmsStageNormalizeFromXyzFloat(ctx);\n+    cmsStage* PCSXYZ = _cmsStageNormalizeToXyzFloat(ctx);\n+\n+    const double M_D65_D50[] =\n+    {\n+       1.047886, 0.022919, -0.050216,\n+       0.029582, 0.990484, -0.017079,\n+      -0.009252, 0.015073,  0.751678\n+    };\n+\n+    const double M_D50_D65[] =\n+    {\n+         0.955512609517083, -0.023073214184645,  0.063308961782107,\n+        -0.028324949364887,  1.009942432477107,  0.021054814890112,\n+         0.012328875695483, -0.020535835374141,  1.330713916450354\n+    };\n+\n+    cmsStage* D65toD50 = cmsStageAllocMatrix(ctx, 3, 3, M_D65_D50, NULL);\n+    cmsStage* D50toD65 = cmsStageAllocMatrix(ctx, 3, 3, M_D50_D65, NULL);\n+\n+    const double M_D65_LMS[] =\n+    {\n+        0.8189330101, 0.3618667424, -0.1288597137,\n+        0.0329845436, 0.9293118715,  0.0361456387,\n+        0.0482003018, 0.2643662691,  0.6338517070\n+    };\n+\n+    const double M_LMS_D65[] =\n+    {\n+        1.227013851103521, -0.557799980651822,  0.281256148966468,\n+       -0.040580178423281,  1.112256869616830, -0.071676678665601,\n+       -0.076381284505707, -0.421481978418013,  1.586163220440795\n+    };\n+\n+    cmsStage* D65toLMS = cmsStageAllocMatrix(ctx, 3, 3, M_D65_LMS, NULL);\n+    cmsStage* LMStoD65 = cmsStageAllocMatrix(ctx, 3, 3, M_LMS_D65, NULL);\n+\n+    cmsToneCurve* CubeRoot = cmsBuildGamma(ctx, 1.0 \/ 3.0);\n+    cmsToneCurve* Cube     = cmsBuildGamma(ctx,  3.0);\n+\n+    cmsToneCurve* Roots[3] = { CubeRoot, CubeRoot, CubeRoot };\n+    cmsToneCurve* Cubes[3] = { Cube, Cube, Cube };\n+\n+    cmsStage* NonLinearityFw = cmsStageAllocToneCurves(ctx, 3, Roots);\n+    cmsStage* NonLinearityRv = cmsStageAllocToneCurves(ctx, 3, Cubes);\n+\n+    const double M_LMSprime_OkLab[] =\n+    {\n+        0.2104542553,  0.7936177850, -0.0040720468,\n+        1.9779984951, -2.4285922050,  0.4505937099,\n+        0.0259040371,  0.7827717662, -0.8086757660\n+    };\n+\n+    const double M_OkLab_LMSprime[] =\n+    {\n+        0.999999998450520,  0.396337792173768,  0.215803758060759,\n+        1.000000008881761, -0.105561342323656, -0.063854174771706,\n+        1.000000054672411, -0.089484182094966, -1.291485537864092\n+    };\n+\n+    cmsStage* LMSprime_OkLab = cmsStageAllocMatrix(ctx, 3, 3, M_LMSprime_OkLab, NULL);\n+    cmsStage* OkLab_LMSprime = cmsStageAllocMatrix(ctx, 3, 3, M_OkLab_LMSprime, NULL);\n+\n+    cmsPipeline* AToB = cmsPipelineAlloc(ctx, 3, 3);\n+    cmsPipeline* BToA = cmsPipelineAlloc(ctx, 3, 3);\n+\n+    cmsHPROFILE hProfile = cmsCreateProfilePlaceholder(ctx);\n+\n+    cmsSetProfileVersion(hProfile, 4.4);\n+\n+    cmsSetDeviceClass(hProfile, cmsSigColorSpaceClass);\n+    cmsSetColorSpace(hProfile, cmsSig3colorData);\n+    cmsSetPCS(hProfile, cmsSigXYZData);\n+\n+    cmsSetHeaderRenderingIntent(hProfile, INTENT_RELATIVE_COLORIMETRIC);\n+\n+    \/**\n+    * Conversion PCS (XYZ\/D50) to OkLab\n+    *\/\n+    if (!cmsPipelineInsertStage(BToA, cmsAT_END, PCSXYZ)) goto error;\n+    if (!cmsPipelineInsertStage(BToA, cmsAT_END, D50toD65)) goto error;\n+    if (!cmsPipelineInsertStage(BToA, cmsAT_END, D65toLMS)) goto error;\n+    if (!cmsPipelineInsertStage(BToA, cmsAT_END, NonLinearityFw)) goto error;\n+    if (!cmsPipelineInsertStage(BToA, cmsAT_END, LMSprime_OkLab)) goto error;\n+\n+    if (!cmsWriteTag(hProfile, cmsSigBToA0Tag, BToA)) goto error;\n+\n+    if (!cmsPipelineInsertStage(AToB, cmsAT_END, OkLab_LMSprime)) goto error;\n+    if (!cmsPipelineInsertStage(AToB, cmsAT_END, NonLinearityRv)) goto error;\n+    if (!cmsPipelineInsertStage(AToB, cmsAT_END, LMStoD65)) goto error;\n+    if (!cmsPipelineInsertStage(AToB, cmsAT_END, D65toD50)) goto error;\n+    if (!cmsPipelineInsertStage(AToB, cmsAT_END, XYZPCS)) goto error;\n+\n+    if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, AToB)) goto error;\n+\n+    cmsPipelineFree(BToA);\n+    cmsPipelineFree(AToB);\n+\n+    cmsFreeToneCurve(CubeRoot);\n+    cmsFreeToneCurve(Cube);\n+\n+    return hProfile;\n+\n+error:\n+    cmsPipelineFree(BToA);\n+    cmsPipelineFree(AToB);\n+\n+    cmsFreeToneCurve(CubeRoot);\n+    cmsFreeToneCurve(Cube);\n+    cmsCloseProfile(hProfile);\n+\n+    return NULL;\n+\n+}\n@@ -1063,1 +1183,1 @@\n-        if (n > Tab ->nTypes) return FALSE;\n+        if (n >= Tab ->nTypes) return FALSE;\n@@ -1094,3 +1214,3 @@\n-        cmsUInt32Number FrmIn, FrmOut;\n-        cmsInt32Number ChansIn, ChansOut;\n-        int ColorSpaceBitsIn, ColorSpaceBitsOut;\n+    cmsUInt32Number FrmIn, FrmOut;\n+    cmsInt32Number ChansIn, ChansOut;\n+    int ColorSpaceBitsIn, ColorSpaceBitsOut;\n@@ -1107,0 +1227,3 @@\n+    \/\/ Check if the pipeline holding is valid\n+    if (xform -> Lut == NULL) return NULL;\n+\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsvirt.c","additions":130,"deletions":7,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -946,1 +946,1 @@\n-    if (_cmsFormatterIsFloat(*OutputFormat)) {\n+    if (_cmsFormatterIsFloat(*InputFormat) || _cmsFormatterIsFloat(*OutputFormat)) {\n@@ -1021,0 +1021,13 @@\n+    \/**\n+    * Check consistency for alpha channel copy\n+    *\/\n+    if (*dwFlags & cmsFLAGS_COPY_ALPHA)\n+    {\n+        if (T_EXTRA(*InputFormat) != T_EXTRA(*OutputFormat))\n+        {\n+            cmsSignalError(ContextID, cmsERROR_NOT_SUITABLE, \"Mismatched alpha channels\");\n+            cmsDeleteTransform(p);\n+            return NULL;\n+        }\n+    }\n+\n","filename":"src\/java.desktop\/share\/native\/liblcms\/cmsxform.c","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-\/\/ Version 2.15\n+\/\/ Version 2.16\n@@ -108,0 +108,3 @@\n+#       if __cplusplus >= 201703L\n+#            define CMS_NO_REGISTER_KEYWORD 1\n+#       endif\n@@ -113,1 +116,1 @@\n-#define LCMS_VERSION        2150\n+#define LCMS_VERSION        2160\n@@ -357,1 +360,2 @@\n-    cmsSigXYZType                           = 0x58595A20   \/\/ 'XYZ '\n+    cmsSigXYZType                           = 0x58595A20,  \/\/ 'XYZ '\n+    cmsSigMHC2Type                          = 0x4D484332   \/\/ 'MHC2'\n@@ -435,1 +439,2 @@\n-    cmsSigArgyllArtsTag                     = 0x61727473   \/\/ 'arts'\n+    cmsSigArgyllArtsTag                     = 0x61727473,  \/\/ 'arts'\n+    cmsSigMHC2Tag                           = 0x4D484332   \/\/ 'MHC2'\n@@ -980,0 +985,1 @@\n+#define TYPE_OKLAB_DBL        (FLOAT_SH(1)|COLORSPACE_SH(PT_MCH3)|CHANNELS_SH(3)|BYTES_SH(0))\n@@ -1080,0 +1086,13 @@\n+typedef struct {\n+    cmsUInt32Number   CurveEntries;\n+    cmsFloat64Number* RedCurve;\n+    cmsFloat64Number* GreenCurve;\n+    cmsFloat64Number* BlueCurve;\n+\n+    cmsFloat64Number  MinLuminance;         \/\/ ST.2086 min luminance in nits\n+    cmsFloat64Number  PeakLuminance;        \/\/ ST.2086 peak luminance in nits\n+\n+    cmsFloat64Number XYZ2XYZmatrix[3][4];\n+\n+} cmsMHC2Type;\n+\n@@ -1252,1 +1271,2 @@\n-CMSAPI cmsFloat64Number* CMSEXPORT cmsGetToneCurveParams(const cmsToneCurve* t);\n+\n+CMSAPI const cmsCurveSegment* CMSEXPORT cmsGetToneCurveSegment(cmsInt32Number n, const cmsToneCurve* t);\n@@ -1346,2 +1366,5 @@\n-#define  cmsNoLanguage \"\\0\\0\"\n-#define  cmsNoCountry  \"\\0\\0\"\n+#define  cmsNoLanguage    \"\\0\\0\"\n+#define  cmsNoCountry     \"\\0\\0\"\n+\n+\/\/ Special language\/country to retrieve unicode field for description in V2 profiles. Use with care.\n+#define  cmsV2Unicode     \"\\xff\\xff\"\n@@ -1359,0 +1382,3 @@\n+CMSAPI cmsBool           CMSEXPORT cmsMLUsetUTF8(cmsMLU* mlu,\n+                                                  const char LanguageCode[3], const char CountryCode[3],\n+                                                  const char* UTF8String);\n@@ -1367,0 +1393,4 @@\n+CMSAPI cmsUInt32Number   CMSEXPORT cmsMLUgetUTF8(const cmsMLU* mlu,\n+                                                 const char LanguageCode[3], const char CountryCode[3],\n+                                                 char* Buffer, cmsUInt32Number BufferSize);\n+\n@@ -1591,0 +1621,4 @@\n+CMSAPI cmsUInt32Number  CMSEXPORT cmsGetProfileInfoUTF8(cmsHPROFILE hProfile, cmsInfoType Info,\n+                                                            const char LanguageCode[3], const char CountryCode[3],\n+                                                            char* Buffer, cmsUInt32Number BufferSize);\n+\n@@ -1653,0 +1687,3 @@\n+CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateDeviceLinkFromCubeFile(const char* cFileName);\n+\n+CMSAPI cmsHPROFILE      CMSEXPORT cmsCreateDeviceLinkFromCubeFileTHR(cmsContext ContextID, const char* cFileName);\n@@ -1665,0 +1702,2 @@\n+CMSAPI cmsHPROFILE      CMSEXPORT cmsCreate_OkLabProfile(cmsContext ctx);\n+\n","filename":"src\/java.desktop\/share\/native\/liblcms\/lcms2.h","additions":46,"deletions":7,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -291,0 +291,1 @@\n+#          pragma warning(disable : 4127)\n@@ -548,1 +549,1 @@\n-    void* chunks[MemoryClientMax];    \/\/ array of pointers to client chunks. Memory itself is hold in the suballocator.\n+    void* chunks[MemoryClientMax];    \/\/ array of pointers to client chunks. Memory itself is held in the suballocator.\n@@ -842,0 +843,3 @@\n+    \/\/ Color management module identification\n+    cmsUInt32Number          CMM;\n+\n@@ -849,0 +853,1 @@\n+    cmsPlatformSignature     platform;\n","filename":"src\/java.desktop\/share\/native\/liblcms\/lcms2_internal.h","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -228,2 +228,2 @@\n-            msn = new CustomMediaSizeName(media[i*2], media[i*2+1],\n-                                          width, length);\n+            msn = CustomMediaSizeName.create(media[i*2], media[i*2+1],\n+                                             width, length);\n@@ -235,13 +235,0 @@\n-\n-                \/\/ add this new custom msn to MediaSize array\n-                if ((width > 0.0) && (length > 0.0)) {\n-                    try {\n-                    new MediaSize(width, length,\n-                                  Size2DSyntax.INCH, msn);\n-                    } catch (IllegalArgumentException e) {\n-                        \/* PDF printer in Linux for Ledger paper causes\n-                        \"IllegalArgumentException: X dimension > Y dimension\".\n-                        We rotate based on IPP spec. *\/\n-                        new MediaSize(length, width, Size2DSyntax.INCH, msn);\n-                    }\n-                }\n@@ -272,2 +259,2 @@\n-            mt = new CustomMediaTray(media[(nPageSizes+i)*2],\n-                                     media[(nPageSizes+i)*2+1]);\n+            mt = CustomMediaTray.create(media[(nPageSizes+i)*2],\n+                                        media[(nPageSizes+i)*2+1]);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/CUPSPrinter.java","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -459,6 +459,8 @@\n-                    cps = new CUPSPrinter(printer);\n-                    mediaSizeNames = cps.getMediaSizeNames();\n-                    mediaTrays = cps.getMediaTrays();\n-                    customMediaSizeNames = cps.getCustomMediaSizeNames();\n-                    defaultMediaIndex = cps.getDefaultMediaIndex();\n-                    rawResolutions = cps.getRawResolutions();\n+                    if (cps == null) {\n+                        cps = new CUPSPrinter(printer);\n+                        mediaSizeNames = cps.getMediaSizeNames();\n+                        mediaTrays = cps.getMediaTrays();\n+                        customMediaSizeNames = cps.getCustomMediaSizeNames();\n+                        defaultMediaIndex = cps.getDefaultMediaIndex();\n+                        rawResolutions = cps.getRawResolutions();\n+                    }\n@@ -1014,2 +1016,2 @@\n-        CustomMediaSizeName sampleSize = new CustomMediaSizeName(\"sample\", \"\",\n-                                                                 0, 0);\n+        CustomMediaSizeName sampleSize =\n+                CustomMediaSizeName.create(\"sample\", \"\", 0, 0);\n@@ -1022,1 +1024,1 @@\n-        CustomMediaTray sampleTray = new CustomMediaTray(\"sample\", \"\");\n+        CustomMediaTray sampleTray = CustomMediaTray.create(\"sample\", \"\");\n@@ -1228,3 +1230,11 @@\n-        \/\/ update getAttMap by sending again get-attributes IPP request\n-        init = false;\n-        initAttributes();\n+        if (!init) {\n+            \/\/ get all attributes for the first time.\n+            initAttributes();\n+        } else {\n+            \/\/ only need service attributes updated.\n+            \/\/ update getAttMap by sending again get-attributes IPP request\n+            if ((urlConnection = getIPPConnection(myURL)) != null) {\n+                opGetAttributes();\n+                urlConnection.disconnect();\n+            }\n+        }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/IPPPrintService.java","additions":23,"deletions":13,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -541,2 +541,2 @@\n-            if (buffers.isEmpty()) return 0;\n-            return 1;\n+            if (!buffers.isEmpty() && buffers.peek() != LAST_LIST ) return 1;\n+            return available;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ResponseSubscribers.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,16 @@\n+#define EXCEPTION_CHECK_WITH_RELEASE(situationDescription, returnVal, js, stringBytes)          \\\n+    if (exception = jniEnv->ExceptionOccurred()) {                                              \\\n+        PrintDebugString(\"[ERROR]: *** Exception occured while doing: %s - call to GetStringLength; returning %d\", situationDescription, returnVal);   \\\n+        jniEnv->ExceptionDescribe();                                                            \\\n+        jniEnv->ExceptionClear();                                                               \\\n+        jniEnv->ReleaseStringChars(js, stringBytes);                                            \\\n+        return (returnVal);                                                                     \\\n+    }                                                                                           \\\n+    jniEnv->ReleaseStringChars(js, stringBytes);                                                \\\n+    if (exception = jniEnv->ExceptionOccurred()) {                                              \\\n+        PrintDebugString(\"[ERROR]: *** Exception occured while doing: %s - call to ReleaseStringChars; returning %d\", situationDescription, returnVal);   \\\n+        jniEnv->ExceptionDescribe();                                                            \\\n+        jniEnv->ExceptionClear();                                                               \\\n+        return (returnVal);                                                                     \\\n+    }\n+\n@@ -1218,3 +1234,1 @@\n-            EXCEPTION_CHECK(\"Getting AccessibleName - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting AccessibleName - call to ReleaseStringChars()\", FALSE);\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting AccessibleName\", FALSE, js, stringBytes);\n@@ -1383,3 +1397,1 @@\n-                EXCEPTION_CHECK(\"Getting AccessibleAttributesAtIndex - call to GetStringLength()\", FALSE);\n-                jniEnv->ReleaseStringChars(js, stringBytes);\n-                EXCEPTION_CHECK(\"Getting AccessibleAttributesAtIndex - call to ReleaseStringChars()\", FALSE);\n+                EXCEPTION_CHECK_WITH_RELEASE(\"Getting AccessibleAttributesAtIndex\", FALSE, js, stringBytes);\n@@ -1738,0 +1750,1 @@\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting AccessibleName\", FALSE, js, stringBytes);\n@@ -1740,3 +1753,0 @@\n-            EXCEPTION_CHECK(\"Getting AccessibleName - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting AccessibleName - call to ReleaseStringChars()\", FALSE);\n@@ -1770,0 +1780,1 @@\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting AccessibleName\", FALSE, js, stringBytes);\n@@ -1772,3 +1783,0 @@\n-            EXCEPTION_CHECK(\"Getting AccessibleName - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting AccessibleName - call to ReleaseStringChars()\", FALSE);\n@@ -1802,0 +1810,1 @@\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting AccessibleRole\", FALSE, js, stringBytes);\n@@ -1804,3 +1813,0 @@\n-            EXCEPTION_CHECK(\"Getting AccessibleRole - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting AccessibleRole - call to ReleaseStringChars()\", FALSE);\n@@ -1834,0 +1840,1 @@\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting AccessibleRole_en_US\", FALSE, js, stringBytes);\n@@ -1836,3 +1843,0 @@\n-            EXCEPTION_CHECK(\"Getting AccessibleRole_en_US - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting AccessibleRole_en_US - call to ReleaseStringChars()\", FALSE);\n@@ -1865,0 +1869,1 @@\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting AccessibleState\", FALSE, js, stringBytes);\n@@ -1867,3 +1872,0 @@\n-            EXCEPTION_CHECK(\"Getting AccessibleState - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting AccessibleState - call to ReleaseStringChars()\", FALSE);\n@@ -1896,0 +1898,1 @@\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting AccessibleState_en_US\", FALSE, js, stringBytes);\n@@ -1898,3 +1901,0 @@\n-            EXCEPTION_CHECK(\"Getting AccessibleState_en_US - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting AccessibleState_en_US - call to ReleaseStringChars()\", FALSE);\n@@ -2812,0 +2812,1 @@\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting AccessibleRelation key\", FALSE, js, stringBytes);\n@@ -2814,3 +2815,0 @@\n-            EXCEPTION_CHECK(\"Getting AccessibleRelation key - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting AccessibleRelation key - call to ReleaseStringChars()\", FALSE);\n@@ -2918,3 +2916,1 @@\n-            EXCEPTION_CHECK(\"Getting AccessibleHyperlink text - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting AccessibleHyperlink text - call to ReleaseStringChars()\", FALSE);\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting AccessibleHyperlink text\", FALSE, js, stringBytes);\n@@ -3055,3 +3051,1 @@\n-            EXCEPTION_CHECK(\"Getting AccessibleHyperlink text - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting AccessibleHyperlink text - call to ReleaseStringChars()\", FALSE);\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting AccessibleHyperlink text\", FALSE, js, stringBytes);\n@@ -3174,3 +3168,1 @@\n-        EXCEPTION_CHECK(\"Getting AccessibleHyperlink text - call to GetStringLength()\", FALSE);\n-        jniEnv->ReleaseStringChars(js, stringBytes);\n-        EXCEPTION_CHECK(\"Getting AccessibleHyperlink text - call to ReleaseStringChars()\", FALSE);\n+        EXCEPTION_CHECK_WITH_RELEASE(\"Getting AccessibleHyperlink text\", FALSE, js, stringBytes);\n@@ -3303,3 +3295,1 @@\n-            EXCEPTION_CHECK(\"Getting AccessibleIcon description - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting AccessibleIcon description - call to ReleaseStringChars()\", FALSE);\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting AccessibleIcon description\", FALSE, js, stringBytes);\n@@ -3382,3 +3372,1 @@\n-            EXCEPTION_CHECK(\"Getting AccessibleAction name  - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting AccessibleAction name  - call to ReleaseStringChars()\", FALSE);\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting AccessibleAction name\", FALSE, js, stringBytes);\n@@ -3564,3 +3552,1 @@\n-            EXCEPTION_CHECK(\"Getting AccessibleWordAtIndex - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting AccessibleWordAtIndex - call to ReleaseStringChars()\", FALSE);\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting AccessibleWordAtIndex\", FALSE, js, stringBytes);\n@@ -3600,3 +3586,1 @@\n-            EXCEPTION_CHECK(\"Getting AccessibleSentenceAtIndex - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting AccessibleSentenceAtIndex - call to ReleaseStringChars()\", FALSE);\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting AccessibleSentenceAtIndex\", FALSE, js, stringBytes);\n@@ -3676,3 +3660,1 @@\n-            EXCEPTION_CHECK(\"Getting AccessibleTextSelectedText - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting AccessibleTextSelectedText - call to ReleaseStringChars()\", FALSE);\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting AccessibleTextSelectedText\", FALSE, js, stringBytes);\n@@ -3893,3 +3875,1 @@\n-            EXCEPTION_CHECK(\"Getting BackgroundColorFromAttributeSet - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting BackgroundColorFromAttributeSet - call to ReleaseStringChars()\", FALSE);\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting BackgroundColorFromAttributeSet\", FALSE, js, stringBytes);\n@@ -3930,3 +3910,1 @@\n-            EXCEPTION_CHECK(\"Getting ForegroundColorFromAttributeSet - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting ForegroundColorFromAttributeSet - call to ReleaseStringChars()\", FALSE);\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting ForegroundColorFromAttributeSet\", FALSE, js, stringBytes);\n@@ -3967,3 +3945,1 @@\n-            EXCEPTION_CHECK(\"Getting FontFamilyFromAttributeSet - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting FontFamilyFromAttributeSet - call to ReleaseStringChars()\", FALSE);\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting FontFamilyFromAttributeSet\", FALSE, js, stringBytes);\n@@ -4173,3 +4149,1 @@\n-            EXCEPTION_CHECK(\"Getting AccessibleAttributesAtIndex - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting AccessibleAttributesAtIndex - call to ReleaseStringChars()\", FALSE);\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting AccessibleAttributesAtIndex\", FALSE, js, stringBytes);\n@@ -4416,3 +4390,1 @@\n-            EXCEPTION_CHECK(\"Getting AccessibleTextRange - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting AccessibleTextRange - call to ReleaseStringChars()\", FALSE);\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting AccessibleTextRange\", FALSE, js, stringBytes);\n@@ -4461,3 +4433,1 @@\n-            EXCEPTION_CHECK(\"Getting CurrentAccessibleValue - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting CurrentAccessibleValue - call to ReleaseStringChars()\", FALSE);\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting CurrentAccessibleValue\", FALSE, js, stringBytes);\n@@ -4504,3 +4474,1 @@\n-            EXCEPTION_CHECK(\"Getting MaximumAccessibleValue - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting MaximumAccessibleValue - call to ReleaseStringChars()\", FALSE);\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting MaximumAccessibleValue\", FALSE, js, stringBytes);\n@@ -4547,3 +4515,1 @@\n-            EXCEPTION_CHECK(\"Getting MinimumAccessibleValue - call to GetStringLength()\", FALSE);\n-            jniEnv->ReleaseStringChars(js, stringBytes);\n-            EXCEPTION_CHECK(\"Getting MinimumAccessibleValue - call to ReleaseStringChars()\", FALSE);\n+            EXCEPTION_CHECK_WITH_RELEASE(\"Getting MinimumAccessibleValue\", FALSE, js, stringBytes);\n","filename":"src\/jdk.accessibility\/windows\/native\/libjavaaccessbridge\/AccessBridgeJavaEntryPoints.cpp","additions":42,"deletions":76,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.ArrayList;\n@@ -1303,1 +1304,1 @@\n-        public List<Symbol> permitted;\n+        private java.util.List<PermittedClassWithPos> permitted;\n@@ -1307,0 +1308,2 @@\n+        private record PermittedClassWithPos(Symbol permittedClass, int pos) {}\n+\n@@ -1315,1 +1318,1 @@\n-            this.permitted = List.nil();\n+            this.permitted = new ArrayList<>();\n@@ -1327,0 +1330,31 @@\n+        public void addPermittedSubclass(ClassSymbol csym, int pos) {\n+            Assert.check(!isPermittedExplicit);\n+            \/\/ we need to insert at the right pos\n+            PermittedClassWithPos element = new PermittedClassWithPos(csym, pos);\n+            int index = Collections.binarySearch(permitted, element, java.util.Comparator.comparing(PermittedClassWithPos::pos));\n+            if (index < 0) {\n+                index = -index - 1;\n+            }\n+            permitted.add(index, element);\n+        }\n+\n+        public boolean isPermittedSubclass(Symbol csym) {\n+            for (PermittedClassWithPos permittedClassWithPos : permitted) {\n+                if (permittedClassWithPos.permittedClass.equals(csym)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        public void clearPermittedSubclasses() {\n+            permitted.clear();\n+        }\n+\n+        public void setPermittedSubclasses(List<Symbol> permittedSubs) {\n+            permitted.clear();\n+            for (Symbol csym : permittedSubs) {\n+                permitted.add(new PermittedClassWithPos(csym, 0));\n+            }\n+        }\n+\n@@ -1643,1 +1677,1 @@\n-            return permitted.map(s -> s.type);\n+            return permitted.stream().map(s -> s.permittedClass().type).collect(List.collector());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":37,"deletions":3,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1696,1 +1696,1 @@\n-                return sealedOne.permitted.stream().allMatch(sym -> areDisjoint((ClassSymbol)sym, other));\n+                return sealedOne.getPermittedSubclasses().stream().allMatch(type -> areDisjoint((ClassSymbol)type.tsym, other));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5409,1 +5409,1 @@\n-                    c.permitted.isEmpty()) {\n+                    c.getPermittedSubclasses().isEmpty()) {\n@@ -5416,1 +5416,1 @@\n-                for (Symbol subTypeSym : c.permitted) {\n+                for (Type subType : c.getPermittedSubclasses()) {\n@@ -5418,1 +5418,1 @@\n-                    if (subTypeSym.type.getTag() == TYPEVAR) {\n+                    if (subType.getTag() == TYPEVAR) {\n@@ -5420,2 +5420,2 @@\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n-                                Errors.InvalidPermitsClause(Fragments.IsATypeVariable(subTypeSym.type)));\n+                        log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n+                                Errors.InvalidPermitsClause(Fragments.IsATypeVariable(subType)));\n@@ -5423,2 +5423,2 @@\n-                    if (subTypeSym.isAnonymous() && !c.isEnum()) {\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),  Errors.LocalClassesCantExtendSealed(Fragments.Anonymous));\n+                    if (subType.tsym.isAnonymous() && !c.isEnum()) {\n+                        log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),  Errors.LocalClassesCantExtendSealed(Fragments.Anonymous));\n@@ -5426,1 +5426,1 @@\n-                    if (permittedTypes.contains(subTypeSym)) {\n+                    if (permittedTypes.contains(subType.tsym)) {\n@@ -5429,1 +5429,1 @@\n-                                        .filter(permittedExpr -> TreeInfo.diagnosticPositionFor(subTypeSym, permittedExpr, true) != null)\n+                                        .filter(permittedExpr -> TreeInfo.diagnosticPositionFor(subType.tsym, permittedExpr, true) != null)\n@@ -5431,1 +5431,1 @@\n-                        log.error(pos, Errors.InvalidPermitsClause(Fragments.IsDuplicated(subTypeSym.type)));\n+                        log.error(pos, Errors.InvalidPermitsClause(Fragments.IsDuplicated(subType)));\n@@ -5433,1 +5433,1 @@\n-                        permittedTypes.add(subTypeSym);\n+                        permittedTypes.add(subType.tsym);\n@@ -5436,2 +5436,2 @@\n-                        if (subTypeSym.packge() != c.packge()) {\n-                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                        if (subType.tsym.packge() != c.packge()) {\n+                            log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n@@ -5441,2 +5441,2 @@\n-                    } else if (subTypeSym.packge().modle != c.packge().modle) {\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                    } else if (subType.tsym.packge().modle != c.packge().modle) {\n+                        log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n@@ -5446,2 +5446,2 @@\n-                    if (subTypeSym == c.type.tsym || types.isSuperType(subTypeSym.type, c.type)) {\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, ((JCClassDecl)env.tree).permitting),\n+                    if (subType.tsym == c.type.tsym || types.isSuperType(subType, c.type)) {\n+                        log.error(TreeInfo.diagnosticPositionFor(subType.tsym, ((JCClassDecl)env.tree).permitting),\n@@ -5449,1 +5449,1 @@\n-                                        subTypeSym == c.type.tsym ?\n+                                        subType.tsym == c.type.tsym ?\n@@ -5451,1 +5451,1 @@\n-                                                Fragments.MustNotBeSupertype(subTypeSym.type)\n+                                                Fragments.MustNotBeSupertype(subType)\n@@ -5455,1 +5455,1 @@\n-                        boolean thisIsASuper = types.directSupertypes(subTypeSym.type)\n+                        boolean thisIsASuper = types.directSupertypes(subType)\n@@ -5459,2 +5459,2 @@\n-                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n-                                    Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subTypeSym.type)));\n+                            log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n+                                    Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subType)));\n@@ -5495,1 +5495,1 @@\n-                        if (!supertypeSym.permitted.contains(c.type.tsym)) {\n+                        if (!supertypeSym.isPermittedSubclass(c.type.tsym)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -923,2 +923,2 @@\n-                    for (Symbol sym : current.permitted) {\n-                        ClassSymbol csym = (ClassSymbol) sym;\n+                    for (Type t : current.getPermittedSubclasses()) {\n+                        ClassSymbol csym = (ClassSymbol) t.tsym;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -923,1 +923,1 @@\n-                            supClass.permitted = supClass.permitted.append(sym);\n+                            supClass.addPermittedSubclass(sym, tree.pos);\n@@ -936,1 +936,1 @@\n-                sym.permitted = permittedSubtypeSymbols.toList();\n+                sym.setPermittedSubclasses(permittedSubtypeSymbols.toList());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1299,1 +1299,1 @@\n-                        ((ClassSymbol)sym).permitted = subtypes.toList();\n+                        ((ClassSymbol)sym).setPermittedSubclasses(subtypes.toList());\n@@ -2616,1 +2616,1 @@\n-        if (c.permitted != null && !c.permitted.isEmpty()) {\n+        if (!c.getPermittedSubclasses().isEmpty()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -925,1 +925,1 @@\n-        if (csym.permitted.nonEmpty()) {\n+        if (csym.getPermittedSubclasses().nonEmpty()) {\n@@ -927,3 +927,3 @@\n-            databuf.appendChar(csym.permitted.size());\n-            for (Symbol c : csym.permitted) {\n-                databuf.appendChar(poolWriter.putClass((ClassSymbol) c));\n+            databuf.appendChar(csym.getPermittedSubclasses().size());\n+            for (Type t : csym.getPermittedSubclasses()) {\n+                databuf.appendChar(poolWriter.putClass((ClassSymbol) t.tsym));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1646,1 +1646,1 @@\n-                    node.sym.permitted = List.nil();\n+                    node.sym.clearPermittedSubclasses();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -275,0 +275,3 @@\n+        if (Instant.MIN.equals(instant)) {\n+            return \"N\/A\";\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/ValueFormatter.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-process.top.args=-l 1\n+process.top.args=-l 2\n","filename":"test\/failure_handler\/src\/share\/conf\/mac.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-  TempNewSymbol A = SymbolTable::new_symbol(\"abc2_8_2023_class\");\n-  TempNewSymbol D = SymbolTable::new_symbol(\"def2_8_2023_class\");\n+  Symbol* A = SymbolTable::new_symbol(\"abc2_8_2023_class\");\n+  Symbol* D = SymbolTable::new_symbol(\"def2_8_2023_class\");\n@@ -45,1 +45,1 @@\n-  TempNewSymbol interf = SymbolTable::new_symbol(\"interface2_8_2023_supername\");\n+  Symbol* interf = SymbolTable::new_symbol(\"interface2_8_2023_supername\");\n@@ -113,0 +113,5 @@\n+\n+  \/\/ clean up temporary symbols\n+  A->decrement_refcount();\n+  D->decrement_refcount();\n+  interf->decrement_refcount();\n","filename":"test\/hotspot\/gtest\/classfile\/test_placeholders.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,0 +30,8 @@\n+\/\/ Helper to avoid interference from the cleanup delay queue by draining it\n+\/\/ immediately after creation.\n+TempNewSymbol stable_temp_symbol(Symbol* sym) {\n+  TempNewSymbol t = sym;\n+  TempSymbolCleanupDelayer::drain_queue();\n+  return t;\n+}\n+\n@@ -39,1 +47,1 @@\n-  TempNewSymbol ss = abc;\n+  TempNewSymbol ss = stable_temp_symbol(abc);\n@@ -48,2 +56,2 @@\n-  TempNewSymbol s1 = efg;\n-  TempNewSymbol s2 = hij;\n+  TempNewSymbol s1 = stable_temp_symbol(efg);\n+  TempNewSymbol s2 = stable_temp_symbol(hij);\n@@ -68,1 +76,1 @@\n-  s3 = klm; \/\/ assignment\n+  s3 = stable_temp_symbol(klm); \/\/ assignment\n@@ -74,1 +82,1 @@\n-    TempNewSymbol s_inner = xyz;\n+    TempNewSymbol s_inner = stable_temp_symbol(xyz);\n@@ -142,0 +150,47 @@\n+\n+TEST_VM(SymbolTable, test_cleanup_delay) {\n+  \/\/ Check that new temp symbols have an extra refcount increment, which is then\n+  \/\/ decremented when the queue spills over.\n+\n+  TempNewSymbol s1 = SymbolTable::new_symbol(\"temp-s1\");\n+  ASSERT_EQ(s1->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n+\n+  \/\/ Fill up the queue\n+  constexpr int symbol_name_length = 30;\n+  char symbol_name[symbol_name_length];\n+  for (uint i = 1; i < TempSymbolCleanupDelayer::QueueSize; i++) {\n+    os::snprintf(symbol_name, symbol_name_length, \"temp-filler-%d\", i);\n+    TempNewSymbol s = SymbolTable::new_symbol(symbol_name);\n+    ASSERT_EQ(s->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n+  }\n+\n+  \/\/ Add one more\n+  TempNewSymbol spillover = SymbolTable::new_symbol(\"temp-spillover\");\n+  ASSERT_EQ(spillover->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n+\n+  \/\/ The first symbol should have been removed from the queue and decremented\n+  ASSERT_EQ(s1->refcount(), 1) << \"TempNewSymbol off queue refcount is 1\";\n+}\n+\n+TEST_VM(SymbolTable, test_cleanup_delay_drain) {\n+  \/\/ Fill up the queue\n+  constexpr int symbol_name_length = 30;\n+  char symbol_name[symbol_name_length];\n+  TempNewSymbol symbols[TempSymbolCleanupDelayer::QueueSize] = {};\n+  for (uint i = 0; i < TempSymbolCleanupDelayer::QueueSize; i++) {\n+    os::snprintf(symbol_name, symbol_name_length, \"temp-%d\", i);\n+    TempNewSymbol s = SymbolTable::new_symbol(symbol_name);\n+    symbols[i] = s;\n+  }\n+\n+  \/\/ While in the queue refcounts are incremented\n+  for (uint i = 0; i < TempSymbolCleanupDelayer::QueueSize; i++) {\n+    ASSERT_EQ(symbols[i]->refcount(), 2) << \"TempNewSymbol refcount in queue is 2\";\n+  }\n+\n+  \/\/ Draining the queue should decrement the refcounts\n+  TempSymbolCleanupDelayer::drain_queue();\n+  for (uint i = 0; i < TempSymbolCleanupDelayer::QueueSize; i++) {\n+    ASSERT_EQ(symbols[i]->refcount(), 1) << \"TempNewSymbol refcount after drain is 1\";\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/classfile\/test_symbolTable.cpp","additions":60,"deletions":5,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-    _heap->set_old_evac_reserve(_heap->old_generation()->soft_max_capacity() \/ 4);\n+    _heap->old_generation()->set_evacuation_reserve(_heap->old_generation()->soft_max_capacity() \/ 4);\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahOldHeuristic.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -256,0 +256,1 @@\n+  applications\/ctw\/modules \\\n@@ -401,0 +402,1 @@\n+ -runtime\/Monitor\/ConcurrentDeflation.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, BELLSOFT. All rights reserved.\n+ * Copyright (c) 2024, BELLSOFT. All rights reserved.\n@@ -92,1 +92,0 @@\n-            \"-XX:CompileOnly=\" + className + \"::main\",\n@@ -95,1 +94,1 @@\n-            \"-XX:+PrintAssembly\",\n+            \"-XX:CompileCommand=option,\" + className + \"::main,bool,PrintAssembly,true\",\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestFarJump.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        List<InlineEntry> inlineesNormal = parseLogFile(LOG_FILE_NORMAL, entryString, \"compile_id='\" + getCompileIdFromFile(getReplayFileName()), inlineeCount);\n+        List<InlineEntry> inlineesNormal = parseLogFile(LOG_FILE_NORMAL, entryString, \"compile_id='\" + getCompileIdFromFile(getReplayFileName()) + \"'\", inlineeCount);\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/TestInliningProtectionDomain.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8326638\n+ * @summary Test handling of irreducible loops in PhaseIdealLoop::remix_address_expressions.\n+ * @run main\/othervm -XX:-TieredCompilation -Xbatch\n+ *                   -XX:CompileCommand=compileonly,TestRemixAddressExpressionsWithIrreducibleLoop::test\n+ *                   TestRemixAddressExpressionsWithIrreducibleLoop\n+ *\/\n+\n+public class TestRemixAddressExpressionsWithIrreducibleLoop {\n+\n+    public static void main(String[] args) {\n+        test(\"4\");\n+    }\n+\n+    public static void test(String arg) {\n+        for (int i = 0; i < 100_000; ++i) {\n+            int j = 0;\n+            while (true) {\n+                boolean tmp = \"1\\ufff0\".startsWith(arg, 2 - arg.length());\n+                if (j++ > 100)\n+                    break;\n+            }\n+        loop:\n+            while (i >= 100) {\n+                for (int i2 = 0; i2 < 1; i2 = 1)\n+                    if (j > 300)\n+                        break loop;\n+                j++;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestRemixAddressExpressionsWithIrreducibleLoop.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -54,1 +54,1 @@\n-    private static void runTest(String test) throws Exception {\n+    private static void runTest(String compiler, String test) throws Exception {\n@@ -57,0 +57,1 @@\n+        command.add(compiler);\n@@ -83,1 +84,1 @@\n-            runTest(methodName);\n+            runTest(args[0], methodName);\n","filename":"test\/hotspot\/jtreg\/compiler\/sharedstubs\/SharedStubToInterpTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires vm.compiler2.enabled\n@@ -49,1 +50,1 @@\n-    private static void runTest(String test) throws Exception {\n+    private static void runTest(String compiler, String test) throws Exception {\n@@ -52,0 +53,1 @@\n+        command.add(compiler);\n@@ -75,1 +77,1 @@\n-            runTest(test);\n+            runTest(args[0], test);\n","filename":"test\/hotspot\/jtreg\/compiler\/sharedstubs\/SharedTrampolineTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-            makePair(FSPEC128, ISPEC128),\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/TestCastMethods.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,5 +56,0 @@\n-    if (GC.Shenandoah.isSupported()) {\n-      noneGCSupported = false;\n-      testDynamicNumberOfGCThreads(\"UseShenandoahGC\");\n-    }\n-\n@@ -62,1 +57,1 @@\n-      throw new SkippedException(\"Skipping test because none of G1\/Parallel\/Shenandoah is supported.\");\n+      throw new SkippedException(\"Skipping test because none of G1\/Parallel is supported.\");\n","filename":"test\/hotspot\/jtreg\/gc\/ergonomics\/TestDynamicNumberOfGCThreads.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2014, 2024, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.parallel;\n+\n+\/**\n+ * @test TestAlwaysPreTouchBehavior\n+ * @summary Tests AlwaysPreTouch Bahavior, pages of java heap should be pretouched with AlwaysPreTouch enabled. This test reads RSS of test process, which should be bigger than heap size(1g) with AlwaysPreTouch enabled.\n+ * @requires vm.gc.Parallel\n+ * @requires vm.debug != true\n+ * @requires os.family == \"linux\"\n+ * @requires os.maxMemory > 2G\n+ * @library \/test\/lib\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UseParallelGC -XX:+AlwaysPreTouch gc.parallel.TestAlwaysPreTouchBehavior\n+ *\/\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.io.IOException;\n+import java.util.*;\n+import javax.management.*;\n+import java.lang.management.*;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.Asserts;\n+import java.lang.management.*;\n+import java.util.stream.*;\n+import java.io.*;\n+\n+public class TestAlwaysPreTouchBehavior {\n+    public static long getProcessRssInKb() throws IOException {\n+        String pid = ManagementFactory.getRuntimeMXBean().getName().split(\"@\")[0];\n+        \/\/ Read RSS from \/proc\/$pid\/status. Only available on Linux.\n+        String processStatusFile = \"\/proc\/\" + pid + \"\/status\";\n+        BufferedReader reader = new BufferedReader(new FileReader(processStatusFile));\n+        String line = null;\n+        while ((line = reader.readLine()) != null) {\n+            if (line.startsWith(\"VmRSS:\")) {\n+                break;\n+            }\n+        }\n+        reader.close();\n+        return Long.valueOf(line.split(\"\\\\s+\")[1].trim());\n+    }\n+    public static void main(String [] args) {\n+    long rss = 0;\n+    Runtime runtime = Runtime.getRuntime();\n+    long committedMemory = runtime.totalMemory() \/ 1024; \/\/ in kb\n+    try {\n+        rss = getProcessRssInKb();\n+    } catch (Exception e) {\n+        System.out.println(\"cannot get RSS, just skip\");\n+        return; \/\/ Did not get avaiable RSS, just ignore this test\n+    }\n+    Asserts.assertGreaterThanOrEqual(rss, committedMemory, \"RSS of this process(\" + rss + \"kb) should be bigger than or equal to committed heap mem(\" + committedMemory + \"kb)\");\n+   }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/parallel\/TestAlwaysPreTouchBehavior.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8325372\n+ * @summary fusion of heap stable test causes GetAndSet node to be removed\n+ * @requires vm.gc.Shenandoah\n+ * @modules java.base\/jdk.internal.misc:+open\n+ *\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:-BackgroundCompilation TestUnsafeLoadStoreMergedHeapStableTests\n+ *\/\n+\n+import jdk.internal.misc.Unsafe;\n+\n+import java.lang.reflect.Field;\n+\n+public class TestUnsafeLoadStoreMergedHeapStableTests {\n+\n+    static final jdk.internal.misc.Unsafe UNSAFE = Unsafe.getUnsafe();\n+    static long F_OFFSET;\n+\n+    static class A {\n+        Object f;\n+    }\n+\n+    static {\n+        try {\n+            Field fField = A.class.getDeclaredField(\"f\");\n+            F_OFFSET = UNSAFE.objectFieldOffset(fField);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static Object testHelper(boolean flag, Object o, long offset, Object x) {\n+        if (flag) {\n+            return UNSAFE.getAndSetObject(o, offset, x);\n+        }\n+        return null;\n+    }\n+\n+    static Object field;\n+\n+\n+    static Object test1(boolean flag, Object o, long offset) {\n+        return testHelper(flag, null, offset, field);\n+    }\n+\n+    static Object test2(Object o, long offset) {\n+        return UNSAFE.getAndSetObject(o, offset, field);\n+    }\n+\n+    static public void main(String[] args) {\n+        A a = new A();\n+        for (int i = 0; i < 20_000; i++) {\n+            testHelper(true, a, F_OFFSET, null);\n+            test1(false, a, F_OFFSET);\n+            test2(a, F_OFFSET);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestUnsafeLoadStoreMergedHeapStableTests.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -84,0 +84,1 @@\n+                    \"-XX:ShenandoahNoProgressThreshold=16\",\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestThreadFailure.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024 SAP SE. All rights reserved.\n@@ -71,1 +71,1 @@\n-        checkHsErrFileContent(f, patterns, null, true, verbose);\n+        checkHsErrFileContent(f, patterns, null, true, verbose, false);\n@@ -83,2 +83,2 @@\n-     * @param verbose If true, the content of the hs-err file is printed while matching. If false, only important\n-     *               information are printed.\n+     * @param verbose If true, the content of the hs-err file is printed while matching. If false, only the matched patterns\n+     *                are printed.\n@@ -88,0 +88,32 @@\n+        checkHsErrFileContent(f, positivePatterns, negativePatterns, checkEndMarker, verbose, false);\n+    }\n+\n+    \/**\n+     * Given an open hs-err file, read it line by line and check for existence of a set of patterns. Will fail\n+     * if patterns are missing, or if the END marker is missing.\n+     * @param f Input file\n+     * @param patterns An array of patterns that need to match, in that order\n+     * @param verbose If true, the content of the hs-err file is printed while matching. If false, only the matched patterns\n+     *                are printed.\n+     * @param printHserrOnError If true, the content of the hs-err file is printed in case of a failing check\n+     * @throws RuntimeException, {@link IOException}\n+     *\/\n+    public static void checkHsErrFileContent(File f, Pattern[] patterns, boolean verbose, boolean printHserrOnError) throws IOException {\n+        checkHsErrFileContent(f, patterns, null, true, verbose, printHserrOnError);\n+    }\n+\n+    \/**\n+     * Given an open hs-err file, read it line by line and check for various conditions.\n+     * @param f input file\n+     * @param positivePatterns Optional array of patterns that need to appear, in given order, in the file. Missing\n+     *                        patterns cause the test to fail.\n+     * @param negativePatterns Optional array of patterns that must not appear in the file; test fails if they do.\n+     *                        Order is irrelevant.\n+     * @param checkEndMarker If true, we check for the final \"END\" in an hs-err file; if it is missing it indicates\n+     *                        that hs-err file printing did not complete successfully.\n+     * @param verbose If true, the content of the hs-err file is printed while matching. If false, only the matched patterns\n+     *                are printed.\n+     * @param printHserrOnError If true, the content of the hs-err file is printed in case of a failing check\n+     * @throws RuntimeException, {@link IOException}\n+     *\/\n+    public static void checkHsErrFileContent(File f, Pattern[] positivePatterns, Pattern[] negativePatterns, boolean checkEndMarker, boolean verbose, boolean printHserrOnError) throws IOException {\n@@ -126,0 +158,3 @@\n+                            if (printHserrOnError) {\n+                                printHsErrFile(f);\n+                            }\n@@ -135,0 +170,3 @@\n+                if (printHserrOnError) {\n+                    printHsErrFile(f);\n+                }\n@@ -138,0 +176,3 @@\n+                if (printHserrOnError) {\n+                    printHsErrFile(f);\n+                }\n@@ -144,0 +185,14 @@\n+    private static void printHsErrFile(File f) throws IOException {\n+        try (\n+                FileInputStream fis = new FileInputStream(f);\n+                BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n+        ) {\n+            String line;\n+            System.out.println(\"------------------------ hs-err file ------------------------\");\n+            while ((line = br.readLine()) != null) {\n+                System.out.println(line);\n+            }\n+            System.out.println(\"-------------------------------------------------------------\");\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/HsErrFileUtils.java","additions":60,"deletions":5,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2014, 2022 SAP SE. All rights reserved.\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024 SAP SE. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,1 +125,1 @@\n-    HsErrFileUtils.checkHsErrFileContent(hs_err_file, pattern, false);\n+    HsErrFileUtils.checkHsErrFileContent(hs_err_file, pattern, false, true);\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/SecondaryErrorTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+\n+\/*\n+ * @test\n+ * @bug 8318757\n+ * @summary Test concurrent monitor deflation by MonitorDeflationThread and thread dumping\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:GuaranteedAsyncDeflationInterval=2000 -XX:+UnlockExperimentalVMOptions -XX:LockingMode=0 ConcurrentDeflation\n+ *\/\n+\n+public class ConcurrentDeflation {\n+    public static final long TOTAL_RUN_TIME_NS = 10_000_000_000L;\n+    public static Object[] monitors = new Object[1000];\n+    public static int monitorCount;\n+\n+    public static void main(String[] args) throws Exception {\n+        Thread threadDumper = new Thread(() -> dumpThreads());\n+        threadDumper.start();\n+        Thread monitorCreator = new Thread(() -> createMonitors());\n+        monitorCreator.start();\n+\n+        threadDumper.join();\n+        monitorCreator.join();\n+    }\n+\n+    static private void dumpThreads() {\n+        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();\n+        int dumpCount = 0;\n+        long startTime = System.nanoTime();\n+        while (System.nanoTime() - startTime < TOTAL_RUN_TIME_NS) {\n+            threadBean.dumpAllThreads(true, false);\n+            dumpCount++;\n+            try {\n+                Thread.sleep(10);\n+            } catch (InterruptedException e) {}\n+        }\n+        System.out.println(\"Dumped all thread info \" + dumpCount + \" times\");\n+    }\n+\n+    static private void createMonitors() {\n+        int index = 0;\n+        long startTime = System.nanoTime();\n+        while (System.nanoTime() - startTime < TOTAL_RUN_TIME_NS) {\n+            index = index++ % 1000;\n+            monitors[index] = new Object();\n+            synchronized (monitors[index]) {\n+                monitorCount++;\n+            }\n+        }\n+        System.out.println(\"Created \" + monitorCount + \" monitors\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/ConcurrentDeflation.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\/*\n+ * @test id=defaults\n+ * @bug 8319048\n+ * @summary Test the MonitorUnlinkBatch options\n+ * @library \/test\/lib\n+ * @run driver MonitorUnlinkBatchTest defaults\n+ *\/\n+\n+\/*\n+ * @test id=legal\n+ * @library \/test\/lib\n+ * @run driver MonitorUnlinkBatchTest legal\n+ *\/\n+\n+\/*\n+ * @test id=illegal\n+ * @library \/test\/lib\n+ * @run driver MonitorUnlinkBatchTest illegal\n+ *\/\n+\n+\/*\n+ * @test id=aggressive\n+ * @library \/test\/lib\n+ * @run driver MonitorUnlinkBatchTest aggressive\n+ *\/\n+\n+\/*\n+ * @test id=lazy\n+ * @library \/test\/lib\n+ * @run driver MonitorUnlinkBatchTest lazy\n+ *\/\n+\n+\n+public class MonitorUnlinkBatchTest {\n+\n+    public static class Test {\n+        \/\/ Inflate a lot of monitors, so that threshold heuristics definitely fires\n+        private static final int MONITORS = 10_000;\n+\n+        \/\/ Use a handful of threads to inflate the monitors, to eat the cost of\n+        \/\/ wait(1) calls. This can be larger than available parallelism, since threads\n+        \/\/ would be time-waiting.\n+        private static final int THREADS = 16;\n+\n+        private static Thread[] threads;\n+        private static Object[] monitors;\n+\n+        public static void main(String... args) throws Exception {\n+            monitors = new Object[MONITORS];\n+            threads = new Thread[THREADS];\n+\n+            for (int t = 0; t < THREADS; t++) {\n+                int monStart = t * MONITORS \/ THREADS;\n+                int monEnd = (t + 1) * MONITORS \/ THREADS;\n+                threads[t] = new Thread(() -> {\n+                    for (int m = monStart; m < monEnd; m++) {\n+                        Object o = new Object();\n+                        synchronized (o) {\n+                            try {\n+                                o.wait(1);\n+                            } catch (InterruptedException e) {\n+                            }\n+                        }\n+                        monitors[m] = o;\n+                    }\n+                });\n+                threads[t].start();\n+            }\n+\n+            for (Thread t : threads) {\n+                t.join();\n+            }\n+\n+            try {\n+                Thread.sleep(10_000);\n+            } catch (InterruptedException ie) {\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length < 1) {\n+            throw new IllegalArgumentException(\"Expect the test label\");\n+        }\n+\n+        String test = args[0];\n+        switch (test) {\n+            case \"defaults\":\n+                test(\"\");\n+                break;\n+\n+            case \"legal\":\n+                \/\/ Legal, even if not useful settings\n+                test(\"\",\n+                     \"-XX:MonitorDeflationMax=100000\",\n+                     \"-XX:MonitorUnlinkBatch=100001\"\n+                     );\n+                break;\n+\n+            case \"illegal\":\n+                \/\/ Quick tests that should fail on JVM flags verification.\n+                test(\"outside the allowed range\",\n+                     \"-XX:MonitorUnlinkBatch=-1\"\n+                );\n+                test(\"outside the allowed range\",\n+                     \"-XX:MonitorUnlinkBatch=0\"\n+                );\n+                break;\n+\n+            case \"aggressive\":\n+                \/\/ The smallest batch possible.\n+                test(\"\",\n+                     \"-XX:MonitorUnlinkBatch=1\"\n+                );\n+                break;\n+\n+            case \"lazy\":\n+                \/\/ The largest batch possible.\n+                test(\"\",\n+                     \"-XX:MonitorDeflationMax=1000000\",\n+                     \"-XX:MonitorUnlinkBatch=1000000\"\n+                );\n+                break;\n+\n+            default:\n+                throw new IllegalArgumentException(\"Unknown test: \" + test);\n+        }\n+    }\n+\n+    public static void test(String msg, String... args) throws Exception {\n+        List<String> opts = new ArrayList<>();\n+        opts.add(\"-Xmx128M\");\n+        opts.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        opts.add(\"-XX:GuaranteedAsyncDeflationInterval=100\");\n+        opts.addAll(Arrays.asList(args));\n+        opts.add(\"MonitorUnlinkBatchTest$Test\");\n+\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(opts);\n+        OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n+        if (msg.isEmpty()) {\n+            oa.shouldHaveExitValue(0);\n+        } else {\n+            oa.shouldNotHaveExitValue(0);\n+            oa.shouldContain(msg);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/MonitorUnlinkBatchTest.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @bug 8320515\n+ * @summary This test checks that ObjectMonitors with dead objects don't\n+ *          cause asserts, crashes, or failures when various sub-systems\n+ *          in the JVM find them.\n+ * @library \/testlibrary \/test\/lib\n+ * @modules jdk.management\n+ *\/\n+\n+\/*\n+ * @requires os.family != \"windows\" & os.family != \"aix\"\n+ * @test id=DetachThread\n+ * @run main\/othervm\/native MonitorWithDeadObjectTest 0\n+ *\/\n+\n+\/*\n+ * @requires os.family != \"windows\" & os.family != \"aix\"\n+ * @test id=DumpThreadsBeforeDetach\n+ * @run main\/othervm\/native MonitorWithDeadObjectTest 1\n+ *\/\n+\n+\/*\n+ * @requires os.family != \"windows\" & os.family != \"aix\"\n+ * @test id=DumpThreadsAfterDetach\n+ * @run main\/othervm\/native MonitorWithDeadObjectTest 2\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadMXBean;\n+\n+public class MonitorWithDeadObjectTest {\n+    public static native void createMonitorWithDeadObject();\n+    public static native void createMonitorWithDeadObjectDumpThreadsBeforeDetach();\n+\n+    static {\n+        System.loadLibrary(\"MonitorWithDeadObjectTest\");\n+    }\n+\n+    private static void dumpThreadsWithLockedMonitors() {\n+        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();\n+        threadBean.dumpAllThreads(true, false);\n+    }\n+\n+    private static void testDetachThread() {\n+        \/\/ Create an ObjectMonitor with a dead object from an attached thread.\n+        \/\/ This used to provoke an assert in DetachCurrentThread.\n+        createMonitorWithDeadObject();\n+    }\n+\n+    private static void testDumpThreadsBeforeDetach() {\n+        \/\/ Create an ObjectMonitor with a dead object from an attached thread\n+        \/\/ and perform a thread dump before detaching the thread.\n+        createMonitorWithDeadObjectDumpThreadsBeforeDetach();\n+    }\n+\n+    private static void testDumpThreadsAfterDetach() {\n+        createMonitorWithDeadObject();\n+\n+        \/\/ The thread dumping code used to not tolerate monitors with dead\n+        \/\/ objects and the detach code used to not unlock these monitors, so\n+        \/\/ test that we don't end up with a bug where these monitors are not\n+        \/\/ unlocked and then passed to the thread dumping code.\n+        dumpThreadsWithLockedMonitors();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        int test = Integer.parseInt(args[0]);\n+        switch (test) {\n+            case 0: testDetachThread(); break;\n+            case 1: testDumpThreadsBeforeDetach(); break;\n+            case 2: testDumpThreadsAfterDetach(); break;\n+            default: throw new RuntimeException(\"Unknown test\");\n+        };\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/MonitorWithDeadObjectTest.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <pthread.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+static JavaVM* jvm;\n+static pthread_t attacher;\n+\n+#define die(x) do { printf(\"%s:%s\\n\",x , __func__); perror(x); exit(EXIT_FAILURE); } while (0)\n+\n+static void check_exception(JNIEnv* env, const char* msg) {\n+  if ((*env)->ExceptionCheck(env)) {\n+    fprintf(stderr, \"Error: %s\", msg);\n+    exit(-1);\n+  }\n+}\n+\n+#define check(env, what, msg)                      \\\n+  check_exception((env), (msg));                   \\\n+  do {                                             \\\n+    if ((what) == 0) {                             \\\n+      fprintf(stderr, #what \"is null: %s\", (msg)); \\\n+      exit(-2);                                    \\\n+    }                                              \\\n+  } while (0)\n+\n+static jobject create_object(JNIEnv* env) {\n+  jclass clazz = (*env)->FindClass(env, \"java\/lang\/Object\");\n+  check(env, clazz, \"No class\");\n+\n+  jmethodID constructor = (*env)->GetMethodID(env, clazz, \"<init>\", \"()V\");\n+  check(env, constructor, \"No constructor\");\n+\n+  jobject obj = (*env)->NewObject(env, clazz, constructor);\n+  check(env, constructor, \"No object\");\n+\n+  return obj;\n+}\n+\n+static void system_gc(JNIEnv* env) {\n+  jclass clazz = (*env)->FindClass(env, \"java\/lang\/System\");\n+  check(env, clazz, \"No class\");\n+\n+  jmethodID method = (*env)->GetStaticMethodID(env, clazz, \"gc\", \"()V\");\n+  check(env, method, \"No method\");\n+\n+  (*env)->CallStaticVoidMethod(env, clazz, method);\n+  check_exception(env, \"Calling System.gc()\");\n+}\n+\n+static void thread_dump_with_locked_monitors(JNIEnv* env) {\n+  jclass ManagementFactoryClass = (*env)->FindClass(env, \"java\/lang\/management\/ManagementFactory\");\n+  check(env, ManagementFactoryClass, \"No ManagementFactory class\");\n+\n+  jmethodID getThreadMXBeanMethod = (*env)->GetStaticMethodID(env, ManagementFactoryClass, \"getThreadMXBean\", \"()Ljava\/lang\/management\/ThreadMXBean;\");\n+  check(env, getThreadMXBeanMethod, \"No getThreadMXBean method\");\n+\n+  jobject threadBean = (*env)->CallStaticObjectMethod(env, ManagementFactoryClass, getThreadMXBeanMethod);\n+  check(env, threadBean, \"Calling getThreadMXBean()\");\n+\n+  jclass ThreadMXBeanClass = (*env)->FindClass(env, \"java\/lang\/management\/ThreadMXBean\");\n+  check(env, ThreadMXBeanClass, \"No ThreadMXBean class\");\n+\n+  jmethodID dumpAllThreadsMethod = (*env)->GetMethodID(env, ThreadMXBeanClass, \"dumpAllThreads\", \"(ZZ)[Ljava\/lang\/management\/ThreadInfo;\");\n+  check(env, dumpAllThreadsMethod, \"No dumpAllThreads method\");\n+\n+  \/\/ The 'lockedMonitors == true' is what causes the monitor with a dead object to be examined.\n+  jobject array = (*env)->CallObjectMethod(env, threadBean, dumpAllThreadsMethod, JNI_TRUE \/* lockedMonitors *\/, JNI_FALSE \/* lockedSynchronizers*\/);\n+  check(env, array, \"Calling dumpAllThreads(true, false)\");\n+}\n+\n+static void create_monitor_with_dead_object(JNIEnv* env) {\n+  jobject obj = create_object(env);\n+\n+  if ((*env)->MonitorEnter(env, obj) != 0) die(\"MonitorEnter\");\n+\n+  \/\/ Drop the last strong reference to the object associated with the monitor.\n+  \/\/ The monitor only keeps a weak reference to the object.\n+  (*env)->DeleteLocalRef(env, obj);\n+\n+  \/\/ Let the GC clear the weak reference to the object.\n+  system_gc(env);\n+}\n+\n+static void* create_monitor_with_dead_object_in_thread(void* arg) {\n+  JNIEnv* env;\n+  int res = (*jvm)->AttachCurrentThread(jvm, (void**)&env, NULL);\n+  if (res != JNI_OK) die(\"AttachCurrentThread\");\n+\n+  \/\/ Make the correct incantation to create a monitor with a dead object.\n+  create_monitor_with_dead_object(env);\n+\n+  \/\/ DetachCurrentThread will try to unlock held monitors. This has been a\n+  \/\/ source of at least two bugs:\n+  \/\/ - When the object reference in the monitor was cleared, the monitor\n+  \/\/   iterator code would skip it, preventing it from being unlocked when\n+  \/\/   the owner thread detached, leaving it lingering in the system.\n+  \/\/ - When the monitor iterator API was rewritten the code was changed to\n+  \/\/   assert that we didn't have \"owned\" monitors with dead objects. This\n+  \/\/   test provokes that situation and that asserts.\n+  if ((*jvm)->DetachCurrentThread(jvm) != JNI_OK) die(\"DetachCurrentThread\");\n+\n+  return NULL;\n+}\n+\n+static void* create_monitor_with_dead_object_and_dump_threads_in_thread(void* arg) {\n+  JNIEnv* env;\n+  int res = (*jvm)->AttachCurrentThread(jvm, (void**)&env, NULL);\n+  if (res != JNI_OK) die(\"AttachCurrentThread\");\n+\n+  \/\/ Make the correct incantation to create a monitor with a dead object.\n+  create_monitor_with_dead_object(env);\n+\n+  \/\/ Perform a thread dump that checks for all thread's monitors.\n+  \/\/ That code didn't expect the monitor iterators to return monitors\n+  \/\/ with dead objects and therefore asserted\/crashed.\n+  thread_dump_with_locked_monitors(env);\n+\n+  if ((*jvm)->DetachCurrentThread(jvm) != JNI_OK) die(\"DetachCurrentThread\");\n+\n+  return NULL;\n+}\n+\n+JNIEXPORT void JNICALL Java_MonitorWithDeadObjectTest_createMonitorWithDeadObject(JNIEnv* env, jclass jc) {\n+  void* ret;\n+\n+  (*env)->GetJavaVM(env, &jvm);\n+\n+  if (pthread_create(&attacher, NULL, create_monitor_with_dead_object_in_thread, NULL) != 0) die(\"pthread_create\");\n+  if (pthread_join(attacher, &ret) != 0) die(\"pthread_join\");\n+}\n+\n+JNIEXPORT void JNICALL Java_MonitorWithDeadObjectTest_createMonitorWithDeadObjectDumpThreadsBeforeDetach(JNIEnv* env, jclass jc) {\n+  void* ret;\n+\n+  (*env)->GetJavaVM(env, &jvm);\n+\n+  if (pthread_create(&attacher, NULL, create_monitor_with_dead_object_and_dump_threads_in_thread, NULL) != 0) die(\"pthread_create\");\n+  if (pthread_join(attacher, &ret) != 0) die(\"pthread_join\");\n+}\n+\n+#ifdef __cplusplus\n+}\n+#endif\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/libMonitorWithDeadObjectTest.c","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -93,1 +93,2 @@\n-        output.shouldContain(\"17 2: jdk\/test\/lib\/apps\\n\");\n+        output.shouldContain(\"17 3: jdk\/test\/lib\/apps\\n\");  \/\/ 3 because a TempSymbol will be found in the TempSymbolCleanupDelayer queue.\n+                   \/\/ Note: we might want to drain the queue before CDS dumps but this is correct for now, unless the queue length changes.\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DynamicSharedSymbols.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires vm.flagless\n@@ -43,0 +44,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/THPsInThreadStackPreventionTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestHugePageDetection.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @requires vm.flagless\n@@ -39,0 +40,1 @@\n+ * @requires vm.flagless\n@@ -50,0 +52,1 @@\n+ * @requires vm.flagless\n@@ -61,0 +64,1 @@\n+ * @requires vm.flagless\n@@ -72,0 +76,1 @@\n+ * @requires vm.flagless\n@@ -83,0 +88,1 @@\n+ * @requires vm.flagless\n@@ -94,0 +100,1 @@\n+ * @requires vm.flagless\n@@ -105,0 +112,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTrimNative.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/framework\/HelpTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/framework\/InvalidCommandTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import nsk.share.jdi.ArgumentHandler;\n@@ -48,0 +47,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/framework\/VMVersionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +60,1 @@\n+import jdk.test.lib.Utils;\n@@ -65,0 +67,1 @@\n+ * @library \/test\/lib\n@@ -74,2 +77,0 @@\n-    public static final String ARGUMENTS = \"\";\n-\n@@ -122,1 +123,1 @@\n-        optionsArg.setValue(ARGUMENTS);\n+        optionsArg.setValue(String.join(\" \", Utils.getTestJavaOpts()));\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/8036666\/GetObjectLockCount.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,2 +27,4 @@\n- * @bug 8185164\n- * @summary Checks that a contended monitor does not show up in the list of owned monitors\n+ * @bug 8185164 8320515\n+ * @summary Checks that a contended monitor does not show up in the list of owned monitors.\n+ *          8320515 piggy-backs on this test and injects an owned monitor with a dead object,\n+            and checks that that monitor isn't exposed to GetOwnedMonitorInfo.\n@@ -49,0 +51,1 @@\n+    private static native void jniMonitorEnter(Object obj);\n@@ -52,0 +55,14 @@\n+    private static void jniMonitorEnterAndLetObjectDie() {\n+        \/\/ The monitor iterator used by GetOwnedMonitorInfo used to\n+        \/\/ assert when an owned monitor with a dead object was found.\n+        \/\/ Inject this situation into this test that performs other\n+        \/\/ GetOwnedMonitorInfo testing.\n+        Object obj = new Object() {};\n+        jniMonitorEnter(obj);\n+        if (!Thread.holdsLock(obj)) {\n+            throw new RuntimeException(\"The object is not locked\");\n+        }\n+        obj = null;\n+        System.gc();\n+    }\n+\n@@ -53,2 +70,4 @@\n-        runTest(true);\n-        runTest(false);\n+        runTest(true, true);\n+        runTest(true, false);\n+        runTest(false, true);\n+        runTest(false, false);\n@@ -57,1 +76,1 @@\n-    public static void runTest(boolean isVirtual) throws Exception {\n+    public static void runTest(boolean isVirtual, boolean jni) throws Exception {\n@@ -62,0 +81,6 @@\n+            Thread.currentThread().setName(\"Worker-Thread\");\n+\n+            if (jni) {\n+                jniMonitorEnterAndLetObjectDie();\n+            }\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetOwnedMonitorInfo\/GetOwnedMonitorInfoTest.java","additions":30,"deletions":5,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include <stdlib.h>\n@@ -267,0 +268,8 @@\n+JNIEXPORT void JNICALL\n+Java_GetOwnedMonitorInfoTest_jniMonitorEnter(JNIEnv* env, jclass cls, jobject obj) {\n+    if ((*env)->MonitorEnter(env, obj) != 0) {\n+        fprintf(stderr, \"MonitorEnter failed\");\n+        exit(-1);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetOwnedMonitorInfo\/libGetOwnedMonitorInfoTest.c","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,416 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @bug 8312498\n+ * @summary Basic test for JVMTI GetThreadState with virtual threads\n+ * @run junit\/othervm\/native GetThreadStateTest\n+ *\/\n+\n+\/*\n+ * @test id=no-vmcontinuations\n+ * @requires vm.continuations\n+ * @run junit\/othervm\/native -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations GetThreadStateTest\n+ *\/\n+\n+import java.util.StringJoiner;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.LockSupport;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class GetThreadStateTest {\n+\n+    @BeforeAll\n+    static void setup() {\n+        System.loadLibrary(\"GetThreadStateTest\");\n+        init();\n+    }\n+\n+    \/**\n+     * Test state of new\/unstarted thread.\n+     *\/\n+    @Test\n+    void testUnstarted() {\n+        var thread = Thread.ofVirtual().unstarted(() -> { });\n+        check(thread, \/*new*\/ 0);\n+    }\n+\n+    \/**\n+     * Test state of terminated thread.\n+     *\/\n+    @Test\n+    void testTerminated() throws Exception {\n+        var thread = Thread.ofVirtual().start(() -> { });\n+        thread.join();\n+        check(thread, JVMTI_THREAD_STATE_TERMINATED);\n+    }\n+\n+    \/**\n+     * Test state of runnable thread.\n+     *\/\n+    @Test\n+    void testRunnable() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            latch.countDown();\n+\n+            \/\/ spin until done\n+            while (!done.get()) {\n+                Thread.onSpinWait();\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to start execution\n+            latch.await();\n+\n+            \/\/ thread should be runnable\n+            int expected = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_RUNNABLE;\n+            check(thread, expected);\n+\n+            \/\/ re-test with interrupt status set\n+            thread.interrupt();\n+            check(thread, expected | JVMTI_THREAD_STATE_INTERRUPTED);\n+        } finally {\n+            done.set(true);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test state of thread waiting to enter a monitor.\n+     *\/\n+    @Test\n+    void testMonitorEnter() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        Object lock = new Object();\n+        var thread = Thread.ofVirtual().unstarted(() -> {\n+            latch.countDown();\n+            synchronized (lock) { }\n+        });\n+        try {\n+            synchronized (lock) {\n+                \/\/ start thread and wait for it to start execution\n+                thread.start();\n+                latch.await();\n+\n+                \/\/ thread should block on monitor enter\n+                int expected = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER;\n+                await(thread, expected);\n+\n+                \/\/ re-test with interrupt status set\n+                thread.interrupt();\n+                check(thread, expected | JVMTI_THREAD_STATE_INTERRUPTED);\n+            }\n+        } finally {\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test state of thread waiting in Object.wait().\n+     *\/\n+    @Test\n+    void testObjectWait() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        Object lock = new Object();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                latch.countDown();\n+                try {\n+                    lock.wait();\n+                } catch (InterruptedException e) { }\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to own monitor\n+            latch.await();\n+\n+            \/\/ thread should wait\n+            int expected = JVMTI_THREAD_STATE_ALIVE |\n+                    JVMTI_THREAD_STATE_WAITING |\n+                    JVMTI_THREAD_STATE_WAITING_INDEFINITELY |\n+                    JVMTI_THREAD_STATE_IN_OBJECT_WAIT;\n+            await(thread, expected);\n+\n+            \/\/ notify so thread waits to re-enter monitor\n+            synchronized (lock) {\n+                lock.notifyAll();\n+                expected = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER;\n+                check(thread, expected);\n+\n+                \/\/ re-test with interrupt status set\n+                thread.interrupt();\n+                check(thread, expected | JVMTI_THREAD_STATE_INTERRUPTED);\n+            }\n+        } finally {\n+            thread.interrupt();\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test state of thread waiting in Object.wait(millis).\n+     *\/\n+    @Test\n+    void testObjectWaitMillis() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        Object lock = new Object();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                latch.countDown();\n+                try {\n+                    lock.wait(Long.MAX_VALUE);\n+                } catch (InterruptedException e) { }\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to own monitor\n+            latch.await();\n+\n+            \/\/ thread should wait\n+            int expected = JVMTI_THREAD_STATE_ALIVE |\n+                    JVMTI_THREAD_STATE_WAITING |\n+                    JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT |\n+                    JVMTI_THREAD_STATE_IN_OBJECT_WAIT;\n+            await(thread, expected);\n+\n+            \/\/ notify so thread waits to re-enter monitor\n+            synchronized (lock) {\n+                lock.notifyAll();\n+                expected = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER;\n+                check(thread, expected);\n+\n+                \/\/ re-test with interrupt status set\n+                thread.interrupt();\n+                check(thread, expected | JVMTI_THREAD_STATE_INTERRUPTED);\n+            }\n+        } finally {\n+            thread.interrupt();\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test state of thread parked with LockSupport.park.\n+     *\/\n+    @Test\n+    void testPark() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            latch.countDown();\n+            while (!done.get()) {\n+                LockSupport.park();\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to start execution\n+            latch.await();\n+\n+            \/\/ thread should park\n+            int expected = JVMTI_THREAD_STATE_ALIVE |\n+                    JVMTI_THREAD_STATE_WAITING |\n+                    JVMTI_THREAD_STATE_WAITING_INDEFINITELY |\n+                    JVMTI_THREAD_STATE_PARKED;\n+            await(thread, expected);\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test state of thread parked with LockSupport.parkNanos.\n+     *\/\n+    @Test\n+    void testParkNanos() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            latch.countDown();\n+            while (!done.get()) {\n+                LockSupport.parkNanos(Long.MAX_VALUE);\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to start execution\n+            latch.await();\n+\n+            \/\/ thread should park\n+            int expected = JVMTI_THREAD_STATE_ALIVE |\n+                    JVMTI_THREAD_STATE_WAITING |\n+                    JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT |\n+                    JVMTI_THREAD_STATE_PARKED;\n+            await(thread, expected);\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test state of thread parked with LockSupport.park while holding a monitor.\n+     *\/\n+    @Test\n+    void testParkWhenPinned() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        Object lock = new Object();\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                latch.countDown();\n+                while (!done.get()) {\n+                    LockSupport.park();\n+                }\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to own monitor\n+            latch.await();\n+\n+            \/\/ thread should park\n+            int expected = JVMTI_THREAD_STATE_ALIVE |\n+                    JVMTI_THREAD_STATE_WAITING |\n+                    JVMTI_THREAD_STATE_WAITING_INDEFINITELY |\n+                    JVMTI_THREAD_STATE_PARKED;\n+            await(thread, expected);\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test state of thread parked with LockSupport.parkNanos while holding a monitor.\n+     *\/\n+    @Test\n+    void testParkNanosWhenPinned() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        Object lock = new Object();\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                latch.countDown();\n+                while (!done.get()) {\n+                    LockSupport.parkNanos(Long.MAX_VALUE);\n+                }\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to own monitor\n+            latch.await();\n+\n+            \/\/ thread should park\n+            int expected = JVMTI_THREAD_STATE_ALIVE |\n+                    JVMTI_THREAD_STATE_WAITING |\n+                    JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT |\n+                    JVMTI_THREAD_STATE_PARKED;\n+            await(thread, expected);\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Asserts that the given thread has the expected JVMTI state.\n+     *\/\n+    private static void check(Thread thread, int expected) {\n+        System.err.format(\"  expect state=0x%x (%s) ...%n\", expected, jvmtiStateToString(expected));\n+        int state = jvmtiState(thread);\n+        System.err.format(\"  thread state=0x%x (%s)%n\", state, jvmtiStateToString(state));\n+        assertEquals(expected, state);\n+    }\n+\n+    \/**\n+     * Waits indefinitely for the given thread to get to the target JVMTI state.\n+     *\/\n+    private static void await(Thread thread, int targetState) throws Exception {\n+        System.err.format(\"  await state=0x%x (%s) ...%n\", targetState, jvmtiStateToString(targetState));\n+        int state = jvmtiState(thread);\n+        System.err.format(\"  thread state=0x%x (%s)%n\", state, jvmtiStateToString(state));\n+        while (state != targetState) {\n+            assertTrue(thread.isAlive(), \"Thread has terminated\");\n+            Thread.sleep(20);\n+            state = jvmtiState(thread);\n+            System.err.format(\"  thread state=0x%x (%s)%n\", state, jvmtiStateToString(state));\n+        }\n+    }\n+\n+    private static final int JVMTI_THREAD_STATE_ALIVE = 0x0001;\n+    private static final int JVMTI_THREAD_STATE_TERMINATED = 0x0002;\n+    private static final int JVMTI_THREAD_STATE_RUNNABLE = 0x0004;\n+    private static final int JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER = 0x0400;\n+    private static final int JVMTI_THREAD_STATE_WAITING = 0x0080;\n+    private static final int JVMTI_THREAD_STATE_WAITING_INDEFINITELY = 0x0010;\n+    private static final int JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT = 0x0020;\n+    private static final int JVMTI_THREAD_STATE_SLEEPING = 0x0040;\n+    private static final int JVMTI_THREAD_STATE_IN_OBJECT_WAIT = 0x0100;\n+    private static final int JVMTI_THREAD_STATE_PARKED = 0x0200;\n+    private static final int JVMTI_THREAD_STATE_SUSPENDED = 0x100000;\n+    private static final int JVMTI_THREAD_STATE_INTERRUPTED = 0x200000;\n+    private static final int JVMTI_THREAD_STATE_IN_NATIVE = 0x400000;\n+\n+    private static native void init();\n+    private static native int jvmtiState(Thread thread);\n+\n+    private static String jvmtiStateToString(int state) {\n+        StringJoiner sj = new StringJoiner(\" | \");\n+        if ((state & JVMTI_THREAD_STATE_ALIVE) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_ALIVE\");\n+        if ((state & JVMTI_THREAD_STATE_TERMINATED) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_TERMINATED\");\n+        if ((state & JVMTI_THREAD_STATE_RUNNABLE) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_RUNNABLE\");\n+        if ((state & JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER\");\n+        if ((state & JVMTI_THREAD_STATE_WAITING) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_WAITING\");\n+        if ((state & JVMTI_THREAD_STATE_WAITING_INDEFINITELY) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_WAITING_INDEFINITELY\");\n+        if ((state & JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT\");\n+        if ((state & JVMTI_THREAD_STATE_IN_OBJECT_WAIT) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_IN_OBJECT_WAIT\");\n+        if ((state & JVMTI_THREAD_STATE_PARKED) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_PARKED\");\n+        if ((state & JVMTI_THREAD_STATE_SUSPENDED) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_SUSPENDED\");\n+        if ((state & JVMTI_THREAD_STATE_INTERRUPTED) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_INTERRUPTED\");\n+        if ((state & JVMTI_THREAD_STATE_IN_NATIVE) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_IN_NATIVE\");\n+        String s = sj.toString();\n+        return s.isEmpty() ? \"<empty>\" : s;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/GetThreadState\/GetThreadStateTest.java","additions":416,"deletions":0,"binary":false,"changes":416,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jvmti.h\"\n+\n+static jvmtiEnv *jvmti;\n+\n+JNIEXPORT void JNICALL Java_GetThreadStateTest_init(JNIEnv *env, jclass clazz) {\n+    JavaVM* vm;\n+    jint res;\n+    res = (*env)->GetJavaVM(env, &vm);\n+    if (res != 0) {\n+        (*env)->FatalError(env, \"GetJavaVM failed\");\n+    } else {\n+        res = (*vm)->GetEnv(vm, (void**)&jvmti, JVMTI_VERSION);\n+        if (res != JNI_OK) {\n+            (*env)->FatalError(env, \"GetEnv failed\");\n+        }\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL Java_GetThreadStateTest_jvmtiState(JNIEnv *env, jclass clazz, jobject thread) {\n+    jvmtiError err;\n+    jint state = 0;\n+    err = (*jvmti)->GetThreadState(jvmti, thread, &state);\n+    if (err != JVMTI_ERROR_NONE) {\n+        (*env)->FatalError(env, \"GetThreadState failed\");\n+    }\n+    return state;\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/GetThreadState\/libGetThreadStateTest.c","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -152,2 +152,2 @@\n-            await(ready1); \/\/ to guaranty state is not State.WAITING after await(mready) in test1()\n-            \/\/ wait for test1 threads to reach WAITING state in sleep()\n+            await(ready1); \/\/ to guarantee state is not State.TIMED_WAITING after await(mready) in test1()\n+            \/\/ wait for test1 threads to reach TIMED_WAITING state in sleep()\n@@ -157,1 +157,1 @@\n-                while (state != Thread.State.WAITING) {\n+                while (state != Thread.State.TIMED_WAITING) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadEventTest\/VThreadEventTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,0 +44,5 @@\n+    \/\/ Call GC after compiling as many methods. This would remove the stale methods.\n+    \/\/ This threshold should balance the GC overhead and the cost of keeping lots\n+    \/\/ of stale methods around.\n+    private static final long GC_METHOD_THRESHOLD = Long.getLong(\"gcMethodThreshold\", 100);\n+\n@@ -46,1 +51,2 @@\n-    private static final AtomicLong METHOD_COUNT = new AtomicLong(0L);\n+    private static final AtomicLong METHOD_COUNT = new AtomicLong();\n+    private static final AtomicLong METHODS_SINCE_LAST_GC = new AtomicLong();\n@@ -86,0 +92,15 @@\n+\n+        \/\/ See if we need to schedule a GC\n+        while (true) {\n+            long current = METHODS_SINCE_LAST_GC.get();\n+            long update = current + methodCount;\n+            if (update >= GC_METHOD_THRESHOLD) {\n+                update = 0;\n+            }\n+            if (METHODS_SINCE_LAST_GC.compareAndSet(current, update)) {\n+                if (update == 0) {\n+                    executor.execute(() -> System.gc());\n+                }\n+                break;\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/testlibrary\/ctw\/src\/sun\/hotspot\/tools\/ctw\/Compiler.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -296,1 +296,0 @@\n-                \/\/ Stress* are c2-specific stress flags, so IgnoreUnrecognizedVMOptions is needed\n@@ -298,0 +297,3 @@\n+                \/\/ Do not pay extra zapping cost for explicit GC invocations\n+                \"-XX:-ZapUnusedHeapArea\",\n+                \/\/ Stress* are c2-specific stress flags, so IgnoreUnrecognizedVMOptions is needed\n","filename":"test\/hotspot\/jtreg\/testlibrary\/ctw\/src\/sun\/hotspot\/tools\/ctw\/CtwRunner.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-com\/sun\/jdi\/ReferrersTest.java 8285422 generic-all\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -462,1 +462,0 @@\n-java\/awt\/GraphicsDevice\/CheckDisplayModes.java 8266242 macosx-aarch64\n@@ -566,2 +565,0 @@\n-jdk\/nio\/zipfs\/TestLocOffsetFromZip64EF.java                     8301183 linux-all\n-\n@@ -743,2 +740,0 @@\n-javax\/rmi\/ssl\/SSLSocketParametersTest.sh                        8162906 generic-all\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -457,0 +457,3 @@\n+            if (name.equals(\"java.lang.reflect.Method\")) {\n+                return;\n+            }\n","filename":"test\/jdk\/com\/sun\/jdi\/ReferrersTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @requires vm.compMode != \"Xcomp\"\n","filename":"test\/jdk\/com\/sun\/management\/ThreadMXBean\/ThreadCpuTimeArray.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng\/othervm\/timeout=180 StressDirListings\n+ * @run testng\/othervm\/timeout=180 -Dsun.net.httpserver.nodelay=true StressDirListings\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/StressDirListings.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,10 +24,0 @@\n-\/*\n-  @test\n-  @key headful\n-  @bug 6988428\n-  @summary Tests whether shape is always set\n-  @author anthony.petrov@oracle.com: area=awt.toplevel\n-  @run main ShapeNotSetSometimes\n-*\/\n-\n-\n@@ -35,0 +25,1 @@\n+import java.awt.Dimension;\n@@ -41,0 +32,1 @@\n+import java.awt.Toolkit;\n@@ -44,0 +36,3 @@\n+import java.io.File;\n+import java.io.IOException;\n+import javax.imageio.ImageIO;\n@@ -45,0 +40,7 @@\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 6988428\n+ * @summary Tests whether shape is always set\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 ShapeNotSetSometimes\n+ *\/\n@@ -50,2 +52,1 @@\n-    private static final Color BACKGROUND_COLOR = Color.GREEN;\n-    private static final Color SHAPE_COLOR = Color.WHITE;\n+\n@@ -56,2 +57,0 @@\n-    private final Rectangle bounds = new Rectangle(220, 400, 300, 300);\n-\n@@ -59,0 +58,4 @@\n+    private static final Color BACKGROUND_COLOR = Color.GREEN;\n+    private static final Color SHAPE_COLOR = Color.WHITE;\n+    private static final int DIM = 300;\n+    private static final int DELTA = 2;\n@@ -63,0 +66,1 @@\n+        robot.delay(500);\n@@ -68,1 +72,2 @@\n-        backgroundFrame.setBounds(bounds);\n+        backgroundFrame.setSize(DIM, DIM);\n+        backgroundFrame.setLocationRelativeTo(null);\n@@ -79,1 +84,1 @@\n-\n+        \/\/ point at the center of white ellipse\n@@ -81,0 +86,2 @@\n+\n+        \/\/ mid points on the 4 sides - on the green background frame\n@@ -88,0 +95,1 @@\n+        \/\/ points just outside the ellipse (opposite side of diagonal)\n@@ -95,1 +103,2 @@\n-        window.setBounds(bounds);\n+        window.setSize(DIM, DIM);\n+        window.setLocationRelativeTo(null);\n@@ -106,1 +115,1 @@\n-            g.fillRect(0, 0, 300, 300);\n+            g.fillRect(0, 0, DIM, DIM);\n@@ -118,1 +127,1 @@\n-            g.fillRect(0, 0, bounds.width, bounds.height);\n+            g.fillRect(0, 0, DIM, DIM);\n@@ -127,1 +136,1 @@\n-        for(int i = 0; i < 50; i++) {\n+        for (int i = 1; i <= 50; i++) {\n@@ -139,1 +148,0 @@\n-\n@@ -154,2 +162,6 @@\n-                backgroundFrame.dispose();\n-                window.dispose();\n+                if (backgroundFrame != null) {\n+                    backgroundFrame.dispose();\n+                }\n+                if (window != null) {\n+                    window.dispose();\n+                }\n@@ -161,1 +173,0 @@\n-\n@@ -165,0 +176,4 @@\n+        robot.mouseMove(screenX, screenY);\n+        robot.waitForIdle();\n+        robot.delay(50);\n+\n@@ -175,1 +190,2 @@\n-        if (mustBeExpectedColor != expectedColor.equals(actualColor)) {\n+        if (mustBeExpectedColor != colorCompare(expectedColor, actualColor)) {\n+            captureScreen();\n@@ -177,1 +193,0 @@\n-\n@@ -188,0 +203,23 @@\n+\n+    private static boolean colorCompare(Color expected, Color actual) {\n+        if (Math.abs(expected.getRed() - actual.getRed()) <= DELTA\n+                && Math.abs(expected.getGreen() - actual.getGreen()) <= DELTA\n+                && Math.abs(expected.getBlue() - actual.getBlue()) <= DELTA) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private static void captureScreen() {\n+        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n+        Rectangle screenBounds = new Rectangle(0, 0, screenSize.width, screenSize.height);\n+        try {\n+            ImageIO.write(\n+                    robot.createScreenCapture(screenBounds),\n+                    \"png\",\n+                    new File(\"Screenshot.png\")\n+            );\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n","filename":"test\/jdk\/java\/awt\/Frame\/ShapeNotSetSometimes\/ShapeNotSetSometimes.java","additions":65,"deletions":27,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4475478\n+ * @summary Tests that there is no NullPointerException\n+            thrown when we try to set Frame's icon\n+            which has null data\n+ * @key headful\n+ * @run main SetIconImageExceptionTest\n+*\/\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Image;\n+import java.awt.Toolkit;\n+\n+public class SetIconImageExceptionTest {\n+    static Frame f;\n+\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            try {\n+                \/\/ Test with non-existent image to test with null data\n+                \/\/  not throwing NPE\n+                Image icon = Toolkit.getDefaultToolkit().getImage(\"notexistent.gif\");\n+                f = new Frame(\"Frame with icon\");\n+                f.setIconImage(icon);\n+                f.setVisible(true);\n+            } finally {\n+                if (f != null) {\n+                    f.dispose();\n+                }\n+            }\n+        });\n+    }\n+\n+ }\/\/ class SetIconImageExceptionTest\n+\n","filename":"test\/jdk\/java\/awt\/Icon\/SetIconImageExceptionTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Frame;\n+import java.awt.Menu;\n+import java.awt.MenuItem;\n+import java.awt.PopupMenu;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+\/*\n+ * @test\n+ * @bug 5090643\n+ * @key headful\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Menus added to the popup menu are truncated on XToolkit\n+ * @run main\/manual TruncatedPopupMenuTest\n+ *\/\n+\n+public class TruncatedPopupMenuTest {\n+    private static final String INSTRUCTIONS =\n+            \"1. Right-click on the Test Window.\\n\\n\" +\n+            \"2. Look at the appeared popup menu.\\n\\n\" +\n+            \"3. It should consist of one menu item (\\\"First simple menu item\\\")\\n\" +\n+            \"and one submenu (\\\"Just simple menu for the test\\\").\\n\\n\" +\n+            \"4. The submenu should not be truncated. The submenu title text should\\n\" +\n+            \"be followed by a triangle. On the whole, menu should be good-looking.\\n\\n\" +\n+            \"5. Left-click on the submenu (\\\"Just simple menu for the test\\\").\\n\" +\n+            \"After this operation, a submenu should popup. It should consist of\\n\"+\n+            \"one menu item (\\\"Second simple menu item \\\") and one submenu (\\\"Other Menu\\\").\\n\\n\" +\n+            \"6. The submenu should not be truncated. The \\\"Other Menu\\\" text should be followed by\\n\" +\n+            \"a triangle.\\n\\n\" +\n+            \"On the whole, menu should be good-looking.\\n\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                      .instructions(INSTRUCTIONS)\n+                      .rows(20)\n+                      .columns(55)\n+                      .testUI(TruncatedPopupMenuTest::createTestUI)\n+                      .build()\n+                      .awaitAndCheck();\n+    }\n+\n+    private static Frame createTestUI() {\n+        Menu subMenu = new Menu(\"Just simple menu for the test\");\n+        subMenu.add(new MenuItem(\"Second simple menu item\"));\n+        subMenu.add(new Menu(\"Other Menu\"));\n+\n+        PopupMenu popup = new PopupMenu();\n+        popup.add(new MenuItem(\"First simple menu item\"));\n+        popup.add(subMenu);\n+\n+        Frame testUI = new Frame(\"TruncatedPopupMenuTest\");\n+        testUI.add(popup);\n+        testUI.addMouseListener(new MouseAdapter() {\n+            public void mousePressed(MouseEvent me) {\n+                if (me.isPopupTrigger()) {\n+                    popup.show(me.getComponent(), me.getX(), me.getY());\n+                }\n+            }\n+            public void mouseReleased(MouseEvent me) {\n+                if (me.isPopupTrigger()) {\n+                    popup.show(me.getComponent(), me.getX(), me.getY());\n+                }\n+            }\n+        });\n+\n+        testUI.setSize(400, 400);\n+        return testUI;\n+   }\n+}\n","filename":"test\/jdk\/java\/awt\/PopupMenu\/TruncatedPopupMenuTest.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,5 +32,26 @@\n-import java.awt.*;\n-import java.awt.datatransfer.*;\n-import java.awt.dnd.*;\n-import java.awt.event.*;\n-import java.io.*;\n+import java.awt.AWTEvent;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragGestureRecognizer;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceAdapter;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetAdapter;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseEvent;\n+import java.io.File;\n+import java.io.InputStream;\n@@ -41,1 +62,1 @@\n-    private boolean successCodes[] = { true, false };\n+    private final boolean[] successCodes = { true, false };\n@@ -71,1 +92,3 @@\n-            Thread.sleep(Util.FRAME_ACTIVATION_TIMEOUT);\n+            Robot robot = new Robot();\n+            robot.waitForIdle();\n+            robot.delay(Util.FRAME_ACTIVATION_TIMEOUT);\n@@ -139,1 +162,1 @@\n-    public static final int FRAME_ACTIVATION_TIMEOUT = 3000;\n+    public static final int FRAME_ACTIVATION_TIMEOUT = 1000;\n@@ -142,1 +165,0 @@\n-    static final int MOUSE_RELEASE_TIMEOUT = 1000;\n@@ -161,6 +183,0 @@\n-    private Component clickedComponent = null;\n-\n-    private void reset() {\n-        clickedComponent = null;\n-    }\n-\n@@ -169,1 +185,0 @@\n-            clickedComponent = (Component)e.getSource();\n@@ -175,25 +190,0 @@\n-\n-    public static boolean pointInComponent(Robot robot, Point p, Component comp)\n-      throws InterruptedException {\n-        return theInstance.pointInComponentImpl(robot, p, comp);\n-    }\n-\n-    private boolean pointInComponentImpl(Robot robot, Point p, Component comp)\n-      throws InterruptedException {\n-        robot.waitForIdle();\n-        reset();\n-        robot.mouseMove(p.x, p.y);\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n-        synchronized (SYNC_LOCK) {\n-            robot.mouseRelease(InputEvent.BUTTON1_MASK);\n-            SYNC_LOCK.wait(MOUSE_RELEASE_TIMEOUT);\n-        }\n-\n-        Component c = clickedComponent;\n-\n-        while (c != null && c != comp) {\n-            c = c.getParent();\n-        }\n-\n-        return c == comp;\n-    }\n@@ -229,0 +219,3 @@\n+    private volatile boolean success1 = false;\n+    private volatile boolean success2 = false;\n+\n@@ -261,1 +254,3 @@\n-            Thread.sleep(Util.FRAME_ACTIVATION_TIMEOUT);\n+            Robot robot = new Robot();\n+            robot.waitForIdle();\n+            robot.delay(Util.FRAME_ACTIVATION_TIMEOUT);\n@@ -264,1 +259,0 @@\n-\n@@ -267,1 +261,0 @@\n-            Robot robot = new Robot();\n@@ -269,1 +262,3 @@\n-            robot.mousePress(InputEvent.BUTTON1_MASK);\n+            robot.waitForIdle();\n+            robot.delay(50);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n@@ -271,2 +266,2 @@\n-                 p.translate(Util.sign(targetPoint.x - p.x),\n-                             Util.sign(targetPoint.y - p.y))) {\n+                p.translate(Util.sign(targetPoint.x - p.x),\n+                            Util.sign(targetPoint.y - p.y))) {\n@@ -274,1 +269,1 @@\n-                Thread.sleep(50);\n+                robot.delay(5);\n@@ -278,1 +273,1 @@\n-                robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n@@ -282,3 +277,7 @@\n-            if (!dragSourceListener.isDropFinished()) {\n-                throw new RuntimeException(\"Drop not finished\");\n-            }\n+            EventQueue.invokeAndWait(() -> {\n+                if (!dragSourceListener.isDropFinished()) {\n+                    throw new RuntimeException(\"Drop not finished\");\n+                }\n+                success1 = dragSourceListener.getDropSuccess();\n+                dragSourceListener.reset();\n+            });\n@@ -286,1 +285,0 @@\n-            boolean success1 = dragSourceListener.getDropSuccess();\n@@ -288,1 +286,0 @@\n-            dragSourceListener.reset();\n@@ -290,1 +287,3 @@\n-            robot.mousePress(InputEvent.BUTTON1_MASK);\n+            robot.waitForIdle();\n+            robot.delay(50);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n@@ -292,2 +291,2 @@\n-                 p.translate(Util.sign(targetPoint.x - p.x),\n-                             Util.sign(targetPoint.y - p.y))) {\n+                p.translate(Util.sign(targetPoint.x - p.x),\n+                            Util.sign(targetPoint.y - p.y))) {\n@@ -295,1 +294,1 @@\n-                Thread.sleep(50);\n+                robot.delay(5);\n@@ -299,1 +298,1 @@\n-                robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n@@ -303,3 +302,7 @@\n-            if (!dragSourceListener.isDropFinished()) {\n-                throw new RuntimeException(\"Drop not finished\");\n-            }\n+            EventQueue.invokeAndWait(() -> {\n+                if (!dragSourceListener.isDropFinished()) {\n+                    throw new RuntimeException(\"Drop not finished\");\n+                }\n+                success2 = dragSourceListener.getDropSuccess();\n+                dragSourceListener.reset();\n+            });\n@@ -307,1 +310,0 @@\n-            boolean success2 = dragSourceListener.getDropSuccess();\n","filename":"test\/jdk\/java\/awt\/dnd\/InterJVMGetDropSuccessTest\/InterJVMGetDropSuccessTest.java","additions":66,"deletions":64,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Locale;\n@@ -545,1 +546,2 @@\n-            label.setText(String.format(\"Test timeout: %02d:%02d:%02d\",\n+            label.setText(String.format(Locale.ENGLISH,\n+                                        \"Test timeout: %02d:%02d:%02d\",\n","filename":"test\/jdk\/java\/awt\/regtesthelpers\/PassFailJFrame.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n@@ -34,0 +36,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -37,1 +40,3 @@\n-import java.io.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -40,0 +45,2 @@\n+import static jdk.test.lib.process.ProcessTools.*;\n+\n@@ -59,1 +66,1 @@\n-    public static void main(String[] args) throws Exception {\n+    public static void main(String[] args) throws Throwable {\n@@ -80,4 +87,2 @@\n-                String command = System.getProperty(\"java.home\") +\n-                    File.separator + \"bin\" + File.separator + \"java Assert\";\n-\n-                StringBuffer commandString = new StringBuffer(command);\n+                List<String> commands = new ArrayList<>();\n+                commands.add(\"Assert\");\n@@ -85,5 +90,2 @@\n-                    commandString.append(\" \"+switches[j]);\n-\n-                Process p = null;\n-                p = Runtime.getRuntime().exec(commandString.toString());\n-\n+                    commands.add(Integer.toString(switches[j]));\n+                OutputAnalyzer outputAnalyzer = executeCommand(createLimitedTestJavaProcessBuilder(commands));\n@@ -91,7 +93,3 @@\n-                    BufferedReader blah = new BufferedReader(\n-                                          new InputStreamReader(p.getInputStream()));\n-                    String outString = blah.readLine();\n-                    while (outString != null) {\n-                        System.out.println(\"from BufferedReader:\"+outString);\n-                        outString = blah.readLine();\n-                    }\n+                    outputAnalyzer.asLines()\n+                                  .stream()\n+                                  .forEach(s -> System.out.println(s));\n@@ -99,3 +97,1 @@\n-\n-                p.waitFor();\n-                int result = p.exitValue();\n+                int result = outputAnalyzer.getExitValue();\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/Assert.java","additions":18,"deletions":22,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires vm.flagless\n@@ -44,0 +45,2 @@\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -121,2 +124,3 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(args);\n-        int res = pb.directory(tmpFolder).inheritIO().start().waitFor();\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(args)\n+                                        .directory(tmpFolder);\n+        int res = ProcessTools.executeProcess(pb).getExitValue();\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/GetSystemPackage.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-import java.util.Map;\n@@ -47,1 +46,0 @@\n-import jdk.test.lib.JDKToolFinder;\n@@ -147,2 +145,0 @@\n-        String javapath = JDKToolFinder.getJDKTool(\"java\");\n-\n@@ -150,1 +146,0 @@\n-        cmdLine.add(javapath);\n@@ -155,12 +150,3 @@\n-\n-        System.out.println(\"Command line: \" + cmdLine);\n-        ProcessBuilder pb =\n-            new ProcessBuilder(cmdLine.stream().toArray(String[]::new));\n-\n-        \/\/ change working directory\n-        pb.directory(dir.toFile());\n-\n-        \/\/ remove CLASSPATH environment variable\n-        Map<String,String> env = pb.environment();\n-        String value = env.remove(\"CLASSPATH\");\n-\n+        ProcessBuilder pb = createTestJavaProcessBuilder(cmdLine);\n+        pb.directory(dir.toFile()); \/\/ change working directory\n+        pb.environment().remove(\"CLASSPATH\"); \/\/ remove CLASSPATH environment variable\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/getResource\/GetResource.java","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import jdk.test.lib.JDKToolFinder;\n@@ -44,4 +43,1 @@\n-import java.lang.ProcessBuilder;\n-import java.lang.Process;\n-import java.io.File;\n-import java.util.*;\n+import static jdk.test.lib.process.ProcessTools.*;\n@@ -54,12 +50,0 @@\n-    private static Process runJavaCommand(String... command) throws Throwable {\n-        String java = JDKToolFinder.getJDKTool(\"java\");\n-        List<String> commands = new ArrayList<>();\n-        Collections.addAll(commands, java);\n-        Collections.addAll(commands, command);\n-        System.out.println(\"COMMAND: \" + String.join(\" \", commands));\n-        return new ProcessBuilder(commands.toArray(new String[0]))\n-                .redirectErrorStream(true)\n-                .directory(new File(testClassPath))\n-                .start();\n-    }\n-\n@@ -81,1 +65,1 @@\n-        Process process = runJavaCommand(\n+        OutputAnalyzer outputAnalyzer = executeCommand(createTestJavaProcessBuilder(\n@@ -84,3 +68,1 @@\n-                \"LoadLibraryUnload\");\n-\n-        OutputAnalyzer outputAnalyzer = new OutputAnalyzer(process);\n+                \"LoadLibraryUnload\"));\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/loadLibraryUnload\/LoadLibraryUnloadTest.java","additions":4,"deletions":22,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -559,3 +559,1 @@\n-        for(int i = 0; i < input.length; i++) {\n-            double d;\n-\n+        for (String s : input) {\n@@ -563,5 +561,4 @@\n-                d = Double.parseDouble(input[i]);\n-                check(input[i]);\n-            }\n-            catch (NumberFormatException e) {\n-                if (! exceptionalInput) {\n+                Double.parseDouble(s);\n+                check(s);\n+            } catch (NumberFormatException e) {\n+                if (!exceptionalInput) {\n@@ -569,1 +566,1 @@\n-                                               \"good string `\" + input[i] +\n+                                               \"good string `\" + s +\n@@ -572,1 +569,1 @@\n-                break;\n+                continue;\n@@ -576,1 +573,1 @@\n-                                           \"bad string `\" + input[i] +\n+                                           \"bad string `\" + s +\n","filename":"test\/jdk\/java\/lang\/Double\/ParseDouble.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -279,3 +279,1 @@\n-        for(int i = 0; i < input.length; i++) {\n-            double d;\n-\n+        for (String s : input) {\n@@ -283,5 +281,4 @@\n-                d = Float.parseFloat(input[i]);\n-                check(input[i]);\n-            }\n-            catch (NumberFormatException e) {\n-                if (! exceptionalInput) {\n+                Float.parseFloat(s);\n+                check(s);\n+            } catch (NumberFormatException e) {\n+                if (!exceptionalInput) {\n@@ -289,1 +286,1 @@\n-                                               \"good string `\" + input[i] +\n+                                               \"good string `\" + s +\n@@ -292,1 +289,1 @@\n-                break;\n+                continue;\n@@ -296,1 +293,1 @@\n-                                           \"bad string `\" + input[i] +\n+                                           \"bad string `\" + s +\n","filename":"test\/jdk\/java\/lang\/Float\/ParseFloat.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/Basic.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/InheritIOTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/JspawnhelperProtocol.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/ProcessStartLoggingTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/ReaderWriterTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/SkipTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/ProcessHandle\/OnExitTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/ProcessHandle\/TreeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/RuntimeExitLogTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/exec\/ArgWithSpaceAndFinalBackslash.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+   @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/exec\/Duped.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+   @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/exec\/ExecWithLotsOfArgs.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/exec\/ExitValue.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- *\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/exec\/SetCwd.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-        ProcessBuilder processBuilder = ProcessTools.createLimitedTestJavaProcessBuilder(args);\n+        ProcessBuilder processBuilder = ProcessTools.createTestJavaProcessBuilder(args);\n","filename":"test\/jdk\/java\/lang\/SecurityManager\/modules\/CustomSecurityManagerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+\n+\/*\n+ * @test\n+ * @bug 8077559\n+ * @summary Tests Compact String for negative size.\n+ * @requires vm.bits == 64 & os.maxMemory >= 4G\n+ * @run main\/othervm -XX:+CompactStrings -Xmx4g NegativeSize\n+ * @run main\/othervm -XX:-CompactStrings -Xmx4g NegativeSize\n+ *\/\n+\n+\/\/ In Java8: java.lang.OutOfMemoryError: Java heap space\n+\/\/ In Java9+: was java.lang.NegativeArraySizeException: -1894967266\n+public class NegativeSize {\n+\n+    static byte[] generateData() {\n+        int asciisize = 1_200_000_000;\n+        byte[] nonAscii = \"\".getBytes();\n+        int nonAsciiSize = nonAscii.length;\n+        \/\/ 1 GB\n+        byte[] arr = new byte[asciisize + nonAsciiSize];\n+        for (int i=0; i<asciisize; ++i) {\n+            arr[i] = (byte)('0' + (i % 40));\n+        }\n+        for(int i=0; i<nonAsciiSize; ++i) {\n+            arr[i + asciisize] = nonAscii[i];\n+        }\n+        return arr;\n+    }\n+\n+\n+    public static void main(String[] args) throws IOException {\n+\n+        try {\n+            byte[] largeBytes = generateData();\n+            String inStr = new String(largeBytes, StandardCharsets.UTF_8);\n+            System.out.println(inStr.length());\n+            System.out.println(inStr.substring(1_200_000_000));\n+        } catch (OutOfMemoryError ex) {\n+            if (ex.getMessage().startsWith(\"UTF16 String size is\")) {\n+                System.out.println(\"Succeeded with OutOfMemoryError\");\n+            } else {\n+                throw new RuntimeException(\"Failed: Not the OutOfMemoryError expected\", ex);\n+            }\n+        } catch (NegativeArraySizeException ex) {\n+            throw new RuntimeException(\"Failed: Expected OutOfMemoryError\", ex);\n+        }\n+    }\n+}\n+\n+\n","filename":"test\/jdk\/java\/lang\/String\/CompactString\/NegativeSize.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,0 +99,2 @@\n+                new Object[] { \"\\u0130\", false, 0, \"I\", 0, 1, false },\n+                new Object[] { \"\\u0130\", true,  0, \"I\", 0, 1, true },\n@@ -102,0 +104,2 @@\n+                new Object[] { \"\\u0131\", false, 0, \"I\", 0, 1, false },\n+                new Object[] { \"\\u0131\", true,  0, \"I\", 0, 1, true },\n","filename":"test\/jdk\/java\/lang\/String\/CompactString\/RegionMatches.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @requires !(os.family == \"windows\" & sun.arch.data.model == \"32\")\n+ * @requires vm.bits == \"64\"\n","filename":"test\/jdk\/java\/lang\/String\/StringRepeat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/modules\/JDKLoggerForImageTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/modules\/JDKLoggerForJDKTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/modules\/LoggerInImageTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/modules\/NamedLoggerForImageTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/modules\/NamedLoggerForJDKTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/modules\/UnnamedLoggerForImageTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/modules\/UnnamedLoggerForJDKTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import jdk.test.lib.JDKToolFinder;\n@@ -54,0 +53,1 @@\n+            System.setProperty(\"test.noclasspath\", \"true\");\n@@ -134,2 +134,1 @@\n-            pb = new ProcessBuilder(\n-                    JDKToolFinder.getJDKTool(\"java\"),\n+            pb = ProcessTools.createTestJavaProcessBuilder(\n@@ -139,2 +138,1 @@\n-            pb = new ProcessBuilder(\n-                    JDKToolFinder.getJDKTool(\"java\"),\n+            pb = ProcessTools.createTestJavaProcessBuilder(\n","filename":"test\/jdk\/java\/lang\/System\/SecurityManagerWarnings.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-    private static final Executor DEFAULT_SCHEDULER = defaultScheduler();\n@@ -219,14 +218,0 @@\n-    \/**\n-     * Returns the default scheduler.\n-     *\/\n-    private static Executor defaultScheduler() {\n-        try {\n-            Field defaultScheduler = Class.forName(\"java.lang.VirtualThread\")\n-                    .getDeclaredField(\"DEFAULT_SCHEDULER\");\n-            defaultScheduler.setAccessible(true);\n-            return (Executor) defaultScheduler.get(null);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/CustomScheduler.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8284161 8286788\n+ * @bug 8284161 8286788 8321270\n@@ -109,1 +109,1 @@\n-        awaitParked(thread);\n+        await(thread, Thread.State.WAITING);\n@@ -133,1 +133,1 @@\n-            awaitBlocked(thread);\n+            await(thread, Thread.State.BLOCKED);\n@@ -163,1 +163,1 @@\n-            awaitParked(thread);\n+            await(thread, Thread.State.WAITING);\n@@ -768,0 +768,1 @@\n+            thread.join();\n@@ -900,1 +901,1 @@\n-        awaitParked(thread);\n+        await(thread, Thread.State.TIMED_WAITING);\n@@ -920,1 +921,1 @@\n-        awaitParked(thread);\n+        await(thread, Thread.State.WAITING);\n@@ -1035,1 +1036,1 @@\n-            assertTrue(me.getPriority() == Thread.NORM_PRIORITY);\n+            assertEquals(Thread.NORM_PRIORITY, me.getPriority());\n@@ -1038,1 +1039,1 @@\n-            assertTrue(me.getPriority() == Thread.NORM_PRIORITY);\n+            assertEquals(Thread.NORM_PRIORITY, me.getPriority());\n@@ -1041,1 +1042,1 @@\n-            assertTrue(me.getPriority() == Thread.NORM_PRIORITY);\n+            assertEquals(Thread.NORM_PRIORITY, me.getPriority());\n@@ -1044,1 +1045,1 @@\n-            assertTrue(me.getPriority() == Thread.NORM_PRIORITY);\n+            assertEquals(Thread.NORM_PRIORITY, me.getPriority());\n@@ -1058,1 +1059,1 @@\n-        assertTrue(thread.getPriority() == Thread.NORM_PRIORITY);\n+        assertEquals(Thread.NORM_PRIORITY, thread.getPriority());\n@@ -1061,1 +1062,1 @@\n-        assertTrue(thread.getPriority() == Thread.NORM_PRIORITY);\n+        assertEquals(Thread.NORM_PRIORITY, thread.getPriority());\n@@ -1064,1 +1065,1 @@\n-        assertTrue(thread.getPriority() == Thread.NORM_PRIORITY);\n+        assertEquals(Thread.NORM_PRIORITY, thread.getPriority());\n@@ -1067,1 +1068,1 @@\n-        assertTrue(thread.getPriority() == Thread.NORM_PRIORITY);\n+        assertEquals(Thread.NORM_PRIORITY, thread.getPriority());\n@@ -1074,1 +1075,1 @@\n-            assertTrue(thread.getPriority() == Thread.NORM_PRIORITY);\n+            assertEquals(Thread.NORM_PRIORITY, thread.getPriority());\n@@ -1078,1 +1079,1 @@\n-            assertTrue(thread.getPriority() == Thread.NORM_PRIORITY);\n+            assertEquals(Thread.NORM_PRIORITY, thread.getPriority());\n@@ -1081,1 +1082,1 @@\n-            assertTrue(thread.getPriority() == Thread.NORM_PRIORITY);\n+            assertEquals(Thread.NORM_PRIORITY, thread.getPriority());\n@@ -1084,1 +1085,1 @@\n-            assertTrue(thread.getPriority() == Thread.NORM_PRIORITY);\n+            assertEquals(Thread.NORM_PRIORITY, thread.getPriority());\n@@ -1094,1 +1095,1 @@\n-        assertTrue(thread.getPriority() == Thread.NORM_PRIORITY);\n+        assertEquals(Thread.NORM_PRIORITY, thread.getPriority());\n@@ -1193,0 +1194,30 @@\n+    \/**\n+     * Test that Thread.yield does not consume the thread's parking permit.\n+     *\/\n+    @Test\n+    void testYield3() throws Exception {\n+        var thread = Thread.ofVirtual().start(() -> {\n+            LockSupport.unpark(Thread.currentThread());\n+            Thread.yield();\n+            LockSupport.park();  \/\/ should not park\n+        });\n+        thread.join();\n+    }\n+\n+    \/**\n+     * Test that Thread.yield does not make available the thread's parking permit.\n+     *\/\n+    @Test\n+    void testYield4() throws Exception {\n+        var thread = Thread.ofVirtual().start(() -> {\n+            Thread.yield();\n+            LockSupport.park();  \/\/ should park\n+        });\n+        try {\n+            await(thread, Thread.State.WAITING);\n+        } finally {\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n@@ -1653,1 +1684,1 @@\n-     * Test Thread::getState when thread is not started.\n+     * Test Thread::getState when thread is new\/unstarted.\n@@ -1658,1 +1689,1 @@\n-        assertTrue(thread.getState() == Thread.State.NEW);\n+        assertEquals(Thread.State.NEW, thread.getState());\n@@ -1662,1 +1693,1 @@\n-     * Test Thread::getState when thread is runnable (mounted).\n+     * Test Thread::getState when thread is terminated.\n@@ -1666,3 +1697,19 @@\n-        VThreadRunner.run(() -> {\n-            Thread.State state = Thread.currentThread().getState();\n-            assertTrue(state == Thread.State.RUNNABLE);\n+        var thread = Thread.ofVirtual().start(() -> { });\n+        thread.join();\n+        assertEquals(Thread.State.TERMINATED, thread.getState());\n+    }\n+\n+    \/**\n+     * Test Thread::getState when thread is runnable (mounted).\n+     *\/\n+    @Test\n+    void testGetState3() throws Exception {\n+        var started = new CountDownLatch(1);\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            started.countDown();\n+\n+            \/\/ spin until done\n+            while (!done.get()) {\n+                Thread.onSpinWait();\n+            }\n@@ -1670,0 +1717,10 @@\n+        try {\n+            \/\/ wait for thread to start\n+            started.await();\n+\n+            \/\/ thread should be runnable\n+            assertEquals(Thread.State.RUNNABLE, thread.getState());\n+        } finally {\n+            done.set(true);\n+            thread.join();\n+        }\n@@ -1676,1 +1733,1 @@\n-    void testGetState3() throws Exception {\n+    void testGetState4() throws Exception {\n@@ -1683,1 +1740,1 @@\n-                assertTrue(t2.getState() == Thread.State.NEW);\n+                assertEquals(Thread.State.NEW, t2.getState());\n@@ -1688,1 +1745,1 @@\n-                    assertTrue(t2.getState() == Thread.State.RUNNABLE);\n+                    assertEquals(Thread.State.RUNNABLE, t2.getState());\n@@ -1692,1 +1749,1 @@\n-                    assertTrue(t2.getState() == Thread.State.WAITING);\n+                    assertEquals(Thread.State.WAITING, t2.getState());\n@@ -1699,1 +1756,1 @@\n-                assertTrue(t2.getState() == Thread.State.RUNNABLE);\n+                assertEquals(Thread.State.RUNNABLE, t2.getState());\n@@ -1709,1 +1766,1 @@\n-     * Test Thread::getState when thread is parked.\n+     * Test Thread::getState when thread is waiting to enter a monitor.\n@@ -1712,4 +1769,12 @@\n-    void testGetState4() throws Exception {\n-        var thread = Thread.ofVirtual().start(LockSupport::park);\n-        while (thread.getState() != Thread.State.WAITING) {\n-            Thread.sleep(20);\n+    void testGetState5() throws Exception {\n+        var started = new CountDownLatch(1);\n+        var thread = Thread.ofVirtual().unstarted(() -> {\n+            started.countDown();\n+            synchronized (lock) { }\n+        });\n+        synchronized (lock) {\n+            thread.start();\n+            started.await();\n+\n+            \/\/ wait for thread to block\n+            await(thread, Thread.State.BLOCKED);\n@@ -1717,1 +1782,0 @@\n-        LockSupport.unpark(thread);\n@@ -1722,1 +1786,1 @@\n-     * Test Thread::getState when thread is parked while holding a monitor.\n+     * Test Thread::getState when thread is waiting in Object.wait.\n@@ -1725,1 +1789,1 @@\n-    void testGetState5() throws Exception {\n+    void testGetState6() throws Exception {\n@@ -1728,1 +1792,1 @@\n-                LockSupport.park();\n+                try { lock.wait(); } catch (InterruptedException e) { }\n@@ -1731,2 +1795,6 @@\n-        while (thread.getState() != Thread.State.WAITING) {\n-            Thread.sleep(20);\n+        try {\n+            \/\/ wait for thread to wait\n+            await(thread, Thread.State.WAITING);\n+        } finally {\n+            thread.interrupt();\n+            thread.join();\n@@ -1734,2 +1802,0 @@\n-        LockSupport.unpark(thread);\n-        thread.join();\n@@ -1739,1 +1805,1 @@\n-     * Test Thread::getState when thread is waiting for a monitor.\n+     * Test Thread::getState when thread is waiting in Object.wait(millis).\n@@ -1742,8 +1808,6 @@\n-    void testGetState6() throws Exception {\n-        var thread = Thread.ofVirtual().unstarted(() -> {\n-            synchronized (lock) { }\n-        });\n-        synchronized (lock) {\n-            thread.start();\n-            while (thread.getState() != Thread.State.BLOCKED) {\n-                Thread.sleep(20);\n+    void testGetState7() throws Exception {\n+        var thread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                try {\n+                    lock.wait(Long.MAX_VALUE);\n+                } catch (InterruptedException e) { }\n@@ -1751,0 +1815,7 @@\n+        });\n+        try {\n+            \/\/ wait for thread to wait\n+            await(thread, Thread.State.TIMED_WAITING);\n+        } finally {\n+            thread.interrupt();\n+            thread.join();\n@@ -1752,1 +1823,0 @@\n-        thread.join();\n@@ -1756,1 +1826,1 @@\n-     * Test Thread::getState when thread is waiting in Object.wait.\n+     * Test Thread::getState when thread is parked.\n@@ -1759,1 +1829,31 @@\n-    void testGetState7() throws Exception {\n+    void testGetState8() throws Exception {\n+        var thread = Thread.ofVirtual().start(LockSupport::park);\n+        try {\n+            await(thread, Thread.State.WAITING);\n+        } finally {\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test Thread::getState when thread is timed parked.\n+     *\/\n+    @Test\n+    void testGetState9() throws Exception {\n+        var thread = Thread.ofVirtual().start(() -> LockSupport.parkNanos(Long.MAX_VALUE));\n+        try {\n+            await(thread, Thread.State.TIMED_WAITING);\n+        } finally {\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test Thread::getState when thread is parked while holding a monitor.\n+     *\/\n+    @Test\n+    void testGetState10() throws Exception {\n+        var started = new CountDownLatch(1);\n+        var done = new AtomicBoolean();\n@@ -1761,0 +1861,1 @@\n+            started.countDown();\n@@ -1762,1 +1863,3 @@\n-                try { lock.wait(); } catch (InterruptedException e) { }\n+                while (!done.get()) {\n+                    LockSupport.park();\n+                }\n@@ -1765,2 +1868,10 @@\n-        while (thread.getState() != Thread.State.WAITING) {\n-            Thread.sleep(20);\n+        try {\n+            \/\/ wait for thread to start\n+            started.await();\n+\n+            \/\/ wait for thread to park\n+            await(thread, Thread.State.WAITING);\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n@@ -1768,2 +1879,0 @@\n-        thread.interrupt();\n-        thread.join();\n@@ -1773,1 +1882,1 @@\n-     * Test Thread::getState when thread is terminated.\n+     * Test Thread::getState when thread is timed parked while holding a monitor.\n@@ -1776,4 +1885,22 @@\n-    void testGetState8() throws Exception {\n-        var thread = Thread.ofVirtual().start(() -> { });\n-        thread.join();\n-        assertTrue(thread.getState() == Thread.State.TERMINATED);\n+    void testGetState11() throws Exception {\n+        var started = new CountDownLatch(1);\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            started.countDown();\n+            synchronized (lock) {\n+                while (!done.get()) {\n+                    LockSupport.parkNanos(Long.MAX_VALUE);\n+                }\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to start\n+            started.await();\n+\n+            \/\/ wait for thread to park\n+            await(thread, Thread.State.TIMED_WAITING);\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n@@ -1902,3 +2029,1 @@\n-            while (vthread.getState() != Thread.State.WAITING) {\n-                Thread.sleep(20);\n-            }\n+            await(vthread, Thread.State.WAITING);\n@@ -1931,6 +2056,1 @@\n-\n-        \/\/ wait for thread to park\n-        while (thread.getState() != Thread.State.WAITING) {\n-            Thread.sleep(20);\n-        }\n-\n+        await(thread, Thread.State.WAITING);\n@@ -1999,3 +2119,1 @@\n-            while (vthread.getState() != Thread.State.WAITING) {\n-                Thread.sleep(20);\n-            }\n+            await(vthread, Thread.State.WAITING);\n@@ -2037,1 +2155,1 @@\n-            assertTrue(thread.getThreadGroup() == vgroup);\n+            assertEquals(vgroup, thread.getThreadGroup());\n@@ -2054,1 +2172,1 @@\n-            assertTrue(group == vgroup);\n+            assertEquals(vgroup, group);\n@@ -2071,1 +2189,1 @@\n-        assertTrue(vgroup.getMaxPriority() == Thread.MAX_PRIORITY);\n+        assertEquals(Thread.MAX_PRIORITY, vgroup.getMaxPriority());\n@@ -2075,1 +2193,1 @@\n-        assertTrue(group.getMaxPriority() == Thread.MAX_PRIORITY);\n+        assertEquals(Thread.MAX_PRIORITY, group.getMaxPriority());\n@@ -2078,2 +2196,2 @@\n-        assertTrue(vgroup.getMaxPriority() == Thread.MAX_PRIORITY);\n-        assertTrue(group.getMaxPriority() == Thread.MAX_PRIORITY - 1);\n+        assertEquals(Thread.MAX_PRIORITY, vgroup.getMaxPriority());\n+        assertEquals(Thread.MAX_PRIORITY - 1, group.getMaxPriority());\n@@ -2082,2 +2200,2 @@\n-        assertTrue(vgroup.getMaxPriority() == Thread.MAX_PRIORITY);\n-        assertTrue(group.getMaxPriority() == Thread.MIN_PRIORITY);\n+        assertEquals(Thread.MAX_PRIORITY, vgroup.getMaxPriority());\n+        assertEquals(Thread.MIN_PRIORITY, group.getMaxPriority());\n@@ -2094,2 +2212,1 @@\n-\n-            assertTrue(vgroup.getMaxPriority() == Thread.MAX_PRIORITY);\n+            assertEquals(Thread.MAX_PRIORITY, vgroup.getMaxPriority());\n@@ -2098,2 +2215,2 @@\n-            assertTrue(group.getParent() == vgroup);\n-            assertTrue(group.getMaxPriority() == Thread.MAX_PRIORITY);\n+            assertEquals(vgroup, group.getParent());\n+            assertEquals(Thread.MAX_PRIORITY, group.getMaxPriority());\n@@ -2102,2 +2219,2 @@\n-            assertTrue(vgroup.getMaxPriority() == Thread.MAX_PRIORITY);\n-            assertTrue(group.getMaxPriority() == Thread.MAX_PRIORITY - 1);\n+            assertEquals(Thread.MAX_PRIORITY, vgroup.getMaxPriority());\n+            assertEquals(Thread.MAX_PRIORITY - 1, group.getMaxPriority());\n@@ -2106,2 +2223,2 @@\n-            assertTrue(vgroup.getMaxPriority() == Thread.MAX_PRIORITY);\n-            assertTrue(group.getMaxPriority() == Thread.MIN_PRIORITY);\n+            assertEquals(Thread.MAX_PRIORITY, vgroup.getMaxPriority());\n+            assertEquals(Thread.MIN_PRIORITY, group.getMaxPriority());\n@@ -2211,3 +2328,1 @@\n-        while (thread.getState() != Thread.State.WAITING) {\n-            Thread.sleep(10);\n-        }\n+        await(thread, Thread.State.WAITING);\n@@ -2236,13 +2351,1 @@\n-     * Waits for the given thread to park.\n-     *\/\n-    static void awaitParked(Thread thread) throws InterruptedException {\n-        Thread.State state = thread.getState();\n-        while (state != Thread.State.WAITING && state != Thread.State.TIMED_WAITING) {\n-            assertTrue(state != Thread.State.TERMINATED, \"Thread has terminated\");\n-            Thread.sleep(10);\n-            state = thread.getState();\n-        }\n-    }\n-\n-    \/**\n-     * Waits for the given thread to block waiting on a monitor.\n+     * Waits for the given thread to reach a given state.\n@@ -2250,1 +2353,1 @@\n-    static void awaitBlocked(Thread thread) throws InterruptedException {\n+    private void await(Thread thread, Thread.State expectedState) throws InterruptedException {\n@@ -2252,1 +2355,1 @@\n-        while (state != Thread.State.BLOCKED) {\n+        while (state != expectedState) {\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadAPI.java","additions":214,"deletions":111,"binary":false,"changes":325,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-        Thread.Builder.OfVirtual builder = Thread.ofVirtual();\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadBuilders.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8284161 8289284\n+ * @bug 8284161 8289284 8322846\n@@ -37,0 +37,1 @@\n+import java.util.concurrent.Executors;\n@@ -70,0 +71,1 @@\n+        assertContains(output, \"reason:MONITOR\");\n@@ -71,1 +73,0 @@\n-        assertDoesNotContain(output, \"(Native Method)\");\n@@ -81,0 +82,1 @@\n+        assertContains(output, \"reason:NATIVE\");\n@@ -82,1 +84,60 @@\n-        assertDoesNotContain(output, \"<== monitors\");\n+    }\n+\n+    \/**\n+     * Test parking in class initializer.\n+     *\/\n+    @Test\n+    void testPinnedCausedByClassInitializer() throws Exception {\n+        class C {\n+            static {\n+                park();\n+            }\n+        }\n+        String output = run(C::new);\n+        assertContains(output, \"reason:NATIVE\");\n+        assertContains(output, \"<clinit>\");\n+    }\n+\n+    \/**\n+     * Test contention writing to System.out when pinned. The test creates four threads\n+     * that write to System.out when pinned, this is enough to potentially deadlock\n+     * without the changes in JDK-8322846.\n+     *\/\n+    @Test\n+    void testContention() throws Exception {\n+        \/\/ use several classes to avoid duplicate stack traces\n+        class C1 {\n+            synchronized void print() {\n+                System.out.println(\"hello\");\n+            }\n+        }\n+        class C2 {\n+            synchronized void print() {\n+                System.out.println(\"hello\");\n+            }\n+        }\n+        class C3 {\n+            synchronized void print() {\n+                System.out.println(\"hello\");\n+            }\n+        }\n+        class C4 {\n+            synchronized void print() {\n+                System.out.println(\"hello\");\n+            }\n+        }\n+\n+        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n+            executor.submit(() -> {\n+                new C1().print();\n+            });\n+            executor.submit(() -> {\n+                new C2().print();\n+            });\n+            executor.submit(() -> {\n+                new C3().print();\n+            });\n+            executor.submit(() -> {\n+                new C4().print();\n+            });\n+        }\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/TracePinnedThreads.java","additions":65,"deletions":4,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8322818\n+ * @summary Stress test Thread.getStackTrace on a virtual thread that is pinned\n+ * @requires vm.debug != true\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run main\/othervm GetStackTraceALotWhenPinned 500000\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=300 GetStackTraceALotWhenPinned 200000\n+ *\/\n+\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.LockSupport;\n+import jdk.test.lib.thread.VThreadRunner;\n+\n+public class GetStackTraceALotWhenPinned {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ need at least two carrier threads when main thread is a virtual thread\n+        if (Thread.currentThread().isVirtual()) {\n+            VThreadRunner.ensureParallelism(2);\n+        }\n+\n+        int iterations = Integer.parseInt(args[0]);\n+        var barrier = new Barrier(2);\n+\n+        \/\/ Start a virtual thread that loops doing Thread.yield and parking while pinned.\n+        \/\/ This loop creates the conditions for the main thread to sample the stack trace\n+        \/\/ as it transitions from being unmounted to parking while pinned.\n+        var thread = Thread.startVirtualThread(() -> {\n+            boolean timed = false;\n+            for (int i = 0; i < iterations; i++) {\n+                \/\/ wait for main thread to arrive\n+                barrier.await();\n+\n+                Thread.yield();\n+                synchronized (GetStackTraceALotWhenPinned.class) {\n+                    if (timed) {\n+                        LockSupport.parkNanos(Long.MAX_VALUE);\n+                    } else {\n+                        LockSupport.park();\n+                    }\n+                }\n+                timed = !timed;\n+            }\n+        });\n+\n+        long lastTimestamp = System.currentTimeMillis();\n+        for (int i = 0; i < iterations; i++) {\n+            \/\/ wait for virtual thread to arrive\n+            barrier.await();\n+\n+            thread.getStackTrace();\n+            LockSupport.unpark(thread);\n+\n+            long currentTime = System.currentTimeMillis();\n+            if ((currentTime - lastTimestamp) > 500) {\n+                System.out.format(\"%s %d remaining ...%n\", Instant.now(), (iterations - i));\n+                lastTimestamp = currentTime;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Alow threads wait for each other to reach a common barrier point. This class does\n+     * not park threads that are waiting for the barrier to trip, instead it spins. This\n+     * makes it suitable for tests that use LockSupport.park or Thread.yield.\n+     *\/\n+    private static class Barrier {\n+        private final int parties;\n+        private final AtomicInteger count;\n+        private volatile int generation;\n+\n+        Barrier(int parties) {\n+            this.parties = parties;\n+            this.count = new AtomicInteger(parties);\n+        }\n+\n+        void await() {\n+            int g = generation;\n+            if (count.decrementAndGet() == 0) {\n+                count.set(parties);\n+                generation = g + 1;\n+            } else {\n+                while (generation == g) {\n+                    Thread.onSpinWait();\n+                }\n+            }\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALotWhenPinned.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Stress test parking and unparking\n+ * @requires vm.debug != true\n+ * @run main\/othervm ParkALot 500000\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true\n+ * @run main\/othervm ParkALot 100000\n+ *\/\n+\n+import java.time.Instant;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class ParkALot {\n+    private static final int ITERATIONS = 1_000_000;\n+\n+    public static void main(String[] args) {\n+        int iterations;\n+        if (args.length > 0) {\n+            iterations = Integer.parseInt(args[0]);\n+        } else {\n+            iterations = ITERATIONS;\n+        }\n+\n+        int maxThreads = Math.clamp(Runtime.getRuntime().availableProcessors() \/ 2, 1, 4);\n+        for (int nthreads = 1; nthreads <= maxThreads; nthreads++) {\n+            System.out.format(\"%s %d thread(s) ...%n\", Instant.now(), nthreads);\n+            ThreadFactory factory = Thread.ofPlatform().factory();\n+            try (var executor = Executors.newThreadPerTaskExecutor(factory)) {\n+                for (int i = 0; i < nthreads; i++) {\n+                    executor.submit(() -> parkALot(iterations));\n+                }\n+            }\n+            System.out.format(\"%s %d thread(s) done%n\", Instant.now(), nthreads);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a virtual thread that alternates between untimed and timed parking.\n+     * A platform thread spins unparking the virtual thread.\n+     *\/\n+    private static void parkALot(int iterations) {\n+        Thread vthread = Thread.ofVirtual().start(() -> {\n+            int i = 0;\n+            boolean timed = false;\n+            while (i < iterations) {\n+                if (timed) {\n+                    LockSupport.parkNanos(Long.MAX_VALUE);\n+                    timed = false;\n+                } else {\n+                    LockSupport.park();\n+                    timed = true;\n+                }\n+                i++;\n+            }\n+        });\n+\n+        Thread.State state;\n+        while ((state = vthread.getState()) != Thread.State.TERMINATED) {\n+            if (state == Thread.State.WAITING || state == Thread.State.TIMED_WAITING) {\n+                LockSupport.unpark(vthread);\n+            } else {\n+                Thread.yield();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/ParkALot.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -47,1 +47,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"CondyNestedResolution\");\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\"CondyNestedResolution\");\n","filename":"test\/jdk\/java\/lang\/invoke\/condy\/CondyNestedResolutionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,1 @@\n-import jdk.test.lib.JDKToolFinder;\n-import jdk.test.lib.process.ProcessTools;\n+import static jdk.test.lib.process.ProcessTools.*;\n@@ -46,1 +45,0 @@\n-    static final String JAVA_LAUNCHER = JDKToolFinder.getJDKTool(\"java\");\n@@ -62,2 +60,3 @@\n-        ProcessTools.executeCommand(JAVA_LAUNCHER, \"-cp\", classpath, TEST_MAIN_CLASS)\n-                    .shouldHaveExitValue(0);\n+        executeCommand(createTestJavaProcessBuilder(\"-cp\", classpath,\n+                                                    TEST_MAIN_CLASS))\n+                .shouldHaveExitValue(0);\n@@ -75,5 +74,4 @@\n-        ProcessTools.executeCommand(JAVA_LAUNCHER,\n-                                    \"-cp\", TEST_CLASS_PATH,\n-                                    \"-p\", modules.toString(),\n-                                    \"-m\", TEST_MODULE + \"\/\" + TEST_MAIN_CLASS)\n-                    .shouldHaveExitValue(0);\n+        executeCommand(createTestJavaProcessBuilder(\"-cp\", TEST_CLASS_PATH,\n+                                                    \"-p\", modules.toString(),\n+                                                    \"-m\", TEST_MODULE + \"\/\" + TEST_MAIN_CLASS))\n+                .shouldHaveExitValue(0);\n","filename":"test\/jdk\/java\/lang\/invoke\/findSpecial\/FindSpecialTest.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,171 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.BufferedReader;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.nio.charset.Charset;\n-import java.nio.file.Files;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n-\n-\/*\n- * support infrastructure to invoke a java class from the command line\n- *\/\n-class LUtils {\n-    static final com.sun.tools.javac.Main javac =\n-            new com.sun.tools.javac.Main();\n-    static final File cwd = new File(\".\").getAbsoluteFile();\n-    static final String JAVAHOME = System.getProperty(\"java.home\");\n-    static final boolean isWindows =\n-            System.getProperty(\"os.name\", \"unknown\").startsWith(\"Windows\");\n-    static final File JAVA_BIN_FILE = new File(JAVAHOME, \"bin\");\n-    static final File JAVA_CMD = new File(JAVA_BIN_FILE,\n-            isWindows ? \"java.exe\" : \"java\");\n-    static final File JAR_BIN_FILE = new File(JAVAHOME, \"bin\");\n-    static final File JAR_CMD = new File(JAR_BIN_FILE,\n-            isWindows ? \"jar.exe\" : \"jar\");\n-\n-    protected LUtils() {\n-    }\n-\n-    public static void compile(String... args) {\n-        if (javac.compile(args) != 0) {\n-            throw new RuntimeException(\"compilation fails\");\n-        }\n-    }\n-\n-    static void createFile(File outFile, List<String> content) {\n-        try {\n-            Files.write(outFile.getAbsoluteFile().toPath(), content,\n-                    Charset.defaultCharset());\n-        } catch (IOException ex) {\n-            throw new RuntimeException(ex);\n-        }\n-    }\n-\n-    static File getClassFile(File javaFile) {\n-        return javaFile.getName().endsWith(\".java\")\n-                ? new File(javaFile.getName().replace(\".java\", \".class\"))\n-                : null;\n-    }\n-\n-    static String getSimpleName(File inFile) {\n-        String fname = inFile.getName();\n-        return fname.substring(0, fname.indexOf(\".\"));\n-    }\n-\n-    static TestResult doExec(String... cmds) {\n-        return doExec(null, null, cmds);\n-    }\n-\n-    \/*\n-     * A method which executes a java cmd and returns the results in a container\n-     *\/\n-    static TestResult doExec(Map<String, String> envToSet,\n-            java.util.Set<String> envToRemove, String... cmds) {\n-        String cmdStr = \"\";\n-        for (String x : cmds) {\n-            cmdStr = cmdStr.concat(x + \" \");\n-        }\n-        ProcessBuilder pb = new ProcessBuilder(cmds);\n-        Map<String, String> env = pb.environment();\n-        if (envToRemove != null) {\n-            for (String key : envToRemove) {\n-                env.remove(key);\n-            }\n-        }\n-        if (envToSet != null) {\n-            env.putAll(envToSet);\n-        }\n-        BufferedReader rdr = null;\n-        try {\n-            List<String> outputList = new ArrayList<>();\n-            pb.redirectErrorStream(true);\n-            Process p = pb.start();\n-            rdr = new BufferedReader(new InputStreamReader(p.getInputStream()));\n-            String in = rdr.readLine();\n-            while (in != null) {\n-                outputList.add(in);\n-                in = rdr.readLine();\n-            }\n-            p.waitFor();\n-            p.destroy();\n-\n-            return new TestResult(cmdStr, p.exitValue(), outputList,\n-                    env, new Throwable(\"current stack of the test\"));\n-        } catch (Exception ex) {\n-            ex.printStackTrace();\n-            throw new RuntimeException(ex.getMessage());\n-        }\n-    }\n-\n-    static class TestResult {\n-        String cmd;\n-        int exitValue;\n-        List<String> testOutput;\n-        Map<String, String> env;\n-        Throwable t;\n-\n-        public TestResult(String str, int rv, List<String> oList,\n-                Map<String, String> env, Throwable t) {\n-            cmd = str;\n-            exitValue = rv;\n-            testOutput = oList;\n-            this.env = env;\n-            this.t = t;\n-        }\n-\n-        void assertZero(String message) {\n-            if (exitValue != 0) {\n-                System.err.println(this);\n-                throw new RuntimeException(message);\n-            }\n-        }\n-\n-        @Override\n-        public String toString() {\n-            StringWriter sw = new StringWriter();\n-            PrintWriter status = new PrintWriter(sw);\n-            status.println(\"Cmd: \" + cmd);\n-            status.println(\"Return code: \" + exitValue);\n-            status.println(\"Environment variable:\");\n-            for (String x : env.keySet()) {\n-                status.println(\"\\t\" + x + \"=\" + env.get(x));\n-            }\n-            status.println(\"Output:\");\n-            for (String x : testOutput) {\n-                status.println(\"\\t\" + x);\n-            }\n-            status.println(\"Exception:\");\n-            status.println(t.getMessage());\n-            t.printStackTrace(status);\n-\n-            return sw.getBuffer().toString();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LUtils.java","additions":0,"deletions":171,"binary":false,"changes":171,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n- * @summary tests DoPrivileged action (implemented as lambda expressions) by\n- * inserting them into the BootClassPath.\n+ * @library \/test\/lib\/\n@@ -31,1 +30,1 @@\n- * @compile -XDignore.symbol.file LambdaAccessControlDoPrivilegedTest.java LUtils.java\n+ * @compile LambdaAccessControlDoPrivilegedTest.java\n@@ -33,0 +32,2 @@\n+ * @summary tests DoPrivileged action (implemented as lambda expressions) by\n+ * inserting them into the BootClassPath.\n@@ -34,1 +35,6 @@\n-import java.io.File;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -37,0 +43,3 @@\n+import java.util.spi.ToolProvider;\n+\n+import static jdk.test.lib.process.ProcessTools.*;\n@@ -38,2 +47,2 @@\n-public class LambdaAccessControlDoPrivilegedTest extends LUtils {\n-    public static void main(String... args) {\n+public class LambdaAccessControlDoPrivilegedTest {\n+    public static void main(String... args) throws Exception {\n@@ -50,3 +59,3 @@\n-        File doprivJava = new File(\"DoPriv.java\");\n-        File doprivClass = getClassFile(doprivJava);\n-        createFile(doprivJava, scratch);\n+        Path doprivJava = Path.of(\"DoPriv.java\");\n+        Path doprivClass = Path.of(\"DoPriv.class\");\n+        Files.write(doprivJava, scratch, Charset.defaultCharset());\n@@ -62,3 +71,29 @@\n-        File barJava = new File(\"Bar.java\");\n-        File barClass = getClassFile(barJava);\n-        createFile(barJava, scratch);\n+        Path barJava = Path.of(\"Bar.java\");\n+        Path barClass = Path.of(\"Bar.class\");\n+        Files.write(barJava, scratch, Charset.defaultCharset());\n+\n+        compile(barJava.toString(), doprivJava.toString());\n+\n+        jar(\"cvf\", \"foo.jar\", doprivClass.toString());\n+        Files.delete(doprivJava);\n+        Files.delete(doprivClass);\n+\n+        ProcessBuilder pb = createTestJavaProcessBuilder(\n+                                \"-Xbootclasspath\/a:foo.jar\",\n+                                \"-cp\", \".\",\n+                                \"-Djava.security.manager=allow\",\n+                                \"Bar\");\n+        executeProcess(pb).shouldHaveExitValue(0);\n+\n+        Files.delete(barJava);\n+        Files.delete(barClass);\n+        Files.delete(Path.of(\"foo.jar\"));\n+    }\n+\n+    static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\").orElseThrow();\n+    static final ToolProvider JAVAC = ToolProvider.findFirst(\"javac\").orElseThrow();\n+    static void compile(String... args) throws IOException {\n+        if (JAVAC.run(System.out, System.err, args) != 0) {\n+            throw new RuntimeException(\"compilation fails\");\n+        }\n+    }\n@@ -66,9 +101,4 @@\n-        String[] javacArgs = {barJava.getName(), doprivJava.getName()};\n-        compile(javacArgs);\n-        File jarFile = new File(\"foo.jar\");\n-        String[] jargs = {\"cvf\", jarFile.getName(), doprivClass.getName()};\n-        TestResult tr = doExec(JAR_CMD.getAbsolutePath(),\n-                                \"cvf\", jarFile.getName(),\n-                                doprivClass.getName());\n-        if (tr.exitValue != 0){\n-            throw new RuntimeException(tr.toString());\n+    static void jar(String... args) {\n+        int rc = JAR_TOOL.run(System.out, System.err, args);\n+        if (rc != 0){\n+            throw new RuntimeException(\"fail to create JAR file\");\n@@ -76,11 +106,0 @@\n-        doprivJava.delete();\n-        doprivClass.delete();\n-        tr = doExec(JAVA_CMD.getAbsolutePath(),\n-                    \"-Xbootclasspath\/a:foo.jar\",\n-                    \"-cp\", \".\",\n-                    \"-Djava.security.manager=allow\",\n-                    \"Bar\");\n-        tr.assertZero(\"testDoPrivileged fails\");\n-        barJava.delete();\n-        barClass.delete();\n-        jarFile.delete();\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LambdaAccessControlDoPrivilegedTest.java","additions":52,"deletions":33,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @summary tests Lambda expression with a security manager at top level\n@@ -29,2 +28,0 @@\n- * @compile -XDignore.symbol.file LambdaAccessControlTest.java LUtils.java\n- *\n@@ -32,0 +29,1 @@\n+ * @summary tests Lambda expression with a security manager at top level\n@@ -34,1 +32,1 @@\n-public class LambdaAccessControlTest extends LUtils {\n+public class LambdaAccessControlTest {\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LambdaAccessControlTest.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,2 +27,1 @@\n- * @summary ensures that j.l.i.InvokerByteCodeGenerator and ASM visitMethodInsn\n- * generate  bytecodes with correct constant pool references\n+ * @library \/test\/lib\/\n@@ -32,1 +31,1 @@\n- * @compile -XDignore.symbol.file LambdaAsm.java LUtils.java\n+ * @compile LambdaAsm.java\n@@ -34,0 +33,2 @@\n+ * @summary ensures that j.l.i.InvokerByteCodeGenerator and ASM visitMethodInsn\n+ * generate  bytecodes with correct constant pool references\n@@ -43,1 +44,3 @@\n-import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n@@ -49,0 +52,2 @@\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -52,0 +57,1 @@\n+import static jdk.test.lib.process.ProcessTools.*;\n@@ -55,0 +61,2 @@\n+    static final Path SRC = Path.of(\"src\");\n+    static final Path CLASSES = Path.of(\"classes\");\n@@ -56,3 +64,1 @@\n-    static final File TestFile = new File(\"A.java\");\n-\n-    static void init() {\n+    static void init() throws Exception {\n@@ -60,2 +66,2 @@\n-        LUtils.compile(TestFile.getName());\n-        LUtils.TestResult tr = LUtils.doExec(LUtils.JAVA_CMD.getAbsolutePath(),\n+        CompilerUtils.compile(SRC, CLASSES);\n+        OutputAnalyzer outputAnalyzer = executeProcess(createTestJavaProcessBuilder(\n@@ -63,5 +69,2 @@\n-                \"-cp\", \".\", \"A\");\n-        if (tr.exitValue != 0) {\n-            System.out.println(\"Error: \" + tr.toString());\n-            throw new RuntimeException(\"could not create proxy classes\");\n-        }\n+                \"-cp\", CLASSES.toString(), \"A\"));\n+        outputAnalyzer.shouldHaveExitValue(0);\n@@ -70,1 +73,1 @@\n-    static void emitCode() {\n+    static void emitCode() throws IOException {\n@@ -92,1 +95,4 @@\n-        LUtils.createFile(TestFile, scratch);\n+\n+        Path testFile = SRC.resolve(\"A.java\");\n+        Files.createDirectories(SRC);\n+        Files.write(testFile, scratch, Charset.defaultCharset());\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LambdaAsm.java","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Synthetic frames should be hidden in exceptions\n+ * @library \/test\/lib\/\n@@ -30,1 +30,1 @@\n- * @compile -XDignore.symbol.file LUtils.java LambdaStackTrace.java\n+ * @compile LambdaStackTrace.java\n@@ -32,0 +32,1 @@\n+ * @summary Synthetic frames should be hidden in exceptions\n@@ -35,0 +36,1 @@\n+import jdk.test.lib.compiler.CompilerUtils;\n@@ -36,2 +38,0 @@\n-import java.io.File;\n-import java.io.FileOutputStream;\n@@ -41,0 +41,3 @@\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -50,1 +53,1 @@\n-    static File classes = new File(System.getProperty(\"test.classes\"));\n+    static Path CLASSES = Path.of(System.getProperty(\"test.classes\", \".\"));\n@@ -124,6 +127,2 @@\n-        try (FileOutputStream fw = new FileOutputStream(new File(classes, \"Maker.class\"))) {\n-            fw.write(generateMaker());\n-        }\n-        try (FileOutputStream fw = new FileOutputStream(new File(classes, \"StringMaker.class\"))) {\n-            fw.write(generateStringMaker());\n-        }\n+        Files.write(CLASSES.resolve(\"Maker.class\"), generateMaker());\n+        Files.write(CLASSES.resolve(\"StringMaker.class\"), generateStringMaker());\n@@ -157,1 +156,1 @@\n-    static void emitCode(File f) {\n+    static void emitCode(Path file) throws IOException {\n@@ -169,1 +168,2 @@\n-        LUtils.createFile(f, scratch);\n+\n+        Files.write(file, scratch, Charset.defaultCharset());\n@@ -172,2 +172,5 @@\n-    static void compileCaller() {\n-        File caller = new File(classes, \"Caller.java\");\n+    static void compileCaller() throws IOException {\n+        Path src = Path.of(\"src\");\n+        Files.createDirectories(src);\n+\n+        Path caller = src.resolve(\"Caller.java\");\n@@ -175,1 +178,1 @@\n-        LUtils.compile(\"-cp\", classes.getAbsolutePath(), \"-d\", classes.getAbsolutePath(), caller.getAbsolutePath());\n+        CompilerUtils.compile(src, CLASSES, \"-cp\", CLASSES.toAbsolutePath().toString());\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LambdaStackTrace.java","additions":19,"deletions":16,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n- * @summary tests logging generated classes for lambda\n+ * @requires vm.flagless\n+ * @library \/test\/lib\/\n@@ -32,0 +33,1 @@\n+ * @summary tests logging generated classes for lambda\n@@ -33,1 +35,0 @@\n-import java.io.File;\n@@ -35,0 +36,1 @@\n+import java.nio.charset.Charset;\n@@ -43,0 +45,2 @@\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -46,1 +50,0 @@\n-import org.testng.SkipException;\n@@ -49,0 +52,1 @@\n+import static jdk.test.lib.process.ProcessTools.*;\n@@ -53,1 +57,1 @@\n-public class LogGeneratedClassesTest extends LUtils {\n+public class LogGeneratedClassesTest {\n@@ -55,0 +59,1 @@\n+    static final Path CLASSES = Path.of(\"classes\").toAbsolutePath();\n@@ -77,3 +82,2 @@\n-        File test = new File(\"TestLambda.java\");\n-        createFile(test, scratch);\n-        compile(\"-d\", \".\", test.getName());\n+        Path testLambda = Path.of(\"TestLambda.java\");\n+        Files.write(testLambda, scratch, Charset.defaultCharset());\n@@ -94,3 +98,4 @@\n-        test = new File(\"LongPackageName.java\");\n-        createFile(test, scratch);\n-        compile(\"-d\", \".\", test.getName());\n+        Path lpnTest = Path.of(\"LongPackageName.java\");\n+        Files.write(lpnTest, scratch, Charset.defaultCharset());\n+\n+        CompilerUtils.compile(Path.of(\".\"), CLASSES);\n@@ -110,3 +115,3 @@\n-    public void testNotLogging() {\n-        TestResult tr = doExec(JAVA_CMD.getAbsolutePath(),\n-                               \"-cp\", \".\",\n+    public void testNotLogging() throws Exception {\n+        ProcessBuilder pb = createLimitedTestJavaProcessBuilder(\n+                               \"-cp\", CLASSES.toString(),\n@@ -115,1 +120,1 @@\n-        tr.assertZero(\"Should still return 0\");\n+        executeProcess(pb).shouldHaveExitValue(0);\n@@ -119,1 +124,1 @@\n-    public void testLogging() throws IOException {\n+    public void testLogging() throws Exception {\n@@ -123,3 +128,2 @@\n-        TestResult tr = doExec(JAVA_CMD.getAbsolutePath(),\n-                               \"-cp\", \"..\",\n-                               \"-Duser.dir=\" + testDir.toAbsolutePath(),\n+        ProcessBuilder pb = createLimitedTestJavaProcessBuilder(\n+                               \"-cp\", CLASSES.toString(),\n@@ -128,1 +132,3 @@\n-                               \"com.example.TestLambda\");\n+                               \"com.example.TestLambda\").directory(testDir.toFile());\n+        executeProcess(pb).shouldHaveExitValue(0);\n+\n@@ -135,2 +141,1 @@\n-                      2, \"Two lambda captured\");\n-        tr.assertZero(\"Should still return 0\");\n+                        2, \"Two lambda captured\");\n@@ -140,1 +145,1 @@\n-    public void testDumpDirNotExist() throws IOException {\n+    public void testDumpDirNotExist() throws Exception {\n@@ -145,1 +150,0 @@\n-\n@@ -147,6 +151,7 @@\n-        TestResult tr = doExec(JAVA_CMD.getAbsolutePath(),\n-                               \"-cp\", \"..\",\n-                               \"-Duser.dir=\" + testDir.toAbsolutePath(),\n-                               \"-Djava.security.manager=allow\",\n-                               \"-Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles\",\n-                               \"com.example.TestLambda\");\n+\n+        ProcessBuilder pb = createLimitedTestJavaProcessBuilder(\n+                                \"-cp\", CLASSES.toString(),\n+                                \"-Djava.security.manager=allow\",\n+                                \"-Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles\",\n+                                \"com.example.TestLambda\").directory(testDir.toFile());\n+        executeProcess(pb).shouldHaveExitValue(0);\n@@ -160,2 +165,1 @@\n-                    2, \"Two lambda captured\");\n-        tr.assertZero(\"Should still return 0\");\n+                        2, \"Two lambda captured\");\n@@ -165,1 +169,1 @@\n-    public void testDumpDirIsFile() throws IOException {\n+    public void testDumpDirIsFile() throws Exception {\n@@ -171,11 +175,8 @@\n-        TestResult tr = doExec(JAVA_CMD.getAbsolutePath(),\n-                               \"-cp\", \"..\",\n-                               \"-Duser.dir=\" + testDir.toAbsolutePath(),\n-                               \"-Djava.security.manager=allow\",\n-                               \"-Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles\",\n-                               \"com.example.TestLambda\");\n-        assertEquals(tr.testOutput.stream()\n-                                  .filter(s -> s.contains(\"DUMP_LAMBDA_PROXY_CLASS_FILES is not a directory\"))\n-                                  .count(),\n-                     1, \"only show error once\");\n-        assertTrue(tr.exitValue != 0);\n+        ProcessBuilder pb = createLimitedTestJavaProcessBuilder(\n+                                \"-cp\", CLASSES.toString(),\n+                                \"-Djava.security.manager=allow\",\n+                                \"-Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles\",\n+                                \"com.example.TestLambda\").directory(testDir.toFile());\n+        executeProcess(pb)\n+                .shouldContain(\"DUMP_LAMBDA_PROXY_CLASS_FILES is not a directory\")\n+                .shouldNotHaveExitValue(0);\n@@ -208,1 +209,1 @@\n-    public void testDumpDirNotWritable() throws IOException {\n+    public void testDumpDirNotWritable() throws Exception {\n@@ -233,3 +234,2 @@\n-            TestResult tr = doExec(JAVA_CMD.getAbsolutePath(),\n-                                   \"-cp\", \"..\",\n-                                   \"-Duser.dir=\" + testDir.toAbsolutePath(),\n+            ProcessBuilder pb = createLimitedTestJavaProcessBuilder(\n+                                   \"-cp\", CLASSES.toString(),\n@@ -238,6 +238,4 @@\n-                                   \"com.example.TestLambda\");\n-            assertEquals(tr.testOutput.stream()\n-                                      .filter(s -> s.contains(\"DUMP_LAMBDA_PROXY_CLASS_FILES is not writable\"))\n-                                      .count(),\n-                         1, \"only show error once\");\n-            assertTrue(tr.exitValue != 0);\n+                                   \"com.example.TestLambda\").directory(testDir.toFile());\n+            executeProcess(pb)\n+                    .shouldContain(\"DUMP_LAMBDA_PROXY_CLASS_FILES is not writable\")\n+                    .shouldNotHaveExitValue(0);\n@@ -250,1 +248,1 @@\n-    public void testLoggingException() throws IOException {\n+    public void testLoggingException() throws Exception {\n@@ -255,3 +253,2 @@\n-        TestResult tr = doExec(JAVA_CMD.getAbsolutePath(),\n-                               \"-cp\", \"..\",\n-                               \"-Duser.dir=\" + testDir.toAbsolutePath(),\n+        ProcessBuilder pb = createLimitedTestJavaProcessBuilder(\n+                               \"-cp\", CLASSES.toString(),\n@@ -260,2 +257,4 @@\n-                               longFQCN);\n-        assertEquals(tr.testOutput.stream()\n+                               longFQCN).directory(testDir.toFile());\n+        OutputAnalyzer outputAnalyzer = executeProcess(pb);\n+        outputAnalyzer.shouldHaveExitValue(0);\n+        assertEquals(outputAnalyzer.asLines().stream()\n@@ -282,1 +281,0 @@\n-        tr.assertZero(\"Should still return 0\");\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LogGeneratedClassesTest.java","additions":58,"deletions":60,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,0 @@\n-import java.io.File;\n-import java.util.Map;\n@@ -37,5 +35,1 @@\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n+import jdk.test.lib.process.ProcessTools;\n@@ -44,21 +38,5 @@\n-    public static void main(String[] args) throws IOException {\n-        Path launcher = Paths.get(System.getProperty(\"test.nativepath\"), \"CallerAccessTest\");\n-        ProcessBuilder pb = new ProcessBuilder(launcher.toString());\n-        Map<String, String> env = pb.environment();\n-\n-        String libDir = Platform.libDir().toString();\n-        String vmDir = Platform.jvmLibDir().toString();\n-\n-        \/\/ set up shared library path\n-        String sharedLibraryPathEnvName = Platform.sharedLibraryPathVariableName();\n-        env.compute(sharedLibraryPathEnvName,\n-                    (k, v) -> (v == null) ? libDir : v + File.pathSeparator + libDir);\n-        env.compute(sharedLibraryPathEnvName,\n-                    (k, v) -> (v == null) ? vmDir : v + File.pathSeparator + vmDir);\n-\n-        System.out.println(\"Launching: \" + launcher + \" shared library path: \" +\n-                           env.get(sharedLibraryPathEnvName));\n-        new OutputAnalyzer(pb.start())\n-                .outputTo(System.out)\n-                .errorTo(System.err)\n-                .shouldHaveExitValue(0);\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createNativeTestProcessBuilder(\"CallerAccessTest\");\n+        System.out.println(\"Launching: \" + pb.command() + \" shared library path: \" +\n+                           pb.environment().get(Platform.sharedLibraryPathVariableName()));\n+        ProcessTools.executeProcess(pb).shouldHaveExitValue(0);\n","filename":"test\/jdk\/java\/lang\/reflect\/exeCallerAccessTest\/CallerAccessTest.java","additions":7,"deletions":29,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n-import java.util.List;\n@@ -48,1 +47,0 @@\n-import jdk.test.lib.JDKToolFinder;\n@@ -50,0 +48,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -54,2 +53,0 @@\n-    private static final String CLASS_PATH = System.getProperty(\n-            \"test.class.path\");\n@@ -138,1 +135,0 @@\n-        String java = JDKToolFinder.getTestJDKTool(\"java\");\n@@ -140,4 +136,3 @@\n-        List<String> cmd = List.of(java, \"-Djava.net.preferIPv4Stack=true\",\n-                \"-cp\", CLASS_PATH, testClz);\n-        System.out.println(\"Executing: \" + cmd);\n-        return new OutputAnalyzer(new ProcessBuilder(cmd).start()).getOutput();\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                \"-Djava.net.preferIPv4Stack=true\", testClz);\n+        return new OutputAnalyzer(pb.start()).getOutput();\n@@ -147,1 +142,0 @@\n-        String java = JDKToolFinder.getTestJDKTool(\"java\");\n@@ -149,4 +143,3 @@\n-        List<String> cmd = List.of(java, \"-Djava.net.preferIPv4Stack=true\",\n-                                   \"-cp\", CLASS_PATH, testClz, \"reverse\", addr);\n-        System.out.println(\"Executing: \" + cmd);\n-        return new OutputAnalyzer(new ProcessBuilder(cmd).start()).getOutput();\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                \"-Djava.net.preferIPv4Stack=true\", testClz, \"reverse\", addr);\n+        return new OutputAnalyzer(pb.start()).getOutput();\n","filename":"test\/jdk\/java\/net\/InetAddress\/ptr\/Lookup.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,2 @@\n- * @requires (os.family != \"windows\")\n+ * @requires os.family != \"windows\"\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/net\/ServerSocket\/AcceptCauseFileDescriptorLeak.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.util.Collections;\n@@ -41,0 +42,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -98,5 +100,1 @@\n-        commands.add(JAVA);\n-        for (String arg : jvmArgs)\n-            commands.add(arg);\n-        commands.add(\"-cp\");\n-        commands.add(CLASSPATH);\n+        Collections.addAll(commands, jvmArgs);\n@@ -107,1 +105,1 @@\n-        ProcessBuilder pb = new ProcessBuilder(commands);\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(commands);\n","filename":"test\/jdk\/java\/net\/ServerSocket\/AcceptInheritHandle.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import jdk.test.lib.JDKToolFinder;\n@@ -56,1 +55,0 @@\n-        String java = JDKToolFinder.getTestJDKTool(\"java\");\n@@ -60,2 +58,3 @@\n-                new ProcessBuilder(\n-                        java, TEST_NAME, \".\/\" + ARCHIVE_NAME\n+                ProcessTools.createTestJavaProcessBuilder(\n+                        TEST_NAME,\n+                        \".\/\" + ARCHIVE_NAME\n@@ -63,2 +62,2 @@\n-                new ProcessBuilder(\n-                        java, \"-cp\", \".\",\n+                ProcessTools.createTestJavaProcessBuilder(\n+                        \"-cp\", \".\",\n@@ -69,2 +68,2 @@\n-                new ProcessBuilder(\n-                        java, \"-cp\", \".\",\n+                ProcessTools.createTestJavaProcessBuilder(\n+                        \"-cp\", \".\",\n@@ -75,2 +74,2 @@\n-                new ProcessBuilder(\n-                        java, \"-cp\", \"..\",\n+                ProcessTools.createTestJavaProcessBuilder(\n+                        \"-cp\", \"..\",\n@@ -81,2 +80,2 @@\n-                new ProcessBuilder(\n-                        java, \"-cp\", basename,\n+                ProcessTools.createTestJavaProcessBuilder(\n+                        \"-cp\", basename,\n","filename":"test\/jdk\/java\/net\/URLClassLoader\/getresourceasstream\/TestDriver.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+import static jdk.test.lib.process.ProcessTools.createTestJavaProcessBuilder;\n+import static jdk.test.lib.process.ProcessTools.executeCommand;\n@@ -58,1 +60,0 @@\n-        String java = JDKToolFinder.getTestJDKTool(\"java\");\n@@ -65,0 +66,5 @@\n+\n+        \/\/ Compile\n+        ProcessTools.executeCommand(javac, \"-cp\", cp, \"-d\", \".\",\n+                srcDir + File.separator + TEST_NAME + \".java\");\n+\n@@ -66,5 +72,0 @@\n-                \/\/ Compile command\n-                new String[]{\n-                        javac, \"-cp\", cp, \"-d\", \".\",\n-                        srcDir + File.separator + TEST_NAME + \".java\"\n-                },\n@@ -73,1 +74,1 @@\n-                        java, \"-cp\", cp, TEST_NAME, \"1\"\n+                        \"-cp\", cp, TEST_NAME, \"1\"\n@@ -77,1 +78,1 @@\n-                        java, \"-cp\", cp, TEST_NAME, \"2\"\n+                        \"-cp\", cp, TEST_NAME, \"2\"\n@@ -82,1 +83,1 @@\n-            ProcessTools.executeCommand(cmd)\n+            executeCommand(createTestJavaProcessBuilder(cmd))\n","filename":"test\/jdk\/java\/net\/URLClassLoader\/sealing\/CheckSealedTest.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/net\/URLConnection\/6212146\/TestDriver.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,2 @@\n+import jdk.test.lib.process.ProcessTools;\n+\n@@ -59,0 +61,1 @@\n+ * @library \/test\/lib\n@@ -271,5 +274,1 @@\n-        String java = getJDKTool(\"java\");\n-\n-        List<String> commands = new ArrayList<>();\n-        commands.add(java);\n-        commands.addAll(properties.entrySet()\n+        List<String> commands = properties.entrySet()\n@@ -278,1 +277,1 @@\n-                .collect(Collectors.toList()));\n+                .collect(Collectors.toList());\n@@ -288,1 +287,1 @@\n-        return run(new ProcessBuilder(commands));\n+        return run(ProcessTools.createTestJavaProcessBuilder(commands));\n","filename":"test\/jdk\/java\/net\/URLConnection\/ContentHandlers\/ContentHandlersTest.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -56,0 +55,1 @@\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -78,0 +78,1 @@\n+ *        jdk.httpclient.test.lib.common.TestServerConfigurator\n@@ -330,1 +331,1 @@\n-        httpsTestServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        httpsTestServer.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), sslContext));\n","filename":"test\/jdk\/java\/net\/httpclient\/AsFileDownloadTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -54,1 +55,1 @@\n- *        DigestEchoServer\n+ *        DigestEchoServer jdk.httpclient.test.lib.common.TestServerConfigurator\n@@ -136,1 +137,1 @@\n-            sserver1.setHttpsConfigurator(new HttpsConfigurator(context));\n+            sserver1.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), context));\n","filename":"test\/jdk\/java\/net\/httpclient\/AuthFilterCacheTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ *        jdk.httpclient.test.lib.common.TestServerConfigurator\n@@ -58,1 +59,0 @@\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -67,0 +67,2 @@\n+\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -294,1 +296,1 @@\n-        httpsTestServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        httpsTestServer.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), sslContext));\n","filename":"test\/jdk\/java\/net\/httpclient\/ConcurrentResponses.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *        jdk.httpclient.test.lib.common.TestServerConfigurator\n@@ -46,1 +47,0 @@\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -55,0 +55,2 @@\n+\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -203,1 +205,1 @@\n-        httpsTestServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        httpsTestServer.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), sslContext));\n","filename":"test\/jdk\/java\/net\/httpclient\/CustomResponseSubscriber.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,3 @@\n- * @modules java.net.http\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext jdk.httpclient.test.lib.common.TestServerConfigurator\n+ * @modules java.net.http\/jdk.internal.net.http.common\n@@ -29,2 +31,0 @@\n- * @library \/test\/lib\n- * @build jdk.test.lib.net.SimpleSSLContext\n@@ -37,1 +37,0 @@\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -52,0 +51,2 @@\n+\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -151,1 +152,1 @@\n-        httpsTestServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        httpsTestServer.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), sslContext));\n","filename":"test\/jdk\/java\/net\/httpclient\/ExpectContinue.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8306040\n+ * @summary HttpResponseInputStream.available() returns 1 on empty stream\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @run junit\/othervm HttpInputStreamAvailableTest\n+ *\n+ *\/\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import jdk.test.lib.net.URIBuilder;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class HttpInputStreamAvailableTest {\n+\n+    private HttpServer server;\n+    private int port;\n+    static final String TEST_MESSAGE = \"This is test message\";\n+    static final int ZERO = 0;\n+\n+    @BeforeAll\n+    void setup() throws Exception {\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        InetSocketAddress addr = new InetSocketAddress(loopback, 0);\n+        server = HttpServer.create(addr, 0);\n+        port = server.getAddress().getPort();\n+        FirstHandler fHandler = new FirstHandler();\n+        server.createContext(\"\/NonZeroResponse\/\", fHandler);\n+        SecondHandler sHandler = new SecondHandler();\n+        server.createContext(\"\/ZeroResponse\/\", sHandler);\n+        server.start();\n+    }\n+\n+    @AfterAll\n+    void teardown() throws Exception {\n+        server.stop(0);\n+    }\n+\n+    @Test\n+    public void test() throws Exception {\n+        HttpClient client = HttpClient\n+                .newBuilder()\n+                .proxy(HttpClient.Builder.NO_PROXY)\n+                .build();\n+\n+        URI uri = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .loopback()\n+                .port(port)\n+                .path(\"\/NonZeroResponse\/\")\n+                .build();\n+\n+        HttpRequest request = HttpRequest\n+                .newBuilder(uri)\n+                .GET()\n+                .build();\n+\n+        \/\/ Send a httpRequest and assert the bytes available\n+        HttpResponse<InputStream> response = client.send(request,\n+                HttpResponse.BodyHandlers.ofInputStream());\n+        try ( InputStream in = response.body()) {\n+            in.readNBytes(2);\n+            \/\/ this is not guaranteed, but a failure here would be surprising\n+            assertEquals(TEST_MESSAGE.length() - 2, in.available());\n+            \/\/read the remaining data\n+            in.readAllBytes();\n+            \/\/available should return 0\n+            assertEquals(ZERO, in.available());\n+        }\n+    }\n+\n+    @Test\n+    public void test1() throws Exception {\n+        HttpClient client = HttpClient\n+                .newBuilder()\n+                .proxy(HttpClient.Builder.NO_PROXY)\n+                .build();\n+\n+        URI uri = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .loopback()\n+                .port(port)\n+                .path(\"\/ZeroResponse\/\")\n+                .build();\n+\n+        HttpRequest request = HttpRequest\n+                .newBuilder(uri)\n+                .GET()\n+                .build();\n+\n+        \/\/ Send a httpRequest and assert the bytes available\n+        HttpResponse<InputStream> response = client.send(request,\n+                HttpResponse.BodyHandlers.ofInputStream());\n+        try ( InputStream in = response.body()) {\n+            assertEquals(ZERO, in.available());\n+            in.readAllBytes();\n+            assertEquals(ZERO, in.available());\n+        }\n+    }\n+\n+    static class FirstHandler implements HttpHandler {\n+\n+        @Override\n+        public void handle(HttpExchange exchange) throws IOException {\n+            try ( OutputStream os = exchange.getResponseBody()) {\n+                byte[] workingResponse = TEST_MESSAGE.getBytes();\n+                exchange.sendResponseHeaders(200, workingResponse.length);\n+                os.write(workingResponse);\n+                os.flush();\n+            }\n+        }\n+    }\n+\n+    static class SecondHandler implements HttpHandler {\n+\n+        @Override\n+        public void handle(HttpExchange exchange) throws IOException {\n+            exchange.sendResponseHeaders(204, -1);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpInputStreamAvailableTest.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -23,2 +23,0 @@\n-import com.sun.net.httpserver.HttpServer;\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -26,0 +24,1 @@\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -63,1 +62,0 @@\n-import jdk.httpclient.test.lib.http2.Http2TestServer;\n@@ -72,0 +70,1 @@\n+ *        jdk.httpclient.test.lib.common.TestServerConfigurator\n@@ -178,1 +177,1 @@\n-            sserver1.setHttpsConfigurator(new HttpsConfigurator(context));\n+            sserver1.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), context));\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRedirectTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -23,2 +23,0 @@\n-import com.sun.net.httpserver.HttpServer;\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -26,0 +24,1 @@\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -54,1 +53,0 @@\n-import jdk.httpclient.test.lib.http2.Http2TestServer;\n@@ -65,0 +63,1 @@\n+ *        jdk.httpclient.test.lib.common.TestServerConfigurator\n@@ -141,1 +140,1 @@\n-            sserver1.setHttpsConfigurator(new HttpsConfigurator(context));\n+            sserver1.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), context));\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpSlowServerTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ *        jdk.httpclient.test.lib.common.TestServerConfigurator\n@@ -46,1 +47,0 @@\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -56,0 +56,2 @@\n+\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -192,1 +194,1 @@\n-        httpsTestServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        httpsTestServer.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), sslContext));\n","filename":"test\/jdk\/java\/net\/httpclient\/ImmutableFlowItems.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -23,2 +23,0 @@\n-import com.sun.net.httpserver.HttpServer;\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -64,1 +62,1 @@\n-import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -85,0 +83,1 @@\n+ *        jdk.httpclient.test.lib.common.TestServerConfigurator\n@@ -1014,1 +1013,1 @@\n-            sserver1.setHttpsConfigurator(new HttpsConfigurator(context));\n+            sserver1.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), context));\n","filename":"test\/jdk\/java\/net\/httpclient\/LargeHandshakeTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -23,2 +23,0 @@\n-import com.sun.net.httpserver.HttpServer;\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -26,0 +24,1 @@\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -41,1 +40,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -54,1 +52,0 @@\n-import jdk.httpclient.test.lib.http2.Http2TestServer;\n@@ -67,0 +64,1 @@\n+ *        jdk.httpclient.test.lib.common.TestServerConfigurator\n@@ -139,1 +137,1 @@\n-            sserver1.setHttpsConfigurator(new HttpsConfigurator(context));\n+            sserver1.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), context));\n","filename":"test\/jdk\/java\/net\/httpclient\/LargeResponseTest.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -53,0 +52,2 @@\n+\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -114,1 +115,1 @@\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(ctx));\n+        httpsServer.setHttpsConfigurator(new TestServerConfigurator(addr.getAddress(), ctx));\n","filename":"test\/jdk\/java\/net\/httpclient\/LightWeightHttpServer.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *        jdk.httpclient.test.lib.common.TestServerConfigurator\n@@ -49,1 +50,0 @@\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -62,0 +62,1 @@\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -233,1 +234,1 @@\n-        httpsTestServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        httpsTestServer.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), sslContext));\n","filename":"test\/jdk\/java\/net\/httpclient\/MappingResponseSubscriber.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run testng\/othervm -ea -esa MaxStreams\n+ * @run testng\/othervm MaxStreams\n@@ -48,1 +48,0 @@\n-import java.util.concurrent.Semaphore;\n@@ -77,1 +76,0 @@\n-    volatile CountDownLatch latch;\n@@ -79,1 +77,0 @@\n-    final Semaphore canStartTestRun = new Semaphore(1);\n@@ -101,1 +98,1 @@\n-    @Test(dataProvider = \"uris\", timeOut=20000)\n+    @Test(dataProvider = \"uris\")\n@@ -103,3 +100,1 @@\n-        System.err.println(\"Semaphore acquire\");\n-        canStartTestRun.acquire();\n-        latch = new CountDownLatch(1);\n+        CountDownLatch latch = new CountDownLatch(1);\n@@ -212,1 +207,0 @@\n-            int c = -1;\n@@ -217,1 +211,1 @@\n-                c = counter.getAndIncrement();\n+                int c = counter.getAndIncrement();\n@@ -226,0 +220,6 @@\n+                } else if (c == MAX_STREAMS + 1) {\n+                    \/\/ client issues MAX_STREAMS + 3 requests in total\n+                    \/\/ but server should only see MAX_STREAMS + 2 in total. One is rejected by client\n+                    \/\/ counter c captured before increment so final value is MAX_STREAMS + 1\n+                    System.err.println(\"Counter reset\");\n+                    counter.set(0);\n@@ -229,9 +229,0 @@\n-            } finally {\n-                \/\/ client issues MAX_STREAMS + 3 requests in total\n-                \/\/ but server should only see MAX_STREAMS + 2 in total. One is rejected by client\n-                \/\/ counter c captured before increment so final value is MAX_STREAMS + 1\n-                if (c == MAX_STREAMS + 1) {\n-                    System.err.println(\"Semaphore release\");\n-                    counter.set(0);\n-                    canStartTestRun.release();\n-                }\n","filename":"test\/jdk\/java\/net\/httpclient\/MaxStreams.java","additions":10,"deletions":19,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n- * @modules java.net.http\n+ * @modules java.net.http\/jdk.internal.net.http.common\n@@ -65,1 +65,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n@@ -69,1 +69,1 @@\n- * @build jdk.test.lib.net.SimpleSSLContext\n+ * @build jdk.test.lib.net.SimpleSSLContext jdk.httpclient.test.lib.common.TestServerConfigurator\n","filename":"test\/jdk\/java\/net\/httpclient\/RequestBodyTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,5 @@\n+\/\/ for jdk\/httpclient\/test\/lib\/* classes\n+grant codeBase \"file:${test.classes}\/..\/..\/..\/..\/test\/jdk\/java\/net\/httpclient\/lib\/-\" {\n+    permission java.lang.RuntimePermission \"accessClassInPackage.jdk.internal.net.http.common\";\n+};\n+\n@@ -55,0 +60,2 @@\n+\n+    permission java.lang.RuntimePermission \"accessClassInPackage.jdk.internal.net.http.common\";\n","filename":"test\/jdk\/java\/net\/httpclient\/RequestBodyTest.policy","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.net.http.common.OperationTrackers;\n@@ -103,0 +104,10 @@\n+    static final long start = System.nanoTime();\n+\n+    public static String now() {\n+        long now = System.nanoTime() - start;\n+        long secs = now \/ 1000_000_000;\n+        long mill = (now % 1000_000_000) \/ 1000_000;\n+        long nan = now % 1000_000;\n+        return String.format(\"[%d s, %d ms, %d ns] \", secs, mill, nan);\n+    }\n+\n@@ -219,0 +230,6 @@\n+            \/\/ ensure client closes before next iteration\n+            if (!sameClient) {\n+                var tracker = TRACKER.getTracker(client);\n+                client = null;\n+                clientCleanup(tracker);\n+            }\n@@ -242,0 +259,6 @@\n+            \/\/ ensure client closes before next iteration\n+            if (!sameClient) {\n+                var tracker = TRACKER.getTracker(client);\n+                client = null;\n+                clientCleanup(tracker);\n+            }\n@@ -268,0 +291,6 @@\n+            \/\/ ensure client closes before next iteration\n+            if (!sameClient) {\n+                var tracker = TRACKER.getTracker(client);\n+                client = null;\n+                clientCleanup(tracker);\n+            }\n@@ -291,0 +320,6 @@\n+            \/\/ ensure client closes before next iteration\n+            if (!sameClient) {\n+                var tracker = TRACKER.getTracker(client);\n+                client = null;\n+                clientCleanup(tracker);\n+            }\n@@ -317,0 +352,6 @@\n+            \/\/ ensure client closes before next iteration\n+            if (!sameClient) {\n+                var tracker = TRACKER.getTracker(client);\n+                client = null;\n+                clientCleanup(tracker);\n+            }\n@@ -454,0 +495,17 @@\n+    \/\/ Wait for the client to be garbage collected.\n+    \/\/ we use the ReferenceTracker API rather than HttpClient::close here,\n+    \/\/ because we want to get some diagnosis if a client doesn't release\n+    \/\/ its resources and terminates as expected\n+    \/\/ By using the ReferenceTracker, we will get some diagnosis about what\n+    \/\/ is keeping the client alive if it doesn't get GC'ed within the\n+    \/\/ expected time frame.\n+    public void clientCleanup(OperationTrackers.Tracker tracker){\n+        System.gc();\n+        System.out.println(now() + \"waiting for client to shutdown: \" + tracker.getName());\n+        System.err.println(now() + \"waiting for client to shutdown: \" + tracker.getName());\n+        var error = TRACKER.check(tracker, 10000);\n+        if (error != null) throw error;\n+        System.out.println(now() + \"client shutdown normally: \" + tracker.getName());\n+        System.err.println(now() + \"client shutdown normally: \" + tracker.getName());\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/ResponsePublisher.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -801,2 +800,2 @@\n-                    InetSocketAddress sa = new InetSocketAddress(\n-                            InetAddress.getLoopbackAddress(), 0);\n+                    InetAddress loopback = InetAddress.getLoopbackAddress();\n+                    InetSocketAddress sa = new InetSocketAddress(loopback, 0);\n@@ -808,1 +807,1 @@\n-                        https.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+                        https.setHttpsConfigurator(new TestServerConfigurator(loopback, sslContext));\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/common\/HttpServerAdapters.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.httpclient.test.lib.common;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import javax.net.ssl.SNIHostName;\n+import javax.net.ssl.SNIMatcher;\n+import javax.net.ssl.SNIServerName;\n+import javax.net.ssl.StandardConstants;\n+\n+import jdk.internal.net.http.common.Logger;\n+import jdk.internal.net.http.common.Utils;\n+\n+\/**\n+ * A (server side) SNI host name matcher. Implementation is based on the expectations set in\n+ * section 3 of RFC-6066.\n+ * A server can be configured with an instance of this class.\n+ * <p>\n+ * The RFC states:\n+ * {@code\n+ * Currently, the only server names supported are DNS hostnames; however, this does not imply\n+ * any dependency of TLS on DNS,\n+ * ....\n+ * TLS MAY treat provided server names as opaque data and pass the names and types to the application.\n+ * }\n+ * <p>\n+ * The implementation in this class doesn't mandate the configured\/recognized SNI host name as DNS\n+ * resolvable. However, the {@code ServerNameMatcher} can be configured to treat the SNI host name\n+ * as DNS resolvable by passing {@code true} to the {@code attemptDNSResolution} parameter of\n+ * the {@link #ServerNameMatcher(boolean, String) constructor}\n+ *\/\n+public class ServerNameMatcher extends SNIMatcher {\n+\n+    private final Logger debug;\n+    private final boolean attemptDNSResolution;\n+    private final Set<String> recognizedSNINames;\n+\n+    \/**\n+     * Creates a ServerNameMatcher which recognizes the passed {@code recognizedSNIName}\n+     *\n+     * @param recognizedSNIName The SNI host name\n+     *\/\n+    public ServerNameMatcher(final String recognizedSNIName) {\n+        this(false, recognizedSNIName);\n+    }\n+\n+    \/**\n+     * Creates a ServerNameMatcher which recognizes the passed SNI host name\n+     * If {@code attemptDNSResolution} is {@code true}, then when\n+     * {@link #matches(SNIServerName) matching} a client requested SNI name against the server\n+     * recognized SNI name, the implementation will, as a last resort do a DNS resolution of the\n+     * client requested SNI name and the server recognized SNI name and compare them to\n+     * try and find a match. If {@code attemptDNSResolution} is false, then no DNS resolution is\n+     * attempted and instead the SNI names are literally compared.\n+     *\n+     * @param attemptDNSResolution If true then a DNS resolution will be attempted during\n+     *                             {@link #matches(SNIServerName) SNI matching}\n+     * @param recognizedSNIName    SNI host name\n+     *\/\n+    public ServerNameMatcher(final boolean attemptDNSResolution,\n+                             final String recognizedSNIName) {\n+        super(StandardConstants.SNI_HOST_NAME);\n+        Objects.requireNonNull(recognizedSNIName);\n+        this.debug = Utils.getDebugLogger(() -> \"SNIMatcher\");\n+        this.recognizedSNINames = Set.of(recognizedSNIName);\n+        this.attemptDNSResolution = attemptDNSResolution;\n+    }\n+\n+    \/**\n+     * @param clientRequestedSNI the SNI name requested by the client\n+     *                           {@return true if the {@code clientRequestedSNI} is recognized by\n+     *                           the server. false otherwise}\n+     *\/\n+    @Override\n+    public boolean matches(final SNIServerName clientRequestedSNI) {\n+        Objects.requireNonNull(clientRequestedSNI);\n+        if (!SNIHostName.class.isInstance(clientRequestedSNI)) {\n+            if (debug.on()) {\n+                debug.log(\"SNI match (against \" + recognizedSNINames + \")\" +\n+                        \" failed - not a SNIHostName: \" + clientRequestedSNI);\n+            }\n+            \/\/ we only support SNIHostName type\n+            return false;\n+        }\n+        final String requestedName = ((SNIHostName) clientRequestedSNI).getAsciiName();\n+        if (recognizedSNINames.contains(requestedName)) {\n+            if (debug.on()) {\n+                debug.log(\"SNI match (against \" + recognizedSNINames + \") passed: \"\n+                        + clientRequestedSNI);\n+            }\n+            return true;\n+        }\n+        if (attemptDNSResolution) {\n+            final boolean res = matchesAfterDNSResolution(requestedName);\n+            if (debug.on()) {\n+                debug.log(\"SNI match (against \" + recognizedSNINames + \") \"\n+                        + (res ? \"passed\" : \"failed\") + \": \" + clientRequestedSNI);\n+            }\n+            return res;\n+        }\n+        if (debug.on()) {\n+            debug.log(\"SNI match (against \" + recognizedSNINames + \") failed: \" + clientRequestedSNI);\n+        }\n+        return false;\n+    }\n+\n+    private boolean matchesAfterDNSResolution(final String clientRequestedSNI) {\n+        final InetAddress clientRequestedAddr;\n+        try {\n+            clientRequestedAddr = InetAddress.getByName(clientRequestedSNI);\n+        } catch (IOException e) {\n+            return false;\n+        }\n+        for (final String recognizedSNIName : recognizedSNINames) {\n+            final InetAddress serverRecognizedAddr;\n+            try {\n+                serverRecognizedAddr = InetAddress.getByName(recognizedSNIName);\n+            } catch (IOException e) {\n+                \/\/ try next\n+                continue;\n+            }\n+            if (serverRecognizedAddr.equals(clientRequestedAddr)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/common\/ServerNameMatcher.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.httpclient.test.lib.common;\n+\n+import java.net.InetAddress;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.List;\n+\n+import javax.net.ssl.SNIMatcher;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsParameters;\n+\n+\/**\n+ * A {@link HttpsConfigurator} that can be used with the HTTP1 test server over HTTPS.\n+ * This configurator {@link #configure(HttpsParameters) configures} the server's\n+ * {@link HttpsParameters} with the necessary {@link SSLParameters} including a\n+ * {@link SNIMatcher}\n+ *\/\n+public final class TestServerConfigurator extends HttpsConfigurator {\n+\n+    private final InetAddress serverAddr;\n+\n+    \/**\n+     * Creates a Https configuration, with the given {@link SSLContext}.\n+     *\n+     * @param serverAddr the address to which the server is bound\n+     * @param context    the {@code SSLContext} to use for this configurator\n+     * @throws NullPointerException if no {@code SSLContext} supplied\n+     *\/\n+    public TestServerConfigurator(final InetAddress serverAddr, final SSLContext context) {\n+        super(context);\n+        this.serverAddr = serverAddr;\n+    }\n+\n+    @Override\n+    public void configure(final HttpsParameters params) {\n+        final SSLParameters sslParams = getSSLContext().getDefaultSSLParameters();\n+        @SuppressWarnings(\"removal\") final SecurityManager sm = System.getSecurityManager();\n+        final String hostname;\n+        if (sm == null) {\n+            hostname = serverAddr.getHostName();\n+        } else {\n+            final PrivilegedAction<String> action = () -> serverAddr.getHostName();\n+            hostname = AccessController.doPrivileged(action);\n+        }\n+        final List<SNIMatcher> sniMatchers = List.of(new ServerNameMatcher(hostname));\n+        sslParams.setSNIMatchers(sniMatchers);\n+        \/\/ configure the server with these custom SSLParameters\n+        params.setSSLParameters(sslParams);\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/common\/TestServerConfigurator.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -129,1 +130,0 @@\n-        String javaCmd = testJdk + sep + \"bin\" + sep + \"java\";\n@@ -134,1 +134,0 @@\n-            cmd.add(javaCmd);\n@@ -153,1 +152,1 @@\n-            ProcessBuilder processBuilder = new ProcessBuilder(cmd)\n+            ProcessBuilder processBuilder = ProcessTools.createTestJavaProcessBuilder(cmd)\n","filename":"test\/jdk\/java\/net\/httpclient\/security\/Driver.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,3 +28,3 @@\n- * @library \/test\/lib\n- * @build jdk.test.lib.net.SimpleSSLContext\n- * @modules java.net.http\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext jdk.httpclient.test.lib.common.TestServerConfigurator\n+ * @modules java.net.http\/jdk.internal.net.http.common\n@@ -37,1 +37,0 @@\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -40,0 +39,1 @@\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -157,1 +157,1 @@\n-        httpsTestServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        httpsTestServer.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), sslContext));\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/HandshakeUrlEncodingTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,3 +28,3 @@\n- * @library \/test\/lib\n- * @build jdk.test.lib.net.SimpleSSLContext\n- * @modules java.net.http\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext jdk.httpclient.test.lib.common.TestServerConfigurator\n+ * @modules java.net.http\/jdk.internal.net.http.common\n@@ -37,1 +37,0 @@\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -50,0 +49,2 @@\n+\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -175,1 +176,1 @@\n-        httpsTestServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        httpsTestServer.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), sslContext));\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/WSHandshakeExceptionTest.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,2 @@\n+\n+import jdk.test.lib.process.ProcessTools;\n@@ -237,1 +239,0 @@\n-        String java = getJDKTool(\"java\");\n@@ -239,4 +240,1 @@\n-        List<String> commands = new ArrayList<>();\n-        commands.add(java);\n-        for (String prop : sysProps)\n-            commands.add(prop);\n+        List<String> commands = new ArrayList<>(sysProps);\n@@ -252,1 +250,1 @@\n-        return run(new ProcessBuilder(commands));\n+        return run(ProcessTools.createTestJavaProcessBuilder(commands));\n","filename":"test\/jdk\/java\/net\/spi\/URLStreamHandlerProvider\/Basic.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng InterruptibleOrNot\n+ * @run junit InterruptibleOrNot\n@@ -43,4 +43,1 @@\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n+import java.util.Arrays;\n@@ -49,2 +46,4 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.function.Executable;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -52,1 +51,0 @@\n-@Test\n@@ -54,0 +52,2 @@\n+    \/\/ DatagramChannel implementation class\n+    private static String dcImplClassName;\n@@ -55,18 +55,5 @@\n-    public void testInterruptBeforeInterruptibleReceive() throws Exception {\n-        testInterruptBeforeReceive(true);\n-    }\n-\n-    public void testInterruptDuringInterruptibleReceive() throws Exception {\n-        testInterruptDuringReceive(true);\n-    }\n-\n-    public void testInterruptBeforeUninterruptibleReceive() throws Exception {\n-        testInterruptBeforeReceive(false);\n-    }\n-\n-    public void testInterruptDuringUninterruptibleReceive() throws Exception {\n-        testInterruptDuringReceive(false);\n-    }\n-\n-    public void testInterruptBeforeInterruptibleSend() throws Exception {\n-        testInterruptBeforeSend(true);\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        try (DatagramChannel dc = boundDatagramChannel(true)) {\n+            dcImplClassName = dc.getClass().getName();\n+        }\n@@ -75,2 +62,14 @@\n-    public void testInterruptBeforeUninterruptibleSend() throws Exception {\n-        testInterruptBeforeSend(false);\n+    \/**\n+     * Call DatagramChannel.receive with the interrupt status set, the DatagramChannel\n+     * is interruptible.\n+     *\/\n+    @Test\n+    public void testInterruptBeforeInterruptibleReceive() throws Exception {\n+        try (DatagramChannel dc = boundDatagramChannel(true)) {\n+            ByteBuffer buf = ByteBuffer.allocate(100);\n+            Thread.currentThread().interrupt();\n+            assertThrows(ClosedByInterruptException.class, () -> dc.receive(buf));\n+            assertFalse(dc.isOpen());\n+        } finally {\n+            Thread.interrupted();  \/\/ clear interrupt status\n+        }\n@@ -80,1 +79,2 @@\n-     * Test invoking DatagramChannel receive with interrupt status set\n+     * Test interrupting a thread blocked in DatagramChannel.receive, the DatagramChannel\n+     * is interruptible.\n@@ -82,13 +82,8 @@\n-    static void testInterruptBeforeReceive(boolean interruptible)\n-        throws Exception\n-    {\n-        try (DatagramChannel dc = openDatagramChannel(interruptible)) {\n-            dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n-            Future<?> timeout = scheduleClose(dc, Duration.ofSeconds(2));\n-            try {\n-                ByteBuffer buf = ByteBuffer.allocate(100);\n-                Thread.currentThread().interrupt();\n-                assertThrows(expectedException(interruptible), () -> dc.receive(buf));\n-            } finally {\n-                timeout.cancel(false);\n-            }\n+    @Test\n+    public void testInterruptDuringInterruptibleReceive() throws Exception {\n+        try (DatagramChannel dc = boundDatagramChannel(true)) {\n+            ByteBuffer buf = ByteBuffer.allocate(100);\n+            Thread thread = Thread.currentThread();\n+            onReceive(thread::interrupt);\n+            assertThrows(ClosedByInterruptException.class, () -> dc.receive(buf));\n+            assertFalse(dc.isOpen());\n@@ -96,1 +91,1 @@\n-            Thread.interrupted();  \/\/ clear interrupt\n+            Thread.interrupted();  \/\/ clear interrupt status\n@@ -101,1 +96,2 @@\n-     * Test Thread.interrupt when target thread is blocked in DatagramChannel receive\n+     * Call DatagramChannel.receive with the interrupt status set, the DatagramChannel\n+     * is not interruptible.\n@@ -103,14 +99,12 @@\n-    static void testInterruptDuringReceive(boolean interruptible)\n-        throws Exception\n-    {\n-        try (DatagramChannel dc = openDatagramChannel(interruptible)) {\n-            dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n-            Future<?> timerTask = scheduleClose(dc, Duration.ofSeconds(5));\n-            Future<?> interruptTask = scheduleInterrupt(Thread.currentThread(), Duration.ofSeconds(1));\n-            try {\n-                ByteBuffer buf = ByteBuffer.allocate(100);\n-                assertThrows(expectedException(interruptible), () -> dc.receive(buf));\n-            } finally {\n-                timerTask.cancel(false);\n-                interruptTask.cancel(false);\n-            }\n+    @Test\n+    public void testInterruptBeforeUninterruptibleReceive() throws Exception {\n+        try (DatagramChannel dc = boundDatagramChannel(false)) {\n+            ByteBuffer buf = ByteBuffer.allocate(100);\n+            onReceive(() -> {\n+                \/\/ close the channel after a delay to ensure receive wakes up\n+                Thread.sleep(1000);\n+                dc.close();\n+            });\n+            Thread.currentThread().interrupt();\n+            assertThrows(AsynchronousCloseException.class, () -> dc.receive(buf));\n+            assertFalse(dc.isOpen());\n@@ -118,1 +112,1 @@\n-            Thread.interrupted();  \/\/ clear interrupt\n+            Thread.interrupted();  \/\/ clear interrupt status\n@@ -123,1 +117,2 @@\n-     * Test invoking DatagramChannel send with interrupt status set\n+     * Test interrupting a thread blocked in DatagramChannel.receive, the DatagramChannel\n+     * is not interruptible.\n@@ -125,19 +120,16 @@\n-    static void testInterruptBeforeSend(boolean interruptible)\n-        throws Exception\n-    {\n-        try (DatagramChannel dc = openDatagramChannel(interruptible)) {\n-            dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n-            Future<?> timeout = scheduleClose(dc, Duration.ofSeconds(2));\n-            try {\n-                ByteBuffer buf = ByteBuffer.allocate(100);\n-                SocketAddress target = dc.getLocalAddress();\n-                Thread.currentThread().interrupt();\n-                if (interruptible) {\n-                    assertThrows(ClosedByInterruptException.class, () -> dc.send(buf, target));\n-                } else {\n-                    int n = dc.send(buf, target);\n-                    assertTrue(n == 100);\n-                }\n-            } finally {\n-                timeout.cancel(false);\n-            }\n+    @Test\n+    public void testInterruptDuringUninterruptibleReceive() throws Exception {\n+        try (DatagramChannel dc = boundDatagramChannel(true)) {\n+            ByteBuffer buf = ByteBuffer.allocate(100);\n+\n+            Thread thread = Thread.currentThread();\n+            onReceive(() -> {\n+                \/\/ interrupt should not cause the receive to wakeup\n+                thread.interrupt();\n+\n+                \/\/ close the channel after a delay to ensure receive wakes up\n+                Thread.sleep(1000);\n+                dc.close();\n+            });\n+            assertThrows(AsynchronousCloseException.class, () -> dc.receive(buf));\n+            assertFalse(dc.isOpen());\n@@ -145,1 +137,1 @@\n-            Thread.interrupted();  \/\/ clear interrupt\n+            Thread.interrupted();  \/\/ clear interrupt status\n@@ -150,1 +142,2 @@\n-     * Creates a DatagramChannel that is interruptible or not.\n+     * Call DatagramChannel.send with the interrupt status set, the DatagramChannel\n+     * is interruptible.\n@@ -152,5 +145,10 @@\n-    static DatagramChannel openDatagramChannel(boolean interruptible) throws IOException {\n-        if (interruptible) {\n-            return DatagramChannel.open();\n-        } else {\n-            return DefaultSelectorProvider.get().openUninterruptibleDatagramChannel();\n+    @Test\n+    public void testInterruptBeforeInterruptibleSend() throws Exception {\n+        try (DatagramChannel dc = boundDatagramChannel(true)) {\n+            ByteBuffer buf = ByteBuffer.allocate(100);\n+            SocketAddress target = dc.getLocalAddress();\n+            Thread.currentThread().interrupt();\n+            assertThrows(ClosedByInterruptException.class, () -> dc.send(buf, target));\n+            assertFalse(dc.isOpen());\n+        } finally {\n+            Thread.interrupted();  \/\/ clear interrupt\n@@ -161,1 +159,2 @@\n-     * Expect ClosedByInterruptException if interruptible.\n+     * Call DatagramChannel.send with the interrupt status set, the DatagramChannel\n+     * is not interruptible.\n@@ -163,5 +162,11 @@\n-    static Class<? extends Exception> expectedException(boolean expectInterrupt) {\n-        if (expectInterrupt) {\n-            return ClosedByInterruptException.class;\n-        } else {\n-            return AsynchronousCloseException.class;\n+    @Test\n+    public void testInterruptBeforeUninterruptibleSend() throws Exception {\n+        try (DatagramChannel dc = boundDatagramChannel(false)) {\n+            ByteBuffer buf = ByteBuffer.allocate(100);\n+            SocketAddress target = dc.getLocalAddress();\n+            Thread.currentThread().interrupt();\n+            int n = dc.send(buf, target);\n+            assertEquals(100, n);\n+            assertTrue(dc.isOpen());\n+        } finally {\n+            Thread.interrupted();  \/\/ clear interrupt status\n@@ -172,1 +177,2 @@\n-     * Schedule the given object to be closed.\n+     * Creates a DatagramChannel that is interruptible or not, and bound to the loopback\n+     * address.\n@@ -174,6 +180,14 @@\n-    static Future<?> scheduleClose(Closeable c, Duration timeout) {\n-        long nanos = TimeUnit.NANOSECONDS.convert(timeout);\n-        return STPE.schedule(() -> {\n-            c.close();\n-            return null;\n-        }, nanos, TimeUnit.NANOSECONDS);\n+    static DatagramChannel boundDatagramChannel(boolean interruptible) throws IOException {\n+        DatagramChannel dc;\n+        if (interruptible) {\n+            dc = DatagramChannel.open();\n+        } else {\n+            dc = DefaultSelectorProvider.get().openUninterruptibleDatagramChannel();\n+        }\n+        try {\n+            dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+        } catch (IOException ioe) {\n+            dc.close();\n+            throw ioe;\n+        }\n+        return dc;\n@@ -183,1 +197,1 @@\n-     * Schedule the given thread to be interrupted.\n+     * Runs the given action when the current thread is sampled in DatagramChannel.receive.\n@@ -185,3 +199,17 @@\n-    static Future<?> scheduleInterrupt(Thread t, Duration timeout) {\n-        long nanos = TimeUnit.NANOSECONDS.convert(timeout);\n-        return STPE.schedule(t::interrupt, nanos, TimeUnit.NANOSECONDS);\n+    static void onReceive(Executable action) {\n+        Thread target = Thread.currentThread();\n+        Thread.ofPlatform().daemon().start(() -> {\n+            try {\n+                boolean found = false;\n+                while (!found) {\n+                    Thread.sleep(20);\n+                    StackTraceElement[] stack = target.getStackTrace();\n+                    found = Arrays.stream(stack)\n+                            .anyMatch(e -> dcImplClassName.equals(e.getClassName())\n+                                    && \"receive\".equals(e.getMethodName()));\n+                }\n+                action.execute();\n+            } catch (Throwable ex) {\n+                ex.printStackTrace();\n+            }\n+        });\n@@ -189,2 +217,0 @@\n-\n-    static final ScheduledExecutorService STPE = Executors.newScheduledThreadPool(0);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/InterruptibleOrNot.java","additions":132,"deletions":106,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,2 @@\n-                    throw new RuntimeException(\"wrong username\");\n+                    throw new RuntimeException(\"wrong username, actual \" + s1 +\n+                                               \" but expected value from property user.name is \" + s2);\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/SocketOptions.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-        \/\/ Wait 5 seconds for server ready\n+        \/\/ Wait 60 seconds for server ready\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/OCSP\/OCSPTimeout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,1 @@\n- * @library \/java\/text\/testlib\n- * @run main\/timeout=2000 BreakIteratorTest\n+ * @run junit\/timeout=2000 BreakIteratorTest\n@@ -81,6 +80,1 @@\n-public class BreakIteratorTest extends IntlTest\n-{\n-    private BreakIterator characterBreak;\n-    private BreakIterator wordBreak;\n-    private BreakIterator lineBreak;\n-    private BreakIterator sentenceBreak;\n+import org.junit.jupiter.api.Test;\n@@ -88,3 +82,7 @@\n-    public static void main(String[] args) throws Exception {\n-        new BreakIteratorTest().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class BreakIteratorTest {\n+    private final BreakIterator characterBreak = BreakIterator.getCharacterInstance();\n+    private final BreakIterator wordBreak = BreakIterator.getWordInstance();\n+    private final BreakIterator lineBreak = BreakIterator.getLineInstance();\n+    private final BreakIterator sentenceBreak = BreakIterator.getSentenceInstance();\n@@ -92,7 +90,0 @@\n-    public BreakIteratorTest()\n-    {\n-        characterBreak = BreakIterator.getCharacterInstance();\n-        wordBreak = BreakIterator.getWordInstance();\n-        lineBreak = BreakIterator.getLineInstance();\n-        sentenceBreak = BreakIterator.getSentenceInstance();\n-    }\n@@ -118,2 +109,1 @@\n-        logln(\"comparing forward and backward...\");\n-        int errs = getErrorCount();\n+        System.out.println(\"comparing forward and backward...\");\n@@ -122,5 +112,3 @@\n-        if (getErrorCount() == errs) {\n-            logln(\"comparing expected and actual...\");\n-            compareFragmentLists(\"expected result\", \"actual result\", expectedResult,\n-                            nextResults);\n-        }\n+        System.out.println(\"comparing expected and actual...\");\n+        compareFragmentLists(\"expected result\", \"actual result\", expectedResult,\n+                        nextResults);\n@@ -149,1 +137,1 @@\n-            errln(\"first() returned \" + p + \" instead of 0\");\n+            fail(\"first() returned \" + p + \" instead of 0\");\n@@ -154,1 +142,1 @@\n-                    errln(\"next() failed to move forward: next() on position \"\n+                    fail(\"next() failed to move forward: next() on position \"\n@@ -161,1 +149,1 @@\n-                    errln(\"next() returned DONE prematurely: offset was \"\n+                    fail(\"next() returned DONE prematurely: offset was \"\n@@ -175,1 +163,1 @@\n-            errln(\"last() returned \" + p + \" instead of \" + text.length());\n+            fail(\"last() returned \" + p + \" instead of \" + text.length());\n@@ -180,1 +168,1 @@\n-                    errln(\"previous() failed to move backward: previous() on position \"\n+                    fail(\"previous() failed to move backward: previous() on position \"\n@@ -187,1 +175,1 @@\n-                    errln(\"previous() returned DONE prematurely: offset was \"\n+                    fail(\"previous() returned DONE prematurely: offset was \"\n@@ -230,1 +218,1 @@\n-                logln(\"*** \" + f1Name + \" has:\");\n+                System.out.println(\"*** \" + f1Name + \" has:\");\n@@ -237,1 +225,1 @@\n-                logln(\"***** \" + f2Name + \" has:\");\n+                System.out.println(\"***** \" + f2Name + \" has:\");\n@@ -244,1 +232,2 @@\n-                errln(\"Discrepancy between \" + f1Name + \" and \" + f2Name + \"\\n---\\n\" + f1 +\"\\n---\\n\" + f2);\n+                fail(\"Discrepancy between \" + f1Name + \" and \" + f2Name\n+                        + \"\\n---\\n\" + f1 +\"\\n---\\n\" + f2);\n@@ -250,1 +239,1 @@\n-        logln(\"testFollowing():\");\n+        System.out.println(\"testFollowing():\");\n@@ -259,1 +248,1 @@\n-                logln(\"bi.following(\" + i + \") -> \" + b);\n+                System.out.println(\"bi.following(\" + i + \") -> \" + b);\n@@ -261,1 +250,1 @@\n-                    errln(\"Wrong result from following() for \" + i + \": expected \" + boundaries[p]\n+                    fail(\"Wrong result from following() for \" + i + \": expected \" + boundaries[p]\n@@ -265,1 +254,1 @@\n-            errln(\"IllegalArgumentException caught from following() for offset: \" + i);\n+            fail(\"IllegalArgumentException caught from following() for offset: \" + i);\n@@ -270,1 +259,1 @@\n-        logln(\"testPreceding():\");\n+        System.out.println(\"testPreceding():\");\n@@ -276,1 +265,1 @@\n-                logln(\"bi.preceding(\" + i + \") -> \" + b);\n+                System.out.println(\"bi.preceding(\" + i + \") -> \" + b);\n@@ -278,1 +267,1 @@\n-                    errln(\"Wrong result from preceding() for \" + i + \": expected \" + boundaries[p]\n+                    fail(\"Wrong result from preceding() for \" + i + \": expected \" + boundaries[p]\n@@ -285,1 +274,1 @@\n-            errln(\"IllegalArgumentException caught from preceding() for offset: \" + i);\n+            fail(\"IllegalArgumentException caught from preceding() for offset: \" + i);\n@@ -290,1 +279,1 @@\n-        logln(\"testIsBoundary():\");\n+        System.out.println(\"testIsBoundary():\");\n@@ -295,1 +284,1 @@\n-            logln(\"bi.isBoundary(\" + i + \") -> \" + isB);\n+            System.out.println(\"bi.isBoundary(\" + i + \") -> \" + isB);\n@@ -299,1 +288,1 @@\n-                    errln(\"Wrong result from isBoundary() for \" + i + \": expected true, got false\");\n+                    fail(\"Wrong result from isBoundary() for \" + i + \": expected true, got false\");\n@@ -304,1 +293,1 @@\n-                    errln(\"Wrong result from isBoundary() for \" + i + \": expected false, got true\");\n+                    fail(\"Wrong result from isBoundary() for \" + i + \": expected false, got true\");\n@@ -311,1 +300,1 @@\n-        logln(\"Multiple selection test...\");\n+        System.out.println(\"Multiple selection test...\");\n@@ -320,1 +309,1 @@\n-            logln(\"next(\" + count + \") -> \" + testOffset);\n+            System.out.println(\"next(\" + count + \") -> \" + testOffset);\n@@ -322,1 +311,1 @@\n-                errln(\"next(n) and next() not returning consistent results: for step \" + count + \", next(n) returned \" + testOffset + \" and next() had \" + offset);\n+                fail(\"next(n) and next() not returning consistent results: for step \" + count + \", next(n) returned \" + testOffset + \" and next() had \" + offset);\n@@ -337,1 +326,1 @@\n-            logln(\"next(\" + count + \") -> \" + testOffset);\n+            System.out.println(\"next(\" + count + \") -> \" + testOffset);\n@@ -339,1 +328,1 @@\n-                errln(\"next(n) and next() not returning consistent results: for step \" + count + \", next(n) returned \" + testOffset + \" and next() had \" + offset);\n+                fail(\"next(n) and next() not returning consistent results: for step \" + count + \", next(n) returned \" + testOffset + \" and next() had \" + offset);\n@@ -385,1 +374,1 @@\n-                        errln(\"No break between U+\" + Integer.toHexString((int)(work.charAt(1)))\n+                        fail(\"No break between U+\" + Integer.toHexString((int)(work.charAt(1)))\n@@ -409,1 +398,1 @@\n-                        errln(\"Break between CR and LF in string U+\" + Integer.toHexString(\n+                        fail(\"Break between CR and LF in string U+\" + Integer.toHexString(\n@@ -447,1 +436,1 @@\n-                        errln(\"Break between U+\" + Integer.toHexString((int)(work.charAt(1)))\n+                        fail(\"Break between U+\" + Integer.toHexString((int)(work.charAt(1)))\n@@ -472,1 +461,1 @@\n-        logln(out.toString());\n+        System.out.println(out.toString());\n@@ -479,0 +468,1 @@\n+    @Test\n@@ -562,0 +552,1 @@\n+    @Test\n@@ -571,0 +562,1 @@\n+    @Test\n@@ -600,0 +592,1 @@\n+    @Test\n@@ -612,0 +605,1 @@\n+    @Test\n@@ -647,0 +641,1 @@\n+    @Test\n@@ -656,0 +651,1 @@\n+    @Test\n@@ -675,0 +671,1 @@\n+    @Test\n@@ -697,0 +694,1 @@\n+    @Test\n@@ -714,0 +712,1 @@\n+    @Test\n@@ -725,0 +724,1 @@\n+    @Test\n@@ -737,0 +737,1 @@\n+    @Test\n@@ -755,0 +756,1 @@\n+    @Test\n@@ -766,0 +768,1 @@\n+    @Test\n@@ -802,0 +805,1 @@\n+    @Test\n@@ -818,0 +822,1 @@\n+    @Test\n@@ -827,0 +832,1 @@\n+    @Test\n@@ -839,0 +845,1 @@\n+    @Test\n@@ -852,0 +859,1 @@\n+    @Test\n@@ -877,1 +885,1 @@\n-            logln(\"This test is skipped in th locale.\");\n+            System.out.println(\"This test is skipped in th locale.\");\n@@ -884,0 +892,1 @@\n+    @Test\n@@ -895,0 +904,1 @@\n+    @Test\n@@ -897,1 +907,1 @@\n-            logln(\"This test is skipped in th locale.\");\n+            System.out.println(\"This test is skipped in th locale.\");\n@@ -924,0 +934,1 @@\n+    @Test\n@@ -955,0 +966,1 @@\n+    @Test\n@@ -995,0 +1007,1 @@\n+    @Test\n@@ -1008,1 +1021,1 @@\n-                    errln(\"Didn't get exception with offset = \" + index +\n+                    fail(\"Didn't get exception with offset = \" + index +\n@@ -1013,1 +1026,1 @@\n-                    errln(\"Got exception with offset = \" + index +\n+                    fail(\"Got exception with offset = \" + index +\n@@ -1019,0 +1032,1 @@\n+    @Test\n@@ -1034,0 +1048,1 @@\n+    @Test\n@@ -1036,1 +1051,1 @@\n-            logln(\"This test is skipped in th locale.\");\n+            System.out.println(\"This test is skipped in th locale.\");\n@@ -1049,0 +1064,1 @@\n+    @Test\n@@ -1051,1 +1067,1 @@\n-            logln(\"This test is skipped in th locale.\");\n+            System.out.println(\"This test is skipped in th locale.\");\n@@ -1073,0 +1089,1 @@\n+    @Test\n@@ -1079,0 +1096,1 @@\n+    @Test\n@@ -1082,1 +1100,1 @@\n-            logln(\"This test is skipped in th locale.\");\n+            System.out.println(\"This test is skipped in th locale.\");\n@@ -1093,0 +1111,1 @@\n+    @Test\n@@ -1096,1 +1115,1 @@\n-            logln(\"This test is skipped in th locale.\");\n+            System.out.println(\"This test is skipped in th locale.\");\n@@ -1145,1 +1164,1 @@\n-                            errln(\"Got break between U+\" + Integer.toHexString((int)\n+                            fail(\"Got break between U+\" + Integer.toHexString((int)\n@@ -1198,1 +1217,1 @@\n-                        errln(\"Didn't get break between U+\" + Integer.toHexString((int)\n+                        fail(\"Didn't get break between U+\" + Integer.toHexString((int)\n@@ -1211,0 +1230,1 @@\n+    @Test\n@@ -1220,0 +1240,1 @@\n+    @Test\n@@ -1229,0 +1250,1 @@\n+    @Test\n@@ -1234,1 +1256,1 @@\n-            errln(\"getAvailableLocales() returned an empty list!\");\n+            fail(\"getAvailableLocales() returned an empty list!\");\n@@ -1242,0 +1264,1 @@\n+    @Test\n@@ -1290,1 +1313,1 @@\n-                errln(\"ja line break failure: failed to start at 0 and bounced at \" + j);\n+                fail(\"ja line break failure: failed to start at 0 and bounced at \" + j);\n@@ -1294,1 +1317,1 @@\n-                errln(\"ja line break failure: failed to stop before '\"\n+                fail(\"ja line break failure: failed to stop before '\"\n@@ -1301,1 +1324,1 @@\n-                errln(\"ja line break failure: failed to skip position after '\"\n+                fail(\"ja line break failure: failed to skip position after '\"\n@@ -1313,1 +1336,1 @@\n-                errln(\"ja line break failure: failed to start at 0 and bounded at \" + j);\n+                fail(\"ja line break failure: failed to start at 0 and bounded at \" + j);\n@@ -1317,1 +1340,1 @@\n-                errln(\"ja line break failure: failed to skip position before '\"\n+                fail(\"ja line break failure: failed to skip position before '\"\n@@ -1324,1 +1347,1 @@\n-                errln(\"ja line break failure: failed to stop after '\"\n+                fail(\"ja line break failure: failed to stop after '\"\n@@ -1335,0 +1358,1 @@\n+    @Test\n@@ -1348,1 +1372,1 @@\n-            errln(\"Word break failure: failed to stop at 5 and bounded at \" + i);\n+            fail(\"Word break failure: failed to stop at 5 and bounded at \" + i);\n@@ -1361,1 +1385,1 @@\n-            errln(\"Line break failure: failed to skip before \\\\u301F(Pe) at 3 and bounded at \" + i);\n+            fail(\"Line break failure: failed to skip before \\\\u301F(Pe) at 3 and bounded at \" + i);\n@@ -1371,1 +1395,1 @@\n-            errln(\"Mongolian line break failure: failed to skip position before \\\\u1806(Pd) at 2 and bounded at \" + i);\n+            fail(\"Mongolian line break failure: failed to skip position before \\\\u1806(Pd) at 2 and bounded at \" + i);\n@@ -1381,1 +1405,1 @@\n-            errln(\"Khmer line break failure: failed to stop before \\\\u17DB(Sc) at 1 and bounded at \" + i);\n+            fail(\"Khmer line break failure: failed to stop before \\\\u17DB(Sc) at 1 and bounded at \" + i);\n@@ -1385,1 +1409,1 @@\n-            errln(\"Khmer line break failure: failed to skip position after \\\\u17DB(Sc) at 3 and bounded at \" + i);\n+            fail(\"Khmer line break failure: failed to skip position after \\\\u17DB(Sc) at 3 and bounded at \" + i);\n@@ -1395,1 +1419,1 @@\n-            errln(\"Ogham line break failure: failed to skip postion before \\\\u1680(Zs) at 2 and bounded at \" + i);\n+            fail(\"Ogham line break failure: failed to skip postion before \\\\u1680(Zs) at 2 and bounded at \" + i);\n@@ -1412,1 +1436,1 @@\n-            errln(\"Thai line break failure: failed to stop before \\\\u201C(Pi) at 1 and bounded at \" + i);\n+            fail(\"Thai line break failure: failed to stop before \\\\u201C(Pi) at 1 and bounded at \" + i);\n@@ -1416,1 +1440,1 @@\n-            errln(\"Thai line break failure: failed to stop after \\\\u201D(Pf) at 4 and bounded at \" + i);\n+            fail(\"Thai line break failure: failed to stop after \\\\u201D(Pf) at 4 and bounded at \" + i);\n@@ -1423,0 +1447,1 @@\n+    @Test\n@@ -1430,1 +1455,1 @@\n-            errln(\"Didn't get break at beginning of string.\");\n+            fail(\"Didn't get break at beginning of string.\");\n@@ -1432,1 +1457,1 @@\n-            errln(\"Didn't get break before period in \\\"boo.\\\"\");\n+            fail(\"Didn't get break before period in \\\"boo.\\\"\");\n@@ -1434,1 +1459,1 @@\n-            errln(\"Didn't get break at end of string.\");\n+            fail(\"Didn't get break at end of string.\");\n@@ -1442,0 +1467,1 @@\n+    @Test\n@@ -1456,0 +1482,1 @@\n+    @Test\n@@ -1473,0 +1500,1 @@\n+    @Test\n","filename":"test\/jdk\/java\/text\/BreakIterator\/BreakIteratorTest.java","additions":112,"deletions":84,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -27,1 +27,0 @@\n- * @library \/java\/text\/testlib\n@@ -29,0 +28,1 @@\n+ * @run junit Bug4533872\n@@ -34,1 +34,1 @@\n-public class Bug4533872 extends IntlTest {\n+import org.junit.jupiter.api.Test;\n@@ -36,3 +36,3 @@\n-    public static void main(String[] args) throws Exception {\n-        new Bug4533872().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class Bug4533872 {\n@@ -65,0 +65,1 @@\n+    @Test\n@@ -76,1 +77,1 @@\n-                errln(\"Word break failure: printEachForward() expected:<\" +\n+                fail(\"Word break failure: printEachForward() expected:<\" +\n@@ -87,0 +88,1 @@\n+    @Test\n@@ -98,1 +100,1 @@\n-                    errln(\"Word break failure: isBoundary() This should be a boundary. Index=\" +\n+                    fail(\"Word break failure: isBoundary() This should be a boundary. Index=\" +\n@@ -115,0 +117,1 @@\n+    @Test\n@@ -125,1 +128,1 @@\n-                errln(\"Word break failure: printEachForward() Unexpected current value: current()=\" +\n+                fail(\"Word break failure: printEachForward() Unexpected current value: current()=\" +\n@@ -137,1 +140,1 @@\n-                    errln(\"Word break failure: printEachForward() Unexpected current value: current()=\" +\n+                    fail(\"Word break failure: printEachForward() Unexpected current value: current()=\" +\n@@ -142,1 +145,1 @@\n-                    errln(\"Word break failure: printEachForward() expected:<\" +\n+                    fail(\"Word break failure: printEachForward() expected:<\" +\n@@ -154,0 +157,1 @@\n+    @Test\n@@ -164,1 +168,1 @@\n-                errln(\"Word break failure: printEachBackward() Unexpected current value: current()=\" +\n+                fail(\"Word break failure: printEachBackward() Unexpected current value: current()=\" +\n@@ -176,1 +180,1 @@\n-                    errln(\"Word break failure: printEachBackward() Unexpected current value: current()=\" +\n+                    fail(\"Word break failure: printEachBackward() Unexpected current value: current()=\" +\n@@ -181,1 +185,1 @@\n-                    errln(\"Word break failure: printEachBackward() expected:<\" +\n+                    fail(\"Word break failure: printEachBackward() expected:<\" +\n@@ -193,0 +197,1 @@\n+    @Test\n@@ -210,1 +215,1 @@\n-                    errln(\"Word break failure: printAt_1() expected:<\" +\n+                    fail(\"Word break failure: printAt_1() expected:<\" +\n@@ -222,0 +227,1 @@\n+    @Test\n@@ -237,1 +243,1 @@\n-                 errln(\"Word break failure: printAt_2() expected:-1(BreakIterator.DONE), got:\" +\n+                 fail(\"Word break failure: printAt_2() expected:-1(BreakIterator.DONE), got:\" +\n@@ -246,1 +252,1 @@\n-                    errln(\"Word break failure: printAt_2() expected:<\" +\n+                    fail(\"Word break failure: printAt_2() expected:<\" +\n@@ -257,1 +263,1 @@\n-                 errln(\"Word break failure: printAt_2() expected:-1(BreakIterator.DONE), got:\" + start);\n+                 fail(\"Word break failure: printAt_2() expected:-1(BreakIterator.DONE), got:\" + start);\n","filename":"test\/jdk\/java\/text\/BreakIterator\/Bug4533872.java","additions":25,"deletions":19,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @library \/java\/text\/testlib\n@@ -28,0 +27,1 @@\n+ * @run junit CharacterIteratorTest\n@@ -68,4 +68,3 @@\n-public class CharacterIteratorTest extends IntlTest {\n-    public static void main(String[] args) throws Exception {\n-        new CharacterIteratorTest().run(args);\n-    }\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n@@ -73,0 +72,1 @@\n+public class CharacterIteratorTest {\n@@ -76,0 +76,1 @@\n+    @Test\n@@ -87,1 +88,1 @@\n-            errln(\"Construation or equals() failed: Two unequal iterators tested equal\");\n+            fail(\"Construation or equals() failed: Two unequal iterators tested equal\");\n@@ -90,1 +91,1 @@\n-            errln(\"clone() or equals() failed: Two clones tested unequal\");\n+            fail(\"clone() or equals() failed: Two clones tested unequal\");\n@@ -94,1 +95,1 @@\n-            errln(\"hash() failed:  different objects have same hash code\");\n+            fail(\"hash() failed:  different objects have same hash code\");\n@@ -97,1 +98,1 @@\n-            errln(\"hash() failed:  identical objects have different hash codes\");\n+            fail(\"hash() failed:  identical objects have different hash codes\");\n@@ -101,1 +102,1 @@\n-            errln(\"setIndex() failed\");\n+            fail(\"setIndex() failed\");\n@@ -104,0 +105,1 @@\n+    @Test\n@@ -110,1 +112,1 @@\n-            errln(\"Iterator didn't start out in the right place.\");\n+            fail(\"Iterator didn't start out in the right place.\");\n@@ -116,1 +118,1 @@\n-            errln(\"getBeginIndex() or getEndIndex() failed\");\n+            fail(\"getBeginIndex() or getEndIndex() failed\");\n@@ -118,1 +120,1 @@\n-        logln(\"Testing forward iteration...\");\n+        System.out.println(\"Testing forward iteration...\");\n@@ -121,1 +123,1 @@\n-                errln(\"Iterator reached end prematurely\");\n+                fail(\"Iterator reached end prematurely\");\n@@ -123,1 +125,1 @@\n-                errln(\"Character mismatch at position \" + i + \", iterator has \" + c +\n+                fail(\"Character mismatch at position \" + i + \", iterator has \" + c +\n@@ -127,1 +129,1 @@\n-                errln(\"current() isn't working right\");\n+                fail(\"current() isn't working right\");\n@@ -129,1 +131,1 @@\n-                errln(\"getIndex() isn't working right\");\n+                fail(\"getIndex() isn't working right\");\n@@ -140,1 +142,1 @@\n-        logln(\"Testing backward iteration...\");\n+        System.out.println(\"Testing backward iteration...\");\n@@ -143,1 +145,1 @@\n-                errln(\"Iterator reached end prematurely\");\n+                fail(\"Iterator reached end prematurely\");\n@@ -145,1 +147,1 @@\n-                errln(\"Character mismatch at position \" + i + \", iterator has \" + c +\n+                fail(\"Character mismatch at position \" + i + \", iterator has \" + c +\n@@ -149,1 +151,1 @@\n-                errln(\"current() isn't working right\");\n+                fail(\"current() isn't working right\");\n@@ -151,1 +153,1 @@\n-                errln(\"getIndex() isn't working right\");\n+                fail(\"getIndex() isn't working right\");\n@@ -161,1 +163,1 @@\n-            errln(\"creation of a restricted-range iterator failed\");\n+            fail(\"creation of a restricted-range iterator failed\");\n@@ -164,1 +166,1 @@\n-            errln(\"starting the iterator in the middle didn't work\");\n+            fail(\"starting the iterator in the middle didn't work\");\n@@ -169,1 +171,1 @@\n-        logln(\"Testing forward iteration over a range...\");\n+        System.out.println(\"Testing forward iteration over a range...\");\n@@ -172,1 +174,1 @@\n-                errln(\"Iterator reached end prematurely\");\n+                fail(\"Iterator reached end prematurely\");\n@@ -174,1 +176,1 @@\n-                errln(\"Character mismatch at position \" + i + \", iterator has \" + c +\n+                fail(\"Character mismatch at position \" + i + \", iterator has \" + c +\n@@ -178,1 +180,1 @@\n-                errln(\"current() isn't working right\");\n+                fail(\"current() isn't working right\");\n@@ -180,1 +182,1 @@\n-                errln(\"getIndex() isn't working right\");\n+                fail(\"getIndex() isn't working right\");\n@@ -191,1 +193,1 @@\n-        logln(\"Testing backward iteration over a range...\");\n+        System.out.println(\"Testing backward iteration over a range...\");\n@@ -194,1 +196,1 @@\n-                errln(\"Iterator reached end prematurely\");\n+                fail(\"Iterator reached end prematurely\");\n@@ -196,1 +198,1 @@\n-                errln(\"Character mismatch at position \" + i + \", iterator has \" + c +\n+                fail(\"Character mismatch at position \" + i + \", iterator has \" + c +\n@@ -200,1 +202,1 @@\n-                errln(\"current() isn't working right\");\n+                fail(\"current() isn't working right\");\n@@ -202,1 +204,1 @@\n-                errln(\"getIndex() isn't working right\");\n+                fail(\"getIndex() isn't working right\");\n@@ -214,0 +216,1 @@\n+    @Test\n@@ -230,1 +233,1 @@\n-            errln(\"Got something other than DONE when performing operations on an empty StringCharacterIterator\");\n+            fail(\"Got something other than DONE when performing operations on an empty StringCharacterIterator\");\n@@ -245,1 +248,1 @@\n-            errln(\"StringCharacterIterator didn't throw an exception when given an invalid substring range.\");\n+            fail(\"StringCharacterIterator didn't throw an exception when given an invalid substring range.\");\n@@ -256,1 +259,1 @@\n-            errln(\"last() failed: expected \" + (expectedIndex - 1) + \", got \" + actualIndex);\n+            fail(\"last() failed: expected \" + (expectedIndex - 1) + \", got \" + actualIndex);\n@@ -261,1 +264,1 @@\n-            errln(\"next() after last() failed: expected \" + expectedIndex + \", got \" + actualIndex);\n+            fail(\"next() after last() failed: expected \" + expectedIndex + \", got \" + actualIndex);\n@@ -266,1 +269,1 @@\n-            errln(\"second next() after last() failed: expected \" + expectedIndex + \", got \" + actualIndex);\n+            fail(\"second next() after last() failed: expected \" + expectedIndex + \", got \" + actualIndex);\n@@ -274,0 +277,1 @@\n+    @Test\n@@ -286,1 +290,1 @@\n-            errln(\"\"); \/\/ re-throw the exception through our test framework\n+            fail(\"\"); \/\/ re-throw the exception through our test framework\n","filename":"test\/jdk\/java\/text\/CharacterIterator\/CharacterIteratorTest.java","additions":45,"deletions":41,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,6 +24,0 @@\n-\/*\n- * @test\n- * @library \/java\/text\/testlib\n- * @summary test Collation API\n- * @modules jdk.localedata\n- *\/\n@@ -42,0 +36,8 @@\n+\/*\n+ * @test\n+ * @library \/java\/text\/testlib\n+ * @summary test Collation API\n+ * @modules jdk.localedata\n+ * @run junit APITest\n+ *\/\n+\n@@ -48,1 +50,1 @@\n-public class APITest extends CollatorTest {\n+import org.junit.jupiter.api.Test;\n@@ -50,3 +52,3 @@\n-    public static void main(String[] args) throws Exception {\n-        new APITest().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class APITest {\n@@ -57,2 +59,1 @@\n-            err(\"ERROR: \");\n-            errln(message);\n+            fail(\"ERROR: \" + message);\n@@ -62,0 +63,1 @@\n+    @Test\n@@ -67,2 +69,2 @@\n-            logln(\"The property tests begin : \");\n-            logln(\"Test ctors : \");\n+            System.out.println(\"The property tests begin : \");\n+            System.out.println(\"Test ctors : \");\n@@ -75,2 +77,2 @@\n-            logln(\"Test ctors ends.\");\n-            logln(\"testing Collator.getStrength() method ...\");\n+            System.out.println(\"Test ctors ends.\");\n+            System.out.println(\"testing Collator.getStrength() method ...\");\n@@ -80,1 +82,1 @@\n-            logln(\"testing Collator.setStrength() method ...\");\n+            System.out.println(\"testing Collator.setStrength() method ...\");\n@@ -86,1 +88,1 @@\n-            logln(\"testing Collator.setDecomposition() method ...\");\n+            System.out.println(\"testing Collator.setDecomposition() method ...\");\n@@ -92,2 +94,2 @@\n-            errln(\"Error : \" + foo.getMessage());\n-            errln(\"Default Collator creation failed.\");\n+            fail(\"Error : \" + foo.getMessage()\n+            + \"\\n Default Collator creation failed.\");\n@@ -95,2 +97,2 @@\n-        logln(\"Default collation property test ended.\");\n-        logln(\"Collator.getRules() testing ...\");\n+        System.out.println(\"Default collation property test ended.\");\n+        System.out.println(\"Collator.getRules() testing ...\");\n@@ -98,1 +100,1 @@\n-        logln(\"getRules tests end.\");\n+        System.out.println(\"getRules tests end.\");\n@@ -102,1 +104,1 @@\n-            logln(\"testing Collator.getStrength() method again ...\");\n+            System.out.println(\"testing Collator.getStrength() method again ...\");\n@@ -106,1 +108,1 @@\n-            logln(\"testing French Collator.setStrength() method ...\");\n+            System.out.println(\"testing French Collator.setStrength() method ...\");\n@@ -113,2 +115,2 @@\n-            errln(\"Error :  \" + bar.getMessage());\n-            errln(\"Creating French collation failed.\");\n+            fail(\"Error :  \" + bar.getMessage()\n+            + \"\\n Creating French collation failed.\");\n@@ -117,1 +119,1 @@\n-        logln(\"Create junk collation: \");\n+        System.out.println(\"Create junk collation: \");\n@@ -123,2 +125,2 @@\n-            errln(\"Error : \" + err.getMessage());\n-            errln(\"Junk collation creation failed, should at least return the collator for the base bundle.\");\n+            fail(\"Error : \" + err.getMessage()\n+            + \"\\n Junk collation creation failed, should at least return the collator for the base bundle.\");\n@@ -130,2 +132,2 @@\n-            errln(\"Error : \" + exc.getMessage());\n-            errln(\"Default collation comparison, caching not working.\");\n+            fail(\"Error : \" + exc.getMessage()\n+            + \"\\n Default collation comparison, caching not working.\");\n@@ -134,1 +136,1 @@\n-        logln(\"Collator property test ended.\");\n+        System.out.println(\"Collator property test ended.\");\n@@ -137,0 +139,1 @@\n+    @Test\n@@ -139,1 +142,1 @@\n-        logln(\"hashCode tests begin.\");\n+        System.out.println(\"hashCode tests begin.\");\n@@ -144,2 +147,2 @@\n-            errln(\"Error : \" + foo.getMessage());\n-            errln(\"Default collation creation failed.\");\n+            fail(\"Error : \" + foo.getMessage()\n+            + \"\\n Default collation creation failed.\");\n@@ -152,2 +155,2 @@\n-            errln(\"Error : \" + bar.getMessage());\n-            errln(\"Danish collation creation failed.\");\n+            fail(\"Error : \" + bar.getMessage()\n+            + \"\\n Danish collation creation failed.\");\n@@ -160,2 +163,2 @@\n-            errln(\"Error : \" + err.getMessage());\n-            errln(\"2nd default collation creation failed.\");\n+            fail(\"Error : \" + err.getMessage()\n+            + \"\\n 2nd default collation creation failed.\");\n@@ -163,1 +166,1 @@\n-        logln(\"Collator.hashCode() testing ...\");\n+        System.out.println(\"Collator.hashCode() testing ...\");\n@@ -172,1 +175,1 @@\n-        logln(\"hashCode tests end.\");\n+        System.out.println(\"hashCode tests end.\");\n@@ -178,0 +181,1 @@\n+    @Test\n@@ -180,1 +184,1 @@\n-        logln(\"testing CollationKey begins...\");\n+        System.out.println(\"testing CollationKey begins...\");\n@@ -185,2 +189,2 @@\n-            errln(\"Error : \" + foo.getMessage());\n-            errln(\"Default collation creation failed.\");\n+            fail(\"Error : \" + foo.getMessage()\n+            + \"\\n Default collation creation failed.\");\n@@ -193,1 +197,1 @@\n-        logln(\"Use tertiary comparison level testing ....\");\n+        System.out.println(\"Use tertiary comparison level testing ....\");\n@@ -212,1 +216,1 @@\n-        logln(\"testing sortkey ends...\");\n+        System.out.println(\"testing sortkey ends...\");\n@@ -217,0 +221,1 @@\n+    @Test\n@@ -219,1 +224,1 @@\n-        logln(\"testing sortkey begins...\");\n+        System.out.println(\"testing sortkey begins...\");\n@@ -224,2 +229,2 @@\n-            errln(\"Error : \" + foo.getMessage());\n-            errln(\"Default collation creation failed.\");\n+            fail(\"Error : \" + foo.getMessage()\n+            + \"\\n Default collation creation failed.\");\n@@ -235,1 +240,1 @@\n-        logln(\"Constructors and comparison testing....\");\n+        System.out.println(\"Constructors and comparison testing....\");\n@@ -306,1 +311,1 @@\n-        logln(\"testing CollationElementIterator ends...\");\n+        System.out.println(\"testing CollationElementIterator ends...\");\n@@ -309,0 +314,1 @@\n+    @Test\n@@ -313,4 +319,4 @@\n-            log(\"Locale name: \");\n-            log(list[i].toString());\n-            log(\" , the display name is : \");\n-            logln(list[i].getDisplayName());\n+            System.out.println(\"Locale name: \");\n+            System.out.println(list[i].toString());\n+            System.out.println(\" , the display name is : \");\n+            System.out.println(list[i].getDisplayName());\n","filename":"test\/jdk\/java\/text\/Collator\/APITest.java","additions":63,"deletions":57,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @library \/java\/text\/testlib\n@@ -29,0 +28,1 @@\n+ * @run junit Bug6271411\n@@ -33,0 +33,4 @@\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n@@ -36,6 +40,1 @@\n-public class Bug6271411 extends IntlTest {\n-\n-    public static void main(String argv[]) throws Exception {\n-        Bug6271411 test = new Bug6271411();\n-        test.run(argv);\n-    }\n+public class Bug6271411 {\n@@ -61,0 +60,1 @@\n+    @Test\n@@ -93,1 +93,1 @@\n-            errln(\"CollationElementIterator.setOffset() didn't throw an expected IllegalArguemntException.\");\n+            fail(\"CollationElementIterator.setOffset() didn't throw an expected IllegalArguemntException.\");\n@@ -102,0 +102,1 @@\n+    @Test\n@@ -147,1 +148,1 @@\n-            errln(\"CollationElementIterator.setOffset() didn't throw an expected IllegalArguemntException.\");\n+            fail(\"CollationElementIterator.setOffset() didn't throw an expected IllegalArguemntException.\");\n@@ -156,0 +157,1 @@\n+    @Test\n","filename":"test\/jdk\/java\/text\/Collator\/Bug6271411.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1,141 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.reflect.*;\n-import java.util.Hashtable;\n-import java.util.Enumeration;\n-import java.util.Vector;\n-import java.io.*;\n-import java.text.*;\n-\n-\/**\n- * CollatorTest is a base class for tests that can be run conveniently from\n- * the command line as well as under the Java test harness.\n- * <p>\n- * Sub-classes implement a set of methods named Test<something>. Each\n- * of these methods performs some test. Test methods should indicate\n- * errors by calling either err or errln.  This will increment the\n- * errorCount field and may optionally print a message to the log.\n- * Debugging information may also be added to the log via the log\n- * and logln methods.  These methods will add their arguments to the\n- * log only if the test is being run in verbose mode.\n- *\/\n-public abstract class CollatorTest extends IntlTest {\n-\n-    \/\/------------------------------------------------------------------------\n-    \/\/ These methods are utilities specific to the Collation tests..\n-    \/\/------------------------------------------------------------------------\n-\n-    protected void assertEqual(CollationElementIterator i1, CollationElementIterator i2) {\n-        int c1, c2, count = 0;\n-        do {\n-            c1 = i1.next();\n-            c2 = i2.next();\n-            if (c1 != c2) {\n-                errln(\"    \" + count + \": \" + c1 + \" != \" + c2);\n-                break;\n-            }\n-            count++;\n-        } while (c1 != CollationElementIterator.NULLORDER);\n-    }\n-\n-    \/\/ Replace nonprintable characters with unicode escapes\n-    static protected String prettify(String str) {\n-        StringBuffer result = new StringBuffer();\n-\n-        String zero = \"0000\";\n-\n-        for (int i = 0; i < str.length(); i++) {\n-            char ch = str.charAt(i);\n-            if (ch < 0x09 || (ch > 0x0A && ch < 0x20)|| (ch > 0x7E && ch < 0xA0) || ch > 0x100) {\n-                String hex = Integer.toString((int)ch,16);\n-\n-                result.append(\"\\\\u\" + zero.substring(0, 4 - hex.length()) + hex);\n-            } else {\n-                result.append(ch);\n-            }\n-        }\n-        return result.toString();\n-    }\n-\n-    \/\/ Produce a printable representation of a CollationKey\n-    static protected String prettify(CollationKey key) {\n-        StringBuffer result = new StringBuffer();\n-        byte[] bytes = key.toByteArray();\n-\n-        for (int i = 0; i < bytes.length; i += 2) {\n-            int val = (bytes[i] << 8) + bytes[i+1];\n-            result.append(Integer.toString(val, 16) + \" \");\n-        }\n-        return result.toString();\n-    }\n-\n-    \/\/------------------------------------------------------------------------\n-    \/\/ Everything below here is boilerplate code that makes it possible\n-    \/\/ to add a new test by simply adding a function to an existing class\n-    \/\/------------------------------------------------------------------------\n-\n-    protected void doTest(Collator col, int strength,\n-                          String[] source, String[] target, int[] result) {\n-        if (source.length != target.length) {\n-            errln(\"Data size mismatch: source = \" +\n-                  source.length + \", target = \" + target.length);\n-\n-            return; \/\/ Return if \"-nothrow\" is specified.\n-        }\n-        if (source.length != result.length) {\n-            errln(\"Data size mismatch: source & target = \" +\n-                  source.length + \", result = \" + result.length);\n-\n-            return; \/\/ Return if \"-nothrow\" is specified.\n-        }\n-\n-        col.setStrength(strength);\n-        for (int i = 0; i < source.length ; i++) {\n-            doTest(col, source[i], target[i], result[i]);\n-        }\n-    }\n-\n-    protected void doTest(Collator col,\n-                          String source, String target, int result) {\n-        char relation = '=';\n-        if (result <= -1) {\n-            relation = '<';\n-        } else if (result >= 1) {\n-            relation = '>';\n-        }\n-\n-        int compareResult = col.compare(source, target);\n-        CollationKey sortKey1 = col.getCollationKey(source);\n-        CollationKey sortKey2 = col.getCollationKey(target);\n-        int keyResult = sortKey1.compareTo(sortKey2);\n-        if (compareResult != keyResult) {\n-            errln(\"Compare and Collation Key results are different! Source = \" +\n-                  source + \" Target = \" + target);\n-        }\n-        if (keyResult != result) {\n-            errln(\"Collation Test failed! Source = \" + source + \" Target = \" +\n-                  target + \" result should be \" + relation);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/text\/Collator\/CollatorTest.java","additions":0,"deletions":141,"binary":false,"changes":141,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @run junit DanishTest\n@@ -46,2 +47,1 @@\n-\/\/ Quick dummy program for printing out test results\n-public class DanishTest extends CollatorTest {\n+import org.junit.jupiter.api.Test;\n@@ -49,3 +49,4 @@\n-    public static void main(String[] args) throws Exception {\n-        new DanishTest().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/\/ Quick dummy program for printing out test results\n+public class DanishTest {\n@@ -199,0 +200,1 @@\n+    @Test\n@@ -200,1 +202,1 @@\n-        doTest(myCollation, Collator.PRIMARY,\n+        TestUtils.doCollatorTest(myCollation, Collator.PRIMARY,\n@@ -204,0 +206,1 @@\n+    @Test\n@@ -205,1 +208,1 @@\n-        doTest(myCollation, Collator.TERTIARY,\n+        TestUtils.doCollatorTest(myCollation, Collator.TERTIARY,\n@@ -210,1 +213,1 @@\n-                doTest(myCollation, testData[i], testData[j], -1);\n+                TestUtils.doCollatorTest(myCollation, testData[i], testData[j], -1);\n","filename":"test\/jdk\/java\/text\/Collator\/DanishTest.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @run junit DummyTest\n@@ -33,0 +34,4 @@\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n@@ -45,5 +50,1 @@\n-public class DummyTest extends CollatorTest {\n-\n-    public static void main(String[] args) throws Exception {\n-        new DummyTest().run(args);\n-    }\n+public class DummyTest {\n@@ -385,0 +386,1 @@\n+    @Test\n@@ -386,1 +388,1 @@\n-        doTest(getCollator(), Collator.PRIMARY,\n+        TestUtils.doCollatorTest(getCollator(), Collator.PRIMARY,\n@@ -390,0 +392,1 @@\n+    @Test\n@@ -391,1 +394,1 @@\n-        doTest(getCollator(), Collator.SECONDARY,\n+        TestUtils.doCollatorTest(getCollator(), Collator.SECONDARY,\n@@ -395,0 +398,1 @@\n+    @Test\n@@ -398,1 +402,1 @@\n-        doTest(col, Collator.TERTIARY,\n+        TestUtils.doCollatorTest(col, Collator.TERTIARY,\n@@ -403,1 +407,1 @@\n-                doTest(col, testData[i], testData[j], -1);\n+                TestUtils.doCollatorTest(col, testData[i], testData[j], -1);\n@@ -415,1 +419,1 @@\n-                errln(\"Collator creation failed.\");\n+                fail(\"Collator creation failed.\");\n","filename":"test\/jdk\/java\/text\/Collator\/DummyTest.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @run junit EnglishTest\n@@ -33,0 +34,4 @@\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n@@ -45,5 +50,1 @@\n-public class EnglishTest extends CollatorTest {\n-\n-    public static void main(String[] args) throws Exception {\n-        new EnglishTest().run(args);\n-    }\n+public class EnglishTest {\n@@ -204,0 +205,1 @@\n+    @Test\n@@ -205,1 +207,1 @@\n-        doTest(myCollation, Collator.PRIMARY,\n+        TestUtils.doCollatorTest(myCollation, Collator.PRIMARY,\n@@ -209,0 +211,1 @@\n+    @Test\n@@ -210,1 +213,1 @@\n-        doTest(myCollation, Collator.SECONDARY,\n+        TestUtils.doCollatorTest(myCollation, Collator.SECONDARY,\n@@ -214,0 +217,1 @@\n+    @Test\n@@ -215,1 +219,1 @@\n-        doTest(myCollation, Collator.TERTIARY,\n+        TestUtils.doCollatorTest(myCollation, Collator.TERTIARY,\n@@ -220,1 +224,1 @@\n-                doTest(myCollation, testData[i], testData[j], -1);\n+                TestUtils.doCollatorTest(myCollation, testData[i], testData[j], -1);\n","filename":"test\/jdk\/java\/text\/Collator\/EnglishTest.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run junit FinnishTest\n@@ -45,2 +46,1 @@\n-\/\/ Quick dummy program for printing out test results\n-public class FinnishTest extends CollatorTest {\n+import org.junit.jupiter.api.Test;\n@@ -48,3 +48,4 @@\n-    public static void main(String[] args) throws Exception {\n-        new FinnishTest().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/\/ Quick dummy program for printing out test results\n+public class FinnishTest {\n@@ -88,0 +89,1 @@\n+    @Test\n@@ -89,1 +91,1 @@\n-        doTest(myCollation, Collator.PRIMARY,\n+        TestUtils.doCollatorTest(myCollation, Collator.PRIMARY,\n@@ -93,0 +95,1 @@\n+    @Test\n@@ -94,1 +97,1 @@\n-        doTest(myCollation, Collator.TERTIARY,\n+        TestUtils.doCollatorTest(myCollation, Collator.TERTIARY,\n","filename":"test\/jdk\/java\/text\/Collator\/FinnishTest.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run junit FrenchTest\n@@ -45,2 +46,1 @@\n-\/\/ Quick dummy program for printing out test results\n-public class FrenchTest extends CollatorTest {\n+import org.junit.jupiter.api.Test;\n@@ -48,3 +48,4 @@\n-    public static void main(String[] args) throws Exception {\n-        new FrenchTest().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/\/ Quick dummy program for printing out test results\n+public class FrenchTest {\n@@ -89,0 +90,1 @@\n+    @Test\n@@ -90,1 +92,1 @@\n-        doTest(myCollation, Collator.TERTIARY,\n+        TestUtils.doCollatorTest(myCollation, Collator.TERTIARY,\n@@ -95,1 +97,1 @@\n-                doTest(myCollation, testData[i], testData[j], -1);\n+                TestUtils.doCollatorTest(myCollation, testData[i], testData[j], -1);\n","filename":"test\/jdk\/java\/text\/Collator\/FrenchTest.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run junit G7Test\n@@ -57,1 +58,1 @@\n-\/\/ G7 test program for printing out test results\n+import org.junit.jupiter.api.Test;\n@@ -59,1 +60,1 @@\n-public class G7Test extends CollatorTest {\n+import static org.junit.jupiter.api.Assertions.fail;\n@@ -61,3 +62,3 @@\n-    public static void main(String[] args) throws Exception {\n-        new G7Test().run(args);\n-    }\n+\/\/ G7 test program for printing out test results\n+\n+public class G7Test {\n@@ -161,0 +162,1 @@\n+    @Test\n@@ -170,1 +172,1 @@\n-                errln(\"Exception: \" + foo.getMessage() +\n+                fail(\"Exception: \" + foo.getMessage() +\n@@ -177,1 +179,1 @@\n-                    doTest(tblColl1, testCases[G7Results[i][j]],\n+                    TestUtils.doCollatorTest(tblColl1, testCases[G7Results[i][j]],\n@@ -188,0 +190,1 @@\n+    @Test\n@@ -199,1 +202,1 @@\n-                    doTest(tblColl, testCases[Test1Results[j]],\n+                    TestUtils.doCollatorTest(tblColl, testCases[Test1Results[j]],\n@@ -205,1 +208,1 @@\n-            errln(\"Exception: \" + foo.getMessage() +\n+            fail(\"Exception: \" + foo.getMessage() +\n@@ -214,0 +217,1 @@\n+    @Test\n@@ -223,1 +227,1 @@\n-                    doTest(tblColl, testCases[Test2Results[j]],\n+                    TestUtils.doCollatorTest(tblColl, testCases[Test2Results[j]],\n@@ -228,1 +232,1 @@\n-            errln(\"Exception: \" + foo.getMessage() +\n+            fail(\"Exception: \" + foo.getMessage() +\n@@ -237,0 +241,1 @@\n+    @Test\n@@ -247,1 +252,1 @@\n-                    doTest(tblColl, testCases[Test3Results[j]],\n+                    TestUtils.doCollatorTest(tblColl, testCases[Test3Results[j]],\n@@ -252,1 +257,1 @@\n-            errln(\"Exception: \" + foo.getMessage() +\n+            fail(\"Exception: \" + foo.getMessage() +\n@@ -261,0 +266,1 @@\n+    @Test\n@@ -271,1 +277,1 @@\n-                    doTest(tblColl, testCases[Test4Results[j]],\n+                    TestUtils.doCollatorTest(tblColl, testCases[Test4Results[j]],\n@@ -276,1 +282,1 @@\n-            errln(\"Exception: \" + foo.getMessage() +\n+            fail(\"Exception: \" + foo.getMessage() +\n","filename":"test\/jdk\/java\/text\/Collator\/G7Test.java","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @run junit GermanTest\n@@ -44,2 +45,1 @@\n-\/\/ Quick dummy program for printing out test results\n-public class GermanTest extends CollatorTest {\n+import org.junit.jupiter.api.Test;\n@@ -47,3 +47,4 @@\n-    public static void main(String[] args) throws Exception {\n-        new GermanTest().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/\/ Quick dummy program for printing out test results\n+public class GermanTest {\n@@ -100,0 +101,1 @@\n+    @Test\n@@ -101,1 +103,1 @@\n-        doTest(myCollation, Collator.PRIMARY,\n+        TestUtils.doCollatorTest(myCollation, Collator.PRIMARY,\n@@ -105,0 +107,1 @@\n+    @Test\n@@ -106,1 +109,1 @@\n-        doTest(myCollation, Collator.TERTIARY,\n+        TestUtils.doCollatorTest(myCollation, Collator.TERTIARY,\n","filename":"test\/jdk\/java\/text\/Collator\/GermanTest.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run junit IteratorTest\n@@ -43,1 +44,5 @@\n-public class IteratorTest extends CollatorTest {\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class IteratorTest {\n@@ -49,4 +54,0 @@\n-    public static void main(String[] args) throws Exception {\n-        new IteratorTest().run(args);\n-    }\n-\n@@ -59,0 +60,1 @@\n+    @Test\n@@ -85,0 +87,1 @@\n+    @Test\n@@ -99,1 +102,1 @@\n-        assertEqual(iter, en_us.getCollationElementIterator(test1));\n+        TestUtils.compareCollationElementIters(iter, en_us.getCollationElementIterator(test1));\n@@ -107,0 +110,1 @@\n+    @Test\n@@ -120,1 +124,1 @@\n-        assertEqual(iter1, iter2);\n+        TestUtils.compareCollationElementIters(iter1, iter2);\n@@ -126,0 +130,1 @@\n+    @Test\n@@ -154,0 +159,1 @@\n+    @Test\n@@ -163,1 +169,1 @@\n-           errln(\"got \" + Integer.toString(e, 16) + \", expected \" +\n+           fail(\"got \" + Integer.toString(e, 16) + \", expected \" +\n@@ -182,1 +188,1 @@\n-                errln(\"Mismatch at index \" + index + \": \"\n+                fail(\"Mismatch at index \" + index + \": \"\n@@ -188,1 +194,1 @@\n-            errln(\"Didn't get back to beginning - index is \" + index);\n+            fail(\"Didn't get back to beginning - index is \" + index);\n@@ -191,1 +197,1 @@\n-            err(\"next: \");\n+            fail(\"next: \");\n@@ -193,1 +199,1 @@\n-                err( Integer.toHexString(o) + \" \");\n+                fail( Integer.toHexString(o) + \" \");\n@@ -195,1 +201,1 @@\n-            errln(\"\");\n+            fail(\"\");\n@@ -197,1 +203,1 @@\n-            err(\"prev: \");\n+            fail(\"prev: \");\n@@ -199,1 +205,1 @@\n-                 err( Integer.toHexString(o) + \" \");\n+                 fail( Integer.toHexString(o) + \" \");\n@@ -201,1 +207,1 @@\n-            errln(\"\");\n+            fail(\"\");\n@@ -229,1 +235,1 @@\n-                errln(\"verifyExpansion: '\" + tests[i][0] +\n+                fail(\"verifyExpansion: '\" + tests[i][0] +\n@@ -237,1 +243,1 @@\n-                errln(\"expansion for '\" + tests[i][0] + \"' is wrong: \" +\n+                fail(\"expansion for '\" + tests[i][0] + \"' is wrong: \" +\n","filename":"test\/jdk\/java\/text\/Collator\/IteratorTest.java","additions":25,"deletions":19,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @run junit MonkeyTest\n@@ -50,5 +51,1 @@\n-public class MonkeyTest extends CollatorTest\n-{\n-    public static void main(String[] args) throws Exception {\n-        new MonkeyTest().run(args);\n-    }\n+import org.junit.jupiter.api.Test;\n@@ -56,0 +53,4 @@\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class MonkeyTest\n+{\n@@ -61,1 +62,1 @@\n-                errln(\" --> Test Failed\");\n+                fail(\" --> Test Failed\");\n@@ -66,1 +67,1 @@\n-                errln(\" --> Test Failed\");\n+                fail(\" --> Test Failed\");\n@@ -71,1 +72,1 @@\n-                errln(\" --> Test Failed\");\n+                fail(\" --> Test Failed\");\n@@ -75,0 +76,1 @@\n+    @Test\n@@ -108,1 +110,1 @@\n-            errln(\"CollationKey(\" + subs + \")\" + \".LT.\" + \"CollationKey(\" + addOne + \") Failed.\");\n+            fail(\"CollationKey(\" + subs + \")\" + \".LT.\" + \"CollationKey(\" + addOne + \") Failed.\");\n@@ -111,1 +113,1 @@\n-            errln(\"CollationKey(\" + addOne + \")\" + \".GT.\" + \"CollationKey(\" + subs + \") Failed.\");\n+            fail(\"CollationKey(\" + addOne + \")\" + \".GT.\" + \"CollationKey(\" + subs + \") Failed.\");\n@@ -118,0 +120,1 @@\n+    @Test\n@@ -143,1 +146,1 @@\n-            errln(\"Test : \" + subs + \" .LT. \" + addOne + \" Failed.\");\n+            fail(\"Test : \" + subs + \" .LT. \" + addOne + \" Failed.\");\n@@ -146,1 +149,1 @@\n-            errln(\"Test : \" + addOne + \" .GE. \" + subs + \" Failed.\");\n+            fail(\"Test : \" + addOne + \" .GE. \" + subs + \" Failed.\");\n","filename":"test\/jdk\/java\/text\/Collator\/MonkeyTest.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @run junit Regression\n@@ -50,0 +51,1 @@\n+import org.junit.jupiter.api.Test;\n@@ -51,1 +53,1 @@\n-public class Regression extends CollatorTest {\n+import static org.junit.jupiter.api.Assertions.fail;\n@@ -53,3 +55,2 @@\n-    public static void main(String[] args) throws Exception {\n-        new Regression().run(args);\n-    }\n+\n+public class Regression {\n@@ -59,0 +60,1 @@\n+    @Test\n@@ -67,1 +69,1 @@\n-        assertEqual(i1, i2);\n+        TestUtils.compareCollationElementIters(i1, i2);\n@@ -73,0 +75,1 @@\n+    @Test\n@@ -87,1 +90,1 @@\n-            errln(\"Rules are not equal\");\n+            fail(\"Rules are not equal\");\n@@ -93,0 +96,1 @@\n+    @Test\n@@ -95,1 +99,1 @@\n-            errln(\"black-bird == black\");\n+            fail(\"black-bird == black\");\n@@ -103,0 +107,1 @@\n+    @Test\n@@ -114,1 +119,1 @@\n-        assertEqual(i1, i2);\n+        TestUtils.compareCollationElementIters(i1, i2);\n@@ -119,0 +124,1 @@\n+    @Test\n@@ -125,1 +131,1 @@\n-            errln(\"Caught \" + e.toString() + \" setting Collator.IDENTICAL\");\n+            fail(\"Caught \" + e.toString() + \" setting Collator.IDENTICAL\");\n@@ -146,0 +152,1 @@\n+    @Test\n@@ -159,0 +166,1 @@\n+    @Test\n@@ -172,1 +180,1 @@\n-              errln(\"Decomposition is not set to NO_DECOMPOSITION\");\n+              fail(\"Decomposition is not set to NO_DECOMPOSITION\");\n@@ -183,0 +191,1 @@\n+    @Test\n@@ -188,1 +197,1 @@\n-            errln(\"Exception building collator: \" + e.toString());\n+            fail(\"Exception building collator: \" + e.toString());\n@@ -192,1 +201,1 @@\n-            errln(\"returned rules do not contain 'c\/a'\");\n+            fail(\"returned rules do not contain 'c\/a'\");\n@@ -198,0 +207,1 @@\n+    @Test\n@@ -204,1 +214,1 @@\n-            errln(\"Exception building collator: \" + e.toString());\n+            fail(\"Exception building collator: \" + e.toString());\n@@ -230,0 +240,1 @@\n+    @Test\n@@ -243,0 +254,1 @@\n+    @Test\n@@ -245,1 +257,1 @@\n-            errln(\"'abcd e' == 'abcd f'\");\n+            fail(\"'abcd e' == 'abcd f'\");\n@@ -253,0 +265,1 @@\n+    @Test\n@@ -265,1 +278,1 @@\n-        assertEqual(i1, i2);\n+        TestUtils.compareCollationElementIters(i1, i2);\n@@ -270,0 +283,1 @@\n+    @Test\n@@ -284,0 +298,1 @@\n+    @Test\n@@ -294,1 +309,1 @@\n-            errln(\"Same-class combining chars were reordered\");\n+            fail(\"Same-class combining chars were reordered\");\n@@ -301,0 +316,1 @@\n+    @Test\n@@ -304,1 +320,1 @@\n-                errln(\"en_us.equals(null) returned true\");\n+                fail(\"en_us.equals(null) returned true\");\n@@ -308,1 +324,1 @@\n-            errln(\"en_us.equals(null) threw \" + e.toString());\n+            fail(\"en_us.equals(null) threw \" + e.toString());\n@@ -314,0 +330,1 @@\n+    @Test\n@@ -320,1 +337,1 @@\n-            errln(\"Compare(a,bb) returned \" + result + \"; expected -1\");\n+            fail(\"Compare(a,bb) returned \" + result + \"; expected -1\");\n@@ -326,0 +343,1 @@\n+    @Test\n@@ -341,1 +359,1 @@\n-            errln(\"Combining chars were not reordered\");\n+            fail(\"Combining chars were not reordered\");\n@@ -347,0 +365,1 @@\n+    @Test\n@@ -363,0 +382,1 @@\n+    @Test\n@@ -377,0 +397,1 @@\n+    @Test\n@@ -404,0 +425,1 @@\n+    @Test\n@@ -411,1 +433,1 @@\n-                errln(\"next did not return NULLORDER\");\n+                fail(\"next did not return NULLORDER\");\n@@ -415,1 +437,1 @@\n-            errln(\"Caught \" + e );\n+            fail(\"Caught \" + e );\n@@ -421,0 +443,1 @@\n+    @Test\n@@ -435,0 +458,1 @@\n+    @Test\n@@ -460,0 +484,1 @@\n+    @Test\n@@ -466,1 +491,1 @@\n-            errln(\"Ran out of memory -- probably an infinite loop\");\n+            fail(\"Ran out of memory -- probably an infinite loop\");\n@@ -472,0 +497,1 @@\n+    @Test\n@@ -484,0 +510,1 @@\n+    @Test\n@@ -495,0 +522,1 @@\n+    @Test\n@@ -522,0 +550,1 @@\n+    @Test\n@@ -534,1 +563,1 @@\n-                errln(\"Caught \" + e + \" creating collator for \" + locales[i]);\n+                fail(\"Caught \" + e + \" creating collator for \" + locales[i]);\n@@ -542,0 +571,1 @@\n+    @Test\n@@ -556,0 +586,1 @@\n+    @Test\n@@ -564,1 +595,1 @@\n-            errln(\"getCollationElementIterator not called\");\n+            fail(\"getCollationElementIterator not called\");\n@@ -570,1 +601,1 @@\n-            errln(\"getCollationElementIterator not called\");\n+            fail(\"getCollationElementIterator not called\");\n@@ -595,0 +626,1 @@\n+    @Test\n@@ -620,1 +652,1 @@\n-                errln(\"Mismatch at index \" + index\n+                fail(\"Mismatch at index \" + index\n@@ -628,0 +660,1 @@\n+    @Test\n@@ -647,1 +680,1 @@\n-                errln(\"error: \\\"\" + testStrings[i - 1]\n+                fail(\"error: \\\"\" + testStrings[i - 1]\n@@ -654,0 +687,1 @@\n+    @Test\n@@ -676,1 +710,1 @@\n-            errln(\"The collation elements at positions 0 (\" + elt0 + \"), 4 (\"\n+            fail(\"The collation elements at positions 0 (\" + elt0 + \"), 4 (\"\n@@ -700,1 +734,1 @@\n-            errln(\"\\\"cat\\\" elements don't match: elt14 = \" + elt14 + \", elt15 = \"\n+            fail(\"\\\"cat\\\" elements don't match: elt14 = \" + elt14 + \", elt15 = \"\n@@ -738,1 +772,1 @@\n-                logln(nextElements[i]);\n+                System.out.println(nextElements[i]);\n@@ -740,1 +774,1 @@\n-                errln(\"Error: next() yielded \" + nextElements[i] + \", but setOffset() yielded \"\n+                fail(\"Error: next() yielded \" + nextElements[i] + \", but setOffset() yielded \"\n@@ -746,0 +780,1 @@\n+    @Test\n@@ -772,0 +807,1 @@\n+    @Test\n@@ -803,1 +839,1 @@\n-        logln(\"Testing French order...\");\n+        System.out.println(\"Testing French order...\");\n@@ -806,1 +842,1 @@\n-        logln(\"Testing French order without decomposition...\");\n+        System.out.println(\"Testing French order without decomposition...\");\n@@ -839,1 +875,1 @@\n-        logln(\"Testing English order...\");\n+        System.out.println(\"Testing English order...\");\n@@ -842,1 +878,1 @@\n-        logln(\"Testing English order without decomposition...\");\n+        System.out.println(\"Testing English order without decomposition...\");\n@@ -852,3 +888,3 @@\n-                errln(\"List out of order at element #\" + i + \": \"\n-                        + prettify(sortedList[i]) + \" >= \"\n-                        + prettify(sortedList[i + 1]));\n+                fail(\"List out of order at element #\" + i + \": \"\n+                        + TestUtils.prettify(sortedList[i]) + \" >= \"\n+                        + TestUtils.prettify(sortedList[i + 1]));\n@@ -860,0 +896,1 @@\n+    @Test\n@@ -866,1 +903,1 @@\n-        logln(\"calling next:\");\n+        System.out.println(\"calling next:\");\n@@ -868,1 +905,1 @@\n-            logln(\"[\" + i + \"] \" + (elements_next[i] = iter.next()));\n+            System.out.println(\"[\" + i + \"] \" + (elements_next[i] = iter.next()));\n@@ -872,1 +909,1 @@\n-        logln(\"calling set\/next:\");\n+        System.out.println(\"calling set\/next:\");\n@@ -875,1 +912,1 @@\n-            logln(\"[\" + i + \"] \" + (elements_fwd[i] = iter.next()));\n+            System.out.println(\"[\" + i + \"] \" + (elements_fwd[i] = iter.next()));\n@@ -880,1 +917,1 @@\n-                errln(\"mismatch at position \" + i +\n+                fail(\"mismatch at position \" + i +\n@@ -907,2 +944,2 @@\n-                errln( i\/3 + \": compare(\" + prettify(tests[i])\n-                                    + \" , \" + prettify(tests[i+2])\n+                fail( i\/3 + \": compare(\" + TestUtils.prettify(tests[i])\n+                                    + \" , \" + TestUtils.prettify(tests[i+2])\n@@ -919,2 +956,2 @@\n-                    errln( i\/3 + \": key(\" + prettify(tests[i])\n-                                        + \").compareTo(key(\" + prettify(tests[i+2])\n+                    fail( i\/3 + \": key(\" + TestUtils.prettify(tests[i])\n+                                        + \").compareTo(key(\" + TestUtils.prettify(tests[i+2])\n@@ -923,1 +960,1 @@\n-                    errln(\"  \" + prettify(k1) + \" vs. \" + prettify(k2));\n+                    fail(\"  \" + TestUtils.prettifyCKey(k1) + \" vs. \" + TestUtils.prettifyCKey(k2));\n","filename":"test\/jdk\/java\/text\/Collator\/Regression.java","additions":87,"deletions":50,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @run junit SpanishTest\n@@ -44,2 +45,1 @@\n-\/\/ Quick dummy program for printing out test results\n-public class SpanishTest extends CollatorTest {\n+import org.junit.jupiter.api.Test;\n@@ -47,3 +47,4 @@\n-    public static void main(String[] args) throws Exception {\n-        new SpanishTest().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/\/ Quick dummy program for printing out test results\n+public class SpanishTest {\n@@ -95,0 +96,1 @@\n+    @Test\n@@ -96,1 +98,1 @@\n-        doTest(myCollation, Collator.PRIMARY,\n+        TestUtils.doCollatorTest(myCollation, Collator.PRIMARY,\n@@ -100,0 +102,1 @@\n+    @Test\n@@ -101,1 +104,1 @@\n-        doTest(myCollation, Collator.TERTIARY,\n+        TestUtils.doCollatorTest(myCollation, Collator.TERTIARY,\n","filename":"test\/jdk\/java\/text\/Collator\/SpanishTest.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @run junit SurrogatesTest\n@@ -33,2 +34,1 @@\n-\/\/ Quick dummy program for printing out test results\n-public class SurrogatesTest extends CollatorTest {\n+import org.junit.jupiter.api.Test;\n@@ -36,3 +36,4 @@\n-    public static void main(String[] args) throws Exception {\n-        new SurrogatesTest().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/\/ Quick dummy program for printing out test results\n+public class SurrogatesTest {\n@@ -86,0 +87,1 @@\n+    @Test\n@@ -87,1 +89,1 @@\n-        doTest(myCollation, Collator.PRIMARY,\n+        TestUtils.doCollatorTest(myCollation, Collator.PRIMARY,\n@@ -91,0 +93,1 @@\n+    @Test\n@@ -92,1 +95,1 @@\n-        doTest(myCollation, Collator.TERTIARY,\n+        TestUtils.doCollatorTest(myCollation, Collator.TERTIARY,\n@@ -111,1 +114,1 @@\n-            errln(\"Failed to create new RulebasedCollator object\");\n+            fail(\"Failed to create new RulebasedCollator object\");\n","filename":"test\/jdk\/java\/text\/Collator\/SurrogatesTest.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @run junit Test4401726\n@@ -37,1 +38,1 @@\n-public class Test4401726 extends CollatorTest {\n+import org.junit.jupiter.api.Test;\n@@ -39,3 +40,3 @@\n-    public static void main(String[] args) throws Exception {\n-        new Test4401726().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class Test4401726 {\n@@ -43,0 +44,1 @@\n+    @Test\n@@ -63,1 +65,1 @@\n-                errln(\"Failed.\");\n+                fail(\"Failed.\");\n@@ -75,1 +77,1 @@\n-                errln(\"Failed.\");\n+                fail(\"Failed.\");\n@@ -79,1 +81,1 @@\n-            errln(\"Unexpected ParseException: \" + e);\n+            fail(\"Unexpected ParseException: \" + e);\n","filename":"test\/jdk\/java\/text\/Collator\/Test4401726.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run junit ThaiTest\n@@ -42,1 +43,1 @@\n-public class ThaiTest extends CollatorTest {\n+import org.junit.jupiter.api.Test;\n@@ -44,3 +45,3 @@\n-    public static void main(String[] args) throws Exception {\n-        new ThaiTest().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class ThaiTest {\n@@ -151,0 +152,1 @@\n+    @Test\n@@ -152,1 +154,1 @@\n-        doTest(myCollation, Collator.PRIMARY,\n+        TestUtils.doCollatorTest(myCollation, Collator.PRIMARY,\n","filename":"test\/jdk\/java\/text\/Collator\/ThaiTest.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run junit TurkishTest\n@@ -45,2 +46,1 @@\n-\/\/ Quick dummy program for printing out test results\n-public class TurkishTest extends CollatorTest {\n+import org.junit.jupiter.api.Test;\n@@ -48,3 +48,4 @@\n-    public static void main(String[] args) throws Exception {\n-        new TurkishTest().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/\/ Quick dummy program for printing out test results\n+public class TurkishTest {\n@@ -108,0 +109,1 @@\n+    @Test\n@@ -109,1 +111,1 @@\n-        doTest(myCollation, Collator.PRIMARY,\n+        TestUtils.doCollatorTest(myCollation, Collator.PRIMARY,\n@@ -113,0 +115,1 @@\n+    @Test\n@@ -114,1 +117,1 @@\n-        doTest(myCollation, Collator.TERTIARY,\n+        TestUtils.doCollatorTest(myCollation, Collator.TERTIARY,\n","filename":"test\/jdk\/java\/text\/Collator\/TurkishTest.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @run junit VietnameseTest\n@@ -47,2 +48,1 @@\n-\/\/ Quick dummy program for printing out test results\n-public class VietnameseTest extends CollatorTest {\n+import org.junit.jupiter.api.Test;\n@@ -50,3 +50,4 @@\n-    public static void main(String[] args) throws Exception {\n-        new VietnameseTest().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/\/ Quick dummy program for printing out test results\n+public class VietnameseTest {\n@@ -349,0 +350,1 @@\n+    @Test\n@@ -350,1 +352,1 @@\n-        doTest(myCollation, Collator.PRIMARY, testPS, testPT, testPR);\n+        TestUtils.doCollatorTest(myCollation, Collator.PRIMARY, testPS, testPT, testPR);\n@@ -353,0 +355,1 @@\n+    @Test\n@@ -359,1 +362,1 @@\n-                doTest(myCollation, testT[i], testT[j], -1);\n+                TestUtils.doCollatorTest(myCollation, testT[i], testT[j], -1);\n","filename":"test\/jdk\/java\/text\/Collator\/VietnameseTest.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,8 +24,0 @@\n-\/*\n- * @test\n- * @bug 4185732\n- * @library \/java\/text\/testlib\n- * @build Bug4185732Test IntlTest HexDumpReader\n- * @run main Bug4185732Test\n- * @summary test that ChoiceFormat invariants are preserved across serialization\n- *\/\n@@ -66,2 +58,12 @@\n-import java.util.*;\n-import java.io.*;\n+\/*\n+ * @test\n+ * @bug 4185732\n+ * @library \/java\/text\/testlib\n+ * @build HexDumpReader\n+ * @summary Test that ChoiceFormat invariants are preserved across serialization.\n+ *          This test depends on Bug4185732.ser.txt and will fail otherwise.\n+ * @run junit Bug4185732Test\n+ *\/\n+\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n@@ -70,11 +72,1 @@\n-\/**\n- *  A Locale can never contains language codes of he, yi or id.\n- *\/\n-public class Bug4185732Test extends IntlTest {\n-    public static void main(String[] args) throws Exception {\n-        if (args.length == 1 && args[0].equals(\"prepTest\")) {\n-            prepTest();\n-        } else {\n-            new Bug4185732Test().run(args);\n-        }\n-    }\n+import org.junit.jupiter.api.Test;\n@@ -82,1 +74,11 @@\n-    public void testIt() throws Exception {\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class Bug4185732Test {\n+\n+    \/*\n+     * The ChoiceFormat class requires that its choiceFormats and choiceLimits\n+     * arrays have the same length. This test ensures that the invariant is enforced\n+     * during the readObject() call.\n+     *\/\n+    @Test\n+    public void choiceFormatSerializationInvariantsTest() {\n@@ -84,0 +86,1 @@\n+            \/\/ A serialized ChoiceFormat with unequal formats and limits\n@@ -88,1 +91,1 @@\n-                errln(\"ChoiceFormat did not properly check stream\");\n+                fail(\"ChoiceFormat did not properly check stream\");\n@@ -90,4 +93,4 @@\n-                \/\/for some reason, the data file was VALID.  This test\n-                \/\/requires a corrupt data file the format and limit\n-                \/\/arrays are of different length.\n-                errln(\"Test data file was not properly created\");\n+                \/\/ for some reason, the data file was VALID.  This test\n+                \/\/ requires a corrupt data file the format and limit\n+                \/\/ arrays are of different length.\n+                fail(\"Test data file was not properly created\");\n@@ -95,23 +98,4 @@\n-        } catch (InvalidObjectException e) {\n-            \/\/this is what we want to have happen\n-        } catch (Exception e) {\n-            errln(e.toString());\n-        }\n-    }\n-\n-    \/**\n-     * Create a data file for this test.  The data file must be corrupted by hand.\n-     *\/\n-    private static void prepTest() {\n-        try {\n-            ObjectOutputStream out = new ObjectOutputStream(\n-                    new FileOutputStream(\"Bug4185732.ser\"));\n-            final double[] limits = {1,2,3,4,5,6,7};\n-            final String[] formats = {\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thur\",\"Fri\",\"Sat\"};\n-            final ChoiceFormat fmt = new ChoiceFormat(limits, formats);\n-            out.writeObject(fmt);\n-            out.close();\n-            System.out.println(\"You must invalidate the output file before running the test\");\n-            System.out.println(\"by modifying the length of one of the array\");\n-        } catch (Exception e) {\n-            System.out.println(e);\n+        } catch (InvalidObjectException expectedException) {\n+            \/\/ Expecting an IOE\n+        } catch (Exception wrongException) {\n+            fail(\"Expected an InvalidObjectException, instead got: \" + wrongException);\n","filename":"test\/jdk\/java\/text\/Format\/ChoiceFormat\/Bug4185732Test.java","additions":35,"deletions":51,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -28,0 +28,2 @@\n+ *          (previously capped at 30).\n+ * @run junit Bug4387255\n@@ -32,1 +34,7 @@\n-public class Bug4387255 {\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n@@ -34,0 +42,1 @@\n+public class Bug4387255 {\n@@ -52,8 +61,2 @@\n-    public static void main(String[] args) throws Exception {\n-        ChoiceFormat choiceFormat1 = new ChoiceFormat(doubles, strings);\n-        ChoiceFormat choiceFormat2 = new ChoiceFormat(pattern);\n-        if (!choiceFormat1.equals(choiceFormat2)) {\n-            System.out.println(\"choiceFormat1: \" + choiceFormat1.toPattern());\n-            System.out.println(\"choiceFormat2: \" + choiceFormat2.toPattern());\n-            throw new RuntimeException();\n-        }\n+    private static final ChoiceFormat choiceFormat1 = new ChoiceFormat(doubles, strings);\n+    private static final ChoiceFormat choiceFormat2 = new ChoiceFormat(pattern);\n@@ -61,0 +64,16 @@\n+    \/\/ Ensure that both the large ChoiceFormats format each value properly\n+    @ParameterizedTest\n+    @MethodSource\n+    public void largeChoicesTest(double db, String expectedString) {\n+        String result = choiceFormat2.format(db);\n+        assertEquals(expectedString, result,\n+                \"Wrong format result with: \" + choiceFormat2);\n+    }\n+\n+\n+    \/*\n+     * Create arguments in form of : (double, string)\n+     * Each string is the expected result of ChoiceFormat.format(double)\n+     *\/\n+    private static Arguments[] largeChoicesTest() {\n+        Arguments[] doublesAndStrings = new Arguments[doubles.length];\n@@ -62,5 +81,1 @@\n-            String result = choiceFormat2.format(doubles[i]);\n-            if (!result.equals(strings[i])) {\n-                throw new RuntimeException(\"Wrong format result - expected \" +\n-                        strings[i] + \", got \" + result);\n-            }\n+            doublesAndStrings[i] = arguments(doubles[i], strings[i]);\n@@ -68,0 +83,12 @@\n+        return doublesAndStrings;\n+    }\n+\n+    \/*\n+     * Check that creating a ChoiceFormat with limits and formats arrays\n+     * equivalent to a string pattern are equal. (Checks that both constructors\n+     * allow for a large number of choices and formats)\n+     *\/\n+    @Test\n+    public void patternEqualsArraysTest() {\n+        assertEquals(choiceFormat1, choiceFormat2, \"Pattern is equivalent to \" +\n+                \"formats and limits, but ChoiceFormats are not equal\");\n","filename":"test\/jdk\/java\/text\/Format\/ChoiceFormat\/Bug4387255.java","additions":43,"deletions":16,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -28,0 +28,1 @@\n+ * @run junit Bug8001209\n@@ -29,1 +30,8 @@\n-import java.text.*;\n+\n+import java.text.ChoiceFormat;\n+import java.text.ParsePosition;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -33,2 +41,5 @@\n-    public static void main(String[] args) throws Exception {\n-        boolean err = false;\n+    \/\/ Represents the expected output of formatting the ChoiceFormat\n+    private static String expectedFormattedOutput;\n+    private static ChoiceFormat cFmt;\n+    private static ParsePosition status;\n+    private static String[] originalSetterArray;\n@@ -36,5 +47,8 @@\n-        \/\/ Borrow an example in API doc\n-        double[] limits = {1,2,3,4,5,6,7};\n-        String[] dayOfWeekNames = {\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\"};\n-        ChoiceFormat form = new ChoiceFormat(limits, dayOfWeekNames);\n-        ParsePosition status = new ParsePosition(0);\n+    \/\/ Build the original ChoiceFormat to test if it can be mutated\n+    @BeforeAll\n+    static void setUpChoiceFormatAndOutput() {\n+        double[] limits = {1, 2, 3, 4, 5, 6, 7};\n+        originalSetterArray = new String[]{\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"};\n+        \/\/ Constructor calls setChoices\n+        cFmt = new ChoiceFormat(limits, originalSetterArray);\n+        status = new ParsePosition(0);\n@@ -42,0 +56,1 @@\n+        \/\/ Build the expected results of formatting with the original ChoiceFormat\n@@ -45,1 +60,1 @@\n-            String s = form.format(i);\n+            String s = cFmt.format(i);\n@@ -48,1 +63,1 @@\n-            before.append(form.parse(form.format(i),status));\n+            before.append(cFmt.parse(cFmt.format(i), status));\n@@ -50,1 +65,2 @@\n-        String original = before.toString();\n+        expectedFormattedOutput = before.toString();\n+    }\n@@ -52,2 +68,8 @@\n-        double[] newLimits = form.getLimits();\n-        String[] newFormats = (String[])form.getFormats();\n+    \/*\n+     * Ensure that mutating the arrays returned by getChoices and getLimits does\n+     * not affect the internal representation of the ChoiceFormat.\n+     *\/\n+    @Test\n+    public void immutableArraysFromGetters() {\n+        \/\/ Modify the array returned by getFormats() -> newFormats\n+        String[] newFormats = (String[]) cFmt.getFormats();\n@@ -58,1 +80,1 @@\n-            String s = form.format(i);\n+            String s = cFmt.format(i);\n@@ -61,6 +83,1 @@\n-            after.append(form.parse(form.format(i),status));\n-        }\n-        if (!original.equals(after.toString())) {\n-            err = true;\n-            System.err.println(\"  Expected:\" + before\n-                               + \"\\n  Got:     \" + after);\n+            after.append(cFmt.parse(cFmt.format(i), status));\n@@ -68,0 +85,4 @@\n+        \/\/ Compare the expected results with the new formatted results\n+        assertEquals(after.toString(), expectedFormattedOutput,\n+                \"Mutating array returned from getter changed internals of ChoiceFormat\");\n+    }\n@@ -69,2 +90,9 @@\n-        dayOfWeekNames[6] = \"Saturday\";\n-        after = new StringBuilder();\n+    \/*\n+     * Ensure that mutating the arrays passed to setChoices\/constructor does\n+     * not affect the internal representation of the ChoiceFormat.\n+     *\/\n+    @Test\n+    public void immutableArraysFromSetter() {\n+        \/\/ Modify the array passed to setFormats() -> dayOfWeekNames\n+        originalSetterArray[6] = \"Saturday\";\n+        StringBuilder after = new StringBuilder();\n@@ -73,1 +101,1 @@\n-            String s = form.format(i);\n+            String s = cFmt.format(i);\n@@ -76,12 +104,1 @@\n-            after.append(form.parse(form.format(i),status));\n-        }\n-        if (!original.equals(after.toString())) {\n-            err = true;\n-            System.err.println(\"  Expected:\" + before\n-                               + \"\\n  Got:     \" + after);\n-        }\n-\n-        if (err) {\n-            throw new RuntimeException(\"Failed.\");\n-        } else {\n-            System.out.println(\"Passed.\");\n+            after.append(cFmt.parse(cFmt.format(i), status));\n@@ -89,0 +106,3 @@\n+        \/\/ Compare the expected results with the new formatted results\n+        assertEquals(after.toString(), expectedFormattedOutput,\n+                \"Mutating array passed to setter changed internals of ChoiceFormat\");\n","filename":"test\/jdk\/java\/text\/Format\/ChoiceFormat\/Bug8001209.java","additions":57,"deletions":37,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @library \/java\/text\/testlib\n@@ -30,0 +29,1 @@\n+ * @run junit Bug4322313\n@@ -36,1 +36,1 @@\n-public class Bug4322313 extends IntlTest {\n+import org.junit.jupiter.api.Test;\n@@ -38,0 +38,5 @@\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class Bug4322313 {\n+\n+    @Test\n@@ -203,1 +208,1 @@\n-                            logln(\"\\tParse  Okay  [Locale=\" +\n+                            System.out.println(\"\\tParse  Okay  [Locale=\" +\n@@ -255,1 +260,1 @@\n-                                logln(\"\\tFormat Okay  [Locale=\" +\n+                                System.out.println(\"\\tFormat Okay  [Locale=\" +\n@@ -289,1 +294,1 @@\n-                                logln(\"\\tParse  Okay  [Locale=\" +\n+                                System.out.println(\"\\tParse  Okay  [Locale=\" +\n@@ -325,1 +330,1 @@\n-                                logln(\"\\tParse  Okay  [Locale=\" +\n+                                System.out.println(\"\\tParse  Okay  [Locale=\" +\n@@ -357,1 +362,1 @@\n-                errln(\"SimpleDateFormat.parse()\/format() test failed\");\n+                fail(\"SimpleDateFormat.parse()\/format() test failed\");\n@@ -362,3 +367,0 @@\n-    public static void main(String[] args) throws Exception {\n-        new Bug4322313().run(args);\n-    }\n","filename":"test\/jdk\/java\/text\/Format\/DateFormat\/Bug4322313.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n@@ -35,1 +39,1 @@\n- * @run main\/othervm -Djava.locale.providers=COMPAT,SPI DateFormatRegression\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT,SPI DateFormatRegression\n@@ -37,5 +41,1 @@\n-public class DateFormatRegression extends IntlTest {\n-\n-    public static void main(String[] args) throws Exception {\n-        new DateFormatRegression().run(args);\n-    }\n+public class DateFormatRegression {\n@@ -43,0 +43,1 @@\n+    @Test\n@@ -47,1 +48,1 @@\n-        logln(\"today: \" + today);\n+        System.out.println(\"today: \" + today);\n@@ -50,2 +51,2 @@\n-        logln(\"pattern: \" + sdf.toPattern());\n-        logln(\"today: \" + sdf.format(today));\n+        System.out.println(\"pattern: \" + sdf.toPattern());\n+        System.out.println(\"today: \" + sdf.format(today));\n@@ -55,1 +56,1 @@\n-        logln(\"today: \" + todayS);\n+        System.out.println(\"today: \" + todayS);\n@@ -58,1 +59,1 @@\n-            logln(\"today date: \" + today);\n+            System.out.println(\"today date: \" + today);\n@@ -60,1 +61,1 @@\n-            logln(\"Error reparsing date: \" + e.getMessage());\n+            System.out.println(\"Error reparsing date: \" + e.getMessage());\n@@ -65,2 +66,2 @@\n-            logln(\"round trip: \" + rt);\n-            if (!rt.equals(todayS)) errln(\"Fail: Want \" + todayS + \" Got \" + rt);\n+            System.out.println(\"round trip: \" + rt);\n+            if (!rt.equals(todayS)) fail(\"Fail: Want \" + todayS + \" Got \" + rt);\n@@ -69,1 +70,1 @@\n-            errln(\"Fail: \" + e);\n+            fail(\"Fail: \" + e);\n@@ -74,0 +75,1 @@\n+    @Test\n@@ -80,1 +82,1 @@\n-        logln(str = fmt.format(date));\n+        System.out.println(str = fmt.format(date));\n@@ -83,1 +85,1 @@\n-            errln(\"Fail: Test broken; Want 5\/3\/97 8:55 AM Got \" + str);\n+            fail(\"Fail: Test broken; Want 5\/3\/97 8:55 AM Got \" + str);\n@@ -120,1 +122,1 @@\n-            log(i + \": \" + fieldNames[i] +\n+            System.out.println(i + \": \" + fieldNames[i] +\n@@ -127,1 +129,1 @@\n-                logln(\" ok\");\n+                System.out.println(\" ok\");\n@@ -129,1 +131,1 @@\n-                logln(\" expected \" + exp);\n+                System.out.println(\" expected \" + exp);\n@@ -133,1 +135,1 @@\n-        if (!pass) errln(\"Fail: FieldPosition not set right by DateFormat\");\n+        if (!pass) fail(\"Fail: FieldPosition not set right by DateFormat\");\n@@ -140,0 +142,1 @@\n+    @Test\n@@ -146,1 +149,1 @@\n-                errln(\"get2DigitYearStart broken\");\n+                fail(\"get2DigitYearStart broken\");\n@@ -157,2 +160,2 @@\n-                logln(s + \" -> \" + got + \"; exp \" + exp);\n-                if (!got.equals(exp)) errln(\"set2DigitYearStart broken\");\n+                System.out.println(s + \" -> \" + got + \"; exp \" + exp);\n+                if (!got.equals(exp)) fail(\"set2DigitYearStart broken\");\n@@ -162,1 +165,1 @@\n-            errln(\"Fail: \" + e);\n+            fail(\"Fail: \" + e);\n@@ -167,0 +170,1 @@\n+    @Test\n@@ -170,1 +174,1 @@\n-            logln(\"Skipping this test because locale is \" + locale);\n+            System.out.println(\"Skipping this test because locale is \" + locale);\n@@ -188,2 +192,2 @@\n-            logln( \"==================\" );\n-            logln( \"testIt: pattern=\" + fmt.toPattern() +\n+            System.out.println( \"==================\" );\n+            System.out.println( \"testIt: pattern=\" + fmt.toPattern() +\n@@ -194,1 +198,1 @@\n-            logln( \"Parsed object: \" + o );\n+            System.out.println( \"Parsed object: \" + o );\n@@ -197,2 +201,2 @@\n-            logln( \"Formatted string: \" + formatted );\n-            if (!formatted.equals(str)) errln(\"Fail: Want \" + str + \" Got \" + formatted);\n+            System.out.println( \"Formatted string: \" + formatted );\n+            if (!formatted.equals(str)) fail(\"Fail: Want \" + str + \" Got \" + formatted);\n@@ -201,1 +205,1 @@\n-            errln(\"Fail: \" + e);\n+            fail(\"Fail: \" + e);\n@@ -206,0 +210,1 @@\n+    @Test\n@@ -212,2 +217,2 @@\n-        logln( \"dateString= \" + dateString );\n-        logln(\"Using yyyy-DDD.hh:mm:ss\");\n+        System.out.println( \"dateString= \" + dateString );\n+        System.out.println(\"Using yyyy-DDD.hh:mm:ss\");\n@@ -219,1 +224,1 @@\n-        logln( myString );\n+        System.out.println( myString );\n@@ -223,1 +228,1 @@\n-            errln(\"Fail: Got \" + cal.get(Calendar.DAY_OF_YEAR) +\n+            fail(\"Fail: Got \" + cal.get(Calendar.DAY_OF_YEAR) +\n@@ -226,1 +231,1 @@\n-        logln(\"Using yyyy-ddd.hh:mm:ss\");\n+        System.out.println(\"Using yyyy-ddd.hh:mm:ss\");\n@@ -232,1 +237,1 @@\n-        logln( myString );\n+        System.out.println( myString );\n@@ -235,1 +240,1 @@\n-            errln(\"Fail: Got \" + cal.get(Calendar.DAY_OF_YEAR) +\n+            fail(\"Fail: Got \" + cal.get(Calendar.DAY_OF_YEAR) +\n@@ -243,0 +248,1 @@\n+    @Test\n@@ -246,1 +252,1 @@\n-            logln(df.parse(\"35\/01\/1971\").toString());\n+            System.out.println(df.parse(\"35\/01\/1971\").toString());\n@@ -249,1 +255,1 @@\n-            errln(\"Fail: \" + e);\n+            fail(\"Fail: \" + e);\n@@ -255,1 +261,1 @@\n-            logln(df.parse(\"35\/01\/1971\").toString());\n+            System.out.println(df.parse(\"35\/01\/1971\").toString());\n@@ -257,1 +263,1 @@\n-        if (!ok) errln(\"Fail: Lenient not working\");\n+        if (!ok) fail(\"Fail: Lenient not working\");\n@@ -261,0 +267,1 @@\n+    @Test\n@@ -279,2 +286,2 @@\n-            logln(strShortDate);\n-            logln(strFullDate);\n+            System.out.println(strShortDate);\n+            System.out.println(strFullDate);\n@@ -285,1 +292,1 @@\n-                errln(\"Fail: Want GMT-05:00\");\n+                fail(\"Fail: Want GMT-05:00\");\n@@ -304,0 +311,1 @@\n+    @Test\n@@ -314,1 +322,1 @@\n-            errln(\"Fail: Can't complete test; Calendar instances unequal\");\n+            fail(\"Fail: Can't complete test; Calendar instances unequal\");\n@@ -316,1 +324,1 @@\n-            errln(\"Fail: DateFormat unequal when Calendars equal\");\n+            fail(\"Fail: DateFormat unequal when Calendars equal\");\n@@ -319,1 +327,1 @@\n-            errln(\"Fail: Can't complete test; Calendar instances equal\");\n+            fail(\"Fail: Can't complete test; Calendar instances equal\");\n@@ -321,2 +329,2 @@\n-            errln(\"Fail: DateFormat unequal when Calendars equivalent\");\n-        logln(\"DateFormat.equals ok\");\n+            fail(\"Fail: DateFormat unequal when Calendars equivalent\");\n+        System.out.println(\"DateFormat.equals ok\");\n@@ -335,0 +343,1 @@\n+    @Test\n@@ -345,1 +354,1 @@\n-                    errln(\"Fail: \" + d + \" != \" + dd);\n+                    fail(\"Fail: \" + d + \" != \" + dd);\n@@ -347,2 +356,2 @@\n-                    errln(\"Fail: \" + s + \" != \" + ss);\n-                logln(\"Ok: \" + s + \" \" + d);\n+                    fail(\"Fail: \" + s + \" != \" + ss);\n+                System.out.println(\"Ok: \" + s + \" \" + d);\n@@ -352,1 +361,1 @@\n-            errln(\"Fail: \" + e);\n+            fail(\"Fail: \" + e);\n@@ -357,0 +366,1 @@\n+    @Test\n@@ -364,1 +374,1 @@\n-                errln(\"Fail: SimpleDateFormat should use TimeZone.getDefault()\");\n+                fail(\"Fail: SimpleDateFormat should use TimeZone.getDefault()\");\n@@ -371,0 +381,1 @@\n+    @Test\n@@ -417,1 +428,1 @@\n-                    logln(\"DateFormat instance for locale \" +\n+                    System.out.println(\"DateFormat instance for locale \" +\n@@ -420,1 +431,1 @@\n-                    logln(\"DateFormat instance for locale \" +\n+                    System.out.println(\"DateFormat instance for locale \" +\n@@ -424,1 +435,1 @@\n-            if (!pass) errln(\"Fail: DateFormat serialization\/equality bug\");\n+            if (!pass) fail(\"Fail: DateFormat serialization\/equality bug\");\n@@ -427,1 +438,1 @@\n-            errln(\"Fail: \" + e);\n+            fail(\"Fail: \" + e);\n@@ -431,1 +442,1 @@\n-            errln(\"Fail: \" + e);\n+            fail(\"Fail: \" + e);\n@@ -440,0 +451,1 @@\n+    @Test\n@@ -468,1 +480,1 @@\n-                    logln(\"DateFormat instance which uses TimeZone <\" +\n+                    System.out.println(\"DateFormat instance which uses TimeZone <\" +\n@@ -471,1 +483,1 @@\n-                    logln(\"DateFormat instance which uses TimeZone <\" +\n+                    System.out.println(\"DateFormat instance which uses TimeZone <\" +\n@@ -476,1 +488,1 @@\n-                errln(\"Fail: DateFormat serialization\/equality bug\");\n+                fail(\"Fail: DateFormat serialization\/equality bug\");\n@@ -480,1 +492,1 @@\n-            errln(\"Fail: \" + e);\n+            fail(\"Fail: \" + e);\n@@ -484,1 +496,1 @@\n-            errln(\"Fail: \" + e);\n+            fail(\"Fail: \" + e);\n@@ -492,0 +504,1 @@\n+    @Test\n@@ -498,5 +511,5 @@\n-        logln(sdf.format(d, buf, fp).toString());\n-        logln(d + \" => \" + buf);\n-        logln(\"beginIndex = \" + fp.getBeginIndex());\n-        logln(\"endIndex = \" + fp.getEndIndex());\n-        if (fp.getBeginIndex() == fp.getEndIndex()) errln(\"Fail: Empty field\");\n+        System.out.println(sdf.format(d, buf, fp).toString());\n+        System.out.println(d + \" => \" + buf);\n+        System.out.println(\"beginIndex = \" + fp.getBeginIndex());\n+        System.out.println(\"endIndex = \" + fp.getEndIndex());\n+        if (fp.getBeginIndex() == fp.getEndIndex()) fail(\"Fail: Empty field\");\n@@ -513,0 +526,1 @@\n+    @Test\n@@ -522,2 +536,2 @@\n-        logln(\"Date=\"+s);\n-        logln(\"DF=\"+s2);\n+        System.out.println(\"Date=\"+s);\n+        System.out.println(\"DF=\"+s2);\n@@ -525,1 +539,1 @@\n-            errln(\"Months should match\");\n+            fail(\"Months should match\");\n@@ -528,0 +542,1 @@\n+    @Test\n@@ -534,1 +549,1 @@\n-                errln(\"Fail: SimpleDateFormat not using default zone\");\n+                fail(\"Fail: SimpleDateFormat not using default zone\");\n@@ -541,0 +556,1 @@\n+    @Test\n@@ -545,1 +561,1 @@\n-        logln(\"pattern: \\\"\" + pattern + \"\\\"\");\n+        System.out.println(\"pattern: \\\"\" + pattern + \"\\\"\");\n@@ -560,3 +576,3 @@\n-            logln(\" text: \\\"\" + text + \"\\\"\");\n-            logln(\" index: \" + pos.getIndex());\n-            logln(\" result: \" + d);\n+            System.out.println(\" text: \\\"\" + text + \"\\\"\");\n+            System.out.println(\" index: \" + pos.getIndex());\n+            System.out.println(\" result: \" + d);\n@@ -564,1 +580,1 @@\n-                errln(\"Fail: Expected pos \" + finish.getIndex());\n+                fail(\"Fail: Expected pos \" + finish.getIndex());\n@@ -567,1 +583,1 @@\n-                errln(\"Fail: Expected result \" + exp);\n+                fail(\"Fail: Expected result \" + exp);\n@@ -577,0 +593,1 @@\n+    @Test\n@@ -581,1 +598,1 @@\n-        logln(\"pattern: \\\"\" + pattern + \"\\\"\");\n+        System.out.println(\"pattern: \\\"\" + pattern + \"\\\"\");\n@@ -587,1 +604,1 @@\n-        logln(\" text: \\\"\" + text + \"\\\"\" +\n+        System.out.println(\" text: \\\"\" + text + \"\\\"\" +\n@@ -594,1 +611,1 @@\n-        logln(\" text: \\\"\" + text + \"\\\"\" +\n+        System.out.println(\" text: \\\"\" + text + \"\\\"\" +\n@@ -598,0 +615,1 @@\n+    @Test\n@@ -621,1 +639,1 @@\n-                logln(df.format(date));\n+                System.out.println(df.format(date));\n@@ -623,2 +641,2 @@\n-                logln(\"\" + gc.get(Calendar.ZONE_OFFSET));\n-                logln(format.format(date));\n+                System.out.println(\"\" + gc.get(Calendar.ZONE_OFFSET));\n+                System.out.println(format.format(date));\n@@ -627,1 +645,1 @@\n-                logln(\"No way Jose\");\n+                System.out.println(\"No way Jose\");\n@@ -635,0 +653,1 @@\n+    @Test\n@@ -640,1 +659,1 @@\n-        logln(d.toString());\n+        System.out.println(d.toString());\n@@ -648,0 +667,1 @@\n+    @Test\n@@ -653,1 +673,1 @@\n-        logln(d.toString());\n+        System.out.println(d.toString());\n@@ -665,0 +685,1 @@\n+    @Test\n@@ -680,1 +701,1 @@\n-                errln(\"FAIL: \" + ms + \" ms x \\\"\" + PAT[i] + \"\\\" -> \\\"\" +\n+                fail(\"FAIL: \" + ms + \" ms x \\\"\" + PAT[i] + \"\\\" -> \\\"\" +\n@@ -695,1 +716,1 @@\n-                errln(\"FAIL: parse(\\\"\" + IN[i] + \"\\\" x \\\"s.S\\\") -> \" +\n+                fail(\"FAIL: parse(\\\"\" + IN[i] + \"\\\" x \\\"s.S\\\") -> \" +\n@@ -704,0 +725,1 @@\n+    @Test\n@@ -706,1 +728,1 @@\n-        logln(\"pattern=\" + pattern);\n+        System.out.println(\"pattern=\" + pattern);\n@@ -711,1 +733,1 @@\n-            errln(\"Fail: result=\" + result);\n+            fail(\"Fail: result=\" + result);\n@@ -714,1 +736,1 @@\n-            logln(\"Pass: result=\" + result);\n+            System.out.println(\"Pass: result=\" + result);\n@@ -723,0 +745,1 @@\n+    @Test\n@@ -729,1 +752,1 @@\n-                errln(\"Incorrect value: \" + d);\n+                fail(\"Incorrect value: \" + d);\n@@ -731,1 +754,1 @@\n-            errln(\"Fail: \" + e);\n+            fail(\"Fail: \" + e);\n@@ -740,0 +763,1 @@\n+    @Test\n@@ -754,1 +778,1 @@\n-            errln(\"Parse failed, got \" + d2 +\n+            fail(\"Parse failed, got \" + d2 +\n@@ -768,0 +792,1 @@\n+    @Test\n@@ -787,1 +812,1 @@\n-            errln(\"Parse failed, d1 = \" + d1 + \", d2 = \" + d2);\n+            fail(\"Parse failed, d1 = \" + d1 + \", d2 = \" + d2);\n@@ -789,1 +814,1 @@\n-            logln(\"Parse passed\");\n+            System.out.println(\"Parse passed\");\n@@ -793,1 +818,1 @@\n-            errln(\"Parse failed, got Exception \" + e);\n+            fail(\"Parse failed, got Exception \" + e);\n@@ -805,0 +830,1 @@\n+    @Test\n@@ -813,2 +839,2 @@\n-            logln(\"Parse format \\\"\" + format + \"\\\" ok\");\n-            logln(dateString + \" -> \" + df.format(x));\n+            System.out.println(\"Parse format \\\"\" + format + \"\\\" ok\");\n+            System.out.println(dateString + \" -> \" + df.format(x));\n@@ -816,1 +842,1 @@\n-            errln(\"Parse format \\\"\" + format + \"\\\" failed.\");\n+            fail(\"Parse format \\\"\" + format + \"\\\" failed.\");\n@@ -823,0 +849,1 @@\n+    @Test\n@@ -872,1 +899,1 @@\n-            log(out.toString());\n+            System.out.println(out.toString());\n@@ -874,1 +901,1 @@\n-            err(out.toString());\n+            fail(out.toString());\n@@ -887,0 +914,1 @@\n+    @Test\n@@ -895,1 +923,1 @@\n-        logln(d + \" x \" + pattern + \" => \" + s);\n+        System.out.println(d + \" x \" + pattern + \" => \" + s);\n@@ -898,2 +926,2 @@\n-        logln(d + \" <= \" + pattern + \" x \" + s);\n-        logln(\"Parse pos = \" + pos);\n+        System.out.println(d + \" <= \" + pattern + \" x \" + s);\n+        System.out.println(\"Parse pos = \" + pos);\n@@ -901,1 +929,1 @@\n-            errln(\"FAIL\");\n+            fail(\"FAIL\");\n@@ -911,1 +939,1 @@\n-        logln(cal.getTime().toString());\n+        System.out.println(cal.getTime().toString());\n@@ -917,0 +945,1 @@\n+    @Test\n@@ -965,1 +994,1 @@\n-                    errln(\"FAIL: DateFormat.\" + DESC[j] + \" style \" + DATA[i] + \" \" +\n+                    fail(\"FAIL: DateFormat.\" + DESC[j] + \" style \" + DATA[i] + \" \" +\n@@ -973,0 +1002,1 @@\n+    @Test\n@@ -996,1 +1026,1 @@\n-                logln(String.valueOf(FORMAT_MS) + \" ms f* \\\"\" +\n+                System.out.println(String.valueOf(FORMAT_MS) + \" ms f* \\\"\" +\n@@ -999,1 +1029,1 @@\n-                errln(\"FAIL: \" + FORMAT_MS + \" ms f* \\\"\" +\n+                fail(\"FAIL: \" + FORMAT_MS + \" ms f* \\\"\" +\n@@ -1011,1 +1041,1 @@\n-                logln(\"\\\"\" + PARSE_STR[i] + \"\\\" p* \\\"\" +\n+                System.out.println(\"\\\"\" + PARSE_STR[i] + \"\\\" p* \\\"\" +\n@@ -1014,1 +1044,1 @@\n-                errln(\"FAIL: \\\"\" + PARSE_STR[i] + \"\\\" p* \\\"\" +\n+                fail(\"FAIL: \\\"\" + PARSE_STR[i] + \"\\\" p* \\\"\" +\n@@ -1026,1 +1056,1 @@\n-                logln(\"\\\"\" + PARSE_STR[i] + \"\\\" p* \\\"\" +\n+                System.out.println(\"\\\"\" + PARSE_STR[i] + \"\\\" p* \\\"\" +\n@@ -1029,1 +1059,1 @@\n-                errln(\"FAIL: \\\"\" + PARSE_STR[i] + \"\\\" p* \\\"\" +\n+                fail(\"FAIL: \\\"\" + PARSE_STR[i] + \"\\\" p* \\\"\" +\n@@ -1039,0 +1069,1 @@\n+    @Test\n@@ -1051,1 +1082,1 @@\n-            errln(\"FAIL: getTimeInstance().format(d) => \\\"\" +\n+            fail(\"FAIL: getTimeInstance().format(d) => \\\"\" +\n@@ -1060,0 +1091,1 @@\n+    @Test\n@@ -1071,1 +1103,1 @@\n-        logln(\"format()=>\" + result);\n+        System.out.println(\"format()=>\" + result);\n@@ -1073,1 +1105,1 @@\n-            errln(\"FAIL: SimpleDataFormat.format() did not retrun PST\");\n+            fail(\"FAIL: SimpleDataFormat.format() did not retrun PST\");\n@@ -1080,1 +1112,1 @@\n-            errln(\"FAIL: SimpleDataFormat.parse() could not parse PST\");\n+            fail(\"FAIL: SimpleDataFormat.parse() could not parse PST\");\n@@ -1084,1 +1116,1 @@\n-        logln(\"roundtrip:\" + result);\n+        System.out.println(\"roundtrip:\" + result);\n@@ -1086,1 +1118,1 @@\n-            errln(\"FAIL: SimpleDataFomat timezone roundtrip failed\");\n+            fail(\"FAIL: SimpleDataFomat timezone roundtrip failed\");\n","filename":"test\/jdk\/java\/text\/Format\/DateFormat\/DateFormatRegression.java","additions":156,"deletions":124,"binary":false,"changes":280,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @library \/java\/text\/testlib\n@@ -32,4 +31,15 @@\n-import java.text.*;\n-import java.util.*;\n-\n-public class DateFormatRoundTripTest extends IntlTest {\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.SimpleTimeZone;\n+import java.util.TimeZone;\n+\n+public class DateFormatRoundTripTest {\n@@ -110,1 +120,1 @@\n-                && (i+1) < args.length) {\n+                    && (i+1) < args.length) {\n@@ -114,1 +124,1 @@\n-                       && (i+1) < args.length) {\n+                    && (i+1) < args.length) {\n@@ -118,1 +128,1 @@\n-                && (i+1) < args.length) {\n+                    && (i+1) < args.length) {\n@@ -129,1 +139,1 @@\n-                       && (i+1) < args.length) {\n+                    && (i+1) < args.length) {\n@@ -143,1 +153,2 @@\n-        new DateFormatRoundTripTest(random, seed, infinite, date, pat, loc).run(args);\n+        new DateFormatRoundTripTest(random, seed, infinite, date, pat, loc)\n+                .TestDateFormatRoundTrip();\n@@ -160,1 +171,0 @@\n-        super.usage();\n@@ -313,2 +323,2 @@\n-        logln(\"DateFormat available locales: \" + avail.length);\n-        logln(\"Default TimeZone: \" +\n+        System.out.println(\"DateFormat available locales: \" + avail.length);\n+        System.out.println(\"Default TimeZone: \" +\n@@ -336,1 +346,1 @@\n-        logln(escape(tc.toString()));\n+        System.out.println(escape(tc.toString()));\n@@ -371,1 +381,1 @@\n-                logln(\"ENTERING INFINITE TEST LOOP, LOCALE \" + locale.getDisplayName());\n+                System.out.println(\"ENTERING INFINITE TEST LOOP, LOCALE \" + locale.getDisplayName());\n@@ -374,1 +384,1 @@\n-                logln(\"ENTERING INFINITE TEST LOOP, ALL LOCALES\");\n+                System.out.println(\"ENTERING INFINITE TEST LOOP, ALL LOCALES\");\n@@ -396,1 +406,1 @@\n-        if (!INFINITE) logln(\"Locale: \" + loc.getDisplayName());\n+        if (!INFINITE) System.out.println(\"Locale: \" + loc.getDisplayName());\n@@ -607,1 +617,1 @@\n-                    errln(escape(out.toString()));\n+                    throw new RuntimeException(escape(out.toString()));\n@@ -612,1 +622,1 @@\n-            errln(e.toString());\n+            throw new RuntimeException(e.toString());\n","filename":"test\/jdk\/java\/text\/Format\/DateFormat\/DateFormatRoundTripTest.java","additions":30,"deletions":20,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @library \/java\/text\/testlib\n@@ -31,1 +30,1 @@\n- * @run main\/othervm -Djava.locale.providers=COMPAT,SPI DateFormatTest\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT,SPI DateFormatTest\n@@ -38,1 +37,6 @@\n-public class DateFormatTest extends IntlTest\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class DateFormatTest\n@@ -40,9 +44,5 @@\n-    public static void main(String[] args) throws Exception {\n-        Locale reservedLocale = Locale.getDefault();\n-        try {\n-            Locale.setDefault(Locale.US);\n-            new DateFormatTest().run(args);\n-        } finally {\n-            \/\/ restore the reserved locale\n-            Locale.setDefault(reservedLocale);\n-        }\n+\n+    \/\/ Change JVM default Locale\n+    @BeforeAll\n+    static void initAll() {\n+        Locale.setDefault(Locale.US);\n@@ -53,0 +53,1 @@\n+    @Test\n@@ -61,1 +62,1 @@\n-            logln(str + \" parses with \" + pat + \" to \" + d);\n+            System.out.println(str + \" parses with \" + pat + \" to \" + d);\n@@ -63,1 +64,1 @@\n-                errln(\"FAIL: Expected \" + exp);\n+                fail(\"FAIL: Expected \" + exp);\n@@ -67,1 +68,1 @@\n-            errln(str + \" parse fails with \" + pat);\n+            fail(str + \" parse fails with \" + pat);\n@@ -72,0 +73,1 @@\n+    @Test\n@@ -94,1 +96,1 @@\n-        logln(\"Time Zone IDs size: \" + ids.length);\n+        System.out.println(\"Time Zone IDs size: \" + ids.length);\n@@ -98,1 +100,1 @@\n-        logln(\"Ordinal ID offset(h:m) name\");\n+        System.out.println(\"Ordinal ID offset(h:m) name\");\n@@ -139,1 +141,1 @@\n-                logln(i + \" \" + ids[i] + \" \" + dstOffset +\n+                System.out.println(i + \" \" + ids[i] + \" \" + dstOffset +\n@@ -145,1 +147,1 @@\n-                errln(i + \" \" + ids[i] + \" \" + dstOffset +\n+                fail(i + \" \" + ids[i] + \" \" + dstOffset +\n@@ -152,0 +154,1 @@\n+    @Test\n@@ -159,1 +162,1 @@\n-            errln(\"FAIL\");\n+            fail(\"FAIL\");\n@@ -165,0 +168,1 @@\n+    @Test\n@@ -184,1 +188,1 @@\n-            logln(s + \" P> \" + fullFmt.format(d));\n+            System.out.println(s + \" P> \" + fullFmt.format(d));\n@@ -186,1 +190,1 @@\n-                errln(\"FAIL: Should parse to hour \" + hour);\n+                fail(\"FAIL: Should parse to hour \" + hour);\n@@ -189,1 +193,1 @@\n-        catch (ParseException e) { errln(\"FAIL: \" + e.getMessage()); }\n+        catch (ParseException e) { fail(\"FAIL: \" + e.getMessage()); }\n@@ -237,0 +241,1 @@\n+    @Test\n@@ -276,2 +281,2 @@\n-            logln(\" Pattern = \" + ((SimpleDateFormat)df).toPattern());\n-            logln(\"  Result = \" + df.format(someDate));\n+            System.out.println(\" Pattern = \" + ((SimpleDateFormat)df).toPattern());\n+            System.out.println(\"  Result = \" + df.format(someDate));\n@@ -282,1 +287,1 @@\n-                    errln(\"FAIL: field #\" + i + \" \" + fieldNames[i] + \" = \\\"\" +\n+                    fail(\"FAIL: field #\" + i + \" \" + fieldNames[i] + \" = \\\"\" +\n@@ -301,0 +306,1 @@\n+    @Test\n@@ -315,1 +321,1 @@\n-        logln(\"Pattern \\\"\" + pat + \"\\\"   String \\\"\" + str + \"\\\"\");\n+        System.out.println(\"Pattern \\\"\" + pat + \"\\\"   String \\\"\" + str + \"\\\"\");\n@@ -320,2 +326,2 @@\n-            logln(\" parse(\" + str + \") -> \" + date.toString());\n-            logln(\" format -> \" + f);\n+            System.out.println(\" parse(\" + str + \") -> \" + date.toString());\n+            System.out.println(\" format -> \" + f);\n@@ -324,1 +330,1 @@\n-                errln(\"FAIL: Expected \" + expected);\n+                fail(\"FAIL: Expected \" + expected);\n@@ -327,1 +333,1 @@\n-                errln(\"FAIL: Expected \" + str);\n+                fail(\"FAIL: Expected \" + str);\n@@ -331,1 +337,1 @@\n-            logln(\"ParseException: \" + e.getMessage());\n+            System.out.println(\"ParseException: \" + e.getMessage());\n@@ -333,1 +339,1 @@\n-                errln(\"FAIL: Expected \" + expected);\n+                fail(\"FAIL: Expected \" + expected);\n@@ -337,1 +343,1 @@\n-            errln(\"*** Exception:\");\n+            fail(\"*** Exception:\");\n@@ -343,0 +349,1 @@\n+    @Test\n@@ -353,1 +360,1 @@\n-        logln(now);\n+        System.out.println(now);\n@@ -364,1 +371,1 @@\n-        logln(then);\n+        System.out.println(then);\n@@ -367,1 +374,1 @@\n-            errln(\"FAIL\");\n+            fail(\"FAIL\");\n@@ -373,0 +380,1 @@\n+    @Test\n@@ -389,1 +397,1 @@\n-        logln( \"pattern=\" + fmt.toPattern() + \"   string=\" + str );\n+        System.out.println( \"pattern=\" + fmt.toPattern() + \"   string=\" + str );\n@@ -398,1 +406,1 @@\n-        logln( \"Parsed object: \" + o );\n+        System.out.println( \"Parsed object: \" + o );\n@@ -400,1 +408,1 @@\n-            errln(\"FAIL: Expected \" + expected);\n+            fail(\"FAIL: Expected \" + expected);\n@@ -404,1 +412,1 @@\n-        logln( \"Formatted string: \" + formatted );\n+        System.out.println( \"Formatted string: \" + formatted );\n@@ -406,1 +414,1 @@\n-            errln(\"FAIL: Expected \" + str);\n+            fail(\"FAIL: Expected \" + str);\n@@ -413,0 +421,1 @@\n+    @Test\n@@ -418,1 +427,1 @@\n-        logln(\"Pattern \" + ((SimpleDateFormat)fmt).toPattern());\n+        System.out.println(\"Pattern \" + ((SimpleDateFormat)fmt).toPattern());\n@@ -427,1 +436,1 @@\n-            logln(\"format(June 15 1997) = \" + juneStr);\n+            System.out.println(\"format(June 15 1997) = \" + juneStr);\n@@ -431,1 +440,1 @@\n-            logln(\"  -> parse -> \" + s + \" (month = \" + month + \")\");\n+            System.out.println(\"  -> parse -> \" + s + \" (month = \" + month + \")\");\n@@ -433,1 +442,1 @@\n-                errln(\"FAIL: Month should be June\");\n+                fail(\"FAIL: Month should be June\");\n@@ -436,1 +445,1 @@\n-            logln(\"format(July 15 1997) = \" + julyStr);\n+            System.out.println(\"format(July 15 1997) = \" + julyStr);\n@@ -440,1 +449,1 @@\n-            logln(\"  -> parse -> \" + s + \" (month = \" + month + \")\");\n+            System.out.println(\"  -> parse -> \" + s + \" (month = \" + month + \")\");\n@@ -442,1 +451,1 @@\n-                errln(\"FAIL: Month should be July\");\n+                fail(\"FAIL: Month should be July\");\n@@ -446,1 +455,1 @@\n-            errln(\"Exception: \" + e);\n+            fail(\"Exception: \" + e);\n@@ -452,0 +461,1 @@\n+    @Test\n@@ -460,1 +470,1 @@\n-        logln( \"dateString= \" + dateString );\n+        System.out.println( \"dateString= \" + dateString );\n@@ -464,1 +474,1 @@\n-        logln(\"Using \" + bigD + \" -> \" + myDate);\n+        System.out.println(\"Using \" + bigD + \" -> \" + myDate);\n@@ -466,1 +476,1 @@\n-            errln(\"FAIL: Expected \" + expBigD + \" got \" + myDate);\n+            fail(\"FAIL: Expected \" + expBigD + \" got \" + myDate);\n@@ -472,1 +482,1 @@\n-        logln(\"Using \" + littleD + \" -> \" + myDate);\n+        System.out.println(\"Using \" + littleD + \" -> \" + myDate);\n@@ -474,1 +484,1 @@\n-            errln(\"FAIL: Expected \" + expLittleD + \" got \" + myDate);\n+            fail(\"FAIL: Expected \" + expLittleD + \" got \" + myDate);\n@@ -480,0 +490,1 @@\n+    @Test\n@@ -485,1 +496,1 @@\n-        logln(\"Test Date: \" + today);\n+        System.out.println(\"Test Date: \" + today);\n@@ -499,1 +510,1 @@\n-        logln(\"pattern: \" + sdf.toPattern());\n+        System.out.println(\"pattern: \" + sdf.toPattern());\n@@ -502,1 +513,1 @@\n-        logln(\" format -> \" + formatResult);\n+        System.out.println(\" format -> \" + formatResult);\n@@ -505,1 +516,1 @@\n-            logln(\" parse(\" + formatResult +  \") -> \" + d2);\n+            System.out.println(\" parse(\" + formatResult +  \") -> \" + d2);\n@@ -507,1 +518,1 @@\n-                errln(\"FAIL: Expected \" + expected);\n+                fail(\"FAIL: Expected \" + expected);\n@@ -510,1 +521,1 @@\n-            logln(\" format -> \" + format2);\n+            System.out.println(\" format -> \" + format2);\n@@ -512,1 +523,1 @@\n-                errln(\"FAIL: Round trip drift\");\n+                fail(\"FAIL: Round trip drift\");\n@@ -516,1 +527,1 @@\n-            errln(\"Error: \" + e.getMessage());\n+            fail(\"Error: \" + e.getMessage());\n@@ -522,0 +533,1 @@\n+    @Test\n@@ -529,1 +541,1 @@\n-        logln(\"format(\" + currentTime_1 + \") = \" + dateString);\n+        System.out.println(\"format(\" + currentTime_1 + \") = \" + dateString);\n@@ -531,1 +543,1 @@\n-            errln(\"FAIL: Expected \" + exp);\n+            fail(\"FAIL: Expected \" + exp);\n@@ -543,0 +555,1 @@\n+    @Test\n@@ -563,1 +576,1 @@\n-                            errln(prefix +\n+                            fail(prefix +\n@@ -568,1 +581,1 @@\n-                        logln(prefix + \"OK: \" + format);\n+                        System.out.println(prefix + \"OK: \" + format);\n@@ -571,1 +584,1 @@\n-                            errln(\"FAIL: Expected \" + expected);\n+                            fail(\"FAIL: Expected \" + expected);\n@@ -578,1 +591,1 @@\n-                        errln(prefix + \"SHOULD NOT HAPPEN: \" + e);\n+                        fail(prefix + \"SHOULD NOT HAPPEN: \" + e);\n@@ -613,0 +626,1 @@\n+    @Test\n@@ -623,1 +637,1 @@\n-        logln(\"Trying to parse \\\"\" + s + \"\\\" with \" + dateParse.toPattern());\n+        System.out.println(\"Trying to parse \\\"\" + s + \"\\\" with \" + dateParse.toPattern());\n@@ -626,1 +640,1 @@\n-            errln(\"FAIL: Expected exception during parse\");\n+            fail(\"FAIL: Expected exception during parse\");\n@@ -628,1 +642,1 @@\n-            logln(\"Exception during parse: \" + ex); \/\/ This is expected\n+            System.out.println(\"Exception during parse: \" + ex); \/\/ This is expected\n@@ -647,1 +661,1 @@\n-                            errln(\"ERROR: null result with pos \" +\n+                            fail(\"ERROR: null result with pos \" +\n@@ -653,1 +667,1 @@\n-                            logln(\"Parsed \\\"\" + s + \"\\\" using \\\"\" + dateParse.toPattern() +\n+                            System.out.println(\"Parsed \\\"\" + s + \"\\\" using \\\"\" + dateParse.toPattern() +\n@@ -656,1 +670,1 @@\n-                                errln(\"FAIL: Expected parse failure\");\n+                                fail(\"FAIL: Expected parse failure\");\n@@ -658,1 +672,1 @@\n-                                errln(\"FAIL: Expected \" + expected);\n+                                fail(\"FAIL: Expected \" + expected);\n@@ -664,1 +678,1 @@\n-                            errln(\"FAIL: Expected \" + expected);\n+                            fail(\"FAIL: Expected \" + expected);\n@@ -668,1 +682,1 @@\n-                    errln(\"An exception was thrown during parse: \" + ex);\n+                    fail(\"An exception was thrown during parse: \" + ex);\n@@ -675,0 +689,1 @@\n+    @Test\n@@ -698,1 +713,1 @@\n-            errln(\"Failed: producing expected values: 2DigitYearStart: \" + new Date(start)\n+            fail(\"Failed: producing expected values: 2DigitYearStart: \" + new Date(start)\n@@ -701,1 +716,1 @@\n-        logln(\"2DigitYearStart: \" + new Date(start) + \", xx17 = \" + xx17 + \", xx34 = \" + xx34);\n+        System.out.println(\"2DigitYearStart: \" + new Date(start) + \", xx17 = \" + xx17 + \", xx34 = \" + xx34);\n@@ -716,1 +731,1 @@\n-            logln(\"Parsing \\\"\" + str + \"\\\" with \" +\n+            System.out.println(\"Parsing \\\"\" + str + \"\\\" with \" +\n@@ -720,1 +735,1 @@\n-                errln(\"FAIL: Expected \" + expected);\n+                fail(\"FAIL: Expected \" + expected);\n@@ -723,1 +738,1 @@\n-            errln(\"FAIL: Got exception\");\n+            fail(\"FAIL: Got exception\");\n@@ -728,0 +743,1 @@\n+    @Test\n@@ -735,1 +751,1 @@\n-        logln( \"Date 1997\/3\/25 00:00 GMT: \" + date );\n+        System.out.println( \"Date 1997\/3\/25 00:00 GMT: \" + date );\n@@ -740,1 +756,1 @@\n-        logln( \"Formatted in GMT to: \" + temp );\n+        System.out.println( \"Formatted in GMT to: \" + temp );\n@@ -745,1 +761,1 @@\n-            logln( \"Parsed to: \" + tempDate );\n+            System.out.println( \"Parsed to: \" + tempDate );\n@@ -747,1 +763,1 @@\n-                errln(\"FAIL: Expected \" + date);\n+                fail(\"FAIL: Expected \" + date);\n@@ -751,1 +767,1 @@\n-            errln( \"Date Formatter throws: \" +\n+            fail( \"Date Formatter throws: \" +\n@@ -757,0 +773,1 @@\n+    @Test\n@@ -770,1 +787,1 @@\n-                logln(\"Test timezone = \" + testtimezone);\n+                System.out.println(\"Test timezone = \" + testtimezone);\n@@ -772,1 +789,1 @@\n-                errln(\"Test timezone should be GMT, not \" + testtimezone);\n+                fail(\"Test timezone should be GMT, not \" + testtimezone);\n@@ -802,1 +819,1 @@\n-                logln(DATA[i] + result);\n+                System.out.println(DATA[i] + result);\n@@ -804,1 +821,1 @@\n-                    errln(\"FAIL: Expected \" + DATA[i+1]\n+                    fail(\"FAIL: Expected \" + DATA[i+1]\n@@ -815,0 +832,1 @@\n+    @Test\n@@ -824,1 +842,1 @@\n-        logln(\"Date set to : \" + testDate);\n+        System.out.println(\"Date set to : \" + testDate);\n@@ -826,2 +844,2 @@\n-        logln(\"Date Formated with French Locale \" + out);\n-        if (!out.equals(expectedFRENCH)) errln(\"FAIL: Expected \" + expectedFRENCH);\n+        System.out.println(\"Date Formated with French Locale \" + out);\n+        if (!out.equals(expectedFRENCH)) fail(\"FAIL: Expected \" + expectedFRENCH);\n@@ -829,2 +847,2 @@\n-        logln(\"Date Formated with US Locale \" + out);\n-        if (!out.equals(expectedUS)) errln(\"FAIL: Expected \" + expectedUS);\n+        System.out.println(\"Date Formated with US Locale \" + out);\n+        if (!out.equals(expectedUS)) fail(\"FAIL: Expected \" + expectedUS);\n@@ -838,0 +856,1 @@\n+    @Test\n@@ -844,1 +863,1 @@\n-            errln(\"DateFormat.getInstance() didn't return an instance of SimpleDateFormat!\");\n+            fail(\"DateFormat.getInstance() didn't return an instance of SimpleDateFormat!\");\n@@ -864,1 +883,1 @@\n-            errln(\"SimpleDateFormat.get2DigitStartDate() returned \" + (cal.get(Calendar.MONTH)\n+            fail(\"SimpleDateFormat.get2DigitStartDate() returned \" + (cal.get(Calendar.MONTH)\n@@ -872,1 +891,1 @@\n-            errln(\"Parsing \\\"3\/10\/67\\\" with 2-digit start date set to 1\/1\/1900 yielded a year of \"\n+            fail(\"Parsing \\\"3\/10\/67\\\" with 2-digit start date set to 1\/1\/1900 yielded a year of \"\n@@ -875,1 +894,1 @@\n-            errln(\"Parsing \\\"3\/10\/67\\\" with 2-digit start date set to 1\/1\/1900 failed: got \" +\n+            fail(\"Parsing \\\"3\/10\/67\\\" with 2-digit start date set to 1\/1\/1900 failed: got \" +\n@@ -881,1 +900,1 @@\n-            errln(\"Parsing \\\"3\/16\/43\\\" with 2-digit start date set to 1\/1\/1900 yielded a year of \"\n+            fail(\"Parsing \\\"3\/16\/43\\\" with 2-digit start date set to 1\/1\/1900 yielded a year of \"\n@@ -884,1 +903,1 @@\n-            errln(\"Parsing \\\"3\/16\/43\\\" with 2-digit start date set to 1\/1\/1900 failed: got \" +\n+            fail(\"Parsing \\\"3\/16\/43\\\" with 2-digit start date set to 1\/1\/1900 failed: got \" +\n@@ -894,1 +913,1 @@\n-            errln(\"Parsing \\\"3\/10\/67\\\" with 2-digit start date set to 1\/1\/2000 yielded a year of \"\n+            fail(\"Parsing \\\"3\/10\/67\\\" with 2-digit start date set to 1\/1\/2000 yielded a year of \"\n@@ -897,1 +916,1 @@\n-            errln(\"Parsing \\\"3\/10\/67\\\" with 2-digit start date set to 1\/1\/2000 failed: got \" +\n+            fail(\"Parsing \\\"3\/10\/67\\\" with 2-digit start date set to 1\/1\/2000 failed: got \" +\n@@ -903,1 +922,1 @@\n-            errln(\"Parsing \\\"3\/16\/43\\\" with 2-digit start date set to 1\/1\/2000 yielded a year of \"\n+            fail(\"Parsing \\\"3\/16\/43\\\" with 2-digit start date set to 1\/1\/2000 yielded a year of \"\n@@ -906,1 +925,1 @@\n-            errln(\"Parsing \\\"3\/16\/43\\\" with 2-digit start date set to 1\/1\/2000 failed: got \" +\n+            fail(\"Parsing \\\"3\/16\/43\\\" with 2-digit start date set to 1\/1\/2000 failed: got \" +\n@@ -916,1 +935,1 @@\n-            errln(\"Parsing \\\"3\/10\/67\\\" with 2-digit start date set to 1\/1\/1950 yielded a year of \"\n+            fail(\"Parsing \\\"3\/10\/67\\\" with 2-digit start date set to 1\/1\/1950 yielded a year of \"\n@@ -919,1 +938,1 @@\n-            errln(\"Parsing \\\"3\/10\/67\\\" with 2-digit start date set to 1\/1\/1950 failed: got \" +\n+            fail(\"Parsing \\\"3\/10\/67\\\" with 2-digit start date set to 1\/1\/1950 failed: got \" +\n@@ -925,1 +944,1 @@\n-            errln(\"Parsing \\\"3\/16\/43\\\" with 2-digit start date set to 1\/1\/1950 yielded a year of \"\n+            fail(\"Parsing \\\"3\/16\/43\\\" with 2-digit start date set to 1\/1\/1950 yielded a year of \"\n@@ -928,1 +947,1 @@\n-            errln(\"Parsing \\\"3\/16\/43\\\" with 2-digit start date set to 1\/1\/1950 failed: got \" +\n+            fail(\"Parsing \\\"3\/16\/43\\\" with 2-digit start date set to 1\/1\/1950 failed: got \" +\n@@ -938,1 +957,1 @@\n-            errln(\"Parsing \\\"3\/16\/43\\\" with 2-digit start date set to 6\/1\/1943 yielded a year of \"\n+            fail(\"Parsing \\\"3\/16\/43\\\" with 2-digit start date set to 6\/1\/1943 yielded a year of \"\n@@ -941,1 +960,1 @@\n-            errln(\"Parsing \\\"3\/16\/43\\\" with 2-digit start date set to 6\/1\/1943 failed: got \" +\n+            fail(\"Parsing \\\"3\/16\/43\\\" with 2-digit start date set to 6\/1\/1943 failed: got \" +\n@@ -947,1 +966,1 @@\n-            errln(\"Parsing \\\"7\/21\/43\\\" with 2-digit start date set to 6\/1\/1943 yielded a year of \"\n+            fail(\"Parsing \\\"7\/21\/43\\\" with 2-digit start date set to 6\/1\/1943 yielded a year of \"\n@@ -950,1 +969,1 @@\n-            errln(\"Parsing \\\"7\/21\/43\\\" with 2-digit start date set to 6\/1\/1943 failed: got \" +\n+            fail(\"Parsing \\\"7\/21\/43\\\" with 2-digit start date set to 6\/1\/1943 failed: got \" +\n@@ -960,1 +979,1 @@\n-            errln(\"SimpleDateFormat.get2DigitStartDate() returned \" + (cal.get(Calendar.MONTH)\n+            fail(\"SimpleDateFormat.get2DigitStartDate() returned \" + (cal.get(Calendar.MONTH)\n@@ -970,0 +989,1 @@\n+    @Test\n@@ -978,1 +998,1 @@\n-        logln(str + \" parses with \" + pat + \" to \" + d);\n+        System.out.println(str + \" parses with \" + pat + \" to \" + d);\n@@ -980,1 +1000,1 @@\n-            logln(\"Expected null returned, failed at : \" + pos.getErrorIndex());\n+            System.out.println(\"Expected null returned, failed at : \" + pos.getErrorIndex());\n@@ -982,1 +1002,1 @@\n-            errln(\"Failed, parse \" + str + \" got : \" + d + \", index=\" + pos.getErrorIndex());\n+            fail(\"Failed, parse \" + str + \" got : \" + d + \", index=\" + pos.getErrorIndex());\n@@ -989,0 +1009,1 @@\n+    @Test\n@@ -999,1 +1020,1 @@\n-            errln(\"Test4469904: Failed. Buddhist Era abbrev not present.\");\n+            fail(\"Test4469904: Failed. Buddhist Era abbrev not present.\");\n@@ -1007,0 +1028,1 @@\n+    @Test\n@@ -1024,1 +1046,1 @@\n-            errln(\"SimpleDateFormat() doesn't throw NPE with null pattern\");\n+            fail(\"SimpleDateFormat() doesn't throw NPE with null pattern\");\n@@ -1031,1 +1053,1 @@\n-            errln(\"SimpleDateFormat() doesn't throw NPE with null locale\");\n+            fail(\"SimpleDateFormat() doesn't throw NPE with null locale\");\n@@ -1038,1 +1060,1 @@\n-            errln(\"SimpleDateFormat() doesn't throw NPE with null DateFormatSymbols\");\n+            fail(\"SimpleDateFormat() doesn't throw NPE with null DateFormatSymbols\");\n@@ -1045,1 +1067,1 @@\n-            errln(\"applyPattern() doesn't throw NPE with null pattern\");\n+            fail(\"applyPattern() doesn't throw NPE with null pattern\");\n@@ -1054,1 +1076,1 @@\n-                errln(\"SimpleDateFormat(\\\"\" + wrongPatterns[i] + \"\\\")\" +\n+                fail(\"SimpleDateFormat(\\\"\" + wrongPatterns[i] + \"\\\")\" +\n@@ -1062,1 +1084,1 @@\n-                errln(\"SimpleDateFormat(\\\"\" + wrongPatterns[i] + \"\\\", DateFormatSymbols) doesn't \" +\n+                fail(\"SimpleDateFormat(\\\"\" + wrongPatterns[i] + \"\\\", DateFormatSymbols) doesn't \" +\n@@ -1070,1 +1092,1 @@\n-                errln(\"SimpleDateFormat(\\\"\" + wrongPatterns[i] +\n+                fail(\"SimpleDateFormat(\\\"\" + wrongPatterns[i] +\n@@ -1078,1 +1100,1 @@\n-                errln(\"SimpleDateFormat.applyPattern(\\\"\" + wrongPatterns[i] +\n+                fail(\"SimpleDateFormat.applyPattern(\\\"\" + wrongPatterns[i] +\n@@ -1103,0 +1125,1 @@\n+    @Test\n@@ -1112,1 +1135,1 @@\n-        logln(\"the test date: \" + date);\n+        System.out.println(\"the test date: \" + date);\n@@ -1123,1 +1146,1 @@\n-                    logln(s);\n+                    System.out.println(s);\n@@ -1136,1 +1159,1 @@\n-                        errln(\"round trip conversion failed: timezone=\"+zones[z]+\n+                        fail(\"round trip conversion failed: timezone=\"+zones[z]+\n@@ -1194,1 +1217,1 @@\n-                errln(\"wrong format result: expected=\"+expected+\", got=\"+s);\n+                fail(\"wrong format result: expected=\"+expected+\", got=\"+s);\n@@ -1200,1 +1223,1 @@\n-                errln(\"wrong parse result: expected=2001, got=\" + cal.get(YEAR));\n+                fail(\"wrong parse result: expected=2001, got=\" + cal.get(YEAR));\n@@ -1210,0 +1233,1 @@\n+    @Test\n","filename":"test\/jdk\/java\/text\/Format\/DateFormat\/DateFormatTest.java","additions":158,"deletions":134,"binary":false,"changes":292,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n- * @library \/java\/text\/testlib\n- * @run main\/othervm -Djava.locale.providers=COMPAT,SPI IntlTestDateFormat\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT,SPI IntlTestDateFormat\n@@ -47,1 +46,5 @@\n-public class IntlTestDateFormat extends IntlTest {\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class IntlTestDateFormat {\n@@ -65,4 +68,1 @@\n-    public static void main(String[] args) throws Exception {\n-        new IntlTestDateFormat().run(args);\n-    }\n-\n+    @Test\n@@ -88,1 +88,1 @@\n-                errln(\"FAIL: localeTest time getTimeInstance exception\");\n+                fail(\"FAIL: localeTest time getTimeInstance exception\");\n@@ -102,1 +102,1 @@\n-                errln(\"FAIL: localeTest date getTimeInstance exception\");\n+                fail(\"FAIL: localeTest date getTimeInstance exception\");\n@@ -115,1 +115,1 @@\n-                    errln(\"FAIL: localeTest date\/time getDateTimeInstance exception\");\n+                    fail(\"FAIL: localeTest date\/time getDateTimeInstance exception\");\n@@ -123,0 +123,1 @@\n+    @Test\n@@ -125,1 +126,1 @@\n-            errln(\"FAIL: DateFormat creation failed\");\n+            fail(\"FAIL: DateFormat creation failed\");\n@@ -145,1 +146,1 @@\n-            errln(\"FAIL: no DateFormat\");\n+            fail(\"FAIL: no DateFormat\");\n@@ -151,1 +152,1 @@\n-        logln(fTestName + \" Pattern \" + s.toPattern());\n+        System.out.println(fTestName + \" Pattern \" + s.toPattern());\n@@ -172,1 +173,1 @@\n-                    errln(\"********** FAIL: Parse of \" + string[i-1] + \" failed.\");\n+                    fail(\"********** FAIL: Parse of \" + string[i-1] + \" failed.\");\n@@ -183,1 +184,1 @@\n-                    errln(\"********** FAIL: Date mismatch after match.\");\n+                    fail(\"********** FAIL: Date mismatch after match.\");\n@@ -190,1 +191,1 @@\n-                    errln(\"********** FAIL: String mismatch after match.\");\n+                    fail(\"********** FAIL: String mismatch after match.\");\n@@ -201,1 +202,1 @@\n-            errln(\"********** FAIL: No string and\/or date match within \" + fLimit + \" iterations.\");\n+            fail(\"********** FAIL: No string and\/or date match within \" + fLimit + \" iterations.\");\n@@ -207,1 +208,1 @@\n-                logln(\"\" + k + \": \" + date[k] + \" F> \" + string[k] + \" P> \");\n+                System.out.println(\"\" + k + \": \" + date[k] + \" F> \" + string[k] + \" P> \");\n@@ -238,0 +239,1 @@\n+    @Test\n@@ -241,1 +243,1 @@\n-        logln(\"\" + count + \" available locales\");\n+        System.out.println(\"\" + count + \" available locales\");\n@@ -248,1 +250,1 @@\n-            logln(all.toString());\n+            System.out.println(all.toString());\n@@ -250,1 +252,1 @@\n-        else errln(\"********** FAIL: Zero available locales or null array pointer\");\n+        else fail(\"********** FAIL: Zero available locales or null array pointer\");\n@@ -254,0 +256,1 @@\n+    @Test\n@@ -260,1 +263,1 @@\n-                logln(\"Testing \" + name + \"...\");\n+                System.out.println(\"Testing \" + name + \"...\");\n@@ -265,1 +268,1 @@\n-                    errln(\"FAIL: TestMonster localeTest exception\" + e);\n+                    fail(\"FAIL: TestMonster localeTest exception\" + e);\n","filename":"test\/jdk\/java\/text\/Format\/DateFormat\/IntlTestDateFormat.java","additions":27,"deletions":24,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n- * @library \/java\/text\/testlib\n- * @run main\/othervm -Djava.locale.providers=COMPAT,SPI IntlTestDateFormatAPI\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT,SPI IntlTestDateFormatAPI\n@@ -46,1 +45,6 @@\n-public class IntlTestDateFormatAPI extends IntlTest\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class IntlTestDateFormatAPI\n@@ -48,9 +52,0 @@\n-    public static void main(String[] args) throws Exception {\n-        Locale reservedLocale = Locale.getDefault();\n-        try {\n-            new IntlTestDateFormatAPI().run(args);\n-        } finally {\n-            \/\/ restore the reserved locale\n-            Locale.setDefault(reservedLocale);\n-        }\n-    }\n@@ -59,0 +54,1 @@\n+    @Test\n@@ -68,1 +64,1 @@\n-            errln(\"FAIL: DateFormat objects created at different times are unequal.\");\n+            fail(\"FAIL: DateFormat objects created at different times are unequal.\");\n@@ -79,1 +75,1 @@\n-                errln(\"FAIL: setTwoDigitStartDate failed.\");\n+                fail(\"FAIL: setTwoDigitStartDate failed.\");\n@@ -85,0 +81,1 @@\n+    @Test\n@@ -87,1 +84,1 @@\n-        logln(\"DateFormat API test---\"); logln(\"\");\n+        System.out.println(\"DateFormat API test---\"); System.out.println(\"\");\n@@ -93,1 +90,1 @@\n-        logln(\"Testing DateFormat constructors\");\n+        System.out.println(\"Testing DateFormat constructors\");\n@@ -102,1 +99,1 @@\n-        logln(\"Testing equality operator\");\n+        System.out.println(\"Testing equality operator\");\n@@ -105,1 +102,1 @@\n-            errln(\"ERROR: equals failed\");\n+            fail(\"ERROR: equals failed\");\n@@ -110,1 +107,1 @@\n-        logln(\"Testing various format() methods\");\n+        System.out.println(\"Testing various format() methods\");\n@@ -121,1 +118,1 @@\n-        logln(\"\" + d.getTime() + \" formatted to \" + res1);\n+        System.out.println(\"\" + d.getTime() + \" formatted to \" + res1);\n@@ -124,1 +121,1 @@\n-        logln(\"\" + d.getTime() + \" formatted to \" + res2);\n+        System.out.println(\"\" + d.getTime() + \" formatted to \" + res2);\n@@ -127,1 +124,1 @@\n-        logln(\"\" + d.getTime() + \" formatted to \" + res3);\n+        System.out.println(\"\" + d.getTime() + \" formatted to \" + res3);\n@@ -131,1 +128,1 @@\n-        logln(\"Testing parse()\");\n+        System.out.println(\"Testing parse()\");\n@@ -142,1 +139,1 @@\n-            errln(\"ERROR: parseObject() failed for \" + text);\n+            fail(\"ERROR: parseObject() failed for \" + text);\n@@ -144,1 +141,1 @@\n-        logln(text + \" parsed into \" + ((Date)result1).getTime());\n+        System.out.println(text + \" parsed into \" + ((Date)result1).getTime());\n@@ -150,1 +147,1 @@\n-            errln(\"ERROR: parse() failed\");\n+            fail(\"ERROR: parse() failed\");\n@@ -152,1 +149,1 @@\n-        logln(text + \" parsed into \" + result2.getTime());\n+        System.out.println(text + \" parsed into \" + result2.getTime());\n@@ -156,1 +153,1 @@\n-            errln(\"ERROR: parse() failed for \" + text);\n+            fail(\"ERROR: parse() failed for \" + text);\n@@ -158,1 +155,1 @@\n-        logln(text + \" parsed into \" + result3.getTime());\n+        System.out.println(text + \" parsed into \" + result3.getTime());\n@@ -163,1 +160,1 @@\n-        logln(\"Testing getters and setters\");\n+        System.out.println(\"Testing getters and setters\");\n@@ -167,1 +164,1 @@\n-        logln(\"Got \" + count + \" locales\" );\n+        System.out.println(\"Got \" + count + \" locales\" );\n@@ -171,1 +168,1 @@\n-            logln(name);\n+            System.out.println(name);\n@@ -176,1 +173,1 @@\n-            errln(\"ERROR: setLenient() failed\");\n+            fail(\"ERROR: setLenient() failed\");\n@@ -184,1 +181,1 @@\n-            errln(\"ERROR: set Calendar() failed\");\n+            fail(\"ERROR: set Calendar() failed\");\n@@ -192,1 +189,1 @@\n-            errln(\"ERROR: set NumberFormat() failed\");\n+            fail(\"ERROR: set NumberFormat() failed\");\n@@ -200,1 +197,1 @@\n-            errln(\"ERROR: set TimeZone() failed\");\n+            fail(\"ERROR: set TimeZone() failed\");\n","filename":"test\/jdk\/java\/text\/Format\/DateFormat\/IntlTestDateFormatAPI.java","additions":34,"deletions":37,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @library \/java\/text\/testlib\n@@ -28,0 +27,1 @@\n+ * @run junit IntlTestDateFormatSymbols\n@@ -44,5 +44,1 @@\n-public class IntlTestDateFormatSymbols extends IntlTest\n-{\n-    public static void main(String[] args) throws Exception {\n-        new IntlTestDateFormatSymbols().run(args);\n-    }\n+import org.junit.jupiter.api.Test;\n@@ -50,0 +46,4 @@\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class IntlTestDateFormatSymbols\n+{\n@@ -51,0 +51,1 @@\n+    @Test\n@@ -61,1 +62,1 @@\n-        logln(\"size = \" + cnt);\n+        System.out.println(\"size = \" + cnt);\n@@ -65,1 +66,1 @@\n-            logln(month[i]);\n+            System.out.println(month[i]);\n@@ -70,0 +71,1 @@\n+    @Test\n@@ -77,1 +79,1 @@\n-            errln(\"ERROR: English DateFormatSymbols equal to French\");\n+            fail(\"ERROR: English DateFormatSymbols equal to French\");\n@@ -88,1 +90,1 @@\n-            errln(\"ERROR: setEras() failed (different size array)\");\n+            fail(\"ERROR: setEras() failed (different size array)\");\n@@ -93,1 +95,1 @@\n-                    errln(\"ERROR: setEras() failed (different string values)\");\n+                    fail(\"ERROR: setEras() failed (different string values)\");\n@@ -104,1 +106,1 @@\n-            errln(\"ERROR: setMonths() failed (different size array)\");\n+            fail(\"ERROR: setMonths() failed (different size array)\");\n@@ -109,1 +111,1 @@\n-                    errln(\"ERROR: setMonths() failed (different string values)\");\n+                    fail(\"ERROR: setMonths() failed (different string values)\");\n@@ -119,1 +121,1 @@\n-            errln(\"ERROR: setShortMonths() failed (different size array)\");\n+            fail(\"ERROR: setShortMonths() failed (different size array)\");\n@@ -124,1 +126,1 @@\n-                    errln(\"ERROR: setShortMonths() failed (different string values)\");\n+                    fail(\"ERROR: setShortMonths() failed (different string values)\");\n@@ -134,1 +136,1 @@\n-            errln(\"ERROR: setWeekdays() failed (different size array)\");\n+            fail(\"ERROR: setWeekdays() failed (different size array)\");\n@@ -139,1 +141,1 @@\n-                    errln(\"ERROR: setWeekdays() failed (different string values)\");\n+                    fail(\"ERROR: setWeekdays() failed (different string values)\");\n@@ -149,1 +151,1 @@\n-            errln(\"ERROR: setShortWeekdays() failed (different size array)\");\n+            fail(\"ERROR: setShortWeekdays() failed (different size array)\");\n@@ -154,1 +156,1 @@\n-                    errln(\"ERROR: setShortWeekdays() failed (different string values)\");\n+                    fail(\"ERROR: setShortWeekdays() failed (different string values)\");\n@@ -164,1 +166,1 @@\n-            errln(\"ERROR: setAmPmStrings() failed (different size array)\");\n+            fail(\"ERROR: setAmPmStrings() failed (different size array)\");\n@@ -169,1 +171,1 @@\n-                    errln(\"ERROR: setAmPmStrings() failed (different string values)\");\n+                    fail(\"ERROR: setAmPmStrings() failed (different string values)\");\n@@ -183,1 +185,1 @@\n-                    errln(\"ERROR: setZoneStrings() failed\");\n+                    fail(\"ERROR: setZoneStrings() failed\");\n@@ -194,1 +196,1 @@\n-            errln(\"ERROR: setLocalPatternChars() failed\");\n+            fail(\"ERROR: setLocalPatternChars() failed\");\n@@ -203,1 +205,1 @@\n-            errln(\"ERROR: Clone failed\");\n+            fail(\"ERROR: Clone failed\");\n","filename":"test\/jdk\/java\/text\/Format\/DateFormat\/IntlTestDateFormatSymbols.java","additions":27,"deletions":25,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n- * @library \/java\/text\/testlib\n- * @run main\/othervm -Djava.locale.providers=COMPAT,SPI IntlTestSimpleDateFormatAPI\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT,SPI IntlTestSimpleDateFormatAPI\n@@ -46,1 +45,6 @@\n-public class IntlTestSimpleDateFormatAPI extends IntlTest\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class IntlTestSimpleDateFormatAPI\n@@ -48,9 +52,0 @@\n-    public static void main(String[] args) throws Exception {\n-        Locale reservedLocale = Locale.getDefault();\n-        try {\n-            new IntlTestSimpleDateFormatAPI().run(args);\n-        } finally {\n-            \/\/ restore the reserved locale\n-            Locale.setDefault(reservedLocale);\n-        }\n-    }\n@@ -59,0 +54,1 @@\n+    @Test\n@@ -61,1 +57,1 @@\n-        logln(\"SimpleDateFormat API test---\"); logln(\"\");\n+        System.out.println(\"SimpleDateFormat API test---\"); System.out.println(\"\");\n@@ -67,1 +63,1 @@\n-        logln(\"Testing SimpleDateFormat constructors\");\n+        System.out.println(\"Testing SimpleDateFormat constructors\");\n@@ -82,1 +78,1 @@\n-        logln(\"Testing clone(), assignment and equality operators\");\n+        System.out.println(\"Testing clone(), assignment and equality operators\");\n@@ -86,1 +82,1 @@\n-            errln(\"ERROR: Format clone or equals failed\");\n+            fail(\"ERROR: Format clone or equals failed\");\n@@ -91,1 +87,1 @@\n-        logln(\"Testing various format() methods\");\n+        System.out.println(\"Testing various format() methods\");\n@@ -101,1 +97,1 @@\n-        logln( \"\" + d.getTime() + \" formatted to \" + res1);\n+        System.out.println( \"\" + d.getTime() + \" formatted to \" + res1);\n@@ -104,1 +100,1 @@\n-        logln(\"\" + d.getTime() + \" formatted to \" + res2);\n+        System.out.println(\"\" + d.getTime() + \" formatted to \" + res2);\n@@ -108,1 +104,1 @@\n-        logln(\"Testing parse()\");\n+        System.out.println(\"Testing parse()\");\n@@ -115,1 +111,1 @@\n-        logln(text + \" parsed into \" + result1);\n+        System.out.println(text + \" parsed into \" + result1);\n@@ -121,1 +117,1 @@\n-            errln(\"ERROR: parse() failed\");\n+            fail(\"ERROR: parse() failed\");\n@@ -123,1 +119,1 @@\n-        logln(text + \" parsed into \" + result2);\n+        System.out.println(text + \" parsed into \" + result2);\n@@ -127,1 +123,1 @@\n-        logln(\"Testing getters and setters\");\n+        System.out.println(\"Testing getters and setters\");\n@@ -133,1 +129,1 @@\n-            errln(\"ERROR: set DateFormatSymbols() failed\");\n+            fail(\"ERROR: set DateFormatSymbols() failed\");\n@@ -141,1 +137,1 @@\n-            errln(\"ERROR: getTwoDigitStartDate() failed\");\n+            fail(\"ERROR: getTwoDigitStartDate() failed\");\n@@ -148,1 +144,1 @@\n-            errln(\"ERROR: setTwoDigitStartDate() failed\");\n+            fail(\"ERROR: setTwoDigitStartDate() failed\");\n@@ -153,1 +149,1 @@\n-        logln(\"Testing applyPattern()\");\n+        System.out.println(\"Testing applyPattern()\");\n@@ -156,1 +152,1 @@\n-        logln(\"Applying pattern \" + p1);\n+        System.out.println(\"Applying pattern \" + p1);\n@@ -160,1 +156,1 @@\n-        logln(\"Extracted pattern is \" + s2);\n+        System.out.println(\"Extracted pattern is \" + s2);\n@@ -162,1 +158,1 @@\n-            errln(\"ERROR: toPattern() result did not match pattern applied\");\n+            fail(\"ERROR: toPattern() result did not match pattern applied\");\n@@ -165,1 +161,1 @@\n-        logln(\"Applying pattern \" + p1);\n+        System.out.println(\"Applying pattern \" + p1);\n@@ -168,1 +164,1 @@\n-        logln(\"Extracted pattern is \" + s3);\n+        System.out.println(\"Extracted pattern is \" + s3);\n@@ -170,1 +166,1 @@\n-            errln(\"ERROR: toLocalizedPattern() result did not match pattern applied\");\n+            fail(\"ERROR: toLocalizedPattern() result did not match pattern applied\");\n","filename":"test\/jdk\/java\/text\/Format\/DateFormat\/IntlTestSimpleDateFormatAPI.java","additions":31,"deletions":35,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n- * @library \/java\/text\/testlib\n- * @run main\/othervm -Djava.locale.providers=COMPAT,SPI TimeZoneNameTest\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT,SPI TimeZoneNameTest\n@@ -35,1 +34,6 @@\n-public class TimeZoneNameTest extends IntlTest\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class TimeZoneNameTest\n@@ -37,0 +41,7 @@\n+\n+    \/\/ Change JVM default Locale\n+    @BeforeAll\n+    static void initAll() {\n+        Locale.setDefault(Locale.US);\n+    }\n+\n@@ -97,11 +108,1 @@\n-    public static void main(String[] args) throws Exception {\n-        Locale reservedLocale = Locale.getDefault();\n-        try {\n-            Locale.setDefault(Locale.US);\n-            new TimeZoneNameTest().run(args);\n-        } finally {\n-            \/\/ restore the reserved locale\n-            Locale.setDefault(reservedLocale);\n-        }\n-    }\n-\n+    @Test\n@@ -132,2 +133,2 @@\n-            logln(tz.getID() + \": \" + sfmt.format(sol1.getTime()) + \", \" + lfmt.format(sol1.getTime()));\n-            logln(tz.getID() + \": \" + sfmt.format(sol2.getTime()) + \", \" + lfmt.format(sol2.getTime()));\n+            System.out.println(tz.getID() + \": \" + sfmt.format(sol1.getTime()) + \", \" + lfmt.format(sol1.getTime()));\n+            System.out.println(tz.getID() + \": \" + sfmt.format(sol2.getTime()) + \", \" + lfmt.format(sol2.getTime()));\n@@ -136,1 +137,1 @@\n-                errln(tz.getID() + \": wrong short name: \\\"\" + s + \"\\\" (expected \\\"\" + data[i] + \"\\\")\");\n+                fail(tz.getID() + \": wrong short name: \\\"\" + s + \"\\\" (expected \\\"\" + data[i] + \"\\\")\");\n@@ -140,1 +141,1 @@\n-                errln(tz.getID() + \": wrong long name: \\\"\" + s + \"\\\" (expected \\\"\" + data[i] + \"\\\")\");\n+                fail(tz.getID() + \": wrong long name: \\\"\" + s + \"\\\" (expected \\\"\" + data[i] + \"\\\")\");\n@@ -144,1 +145,1 @@\n-                errln(tz.getID() + \": wrong short name: \\\"\" + s + \"\\\" (expected \\\"\" + data[i] + \"\\\")\");\n+                fail(tz.getID() + \": wrong short name: \\\"\" + s + \"\\\" (expected \\\"\" + data[i] + \"\\\")\");\n@@ -148,1 +149,1 @@\n-                errln(tz.getID() + \": wrong long name: \\\"\" + s + \"\\\" (expected \\\"\" + data[i] + \"\\\")\");\n+                fail(tz.getID() + \": wrong long name: \\\"\" + s + \"\\\" (expected \\\"\" + data[i] + \"\\\")\");\n","filename":"test\/jdk\/java\/text\/Format\/DateFormat\/TimeZoneNameTest.java","additions":22,"deletions":21,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,4 @@\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n@@ -31,1 +35,0 @@\n- * @library \/java\/text\/testlib\n@@ -33,0 +36,1 @@\n+ * @run junit bug4358730\n@@ -35,5 +39,1 @@\n-public class bug4358730 extends IntlTest {\n-\n-    public static void main(String[] args) throws Exception {\n-        new bug4358730().run(args);\n-    }\n+public class bug4358730 {\n@@ -53,0 +53,1 @@\n+    @Test\n@@ -68,1 +69,1 @@\n-                        errln(\"Invalid format : \" + sdf.format(d) +\n+                        fail(\"Invalid format : \" + sdf.format(d) +\n","filename":"test\/jdk\/java\/text\/Format\/DateFormat\/bug4358730.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,3 @@\n- * @build Bug4185816Test IntlTest HexDumpReader\n- * @run main Bug4185816Test\n- * @summary test that MessageFormat invariants are preserved across serialization\n+ * @build Bug4185816Test HexDumpReader\n+ * @run junit Bug4185816Test\n+ * @summary test that MessageFormat invariants are preserved across serialization.\n@@ -32,0 +32,1 @@\n+\n@@ -71,0 +72,4 @@\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n@@ -72,1 +77,1 @@\n- *  A Locale can never contains language codes of he, yi or id.\n+ *  A Locale can never contain language codes of he, yi or id.\n@@ -74,1 +79,1 @@\n-public class Bug4185816Test extends IntlTest {\n+public class Bug4185816Test {\n@@ -78,8 +83,1 @@\n-    public static void main(String[] args) throws Exception {\n-        if (args.length == 1 && args[0].equals(\"prepTest\")) {\n-            prepTest();\n-        } else {\n-            new Bug4185816Test().run(args);\n-        }\n-    }\n-\n+    @Test\n@@ -89,1 +87,1 @@\n-            errln(\"MessageFormat did not stream in valid stream: \"+e);\n+            fail(\"MessageFormat did not stream in valid stream: \"+e);\n@@ -94,1 +92,1 @@\n-            errln(\"MessageFormat did NOT detect corrupt stream: \"+e);\n+            fail(\"MessageFormat did NOT detect corrupt stream: \"+e);\n@@ -112,26 +110,0 @@\n-\n-    \/**\n-     * Create a data file for this test.  The data file must be corrupted by hand.\n-     *\/\n-    private static void prepTest() {\n-        writeFormatToFile(FILE_NAME);\n-        writeFormatToFile(CORRUPT_FILE_NAME);\n-    }\n-\n-    private static void writeFormatToFile(final String name) {\n-        try {\n-            ObjectOutputStream out = new ObjectOutputStream(\n-                    new FileOutputStream(name));\n-\n-            MessageFormat fmt = new MessageFormat(\"The disk \\\"{1}\\\" contains {0}.\");\n-            double[] filelimits = {0,1,2};\n-            String[] filepart = {\"no files\",\"one file\",\"{0,number} files\"};\n-            ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);\n-            fmt.setFormat(1,fileform); \/\/ NOT zero, see below\n-\n-            out.writeObject(fmt);\n-            out.close();\n-        } catch (Exception e) {\n-            System.out.println(e);\n-        }\n-    }\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/Bug4185816Test.java","additions":14,"deletions":42,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run main MessageRegression\n+ * @run junit MessageRegression\n@@ -56,1 +56,1 @@\n-public class MessageRegression extends IntlTest {\n+import org.junit.jupiter.api.Test;\n@@ -58,3 +58,3 @@\n-    public static void main(String[] args) throws Exception {\n-        new MessageRegression().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class MessageRegression {\n@@ -66,0 +66,1 @@\n+    @Test\n@@ -83,2 +84,2 @@\n-                errln(\"MessageFormat with one param test failed.\");\n-            logln(\"Formatted with one extra param : \" + tempBuffer);\n+                fail(\"MessageFormat with one param test failed.\");\n+            System.out.println(\"Formatted with one extra param : \" + tempBuffer);\n@@ -90,2 +91,2 @@\n-                errln(\"MessageFormat with no param test failed.\");\n-            logln(\"Formatted with no params : \" + tempBuffer);\n+                fail(\"MessageFormat with no param test failed.\");\n+            System.out.println(\"Formatted with no params : \" + tempBuffer);\n@@ -95,2 +96,2 @@\n-                errln(\"Formatted with arguments > subsitution failed. result = \" + tempBuffer.toString());\n-             logln(\"Formatted with extra params : \" + tempBuffer);\n+                fail(\"Formatted with arguments > subsitution failed. result = \" + tempBuffer.toString());\n+             System.out.println(\"Formatted with extra params : \" + tempBuffer);\n@@ -106,1 +107,1 @@\n-            errln(\"Exception when formatting with no params.\");\n+            fail(\"Exception when formatting with no params.\");\n@@ -113,0 +114,1 @@\n+    @Test\n@@ -118,1 +120,1 @@\n-            errln(\"MessageFormat.toPattern failed\");\n+            fail(\"MessageFormat.toPattern failed\");\n@@ -124,0 +126,1 @@\n+    @Test\n@@ -127,1 +130,1 @@\n-            logln(\"Skipping this test because locale is \" + locale);\n+            System.out.println(\"Skipping this test because locale is \" + locale);\n@@ -137,1 +140,1 @@\n-            logln(\"Apply with pattern : \" + pattern1);\n+            System.out.println(\"Apply with pattern : \" + pattern1);\n@@ -142,1 +145,1 @@\n-                errln(\"Tests arguments < substitution failed. Formatted text=\" +\n+                fail(\"Tests arguments < substitution failed. Formatted text=\" +\n@@ -144,1 +147,1 @@\n-            logln(\"Formatted with 7 : \" + tempBuffer);\n+            System.out.println(\"Formatted with 7 : \" + tempBuffer);\n@@ -148,1 +151,1 @@\n-                errln(\"Parse failed with more than expected arguments\");\n+                fail(\"Parse failed with more than expected arguments\");\n@@ -151,1 +154,1 @@\n-                    errln(\"Parse failed on object \" + objs[i] + \" at index : \" + i);\n+                    fail(\"Parse failed on object \" + objs[i] + \" at index : \" + i);\n@@ -156,3 +159,3 @@\n-                errln(\"Tests with no arguments failed\");\n-            logln(\"Formatted with null : \" + tempBuffer);\n-            logln(\"Apply with pattern : \" + pattern2);\n+                fail(\"Tests with no arguments failed\");\n+            System.out.println(\"Formatted with null : \" + tempBuffer);\n+            System.out.println(\"Apply with pattern : \" + pattern2);\n@@ -162,2 +165,2 @@\n-                errln(\"quote format test (w\/ params) failed.\");\n-            logln(\"Formatted with params : \" + tempBuffer);\n+                fail(\"quote format test (w\/ params) failed.\");\n+            System.out.println(\"Formatted with params : \" + tempBuffer);\n@@ -166,3 +169,3 @@\n-                errln(\"quote format test (w\/ null) failed.\");\n-            logln(\"Formatted with null : \" + tempBuffer);\n-            logln(\"toPattern : \" + messageFormatter.toPattern());\n+                fail(\"quote format test (w\/ null) failed.\");\n+            System.out.println(\"Formatted with null : \" + tempBuffer);\n+            System.out.println(\"toPattern : \" + messageFormatter.toPattern());\n@@ -170,1 +173,1 @@\n-            errln(\"Exception when formatting in bug 4031438. \"+foo.getMessage());\n+            fail(\"Exception when formatting in bug 4031438. \"+foo.getMessage());\n@@ -173,0 +176,1 @@\n+    @Test\n@@ -177,1 +181,1 @@\n-            errln(\"ParsePosition.getErrorIndex initialization failed.\");\n+            fail(\"ParsePosition.getErrorIndex initialization failed.\");\n@@ -182,1 +186,1 @@\n-        logln(\"unparsable string , should fail at \" + pos.getErrorIndex());\n+        System.out.println(\"unparsable string , should fail at \" + pos.getErrorIndex());\n@@ -184,1 +188,1 @@\n-            errln(\"Bug 4052223 failed : parsing string \" + str);\n+            fail(\"Bug 4052223 failed : parsing string \" + str);\n@@ -187,1 +191,1 @@\n-            errln(\"setErrorIndex failed, got \" + pos.getErrorIndex() + \" instead of 4\");\n+            fail(\"setErrorIndex failed, got \" + pos.getErrorIndex() + \" instead of 4\");\n@@ -193,1 +197,1 @@\n-            errln(\"Parse with \\\"are negative\\\" failed, at \" + pos.getErrorIndex());\n+            fail(\"Parse with \\\"are negative\\\" failed, at \" + pos.getErrorIndex());\n@@ -197,1 +201,1 @@\n-            errln(\"Parse with \\\"are no or fraction\\\" failed, at \" + pos.getErrorIndex());\n+            fail(\"Parse with \\\"are no or fraction\\\" failed, at \" + pos.getErrorIndex());\n@@ -201,1 +205,1 @@\n-            errln(\"Parse with \\\"go postal\\\" failed, at \" + pos.getErrorIndex());\n+            fail(\"Parse with \\\"go postal\\\" failed, at \" + pos.getErrorIndex());\n@@ -206,0 +210,1 @@\n+    @Test\n@@ -212,2 +217,2 @@\n-            log(\"Compares to null is always false, returned : \");\n-            logln(cf.equals(null) ? \"TRUE\" : \"FALSE\");\n+            System.out.println(\"Compares to null is always false, returned : \");\n+            System.out.println(cf.equals(null) ? \"TRUE\" : \"FALSE\");\n@@ -215,1 +220,1 @@\n-            errln(\"ChoiceFormat.equals(null) throws exception.\");\n+            fail(\"ChoiceFormat.equals(null) throws exception.\");\n@@ -222,0 +227,1 @@\n+    @Test\n@@ -230,1 +236,1 @@\n-            logln(\"ChoiceFormat constructor should check for the array lengths\");\n+            System.out.println(\"ChoiceFormat constructor should check for the array lengths\");\n@@ -233,1 +239,1 @@\n-        if (cf != null) errln(cf.format(5));\n+        if (cf != null) fail(cf.format(5));\n@@ -241,0 +247,1 @@\n+    @Test\n@@ -249,1 +256,1 @@\n-            errln(\"format(\" + d + \") = \" + cf.format(d));\n+            fail(\"format(\" + d + \") = \" + cf.format(d));\n@@ -255,0 +262,1 @@\n+    @Test\n@@ -267,1 +275,1 @@\n-            errln(\"Unexpected exception : \" + e.getMessage());\n+            fail(\"Unexpected exception : \" + e.getMessage());\n@@ -281,1 +289,1 @@\n-            errln(\"Unexpected exception : \" + e.getMessage());\n+            fail(\"Unexpected exception : \" + e.getMessage());\n@@ -285,1 +293,1 @@\n-            errln(\"MessageFormats before and after serialization are not\" +\n+            fail(\"MessageFormats before and after serialization are not\" +\n@@ -289,1 +297,1 @@\n-            logln(\"Serialization for MessageFormat is OK.\");\n+            System.out.println(\"Serialization for MessageFormat is OK.\");\n@@ -295,0 +303,1 @@\n+    @Test\n@@ -302,1 +311,1 @@\n-            errln(\"illegal pattern: \\\"\" + illegalPattern + \"\\\"\");\n+            fail(\"illegal pattern: \\\"\" + illegalPattern + \"\\\"\");\n@@ -305,1 +314,1 @@\n-                errln(\"pattern after: \\\"\" + mf.toPattern() + \"\\\"\");\n+                fail(\"pattern after: \\\"\" + mf.toPattern() + \"\\\"\");\n@@ -312,0 +321,1 @@\n+    @Test\n@@ -322,2 +332,2 @@\n-                logln(\"pattern: \\\"\" + pattern + \"\\\"\");\n-                log(\" parsedObjects: \");\n+                System.out.println(\"pattern: \\\"\" + pattern + \"\\\"\");\n+                System.out.println(\" parsedObjects: \");\n@@ -325,1 +335,1 @@\n-                    log(\"{\");\n+                    System.out.println(\"{\");\n@@ -328,1 +338,1 @@\n-                            err(\"\\\"\" + array[j].toString() + \"\\\"\");\n+                            fail(\"\\\"\" + array[j].toString() + \"\\\"\");\n@@ -330,2 +340,2 @@\n-                            log(\"null\");\n-                        if (j < array.length - 1) log(\",\");\n+                            System.out.println(\"null\");\n+                        if (j < array.length - 1) System.out.println(\",\");\n@@ -333,1 +343,1 @@\n-                    log(\"}\") ;\n+                    System.out.println(\"}\") ;\n@@ -335,1 +345,1 @@\n-                    log(\"null\");\n+                    System.out.println(\"null\");\n@@ -337,1 +347,1 @@\n-                logln(\"\");\n+                System.out.println(\"\");\n@@ -339,2 +349,2 @@\n-                errln(\"pattern: \\\"\" + pattern + \"\\\"\");\n-                errln(\"  Exception: \" + e.getMessage());\n+                fail(\"pattern: \\\"\" + pattern + \"\\\"\");\n+                fail(\"  Exception: \" + e.getMessage());\n@@ -348,0 +358,1 @@\n+    @Test\n@@ -356,7 +367,7 @@\n-            logln(\"pattern: \\\"\" + mf.toPattern() + \"\\\"\");\n-            log(\"format(null) : \");\n-            logln(\"\\\"\" + mf.format(objs1) + \"\\\"\");\n-            log(\"format({})   : \");\n-            logln(\"\\\"\" + mf.format(objs2) + \"\\\"\");\n-            log(\"format({null}) :\");\n-            logln(\"\\\"\" + mf.format(objs3) + \"\\\"\");\n+            System.out.println(\"pattern: \\\"\" + mf.toPattern() + \"\\\"\");\n+            System.out.println(\"format(null) : \");\n+            System.out.println(\"\\\"\" + mf.format(objs1) + \"\\\"\");\n+            System.out.println(\"format({})   : \");\n+            System.out.println(\"\\\"\" + mf.format(objs2) + \"\\\"\");\n+            System.out.println(\"format({null}) :\");\n+            System.out.println(\"\\\"\" + mf.format(objs3) + \"\\\"\");\n@@ -364,1 +375,1 @@\n-            errln(\"Exception thrown for null argument tests.\");\n+            fail(\"Exception thrown for null argument tests.\");\n@@ -371,0 +382,1 @@\n+    @Test\n@@ -376,2 +388,2 @@\n-        logln(\"pattern before: \\\"\" + mf.toPattern() + \"\\\"\");\n-        logln(\"illegal pattern: \\\"\" + illegalPattern + \"\\\"\");\n+        System.out.println(\"pattern before: \\\"\" + mf.toPattern() + \"\\\"\");\n+        System.out.println(\"illegal pattern: \\\"\" + illegalPattern + \"\\\"\");\n@@ -380,1 +392,1 @@\n-            errln(\"Should have thrown IllegalArgumentException for pattern : \" + illegalPattern);\n+            fail(\"Should have thrown IllegalArgumentException for pattern : \" + illegalPattern);\n@@ -383,1 +395,1 @@\n-                errln(\"pattern after: \\\"\" + mf.toPattern() + \"\\\"\");\n+                fail(\"pattern after: \\\"\" + mf.toPattern() + \"\\\"\");\n@@ -389,0 +401,1 @@\n+    @Test\n@@ -393,12 +406,12 @@\n-        logln(\"Formatter Pattern : \" + fmt.toPattern());\n-\n-        logln(\"Format with -INF : \" + fmt.format(Double.NEGATIVE_INFINITY));\n-        logln(\"Format with -1.0 : \" + fmt.format(-1.0));\n-        logln(\"Format with 0 : \" + fmt.format(0));\n-        logln(\"Format with 0.9 : \" + fmt.format(0.9));\n-        logln(\"Format with 1.0 : \" + fmt.format(1));\n-        logln(\"Format with 1.5 : \" + fmt.format(1.5));\n-        logln(\"Format with 2 : \" + fmt.format(2));\n-        logln(\"Format with 2.1 : \" + fmt.format(2.1));\n-        logln(\"Format with NaN : \" + fmt.format(Double.NaN));\n-        logln(\"Format with +INF : \" + fmt.format(Double.POSITIVE_INFINITY));\n+        System.out.println(\"Formatter Pattern : \" + fmt.toPattern());\n+\n+        System.out.println(\"Format with -INF : \" + fmt.format(Double.NEGATIVE_INFINITY));\n+        System.out.println(\"Format with -1.0 : \" + fmt.format(-1.0));\n+        System.out.println(\"Format with 0 : \" + fmt.format(0));\n+        System.out.println(\"Format with 0.9 : \" + fmt.format(0.9));\n+        System.out.println(\"Format with 1.0 : \" + fmt.format(1));\n+        System.out.println(\"Format with 1.5 : \" + fmt.format(1.5));\n+        System.out.println(\"Format with 2 : \" + fmt.format(2));\n+        System.out.println(\"Format with 2.1 : \" + fmt.format(2.1));\n+        System.out.println(\"Format with NaN : \" + fmt.format(Double.NaN));\n+        System.out.println(\"Format with +INF : \" + fmt.format(Double.POSITIVE_INFINITY));\n@@ -409,0 +422,1 @@\n+    @Test\n@@ -414,9 +428,9 @@\n-            errln(\"Formatter Pattern : \" + fmt.toPattern());\n-        logln(\"Format with -INF : \" + fmt.format(Double.NEGATIVE_INFINITY));\n-        logln(\"Format with -1.0 : \" + fmt.format(-1.0));\n-        logln(\"Format with 0 : \" + fmt.format(0));\n-        logln(\"Format with 0.9 : \" + fmt.format(0.9));\n-        logln(\"Format with 1.0 : \" + fmt.format(1));\n-        logln(\"Format with 1.5 : \" + fmt.format(1.5));\n-        logln(\"Format with 2 : \" + fmt.format(2));\n-        logln(\"Format with +INF : \" + fmt.format(Double.POSITIVE_INFINITY));\n+            fail(\"Formatter Pattern : \" + fmt.toPattern());\n+        System.out.println(\"Format with -INF : \" + fmt.format(Double.NEGATIVE_INFINITY));\n+        System.out.println(\"Format with -1.0 : \" + fmt.format(-1.0));\n+        System.out.println(\"Format with 0 : \" + fmt.format(0));\n+        System.out.println(\"Format with 0.9 : \" + fmt.format(0.9));\n+        System.out.println(\"Format with 1.0 : \" + fmt.format(1));\n+        System.out.println(\"Format with 1.5 : \" + fmt.format(1.5));\n+        System.out.println(\"Format with 2 : \" + fmt.format(2));\n+        System.out.println(\"Format with +INF : \" + fmt.format(Double.POSITIVE_INFINITY));\n@@ -428,0 +442,1 @@\n+    @Test\n@@ -438,4 +453,4 @@\n-            logln(i + \". pattern :\\\"\" + mf.toPattern() + \"\\\"\");\n-            log(\" \\\"\" + formatted + \"\\\" parsed as \");\n-            if (objs == null) logln(\"  null\");\n-            else logln(\"  \" + objs[0]);\n+            System.out.println(i + \". pattern :\\\"\" + mf.toPattern() + \"\\\"\");\n+            System.out.println(\" \\\"\" + formatted + \"\\\" parsed as \");\n+            if (objs == null) System.out.println(\"  null\");\n+            else System.out.println(\"  \" + objs[0]);\n@@ -447,0 +462,1 @@\n+    @Test\n@@ -452,2 +468,2 @@\n-        logln(\"pattern: \\\"\" + mf.toPattern() + \"\\\"\");\n-        logln(\"text for parsing: \\\"\" + forParsing + \"\\\"\");\n+        System.out.println(\"pattern: \\\"\" + mf.toPattern() + \"\\\"\");\n+        System.out.println(\"text for parsing: \\\"\" + forParsing + \"\\\"\");\n@@ -455,1 +471,1 @@\n-            errln(\"argument0: \\\"\" + objs[0] + \"\\\"\");\n+            fail(\"argument0: \\\"\" + objs[0] + \"\\\"\");\n@@ -460,2 +476,2 @@\n-        logln(\"pattern: \\\"\" + mf.toPattern() + \"\\\"\");\n-        logln(\"text for parsing: \\\"\" + result + \"\\\"\");\n+        System.out.println(\"pattern: \\\"\" + mf.toPattern() + \"\\\"\");\n+        System.out.println(\"text for parsing: \\\"\" + result + \"\\\"\");\n@@ -464,1 +480,1 @@\n-            errln(\"result = \" + result);\n+            fail(\"result = \" + result);\n@@ -468,1 +484,1 @@\n-            errln( \"newobjs[0] = \" + newobjs[0]);\n+            fail( \"newobjs[0] = \" + newobjs[0]);\n@@ -473,0 +489,1 @@\n+    @Test\n@@ -485,2 +502,2 @@\n-        logln(form1.format(testArgs));\n-        logln(form2.format(testArgs));\n+        System.out.println(form1.format(testArgs));\n+        System.out.println(form2.format(testArgs));\n@@ -491,0 +508,1 @@\n+    @Test\n@@ -495,1 +513,1 @@\n-        logln(\"pattern: \\\"\" + mf.toPattern() + \"\\\"\");\n+        System.out.println(\"pattern: \\\"\" + mf.toPattern() + \"\\\"\");\n@@ -499,1 +517,1 @@\n-            log(\"  text for parsing: \\\"\" + texts[i] + \"\\\"\");\n+            System.out.println(\"  text for parsing: \\\"\" + texts[i] + \"\\\"\");\n@@ -501,1 +519,1 @@\n-                logln(\"  (incorrectly formatted string)\");\n+                System.out.println(\"  (incorrectly formatted string)\");\n@@ -503,1 +521,1 @@\n-                    errln(\"Incorrect error index: \" + pp.getErrorIndex());\n+                    fail(\"Incorrect error index: \" + pp.getErrorIndex());\n@@ -505,1 +523,1 @@\n-                logln(\"  (correctly formatted string)\");\n+                System.out.println(\"  (correctly formatted string)\");\n@@ -516,0 +534,1 @@\n+    @Test\n@@ -537,1 +556,1 @@\n-                    errln(\"\" + i + \": Got \\\"\" + out + \"\\\"; Want \\\"\" + PREFIX[i] + \"\\\"\");\n+                    fail(\"\" + i + \": Got \\\"\" + out + \"\\\"; Want \\\"\" + PREFIX[i] + \"\\\"\");\n@@ -542,1 +561,1 @@\n-                    errln(\"\" + i + \": Got \\\"\" + out + \"\\\"; Want \\\"\" + PREFIX[i] + \"\\\"...\\\"\" +\n+                    fail(\"\" + i + \": Got \\\"\" + out + \"\\\"; Want \\\"\" + PREFIX[i] + \"\\\"...\\\"\" +\n@@ -556,0 +575,1 @@\n+    @Test\n@@ -569,1 +589,1 @@\n-                        errln(\"Fail: Pattern \\\"\" + DATA[i] + \"\\\" x \"+j+\" -> \" +\n+                        fail(\"Fail: Pattern \\\"\" + DATA[i] + \"\\\" x \"+j+\" -> \" +\n@@ -575,1 +595,1 @@\n-                    errln(\"Fail: Pattern \\\"\" + DATA[i] + \"\\\" x toPattern -> \\\"\" + pat + '\"');\n+                    fail(\"Fail: Pattern \\\"\" + DATA[i] + \"\\\" x toPattern -> \\\"\" + pat + '\"');\n@@ -577,1 +597,1 @@\n-                    logln(\"Ok: Pattern \\\"\" + DATA[i] + \"\\\" x toPattern -> \\\"\" + pat + '\"');\n+                    System.out.println(\"Ok: Pattern \\\"\" + DATA[i] + \"\\\" x toPattern -> \\\"\" + pat + '\"');\n@@ -580,1 +600,1 @@\n-                errln(\"Fail: Pattern \\\"\" + DATA[i] + \"\\\" -> \" + e);\n+                fail(\"Fail: Pattern \\\"\" + DATA[i] + \"\\\" -> \" + e);\n@@ -590,0 +610,1 @@\n+    @Test\n@@ -596,1 +617,1 @@\n-                errln(\"MessageFormat.equals(null) returns false\");\n+                fail(\"MessageFormat.equals(null) returns false\");\n@@ -600,1 +621,1 @@\n-            errln(\"MessageFormat.equals(null) throws \" + e);\n+            fail(\"MessageFormat.equals(null) throws \" + e);\n@@ -608,0 +629,1 @@\n+    @Test\n@@ -610,1 +632,1 @@\n-        logln(MessageFormat.format( \"This will {0}\", \"work\"));\n+        System.out.println(MessageFormat.format( \"This will {0}\", \"work\"));\n@@ -613,1 +635,1 @@\n-        logln(MessageFormat.format( \"This will {0}\",\n+        System.out.println(MessageFormat.format( \"This will {0}\",\n@@ -617,0 +639,1 @@\n+    @Test\n@@ -635,0 +658,1 @@\n+    @Test\n@@ -650,0 +674,1 @@\n+    @Test\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/MessageRegression.java","additions":145,"deletions":120,"binary":false,"changes":265,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @library \/java\/text\/testlib\n@@ -28,0 +27,1 @@\n+ * @run junit MessageTest\n@@ -46,1 +46,1 @@\n-public class MessageTest extends IntlTest {\n+import org.junit.jupiter.api.Test;\n@@ -48,3 +48,3 @@\n-    public static void main(String[] args) throws Exception {\n-        new MessageTest().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class MessageTest {\n@@ -53,0 +53,1 @@\n+    @Test\n@@ -74,2 +75,2 @@\n-                logln(\"\");\n-                logln( i + \" Pat in:  \" + testCases[i]);\n+                System.out.println(\"\");\n+                System.out.println( i + \" Pat in:  \" + testCases[i]);\n@@ -77,1 +78,1 @@\n-                logln( i + \" Pat out: \" + form.toPattern());\n+                System.out.println( i + \" Pat out: \" + form.toPattern());\n@@ -79,1 +80,1 @@\n-                logln( i + \" Result:  \" + result);\n+                System.out.println( i + \" Result:  \" + result);\n@@ -89,2 +90,2 @@\n-                       logln( i + \" \" + j + \" old: \" + testArg);\n-                       logln( i + \" \" + j + \" new: \" + value);\n+                       System.out.println( i + \" \" + j + \" old: \" + testArg);\n+                       System.out.println( i + \" \" + j + \" new: \" + value);\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/MessageTest.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @library \/java\/text\/testlib\n@@ -30,0 +29,1 @@\n+ * @run junit\/othervm bug4492719\n@@ -35,1 +35,2 @@\n-public class bug4492719 extends IntlTest {\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n@@ -37,1 +38,8 @@\n-    public static void main(String[] args) throws Exception {\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class bug4492719 {\n+\n+    \/\/ MessageFormat.parse() should be able to interpret a time zone\n+    \/\/ that uses \"GMT+\/-\".\n+    @Test\n+    public void testParse() throws Exception {\n@@ -44,1 +52,1 @@\n-            \"short\", \"medium\", \"long\", \"full\"\n+                \"short\", \"medium\", \"long\", \"full\"\n@@ -47,2 +55,2 @@\n-            \"America\/Los_Angeles\", \"GMT\", \"GMT+09:00\", \"GMT-8:00\",\n-            \"GMT+123\", \"GMT-1234\", \"GMT+2\", \"GMT-13\"\n+                \"America\/Los_Angeles\", \"GMT\", \"GMT+09:00\", \"GMT-8:00\",\n+                \"GMT+123\", \"GMT-1234\", \"GMT+2\", \"GMT-13\"\n@@ -61,1 +69,1 @@\n-                                      new Object [] { new Date(123456789012L)});\n+                            new Object [] { new Date(123456789012L)});\n@@ -68,1 +76,1 @@\n-                               e.getMessage());\n+                    e.getMessage());\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/bug4492719.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n- * @library \/java\/text\/testlib\n- * @run main\/othervm -Djava.locale.providers=COMPAT,SPI BigDecimalFormat\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT,SPI BigDecimalFormat\n@@ -34,2 +33,5 @@\n-import java.text.*;\n-import java.util.*;\n+import java.text.DecimalFormat;\n+import java.text.FieldPosition;\n+import java.text.MessageFormat;\n+import java.text.NumberFormat;\n+import java.util.Locale;\n@@ -37,1 +39,1 @@\n-public class BigDecimalFormat extends IntlTest {\n+import org.junit.jupiter.api.Test;\n@@ -39,3 +41,3 @@\n-    public static void main(String[] args) throws Exception {\n-        new BigDecimalFormat().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class BigDecimalFormat {\n@@ -102,0 +104,1 @@\n+    @Test\n@@ -523,0 +526,1 @@\n+    @Test\n@@ -583,0 +587,1 @@\n+    @Test\n@@ -723,0 +728,1 @@\n+    @Test\n@@ -778,0 +784,1 @@\n+    @Test\n@@ -893,0 +900,1 @@\n+    @Test\n@@ -935,0 +943,1 @@\n+    @Test\n@@ -967,0 +976,1 @@\n+    @Test\n@@ -1001,1 +1011,1 @@\n-            errln(\"Wrong format.\\n      got:\\n\" + mf.format(testArgs) +\n+            fail(\"Wrong format.\\n      got:\\n\" + mf.format(testArgs) +\n@@ -1017,1 +1027,1 @@\n-            errln(\"Formatting... failed.\" +\n+            fail(\"Formatting... failed.\" +\n@@ -1030,1 +1040,1 @@\n-            errln(\"Formatting... wrong Begin index returned for \" +\n+            fail(\"Formatting... wrong Begin index returned for \" +\n@@ -1037,1 +1047,1 @@\n-            errln(\"Formatting... wrong End index returned for \" +\n+            fail(\"Formatting... wrong End index returned for \" +\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/BigDecimalFormat.java","additions":23,"deletions":13,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n- * @library \/java\/text\/testlib\n- * @run main\/othervm -Djava.locale.providers=COMPAT,SPI BigDecimalParse\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT,SPI BigDecimalParse\n@@ -36,1 +35,2 @@\n-public class BigDecimalParse extends IntlTest {\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n@@ -38,9 +38,8 @@\n-    public static void main(String[] args) throws Exception {\n-        Locale loc = Locale.getDefault();\n-        try {\n-            Locale.setDefault(Locale.US);\n-            new BigDecimalParse().run(args);\n-        } finally {\n-            \/\/ restore the reserved locale\n-            Locale.setDefault(loc);\n-        }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class BigDecimalParse {\n+\n+    \/\/ Change JVM default Locale\n+    @BeforeAll\n+    static void initAll() {\n+        Locale.setDefault(Locale.US);\n@@ -49,0 +48,1 @@\n+\n@@ -111,1 +111,2 @@\n-    void test_Parse_in_DecimalFormat_BigDecimal() {\n+    @Test\n+    public void test_Parse_in_DecimalFormat_BigDecimal() {\n@@ -153,1 +154,2 @@\n-    void test_Parse_in_DecimalFormat_BigDecimal_usingMultiplier() {\n+    @Test\n+    public void test_Parse_in_DecimalFormat_BigDecimal_usingMultiplier() {\n@@ -195,1 +197,2 @@\n-    void test_Parse_in_DecimalFormat_BigDecimal_DivisionByZero() {\n+    @Test\n+    public void test_Parse_in_DecimalFormat_BigDecimal_DivisionByZero() {\n@@ -216,1 +219,2 @@\n-    void test_Parse_in_DecimalFormat_Double_DivisionByZero() {\n+    @Test\n+    public void test_Parse_in_DecimalFormat_Double_DivisionByZero() {\n@@ -253,1 +257,2 @@\n-    void test_Parse_in_DecimalFormat_Long_DivisionByZero() {\n+    @Test\n+    public void test_Parse_in_DecimalFormat_Long_DivisionByZero() {\n@@ -274,1 +279,2 @@\n-    void test_Parse_in_DecimalFormat_BigInteger() {\n+    @Test\n+    public void test_Parse_in_DecimalFormat_BigInteger() {\n@@ -299,1 +305,2 @@\n-    void test_Parse_in_DecimalFormat_BigInteger_usingMultiplier() {\n+    @Test\n+    public void test_Parse_in_DecimalFormat_BigInteger_usingMultiplier() {\n@@ -340,1 +347,2 @@\n-    void test_Parse_in_DecimalFormat_SpecialNumber() {\n+    @Test\n+    public void test_Parse_in_DecimalFormat_SpecialNumber() {\n@@ -381,1 +389,2 @@\n-    void test_Parse_in_DecimalFormat_Other() {\n+    @Test\n+    public void test_Parse_in_DecimalFormat_Other() {\n@@ -475,1 +484,2 @@\n-    void test_Parse_in_MessageFormat_NotParseIntegerOnly() {\n+    @Test\n+    public void test_Parse_in_MessageFormat_NotParseIntegerOnly() {\n@@ -490,1 +500,1 @@\n-                    errln(\"Case\" + (i+1) +\n+                    fail(\"Case\" + (i+1) +\n@@ -495,1 +505,1 @@\n-                    errln(\"Case\" + (i+1) +\n+                    fail(\"Case\" + (i+1) +\n@@ -502,1 +512,1 @@\n-                errln(\"Unexpected exception: \" + e.getMessage());\n+                fail(\"Unexpected exception: \" + e.getMessage());\n@@ -561,1 +571,2 @@\n-    void test_Parse_in_MessageFormat_ParseIntegerOnly() {\n+    @Test\n+    public void test_Parse_in_MessageFormat_ParseIntegerOnly() {\n@@ -577,1 +588,1 @@\n-                    errln(\"Case\" + (i+1) +\n+                    fail(\"Case\" + (i+1) +\n@@ -583,1 +594,1 @@\n-                    errln(\"Case\" + (i+1) +\n+                    fail(\"Case\" + (i+1) +\n@@ -590,1 +601,1 @@\n-                errln(\"Unexpected exception: \" + e.getMessage());\n+                fail(\"Unexpected exception: \" + e.getMessage());\n@@ -627,1 +638,2 @@\n-    void test_Parse_in_DecimalFormat_ParseIntegerOnly() {\n+    @Test\n+    public void test_Parse_in_DecimalFormat_ParseIntegerOnly() {\n@@ -639,1 +651,1 @@\n-                    errln(\"Case\" + (i+1) +\n+                    fail(\"Case\" + (i+1) +\n@@ -645,1 +657,1 @@\n-                    errln(\"Case\" + (i+1) +\n+                    fail(\"Case\" + (i+1) +\n@@ -652,1 +664,1 @@\n-                errln(\"Unexpected exception: \" + e.getMessage());\n+                fail(\"Unexpected exception: \" + e.getMessage());\n@@ -670,1 +682,1 @@\n-            errln(e.getMessage());\n+            fail(e.getMessage());\n@@ -681,1 +693,1 @@\n-            errln(\"Parsing... failed.\" +\n+            fail(\"Parsing... failed.\" +\n@@ -690,1 +702,1 @@\n-            errln(\"Parsing... unexpected Class returned.\" +\n+            fail(\"Parsing... unexpected Class returned.\" +\n@@ -699,1 +711,1 @@\n-            errln(\"Parsing... wrong ParsePosition returned.\" +\n+            fail(\"Parsing... wrong ParsePosition returned.\" +\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/BigDecimalParse.java","additions":50,"deletions":38,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n- * @library \/java\/text\/testlib\n- * @run main\/othervm -Djava.locale.providers=COMPAT,SPI Bug4838107\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT,SPI Bug4838107\n@@ -36,1 +35,5 @@\n-public class Bug4838107 extends IntlTest {\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class Bug4838107 {\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug4838107.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -27,1 +27,0 @@\n- * @library \/java\/text\/testlib\n@@ -31,0 +30,1 @@\n+ * @run junit DFSExponential\n@@ -33,2 +33,3 @@\n-import java.util.*;\n-import java.text.*;\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.Locale;\n@@ -36,2 +37,1 @@\n-public class DFSExponential extends IntlTest\n-{\n+import org.junit.jupiter.api.Test;\n@@ -39,3 +39,1 @@\n-    public static void main(String[] args) throws Exception {\n-        new DFSExponential().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n@@ -43,0 +41,1 @@\n+public class DFSExponential {\n@@ -44,1 +43,2 @@\n-   public void DFSExponenTest() throws Exception {\n+    @Test\n+    public void TestDFSExponential() {\n@@ -46,4 +46,3 @@\n-        String pat[] = { \"0.####E0\", \"00.000E00\", \"##0.####E000\", \"0.###E0;[0.###E0]\"  };\n-        double val[] = { 0.01234, 123456789, 1.23e300, -3.141592653e-271 };\n-        long lval[] = { 0, -1, 1, 123456789 };\n-        String valFormat[][] = {\n+        String[] pat = { \"0.####E0\", \"00.000E00\", \"##0.####E000\", \"0.###E0;[0.###E0]\"};\n+        double[] val = { 0.01234, 123456789, 1.23e300, -3.141592653e-271};\n+        String[][] valFormat = {\n@@ -55,4 +54,1 @@\n-\n-\n-        int ival = 0, ilval = 0;\n-        logln(\"Default exponent separator: \"+sym.getExponentSeparator());\n+        System.out.println(\"Default exponent separator: \"+sym.getExponentSeparator());\n@@ -62,2 +58,1 @@\n-            errln(\"null String was passed to set an exponent separator symbol\");\n-            throw new RuntimeException(\"Test Malfunction: null String was passed to set an exponent separator symbol\" );\n+            fail(\"null String was passed to set an exponent separator symbol\");\n@@ -65,1 +60,1 @@\n-        logln(\"Current exponent separator: \"+sym.getExponentSeparator());\n+        System.out.println(\"Current exponent separator: \"+sym.getExponentSeparator());\n@@ -69,1 +64,1 @@\n-            logln(\"     Pattern: \" + fmt.toPattern());\n+            System.out.println(\"     Pattern: \" + fmt.toPattern());\n@@ -71,4 +66,1 @@\n-            logln(\"     Localized pattern: \"+locPattern);\n-            \/\/fmt.applyLocalizedPattern(locPattern);\n-            \/\/System.out.println(\"      fmt.applyLocalizedPattern(): \"+fmt.toLocalizedPattern());\n-\n+            System.out.println(\"     Localized pattern: \"+locPattern);\n@@ -77,6 +69,5 @@\n-                logln(\"         \" + val[v]+\" --> \"+s);\n-                if(valFormat[p][v].equals(s)){\n-                    logln(\": Passed\");\n-                }else{\n-                   errln(\" Failed: Should be formatted as \"+valFormat[p][v]+ \"but got \"+s);\n-                   throw new RuntimeException(\" Failed: Should be formatted as \"+valFormat[p][v]+ \"but got \"+s);\n+                System.out.println(\"         \" + val[v]+\" --> \"+s);\n+                if (valFormat[p][v].equals(s)){\n+                    System.out.println(\": Passed\");\n+                } else{\n+                   fail(\" Failed: Should be formatted as \"+valFormat[p][v]+ \"but got \"+s);\n@@ -85,2 +76,2 @@\n-         } \/\/end of the first for loop\n-   }\n+         }\n+    }\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/DFSExponential.java","additions":26,"deletions":35,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * @build DFSSerialization IntlTest HexDumpReader\n- * @run main DFSSerialization\n+ * @build DFSSerialization HexDumpReader\n+ * @run junit DFSSerialization\n@@ -46,4 +46,7 @@\n-public class DFSSerialization extends IntlTest{\n-    public static void main(String[] args) throws Exception {\n-        new DFSSerialization().run(args);\n-    }\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class DFSSerialization{\n+\n+    @Test\n@@ -59,1 +62,1 @@\n-                logln(\" Deserialization of JDK1.4.2 Object from the current JDK: Passed.\");\n+                System.out.println(\" Deserialization of JDK1.4.2 Object from the current JDK: Passed.\");\n@@ -61,1 +64,1 @@\n-                errln(\" Deserialization of JDK1.4.2 Object from the current JDK was Failed:\"\n+                fail(\" Deserialization of JDK1.4.2 Object from the current JDK was Failed:\"\n@@ -82,1 +85,1 @@\n-                logln(\" Deserialization of current JDK Object from the current JDK: Passed.\");\n+                System.out.println(\" Deserialization of current JDK Object from the current JDK: Passed.\");\n@@ -84,1 +87,1 @@\n-                errln(\" Deserialization of current JDK Object from the current JDK was Failed:\"\n+                fail(\" Deserialization of current JDK Object from the current JDK was Failed:\"\n@@ -105,1 +108,1 @@\n-            logln(\" Trying to set exponent separator with null: Passed.\");\n+            System.out.println(\" Trying to set exponent separator with null: Passed.\");\n@@ -109,1 +112,1 @@\n-            errln(\"  Trying to set exponent separator with null:Failed.\");\n+            fail(\"  Trying to set exponent separator with null:Failed.\");\n@@ -127,1 +130,1 @@\n-            errln(\"Test Malfunction in DFSSerialization: Exception while reading the object\");\n+            fail(\"Test Malfunction in DFSSerialization: Exception while reading the object\");\n@@ -140,2 +143,2 @@\n-        logln(\" The special exponent separator is set : \"  + dfs.getExponentSeparator());\n-        logln(\" The special currency symbol is set : \"  + dfs.getCurrencySymbol());\n+        System.out.println(\" The special exponent separator is set : \"  + dfs.getExponentSeparator());\n+        System.out.println(\" The special currency symbol is set : \"  + dfs.getCurrencySymbol());\n@@ -151,1 +154,1 @@\n-            errln(\"Test Malfunction in DFSSerialization: Exception while creating an object\");\n+            fail(\"Test Malfunction in DFSSerialization: Exception while creating an object\");\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/DFSSerialization.java","additions":20,"deletions":17,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @library \/java\/text\/testlib\n@@ -28,0 +27,1 @@\n+ * @run junit IntlTestDecimalFormatAPI\n@@ -44,5 +44,1 @@\n-public class IntlTestDecimalFormatAPI extends IntlTest\n-{\n-    public static void main(String[] args)  throws Exception {\n-        new IntlTestDecimalFormatAPI().run(args);\n-    }\n+import org.junit.jupiter.api.Test;\n@@ -50,0 +46,4 @@\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class IntlTestDecimalFormatAPI\n+{\n@@ -51,0 +51,1 @@\n+    @Test\n@@ -55,1 +56,1 @@\n-            logln(\"DecimalFormat API test---\"); logln(\"\");\n+            System.out.println(\"DecimalFormat API test---\"); System.out.println(\"\");\n@@ -60,1 +61,1 @@\n-            logln(\"Testing DecimalFormat constructors\");\n+            System.out.println(\"Testing DecimalFormat constructors\");\n@@ -70,1 +71,1 @@\n-                errln(\"ERROR: Could not create DecimalFormat (pattern)\");\n+                fail(\"ERROR: Could not create DecimalFormat (pattern)\");\n@@ -80,1 +81,1 @@\n-            logln(\"Testing clone() and equality operators\");\n+            System.out.println(\"Testing clone() and equality operators\");\n@@ -84,1 +85,1 @@\n-                errln(\"ERROR: Clone() failed\");\n+                fail(\"ERROR: Clone() failed\");\n@@ -89,1 +90,1 @@\n-            logln(\"Testing various format() methods\");\n+            System.out.println(\"Testing various format() methods\");\n@@ -97,1 +98,1 @@\n-            logln(\"\" + d + \" is the double value\");\n+            System.out.println(\"\" + d + \" is the double value\");\n@@ -109,1 +110,1 @@\n-            logln(\"\" + d + \" formatted to \" + res1);\n+            System.out.println(\"\" + d + \" formatted to \" + res1);\n@@ -112,1 +113,1 @@\n-            logln(\"\" + l + \" formatted to \" + res2);\n+            System.out.println(\"\" + l + \" formatted to \" + res2);\n@@ -115,1 +116,1 @@\n-            logln(\"\" + d + \" formatted to \" + res3);\n+            System.out.println(\"\" + d + \" formatted to \" + res3);\n@@ -118,1 +119,1 @@\n-            logln(\"\" + l + \" formatted to \" + res4);\n+            System.out.println(\"\" + l + \" formatted to \" + res4);\n@@ -122,1 +123,1 @@\n-            logln(\"Testing parse()\");\n+            System.out.println(\"Testing parse()\");\n@@ -130,1 +131,1 @@\n-                errln(\"ERROR: Roundtrip failed (via parse(\" +\n+                fail(\"ERROR: Roundtrip failed (via parse(\" +\n@@ -133,1 +134,1 @@\n-            logln(text + \" parsed into \" + (long) d2);\n+            System.out.println(text + \" parsed into \" + (long) d2);\n@@ -137,1 +138,1 @@\n-            logln(\"Testing getters and setters\");\n+            System.out.println(\"Testing getters and setters\");\n@@ -143,1 +144,1 @@\n-                errln(\"ERROR: set DecimalFormatSymbols() failed\");\n+                fail(\"ERROR: set DecimalFormatSymbols() failed\");\n@@ -149,1 +150,1 @@\n-            logln(\"Positive prefix (should be +): \" + posPrefix);\n+            System.out.println(\"Positive prefix (should be +): \" + posPrefix);\n@@ -151,1 +152,1 @@\n-                errln(\"ERROR: setPositivePrefix() failed\");\n+                fail(\"ERROR: setPositivePrefix() failed\");\n@@ -157,1 +158,1 @@\n-            logln(\"Negative prefix (should be -): \" + negPrefix);\n+            System.out.println(\"Negative prefix (should be -): \" + negPrefix);\n@@ -159,1 +160,1 @@\n-                errln(\"ERROR: setNegativePrefix() failed\");\n+                fail(\"ERROR: setNegativePrefix() failed\");\n@@ -165,1 +166,1 @@\n-            logln(\"Positive suffix (should be _): \" + posSuffix);\n+            System.out.println(\"Positive suffix (should be _): \" + posSuffix);\n@@ -167,1 +168,1 @@\n-                errln(\"ERROR: setPositiveSuffix() failed\");\n+                fail(\"ERROR: setPositiveSuffix() failed\");\n@@ -173,1 +174,1 @@\n-            logln(\"Negative suffix (should be ~): \" + negSuffix);\n+            System.out.println(\"Negative suffix (should be ~): \" + negSuffix);\n@@ -175,1 +176,1 @@\n-                errln(\"ERROR: setNegativeSuffix() failed\");\n+                fail(\"ERROR: setNegativeSuffix() failed\");\n@@ -181,1 +182,1 @@\n-            logln(\"Multiplier (should be 8): \" + multiplier);\n+            System.out.println(\"Multiplier (should be 8): \" + multiplier);\n@@ -183,1 +184,1 @@\n-                errln(\"ERROR: setMultiplier() failed\");\n+                fail(\"ERROR: setMultiplier() failed\");\n@@ -189,1 +190,1 @@\n-            logln(\"Grouping size (should be 2): \" + (long) groupingSize);\n+            System.out.println(\"Grouping size (should be 2): \" + (long) groupingSize);\n@@ -191,1 +192,1 @@\n-                errln(\"ERROR: setGroupingSize() failed\");\n+                fail(\"ERROR: setGroupingSize() failed\");\n@@ -196,1 +197,1 @@\n-            logln(\"DecimalSeparatorIsAlwaysShown (should be true) is \" +\n+            System.out.println(\"DecimalSeparatorIsAlwaysShown (should be true) is \" +\n@@ -199,1 +200,1 @@\n-                errln(\"ERROR: setDecimalSeparatorAlwaysShown() failed\");\n+                fail(\"ERROR: setDecimalSeparatorAlwaysShown() failed\");\n@@ -204,1 +205,1 @@\n-            logln(\"Pattern is \" + funkyPat);\n+            System.out.println(\"Pattern is \" + funkyPat);\n@@ -208,1 +209,1 @@\n-            logln(\"Localized pattern is \" + locPat);\n+            System.out.println(\"Localized pattern is \" + locPat);\n@@ -212,1 +213,1 @@\n-            logln(\"Testing applyPattern()\");\n+            System.out.println(\"Testing applyPattern()\");\n@@ -215,1 +216,1 @@\n-            logln(\"Applying pattern \" + p1);\n+            System.out.println(\"Applying pattern \" + p1);\n@@ -219,1 +220,1 @@\n-            logln(\"Extracted pattern is \" + s2);\n+            System.out.println(\"Extracted pattern is \" + s2);\n@@ -221,1 +222,1 @@\n-                errln(\"ERROR: toPattern() result did not match \" +\n+                fail(\"ERROR: toPattern() result did not match \" +\n@@ -226,1 +227,1 @@\n-            logln(\"Applying pattern \" + p2);\n+            System.out.println(\"Applying pattern \" + p2);\n@@ -230,1 +231,1 @@\n-            logln(\"Extracted pattern is \" + s3);\n+            System.out.println(\"Extracted pattern is \" + s3);\n@@ -232,1 +233,1 @@\n-                errln(\"ERROR: toLocalizedPattern() result did not match \" +\n+                fail(\"ERROR: toLocalizedPattern() result did not match \" +\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/IntlTestDecimalFormatAPI.java","additions":47,"deletions":46,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @library \/java\/text\/testlib\n@@ -29,0 +28,1 @@\n+ * @run junit IntlTestDecimalFormatSymbols\n@@ -45,5 +45,1 @@\n-public class IntlTestDecimalFormatSymbols extends IntlTest\n-{\n-    public static void main(String[] args) throws Exception {\n-        new IntlTestDecimalFormatSymbols().run(args);\n-    }\n+import org.junit.jupiter.api.Test;\n@@ -51,0 +47,4 @@\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class IntlTestDecimalFormatSymbols\n+{\n@@ -52,0 +52,1 @@\n+    @Test\n@@ -59,1 +60,1 @@\n-            errln(\"ERROR: English DecimalFormatSymbols equal to French\");\n+            fail(\"ERROR: English DecimalFormatSymbols equal to French\");\n@@ -65,1 +66,1 @@\n-            errln(\"ERROR: French DecimalFormatSymbols not Locale.FRENCH\");\n+            fail(\"ERROR: French DecimalFormatSymbols not Locale.FRENCH\");\n@@ -69,1 +70,1 @@\n-            errln(\"ERROR: English DecimalFormatSymbols not Locale.ENGLISH\");\n+            fail(\"ERROR: English DecimalFormatSymbols not Locale.ENGLISH\");\n@@ -75,1 +76,1 @@\n-            errln(\"ERROR: get\/set ZeroDigit failed\");\n+            fail(\"ERROR: get\/set ZeroDigit failed\");\n@@ -81,1 +82,1 @@\n-            errln(\"ERROR: get\/set GroupingSeparator failed\");\n+            fail(\"ERROR: get\/set GroupingSeparator failed\");\n@@ -87,1 +88,1 @@\n-            errln(\"ERROR: get\/set DecimalSeparator failed\");\n+            fail(\"ERROR: get\/set DecimalSeparator failed\");\n@@ -93,1 +94,1 @@\n-            errln(\"ERROR: get\/set PerMill failed\");\n+            fail(\"ERROR: get\/set PerMill failed\");\n@@ -99,1 +100,1 @@\n-            errln(\"ERROR: get\/set Percent failed\");\n+            fail(\"ERROR: get\/set Percent failed\");\n@@ -105,1 +106,1 @@\n-            errln(\"ERROR: get\/set Percent failed\");\n+            fail(\"ERROR: get\/set Percent failed\");\n@@ -111,1 +112,1 @@\n-            errln(\"ERROR: get\/set PatternSeparator failed\");\n+            fail(\"ERROR: get\/set PatternSeparator failed\");\n@@ -118,1 +119,1 @@\n-            errln(\"ERROR: get\/set Infinity failed\");\n+            fail(\"ERROR: get\/set Infinity failed\");\n@@ -125,1 +126,1 @@\n-            errln(\"ERROR: get\/set NaN failed\");\n+            fail(\"ERROR: get\/set NaN failed\");\n@@ -131,1 +132,1 @@\n-            errln(\"ERROR: get\/set MinusSign failed\");\n+            fail(\"ERROR: get\/set MinusSign failed\");\n@@ -145,1 +146,1 @@\n-            errln(\"ERROR: Clone failed\");\n+            fail(\"ERROR: Clone failed\");\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/IntlTestDecimalFormatSymbols.java","additions":22,"deletions":21,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @library \/java\/text\/testlib\n@@ -29,0 +28,1 @@\n+ * @run junit IntlTestNumberFormatAPI\n@@ -45,5 +45,1 @@\n-public class IntlTestNumberFormatAPI extends IntlTest\n-{\n-    public static void main(String[] args) throws Exception {\n-        new IntlTestNumberFormatAPI().run(args);\n-    }\n+import org.junit.jupiter.api.Test;\n@@ -51,0 +47,4 @@\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class IntlTestNumberFormatAPI\n+{\n@@ -52,0 +52,1 @@\n+    @Test\n@@ -56,1 +57,1 @@\n-            logln(\"NumberFormat API test---\"); logln(\"\");\n+            System.out.println(\"NumberFormat API test---\"); System.out.println(\"\");\n@@ -61,1 +62,1 @@\n-            logln(\"Testing NumberFormat constructors\");\n+            System.out.println(\"Testing NumberFormat constructors\");\n@@ -79,1 +80,1 @@\n-            logln(\"Testing equality operator\");\n+            System.out.println(\"Testing equality operator\");\n@@ -82,1 +83,1 @@\n-                errln(\"ERROR: == failed\");\n+                fail(\"ERROR: == failed\");\n@@ -87,1 +88,1 @@\n-            logln(\"Testing various format() methods\");\n+            System.out.println(\"Testing various format() methods\");\n@@ -108,1 +109,1 @@\n-            logln( \"\" + d + \" formatted to \" + res1);\n+            System.out.println( \"\" + d + \" formatted to \" + res1);\n@@ -111,1 +112,1 @@\n-            logln(\"\" + l + \" formatted to \" + res2);\n+            System.out.println(\"\" + l + \" formatted to \" + res2);\n@@ -114,1 +115,1 @@\n-            logln( \"\" + d + \" formatted to \" + res3);\n+            System.out.println( \"\" + d + \" formatted to \" + res3);\n@@ -117,1 +118,1 @@\n-            logln(\"\" + l + \" formatted to \" + res4);\n+            System.out.println(\"\" + l + \" formatted to \" + res4);\n@@ -120,1 +121,1 @@\n-            logln(\"\" + d + \" formatted to \" + res5);\n+            System.out.println(\"\" + d + \" formatted to \" + res5);\n@@ -123,1 +124,1 @@\n-            logln(\"\" + l + \" formatted to \" + res6);\n+            System.out.println(\"\" + l + \" formatted to \" + res6);\n@@ -128,1 +129,1 @@\n-            logln(\"Testing parse()\");\n+            System.out.println(\"Testing parse()\");\n@@ -136,1 +137,1 @@\n-                errln(\"ERROR: Roundtrip failed (via parse()) for \" + text);\n+                fail(\"ERROR: Roundtrip failed (via parse()) for \" + text);\n@@ -138,1 +139,1 @@\n-            logln(text + \" parsed into \" + d1);\n+            System.out.println(text + \" parsed into \" + d1);\n@@ -142,1 +143,1 @@\n-                errln(\"ERROR: Roundtrip failed (via parse()) for \" + text);\n+                fail(\"ERROR: Roundtrip failed (via parse()) for \" + text);\n@@ -144,1 +145,1 @@\n-            logln(text + \" parsed into \" + d2);\n+            System.out.println(text + \" parsed into \" + d2);\n@@ -151,1 +152,1 @@\n-                errln(\"ERROR: parse() failed\");\n+                fail(\"ERROR: parse() failed\");\n@@ -154,1 +155,1 @@\n-                errln(\"ERROR: Roundtrip failed (via parse()) for \" + text);\n+                fail(\"ERROR: Roundtrip failed (via parse()) for \" + text);\n@@ -156,1 +157,1 @@\n-            logln(text + \" parsed into \" + d3);\n+            System.out.println(text + \" parsed into \" + d3);\n@@ -161,1 +162,1 @@\n-            logln(\"Testing getters and setters\");\n+            System.out.println(\"Testing getters and setters\");\n@@ -165,1 +166,1 @@\n-            logln(\"Got \" + count + \" locales\" );\n+            System.out.println(\"Got \" + count + \" locales\" );\n@@ -169,1 +170,1 @@\n-                logln(name);\n+                System.out.println(name);\n@@ -174,1 +175,1 @@\n-                    errln(\"ERROR: setParseIntegerOnly() failed\");\n+                    fail(\"ERROR: setParseIntegerOnly() failed\");\n@@ -179,1 +180,1 @@\n-                    errln(\"ERROR: setGroupingUsed() failed\");\n+                    fail(\"ERROR: setGroupingUsed() failed\");\n@@ -184,1 +185,1 @@\n-                    errln(\"ERROR: setMaximumIntegerDigits() failed\");\n+                    fail(\"ERROR: setMaximumIntegerDigits() failed\");\n@@ -189,1 +190,1 @@\n-                    errln(\"ERROR: setMinimumIntegerDigits() failed\");\n+                    fail(\"ERROR: setMinimumIntegerDigits() failed\");\n@@ -194,1 +195,1 @@\n-                    errln(\"ERROR: setMaximumFractionDigits() failed\");\n+                    fail(\"ERROR: setMaximumFractionDigits() failed\");\n@@ -199,1 +200,1 @@\n-                    errln(\"ERROR: setMinimumFractionDigits() failed\");\n+                    fail(\"ERROR: setMinimumFractionDigits() failed\");\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/IntlTestNumberFormatAPI.java","additions":36,"deletions":35,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @build IntlTest HexDumpReader TestUtils\n+ * @build HexDumpReader TestUtils\n@@ -39,1 +39,1 @@\n- * @run main\/othervm -Djava.locale.providers=COMPAT,SPI NumberRegression\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT,SPI NumberRegression\n@@ -61,1 +61,1 @@\n-public class NumberRegression extends IntlTest {\n+import org.junit.jupiter.api.Test;\n@@ -63,3 +63,3 @@\n-    public static void main(String[] args) throws Exception {\n-        new NumberRegression().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class NumberRegression {\n@@ -70,0 +70,1 @@\n+    @Test\n@@ -75,1 +76,1 @@\n-                logln(\"NumberFormat.equals passed\");\n+                System.out.println(\"NumberFormat.equals passed\");\n@@ -77,1 +78,1 @@\n-            errln(\"(new MyNumberFormatTest()).equals(null) throws unexpected exception\");\n+            fail(\"(new MyNumberFormatTest()).equals(null) throws unexpected exception\");\n@@ -85,0 +86,1 @@\n+    @Test\n@@ -93,2 +95,2 @@\n-        if (nf1.equals(nf2)) errln(\"Test for bug 4074620 failed\");\n-        else logln(\"Test for bug 4074620 passed.\");\n+        if (nf1.equals(nf2)) fail(\"Test for bug 4074620 failed\");\n+        else System.out.println(\"Test for bug 4074620 passed.\");\n@@ -103,0 +105,1 @@\n+    @Test\n@@ -106,1 +109,1 @@\n-            logln(\"Skipping this test because locale is \" + locale);\n+            System.out.println(\"Skipping this test because locale is \" + locale);\n@@ -116,3 +119,3 @@\n-        logln(\"d = \" + d);\n-        logln(\"maxFractionDigits = \" + df.getMaximumFractionDigits());\n-        logln(\" format(d) = '\" + df.format(d, sBuf1, fp1) + \"'\");\n+        System.out.println(\"d = \" + d);\n+        System.out.println(\"maxFractionDigits = \" + df.getMaximumFractionDigits());\n+        System.out.println(\" format(d) = '\" + df.format(d, sBuf1, fp1) + \"'\");\n@@ -122,1 +125,1 @@\n-        logln(\"maxFractionDigits = \" + df.getMaximumFractionDigits());\n+        System.out.println(\"maxFractionDigits = \" + df.getMaximumFractionDigits());\n@@ -126,1 +129,1 @@\n-            errln(\" format(d) = '\" + sBuf2 + \"'\");\n+            fail(\" format(d) = '\" + sBuf2 + \"'\");\n@@ -132,0 +135,1 @@\n+    @Test\n@@ -138,1 +142,1 @@\n-        logln(\"format(\" + n + \") = \" +\n+        System.out.println(\"format(\" + n + \") = \" +\n@@ -141,1 +145,1 @@\n-        logln(\"format(\" + n + \") = \" +\n+        System.out.println(\"format(\" + n + \") = \" +\n@@ -144,1 +148,1 @@\n-            errln(\"Test for bug 4087245 failed\");\n+            fail(\"Test for bug 4087245 failed\");\n@@ -149,0 +153,1 @@\n+    @Test\n@@ -158,1 +163,1 @@\n-            errln(n + \": '\" + buffer + \"'\");\n+            fail(n + \": '\" + buffer + \"'\");\n@@ -162,1 +167,1 @@\n-            errln(n + \": '\" + buffer + \"'\");\n+            fail(n + \": '\" + buffer + \"'\");\n@@ -168,0 +173,1 @@\n+    @Test\n@@ -174,1 +180,1 @@\n-            logln(df.format(123, sBuf, fp).toString());\n+            System.out.println(df.format(123, sBuf, fp).toString());\n@@ -176,1 +182,1 @@\n-            errln(\"Test for bug 4088503 failed.\");\n+            fail(\"Test for bug 4088503 failed.\");\n@@ -183,0 +189,1 @@\n+    @Test\n@@ -193,1 +200,1 @@\n-        logln(\" VALUE \" + returnfloat);\n+        System.out.println(\" VALUE \" + returnfloat);\n@@ -199,1 +206,1 @@\n-            errln(\" DISPLAYVALUE \" + stringValue);\n+            fail(\" DISPLAYVALUE \" + stringValue);\n@@ -206,0 +213,1 @@\n+    @Test\n@@ -209,2 +217,2 @@\n-            logln(format.parse(\"0\").toString());\n-        } catch (Exception e) { errln(\"Test for bug 4059870 failed : \" + e); }\n+            System.out.println(format.parse(\"0\").toString());\n+        } catch (Exception e) { fail(\"Test for bug 4059870 failed : \" + e); }\n@@ -217,0 +225,1 @@\n+    @Test\n@@ -221,1 +230,1 @@\n-                logln(\"Test Passed!\");\n+                System.out.println(\"Test Passed!\");\n@@ -223,1 +232,1 @@\n-            errln(\"Test for bug 4083018 failed => Message : \" + foo.getMessage());\n+            fail(\"Test for bug 4083018 failed => Message : \" + foo.getMessage());\n@@ -229,0 +238,1 @@\n+    @Test\n@@ -236,1 +246,1 @@\n-        logln(\"0.00159999 formats with 4 fractional digits to \" + out);\n+        System.out.println(\"0.00159999 formats with 4 fractional digits to \" + out);\n@@ -239,1 +249,1 @@\n-            errln(\"FAIL: Expected \" + expected);\n+            fail(\"FAIL: Expected \" + expected);\n@@ -247,0 +257,1 @@\n+    @Test\n@@ -250,2 +261,2 @@\n-        logln(\"nf toPattern1: \" + ((DecimalFormat)nf).toPattern());\n-        logln(\"nf toLocPattern1: \" + ((DecimalFormat)nf).toLocalizedPattern());\n+        System.out.println(\"nf toPattern1: \" + ((DecimalFormat)nf).toPattern());\n+        System.out.println(\"nf toLocPattern1: \" + ((DecimalFormat)nf).toLocalizedPattern());\n@@ -254,1 +265,1 @@\n-        logln(\"...applyLocalizedPattern ###,00;(###,00) \");\n+        System.out.println(\"...applyLocalizedPattern ###,00;(###,00) \");\n@@ -256,2 +267,2 @@\n-        logln(\"nf toPattern2: \" + ((DecimalFormat)nf).toPattern());\n-        logln(\"nf toLocPattern2: \" + ((DecimalFormat)nf).toLocalizedPattern());\n+        System.out.println(\"nf toPattern2: \" + ((DecimalFormat)nf).toPattern());\n+        System.out.println(\"nf toLocPattern2: \" + ((DecimalFormat)nf).toLocalizedPattern());\n@@ -259,2 +270,2 @@\n-        logln(\"nf: \" + nf.format(1234)); \/\/ 1234,00\n-        logln(\"nf: \" + nf.format(-1234)); \/\/ (1234,00)\n+        System.out.println(\"nf: \" + nf.format(1234)); \/\/ 1234,00\n+        System.out.println(\"nf: \" + nf.format(-1234)); \/\/ (1234,00)\n@@ -264,1 +275,1 @@\n-        logln(\"...applyLocalizedPattern # ###,00;(# ###,00) \");\n+        System.out.println(\"...applyLocalizedPattern # ###,00;(# ###,00) \");\n@@ -266,2 +277,2 @@\n-        logln(\"nf toPattern2: \" + ((DecimalFormat)nf).toPattern());\n-        logln(\"nf toLocPattern2: \" + ((DecimalFormat)nf).toLocalizedPattern());\n+        System.out.println(\"nf toPattern2: \" + ((DecimalFormat)nf).toPattern());\n+        System.out.println(\"nf toLocPattern2: \" + ((DecimalFormat)nf).toLocalizedPattern());\n@@ -270,1 +281,1 @@\n-            errln(\"nf : \" + buffer); \/\/ Expect 1 234,00\n+            fail(\"nf : \" + buffer); \/\/ Expect 1 234,00\n@@ -273,1 +284,1 @@\n-            errln(\"nf : \" + buffer); \/\/ Expect (1 234,00)\n+            fail(\"nf : \" + buffer); \/\/ Expect (1 234,00)\n@@ -283,0 +294,1 @@\n+    @Test\n@@ -287,1 +299,1 @@\n-        logln(\"----- Test Application -----\");\n+        System.out.println(\"----- Test Application -----\");\n@@ -292,1 +304,1 @@\n-            errln(\"Result -> \" + d);\n+            fail(\"Result -> \" + d);\n@@ -301,0 +313,1 @@\n+    @Test\n@@ -305,1 +318,1 @@\n-            logln(it.Now());\n+            System.out.println(it.Now());\n@@ -310,1 +323,1 @@\n-            logln(\"Saved ok.\");\n+            System.out.println(\"Saved ok.\");\n@@ -315,1 +328,1 @@\n-            logln(it2.Now());\n+            System.out.println(it2.Now());\n@@ -317,1 +330,1 @@\n-            logln(\"Loaded ok.\");\n+            System.out.println(\"Loaded ok.\");\n@@ -319,1 +332,1 @@\n-            errln(\"Test for bug 4069754 or 4057878 failed => Exception: \" + foo.getMessage());\n+            fail(\"Test for bug 4069754 or 4057878 failed => Exception: \" + foo.getMessage());\n@@ -326,0 +339,1 @@\n+    @Test\n@@ -330,2 +344,2 @@\n-            logln(\"toPattern() returns \\\"\" + df.toPattern() + \"\\\"\");\n-            errln(\"applyPattern(\\\"#.#.#\\\") doesn't throw IllegalArgumentException\");\n+            System.out.println(\"toPattern() returns \\\"\" + df.toPattern() + \"\\\"\");\n+            fail(\"applyPattern(\\\"#.#.#\\\") doesn't throw IllegalArgumentException\");\n@@ -333,1 +347,1 @@\n-            logln(\"Caught Illegal Argument Error !\");\n+            System.out.println(\"Caught Illegal Argument Error !\");\n@@ -338,2 +352,2 @@\n-            logln(\"toPattern() returns \\\"\" + df.toPattern() + \"\\\"\");\n-            errln(\"applyPattern(\\\"#0.0#0#0\\\") doesn't throw IllegalArgumentException\");\n+            System.out.println(\"toPattern() returns \\\"\" + df.toPattern() + \"\\\"\");\n+            fail(\"applyPattern(\\\"#0.0#0#0\\\") doesn't throw IllegalArgumentException\");\n@@ -341,1 +355,1 @@\n-            logln(\"Ok - IllegalArgumentException for #0.0#0#0\");\n+            System.out.println(\"Ok - IllegalArgumentException for #0.0#0#0\");\n@@ -348,0 +362,1 @@\n+    @Test\n@@ -358,2 +373,2 @@\n-        logln(\"d = \" + d);\n-        logln(\"BigDecimal.toString():  \" + bd.toString());\n+        System.out.println(\"d = \" + d);\n+        System.out.println(\"BigDecimal.toString():  \" + bd.toString());\n@@ -362,1 +377,1 @@\n-            errln(\"DecimalFormat.format(): \" + sb.toString());\n+            fail(\"DecimalFormat.format(): \" + sb.toString());\n@@ -370,0 +385,1 @@\n+    @Test\n@@ -373,1 +389,1 @@\n-        logln(\"d = \" + d);\n+        System.out.println(\"d = \" + d);\n@@ -382,2 +398,2 @@\n-                logln(\"  getMaximumFractionDigits() = \" + i);\n-                logln(\"  formated: \" + df.format(d, sb, fp));\n+                System.out.println(\"  getMaximumFractionDigits() = \" + i);\n+                System.out.println(\"  formated: \" + df.format(d, sb, fp));\n@@ -386,1 +402,1 @@\n-            errln(\"Bug 4090504 regression test failed. Message : \" + foo.getMessage());\n+            fail(\"Bug 4090504 regression test failed. Message : \" + foo.getMessage());\n@@ -392,0 +408,1 @@\n+    @Test\n@@ -400,1 +417,1 @@\n-        logln(d1.toString());\n+        System.out.println(d1.toString());\n@@ -402,1 +419,1 @@\n-            errln(\"Bug 4095713 test failed, new double value : \" + d2);\n+            fail(\"Bug 4095713 test failed, new double value : \" + d2);\n@@ -409,0 +426,1 @@\n+    @Test\n@@ -416,1 +434,1 @@\n-        logln(\"Long.MIN_VALUE : \" + df.parse(str, new ParsePosition(0)).toString());\n+        System.out.println(\"Long.MIN_VALUE : \" + df.parse(str, new ParsePosition(0)).toString());\n@@ -420,1 +438,1 @@\n-            errln(\"Bug 4092561 test failed when multiplier is not set to 1. Expected: -9.223372036854776E16, got: \" + num.doubleValue());\n+            fail(\"Bug 4092561 test failed when multiplier is not set to 1. Expected: -9.223372036854776E16, got: \" + num.doubleValue());\n@@ -426,1 +444,1 @@\n-            errln(\"Bug 4092561 test failed when multiplier is not set to 1. Expected: 9.223372036854776E16, got: \" + num.doubleValue());\n+            fail(\"Bug 4092561 test failed when multiplier is not set to 1. Expected: 9.223372036854776E16, got: \" + num.doubleValue());\n@@ -430,1 +448,1 @@\n-        logln(\"Long.MAX_VALUE : \" + df.parse(str, new ParsePosition(0)).toString());\n+        System.out.println(\"Long.MAX_VALUE : \" + df.parse(str, new ParsePosition(0)).toString());\n@@ -435,1 +453,1 @@\n-            errln(\"Bug 4092561 test failed when multiplier is not set to 1. Expected: 9.223372036854776E16, got: \" + num.doubleValue());\n+            fail(\"Bug 4092561 test failed when multiplier is not set to 1. Expected: 9.223372036854776E16, got: \" + num.doubleValue());\n@@ -441,1 +459,1 @@\n-            errln(\"Bug 4092561 test failed when multiplier is not set to 1. Expected: -9.223372036854776E16, got: \" + num.doubleValue());\n+            fail(\"Bug 4092561 test failed when multiplier is not set to 1. Expected: -9.223372036854776E16, got: \" + num.doubleValue());\n@@ -450,0 +468,1 @@\n+    @Test\n@@ -457,3 +476,3 @@\n-                errln(\"dfFoo.toPattern : \" + dfFoo.toPattern());\n-            logln(dfFoo.format(42));\n-            logln(dfFoo.format(-42));\n+                fail(\"dfFoo.toPattern : \" + dfFoo.toPattern());\n+            System.out.println(dfFoo.format(42));\n+            System.out.println(dfFoo.format(-42));\n@@ -462,3 +481,3 @@\n-                errln(\"dfFoo.toPattern : \" + dfFoo.toPattern());\n-            logln(dfFoo.format(42));\n-            logln(dfFoo.format(-42));\n+                fail(\"dfFoo.toPattern : \" + dfFoo.toPattern());\n+            System.out.println(dfFoo.format(42));\n+            System.out.println(dfFoo.format(-42));\n@@ -468,3 +487,3 @@\n-                errln(\"dfFoo.toPattern : \" + dfFoo.toPattern());\n-            logln(dfFoo.format(42));\n-            logln(dfFoo.format(-42));\n+                fail(\"dfFoo.toPattern : \" + dfFoo.toPattern());\n+            System.out.println(dfFoo.format(42));\n+            System.out.println(dfFoo.format(-42));\n@@ -474,3 +493,3 @@\n-                errln(\"dfFoo.toPattern : \" + dfFoo.toPattern());\n-            logln(dfFoo.format(42));\n-            logln(dfFoo.format(-42));\n+                fail(\"dfFoo.toPattern : \" + dfFoo.toPattern());\n+            System.out.println(dfFoo.format(42));\n+            System.out.println(dfFoo.format(-42));\n@@ -478,1 +497,1 @@\n-            errln(\"Message \" + foo.getMessage());\n+            fail(\"Message \" + foo.getMessage());\n@@ -489,0 +508,1 @@\n+    @Test\n@@ -499,1 +519,1 @@\n-            errln(\"ERROR in test: want decimal sep != monetary sep\");\n+            fail(\"ERROR in test: want decimal sep != monetary sep\");\n@@ -507,1 +527,1 @@\n-                logln(\"OK: 1.23 -> \\\"\" + str + \"\\\" contains \\\"\" +\n+                System.out.println(\"OK: 1.23 -> \\\"\" + str + \"\\\" contains \\\"\" +\n@@ -510,1 +530,1 @@\n-                errln(\"FAIL: 1.23 -> \\\"\" + str + \"\\\", should contain \\\"\" +\n+                fail(\"FAIL: 1.23 -> \\\"\" + str + \"\\\", should contain \\\"\" +\n@@ -519,0 +539,1 @@\n+    @Test\n@@ -536,1 +557,1 @@\n-            logln (\"Bug 4070798 default test passed.\");\n+            System.out.println(\"Bug 4070798 default test passed.\");\n@@ -538,1 +559,1 @@\n-            errln(\"Failed:\" +\n+            fail(\"Failed:\" +\n@@ -548,1 +569,1 @@\n-            logln (\"Bug 4070798 currency test assed.\");\n+            System.out.println(\"Bug 4070798 currency test assed.\");\n@@ -550,1 +571,1 @@\n-            errln(\"Failed:\" +\n+            fail(\"Failed:\" +\n@@ -560,1 +581,1 @@\n-            logln (\"Bug 4070798 percentage test passed.\");\n+            System.out.println(\"Bug 4070798 percentage test passed.\");\n@@ -562,1 +583,1 @@\n-            errln(\"Failed:\" +\n+            fail(\"Failed:\" +\n@@ -570,0 +591,1 @@\n+    @Test\n@@ -587,1 +609,1 @@\n-            logln (\"Bug 4071005 default test passed.\");\n+            System.out.println(\"Bug 4071005 default test passed.\");\n@@ -589,1 +611,1 @@\n-            errln(\"Failed:\" +\n+            fail(\"Failed:\" +\n@@ -598,1 +620,1 @@\n-            logln (\"Bug 4071005 currency test passed.\");\n+            System.out.println(\"Bug 4071005 currency test passed.\");\n@@ -600,1 +622,1 @@\n-            errln(\"Failed:\" +\n+            fail(\"Failed:\" +\n@@ -608,1 +630,1 @@\n-            logln (\"Bug 4071005 percentage test passed.\");\n+            System.out.println(\"Bug 4071005 percentage test passed.\");\n@@ -610,1 +632,1 @@\n-            errln(\"Failed:\" +\n+            fail(\"Failed:\" +\n@@ -619,0 +641,1 @@\n+    @Test\n@@ -635,1 +658,1 @@\n-            logln (\"Bug 4071014 default test passed.\");\n+            System.out.println(\"Bug 4071014 default test passed.\");\n@@ -637,1 +660,1 @@\n-            errln(\"Failed:\" +\n+            fail(\"Failed:\" +\n@@ -646,1 +669,1 @@\n-            logln (\"Bug 4071014 currency test passed.\");\n+            System.out.println(\"Bug 4071014 currency test passed.\");\n@@ -648,1 +671,1 @@\n-            errln(\"Failed:\" +\n+            fail(\"Failed:\" +\n@@ -657,1 +680,1 @@\n-            logln (\"Bug 4071014 percentage test passed.\");\n+            System.out.println(\"Bug 4071014 percentage test passed.\");\n@@ -659,1 +682,1 @@\n-            errln(\"Failed:\" +\n+            fail(\"Failed:\" +\n@@ -668,0 +691,1 @@\n+    @Test\n@@ -684,1 +708,1 @@\n-            logln (\"Bug 4071859 default test passed.\");\n+            System.out.println(\"Bug 4071859 default test passed.\");\n@@ -686,1 +710,1 @@\n-            errln(\"Failed:\" +\n+            fail(\"Failed:\" +\n@@ -695,1 +719,1 @@\n-            logln (\"Bug 4071859 currency test passed.\");\n+            System.out.println(\"Bug 4071859 currency test passed.\");\n@@ -697,1 +721,1 @@\n-            errln(\"Failed:\" +\n+            fail(\"Failed:\" +\n@@ -706,1 +730,1 @@\n-            logln (\"Bug 4071859 percentage test passed.\");\n+            System.out.println(\"Bug 4071859 percentage test passed.\");\n@@ -708,1 +732,1 @@\n-            errln(\"Failed:\" +\n+            fail(\"Failed:\" +\n@@ -718,0 +742,1 @@\n+    @Test\n@@ -742,2 +767,2 @@\n-        logln(\"\" + x + \" formats with 1 fractional digits to \" + out);\n-        if (!out.equals(expected)) errln(\"FAIL: Expected \" + expected);\n+        System.out.println(\"\" + x + \" formats with 1 fractional digits to \" + out);\n+        if (!out.equals(expected)) fail(\"FAIL: Expected \" + expected);\n@@ -748,0 +773,1 @@\n+    @Test\n@@ -753,1 +779,1 @@\n-            logln(fmt.format(.001));\n+            System.out.println(fmt.format(.001));\n@@ -755,1 +781,1 @@\n-            errln(\"Bug 4098471 failed with exception thrown : \" + foo.getMessage());\n+            fail(\"Bug 4098471 failed with exception thrown : \" + foo.getMessage());\n@@ -763,0 +789,1 @@\n+    @Test\n@@ -769,1 +796,1 @@\n-            logln(\"Inconsistent negative pattern is fine.\");\n+            System.out.println(\"Inconsistent negative pattern is fine.\");\n@@ -773,1 +800,1 @@\n-                errln(\"Failed!  3,456.78 p'ieces expected, but got : \" + tempString);\n+                fail(\"Failed!  3,456.78 p'ieces expected, but got : \" + tempString);\n@@ -775,1 +802,1 @@\n-            errln(\"An exception was thrown for any inconsistent negative pattern.\");\n+            fail(\"An exception was thrown for any inconsistent negative pattern.\");\n@@ -799,0 +826,1 @@\n+    @Test\n@@ -803,1 +831,1 @@\n-            errln(\"Bug 4099404 failed applying illegal pattern \\\"000.0#0\\\"\");\n+            fail(\"Bug 4099404 failed applying illegal pattern \\\"000.0#0\\\"\");\n@@ -805,1 +833,1 @@\n-            logln(\"Bug 4099404 pattern \\\"000.0#0\\\" passed\");\n+            System.out.println(\"Bug 4099404 pattern \\\"000.0#0\\\" passed\");\n@@ -809,1 +837,1 @@\n-            errln(\"Bug 4099404 failed applying illegal pattern \\\"0#0.000\\\"\");\n+            fail(\"Bug 4099404 failed applying illegal pattern \\\"0#0.000\\\"\");\n@@ -811,1 +839,1 @@\n-            logln(\"Bug 4099404 pattern \\\"0#0.000\\\" passed\");\n+            System.out.println(\"Bug 4099404 pattern \\\"0#0.000\\\" passed\");\n@@ -817,0 +845,1 @@\n+    @Test\n@@ -821,1 +850,1 @@\n-            errln(\"Minimum integer digits : \" + sdf.getMinimumIntegerDigits());\n+            fail(\"Minimum integer digits : \" + sdf.getMinimumIntegerDigits());\n@@ -826,0 +855,1 @@\n+    @Test\n@@ -831,1 +861,1 @@\n-            errln(\"Bug 4052223 failed : can't parse string \\\"a\\\".  Got \" + num);\n+            fail(\"Bug 4052223 failed : can't parse string \\\"a\\\".  Got \" + num);\n@@ -833,1 +863,1 @@\n-            logln(\"Caught expected ParseException : \" + foo.getMessage() + \" at index : \" + foo.getErrorOffset());\n+            System.out.println(\"Caught expected ParseException : \" + foo.getMessage() + \" at index : \" + foo.getErrorOffset());\n@@ -839,0 +869,1 @@\n+    @Test\n@@ -848,1 +879,1 @@\n-            errln(\"getCurrencySymbols failed, got empty string.\");\n+            fail(\"getCurrencySymbols failed, got empty string.\");\n@@ -850,1 +881,1 @@\n-        logln(\"Before set ==> Currency : \" + currency + \" Intl Currency : \" + intlCurrency + \" Monetary Decimal Separator : \" + monDecSeparator);\n+        System.out.println(\"Before set ==> Currency : \" + currency + \" Intl Currency : \" + intlCurrency + \" Monetary Decimal Separator : \" + monDecSeparator);\n@@ -860,1 +891,1 @@\n-            errln(\"setCurrencySymbols failed.\");\n+            fail(\"setCurrencySymbols failed.\");\n@@ -862,1 +893,1 @@\n-        logln(\"After set ==> Currency : \" + currency + \" Intl Currency : \" + intlCurrency + \" Monetary Decimal Separator : \" + monDecSeparator);\n+        System.out.println(\"After set ==> Currency : \" + currency + \" Intl Currency : \" + intlCurrency + \" Monetary Decimal Separator : \" + monDecSeparator);\n@@ -868,0 +899,1 @@\n+    @Test\n@@ -876,1 +908,1 @@\n-            errln(\"Format 1234.5 failed. Begin index: \" + field.getBeginIndex() + \" End index: \" + field.getEndIndex());\n+            fail(\"Format 1234.5 failed. Begin index: \" + field.getBeginIndex() + \" End index: \" + field.getEndIndex());\n@@ -880,1 +912,1 @@\n-            errln(\"Set begin\/end field indexes failed. Begin index: \" + field.getBeginIndex() + \" End index: \" + field.getEndIndex());\n+            fail(\"Set begin\/end field indexes failed. Begin index: \" + field.getBeginIndex() + \" End index: \" + field.getEndIndex());\n@@ -886,0 +918,1 @@\n+    @Test\n@@ -894,1 +927,1 @@\n-            errln(\"\\\"\" + text + \"\\\"  is parsed as \" + num);\n+            fail(\"\\\"\" + text + \"\\\"  is parsed as \" + num);\n@@ -898,1 +931,1 @@\n-            errln(\"\\\"\" + text + \"\\\"  is parsed as \" + num);\n+            fail(\"\\\"\" + text + \"\\\"  is parsed as \" + num);\n@@ -904,0 +937,1 @@\n+    @Test\n@@ -912,1 +946,1 @@\n-        logln(\"pattern: \\\"\" + df.toPattern() + \"\\\"\");\n+        System.out.println(\"pattern: \\\"\" + df.toPattern() + \"\\\"\");\n@@ -915,1 +949,1 @@\n-            errln(d1 + \"      is formatted as \" + buffer);\n+            fail(d1 + \"      is formatted as \" + buffer);\n@@ -920,1 +954,1 @@\n-            errln(d2 + \"      is formatted as \" + buffer);\n+            fail(d2 + \"      is formatted as \" + buffer);\n@@ -928,0 +962,1 @@\n+    @Test\n@@ -934,1 +969,1 @@\n-        logln(\"pattern: \\\"\" + df.toPattern() + \"\\\"\");\n+        System.out.println(\"pattern: \\\"\" + df.toPattern() + \"\\\"\");\n@@ -937,1 +972,1 @@\n-            errln(\"Test Failed: \\\"\" + text + \"\\\" is parsed as \" + num);\n+            fail(\"Test Failed: \\\"\" + text + \"\\\" is parsed as \" + num);\n@@ -943,1 +978,1 @@\n-            errln(\"Test Failed: \\\"$\\\" is parsed as \" + num);\n+            fail(\"Test Failed: \\\"$\\\" is parsed as \" + num);\n@@ -950,0 +985,1 @@\n+    @Test\n@@ -956,1 +992,1 @@\n-        if (result != null) errln(\"Should return null but got : \" + result); \/\/ Should be null; it isn't\n+        if (result != null) fail(\"Should return null but got : \" + result); \/\/ Should be null; it isn't\n@@ -962,0 +998,1 @@\n+    @Test\n@@ -971,1 +1008,1 @@\n-        logln(\"formated: \" +\n+        System.out.println(\"formated: \" +\n@@ -973,1 +1010,1 @@\n-        logln(\"expected: \" + bigN.toString());\n+        System.out.println(\"expected: \" + bigN.toString());\n@@ -978,0 +1015,1 @@\n+    @Test\n@@ -985,1 +1023,1 @@\n-        logln(\"pattern: \\\"\" + df.toPattern() + \"\\\"\");\n+        System.out.println(\"pattern: \\\"\" + df.toPattern() + \"\\\"\");\n@@ -989,1 +1027,1 @@\n-            errln(d + \"  is formatted as \" + buffer);\n+            fail(d + \"  is formatted as \" + buffer);\n@@ -997,0 +1035,1 @@\n+    @Test\n@@ -1001,1 +1040,1 @@\n-        logln(\"setMaximumIntegerDigits(128)\");\n+        System.out.println(\"setMaximumIntegerDigits(128)\");\n@@ -1003,1 +1042,1 @@\n-            errln(\"getMaximumIntegerDigits() returns \" +\n+            fail(\"getMaximumIntegerDigits() returns \" +\n@@ -1014,0 +1053,1 @@\n+    @Test\n@@ -1030,1 +1070,1 @@\n-                errln(\"Currency format for \" + locales[i] +\n+                fail(\"Currency format for \" + locales[i] +\n@@ -1061,1 +1101,1 @@\n-                errln(\"Results for \" + locales[i] + \" differ: \" +\n+                fail(\"Results for \" + locales[i] + \" differ: \" +\n@@ -1070,0 +1110,1 @@\n+    @Test\n@@ -1076,1 +1117,1 @@\n-        logln(\"toPattern: \" + formatDec.toPattern());\n+        System.out.println(\"toPattern: \" + formatDec.toPattern());\n@@ -1079,1 +1120,1 @@\n-            errln(\"result : \" + rateString + \" expected : 012.34\");\n+            fail(\"result : \" + rateString + \" expected : 012.34\");\n@@ -1083,1 +1124,1 @@\n-        logln(\"toPattern: \" + formatDec.toPattern());\n+        System.out.println(\"toPattern: \" + formatDec.toPattern());\n@@ -1086,1 +1127,1 @@\n-            errln(\"result : \" + rateString + \" expected : +012.34%\");\n+            fail(\"result : \" + rateString + \" expected : +012.34%\");\n@@ -1094,0 +1135,1 @@\n+    @Test\n@@ -1100,1 +1142,1 @@\n-        if (f.equals(\"9.02\")) logln(f + \" ok\"); else errln(\"9.02 -> \" + f + \"; want 9.02\");\n+        if (f.equals(\"9.02\")) System.out.println(f + \" ok\"); else fail(\"9.02 -> \" + f + \"; want 9.02\");\n@@ -1103,1 +1145,1 @@\n-        if (f.equals(\".00\")) logln(f + \" ok\"); else errln(\"0 -> \" + f + \"; want .00\");\n+        if (f.equals(\".00\")) System.out.println(f + \" ok\"); else fail(\"0 -> \" + f + \"; want .00\");\n@@ -1131,0 +1173,1 @@\n+    @Test\n@@ -1145,1 +1188,1 @@\n-                errln(\"Fail: 1.2 x \" + DATA[i] + \" = \" + result +\n+                fail(\"Fail: 1.2 x \" + DATA[i] + \" = \" + result +\n@@ -1149,1 +1192,1 @@\n-                logln(\"Ok: 1.2 x \" + DATA[i] + \" = \" + result);\n+                System.out.println(\"Ok: 1.2 x \" + DATA[i] + \" = \" + result);\n@@ -1158,0 +1201,1 @@\n+    @Test\n@@ -1174,1 +1218,1 @@\n-                errln(\"Fail: Format empty pattern x 123.456 => \" + s);\n+                fail(\"Fail: Format empty pattern x 123.456 => \" + s);\n@@ -1177,1 +1221,1 @@\n-                errln(\"Fail: Format empty pattern x -123.456 => \" + s);\n+                fail(\"Fail: Format empty pattern x -123.456 => \" + s);\n@@ -1184,0 +1228,1 @@\n+    @Test\n@@ -1191,1 +1236,1 @@\n-                errln(\"Fail: \" + str + \" x format -> \" + sd);\n+                fail(\"Fail: \" + str + \" x format -> \" + sd);\n@@ -1195,1 +1240,1 @@\n-            errln(e.toString());\n+            fail(e.toString());\n@@ -1204,0 +1249,1 @@\n+    @Test\n@@ -1226,1 +1272,1 @@\n-                    errln(\"Fail with \\\"\" + PATS[i] + \"\\\": Patterns should concur, \\\"\" +\n+                    fail(\"Fail with \\\"\" + PATS[i] + \"\\\": Patterns should concur, \\\"\" +\n@@ -1229,1 +1275,1 @@\n-                    logln(\"Ok \\\"\" + PATS[i] + \"\\\" toPattern() -> \\\"\" + pat + '\"');\n+                    System.out.println(\"Ok \\\"\" + PATS[i] + \"\\\" toPattern() -> \\\"\" + pat + '\"');\n@@ -1232,1 +1278,1 @@\n-                    logln(\"Ok \" + pi + \" x \\\"\" + PATS[i] + \"\\\" -> \\\"\" +\n+                    System.out.println(\"Ok \" + pi + \" x \\\"\" + PATS[i] + \"\\\" -> \\\"\" +\n@@ -1237,1 +1283,1 @@\n-                    errln(\"Fail \" + pi + \" x \\\"\" + PATS[i] + \"\\\" -> \\\"\" +\n+                    fail(\"Fail \" + pi + \" x \\\"\" + PATS[i] + \"\\\" -> \\\"\" +\n@@ -1244,1 +1290,1 @@\n-            errln(\"Fail: \" + e);\n+            fail(\"Fail: \" + e);\n@@ -1254,0 +1300,1 @@\n+    @Test\n@@ -1257,1 +1304,1 @@\n-        logln(\"Applying pattern \\\"\" + pattern + \"\\\"\");\n+        System.out.println(\"Applying pattern \\\"\" + pattern + \"\\\"\");\n@@ -1261,3 +1308,3 @@\n-            errln(\"Test failed\");\n-            errln(\" Minimum integer digits : \" + minIntDig);\n-            errln(\" new pattern: \" + sdf.toPattern());\n+            fail(\"Test failed\"\n+            + \"\\n Minimum integer digits : \" + minIntDig\n+            + \"\\n new pattern: \" + sdf.toPattern());\n@@ -1265,2 +1312,2 @@\n-            logln(\"Test passed\");\n-            logln(\" Minimum integer digits : \" + minIntDig);\n+            System.out.println(\"Test passed\");\n+            System.out.println(\" Minimum integer digits : \" + minIntDig);\n@@ -1274,0 +1321,1 @@\n+    @Test\n@@ -1282,1 +1330,1 @@\n-            errln(d1 + \" x \\\"\" + df.toPattern() + \"\\\" is formatted as \\\"\" + f1 + '\"');\n+            fail(d1 + \" x \\\"\" + df.toPattern() + \"\\\" is formatted as \\\"\" + f1 + '\"');\n@@ -1285,1 +1333,1 @@\n-            errln(d2 + \" x \\\"\" + df.toPattern() + \"\\\" is formatted as \\\"\" + f2 + '\"');\n+            fail(d2 + \" x \\\"\" + df.toPattern() + \"\\\" is formatted as \\\"\" + f2 + '\"');\n@@ -1292,0 +1340,1 @@\n+    @Test\n@@ -1298,1 +1347,1 @@\n-        logln(\"The number \" + dbl + \" formatted to \" + s);\n+        System.out.println(\"The number \" + dbl + \" formatted to \" + s);\n@@ -1303,1 +1352,1 @@\n-            errln(\"Caught a ParseException:\");\n+            fail(\"Caught a ParseException:\");\n@@ -1306,1 +1355,1 @@\n-        logln(\"The string \" + s + \" parsed as \" + n);\n+        System.out.println(\"The string \" + s + \" parsed as \" + n);\n@@ -1308,1 +1357,1 @@\n-            errln(\"Round trip failure\");\n+            fail(\"Round trip failure\");\n@@ -1315,0 +1364,1 @@\n+    @Test\n@@ -1322,1 +1372,1 @@\n-            logln(\"\" +\n+            System.out.println(\"\" +\n@@ -1327,1 +1377,1 @@\n-                logln(\"Failed to parse negative zero\");\n+                System.out.println(\"Failed to parse negative zero\");\n@@ -1335,0 +1385,1 @@\n+    @Test\n@@ -1343,1 +1394,1 @@\n-            logln(\"\" + a + \" -> \\\"\" + s + \"\\\" -> \" + b + \" ok\");\n+            System.out.println(\"\" + a + \" -> \\\"\" + s + \"\\\" -> \" + b + \" ok\");\n@@ -1345,1 +1396,1 @@\n-            errln(\"\" + a + \" -> \\\"\" + s + \"\\\" -> \" + b + \" FAIL\");\n+            fail(\"\" + a + \" -> \\\"\" + s + \"\\\" -> \" + b + \" FAIL\");\n@@ -1358,1 +1409,1 @@\n-                logln(\"\" + a + \" -> \\\"\" + s + \"\\\" -> \" + b + \" ok\");\n+                System.out.println(\"\" + a + \" -> \\\"\" + s + \"\\\" -> \" + b + \" ok\");\n@@ -1360,1 +1411,1 @@\n-                errln(\"\" + a + \" -> \\\"\" + s + \"\\\" -> \" + b + \" FAIL\");\n+                fail(\"\" + a + \" -> \\\"\" + s + \"\\\" -> \" + b + \" FAIL\");\n@@ -1368,0 +1419,1 @@\n+    @Test\n@@ -1376,1 +1428,1 @@\n-            errln(\"FAIL: parse(\\\"-0.0\\\") returns \" +\n+            fail(\"FAIL: parse(\\\"-0.0\\\") returns \" +\n@@ -1385,0 +1437,1 @@\n+    @Test\n@@ -1401,1 +1454,1 @@\n-                errln(\"FAIL: \" + DATA[i] + \" -> \" + s + \", want \" + DATA[i+1]);\n+                fail(\"FAIL: \" + DATA[i] + \" -> \" + s + \", want \" + DATA[i+1]);\n@@ -1409,0 +1462,1 @@\n+    @Test\n@@ -1425,1 +1479,1 @@\n-                logln(\"Ok: \" + in + \" x \" + pat + \" = \" + out);\n+                System.out.println(\"Ok: \" + in + \" x \" + pat + \" = \" + out);\n@@ -1427,1 +1481,1 @@\n-                errln(\"FAIL: \" + in + \" x  \" + pat + \" = \" + out +\n+                fail(\"FAIL: \" + in + \" x  \" + pat + \" = \" + out +\n@@ -1433,0 +1487,1 @@\n+    @Test\n@@ -1459,1 +1514,1 @@\n-            errln(\"FAIL: Deserialized bogus NumberFormat int:\" +\n+            fail(\"FAIL: Deserialized bogus NumberFormat int:\" +\n@@ -1465,1 +1520,1 @@\n-            logln(\"Ok: \" + e.getMessage());\n+            System.out.println(\"Ok: \" + e.getMessage());\n@@ -1473,1 +1528,1 @@\n-            errln(\"FAIL: Deserialized bogus DecimalFormat int:\" +\n+            fail(\"FAIL: Deserialized bogus DecimalFormat int:\" +\n@@ -1479,1 +1534,1 @@\n-            logln(\"Ok: \" + e.getMessage());\n+            System.out.println(\"Ok: \" + e.getMessage());\n@@ -1491,0 +1546,1 @@\n+    @Test\n@@ -1498,1 +1554,1 @@\n-            errln(\"FAIL: -1 x (minus=^) -> \" + fmt.format(-1) +\n+            fail(\"FAIL: -1 x (minus=^) -> \" + fmt.format(-1) +\n@@ -1502,1 +1558,1 @@\n-            errln(\"FAIL: (minus=^).getNegativePrefix -> \" +\n+            fail(\"FAIL: (minus=^).getNegativePrefix -> \" +\n@@ -1511,1 +1567,1 @@\n-            errln(\"FAIL: 0.25 x (percent=^) -> \" + fmt.format(0.25) +\n+            fail(\"FAIL: 0.25 x (percent=^) -> \" + fmt.format(0.25) +\n@@ -1515,1 +1571,1 @@\n-            errln(\"FAIL: (percent=^).getPositiveSuffix -> \" +\n+            fail(\"FAIL: (percent=^).getPositiveSuffix -> \" +\n@@ -1524,1 +1580,1 @@\n-            errln(\"FAIL: 0.25 x (permill=^) -> \" + fmt.format(0.25) +\n+            fail(\"FAIL: 0.25 x (permill=^) -> \" + fmt.format(0.25) +\n@@ -1528,1 +1584,1 @@\n-            errln(\"FAIL: (permill=^).getPositiveSuffix -> \" +\n+            fail(\"FAIL: (permill=^).getPositiveSuffix -> \" +\n@@ -1537,1 +1593,1 @@\n-            errln(\"FAIL: 12.5 x (currency=usd) -> \" + fmt.format(12.5) +\n+            fail(\"FAIL: 12.5 x (currency=usd) -> \" + fmt.format(12.5) +\n@@ -1541,1 +1597,1 @@\n-            errln(\"FAIL: (currency=usd).getPositivePrefix -> \" +\n+            fail(\"FAIL: (currency=usd).getPositivePrefix -> \" +\n@@ -1550,1 +1606,1 @@\n-            errln(\"FAIL: 12.5 x (intlcurrency=DOL) -> \" + fmt.format(12.5) +\n+            fail(\"FAIL: 12.5 x (intlcurrency=DOL) -> \" + fmt.format(12.5) +\n@@ -1554,1 +1610,1 @@\n-            errln(\"FAIL: (intlcurrency=DOL).getPositivePrefix -> \" +\n+            fail(\"FAIL: (intlcurrency=DOL).getPositivePrefix -> \" +\n@@ -1583,1 +1639,1 @@\n-                    errln(\"FAIL: \" + avail[i] + \" -> \\\"\" + pat +\n+                    fail(\"FAIL: \" + avail[i] + \" -> \\\"\" + pat +\n@@ -1591,1 +1647,1 @@\n-                    errln(\"FAIL: \" + avail[i] + \" -> localized \\\"\" + pat +\n+                    fail(\"FAIL: \" + avail[i] + \" -> localized \\\"\" + pat +\n@@ -1606,1 +1662,1 @@\n-                    errln(\"FAIL: Stream in\/out \" + avail[i] + \" -> \\\"\" + pat +\n+                    fail(\"FAIL: Stream in\/out \" + avail[i] + \" -> \\\"\" + pat +\n@@ -1618,0 +1674,1 @@\n+    @Test\n@@ -1627,1 +1684,1 @@\n-                    errln(\"\\\"\" + str + \"\\\" parse(x \" + fmt.getMultiplier() +\n+                    fail(\"\\\"\" + str + \"\\\" parse(x \" + fmt.getMultiplier() +\n@@ -1638,0 +1695,1 @@\n+    @Test\n@@ -1650,1 +1708,1 @@\n-                errln(\"FAIL: Got \" + s + \", exp \" + DATA[i+1]);\n+                fail(\"FAIL: Got \" + s + \", exp \" + DATA[i+1]);\n@@ -1658,0 +1716,1 @@\n+    @Test\n@@ -1668,1 +1727,1 @@\n-                logln(\"OK: got \" + result);\n+                System.out.println(\"OK: got \" + result);\n@@ -1670,1 +1729,1 @@\n-                errln(\"FAIL: got \" + result);\n+                fail(\"FAIL: got \" + result);\n@@ -1679,0 +1738,1 @@\n+    @Test\n@@ -1685,1 +1745,1 @@\n-            logln(\"OK: got \" + result);\n+            System.out.println(\"OK: got \" + result);\n@@ -1687,1 +1747,1 @@\n-            errln(\"FAIL: got \" + result);\n+            fail(\"FAIL: got \" + result);\n@@ -1692,1 +1752,1 @@\n-                logln(\"OK: got \" + dResult);\n+                System.out.println(\"OK: got \" + dResult);\n@@ -1694,1 +1754,1 @@\n-                errln(\"FAIL: got \" + dResult);\n+                fail(\"FAIL: got \" + dResult);\n@@ -1697,1 +1757,1 @@\n-            errln(\"Caught a ParseException:\");\n+            fail(\"Caught a ParseException:\");\n@@ -1702,1 +1762,1 @@\n-            logln(\"OK: got \" + result);\n+            System.out.println(\"OK: got \" + result);\n@@ -1704,1 +1764,1 @@\n-            errln(\"FAIL: got \" + result);\n+            fail(\"FAIL: got \" + result);\n@@ -1712,0 +1772,1 @@\n+    @Test\n@@ -1743,1 +1804,1 @@\n-                    errln(\"FAIL: input: \" + input[i] +\n+                    fail(\"FAIL: input: \" + input[i] +\n@@ -1756,0 +1817,1 @@\n+    @Test\n@@ -1765,1 +1827,1 @@\n-            errln(\"FAIL: input: \" + f + \", expected: 0.01, got: \" + result);\n+            fail(\"FAIL: input: \" + f + \", expected: 0.01, got: \" + result);\n@@ -1772,0 +1834,1 @@\n+    @Test\n@@ -1797,1 +1860,1 @@\n-                errln(\"FAIL: input: \" + input[i] +\n+                fail(\"FAIL: input: \" + input[i] +\n@@ -1810,0 +1873,1 @@\n+    @Test\n@@ -1832,1 +1896,1 @@\n-            errln(\"FAIL: getMonetaryGroupingSeparator() returned incorrect value. expected: \"\n+            fail(\"FAIL: getMonetaryGroupingSeparator() returned incorrect value. expected: \"\n@@ -1836,1 +1900,1 @@\n-            errln(\"FAIL: getMonetaryGroupingSeparator() returned the same value with \" +\n+            fail(\"FAIL: getMonetaryGroupingSeparator() returned the same value with \" +\n@@ -1844,1 +1908,1 @@\n-            errln(\"FAIL: format failed. expected: \" + expectedMonFmt +\n+            fail(\"FAIL: format failed. expected: \" + expectedMonFmt +\n@@ -1849,1 +1913,1 @@\n-            errln(\"FAIL: normal format failed. expected: \" + expectedNrmFmt +\n+            fail(\"FAIL: normal format failed. expected: \" + expectedNrmFmt +\n@@ -1856,1 +1920,1 @@\n-            errln(\"FAIL: parse failed. expected: \" + inputNum +\n+            fail(\"FAIL: parse failed. expected: \" + inputNum +\n@@ -1861,1 +1925,1 @@\n-            errln(\"FAIL: normal parse failed. expected: \" + inputNum +\n+            fail(\"FAIL: normal parse failed. expected: \" + inputNum +\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/NumberRegression.java","additions":289,"deletions":225,"binary":false,"changes":514,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @library \/java\/text\/testlib\n@@ -29,0 +28,1 @@\n+ * @run junit NumberRoundTrip\n@@ -31,2 +31,8 @@\n-import java.text.*;\n-import java.util.*;\n+import java.text.DecimalFormat;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.util.Locale;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n@@ -43,1 +49,1 @@\n-public class NumberRoundTrip extends IntlTest {\n+public class NumberRoundTrip {\n@@ -47,1 +53,0 @@\n-    static boolean DEBUG = false;\n@@ -53,10 +58,1 @@\n-    public static void main(String[] args) throws Exception {\n-        if (args.length > 0 && args[0].equals(\"-debug\")) {\n-            DEBUG = true;\n-            String[] newargs = new String[args.length - 1];\n-            System.arraycopy(args, 1, newargs, 0, newargs.length);\n-            args = newargs;\n-        }\n-        new NumberRoundTrip().run(args);\n-    }\n-\n+    @Test\n@@ -64,1 +60,1 @@\n-        logln(\"Default Locale\");\n+        System.out.println(\"Default Locale\");\n@@ -77,1 +73,1 @@\n-            logln(loc[i].getDisplayName());\n+            System.out.println(loc[i].getDisplayName());\n@@ -89,1 +85,1 @@\n-        logln(\"Numeric error \" +\n+        System.out.println(\"Numeric error \" +\n@@ -153,1 +149,1 @@\n-            if (DEBUG) logln(\"  \" + value + \" F> \" + escape(s));\n+            System.out.println(\"  \" + value + \" F> \" + escape(s));\n@@ -155,1 +151,1 @@\n-            if (DEBUG) logln(\"  \" + escape(s) + \" P> \" + n);\n+            System.out.println(\"  \" + escape(s) + \" P> \" + n);\n@@ -157,1 +153,1 @@\n-            if (DEBUG) logln(\"  \" + n + \" F> \" + escape(s2));\n+            System.out.println(\"  \" + n + \" F> \" + escape(s2));\n@@ -162,1 +158,1 @@\n-                        logln(\"Text mismatch: expected: \" + s + \", got: \" + s2 + \" --- Try BigDecimal parsing.\");\n+                        System.out.println(\"Text mismatch: expected: \" + s + \", got: \" + s2 + \" --- Try BigDecimal parsing.\");\n@@ -165,1 +161,1 @@\n-                        if (DEBUG) logln(\"  \" + escape(s) + \" P> \" + n);\n+                        System.out.println(\"  \" + escape(s) + \" P> \" + n);\n@@ -167,1 +163,1 @@\n-                        if (DEBUG) logln(\"  \" + n + \" F> \" + escape(s2));\n+                        System.out.println(\"  \" + n + \" F> \" + escape(s2));\n@@ -200,1 +196,1 @@\n-                errln(\"*** \" + err + \" with \" +\n+                fail(\"*** \" + err + \" with \" +\n@@ -204,1 +200,1 @@\n-                logln(message);\n+                System.out.println(message);\n@@ -207,1 +203,1 @@\n-            errln(\"*** \" + e.toString() + \" with \" +\n+            fail(\"*** \" + e.toString() + \" with \" +\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/NumberRoundTrip.java","additions":24,"deletions":28,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @library \/java\/text\/testlib\n@@ -32,1 +31,1 @@\n- * @run main\/othervm -Djava.locale.providers=COMPAT,SPI NumberTest\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT,SPI NumberTest\n@@ -39,5 +38,1 @@\n-public class NumberTest extends IntlTest\n-{\n-    public static void main(String[] args) throws Exception {\n-        new NumberTest().run(args);\n-    }\n+import org.junit.jupiter.api.Test;\n@@ -45,0 +40,4 @@\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class NumberTest\n+{\n@@ -46,0 +45,1 @@\n+    @Test\n@@ -57,1 +57,1 @@\n-        errln(\"FAIL: Pattern \" + pat[i] + \" should transmute to \" + newpat[i] +\n+        fail(\"FAIL: Pattern \" + pat[i] + \" should transmute to \" + newpat[i] +\n@@ -63,1 +63,1 @@\n-        errln(\"FAIL: Pattern \" + pat[i] + \" should format zero as \" + num[i] +\n+        fail(\"FAIL: Pattern \" + pat[i] + \" should format zero as \" + num[i] +\n@@ -65,1 +65,1 @@\n-        logln(\"Min integer digits = \" + fmt.getMinimumIntegerDigits());\n+        System.out.println(\"Min integer digits = \" + fmt.getMinimumIntegerDigits());\n@@ -71,0 +71,1 @@\n+    @Test\n@@ -103,1 +104,1 @@\n-            logln(\"Pattern \\\"\" + pat[p] + \"\\\" -toPattern-> \\\"\" +\n+            System.out.println(\"Pattern \\\"\" + pat[p] + \"\\\" -toPattern-> \\\"\" +\n@@ -108,1 +109,1 @@\n-                logln(\" Format \" + val[v] + \" -> \" + escape(s));\n+                System.out.println(\" Format \" + val[v] + \" -> \" + escape(s));\n@@ -110,1 +111,1 @@\n-                    errln(\"FAIL: Expected \" + valFormat[v+ival] +\n+                    fail(\"FAIL: Expected \" + valFormat[v+ival] +\n@@ -118,1 +119,1 @@\n-                    logln(\" Parse -> \" + a);\n+                    System.out.println(\" Parse -> \" + a);\n@@ -120,1 +121,1 @@\n-                        errln(\"FAIL: Expected \" + valParse[v+ival] +\n+                        fail(\"FAIL: Expected \" + valParse[v+ival] +\n@@ -125,1 +126,1 @@\n-                    errln(\" FAIL: Partial parse (\" + pos.getIndex() +\n+                    fail(\" FAIL: Partial parse (\" + pos.getIndex() +\n@@ -131,1 +132,1 @@\n-                logln(\" Format \" + lval[v] + \"L -> \" + escape(s));\n+                System.out.println(\" Format \" + lval[v] + \"L -> \" + escape(s));\n@@ -133,1 +134,1 @@\n-                    errln(\"ERROR: Expected \" + lvalFormat[v+ilval] +\n+                    fail(\"ERROR: Expected \" + lvalFormat[v+ilval] +\n@@ -141,1 +142,1 @@\n-                    logln(\" Parse -> \" + a);\n+                    System.out.println(\" Parse -> \" + a);\n@@ -143,1 +144,1 @@\n-                        errln(\"FAIL: Expected \" + lvalParse[v+ilval] +\n+                        fail(\"FAIL: Expected \" + lvalParse[v+ilval] +\n@@ -148,1 +149,1 @@\n-                    errln(\" FAIL: Partial parse (\" + pos.getIndex() +\n+                    fail(\" FAIL: Partial parse (\" + pos.getIndex() +\n@@ -158,0 +159,1 @@\n+    @Test\n@@ -164,3 +166,3 @@\n-    logln(\"Pattern \\\"\" + pat + \"\\\"\");\n-    logln(\" Format 123 -> \" + escape(s));\n-    if (!s.equals(\"afo'ob123\")) errln(\"FAIL: Expected afo'ob123\");\n+    System.out.println(\"Pattern \\\"\" + pat + \"\\\"\");\n+    System.out.println(\" Format 123 -> \" + escape(s));\n+    if (!s.equals(\"afo'ob123\")) fail(\"FAIL: Expected afo'ob123\");\n@@ -170,3 +172,3 @@\n-    logln(\"Pattern \\\"\" + pat + \"\\\"\");\n-    logln(\" Format 123 -> \" + escape(s));\n-    if (!s.equals(\"a'b123\")) errln(\"FAIL: Expected a'b123\");\n+    System.out.println(\"Pattern \\\"\" + pat + \"\\\"\");\n+    System.out.println(\" Format 123 -> \" + escape(s));\n+    if (!s.equals(\"a'b123\")) fail(\"FAIL: Expected a'b123\");\n@@ -176,0 +178,1 @@\n+    @Test\n@@ -184,3 +187,3 @@\n-    logln(\"Pattern \\\"\" + fmt.toPattern() + \"\\\"\");\n-    logln(\" Format \" + 1234.56 + \" -> \" + escape(s));\n-    if (!s.equals(\"$1,234.56\")) errln(\"FAIL: Expected $1,234.56\");\n+    System.out.println(\"Pattern \\\"\" + fmt.toPattern() + \"\\\"\");\n+    System.out.println(\" Format \" + 1234.56 + \" -> \" + escape(s));\n+    if (!s.equals(\"$1,234.56\")) fail(\"FAIL: Expected $1,234.56\");\n@@ -188,2 +191,2 @@\n-    logln(\" Format \" + -1234.56 + \" -> \" + escape(s));\n-    if (!s.equals(\"-$1,234.56\")) errln(\"FAIL: Expected -$1,234.56\");\n+    System.out.println(\" Format \" + -1234.56 + \" -> \" + escape(s));\n+    if (!s.equals(\"-$1,234.56\")) fail(\"FAIL: Expected -$1,234.56\");\n@@ -193,3 +196,3 @@\n-    logln(\"Pattern \\\"\" + fmt.toPattern() + \"\\\"\");\n-    logln(\" Format \" + 1234.56 + \" -> \" + escape(s));\n-    if (!s.equals(\"USD 1,234.56\")) errln(\"FAIL: Expected USD 1,234.56\");\n+    System.out.println(\"Pattern \\\"\" + fmt.toPattern() + \"\\\"\");\n+    System.out.println(\" Format \" + 1234.56 + \" -> \" + escape(s));\n+    if (!s.equals(\"USD 1,234.56\")) fail(\"FAIL: Expected USD 1,234.56\");\n@@ -197,2 +200,2 @@\n-    logln(\" Format \" + -1234.56 + \" -> \" + escape(s));\n-    if (!s.equals(\"USD -1,234.56\")) errln(\"FAIL: Expected USD -1,234.56\");\n+    System.out.println(\" Format \" + -1234.56 + \" -> \" + escape(s));\n+    if (!s.equals(\"USD -1,234.56\")) fail(\"FAIL: Expected USD -1,234.56\");\n@@ -222,0 +225,1 @@\n+    @Test\n@@ -226,1 +230,1 @@\n-        logln(\"Un pauvre ici a...........\" + s);\n+        System.out.println(\"Un pauvre ici a...........\" + s);\n@@ -228,1 +232,1 @@\n-            errln(\"FAIL: Expected 1,50 $; got \" + s + \"; \"+ dumpFmt(currencyFmt));\n+            fail(\"FAIL: Expected 1,50 $; got \" + s + \"; \"+ dumpFmt(currencyFmt));\n@@ -232,1 +236,1 @@\n-        logln(\"Un pauvre en Allemagne a..\" + s);\n+        System.out.println(\"Un pauvre en Allemagne a..\" + s);\n@@ -234,1 +238,1 @@\n-            errln(\"FAIL: Expected 1,50 \\u20AC; got \" + s + \"; \" + dumpFmt(currencyFmt));\n+            fail(\"FAIL: Expected 1,50 \\u20AC; got \" + s + \"; \" + dumpFmt(currencyFmt));\n@@ -238,1 +242,1 @@\n-        logln(\"Un pauvre en France a.....\" + s);\n+        System.out.println(\"Un pauvre en France a.....\" + s);\n@@ -240,1 +244,1 @@\n-            errln(\"FAIL: Expected 1,50 \\u20AC; got \" + s + \"; \" + dumpFmt(currencyFmt));\n+            fail(\"FAIL: Expected 1,50 \\u20AC; got \" + s + \"; \" + dumpFmt(currencyFmt));\n@@ -257,0 +261,1 @@\n+    @Test\n@@ -263,3 +268,3 @@\n-        logln(\"parse(\" + arg + \") = \" + n);\n-        if (n.doubleValue() != 0.0) errln(\"FAIL: Expected 0\");\n-    } catch (Exception e) { errln(\"Exception caught: \" + e); }\n+        System.out.println(\"parse(\" + arg + \") = \" + n);\n+        if (n.doubleValue() != 0.0) fail(\"FAIL: Expected 0\");\n+    } catch (Exception e) { fail(\"Exception caught: \" + e); }\n@@ -269,0 +274,1 @@\n+    @Test\n@@ -281,1 +287,1 @@\n-        logln(\"\" + x + \" formats with \" + maxFractionDigits + \" fractional digits to \" + out);\n+        System.out.println(\"\" + x + \" formats with \" + maxFractionDigits + \" fractional digits to \" + out);\n@@ -283,1 +289,1 @@\n-            errln(\"FAIL: Expected \" + expected + \", got \" + out);\n+            fail(\"FAIL: Expected \" + expected + \", got \" + out);\n@@ -295,0 +301,1 @@\n+    @Test\n@@ -327,1 +334,1 @@\n-                errln(\"Can't parse Unicode \" + Integer.toHexString(zero) + \" as digit (\" + n + \")\");\n+                fail(\"Can't parse Unicode \" + Integer.toHexString(zero) + \" as digit (\" + n + \")\");\n@@ -329,1 +336,1 @@\n-                logln(\"Parse digit \" + Integer.toHexString(zero) + \" ok\");\n+                System.out.println(\"Parse digit \" + Integer.toHexString(zero) + \" ok\");\n@@ -337,0 +344,1 @@\n+    @Test\n@@ -359,1 +367,1 @@\n-                    errln(\"FAIL: \" + locales[i] +\n+                    fail(\"FAIL: \" + locales[i] +\n@@ -365,1 +373,1 @@\n-                            errln(\"Fail: Positive and negative patterns use different symbols\");\n+                            fail(\"Fail: Positive and negative patterns use different symbols\");\n@@ -367,1 +375,1 @@\n-                            logln(\"Ok: \" + locales[i] +\n+                            System.out.println(\"Ok: \" + locales[i] +\n@@ -373,1 +381,1 @@\n-                            errln(\"Fail: Positive and negative patterns use different symbols\");\n+                            fail(\"Fail: Positive and negative patterns use different symbols\");\n@@ -375,1 +383,1 @@\n-                            logln(\"Ok: \" + locales[i] +\n+                            System.out.println(\"Ok: \" + locales[i] +\n@@ -380,1 +388,1 @@\n-                        errln(\"FAIL: \" + locales[i] +\n+                        fail(\"FAIL: \" + locales[i] +\n@@ -385,1 +393,1 @@\n-            else logln(\"Skipping \" + locales[i] + \"; not a DecimalFormat\");\n+            else System.out.println(\"Skipping \" + locales[i] + \"; not a DecimalFormat\");\n@@ -389,0 +397,1 @@\n+    @Test\n@@ -398,1 +407,1 @@\n-                errln(\"FAIL: Expected \" + formatExpected[i] + \", got \" + result);\n+                fail(\"FAIL: Expected \" + formatExpected[i] + \", got \" + result);\n@@ -408,1 +417,1 @@\n-                errln(\"FAIL: Expected \" + parseExpected[i] + \", got \" + result);\n+                fail(\"FAIL: Expected \" + parseExpected[i] + \", got \" + result);\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/NumberTest.java","additions":69,"deletions":60,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @library \/java\/text\/testlib\n@@ -29,0 +28,1 @@\n+ * @run junit PositionTest\n@@ -45,1 +45,1 @@\n-public class PositionTest extends IntlTest {\n+import org.junit.jupiter.api.Test;\n@@ -47,3 +47,3 @@\n-    public static void main(String[] args) throws Exception {\n-        new PositionTest().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class PositionTest {\n@@ -51,0 +51,1 @@\n+    @Test\n@@ -54,1 +55,1 @@\n-            logln(\"PP constructor() tested.\");\n+            System.out.println(\"PP constructor() tested.\");\n@@ -56,1 +57,1 @@\n-            errln(\"*** PP getIndex or constructor() result\");\n+            fail(\"*** PP getIndex or constructor() result\");\n@@ -63,1 +64,1 @@\n-                logln(\"PP getIndex and constructor(TextOffset) tested.\");\n+                System.out.println(\"PP getIndex and constructor(TextOffset) tested.\");\n@@ -65,1 +66,1 @@\n-                errln(\"*** PP getIndex or constructor(TextOffset) result\");\n+                fail(\"*** PP getIndex or constructor(TextOffset) result\");\n@@ -69,1 +70,1 @@\n-                logln(\"PP setIndex tested.\");\n+                System.out.println(\"PP setIndex tested.\");\n@@ -71,1 +72,1 @@\n-                errln(\"*** PP getIndex or setIndex result\");\n+                fail(\"*** PP getIndex or setIndex result\");\n@@ -80,1 +81,1 @@\n-            logln(\"PP not equals tested.\");\n+            System.out.println(\"PP not equals tested.\");\n@@ -82,1 +83,1 @@\n-            errln(\"*** PP not equals fails\");\n+            fail(\"*** PP not equals fails\");\n@@ -85,1 +86,1 @@\n-            logln(\"PP equals tested.\");\n+            System.out.println(\"PP equals tested.\");\n@@ -87,1 +88,1 @@\n-            errln(\"*** PP equals fails (\" + pp3.getIndex() + \" != \" + pp4.getIndex() + \")\");\n+            fail(\"*** PP equals fails (\" + pp3.getIndex() + \" != \" + pp4.getIndex() + \")\");\n@@ -93,1 +94,1 @@\n-            logln(\"PP operator= tested.\");\n+            System.out.println(\"PP operator= tested.\");\n@@ -95,1 +96,1 @@\n-            errln(\"*** PP operator= operator== or operator != result\");\n+            fail(\"*** PP operator= operator== or operator != result\");\n@@ -100,0 +101,1 @@\n+    @Test\n@@ -104,1 +106,1 @@\n-            logln(\"FP constructor(int) and getField tested.\");\n+            System.out.println(\"FP constructor(int) and getField tested.\");\n@@ -106,1 +108,1 @@\n-            errln(\"*** FP constructor(int) or getField\");\n+            fail(\"*** FP constructor(int) or getField\");\n@@ -110,1 +112,1 @@\n-        if ( fph.getField() != 3) errln(\"*** FP getField or heap constr.\");\n+        if ( fph.getField() != 3) fail(\"*** FP getField or heap constr.\");\n@@ -124,1 +126,1 @@\n-            logln(\"FP setField and getField tested.\");\n+            System.out.println(\"FP setField and getField tested.\");\n@@ -126,1 +128,1 @@\n-            errln(\"*** FP setField or getField\");\n+            fail(\"*** FP setField or getField\");\n@@ -129,1 +131,1 @@\n-            logln(\"FP setBeginIndex and getBeginIndex tested.\");\n+            System.out.println(\"FP setBeginIndex and getBeginIndex tested.\");\n@@ -131,1 +133,1 @@\n-            errln(\"*** FP setBeginIndex or getBeginIndex\");\n+            fail(\"*** FP setBeginIndex or getBeginIndex\");\n@@ -134,1 +136,1 @@\n-            logln(\"FP setEndIndex and getEndIndex tested.\");\n+            System.out.println(\"FP setEndIndex and getEndIndex tested.\");\n@@ -136,1 +138,1 @@\n-            errln(\"*** FP setEndIndex or getEndIndex\");\n+            fail(\"*** FP setEndIndex or getEndIndex\");\n@@ -139,1 +141,1 @@\n-        logln(\"\");\n+        System.out.println(\"\");\n@@ -142,0 +144,1 @@\n+    @Test\n@@ -167,1 +170,1 @@\n-            logln(\"FP \" + temp + res);\n+            System.out.println(\"FP \" + temp + res);\n@@ -170,1 +173,1 @@\n-        logln(\"\");\n+        System.out.println(\"\");\n@@ -175,0 +178,1 @@\n+    @Test\n@@ -181,1 +185,1 @@\n-            errln(\"Error : ParsePosition.equals() failed\");\n+            fail(\"Error : ParsePosition.equals() failed\");\n@@ -185,1 +189,1 @@\n-            errln(\"Error : FieldPosition.equals() failed\");\n+            fail(\"Error : FieldPosition.equals() failed\");\n@@ -192,0 +196,1 @@\n+    @Test\n@@ -196,1 +201,1 @@\n-            errln(\"\" + p + \" and \" + q + \" are not equal and should be\");\n+            fail(\"\" + p + \" and \" + q + \" are not equal and should be\");\n@@ -199,1 +204,1 @@\n-            errln(\"ParsePosition.hashCode() different for equal objects\");\n+            fail(\"ParsePosition.hashCode() different for equal objects\");\n@@ -201,1 +206,1 @@\n-            logln(\"hashCode(\" + p + \") = \" + p.hashCode());\n+            System.out.println(\"hashCode(\" + p + \") = \" + p.hashCode());\n@@ -209,0 +214,1 @@\n+    @Test\n@@ -213,1 +219,1 @@\n-            errln(\"\" + p + \" and \" + q + \" are not equal and should be\");\n+            fail(\"\" + p + \" and \" + q + \" are not equal and should be\");\n@@ -216,1 +222,1 @@\n-            errln(\"FieldPosition.hashCode() different for equal objects\");\n+            fail(\"FieldPosition.hashCode() different for equal objects\");\n@@ -218,1 +224,1 @@\n-            logln(\"hashCode(\" + p + \") = \" + p.hashCode());\n+            System.out.println(\"hashCode(\" + p + \") = \" + p.hashCode());\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/PositionTest.java","additions":44,"deletions":38,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,2 @@\n- * @library \/java\/text\/testlib\n- * @build FormatIteratorTest PParser IntlTest\n- * @run main FormatIteratorTest\n+ * @build FormatIteratorTest PParser\n+ * @run junit\/othervm FormatIteratorTest\n@@ -42,0 +41,5 @@\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n@@ -97,1 +101,14 @@\n-public class FormatIteratorTest extends IntlTest {\n+public class FormatIteratorTest {\n+\n+    \/*\n+     * Change JVM default Locale and TimeZone.\n+     * The current tests are only appropriate for US. If tests are\n+     * added for other locales are added, then a property should be\n+     * added to each file (test) to be able to specify the locale.\n+     *\/\n+    @BeforeAll\n+    static void initAll() {\n+        Locale.setDefault(Locale.US);\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"America\/Los_Angeles\"));\n+    }\n+\n@@ -102,26 +119,0 @@\n-    public static final Object ARG0_FIELD_ID = MessageFormat.\n-                                                     Field.ARGUMENT;\n-    public static final Object ARG1_FIELD_ID = MessageFormat.\n-                                                     Field.ARGUMENT;\n-    public static final Object ARG2_FIELD_ID = MessageFormat.\n-                                                     Field.ARGUMENT;\n-    public static final Object ARG3_FIELD_ID = MessageFormat.\n-                                                     Field.ARGUMENT;\n-\n-    public static void main(String[] args) throws Exception {\n-        Locale reservedLocale = Locale.getDefault();\n-        TimeZone reservedTimeZone = TimeZone.getDefault();\n-        try {\n-            \/\/ The current tests are only appropriate for US. If tests are\n-            \/\/ added for other locales are added, then a property should be\n-            \/\/ added to each file (test) to be able to specify the locale.\n-            Locale.setDefault(Locale.US);\n-            TimeZone.setDefault(TimeZone.getTimeZone(\"America\/Los_Angeles\"));\n-            new FormatIteratorTest().run(args);\n-        } finally {\n-            \/\/ restore the reserved locale and time zone\n-            Locale.setDefault(reservedLocale);\n-            TimeZone.setDefault(reservedTimeZone);\n-        }\n-    }\n-\n@@ -131,0 +122,1 @@\n+    @Test\n@@ -136,0 +128,1 @@\n+    @Test\n@@ -141,0 +134,1 @@\n+    @Test\n@@ -149,1 +143,1 @@\n-            logln(\"testing: \" + file);\n+            System.out.println(\"testing: \" + file);\n@@ -156,1 +150,1 @@\n-                logln(\"creating: \" + (counter \/ 2));\n+                System.out.println(\"creating: \" + (counter \/ 2));\n@@ -161,1 +155,1 @@\n-                logln(\"verifying: \" + (counter \/ 2));\n+                System.out.println(\"verifying: \" + (counter \/ 2));\n@@ -165,1 +159,1 @@\n-            errln(\"Error reading: \" + ioe);\n+            fail(\"Error reading: \" + ioe);\n@@ -178,1 +172,1 @@\n-            errln(\"text doesn't match, got: \" + getText(iterator));\n+            fail(\"text doesn't match, got: \" + getText(iterator));\n@@ -181,1 +175,1 @@\n-            errln(\"Bogus start: \" + iterator.getBeginIndex());\n+            fail(\"Bogus start: \" + iterator.getBeginIndex());\n@@ -184,1 +178,1 @@\n-            errln(\"Bogus end: \" + iterator.getEndIndex());\n+            fail(\"Bogus end: \" + iterator.getEndIndex());\n@@ -191,1 +185,1 @@\n-                errln(\"Attributes don't match at \" + counter + \" expecting \" +\n+                fail(\"Attributes don't match at \" + counter + \" expecting \" +\n@@ -202,1 +196,1 @@\n-                errln(\"Attributes don't match at \" + counter + \" expecting \" +\n+                fail(\"Attributes don't match at \" + counter + \" expecting \" +\n@@ -246,1 +240,1 @@\n-                errln(\"Begin doesn't match want \" + begin + \" got \" +\n+                fail(\"Begin doesn't match want \" + begin + \" got \" +\n@@ -251,1 +245,1 @@\n-                errln(\"Begin2 doesn't match want \" + begin2 + \" got \" +\n+                fail(\"Begin2 doesn't match want \" + begin2 + \" got \" +\n@@ -256,1 +250,1 @@\n-                errln(\"End doesn't match want \" + end + \" got \" +\n+                fail(\"End doesn't match want \" + end + \" got \" +\n@@ -261,1 +255,1 @@\n-                errln(\"End2 doesn't match want \" + end2 + \" got \" +\n+                fail(\"End2 doesn't match want \" + end2 + \" got \" +\n@@ -315,1 +309,1 @@\n-            errln(\"bogus begin want \" + begin + \" got \" + fp.getBeginIndex() +\n+            fail(\"bogus begin want \" + begin + \" got \" + fp.getBeginIndex() +\n@@ -319,1 +313,1 @@\n-            errln(\"bogus end want \" + end + \" got \" + fp.getEndIndex() +\n+            fail(\"bogus end want \" + end + \" got \" + fp.getEndIndex() +\n@@ -323,1 +317,1 @@\n-            errln(\"Text does not match, want !\" + buffer.toString() +\n+            fail(\"Text does not match, want !\" + buffer.toString() +\n@@ -334,1 +328,1 @@\n-        logln(\"Created format: \" + format + \" value \" + value);\n+        System.out.println(\"Created format: \" + format + \" value \" + value);\n@@ -338,1 +332,1 @@\n-        logln(\"Obtained Iterator: \" + aci);\n+        System.out.println(\"Obtained Iterator: \" + aci);\n@@ -376,1 +370,1 @@\n-            errln(\"Error creating instance \" + th);\n+            fail(\"Error creating instance \" + th);\n@@ -416,1 +410,1 @@\n-        errln(\"Could not lookup field \" + name + \" \" + error);\n+        fail(\"Could not lookup field \" + name + \" \" + error);\n","filename":"test\/jdk\/java\/text\/Format\/common\/FormatIteratorTest.java","additions":45,"deletions":51,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @library \/java\/text\/testlib\n@@ -31,1 +30,1 @@\n- * @run main\/timeout=30 ICUBasicTest\n+ * @run junit\/timeout=30 ICUBasicTest\n@@ -48,1 +47,1 @@\n-public class ICUBasicTest extends IntlTest {\n+import org.junit.jupiter.api.Test;\n@@ -50,3 +49,3 @@\n-    public static void main(String[] args) throws Exception {\n-        new ICUBasicTest().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class ICUBasicTest {\n@@ -80,0 +79,1 @@\n+    @Test\n@@ -119,4 +119,1 @@\n-                errln(\"unexpected result for case \" + i + \". Expected=\"\n-                      + cases[i].expect + \", Actual=\" + output);\n-            } else if (verbose) {\n-                logln(\"expected result for case \" + i + \". Expected=\"\n+                fail(\"unexpected result for case \" + i + \". Expected=\"\n@@ -147,0 +144,1 @@\n+    @Test\n@@ -153,1 +151,1 @@\n-            errln(\"Reordering of combining marks failed. Expected: \" +\n+            fail(\"Reordering of combining marks failed. Expected: \" +\n@@ -162,0 +160,1 @@\n+    @Test\n@@ -167,1 +166,1 @@\n-             errln(\"ERROR in NFC of string\");\n+             fail(\"ERROR in NFC of string\");\n@@ -181,0 +180,1 @@\n+    @Test\n@@ -197,1 +197,1 @@\n-                errln(\"FAIL input: \" + HexFormat.of().withDelimiter(\" \")\n+                fail(\"FAIL input: \" + HexFormat.of().withDelimiter(\" \")\n@@ -207,1 +207,1 @@\n-                errln(\"FAIL input: \" + HexFormat.of().withDelimiter(\" \")\n+                fail(\"FAIL input: \" + HexFormat.of().withDelimiter(\" \")\n@@ -226,0 +226,1 @@\n+    @Test\n@@ -243,1 +244,1 @@\n-                logln(\"Ok: \" + HexFormat.of().withDelimiter(\" \")\n+                System.out.println(\"Ok: \" + HexFormat.of().withDelimiter(\" \")\n@@ -248,1 +249,1 @@\n-                errln(\"FAIL: \" + HexFormat.of().withDelimiter(\" \")\n+                fail(\"FAIL: \" + HexFormat.of().withDelimiter(\" \")\n@@ -259,1 +260,1 @@\n-                logln(\"Ok: \" + HexFormat.of().withDelimiter(\" \").formatHex(b.getBytes()) + \" x DECOMP => \" +\n+                System.out.println(\"Ok: \" + HexFormat.of().withDelimiter(\" \").formatHex(b.getBytes()) + \" x DECOMP => \" +\n@@ -262,1 +263,1 @@\n-                errln(\"FAIL: \" + HexFormat.of().withDelimiter(\" \").formatHex(b.getBytes()) + \" x DECOMP => \" +\n+                fail(\"FAIL: \" + HexFormat.of().withDelimiter(\" \").formatHex(b.getBytes()) + \" x DECOMP => \" +\n@@ -272,0 +273,1 @@\n+    @Test\n@@ -400,8 +402,1 @@\n-            errln(\"FAIL: \" + HexFormat.of().withDelimiter(\" \")\n-                    .formatHex(a.getBytes()) + \" x DECOMP_COMPAT => \" +\n-                  HexFormat.of().withDelimiter(\" \")\n-                          .formatHex(b.getBytes()) + \" x COMPOSE => \" +\n-                  HexFormat.of().withDelimiter(\" \")\n-                          .formatHex(c.getBytes()) + \" for the latest Unicode\");\n-        } else if (verbose) {\n-            logln(\"Ok: \" + HexFormat.of().withDelimiter(\" \")\n+            fail(\"FAIL: \" + HexFormat.of().withDelimiter(\" \")\n@@ -418,6 +413,1 @@\n-            errln(\"FAIL: \" + HexFormat.of().withDelimiter(\" \")\n-                    .formatHex(a.getBytes()) + \" x DECOMP_COMPAT => \" +\n-                  HexFormat.of().withDelimiter(\" \").formatHex(b.getBytes()) + \" x COMPOSE => \" +\n-                  HexFormat.of().withDelimiter(\" \").formatHex(c.getBytes()) + \" for Unicode 3.2.0\");\n-        } else if (verbose) {\n-            logln(\"Ok: \" + HexFormat.of().withDelimiter(\" \")\n+            fail(\"FAIL: \" + HexFormat.of().withDelimiter(\" \")\n@@ -430,0 +420,1 @@\n+    @Test\n@@ -444,0 +435,1 @@\n+    @Test\n@@ -577,0 +569,1 @@\n+    @Test\n@@ -581,0 +574,1 @@\n+    @Test\n@@ -585,0 +579,1 @@\n+    @Test\n@@ -589,0 +584,1 @@\n+    @Test\n@@ -598,1 +594,1 @@\n-            logln(\"Normalizing '\" + input + \"' (\" + HexFormat.of()\n+            System.out.println(\"Normalizing '\" + input + \"' (\" + HexFormat.of()\n@@ -605,1 +601,1 @@\n-                errln(\"FAIL: case \" + i\n+                fail(\"FAIL: case \" + i\n@@ -624,0 +620,1 @@\n+    @Test\n@@ -625,1 +622,1 @@\n-        logln(\"Canonical composition...\");\n+        System.out.println(\"Canonical composition...\");\n@@ -629,0 +626,1 @@\n+    @Test\n@@ -630,1 +628,1 @@\n-        logln(\"Canonical decomposition...\");\n+        System.out.println(\"Canonical decomposition...\");\n","filename":"test\/jdk\/java\/text\/Normalizer\/ICUBasicTest.java","additions":35,"deletions":37,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @library \/java\/text\/testlib\n@@ -31,1 +30,1 @@\n- * @run main\/timeout=30 NormalizerAPITest\n+ * @run junit\/timeout=30 NormalizerAPITest\n@@ -37,0 +36,4 @@\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n@@ -44,1 +47,1 @@\n-public class NormalizerAPITest extends IntlTest {\n+public class NormalizerAPITest {\n@@ -74,4 +77,0 @@\n-    public static void main(String[] args) throws Exception {\n-        new NormalizerAPITest().run(args);\n-    }\n-\n@@ -81,0 +80,1 @@\n+    @Test\n@@ -103,1 +103,1 @@\n-             errln(\"normalize(null) should throw NullPointerException.\");\n+             fail(\"normalize(null) should throw NullPointerException.\");\n@@ -110,0 +110,1 @@\n+    @Test\n@@ -134,1 +135,1 @@\n-             errln(\"normalize(null) should throw NullPointerException.\");\n+             fail(\"normalize(null) should throw NullPointerException.\");\n@@ -141,0 +142,1 @@\n+    @Test\n@@ -163,1 +165,1 @@\n-             errln(\"isNormalized(null) should throw NullPointerException.\");\n+             fail(\"isNormalized(null) should throw NullPointerException.\");\n@@ -170,0 +172,1 @@\n+    @Test\n@@ -194,1 +197,1 @@\n-             errln(\"isNormalized(null) should throw NullPointerException.\");\n+             fail(\"isNormalized(null) should throw NullPointerException.\");\n@@ -202,0 +205,1 @@\n+    @Test\n@@ -218,1 +222,1 @@\n-             errln(\"normalize() for String(\\\"\\\") should return \\\"\\\".\");\n+             fail(\"normalize() for String(\\\"\\\") should return \\\"\\\".\");\n@@ -226,0 +230,1 @@\n+    @Test\n@@ -243,1 +248,1 @@\n-             errln(\"normalize() for String(\\\"\\\") should return \\\"\\\".\");\n+             fail(\"normalize() for String(\\\"\\\") should return \\\"\\\".\");\n@@ -251,0 +256,1 @@\n+    @Test\n@@ -266,1 +272,1 @@\n-             errln(\"isNormalized() for String(\\\"\\\") should not return true.\");\n+             fail(\"isNormalized() for String(\\\"\\\") should not return true.\");\n@@ -274,0 +280,1 @@\n+    @Test\n@@ -291,1 +298,1 @@\n-             errln(\"isNormalized() for String(\\\"\\\") should not return true.\");\n+             fail(\"isNormalized() for String(\\\"\\\") should not return true.\");\n@@ -299,0 +306,1 @@\n+    @Test\n@@ -318,1 +326,1 @@\n-            errln(\"java.text.Normalizer.normalize(\" +\n+            fail(\"java.text.Normalizer.normalize(\" +\n@@ -324,1 +332,1 @@\n-            errln(\"sun.text.Normalizer.normalize(\" +\n+            fail(\"sun.text.Normalizer.normalize(\" +\n@@ -329,1 +337,1 @@\n-            errln(\"java.text.Normalizer.isNormalize(\" +\n+            fail(\"java.text.Normalizer.isNormalize(\" +\n@@ -334,1 +342,1 @@\n-            errln(\"sun.text.Normalizer.isNormalize(\" +\n+            fail(\"sun.text.Normalizer.isNormalize(\" +\n","filename":"test\/jdk\/java\/text\/Normalizer\/NormalizerAPITest.java","additions":28,"deletions":20,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -40,1 +41,5 @@\n-public class HexDumpReader {\n+public final class HexDumpReader {\n+\n+    \/\/ Utility class should not be instantiated\n+    private HexDumpReader() {}\n+\n@@ -51,1 +56,1 @@\n-                                                            \"us-ascii\"))) {\n+                StandardCharsets.US_ASCII))) {\n","filename":"test\/jdk\/java\/text\/testlib\/HexDumpReader.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,262 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.ArrayList;\n-import java.util.Comparator;\n-import java.util.Map;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n-\n-\/**\n- * IntlTest is a base class for tests that can be run conveniently from\n- * the command line as well as under the Java test harness.\n- * <p>\n- * Sub-classes implement a set of public void methods named \"Test*\" or\n- * \"test*\" with no arguments. Each of these methods performs some\n- * test. Test methods should indicate errors by calling either err() or\n- * errln().  This will increment the errorCount field and may optionally\n- * print a message to the log.  Debugging information may also be added to\n- * the log via the log and logln methods.  These methods will add their\n- * arguments to the log only if the test is being run in verbose mode.\n- *\/\n-public abstract class IntlTest {\n-\n-    \/\/------------------------------------------------------------------------\n-    \/\/ Everything below here is boilerplate code that makes it possible\n-    \/\/ to add a new test by simply adding a method to an existing class.\n-    \/\/------------------------------------------------------------------------\n-    protected IntlTest() {\n-        Class<? extends IntlTest> testClass = getClass();\n-        testName = testClass.getCanonicalName();\n-        \/\/ Populate testMethods with all the test methods.\n-        Method[] methods = testClass.getDeclaredMethods();\n-        for (Method method : methods) {\n-            if (Modifier.isPublic(method.getModifiers())\n-                && method.getReturnType() == void.class\n-                && method.getParameterCount() == 0) {\n-                String name = method.getName();\n-                if (name.length() > 4) {\n-                    if (name.startsWith(\"Test\") || name.startsWith(\"test\")) {\n-                        testMethods.put(name, method);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    protected void run(String[] args) throws Exception {\n-        \/\/ Set up the log and reference streams.  We use PrintWriters in order to\n-        \/\/ take advantage of character conversion.  The JavaEsc converter will\n-        \/\/ convert Unicode outside the ASCII range to Java's \\\\uxxxx notation.\n-        log = new PrintWriter(System.out, true);\n-        List<Method> testsToRun = configureTestsAndArgs(args);\n-        System.out.println(testName + \" {\");\n-        indentLevel++;\n-\n-        \/\/ Run the list of tests given in the test arguments\n-        for (Method testMethod : testsToRun) {\n-            int oldCount = errorCount;\n-            String testName = testMethod.getName();\n-            writeTestName(testName);\n-            try {\n-                testMethod.invoke(this);\n-            } catch (IllegalAccessException e) {\n-                errln(\"Can't access test method \" + testName);\n-            } catch (InvocationTargetException e) {\n-                \/\/ Log exception first, that way if -nothrow is\n-                \/\/ not an arg, the original exception is still logged\n-                logExc(e);\n-                errln(String.format(\"$$$ Uncaught exception thrown in %s,\" +\n-                        \" see above for cause\", testName));\n-            }\n-            writeTestResult(errorCount - oldCount);\n-        }\n-        indentLevel--;\n-        if (prompt) {\n-            System.out.println(\"Hit RETURN to exit...\");\n-            try {\n-                System.in.read();\n-            } catch (IOException e) {\n-                System.out.println(\"Exception: \" + e.toString() + e.getMessage());\n-            }\n-        }\n-        if (exitCode) {\n-            System.exit(errorCount);\n-        }\n-        if (errorCount > 0) {\n-            throw new RuntimeException(String.format(\n-                    \"$$$ %s FAILED with %s failures%n\", testName, errorCount));\n-        } else {\n-            log.println(String.format(\"\\t$$$ %s PASSED%n\", testName));\n-        }\n-    }\n-\n-    private List<Method> configureTestsAndArgs(String[] args) {\n-        \/\/ Parse the test arguments. They can be either the flag\n-        \/\/ \"-verbose\" or names of test methods. Create a list of\n-        \/\/ tests to be run.\n-        List<Method> testsToRun = new ArrayList<>(args.length);\n-        for (String arg : args) {\n-            switch (arg) {\n-                case \"-verbose\" -> verbose = true;\n-                case \"-prompt\" -> prompt = true;\n-                case \"-nothrow\" -> nothrow = true;\n-                case \"-exitcode\" -> exitCode = true;\n-                default -> {\n-                    Method m = testMethods.get(arg);\n-                    if (m == null) {\n-                        System.out.println(\"Method \" + arg + \": not found\");\n-                        usage();\n-                        return testsToRun;\n-                    }\n-                    testsToRun.add(m);\n-                }\n-            }\n-        }\n-        \/\/ If no test method names were given explicitly, run them all.\n-        if (testsToRun.isEmpty()) {\n-            testsToRun.addAll(testMethods.values());\n-        }\n-        \/\/ Arbitrarily sort the tests, so that they are run in the same order every time\n-        testsToRun.sort(Comparator.comparing(Method::getName));\n-        return testsToRun;\n-    }\n-\n-    \/**\n-     * Adds the given message to the log if we are in verbose mode.\n-     *\/\n-    protected void log(String message) {\n-        logImpl(message, false);\n-    }\n-\n-    protected void logln(String message) {\n-        logImpl(message, true);\n-    }\n-\n-    protected void logln() {\n-        logImpl(null, true);\n-    }\n-\n-    private void logImpl(String message, boolean newline) {\n-        if (verbose) {\n-            if (message != null) {\n-                indent(indentLevel + 1);\n-                log.print(message);\n-            }\n-            if (newline) {\n-                log.println();\n-            }\n-        }\n-    }\n-\n-    private void logExc(InvocationTargetException ite) {\n-        indent(indentLevel);\n-        ite.getTargetException().printStackTrace(this.log);\n-    }\n-\n-    protected void err(String message) {\n-        errImpl(message, false);\n-    }\n-\n-    protected void errln(String message) {\n-        errImpl(message, true);\n-    }\n-\n-    private void errImpl(String message, boolean newline) {\n-        errorCount++;\n-        indent(indentLevel + 1);\n-        log.print(message);\n-        if (newline) {\n-            log.println();\n-        }\n-        log.flush();\n-\n-        if (!nothrow) {\n-            throw new RuntimeException(message);\n-        }\n-    }\n-\n-    protected int getErrorCount() {\n-        return errorCount;\n-    }\n-\n-    protected void writeTestName(String testName) {\n-        indent(indentLevel);\n-        log.print(testName);\n-        log.flush();\n-        needLineFeed = true;\n-    }\n-\n-    protected void writeTestResult(int count) {\n-        if (!needLineFeed) {\n-            indent(indentLevel);\n-            log.print(\"}\");\n-        }\n-        needLineFeed = false;\n-\n-        if (count != 0) {\n-            log.println(\" FAILED\");\n-        } else {\n-            log.println(\" Passed\");\n-        }\n-    }\n-\n-    private void indent(int distance) {\n-        if (needLineFeed) {\n-            log.println(\" {\");\n-            needLineFeed = false;\n-        }\n-        log.print(SPACES.substring(0, distance * 2));\n-    }\n-\n-    \/**\n-     * Print a usage message for this test class.\n-     *\/\n-    void usage() {\n-        System.out.println(getClass().getName() +\n-                            \": [-verbose] [-nothrow] [-exitcode] [-prompt] [test names]\");\n-\n-        System.out.println(\"  Available test names:\");\n-        for (String methodName : testMethods.keySet()) {\n-            System.out.println(\"\\t\" + methodName);\n-        }\n-    }\n-    private final String testName;\n-    private boolean     prompt;\n-    private boolean     nothrow;\n-    protected boolean   verbose;\n-    private boolean     exitCode;\n-    private PrintWriter log;\n-    private int         indentLevel;\n-    private boolean     needLineFeed;\n-    private int         errorCount;\n-\n-    private final Map<String, Method> testMethods = new LinkedHashMap<>();\n-\n-    private static final String SPACES = \"                                          \";\n-}\n","filename":"test\/jdk\/java\/text\/testlib\/IntlTest.java","additions":0,"deletions":262,"binary":false,"changes":262,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,3 @@\n+import java.text.CollationElementIterator;\n+import java.text.CollationKey;\n+import java.text.Collator;\n@@ -29,2 +32,0 @@\n-import java.util.Locale.Builder;\n-\n@@ -32,5 +33,1 @@\n- * TestUtils provides utility methods to get a locale-dependent attribute.\n- * For example,\n- *   - whether or not a non-Gregorian calendar is used\n- *   - whether or not non-ASCII digits are used\n- *\n+ * TestUtils provides utility methods used by i18n related tests.\n@@ -38,1 +35,9 @@\n- * localization and is not versatile.\n+ * localization and is not versatile. This class is split into the following sections,\n+ * 1) Methods to get a locale-dependent attribute.\n+ * For example,\n+ *   - whether a non-Gregorian calendar is used\n+ *   - whether non-ASCII digits are used\n+ * 2) Methods that help Collator related tests\n+ * For example,\n+ *   - compare CollationElementIterators\n+ *   - test the expected relation key result for a Collator\n@@ -40,1 +45,8 @@\n-public class TestUtils {\n+public final class TestUtils {\n+\n+    \/\/ Utility class should not be instantiated\n+    private TestUtils() {}\n+\n+    \/*\n+     * The below methods are utilities for getting locale-dependent attributes.\n+     *\/\n@@ -59,1 +71,0 @@\n-     *\n@@ -74,0 +85,99 @@\n+    \/*\n+     * The below methods are utilities specific to the Collation tests\n+     *\/\n+\n+    \/**\n+     * Compares two CollationElementIterators and throws an exception\n+     * with a message detailing which collation elements were not equal\n+     *\/\n+    public static void compareCollationElementIters(CollationElementIterator i1, CollationElementIterator i2) {\n+        int c1, c2, count = 0;\n+        do {\n+            c1 = i1.next();\n+            c2 = i2.next();\n+            if (c1 != c2) {\n+                throw new RuntimeException(\"    \" + count + \": \" + c1 + \" != \" + c2);\n+            }\n+            count++;\n+        } while (c1 != CollationElementIterator.NULLORDER);\n+    }\n+\n+    \/\/ Replace non-printable characters with unicode escapes\n+    public static String prettify(String str) {\n+        StringBuilder result = new StringBuilder();\n+\n+        String zero = \"0000\";\n+\n+        for (int i = 0; i < str.length(); i++) {\n+            char ch = str.charAt(i);\n+            if (ch < 0x09 || (ch > 0x0A && ch < 0x20)|| (ch > 0x7E && ch < 0xA0) || ch > 0x100) {\n+                String hex = Integer.toString((int)ch,16);\n+\n+                result.append(\"\\\\u\").append(zero.substring(0, 4 - hex.length())).append(hex);\n+            } else {\n+                result.append(ch);\n+            }\n+        }\n+        return result.toString();\n+    }\n+\n+    \/\/ Produce a printable representation of a CollationKey\n+    public static String prettifyCKey(CollationKey key) {\n+        StringBuilder result = new StringBuilder();\n+        byte[] bytes = key.toByteArray();\n+\n+        for (int i = 0; i < bytes.length; i += 2) {\n+            int val = (bytes[i] << 8) + bytes[i+1];\n+            result.append(Integer.toString(val, 16)).append(\" \");\n+        }\n+        return result.toString();\n+    }\n+\n+    \/**\n+     * Utility to test a collator with an array of test values.\n+     * See the other doTest() method for specific comparison details.\n+     *\/\n+    public static void doCollatorTest(Collator col, int strength,\n+                                      String[] source, String[] target, int[] result) {\n+        if (source.length != target.length) {\n+            throw new RuntimeException(\"Data size mismatch: source = \" +\n+                    source.length + \", target = \" + target.length);\n+        }\n+        if (source.length != result.length) {\n+            throw new RuntimeException(\"Data size mismatch: source & target = \" +\n+                    source.length + \", result = \" + result.length);\n+        }\n+\n+        col.setStrength(strength);\n+        for (int i = 0; i < source.length ; i++) {\n+            doCollatorTest(col, source[i], target[i], result[i]);\n+        }\n+    }\n+\n+    \/**\n+     * Test that a collator returns the correct relation result value when\n+     * comparing a source and target string. Also tests that the compare and collation\n+     * key results return the same value.\n+     *\/\n+    public static void doCollatorTest(Collator col,\n+                                      String source, String target, int result) {\n+        char relation = '=';\n+        if (result <= -1) {\n+            relation = '<';\n+        } else if (result >= 1) {\n+            relation = '>';\n+        }\n+\n+        int compareResult = col.compare(source, target);\n+        CollationKey sortKey1 = col.getCollationKey(source);\n+        CollationKey sortKey2 = col.getCollationKey(target);\n+        int keyResult = sortKey1.compareTo(sortKey2);\n+        if (compareResult != keyResult) {\n+            throw new RuntimeException(\"Compare and Collation Key results are different! Source = \" +\n+                    source + \" Target = \" + target);\n+        }\n+        if (keyResult != result) {\n+            throw new RuntimeException(\"Collation Test failed! Source = \" + source + \" Target = \" +\n+                    target + \" result should be \" + relation);\n+        }\n+    }\n","filename":"test\/jdk\/java\/text\/testlib\/TestUtils.java","additions":121,"deletions":11,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,3 @@\n- * @summary Confirm that BuddhistCalendar's add(), roll() and toString() work correctly with Buddhist Era years.\n+ * @summary Confirm that BuddhistCalendar's add(), roll(), set(), and toString()\n+ *          work correctly with Buddhist Era years.\n+ * @run junit BuddhistCalendarTest\n@@ -33,1 +35,21 @@\n-import static java.util.Calendar.*;\n+import java.util.stream.Stream;\n+\n+import static java.util.Calendar.APRIL;\n+import static java.util.Calendar.DATE;\n+import static java.util.Calendar.DECEMBER;\n+import static java.util.Calendar.ERA;\n+import static java.util.Calendar.FEBRUARY;\n+import static java.util.Calendar.JANUARY;\n+import static java.util.Calendar.MAY;\n+import static java.util.Calendar.MONTH;\n+import static java.util.Calendar.WEEK_OF_YEAR;\n+import static java.util.Calendar.YEAR;\n+\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -39,5 +61,86 @@\n-    public static void main(String[] args) {\n-        testAddRoll();\n-        testToString();\n-        testException();\n-        testLeastMax();\n+    \/*\n+     * Test some add values for the BuddhistCalendar. This test compares the same field\n+     * as the one added.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"addDataProvider\")\n+    public void buddhistAddTest(Calendar cal, int amount, int fieldToAdd) {\n+        int base = cal.get(YEAR);\n+        cal.add(fieldToAdd, amount);\n+        int yearAfterRoll = cal.get(YEAR);\n+        assertEquals(yearAfterRoll, base+amount, String.format(\n+                \"Added: %s to field: %s\", amount, fieldToAdd));\n+    }\n+\n+    \/*\n+     * Given in the format: Calendar, amount to add, and field to add.\n+     * Test adding of positive and negative year values.\n+     *\/\n+    private static Stream<Arguments> addDataProvider() {\n+        return Stream.of(\n+                Arguments.of(getBuddhistCalendar(), 1, YEAR),\n+                Arguments.of(getBuddhistCalendar(), -3, YEAR)\n+        );\n+    }\n+\n+    \/*\n+     * Test some add values for the BuddhistCalendar. Compare a bigger field\n+     * (year) than the one added (month). Larger field should roll over.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"alternateAddDataProvider\")\n+    public void buddhistAlternateAddTest(Calendar cal, int amount, int fieldToAdd) {\n+        int base = cal.get(YEAR);\n+        cal.add(fieldToAdd, amount);\n+        int yearAfterRoll = cal.get(YEAR);\n+        assertEquals(yearAfterRoll, (amount>0) ? (base+1): (base-1), String.format(\n+                \"Added: %s to field: %s\", amount, fieldToAdd));\n+    }\n+\n+    \/*\n+     * Given in the format: Calendar, amount to add, and field to add.\n+     * Test adding of positive and negative month values.\n+     *\/\n+    private static Stream<Arguments> alternateAddDataProvider() {\n+        return Stream.of(\n+                Arguments.of(getBuddhistCalendarBuilder().set(MONTH, DECEMBER).build(), 2, MONTH),\n+                Arguments.of(getBuddhistCalendarBuilder().set(MONTH, FEBRUARY).build(), -4, MONTH)\n+                );\n+    }\n+\n+    \/*\n+     * Test some roll values for the BuddhistCalendar. Compare same field\n+     * that was rolled, value should change.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"rollProvider\")\n+    public void buddhistRollTest(Calendar cal, int amount, int fieldToRoll) {\n+        int base = cal.get(YEAR);\n+        cal.roll(fieldToRoll, amount);\n+        int year = cal.get(YEAR);\n+        assertEquals(year, base+amount, \"Rolling field should change value\");\n+    }\n+\n+    \/*\n+     * Given in the format: Calendar, amount to roll, and field to roll.\n+     * Test rolling of positive and negative year values.\n+     *\/\n+    private static Stream<Arguments> rollProvider() {\n+        return Stream.of(\n+                Arguments.of(getBuddhistCalendar(), 2, YEAR),\n+                Arguments.of(getBuddhistCalendar(), -4, YEAR)\n+        );\n+    }\n+\n+    \/*\n+     * Set some calendar values and roll, however, measure a different\n+     * field than the field that was rolled. Rolling should not change the\n+     * larger field.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"alternateRollProvider\")\n+    public void buddhistAlternateRollTest(Calendar cal, int amount, int fieldToRoll) {\n+        int base = cal.get(YEAR);\n+        cal.roll(fieldToRoll, amount);\n+        int year = cal.get(YEAR);\n+        assertEquals(year, base, \"Rolling smaller field should not change bigger field\");\n@@ -46,2 +149,3 @@\n-    \/**\n-     * 4817812\n+    \/*\n+     * Given in the format: Calendar, amount to roll, and field to roll.\n+     * Test rolling of positive and negative week_of_year values.\n@@ -49,79 +153,13 @@\n-    static void testAddRoll() {\n-        Calendar cal;\n-        int base, year;\n-\n-        \/*\n-         * Test: BuddhistCalendar.add(YEAR)\n-         *\/\n-        cal = getBuddhistCalendar();\n-        base = cal.get(YEAR);\n-        cal.add(YEAR, 1);\n-        year = cal.get(YEAR);\n-        check(year, base+1, \"add(+YEAR)\");\n-\n-        cal = getBuddhistCalendar();\n-        base = cal.get(YEAR);\n-        cal.add(YEAR, -3);\n-        year = cal.get(YEAR);\n-        check(year, base-3, \"add(-YEAR)\");\n-\n-        \/*\n-         * Test BuddhistCalendar.add(MONTH)\n-         *\/\n-        cal = getBuddhistCalendar();\n-        base = cal.get(YEAR);\n-        cal.set(MONTH, DECEMBER);\n-        cal.add(MONTH, 2);\n-        year = cal.get(YEAR);\n-        check(year, base+1, \"add(+MONTH)\");\n-\n-        cal = getBuddhistCalendar();\n-        base = cal.get(YEAR);\n-        cal.set(MONTH, FEBRUARY);\n-        cal.add(MONTH, -4);\n-        year = cal.get(YEAR);\n-        check(year, base-1, \"add(-MONTH)\");\n-\n-        \/*\n-         * Test BuddhistCalendar.roll(YEAR)\n-         *\/\n-        cal = getBuddhistCalendar();\n-        base = cal.get(YEAR);\n-        cal.roll(YEAR, 2);\n-        year = cal.get(YEAR);\n-        check(year, base+2, \"roll(+YEAR)\");\n-\n-        cal = getBuddhistCalendar();\n-        base = cal.get(YEAR);\n-        cal.roll(YEAR, -4);\n-        year = cal.get(YEAR);\n-        check(year, base-4, \"roll(-YEAR)\");\n-\n-        \/*\n-         * Test BuddhistCalendar.roll(WEEK_OF_YEAR)\n-         *\/\n-        cal = getBuddhistCalendar();\n-        cal.set(YEAR, 2543);   \/\/ A.D.2000\n-        cal.set(MONTH, DECEMBER);\n-        cal.set(DATE, 31);\n-        base = cal.get(YEAR);\n-        check(base, 2543, \"roll(+WEEK_OF_YEAR)\");\n-        cal.roll(WEEK_OF_YEAR, 10);\n-        year = cal.get(YEAR);\n-        check(year, base, \"roll(+WEEK_OF_YEAR)\");\n-\n-        cal = getBuddhistCalendar();\n-        cal.set(YEAR, 2543);   \/\/ A.D.2000\n-        cal.set(MONTH, JANUARY);\n-        cal.set(DATE, 1);\n-        base = cal.get(YEAR);\n-        check(base, 2543, \"roll(+WEEK_OF_YEAR)\");\n-        cal.roll(WEEK_OF_YEAR, -10);\n-        year = cal.get(YEAR);\n-        check(year, base, \"roll(-WEEK_OF_YEAR)\");\n-\n-        \/*\n-         * Test Calendar.set(year, month, date)\n-         *\/\n-        cal = getBuddhistCalendar();\n-        base = cal.get(YEAR);\n+    private static Stream<Arguments> alternateRollProvider() {\n+        return Stream.of(\n+                Arguments.of(getBuddhistCalendarBuilder().set(YEAR, 2543)\n+                        .set(MONTH, DECEMBER).set(DATE, 31).build(), 10, WEEK_OF_YEAR),\n+                Arguments.of(getBuddhistCalendarBuilder().set(YEAR, 2543)\n+                        .set(MONTH, JANUARY).set(DATE, 1).build(), -10, WEEK_OF_YEAR)\n+        );\n+    }\n+\n+    \/\/ Test the overloaded set() methods. Check year value.\n+    @Test\n+    public void buddhistSetTest() {\n+        Calendar cal = getBuddhistCalendar();\n@@ -129,8 +167,1 @@\n-        year = cal.get(YEAR);\n-        check(year, 3001, \"set(year, month, date)\");\n-\n-        \/*\n-         * Test Calendar.set(year, month, date, hour, minute)\n-         *\/\n-        cal = getBuddhistCalendar();\n-        base = cal.get(YEAR);\n+        assertEquals(cal.get(YEAR), 3001);\n@@ -138,36 +169,9 @@\n-        year = cal.get(YEAR);\n-        check(year, 3020, \"set(year, month, date, hour, minute)\");\n-\n-        \/*\n-         * Test Calendar.set(year, month, date, hour, minute, second)\n-         *\/\n-        cal = getBuddhistCalendar();\n-        base = cal.get(YEAR);\n-        cal.set(3120, MAY, 20, 9, 10, 52);\n-        year = cal.get(YEAR);\n-        check(year, 3120, \"set(year, month, date, hour, minute, second)\");\n-\n-        \/*\n-         * Test BuddhistCalendar.getActualMaximum(YEAR);\n-         *    set(YEAR)\/get(YEAR) in this method doesn't affect the real\n-         *    YEAR value because a clone is used with set()&get().\n-         *\/\n-        cal = getBuddhistCalendar();\n-        base = cal.get(YEAR);\n-        int limit = cal.getActualMaximum(YEAR);\n-        year = cal.get(YEAR);\n-        check(year, base, \"BuddhistCalendar.getActualMaximum(YEAR)\");\n-\n-        \/*\n-         * Test BuddhistCalendar.getActualMinimum(YEAR);\n-         *   This doesn't call set(YEAR) nor get(YEAR), though.\n-         *\/\n-        cal = getBuddhistCalendar();\n-        base = cal.get(YEAR);\n-        limit = cal.getActualMinimum(YEAR);\n-        year = cal.get(YEAR);\n-        check(year, base, \"BuddhistCalendar.getActualMinimum(YEAR)\");\n-    }\n-\n-    \/**\n-     * 4847186: BuddhistCalendar: toString() returns Gregorian year\n+        assertEquals(cal.get(YEAR), 3020);\n+        cal.set(3120, MAY, 20, 9, 10, 52 );\n+        assertEquals(cal.get(YEAR), 3120);\n+    }\n+\n+    \/*\n+     * Test BuddhistCalendar.getActualMaximum(YEAR);\n+     * set(YEAR)\/get(YEAR) in this method doesn't affect the real\n+     * YEAR value because a clone is used with set() and get().\n@@ -175,1 +179,22 @@\n-    static void testToString() {\n+    @Test\n+    public void buddhistActualMaximumTest() {\n+        Calendar cal = getBuddhistCalendar();\n+        int base = cal.get(YEAR);\n+        int ignored = cal.getActualMaximum(YEAR);\n+        int year = cal.get(YEAR);\n+        assertEquals(year, base, \"BuddhistCalendar.getActualMaximum(YEAR)\");\n+    }\n+\n+    \/\/ Test BuddhistCalendar.getActualMinimum(YEAR), doesn't call set(YEAR) nor get(YEAR).\n+    @Test\n+    public void buddhistActualMinimumTest() {\n+        Calendar cal = getBuddhistCalendar();\n+        int base = cal.get(YEAR);\n+        int ignored = cal.getActualMinimum(YEAR);\n+        int year = cal.get(YEAR);\n+        assertEquals(year, base, \"BuddhistCalendar.getActualMinimum(YEAR)\");\n+    }\n+\n+    \/\/ 4847186: BuddhistCalendar: toString() returns Gregorian year\n+    @Test\n+    public void buddhistToStringTest() {\n@@ -180,4 +205,1 @@\n-        if (Integer.parseInt(y) != year) {\n-            throw new RuntimeException(\"toString(): wrong year value: got \" + y\n-                                       + \", expected \" + year);\n-        }\n+        assertEquals(year, Integer.parseInt(y), \"Wrong year value\");\n@@ -186,4 +208,3 @@\n-    \/**\n-     * 4956479: BuddhistCalendar methods may return wrong values after exception\n-     *\/\n-    static void testException() {\n+    \/\/ 4956479: BuddhistCalendar methods may return wrong values after exception\n+    @Test\n+    public void buddhistValuesAfterExceptionTest() {\n@@ -192,9 +213,1 @@\n-        boolean exceptionOccurred = false;\n-        try {\n-            cal.add(100, +1); \/\/ cause exception\n-        } catch (Exception e) {\n-            exceptionOccurred = true;\n-        }\n-        if (!exceptionOccurred) {\n-            throw new RuntimeException(\"testException: test case failed: no exception thrown\");\n-        }\n+        assertThrows(IllegalArgumentException.class, ()-> cal.add(100, +1));\n@@ -202,4 +215,1 @@\n-        if (year2 != year) {\n-            throw new RuntimeException(\"wrong year value after exception: got \" + year2\n-                                       + \", expected \" + year);\n-        }\n+        assertEquals(year2, year, \"Wrong year value after exception thrown\");\n@@ -208,4 +218,3 @@\n-    \/**\n-     * 4956227: getLeastMaximum(WEEK_OF_MONTH) return diff. val. for Greg. and Buddhist Calendar\n-     *\/\n-    static void testLeastMax() {\n+    \/\/ 4956227: getLeastMaximum(WEEK_OF_MONTH) return diff. val. for Greg. and Buddhist Calendar\n+    @Test\n+    public void buddhistLeastMaximumTest() {\n@@ -222,5 +231,1 @@\n-            if (bn != gn) {\n-                throw new RuntimeException(\"inconsistent Least Max value for \" + Koyomi.getFieldName(f)\n-                                           + \": Buddhist=\" + bn\n-                                           + \": Gregorian=\" + gn);\n-            }\n+            assertEquals(bn, gn, \"Inconsistent Least Max value for \" + Koyomi.getFieldName(f));\n@@ -230,5 +235,3 @@\n-    \/**\n-     * @return a BuddhistCalendar\n-     *\/\n-    static Calendar getBuddhistCalendar() {\n-        return Calendar.getInstance(THAI_LOCALE);\n+    \/\/ Utility to get a new Buddhist Calendar Builder (to allow setting of other values)\n+    private static Calendar.Builder getBuddhistCalendarBuilder() {\n+        return new Calendar.Builder().setLocale(THAI_LOCALE);\n@@ -237,5 +240,3 @@\n-    static void check(int got, int expected, String s) {\n-        if (got != expected) {\n-            throw new RuntimeException(\"Failed: \" +\n-                s + \": got:\" + got + \", expected:\" + expected);\n-        }\n+    \/\/ Utility to get a new Buddhist calendar\n+    private static Calendar getBuddhistCalendar() {\n+        return Calendar.getInstance(THAI_LOCALE);\n","filename":"test\/jdk\/java\/util\/Calendar\/BuddhistCalendarTest.java","additions":175,"deletions":174,"binary":false,"changes":349,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run junit Bug4302966\n@@ -34,0 +35,4 @@\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n@@ -36,1 +41,2 @@\n-    public static void main(String[] args) {\n+    \/\/ Specific day of week test for Czech locale\n+    public void czechDayOfWeekTest() {\n@@ -39,3 +45,1 @@\n-        if (firstDayOfWeek != Calendar.MONDAY) {\n-            throw new RuntimeException();\n-        }\n+        assertEquals(firstDayOfWeek, Calendar.MONDAY);\n","filename":"test\/jdk\/java\/util\/Calendar\/Bug4302966.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n- * @summary Make sure that computeTime call doesn't reset the isTimeSet value.\n+ * @summary Make sure that calling computeTime doesn't reset the isTimeSet value.\n+ * @run junit Bug4766302\n@@ -32,1 +33,4 @@\n-@SuppressWarnings(\"serial\")\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n@@ -35,0 +39,2 @@\n+    \/\/ Extend GregorianCalendar to check the protected value of isTimeSet\n+    @SuppressWarnings(\"serial\")\n@@ -36,1 +42,0 @@\n-\n@@ -46,1 +51,3 @@\n-    public static void main(String[] args) {\n+    \/\/ Check the value of isTimeStillSet() after calling computeTime()\n+    @Test\n+    public void validateIsTimeSetTest() {\n@@ -49,3 +56,1 @@\n-        if (!cal.isTimeStillSet()) {\n-            throw new RuntimeException(\"computeTime() call reset isTimeSet.\");\n-        }\n+        assertTrue(cal.isTimeStillSet(), \"computeTime() call reset isTimeSet.\");\n","filename":"test\/jdk\/java\/util\/Calendar\/Bug4766302.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main CalendarLimitTest -verbose\n+ * @run junit CalendarLimitTest\n@@ -35,0 +35,4 @@\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n@@ -45,1 +49,1 @@\n-public class CalendarLimitTest extends IntlTest\n+public class CalendarLimitTest\n@@ -64,10 +68,0 @@\n-    public static void main(String argv[]) throws Exception {\n-        Locale locale = Locale.getDefault();\n-        if (!TestUtils.usesGregorianCalendar(locale)) {\n-            System.out.println(\"Skipping this test because locale is \" + locale);\n-            return;\n-        }\n-\n-        new CalendarLimitTest().run(argv);\n-    }\n-\n@@ -111,1 +105,1 @@\n-            errln(\"FAIL: Exception \" + s);\n+            fail(\"FAIL: Exception \" + s);\n@@ -117,1 +111,1 @@\n-            errln(\"FAIL: Bad year\/era \" + s);\n+            fail(\"FAIL: Bad year\/era \" + s);\n@@ -121,1 +115,1 @@\n-            errln(\"FAIL: Bad DOM \" + s);\n+            fail(\"FAIL: Bad DOM \" + s);\n@@ -125,1 +119,1 @@\n-            errln(\"FAIL: RT fail \" + s + \" -> 0x\" +\n+            fail(\"FAIL: RT fail \" + s + \" -> 0x\" +\n@@ -130,1 +124,1 @@\n-        if (ok) logln(s);\n+        if (ok) System.out.println(s);\n@@ -135,0 +129,1 @@\n+    @Test\n@@ -137,0 +132,5 @@\n+        Locale locale = Locale.getDefault();\n+        if (!TestUtils.usesGregorianCalendar(locale)) {\n+            System.out.println(\"Skipping this test because locale is \" + locale);\n+            return;\n+        }\n@@ -157,1 +157,1 @@\n-                errln(\"FAIL: Years should be decreasing \" + lastYear + \" \" + y);\n+                fail(\"FAIL: Years should be decreasing \" + lastYear + \" \" + y);\n@@ -168,1 +168,1 @@\n-                errln(\"FAIL: Years should be increasing \" + lastYear + \" \" + y);\n+                fail(\"FAIL: Years should be increasing \" + lastYear + \" \" + y);\n@@ -191,1 +191,1 @@\n-                    logln(\"\" + h + \":00 Dec \"+dom+\", 292269055 BC -> \" +\n+                    System.out.println(\"\" + h + \":00 Dec \"+dom+\", 292269055 BC -> \" +\n@@ -200,1 +200,1 @@\n-                logln(\"0x\" + Long.toHexString(t) + \" -> \" +\n+                System.out.println(\"0x\" + Long.toHexString(t) + \" -> \" +\n","filename":"test\/jdk\/java\/util\/Calendar\/CalendarLimitTest.java","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main CalendarRegression\n+ * @run junit CalendarRegression\n@@ -56,1 +56,1 @@\n-public class CalendarRegression extends IntlTest {\n+import org.junit.jupiter.api.Test;\n@@ -58,3 +58,3 @@\n-    public static void main(String[] args) throws Exception {\n-        new CalendarRegression().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class CalendarRegression {\n@@ -66,6 +66,0 @@\n-    public static void main (String args[]) {\n-    java.sql.Timestamp t= new java.sql.Timestamp(0,15,5,5,8,13,123456700);\n-    logln(\"expected=1901-04-05 05:08:13.1234567\");\n-    logln(\" result=\"+t);\n-    }\n-\n@@ -80,0 +74,1 @@\n+    @Test\n@@ -91,1 +86,1 @@\n-                logln(zone.getID() + \" \"\n+                System.out.println(zone.getID() + \" \"\n@@ -100,1 +95,1 @@\n-            errln(\"TimeZone problems with GC\");\n+            fail(\"TimeZone problems with GC\");\n@@ -104,0 +99,1 @@\n+    @Test\n@@ -113,1 +109,1 @@\n-            errln(\"Fail\");\n+            fail(\"Fail\");\n@@ -117,0 +113,1 @@\n+    @Test\n@@ -128,2 +125,2 @@\n-        logln(\"MONTH: \" + calendar.get(MONTH));\n-        logln(\"DAY_OF_MONTH: \"\n+        System.out.println(\"MONTH: \" + calendar.get(MONTH));\n+        System.out.println(\"DAY_OF_MONTH: \"\n@@ -131,2 +128,2 @@\n-        logln(\"MINUTE: \" + calendar.get(MINUTE));\n-        logln(\"SECOND: \" + calendar.get(SECOND));\n+        System.out.println(\"MINUTE: \" + calendar.get(MINUTE));\n+        System.out.println(\"SECOND: \" + calendar.get(SECOND));\n@@ -138,2 +135,2 @@\n-        logln(\"MONTH: \" + calendar.get(MONTH));\n-        logln(\"DAY_OF_MONTH: \"\n+        System.out.println(\"MONTH: \" + calendar.get(MONTH));\n+        System.out.println(\"DAY_OF_MONTH: \"\n@@ -141,2 +138,2 @@\n-        logln(\"MINUTE: \" + calendar.get(MINUTE));\n-        logln(\"SECOND: \" + calendar.get(SECOND));\n+        System.out.println(\"MINUTE: \" + calendar.get(MINUTE));\n+        System.out.println(\"SECOND: \" + calendar.get(SECOND));\n@@ -146,1 +143,1 @@\n-            errln(\"Fail: Calendar.add misbehaves\");\n+            fail(\"Fail: Calendar.add misbehaves\");\n@@ -150,0 +147,1 @@\n+    @Test\n@@ -156,1 +154,1 @@\n-            errln(\"Fail: DAY_OF_WEEK 0 should be disallowed\");\n+            fail(\"Fail: DAY_OF_WEEK 0 should be disallowed\");\n@@ -163,0 +161,1 @@\n+    @Test\n@@ -167,4 +166,4 @@\n-        logln(\"ERA: \" + calendar.get(calendar.ERA));\n-        logln(\"YEAR: \" + calendar.get(calendar.YEAR));\n-        logln(\"MONTH: \" + calendar.get(calendar.MONTH));\n-        logln(\"WEEK_OF_YEAR: \" +\n+        System.out.println(\"ERA: \" + calendar.get(calendar.ERA));\n+        System.out.println(\"YEAR: \" + calendar.get(calendar.YEAR));\n+        System.out.println(\"MONTH: \" + calendar.get(calendar.MONTH));\n+        System.out.println(\"WEEK_OF_YEAR: \" +\n@@ -172,1 +171,1 @@\n-        logln(\"WEEK_OF_MONTH: \" +\n+        System.out.println(\"WEEK_OF_MONTH: \" +\n@@ -174,2 +173,2 @@\n-        logln(\"DATE: \" + calendar.get(calendar.DATE));\n-        logln(\"DAY_OF_MONTH: \" +\n+        System.out.println(\"DATE: \" + calendar.get(calendar.DATE));\n+        System.out.println(\"DAY_OF_MONTH: \" +\n@@ -177,3 +176,3 @@\n-        logln(\"DAY_OF_YEAR: \" + calendar.get(calendar.DAY_OF_YEAR));\n-        logln(\"DAY_OF_WEEK: \" + calendar.get(calendar.DAY_OF_WEEK));\n-        logln(\"DAY_OF_WEEK_IN_MONTH: \" +\n+        System.out.println(\"DAY_OF_YEAR: \" + calendar.get(calendar.DAY_OF_YEAR));\n+        System.out.println(\"DAY_OF_WEEK: \" + calendar.get(calendar.DAY_OF_WEEK));\n+        System.out.println(\"DAY_OF_WEEK_IN_MONTH: \" +\n@@ -181,7 +180,7 @@\n-        logln(\"AM_PM: \" + calendar.get(calendar.AM_PM));\n-        logln(\"HOUR: \" + calendar.get(calendar.HOUR));\n-        logln(\"HOUR_OF_DAY: \" + calendar.get(calendar.HOUR_OF_DAY));\n-        logln(\"MINUTE: \" + calendar.get(calendar.MINUTE));\n-        logln(\"SECOND: \" + calendar.get(calendar.SECOND));\n-        logln(\"MILLISECOND: \" + calendar.get(calendar.MILLISECOND));\n-        logln(\"ZONE_OFFSET: \"\n+        System.out.println(\"AM_PM: \" + calendar.get(calendar.AM_PM));\n+        System.out.println(\"HOUR: \" + calendar.get(calendar.HOUR));\n+        System.out.println(\"HOUR_OF_DAY: \" + calendar.get(calendar.HOUR_OF_DAY));\n+        System.out.println(\"MINUTE: \" + calendar.get(calendar.MINUTE));\n+        System.out.println(\"SECOND: \" + calendar.get(calendar.SECOND));\n+        System.out.println(\"MILLISECOND: \" + calendar.get(calendar.MILLISECOND));\n+        System.out.println(\"ZONE_OFFSET: \"\n@@ -189,1 +188,1 @@\n-        logln(\"DST_OFFSET: \"\n+        System.out.println(\"DST_OFFSET: \"\n@@ -193,5 +192,5 @@\n-        logln(\"April 10, 1997\");\n-        logln(\"ERA: \" + calendar.get(calendar.ERA));\n-        logln(\"YEAR: \" + calendar.get(calendar.YEAR));\n-        logln(\"MONTH: \" + calendar.get(calendar.MONTH));\n-        logln(\"WEEK_OF_YEAR: \" +\n+        System.out.println(\"April 10, 1997\");\n+        System.out.println(\"ERA: \" + calendar.get(calendar.ERA));\n+        System.out.println(\"YEAR: \" + calendar.get(calendar.YEAR));\n+        System.out.println(\"MONTH: \" + calendar.get(calendar.MONTH));\n+        System.out.println(\"WEEK_OF_YEAR: \" +\n@@ -199,1 +198,1 @@\n-        logln(\"WEEK_OF_MONTH: \" +\n+        System.out.println(\"WEEK_OF_MONTH: \" +\n@@ -201,2 +200,2 @@\n-        logln(\"DATE: \" + calendar.get(calendar.DATE));\n-        logln(\"DAY_OF_MONTH: \" +\n+        System.out.println(\"DATE: \" + calendar.get(calendar.DATE));\n+        System.out.println(\"DAY_OF_MONTH: \" +\n@@ -204,10 +203,10 @@\n-        logln(\"DAY_OF_YEAR: \" + calendar.get(calendar.DAY_OF_YEAR));\n-        logln(\"DAY_OF_WEEK: \" + calendar.get(calendar.DAY_OF_WEEK));\n-        logln(\"DAY_OF_WEEK_IN_MONTH: \" + calendar.get(calendar.DAY_OF_WEEK_IN_MONTH));\n-        logln(\"AM_PM: \" + calendar.get(calendar.AM_PM));\n-        logln(\"HOUR: \" + calendar.get(calendar.HOUR));\n-        logln(\"HOUR_OF_DAY: \" + calendar.get(calendar.HOUR_OF_DAY));\n-        logln(\"MINUTE: \" + calendar.get(calendar.MINUTE));\n-        logln(\"SECOND: \" + calendar.get(calendar.SECOND));\n-        logln(\"MILLISECOND: \" + calendar.get(calendar.MILLISECOND));\n-        logln(\"ZONE_OFFSET: \"\n+        System.out.println(\"DAY_OF_YEAR: \" + calendar.get(calendar.DAY_OF_YEAR));\n+        System.out.println(\"DAY_OF_WEEK: \" + calendar.get(calendar.DAY_OF_WEEK));\n+        System.out.println(\"DAY_OF_WEEK_IN_MONTH: \" + calendar.get(calendar.DAY_OF_WEEK_IN_MONTH));\n+        System.out.println(\"AM_PM: \" + calendar.get(calendar.AM_PM));\n+        System.out.println(\"HOUR: \" + calendar.get(calendar.HOUR));\n+        System.out.println(\"HOUR_OF_DAY: \" + calendar.get(calendar.HOUR_OF_DAY));\n+        System.out.println(\"MINUTE: \" + calendar.get(calendar.MINUTE));\n+        System.out.println(\"SECOND: \" + calendar.get(calendar.SECOND));\n+        System.out.println(\"MILLISECOND: \" + calendar.get(calendar.MILLISECOND));\n+        System.out.println(\"ZONE_OFFSET: \"\n@@ -215,1 +214,1 @@\n-        logln(\"DST_OFFSET: \"\n+        System.out.println(\"DST_OFFSET: \"\n@@ -219,0 +218,1 @@\n+    @Test\n@@ -234,1 +234,1 @@\n-            errln(\"Fail: Calendar.set broken. Got \" + cd + \" Want \" + exp);\n+            fail(\"Fail: Calendar.set broken. Got \" + cd + \" Want \" + exp);\n@@ -238,0 +238,1 @@\n+    @Test\n@@ -249,1 +250,1 @@\n-        logln(\"Hour: \" + cal.get(HOUR_OF_DAY));\n+        System.out.println(\"Hour: \" + cal.get(HOUR_OF_DAY));\n@@ -251,1 +252,1 @@\n-        logln(\"Hour: \" + cal.get(HOUR_OF_DAY));\n+        System.out.println(\"Hour: \" + cal.get(HOUR_OF_DAY));\n@@ -253,1 +254,1 @@\n-            errln(\"Fail: Want 19 Got \" + cal.get(HOUR_OF_DAY));\n+            fail(\"Fail: Want 19 Got \" + cal.get(HOUR_OF_DAY));\n@@ -257,0 +258,1 @@\n+    @Test\n@@ -264,1 +266,1 @@\n-            errln(\"Fail: Want weekday Got \" + d);\n+            fail(\"Fail: Want weekday Got \" + d);\n@@ -292,0 +294,1 @@\n+    @Test\n@@ -306,1 +309,1 @@\n-        logln(cal.getTime().toString());\n+        System.out.println(cal.getTime().toString());\n@@ -308,1 +311,1 @@\n-            errln(\"FAIL: Min\/max bad\");\n+            fail(\"FAIL: Min\/max bad\");\n@@ -311,1 +314,1 @@\n-            errln(\"FAIL: Day of week \" + dow + \" out of range\");\n+            fail(\"FAIL: Day of week \" + dow + \" out of range\");\n@@ -314,1 +317,1 @@\n-            errln(\"FAIL: Day of week should be SUNDAY Got \" + dow);\n+            fail(\"FAIL: Day of week should be SUNDAY Got \" + dow);\n@@ -319,0 +322,1 @@\n+    @Test\n@@ -323,1 +327,1 @@\n-        logln(cal.getTime().toString());\n+        System.out.println(cal.getTime().toString());\n@@ -325,1 +329,1 @@\n-            errln(\"Fail\");\n+            fail(\"Fail\");\n@@ -329,0 +333,1 @@\n+    @Test\n@@ -338,1 +343,1 @@\n-            errln(\"Fail: Calendar not initialized\");\n+            fail(\"Fail: Calendar not initialized\");\n@@ -342,0 +347,1 @@\n+    @Test\n@@ -354,1 +360,1 @@\n-            logln(\"Current time: \" + firstDate.toString());\n+            System.out.println(\"Current time: \" + firstDate.toString());\n@@ -365,1 +371,1 @@\n-                    errln(\"Day has shifted \" + lastDate);\n+                    fail(\"Day has shifted \" + lastDate);\n@@ -373,0 +379,1 @@\n+    @Test\n@@ -390,1 +397,1 @@\n-                errln(\"Wrong display name \\\"\" + formattedDate\n+                fail(\"Wrong display name \\\"\" + formattedDate\n@@ -395,1 +402,1 @@\n-                errln(\"Wrong week-of-year \" + weekOfYear\n+                fail(\"Wrong week-of-year \" + weekOfYear\n@@ -403,1 +410,1 @@\n-                errln(\"Wrong display name \\\"\" + formattedDate\n+                fail(\"Wrong display name \\\"\" + formattedDate\n@@ -408,1 +415,1 @@\n-                errln(\"Wrong week-of-year \" + weekOfYear\n+                fail(\"Wrong week-of-year \" + weekOfYear\n@@ -416,1 +423,1 @@\n-                errln(\"Wrong display name \\\"\" + formattedDate\n+                fail(\"Wrong display name \\\"\" + formattedDate\n@@ -421,1 +428,1 @@\n-                errln(\"Wrong week-of-year \" + weekOfYear\n+                fail(\"Wrong week-of-year \" + weekOfYear\n@@ -429,1 +436,1 @@\n-                errln(\"Wrong display name \\\"\" + formattedDate\n+                fail(\"Wrong display name \\\"\" + formattedDate\n@@ -434,1 +441,1 @@\n-                errln(\"Wrong week-of-year \" + weekOfYear\n+                fail(\"Wrong week-of-year \" + weekOfYear\n@@ -444,0 +451,1 @@\n+    @Test\n@@ -453,2 +461,2 @@\n-        logln(\" Cal1 = \" + cal1.getTime().getTime());\n-        logln(\" Cal1 time in ms = \" + cal1.get(MILLISECOND));\n+        System.out.println(\" Cal1 = \" + cal1.getTime().getTime());\n+        System.out.println(\" Cal1 time in ms = \" + cal1.get(MILLISECOND));\n@@ -465,2 +473,2 @@\n-        logln(\" Cal2 = \" + cal2.getTime().getTime());\n-        logln(\" Cal2 time in ms = \" + cal2.get(MILLISECOND));\n+        System.out.println(\" Cal2 = \" + cal2.getTime().getTime());\n+        System.out.println(\" Cal2 time in ms = \" + cal2.get(MILLISECOND));\n@@ -468,1 +476,1 @@\n-            errln(\"Fail: Milliseconds randomized\");\n+            fail(\"Fail: Milliseconds randomized\");\n@@ -472,0 +480,1 @@\n+    @Test\n@@ -476,1 +485,1 @@\n-            errln(\"Fail: Want THURSDAY Got \" + dow);\n+            fail(\"Fail: Want THURSDAY Got \" + dow);\n@@ -480,0 +489,1 @@\n+    @Test\n@@ -488,1 +498,1 @@\n-        logln(\"PST 1 is: \" + (p = cal1.get(HOUR_OF_DAY)));\n+        System.out.println(\"PST 1 is: \" + (p = cal1.get(HOUR_OF_DAY)));\n@@ -493,1 +503,1 @@\n-        logln(\"GMT 1 is: \" + (h1 = cal1.get(HOUR_OF_DAY)));\n+        System.out.println(\"GMT 1 is: \" + (h1 = cal1.get(HOUR_OF_DAY)));\n@@ -495,1 +505,1 @@\n-        logln(\"GMT 2 is: \" + (h2 = cal1.get(HOUR_OF_DAY)));\n+        System.out.println(\"GMT 2 is: \" + (h2 = cal1.get(HOUR_OF_DAY)));\n@@ -500,1 +510,1 @@\n-            errln(\"Fail: Hour same in different zones\");\n+            fail(\"Fail: Hour same in different zones\");\n@@ -516,1 +526,1 @@\n-        logln(\"RGMT 1 is: \" + (t1 = cal2.getTime().getTime()));\n+        System.out.println(\"RGMT 1 is: \" + (t1 = cal2.getTime().getTime()));\n@@ -518,1 +528,1 @@\n-        logln(\"RPST 1 is: \" + (t2 = cal3.getTime().getTime()));\n+        System.out.println(\"RPST 1 is: \" + (t2 = cal3.getTime().getTime()));\n@@ -520,1 +530,1 @@\n-        logln(\"RGMT 2 is: \" + (t3 = cal3.getTime().getTime()));\n+        System.out.println(\"RGMT 2 is: \" + (t3 = cal3.getTime().getTime()));\n@@ -530,1 +540,1 @@\n-        logln(\"RGMT 3 is: \" + (t4 = cal3.getTime().getTime()));\n+        System.out.println(\"RGMT 3 is: \" + (t4 = cal3.getTime().getTime()));\n@@ -534,1 +544,1 @@\n-            errln(\"Fail: Calendar zone behavior faulty\");\n+            fail(\"Fail: Calendar zone behavior faulty\");\n@@ -538,0 +548,1 @@\n+    @Test\n@@ -544,1 +555,1 @@\n-            log((m1 = gc.get(MONTH) + 1) + \"\/\"\n+            System.out.println((m1 = gc.get(MONTH) + 1) + \"\/\"\n@@ -549,1 +560,1 @@\n-            logln((m2 = gc.get(MONTH) + 1) + \"\/\"\n+            System.out.println((m2 = gc.get(MONTH) + 1) + \"\/\"\n@@ -554,1 +565,1 @@\n-                errln(\"Fail: Want \" + m + \" Got \" + m2);\n+                fail(\"Fail: Want \" + m + \" Got \" + m2);\n@@ -560,0 +571,1 @@\n+    @Test\n@@ -563,1 +575,1 @@\n-            logln(\"Skipping this test because locale is \" + locale);\n+            System.out.println(\"Skipping this test because locale is \" + locale);\n@@ -571,1 +583,1 @@\n-        logln(d.toString());\n+        System.out.println(d.toString());\n@@ -573,1 +585,1 @@\n-            errln(\"Fail: DAY_OF_YEAR not set\");\n+            fail(\"Fail: DAY_OF_YEAR not set\");\n@@ -577,0 +589,1 @@\n+    @Test\n@@ -580,1 +593,1 @@\n-            logln(\"Skipping this test because locale is \" + locale);\n+            System.out.println(\"Skipping this test because locale is \" + locale);\n@@ -597,1 +610,1 @@\n-                logln(testDesc + \" => 1st day of week=\"\n+                System.out.println(testDesc + \" => 1st day of week=\"\n@@ -612,1 +625,1 @@\n-                            logln(output);\n+                            System.out.println(output);\n@@ -629,1 +642,1 @@\n-            logln(\"Minimal days in first week = \" + DATA[j]\n+            System.out.println(\"Minimal days in first week = \" + DATA[j]\n@@ -635,1 +648,1 @@\n-                log(\"\\t\" + testCal.getTime() + \" \" + woy);\n+                System.out.println(\"\\t\" + testCal.getTime() + \" \" + woy);\n@@ -637,1 +650,1 @@\n-                    log(\" ERROR\");\n+                    System.out.println(\" ERROR\");\n@@ -640,1 +653,1 @@\n-                    logln(\" OK\");\n+                    System.out.println(\" OK\");\n@@ -651,1 +664,1 @@\n-                    logln(\"  Parse failed: \" + testCal.getTime());\n+                    System.out.println(\"  Parse failed: \" + testCal.getTime());\n@@ -654,1 +667,1 @@\n-                    logln(\"  Passed\");\n+                    System.out.println(\"  Passed\");\n@@ -685,1 +698,1 @@\n-            log(y + \"-W\" + woy + \"-DOW\" + dow);\n+            System.out.println(y + \"-W\" + woy + \"-DOW\" + dow);\n@@ -687,1 +700,1 @@\n-                logln(\"  FAILED expect: \" + exp + \"\\n            got: \" + testCal.getTime());\n+                System.out.println(\"  FAILED expect: \" + exp + \"\\n            got: \" + testCal.getTime());\n@@ -690,1 +703,1 @@\n-                logln(\"  OK\");\n+                System.out.println(\"  OK\");\n@@ -717,1 +730,1 @@\n-            log((ADDROLL[i] == ADD ? \"add(WOY,\" : \"roll(WOY,\")\n+            System.out.println((ADDROLL[i] == ADD ? \"add(WOY,\" : \"roll(WOY,\")\n@@ -721,1 +734,1 @@\n-                logln(\"\\tFAIL\\n\\t\\texp: \" + after);\n+                System.out.println(\"\\tFAIL\\n\\t\\texp: \" + after);\n@@ -724,1 +737,1 @@\n-                logln(\"  OK\");\n+                System.out.println(\"  OK\");\n@@ -733,1 +746,1 @@\n-            log((ADDROLL[i] == ADD ? \"add(WOY,\" : \"roll(WOY,\")\n+            System.out.println((ADDROLL[i] == ADD ? \"add(WOY,\" : \"roll(WOY,\")\n@@ -737,1 +750,1 @@\n-                logln(\"\\tFAIL\\n\\t\\texp: \" + before);\n+                System.out.println(\"\\tFAIL\\n\\t\\texp: \" + before);\n@@ -740,1 +753,1 @@\n-                logln(\"\\tOK\");\n+                System.out.println(\"\\tOK\");\n@@ -745,1 +758,1 @@\n-            errln(\"Fail: Week of year misbehaving\");\n+            fail(\"Fail: Week of year misbehaving\");\n@@ -749,0 +762,1 @@\n+    @Test\n@@ -761,1 +775,1 @@\n-                        errln(\"Fail: No locales for \" + locales[i]);\n+                        fail(\"Fail: No locales for \" + locales[i]);\n@@ -771,0 +785,1 @@\n+    @Test\n@@ -782,1 +797,1 @@\n-        logln(cal.getTime().toString());\n+        System.out.println(cal.getTime().toString());\n@@ -784,1 +799,1 @@\n-            errln(\"Fail: clear(MINUTE) broken\");\n+            fail(\"Fail: clear(MINUTE) broken\");\n@@ -788,1 +803,1 @@\n-        logln(cal.getTime().toString());\n+        System.out.println(cal.getTime().toString());\n@@ -790,1 +805,1 @@\n-            errln(\"Fail: set(SECOND, 0) broken\");\n+            fail(\"Fail: set(SECOND, 0) broken\");\n@@ -795,1 +810,1 @@\n-        logln(cal.getTime().toString());\n+        System.out.println(cal.getTime().toString());\n@@ -797,1 +812,1 @@\n-            errln(\"Fail: set(SECOND, 0) broken #2\");\n+            fail(\"Fail: set(SECOND, 0) broken #2\");\n@@ -801,1 +816,1 @@\n-        logln(cal.getTime().toString());\n+        System.out.println(cal.getTime().toString());\n@@ -803,1 +818,1 @@\n-            errln(\"Fail: clear(MINUTE) broken #2\");\n+            fail(\"Fail: clear(MINUTE) broken #2\");\n@@ -807,1 +822,1 @@\n-        logln(cal.getTime().toString());\n+        System.out.println(cal.getTime().toString());\n@@ -809,1 +824,1 @@\n-            errln(\"Fail: clear() broken Want \" + epoch);\n+            fail(\"Fail: clear() broken Want \" + epoch);\n@@ -814,0 +829,1 @@\n+    @Test\n@@ -817,1 +833,1 @@\n-            logln(\"Skipping this test because locale is \" + locale);\n+            System.out.println(\"Skipping this test because locale is \" + locale);\n@@ -852,1 +868,1 @@\n-                log(date.toString());\n+                System.out.println(date.toString());\n@@ -857,1 +873,1 @@\n-                        log(\" add (HOUR,\" + (amt < 0 ? \"\" : \"+\") + amt + \")= \");\n+                        System.out.println(\" add (HOUR,\" + (amt < 0 ? \"\" : \"+\") + amt + \")= \");\n@@ -861,1 +877,1 @@\n-                        log(\" roll(HOUR,\" + (amt < 0 ? \"\" : \"+\") + amt + \")= \");\n+                        System.out.println(\" roll(HOUR,\" + (amt < 0 ? \"\" : \"+\") + amt + \")= \");\n@@ -866,1 +882,1 @@\n-                log(cal.getTime().toString());\n+                System.out.println(cal.getTime().toString());\n@@ -871,1 +887,1 @@\n-                    logln(\" FAIL\");\n+                    System.out.println(\" FAIL\");\n@@ -873,1 +889,1 @@\n-                    logln(\" OK\");\n+                    System.out.println(\" OK\");\n@@ -881,1 +897,1 @@\n-            errln(\"Fail: roll\/add misbehaves around DST onset\/cease\");\n+            fail(\"Fail: roll\/add misbehaves around DST onset\/cease\");\n@@ -888,0 +904,1 @@\n+    @Test\n@@ -893,1 +910,1 @@\n-            errln(\"Fail: maximum of HOUR field should be 11\");\n+            fail(\"Fail: maximum of HOUR field should be 11\");\n@@ -900,0 +917,1 @@\n+    @Test\n@@ -903,1 +921,1 @@\n-            logln(\"Skipping this test because locale is \" + locale);\n+            System.out.println(\"Skipping this test because locale is \" + locale);\n@@ -913,1 +931,1 @@\n-            logln(y + \" = \" + fmt.format(cal.getTime()) + \" \"\n+            System.out.println(y + \" = \" + fmt.format(cal.getTime()) + \" \"\n@@ -916,1 +934,1 @@\n-                errln(\"Leap years broken\");\n+                fail(\"Leap years broken\");\n@@ -925,0 +943,1 @@\n+    @Test\n@@ -928,1 +947,1 @@\n-            logln(\"Skipping this test because locale is \" + locale);\n+            System.out.println(\"Skipping this test because locale is \" + locale);\n@@ -942,1 +961,1 @@\n-            errln(\"Calendar not proleptic\");\n+            fail(\"Calendar not proleptic\");\n@@ -951,0 +970,1 @@\n+    @Test\n@@ -964,1 +984,1 @@\n-            errln(\"Calendar hash code unequal for cloned objects\");\n+            fail(\"Calendar hash code unequal for cloned objects\");\n@@ -969,1 +989,1 @@\n-            errln(\"Calendar hash code ignores minimal days in first week\");\n+            fail(\"Calendar hash code ignores minimal days in first week\");\n@@ -975,1 +995,1 @@\n-            errln(\"Calendar hash code ignores first day of week\");\n+            fail(\"Calendar hash code ignores first day of week\");\n@@ -981,1 +1001,1 @@\n-            errln(\"Calendar hash code ignores lenient setting\");\n+            fail(\"Calendar hash code ignores lenient setting\");\n@@ -989,1 +1009,1 @@\n-            errln(\"Calendar hash code ignores zone\");\n+            fail(\"Calendar hash code ignores zone\");\n@@ -996,1 +1016,1 @@\n-            errln(\"GregorianCalendar hash code unequal for clones objects\");\n+            fail(\"GregorianCalendar hash code unequal for clones objects\");\n@@ -1001,1 +1021,1 @@\n-            errln(\"GregorianCalendar hash code ignores cutover\");\n+            fail(\"GregorianCalendar hash code ignores cutover\");\n@@ -1008,0 +1028,1 @@\n+    @Test\n@@ -1014,1 +1035,1 @@\n-            errln(\"Cloned GregorianCalendars not equal\");\n+            fail(\"Cloned GregorianCalendars not equal\");\n@@ -1018,1 +1039,1 @@\n-            errln(\"GregorianCalendar.equals() ignores cutover\");\n+            fail(\"GregorianCalendar.equals() ignores cutover\");\n@@ -1026,0 +1047,1 @@\n+    @Test\n@@ -1030,1 +1052,1 @@\n-            errln(\"Test failed, no exception trown\");\n+            fail(\"Test failed, no exception trown\");\n@@ -1035,1 +1057,1 @@\n-            errln(\"Test failed. Unexpected exception is thrown: \" + e);\n+            fail(\"Test failed. Unexpected exception is thrown: \" + e);\n@@ -1047,0 +1069,1 @@\n+    @Test\n@@ -1061,1 +1084,1 @@\n-            errln(\"Fail: Long.MIN_VALUE or Long.MAX_VALUE wrapping around\");\n+            fail(\"Fail: Long.MIN_VALUE or Long.MAX_VALUE wrapping around\");\n@@ -1068,0 +1091,1 @@\n+    @Test\n@@ -1077,1 +1101,1 @@\n-                errln(\"Failed for \" + DATES[i].getTime() + \" ms: year=\"\n+                fail(\"Failed for \" + DATES[i].getTime() + \" ms: year=\"\n@@ -1089,0 +1113,1 @@\n+    @Test\n@@ -1124,1 +1149,1 @@\n-                errln(\"Test failed with field \" + fieldName[field]\n+                fail(\"Test failed with field \" + fieldName[field]\n@@ -1138,0 +1163,1 @@\n+    @Test\n@@ -1148,1 +1174,1 @@\n-                errln(\"Fail: Date(Long.MIN_VALUE) has an AD year in \" + zones[i]);\n+                fail(\"Fail: Date(Long.MIN_VALUE) has an AD year in \" + zones[i]);\n@@ -1152,1 +1178,1 @@\n-                errln(\"Fail: Date(Long.MAX_VALUE) has a BC year in \" + zones[i]);\n+                fail(\"Fail: Date(Long.MAX_VALUE) has a BC year in \" + zones[i]);\n@@ -1160,3 +1186,3 @@\n-                errln(\"test failed with zone \" + zones[i].getID());\n-                errln(\" cutover date is Date(Long.MAX_VALUE)\");\n-                errln(\" isLeapYear(100) returns: \" + is100Leap);\n+                fail(\"test failed with zone \" + zones[i].getID()\n+                + \"\\n cutover date is Date(Long.MAX_VALUE)\"\n+                + \"\\n isLeapYear(100) returns: \" + is100Leap);\n@@ -1171,0 +1197,1 @@\n+    @Test\n@@ -1181,1 +1208,1 @@\n-                    logln(\"---\");\n+                    System.out.println(\"---\");\n@@ -1188,1 +1215,1 @@\n-                logln(\"0 \" + i + \": \" + s0);\n+                System.out.println(\"0 \" + i + \": \" + s0);\n@@ -1194,1 +1221,1 @@\n-                logln(\"+ \" + i + \": \" + sPlus);\n+                System.out.println(\"+ \" + i + \": \" + sPlus);\n@@ -1200,1 +1227,1 @@\n-                logln(\"- \" + i + \": \" + sMinus);\n+                System.out.println(\"- \" + i + \": \" + sMinus);\n@@ -1203,1 +1230,1 @@\n-                    errln(\"Fail: All three lines must match\");\n+                    fail(\"Fail: All three lines must match\");\n@@ -1214,0 +1241,1 @@\n+    @Test\n@@ -1217,1 +1245,1 @@\n-        logln(\"init date: \" + start);\n+        System.out.println(\"init date: \" + start);\n@@ -1220,1 +1248,1 @@\n-        logln(\"after adding 12 months: \" + date1);\n+        System.out.println(\"after adding 12 months: \" + date1);\n@@ -1224,1 +1252,1 @@\n-        logln(\"after adding one year : \" + date2);\n+        System.out.println(\"after adding one year : \" + date2);\n@@ -1226,1 +1254,1 @@\n-            logln(\"Test passed\");\n+            System.out.println(\"Test passed\");\n@@ -1228,1 +1256,1 @@\n-            errln(\"Test failed\");\n+            fail(\"Test failed\");\n@@ -1235,0 +1263,1 @@\n+    @Test\n@@ -1252,1 +1281,1 @@\n-        logln(\"Date:  \" + calendar.getTime());\n+        System.out.println(\"Date:  \" + calendar.getTime());\n@@ -1261,1 +1290,1 @@\n-            logln(\"First day of week = \" + firstInWeek\n+            System.out.println(\"First day of week = \" + firstInWeek\n@@ -1271,1 +1300,1 @@\n-            errln(\"Test failed\");\n+            fail(\"Test failed\");\n@@ -1282,0 +1311,1 @@\n+    @Test\n@@ -1296,1 +1326,1 @@\n-            logln(\"--- \" + id[k] + \" ---\");\n+            System.out.println(\"--- \" + id[k] + \" ---\");\n@@ -1311,2 +1341,2 @@\n-                logln(\"maxYear: \" + maxYear + \" for \" + format.format(calendar.getTime()));\n-                logln(\"date before: \" + format.format(dateBefore));\n+                System.out.println(\"maxYear: \" + maxYear + \" for \" + format.format(calendar.getTime()));\n+                System.out.println(\"date before: \" + format.format(dateBefore));\n@@ -1323,1 +1353,1 @@\n-                    logln(\" Year \" + years[i] + (valid ? \" ok \" : \" bad\")\n+                    System.out.println(\" Year \" + years[i] + (valid ? \" ok \" : \" bad\")\n@@ -1326,1 +1356,1 @@\n-                        errln(\"  FAIL: \" + newYear + \" should be valid; date, month and time shouldn't change\");\n+                        fail(\"  FAIL: \" + newYear + \" should be valid; date, month and time shouldn't change\");\n@@ -1328,1 +1358,1 @@\n-                        errln(\"  FAIL: \" + newYear + \" should be invalid\");\n+                        fail(\"  FAIL: \" + newYear + \" should be invalid\");\n@@ -1339,0 +1369,1 @@\n+    @Test\n@@ -1342,1 +1373,1 @@\n-            logln(\"Skipping this test because locale is \" + locale);\n+            System.out.println(\"Skipping this test because locale is \" + locale);\n@@ -1368,1 +1399,1 @@\n-                errln(\"Hour rolling broken. expected 0, got \" + cal.getTime().getTime());\n+                fail(\"Hour rolling broken. expected 0, got \" + cal.getTime().getTime());\n@@ -1372,1 +1403,1 @@\n-                logln(\"Testing GregorianCalendar \" + (op == 0 ? \"add\" : \"roll\"));\n+                System.out.println(\"Testing GregorianCalendar \" + (op == 0 ? \"add\" : \"roll\"));\n@@ -1398,1 +1429,1 @@\n-                                errln(\"Field \" + field\n+                                fail(\"Field \" + field\n@@ -1420,1 +1451,1 @@\n-                                errln(cal.get(YEAR)\n+                                fail(cal.get(YEAR)\n@@ -1438,1 +1469,1 @@\n-                                    errln((op == 0 ? \"add(\" : \"roll(\")\n+                                    fail((op == 0 ? \"add(\" : \"roll(\")\n@@ -1460,0 +1491,1 @@\n+    @Test\n@@ -1473,1 +1505,1 @@\n-            errln(\"adding months to Feb 29 broken\");\n+            fail(\"adding months to Feb 29 broken\");\n@@ -1480,0 +1512,1 @@\n+    @Test\n@@ -1491,1 +1524,1 @@\n-            errln(\"FAIL: Fields not updated after setTimeZone\");\n+            fail(\"FAIL: Fields not updated after setTimeZone\");\n@@ -1503,1 +1536,1 @@\n-            errln(\"FAIL: setTimeZone changed time\");\n+            fail(\"FAIL: setTimeZone changed time\");\n@@ -1510,0 +1543,1 @@\n+    @Test\n@@ -1526,1 +1560,1 @@\n-                logln(\"Ok: \" + fmt.format(cal.getTime()));\n+                System.out.println(\"Ok: \" + fmt.format(cal.getTime()));\n@@ -1528,1 +1562,1 @@\n-                errln(\"FAIL: \" + fmt.format(cal.getTime())\n+                fail(\"FAIL: \" + fmt.format(cal.getTime())\n@@ -1533,1 +1567,1 @@\n-                    logln(fmt.format(cal.getTime()));\n+                    System.out.println(fmt.format(cal.getTime()));\n@@ -1552,0 +1586,1 @@\n+    @Test\n@@ -1628,1 +1663,1 @@\n-                errln(\"FAIL: Test \" + (i \/ 2) + \" got \" + act\n+                fail(\"FAIL: Test \" + (i \/ 2) + \" got \" + act\n@@ -1652,1 +1687,1 @@\n-                errln(\"FAIL: Sunday \" + DATA[i]\n+                fail(\"FAIL: Sunday \" + DATA[i]\n@@ -1659,0 +1694,1 @@\n+    @Test\n@@ -1681,1 +1717,1 @@\n-                                errln(cal.getTime() + \",got=\" + WOY\n+                                fail(cal.getTime() + \",got=\" + WOY\n@@ -1690,1 +1726,1 @@\n-                            errln(cal.getTime() + \",got=\" + WOY\n+                            fail(cal.getTime() + \",got=\" + WOY\n@@ -1701,0 +1737,1 @@\n+    @Test\n@@ -1721,1 +1758,1 @@\n-            errln(\"deserialized Calendar returned wrong date field(s): \"\n+            fail(\"deserialized Calendar returned wrong date field(s): \"\n@@ -1731,0 +1768,1 @@\n+    @Test\n@@ -1754,1 +1792,1 @@\n-                    logln(\"Calendar instance which uses TimeZone <\"\n+                    System.out.println(\"Calendar instance which uses TimeZone <\"\n@@ -1757,1 +1795,1 @@\n-                    logln(\"Calendar instance which uses TimeZone <\"\n+                    System.out.println(\"Calendar instance which uses TimeZone <\"\n@@ -1762,1 +1800,1 @@\n-                errln(\"Fail: Calendar serialization\/equality bug\");\n+                fail(\"Fail: Calendar serialization\/equality bug\");\n@@ -1765,1 +1803,1 @@\n-            errln(\"Fail: \" + e);\n+            fail(\"Fail: \" + e);\n@@ -1775,0 +1813,1 @@\n+    @Test\n@@ -1782,1 +1821,1 @@\n-            errln(\"Fail: 2001\/11\/4 must be the first week of the month.\");\n+            fail(\"Fail: 2001\/11\/4 must be the first week of the month.\");\n@@ -1789,0 +1828,1 @@\n+    @Test\n@@ -1798,1 +1838,1 @@\n-            errln(\"Fail: 2000\/1\/1 must be the 52nd week of the year.\");\n+            fail(\"Fail: 2000\/1\/1 must be the 52nd week of the year.\");\n@@ -1808,0 +1848,1 @@\n+    @Test\n@@ -1812,1 +1853,1 @@\n-            logln(\"Skipping this test because locale is \" + locale);\n+            System.out.println(\"Skipping this test because locale is \" + locale);\n@@ -1834,1 +1875,1 @@\n-            errln(\"DAY_OF_MONTH w\/o ZONE_OFFSET: expected: \" + expected + \", got: \" + s);\n+            fail(\"DAY_OF_MONTH w\/o ZONE_OFFSET: expected: \" + expected + \", got: \" + s);\n@@ -1850,1 +1891,1 @@\n-            errln(\"DAY_OF_MONTH: expected: \" + expected + \", got: \" + s);\n+            fail(\"DAY_OF_MONTH: expected: \" + expected + \", got: \" + s);\n@@ -1870,1 +1911,1 @@\n-            errln(\"WEEK_OF_YEAR: expected: \" + expected + \", got: \" + s);\n+            fail(\"WEEK_OF_YEAR: expected: \" + expected + \", got: \" + s);\n@@ -1882,1 +1923,1 @@\n-            errln(\"WEEK_OF_MONTH: expected: \" + expected + \", got: \" + s);\n+            fail(\"WEEK_OF_MONTH: expected: \" + expected + \", got: \" + s);\n@@ -1906,1 +1947,1 @@\n-            errln(\"MINUTE: expected: \" + expected + \", got: \" + s);\n+            fail(\"MINUTE: expected: \" + expected + \", got: \" + s);\n@@ -1916,0 +1957,1 @@\n+    @Test\n@@ -1919,1 +1961,1 @@\n-            logln(\"Skipping this test because locale is \" + locale);\n+            System.out.println(\"Skipping this test because locale is \" + locale);\n@@ -1938,1 +1980,1 @@\n-            errln(\"expected: \" + expected + \", got: \" + s);\n+            fail(\"expected: \" + expected + \", got: \" + s);\n@@ -1950,0 +1992,1 @@\n+    @Test\n@@ -1959,1 +2002,1 @@\n-            errln(\"expected: \" + expected + \", got: \" + s);\n+            fail(\"expected: \" + expected + \", got: \" + s);\n@@ -1966,0 +2009,1 @@\n+    @Test\n@@ -1974,1 +2018,1 @@\n-        logln(\"hash code: h1=\" + h1 + \", h2=\" + h2 + \", h3=\" + h3);\n+        System.out.println(\"hash code: h1=\" + h1 + \", h2=\" + h2 + \", h3=\" + h3);\n@@ -1976,1 +2020,1 @@\n-            errln(\"hash code is poor: hashCode=\" + h1);\n+            fail(\"hash code is poor: hashCode=\" + h1);\n@@ -1981,1 +2025,1 @@\n-        logln(\"hash code: h2=\" + h2 + \", h4=\" + h4);\n+        System.out.println(\"hash code: h2=\" + h2 + \", h4=\" + h4);\n@@ -1983,1 +2027,1 @@\n-            errln(\"broken hash code: h2=\" + h2 + \", h4=\" + h4);\n+            fail(\"broken hash code: h2=\" + h2 + \", h4=\" + h4);\n@@ -1991,1 +2035,1 @@\n-        logln(\"hash code: h4=\" + h4 + \", h5=\" + h5);\n+        System.out.println(\"hash code: h4=\" + h4 + \", h5=\" + h5);\n@@ -1993,1 +2037,1 @@\n-            errln(\"has code is poor with first day of week param: hashCode=\" + h4);\n+            fail(\"has code is poor with first day of week param: hashCode=\" + h4);\n@@ -2001,0 +2045,1 @@\n+    @Test\n@@ -2008,1 +2053,1 @@\n-            errln(\"BCE: wrong modifiers: \" + mod);\n+            fail(\"BCE: wrong modifiers: \" + mod);\n@@ -2013,1 +2058,1 @@\n-            errln(\"CE: wrong modifiers: \" + mod);\n+            fail(\"CE: wrong modifiers: \" + mod);\n@@ -2017,1 +2062,1 @@\n-            errln(\"Wrong BCE and\/or CE values\");\n+            fail(\"Wrong BCE and\/or CE values\");\n@@ -2024,0 +2069,1 @@\n+    @Test\n@@ -2026,1 +2072,1 @@\n-        logln(\"Hybrid: min date\");\n+        System.out.println(\"Hybrid: min date\");\n@@ -2030,1 +2076,1 @@\n-            errln(gc.getMessage());\n+            fail(gc.getMessage());\n@@ -2032,1 +2078,1 @@\n-        logln(\"Hybrid: max date\");\n+        System.out.println(\"Hybrid: max date\");\n@@ -2036,1 +2082,1 @@\n-            errln(gc.getMessage());\n+            fail(gc.getMessage());\n@@ -2040,1 +2086,1 @@\n-        logln(\"Gregorian: min date\");\n+        System.out.println(\"Gregorian: min date\");\n@@ -2044,1 +2090,1 @@\n-            errln(gc.getMessage());\n+            fail(gc.getMessage());\n@@ -2046,1 +2092,1 @@\n-        logln(\"Gregorian: max date\");\n+        System.out.println(\"Gregorian: max date\");\n@@ -2050,1 +2096,1 @@\n-            errln(gc.getMessage());\n+            fail(gc.getMessage());\n@@ -2054,1 +2100,1 @@\n-        logln(\"Julian: min date\");\n+        System.out.println(\"Julian: min date\");\n@@ -2058,1 +2104,1 @@\n-            errln(gc.getMessage());\n+            fail(gc.getMessage());\n@@ -2060,1 +2106,1 @@\n-        logln(\"Julian: max date\");\n+        System.out.println(\"Julian: max date\");\n@@ -2064,1 +2110,1 @@\n-            errln(gc.getMessage());\n+            fail(gc.getMessage());\n@@ -2071,0 +2117,1 @@\n+    @Test\n@@ -2077,1 +2124,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -2081,1 +2128,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -2088,0 +2135,1 @@\n+    @Test\n@@ -2103,0 +2151,1 @@\n+    @Test\n@@ -2115,1 +2164,1 @@\n-        logln(\"Roll backwards from \" + cal.toDateString());\n+        System.out.println(\"Roll backwards from \" + cal.toDateString());\n@@ -2119,1 +2168,1 @@\n-                errln(cal.getMessage());\n+                fail(cal.getMessage());\n@@ -2122,1 +2171,1 @@\n-        logln(\"Roll forewards from \" + cal.toDateString());\n+        System.out.println(\"Roll forewards from \" + cal.toDateString());\n@@ -2126,1 +2175,1 @@\n-                errln(cal.getMessage());\n+                fail(cal.getMessage());\n@@ -2134,0 +2183,1 @@\n+    @Test\n@@ -2137,1 +2187,1 @@\n-        logln(\"BCE 9-2-28 (leap year) roll DAY_OF_MONTH++ twice\");\n+        System.out.println(\"BCE 9-2-28 (leap year) roll DAY_OF_MONTH++ twice\");\n@@ -2141,1 +2191,1 @@\n-            errln(\"    wrong actual max of DAY_OF_YEAR: got \"\n+            fail(\"    wrong actual max of DAY_OF_YEAR: got \"\n@@ -2147,1 +2197,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -2152,1 +2202,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -2159,0 +2209,1 @@\n+    @Test\n@@ -2160,1 +2211,1 @@\n-        logln(\"1999\/(Feb+12)\/1 should be normalized to 2000\/Feb\/1 for getActualMaximum\");\n+        System.out.println(\"1999\/(Feb+12)\/1 should be normalized to 2000\/Feb\/1 for getActualMaximum\");\n@@ -2165,1 +2216,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -2168,1 +2219,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -2175,0 +2226,1 @@\n+    @Test\n@@ -2216,1 +2268,1 @@\n-            errln(\"set(\" + Koyomi.getFieldName(field) + \", \" + s + \") failed.\" + \" got \" + time2\n+            fail(\"set(\" + Koyomi.getFieldName(field) + \", \" + s + \") failed.\" + \" got \" + time2\n@@ -2225,0 +2277,1 @@\n+    @Test\n@@ -2236,1 +2289,1 @@\n-                errln(\"lenient and non-lenient shouldn't be equal. (2003\/10\/31)\");\n+                fail(\"lenient and non-lenient shouldn't be equal. (2003\/10\/31)\");\n@@ -2239,1 +2292,1 @@\n-                errln(\"cal1 and cal2 should represent the same time. (2003\/10\/31)\");\n+                fail(\"cal1 and cal2 should represent the same time. (2003\/10\/31)\");\n@@ -2242,1 +2295,1 @@\n-            errln(\"equals threw IllegalArugumentException with non-lenient\");\n+            fail(\"equals threw IllegalArugumentException with non-lenient\");\n@@ -2249,1 +2302,1 @@\n-                errln(\"lenient and non-lenient shouldn't be equal. (2003\/10\/32)\");\n+                fail(\"lenient and non-lenient shouldn't be equal. (2003\/10\/32)\");\n@@ -2252,1 +2305,1 @@\n-                errln(\"cal1 and cal2 should represent the same time. (2003\/10\/32)\");\n+                fail(\"cal1 and cal2 should represent the same time. (2003\/10\/32)\");\n@@ -2255,1 +2308,1 @@\n-            errln(\"equals threw IllegalArugumentException with non-lenient\");\n+            fail(\"equals threw IllegalArugumentException with non-lenient\");\n@@ -2263,1 +2316,1 @@\n-            errln(\"Buddhist.equals(Gregorian) shouldn't be true. (millis=0)\");\n+            fail(\"Buddhist.equals(Gregorian) shouldn't be true. (millis=0)\");\n@@ -2266,1 +2319,1 @@\n-            errln(\"cal1 (Buddhist) and cal2 (Gregorian) should represent the same time. (millis=0)\");\n+            fail(\"cal1 (Buddhist) and cal2 (Gregorian) should represent the same time. (millis=0)\");\n@@ -2273,0 +2326,1 @@\n+    @Test\n@@ -2278,1 +2332,1 @@\n-            errln(\"!(cal1 > cal0)\");\n+            fail(\"!(cal1 > cal0)\");\n@@ -2281,1 +2335,1 @@\n-            errln(\"!(cal1 < cal2)\");\n+            fail(\"!(cal1 < cal2)\");\n@@ -2284,1 +2338,1 @@\n-            errln(\"cal1 != new GregorianCalendar(2003, OCTOBER, 1)\");\n+            fail(\"cal1 != new GregorianCalendar(2003, OCTOBER, 1)\");\n@@ -2288,1 +2342,1 @@\n-            errln(\"cal0 shouldn't be after cal2\");\n+            fail(\"cal0 shouldn't be after cal2\");\n@@ -2291,1 +2345,1 @@\n-            errln(\"cal2 shouldn't be before cal0\");\n+            fail(\"cal2 shouldn't be before cal0\");\n@@ -2295,1 +2349,1 @@\n-            errln(\"cal0.after() returned true with an Integer.\");\n+            fail(\"cal0.after() returned true with an Integer.\");\n@@ -2298,1 +2352,1 @@\n-            errln(\"cal0.before() returned true with an Integer.\");\n+            fail(\"cal0.before() returned true with an Integer.\");\n@@ -2301,1 +2355,1 @@\n-            errln(\"cal0.after() returned true with null.\");\n+            fail(\"cal0.after() returned true with null.\");\n@@ -2304,1 +2358,1 @@\n-            errln(\"cal0.before() returned true with null.\");\n+            fail(\"cal0.before() returned true with null.\");\n@@ -2312,0 +2366,1 @@\n+    @Test\n@@ -2337,1 +2392,1 @@\n-                errln(cal.getMessage());\n+                fail(cal.getMessage());\n@@ -2340,1 +2395,1 @@\n-                errln(cal.getMessage());\n+                fail(cal.getMessage());\n@@ -2345,1 +2400,1 @@\n-                errln(\"didn't throw IllegalArgumentException in non-lenient\");\n+                fail(\"didn't throw IllegalArgumentException in non-lenient\");\n@@ -2355,0 +2410,1 @@\n+    @Test\n@@ -2363,1 +2419,1 @@\n-            errln(\"roll: AM_PM didn't change to PM\");\n+            fail(\"roll: AM_PM didn't change to PM\");\n@@ -2372,1 +2428,1 @@\n-            errln(\"set: AM_PM didn't change to PM\");\n+            fail(\"set: AM_PM didn't change to PM\");\n@@ -2381,1 +2437,1 @@\n-            errln(\"set: both AM_PM and HOUT didn't change to PM\");\n+            fail(\"set: both AM_PM and HOUT didn't change to PM\");\n@@ -2388,0 +2444,1 @@\n+    @Test\n@@ -2404,1 +2461,1 @@\n-        logln(\"1: \" + cal.get(WEEK_OF_MONTH) + \", \" + cal.get(DAY_OF_MONTH));\n+        System.out.println(\"1: \" + cal.get(WEEK_OF_MONTH) + \", \" + cal.get(DAY_OF_MONTH));\n@@ -2406,1 +2463,1 @@\n-        logln(\"1st Sunday of June 2003 with FirstDayOfWeek=MONDAY\");\n+        System.out.println(\"1st Sunday of June 2003 with FirstDayOfWeek=MONDAY\");\n@@ -2408,1 +2465,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -2415,0 +2472,1 @@\n+    @Test\n@@ -2431,1 +2489,1 @@\n-            errln(\"date1.equals(date2) != true\");\n+            fail(\"date1.equals(date2) != true\");\n@@ -2434,1 +2492,1 @@\n-            errln(\"inconsistent hashCode() value (before=0x\"\n+            fail(\"inconsistent hashCode() value (before=0x\"\n@@ -2443,0 +2501,1 @@\n+    @Test\n@@ -2447,1 +2506,1 @@\n-            errln(\"getMaximum(100) didn't throw an exception.\");\n+            fail(\"getMaximum(100) didn't throw an exception.\");\n@@ -2449,1 +2508,1 @@\n-            logln(\"getMaximum: \" + e.getClass().getName() + \": \" + e.getMessage());\n+            System.out.println(\"getMaximum: \" + e.getClass().getName() + \": \" + e.getMessage());\n@@ -2454,1 +2513,1 @@\n-            errln(\"getLeastMaximum(100) didn't throw an exception.\");\n+            fail(\"getLeastMaximum(100) didn't throw an exception.\");\n@@ -2456,1 +2515,1 @@\n-            logln(\"getLeastMaximum: \" + e.getClass().getName() + \": \" + e.getMessage());\n+            System.out.println(\"getLeastMaximum: \" + e.getClass().getName() + \": \" + e.getMessage());\n@@ -2461,1 +2520,1 @@\n-            errln(\"getActualMaximum(100) didn't throw an exception.\");\n+            fail(\"getActualMaximum(100) didn't throw an exception.\");\n@@ -2463,1 +2522,1 @@\n-            logln(\"getActualMaximum: \" + e.getClass().getName() + \": \" + e.getMessage());\n+            System.out.println(\"getActualMaximum: \" + e.getClass().getName() + \": \" + e.getMessage());\n@@ -2468,1 +2527,1 @@\n-            errln(\"getMinimum(100) didn't throw an exception.\");\n+            fail(\"getMinimum(100) didn't throw an exception.\");\n@@ -2470,1 +2529,1 @@\n-            logln(\"getMinimum: \" + e.getClass().getName() + \": \" + e.getMessage());\n+            System.out.println(\"getMinimum: \" + e.getClass().getName() + \": \" + e.getMessage());\n@@ -2475,1 +2534,1 @@\n-            errln(\"getGreatestMinimum(100) didn't throw an exception.\");\n+            fail(\"getGreatestMinimum(100) didn't throw an exception.\");\n@@ -2477,1 +2536,1 @@\n-            logln(\"getGreatestMinimum: \" + e.getClass().getName() + \": \" + e.getMessage());\n+            System.out.println(\"getGreatestMinimum: \" + e.getClass().getName() + \": \" + e.getMessage());\n@@ -2482,1 +2541,1 @@\n-            errln(\"getActualMinimum(100) didn't throw an exception.\");\n+            fail(\"getActualMinimum(100) didn't throw an exception.\");\n@@ -2484,1 +2543,1 @@\n-            logln(\"getActualMinimum: \" + e.getClass().getName() + \": \" + e.getMessage());\n+            System.out.println(\"getActualMinimum: \" + e.getClass().getName() + \": \" + e.getMessage());\n@@ -2491,0 +2550,1 @@\n+    @Test\n@@ -2512,1 +2572,1 @@\n-                    errln(\"isLeapYear(1000) returned \" + cal.isLeapYear(1000)\n+                    fail(\"isLeapYear(1000) returned \" + cal.isLeapYear(1000)\n@@ -2535,0 +2595,1 @@\n+    @Test\n@@ -2539,1 +2600,1 @@\n-            errln(\"GregorianCalendar.getMinimum(DAY_OF_WEEK_IN_MONTH) returned \"\n+            fail(\"GregorianCalendar.getMinimum(DAY_OF_WEEK_IN_MONTH) returned \"\n@@ -2544,1 +2605,1 @@\n-            errln(\"GregorianCalendar.getGreatestMinimum(DAY_OF_WEEK_IN_MONTH) returned \"\n+            fail(\"GregorianCalendar.getGreatestMinimum(DAY_OF_WEEK_IN_MONTH) returned \"\n","filename":"test\/jdk\/java\/util\/Calendar\/CalendarRegression.java","additions":358,"deletions":297,"binary":false,"changes":655,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main CalendarTest\n+ * @run junit CalendarTest\n@@ -51,1 +51,5 @@\n-public class CalendarTest extends IntlTest {\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class CalendarTest {\n@@ -56,4 +60,0 @@\n-    public static void main(String argv[]) throws Exception {\n-        new CalendarTest().run(argv);\n-    }\n-\n@@ -63,0 +63,1 @@\n+    @Test\n@@ -100,1 +101,1 @@\n-                logln(\"Changeover \" + (i >= 0 ? \"+\" : \"\") + i\n+                System.out.println(\"Changeover \" + (i >= 0 ? \"+\" : \"\") + i\n@@ -103,1 +104,1 @@\n-                    errln(\" Fail: Above line is wrong\");\n+                    fail(\" Fail: Above line is wrong\");\n@@ -117,0 +118,1 @@\n+    @Test\n@@ -163,1 +165,1 @@\n-                    errln(s + \" FAIL\");\n+                    fail(s + \" FAIL\");\n@@ -165,1 +167,1 @@\n-                    logln(s);\n+                    System.out.println(s);\n@@ -187,1 +189,1 @@\n-                    errln(s + \" FAIL\");\n+                    fail(s + \" FAIL\");\n@@ -189,1 +191,1 @@\n-                    logln(s);\n+                    System.out.println(s);\n@@ -215,1 +217,1 @@\n-            errln(\"Round-trip failure: \" + y + \"-\" + (m + 1) + \"-\" + d + \" =>ms=> \"\n+            fail(\"Round-trip failure: \" + y + \"-\" + (m + 1) + \"-\" + d + \" =>ms=> \"\n@@ -221,0 +223,1 @@\n+    @Test\n@@ -224,1 +227,1 @@\n-            logln(\"Skipping this test because locale is \" + locale);\n+            System.out.println(\"Skipping this test because locale is \" + locale);\n@@ -238,1 +241,1 @@\n-            errln(\"FAIL: Calendar.getTimeZone failed\");\n+            fail(\"FAIL: Calendar.getTimeZone failed\");\n@@ -247,1 +250,1 @@\n-            errln(\"FAIL: Calendar.operator== failed\");\n+            fail(\"FAIL: Calendar.operator== failed\");\n@@ -253,1 +256,1 @@\n-            errln(\"FAIL: equals\/before\/after failed\");\n+            fail(\"FAIL: equals\/before\/after failed\");\n@@ -260,1 +263,1 @@\n-            errln(\"FAIL: equals\/before\/after failed\");\n+            fail(\"FAIL: equals\/before\/after failed\");\n@@ -267,1 +270,1 @@\n-            errln(\"FAIL: equals\/before\/after failed\");\n+            fail(\"FAIL: equals\/before\/after failed\");\n@@ -275,1 +278,1 @@\n-            errln(\"FAIL: equals\/before\/after failed\");\n+            fail(\"FAIL: equals\/before\/after failed\");\n@@ -282,1 +285,1 @@\n-        errln(\"FAIL: orphanTimeZone failed\");\n+        fail(\"FAIL: orphanTimeZone failed\");\n@@ -288,1 +291,1 @@\n-                errln(\"FAIL: setLenient\/isLenient failed\");\n+                fail(\"FAIL: setLenient\/isLenient failed\");\n@@ -297,1 +300,1 @@\n-                errln(\"FAIL: set\/getFirstDayOfWeek failed\");\n+                fail(\"FAIL: set\/getFirstDayOfWeek failed\");\n@@ -304,1 +307,1 @@\n-                errln(\"FAIL: set\/getFirstDayOfWeek failed\");\n+                fail(\"FAIL: set\/getFirstDayOfWeek failed\");\n@@ -310,1 +313,1 @@\n-                errln(\"FAIL: getMinimum doesn't match getGreatestMinimum for field \" + i);\n+                fail(\"FAIL: getMinimum doesn't match getGreatestMinimum for field \" + i);\n@@ -313,1 +316,1 @@\n-                errln(\"FAIL: getLeastMaximum larger than getMaximum for field \" + i);\n+                fail(\"FAIL: getLeastMaximum larger than getMaximum for field \" + i);\n@@ -316,1 +319,1 @@\n-                errln(\"FAIL: getMinimum not less than getMaximum for field \" + i);\n+                fail(\"FAIL: getMinimum not less than getMaximum for field \" + i);\n@@ -324,2 +327,2 @@\n-            errln(\"FAIL: Calendar.set(3 args) failed\");\n-            logln(\" Got: \" + cal.getTime() + \"  Expected: \" + new Date(84, 5, 24));\n+            fail(\"FAIL: Calendar.set(3 args) failed\");\n+            System.out.println(\" Got: \" + cal.getTime() + \"  Expected: \" + new Date(84, 5, 24));\n@@ -331,2 +334,2 @@\n-            errln(\"FAIL: Calendar.set(5 args) failed\");\n-            logln(\" Got: \" + cal.getTime() + \"  Expected: \" + new Date(85, 3, 2, 11, 49));\n+            fail(\"FAIL: Calendar.set(5 args) failed\");\n+            System.out.println(\" Got: \" + cal.getTime() + \"  Expected: \" + new Date(85, 3, 2, 11, 49));\n@@ -338,2 +341,2 @@\n-            errln(\"FAIL: Calendar.set(6 args) failed\");\n-            logln(\" Got: \" + cal.getTime() + \"  Expected: \" + new Date(95, 9, 12, 1, 39, 55));\n+            fail(\"FAIL: Calendar.set(6 args) failed\");\n+            System.out.println(\" Got: \" + cal.getTime() + \"  Expected: \" + new Date(95, 9, 12, 1, 39, 55));\n@@ -352,1 +355,1 @@\n-                        errln(\"FAIL: !Calendar.isSet test failed: \" + calendarFieldNames[i]);\n+                        fail(\"FAIL: !Calendar.isSet test failed: \" + calendarFieldNames[i]);\n@@ -357,1 +360,1 @@\n-                        errln(\"FAIL: Calendar.isSet test failed: \" + calendarFieldNames[i]);\n+                        fail(\"FAIL: Calendar.isSet test failed: \" + calendarFieldNames[i]);\n@@ -362,1 +365,1 @@\n-                errln(\"FAIL: Calendar.clear\/isSet failed\");\n+                fail(\"FAIL: Calendar.clear\/isSet failed\");\n@@ -371,1 +374,1 @@\n-            errln(\"FAIL: getAvailableLocales failed\");\n+            fail(\"FAIL: getAvailableLocales failed\");\n@@ -402,1 +405,1 @@\n-            errln(\"FAIL: new GregorianCalendar(ymdhm) failed\");\n+            fail(\"FAIL: new GregorianCalendar(ymdhm) failed\");\n@@ -408,1 +411,1 @@\n-            errln(\"FAIL: new GregorianCalendar(ymdhms) failed\");\n+            fail(\"FAIL: new GregorianCalendar(ymdhms) failed\");\n@@ -420,0 +423,1 @@\n+    @Test\n@@ -435,1 +439,1 @@\n-                errln(\"FAIL: Date \" + gc.getTime() + \" wrong\");\n+                fail(\"FAIL: Date \" + gc.getTime() + \" wrong\");\n@@ -441,0 +445,1 @@\n+    @Test\n@@ -456,1 +461,1 @@\n-            errln(\"FAIL: Day of week \" + dow + \" out of range\");\n+            fail(\"FAIL: Day of week \" + dow + \" out of range\");\n@@ -459,1 +464,1 @@\n-            errln(\"FAIL2: Day of week should be SUNDAY; is \" + dow + \": \" + cal.getTime());\n+            fail(\"FAIL2: Day of week should be SUNDAY; is \" + dow + \": \" + cal.getTime());\n@@ -462,1 +467,1 @@\n-            errln(\"FAIL: Min\/max bad\");\n+            fail(\"FAIL: Min\/max bad\");\n@@ -468,0 +473,1 @@\n+    @Test\n@@ -475,1 +481,1 @@\n-            errln(\"FAIL: Clones share fields\");\n+            fail(\"FAIL: Clones share fields\");\n@@ -481,0 +487,1 @@\n+    @Test\n@@ -484,3 +491,3 @@\n-        logln(\"With cutoff \" + c.getGregorianChange());\n-        logln(\" isLeapYear(1800) = \" + (b = c.isLeapYear(1800)));\n-        logln(\" (should be FALSE)\");\n+        System.out.println(\"With cutoff \" + c.getGregorianChange());\n+        System.out.println(\" isLeapYear(1800) = \" + (b = c.isLeapYear(1800)));\n+        System.out.println(\" (should be FALSE)\");\n@@ -488,1 +495,1 @@\n-            errln(\"FAIL\");\n+            fail(\"FAIL\");\n@@ -491,3 +498,3 @@\n-        logln(\"With cutoff \" + c.getGregorianChange());\n-        logln(\" isLeapYear(1800) = \" + (b = c.isLeapYear(1800)));\n-        logln(\" (should be TRUE)\");\n+        System.out.println(\"With cutoff \" + c.getGregorianChange());\n+        System.out.println(\" isLeapYear(1800) = \" + (b = c.isLeapYear(1800)));\n+        System.out.println(\" (should be TRUE)\");\n@@ -495,1 +502,1 @@\n-            errln(\"FAIL\");\n+            fail(\"FAIL\");\n@@ -500,0 +507,1 @@\n+    @Test\n@@ -565,1 +573,1 @@\n-                errln(\"FAIL: Exception seen: \" + ex.getMessage());\n+                fail(\"FAIL: Exception seen: \" + ex.getMessage());\n@@ -599,1 +607,1 @@\n-            logln(\"PASS: \" + msg + c.getTime());\n+            System.out.println(\"PASS: \" + msg + c.getTime());\n@@ -601,1 +609,1 @@\n-            errln(\"FAIL: \" + msg + c.getTime()\n+            fail(\"FAIL: \" + msg + c.getTime()\n@@ -610,1 +618,1 @@\n-            errln(\"FAIL: No IllegalArgumentException for \" + msg);\n+            fail(\"FAIL: No IllegalArgumentException for \" + msg);\n@@ -612,1 +620,1 @@\n-            logln(\"PASS: \" + msg + \"IllegalArgument as expected\");\n+            System.out.println(\"PASS: \" + msg + \"IllegalArgument as expected\");\n@@ -617,0 +625,1 @@\n+    @Test\n@@ -620,1 +629,1 @@\n-            logln(\"Skipping this test because locale is \" + locale);\n+            System.out.println(\"Skipping this test because locale is \" + locale);\n@@ -648,1 +657,1 @@\n-        logln(\"date = \" + date);\n+        System.out.println(\"date = \" + date);\n@@ -661,1 +670,1 @@\n-        logln(\"offset for \" + date + \"= \" + (offset \/ 1000 \/ 60 \/ 60.0) + \"hr\");\n+        System.out.println(\"offset for \" + date + \"= \" + (offset \/ 1000 \/ 60 \/ 60.0) + \"hr\");\n@@ -671,1 +680,1 @@\n-            errln(\"FAIL: Discrepancy of \"\n+            fail(\"FAIL: Discrepancy of \"\n@@ -679,0 +688,1 @@\n+    @Test\n@@ -702,1 +712,1 @@\n-            logln(\"Pass: \" + s + \" == \" + s2);\n+            System.out.println(\"Pass: \" + s + \" == \" + s2);\n@@ -704,1 +714,1 @@\n-            errln(\"FAIL: \" + s + \" != \" + s2);\n+            fail(\"FAIL: \" + s + \" != \" + s2);\n@@ -709,0 +719,1 @@\n+    @Test\n@@ -740,1 +751,1 @@\n-            errln(\"FAILURE: Expected YEAR\/MONTH\/DATE of \"\n+            fail(\"FAILURE: Expected YEAR\/MONTH\/DATE of \"\n@@ -747,1 +758,1 @@\n-            logln(\"Confirmed: \"\n+            System.out.println(\"Confirmed: \"\n@@ -753,0 +764,1 @@\n+    @Test\n@@ -766,1 +778,1 @@\n-                logln(\"Same\");\n+                System.out.println(\"Same\");\n@@ -768,1 +780,1 @@\n-                logln(\"Different\");\n+                System.out.println(\"Different\");\n@@ -771,1 +783,1 @@\n-            errln(\"Unexpected exception seen: \" + e);\n+            fail(\"Unexpected exception seen: \" + e);\n@@ -776,0 +788,1 @@\n+    @Test\n@@ -803,1 +816,1 @@\n-            errln(\"FAIL: Exception received:\");\n+            fail(\"FAIL: Exception received:\");\n@@ -806,1 +819,1 @@\n-            errln(\"FAIL: Exception received:\");\n+            fail(\"FAIL: Exception received:\");\n@@ -811,1 +824,1 @@\n-            errln(\"Serialization of Calendar object failed.\");\n+            fail(\"Serialization of Calendar object failed.\");\n@@ -819,0 +832,1 @@\n+    @Test\n@@ -828,1 +842,1 @@\n-            errln(\"Expected to see :00 in \" + s);\n+            fail(\"Expected to see :00 in \" + s);\n@@ -833,0 +847,1 @@\n+    @Test\n@@ -843,1 +858,1 @@\n-            logln(\"1A) \" + value(calendar));\n+            System.out.println(\"1A) \" + value(calendar));\n@@ -846,2 +861,2 @@\n-            logln(\"1B) \" + v);\n-            logln(\"--) 1993\/0\/5\");\n+            System.out.println(\"1B) \" + v);\n+            System.out.println(\"--) 1993\/0\/5\");\n@@ -849,1 +864,1 @@\n-                errln(\"Expected \" + EXPECTED_0610\n+                fail(\"Expected \" + EXPECTED_0610\n@@ -861,1 +876,1 @@\n-            logln(\"2A) \" + value(calendar));\n+            System.out.println(\"2A) \" + value(calendar));\n@@ -864,2 +879,2 @@\n-            logln(\"2B) \" + v);\n-            logln(\"--) 1993\/0\/5\");\n+            System.out.println(\"2B) \" + v);\n+            System.out.println(\"--) 1993\/0\/5\");\n@@ -867,1 +882,1 @@\n-                errln(\"Expected \" + EXPECTED_0610\n+                fail(\"Expected \" + EXPECTED_0610\n@@ -880,1 +895,1 @@\n-            logln(\"3A) \" + value(calendar));\n+            System.out.println(\"3A) \" + value(calendar));\n@@ -884,2 +899,2 @@\n-            logln(\"3B) \" + v);\n-            logln(\"--) 1993\/0\/5\");\n+            System.out.println(\"3B) \" + v);\n+            System.out.println(\"--) 1993\/0\/5\");\n@@ -887,1 +902,1 @@\n-                errln(\"Expected \" + EXPECTED_0610\n+                fail(\"Expected \" + EXPECTED_0610\n@@ -900,0 +915,1 @@\n+    @Test\n@@ -911,1 +927,1 @@\n-                errln(\"Expected field \" + field + \" to have value \" + expected\n+                fail(\"Expected field \" + field + \" to have value \" + expected\n@@ -945,0 +961,1 @@\n+    @Test\n@@ -991,1 +1008,1 @@\n-                        errln(\"Wrong value: \" + val\n+                        fail(\"Wrong value: \" + val\n@@ -998,1 +1015,1 @@\n-                    errln(\"Failed: \\n\\tDate=\" + d + \"\\n\\tTimeZone=\" + z\n+                    fail(\"Failed: \\n\\tDate=\" + d + \"\\n\\tTimeZone=\" + z\n@@ -1010,0 +1027,1 @@\n+    @Test\n@@ -1023,1 +1041,1 @@\n-            logln(\"DOW = \" + DOW + \"  \" + cur.getTime());\n+            System.out.println(\"DOW = \" + DOW + \"  \" + cur.getTime());\n@@ -1029,1 +1047,1 @@\n-                errln(\"Day of week should be \" + expectedDOW\n+                fail(\"Day of week should be \" + expectedDOW\n@@ -1036,0 +1054,1 @@\n+    @Test\n@@ -1042,1 +1061,1 @@\n-            errln(\"Actual minimum date for 3\/10\/1967 should have been 1; got \"\n+            fail(\"Actual minimum date for 3\/10\/1967 should have been 1; got \"\n@@ -1046,1 +1065,1 @@\n-            errln(\"Actual maximum date for 3\/10\/1967 should have been 31; got \"\n+            fail(\"Actual maximum date for 3\/10\/1967 should have been 31; got \"\n@@ -1052,1 +1071,1 @@\n-            errln(\"Actual maximum date for 2\/10\/1967 should have been 28; got \"\n+            fail(\"Actual maximum date for 2\/10\/1967 should have been 28; got \"\n@@ -1056,1 +1075,1 @@\n-            errln(\"Number of days in 1967 should have been 365; got \"\n+            fail(\"Number of days in 1967 should have been 365; got \"\n@@ -1062,1 +1081,1 @@\n-            errln(\"Actual maximum date for 2\/10\/1968 should have been 29; got \"\n+            fail(\"Actual maximum date for 2\/10\/1968 should have been 29; got \"\n@@ -1066,1 +1085,1 @@\n-            errln(\"Number of days in 1968 should have been 366; got \"\n+            fail(\"Number of days in 1968 should have been 366; got \"\n@@ -1071,1 +1090,1 @@\n-            errln(\"Number of weeks in 1968 should have been 52; got \"\n+            fail(\"Number of weeks in 1968 should have been 52; got \"\n@@ -1078,1 +1097,1 @@\n-            errln(\"Number of weeks in 1976 should have been 53; got \"\n+            fail(\"Number of weeks in 1976 should have been 53; got \"\n@@ -1083,0 +1102,1 @@\n+    @Test\n@@ -1092,1 +1112,1 @@\n-                errln(\"Rolling the month in 1\/31\/1997 up by \" + i + \" should have yielded \"\n+                fail(\"Rolling the month in 1\/31\/1997 up by \" + i + \" should have yielded \"\n@@ -1108,1 +1128,1 @@\n-                errln(\"Rolling the year in 2\/29\/1996 up by \" + i + \" should have yielded \"\n+                fail(\"Rolling the year in 2\/29\/1996 up by \" + i + \" should have yielded \"\n@@ -1121,1 +1141,1 @@\n-            errln(\"Rolling HOUR_OF_DAY=0 delta=-2 gave \" + f + \" Wanted 22\");\n+            fail(\"Rolling HOUR_OF_DAY=0 delta=-2 gave \" + f + \" Wanted 22\");\n@@ -1126,1 +1146,1 @@\n-            errln(\"Rolling HOUR_OF_DAY=22 delta=5 gave \" + f + \" Wanted 3\");\n+            fail(\"Rolling HOUR_OF_DAY=22 delta=5 gave \" + f + \" Wanted 3\");\n@@ -1131,1 +1151,1 @@\n-            errln(\"Rolling HOUR_OF_DAY=3 delta=21 gave \" + f + \" Wanted 0\");\n+            fail(\"Rolling HOUR_OF_DAY=3 delta=21 gave \" + f + \" Wanted 0\");\n@@ -1139,1 +1159,1 @@\n-            errln(\"Rolling HOUR=0 delta=-2 gave \" + f + \" Wanted 10\");\n+            fail(\"Rolling HOUR=0 delta=-2 gave \" + f + \" Wanted 10\");\n@@ -1144,1 +1164,1 @@\n-            errln(\"Rolling HOUR=10 delta=5 gave \" + f + \" Wanted 3\");\n+            fail(\"Rolling HOUR=10 delta=5 gave \" + f + \" Wanted 3\");\n@@ -1149,1 +1169,1 @@\n-            errln(\"Rolling HOUR=3 delta=9 gave \" + f + \" Wanted 0\");\n+            fail(\"Rolling HOUR=3 delta=9 gave \" + f + \" Wanted 0\");\n@@ -1156,0 +1176,1 @@\n+    @Test\n@@ -1174,1 +1195,1 @@\n-                errln(\"Failed : got \" + cal.getTime() + \", expected Mon Jan 22, 2001\");\n+                fail(\"Failed : got \" + cal.getTime() + \", expected Mon Jan 22, 2001\");\n@@ -1182,0 +1203,1 @@\n+    @Test\n@@ -1194,1 +1216,1 @@\n-            errln(\"Failed : c1.sharedZone == false\");\n+            fail(\"Failed : c1.sharedZone == false\");\n@@ -1198,1 +1220,1 @@\n-                errln(\"Failed : c2.sharedZone == false\");\n+                fail(\"Failed : c2.sharedZone == false\");\n@@ -1200,1 +1222,1 @@\n-                errln(\"Failed : c1.zone != c2.zone\");\n+                fail(\"Failed : c1.zone != c2.zone\");\n","filename":"test\/jdk\/java\/util\/Calendar\/CalendarTest.java","additions":132,"deletions":110,"binary":false,"changes":242,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,1 @@\n- * @library \/java\/text\/testlib\n- * @build Koyomi\n- * @run main FieldStateTest\n+ * @run junit\/othervm FieldStateTest\n@@ -39,1 +37,2 @@\n-public class FieldStateTest extends IntlTest {\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n@@ -41,6 +40,1 @@\n-    public static void main(String[] args) throws Exception {\n-        Locale reservedLocale = Locale.getDefault();\n-        TimeZone reservedTimeZone = TimeZone.getDefault();\n-        try {\n-            TimeZone.setDefault(TimeZone.getTimeZone(\"GMT\"));\n-            Locale.setDefault(Locale.US);\n+import static org.junit.jupiter.api.Assertions.fail;\n@@ -48,6 +42,7 @@\n-            new FieldStateTest().run(args);\n-        } finally {\n-            \/\/ restore the reserved locale and time zone\n-            Locale.setDefault(reservedLocale);\n-            TimeZone.setDefault(reservedTimeZone);\n-        }\n+public class FieldStateTest {\n+\n+    \/\/ Change JVM default Locale and TimeZone\n+    @BeforeAll\n+    static void initAll() {\n+        Locale.setDefault(Locale.US);\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"GMT\"));\n@@ -56,0 +51,2 @@\n+\n+    @Test\n@@ -58,1 +55,1 @@\n-        logln(\"Right after instantialtion:\");\n+        System.out.println(\"Right after instantialtion:\");\n@@ -60,1 +57,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -63,1 +60,1 @@\n-        logln(\"Set date to 2003\/10\/31 after the instantiation:\");\n+        System.out.println(\"Set date to 2003\/10\/31 after the instantiation:\");\n@@ -73,1 +70,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -77,1 +74,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -80,1 +77,1 @@\n-        logln(\"Change to Monday of the week, which is 2003\/10\/27:\");\n+        System.out.println(\"Change to Monday of the week, which is 2003\/10\/27:\");\n@@ -84,1 +81,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -92,1 +89,1 @@\n-        logln(\"Set to 2003\/10\/31 after clear():\");\n+        System.out.println(\"Set to 2003\/10\/31 after clear():\");\n@@ -98,1 +95,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -101,1 +98,1 @@\n-        logln(\"Set to 2003\/10\/31 after clear(), then to the 51st week of year (12\/19):\");\n+        System.out.println(\"Set to 2003\/10\/31 after clear(), then to the 51st week of year (12\/19):\");\n@@ -107,1 +104,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -110,1 +107,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -113,1 +110,1 @@\n-        logln(\"Set to 2003\/10 Mon of 4th week (10\/20: 43rd week of year, 293rd day):\");\n+        System.out.println(\"Set to 2003\/10 Mon of 4th week (10\/20: 43rd week of year, 293rd day):\");\n@@ -121,1 +118,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -124,1 +121,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -127,1 +124,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -130,1 +127,1 @@\n-        logln(\"Set to 2003\/10 Mon of 43rd week of year (10\/20: 4th week of month, 293rd day):\");\n+        System.out.println(\"Set to 2003\/10 Mon of 43rd week of year (10\/20: 4th week of month, 293rd day):\");\n@@ -137,1 +134,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -140,1 +137,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -143,1 +140,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -146,1 +143,1 @@\n-        logln(\"Set day of week to SUNDAY and date to 2003\/10\/31. \"\n+        System.out.println(\"Set day of week to SUNDAY and date to 2003\/10\/31. \"\n@@ -164,1 +161,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -171,0 +168,1 @@\n+    @Test\n@@ -172,1 +170,1 @@\n-        logln(\"Set date to 2003\/9\/26 (Fri). Roll to Aug and back to Sep. \"\n+        System.out.println(\"Set date to 2003\/9\/26 (Fri). Roll to Aug and back to Sep. \"\n@@ -186,1 +184,1 @@\n-            errln(cal2.getMessage());\n+            fail(cal2.getMessage());\n@@ -193,0 +191,1 @@\n+    @Test\n@@ -212,1 +211,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n","filename":"test\/jdk\/java\/util\/Calendar\/FieldStateTest.java","additions":41,"deletions":42,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,1 @@\n- * @library \/java\/text\/testlib\n- * @build Koyomi\n- * @run main GregorianCutoverTest\n+ * @run junit\/othervm GregorianCutoverTest\n@@ -39,1 +37,2 @@\n-public class GregorianCutoverTest extends IntlTest {\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n@@ -41,6 +40,1 @@\n-    public static void main(String[] args) throws Exception {\n-        TimeZone tz = TimeZone.getDefault();\n-        Locale lc = Locale.getDefault();\n-        try {\n-            TimeZone.setDefault(TimeZone.getTimeZone(\"GMT\"));\n-            Locale.setDefault(Locale.US);\n+import static org.junit.jupiter.api.Assertions.fail;\n@@ -48,5 +42,7 @@\n-            new GregorianCutoverTest().run(args);\n-        } finally {\n-            TimeZone.setDefault(tz);\n-            Locale.setDefault(lc);\n-        }\n+public class GregorianCutoverTest {\n+\n+    \/\/ Change JVM default Locale and TimeZone\n+    @BeforeAll\n+    static void initAll() {\n+        Locale.setDefault(Locale.US);\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"GMT\"));\n@@ -55,0 +51,1 @@\n+\n@@ -58,0 +55,1 @@\n+    @Test\n@@ -103,1 +101,1 @@\n-        logln(\"Default cutover\");\n+        System.out.println(\"Default cutover\");\n@@ -106,1 +104,1 @@\n-        logln(\"  roll --DAY_OF_MONTH from 1582\/10\/01\");\n+        System.out.println(\"  roll --DAY_OF_MONTH from 1582\/10\/01\");\n@@ -109,1 +107,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -111,1 +109,1 @@\n-        logln(\"  roll DAY_OF_MONTH+10 from 1582\/10\/31\");\n+        System.out.println(\"  roll DAY_OF_MONTH+10 from 1582\/10\/31\");\n@@ -114,1 +112,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -116,1 +114,1 @@\n-        logln(\"  roll DAY_OF_MONTH-10 from 1582\/10\/20\");\n+        System.out.println(\"  roll DAY_OF_MONTH-10 from 1582\/10\/20\");\n@@ -119,1 +117,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -121,1 +119,1 @@\n-        logln(\"  roll back one day further\");\n+        System.out.println(\"  roll back one day further\");\n@@ -124,1 +122,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -128,1 +126,1 @@\n-        logln(\"Cutover date is 1970\/1\/5\");\n+        System.out.println(\"Cutover date is 1970\/1\/5\");\n@@ -134,1 +132,1 @@\n-        logln(\"  Set DAY_OF_YEAR to the 28th day of 1970\");\n+        System.out.println(\"  Set DAY_OF_YEAR to the 28th day of 1970\");\n@@ -137,1 +135,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -140,1 +138,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -142,1 +140,1 @@\n-        logln(\"  1969\/12\/22 should be the 356th day of the year.\");\n+        System.out.println(\"  1969\/12\/22 should be the 356th day of the year.\");\n@@ -145,1 +143,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -147,1 +145,1 @@\n-        logln(\"  Set DAY_OF_YEAR to autual maximum.\");\n+        System.out.println(\"  Set DAY_OF_YEAR to autual maximum.\");\n@@ -150,1 +148,1 @@\n-            errln(\"actual maximum of DAY_OF_YEAR: got \" + actualMaxDayOfYear + \", expected 356\");\n+            fail(\"actual maximum of DAY_OF_YEAR: got \" + actualMaxDayOfYear + \", expected 356\");\n@@ -154,1 +152,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -158,1 +156,1 @@\n-        logln(\"  Set to 1969\/12\/22 and roll DAY_OF_YEAR++\");\n+        System.out.println(\"  Set to 1969\/12\/22 and roll DAY_OF_YEAR++\");\n@@ -160,1 +158,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -162,1 +160,1 @@\n-        logln(\"  1970\/1\/5 should be the first day of the year.\");\n+        System.out.println(\"  1970\/1\/5 should be the first day of the year.\");\n@@ -165,1 +163,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -167,1 +165,1 @@\n-        logln(\"  roll --DAY_OF_MONTH from 1970\/1\/5\");\n+        System.out.println(\"  roll --DAY_OF_MONTH from 1970\/1\/5\");\n@@ -170,1 +168,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -172,1 +170,1 @@\n-        logln(\"  roll back one day of month\");\n+        System.out.println(\"  roll back one day of month\");\n@@ -175,1 +173,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -183,1 +181,1 @@\n-            logln(\"1582\/10\/10 doesn't exit with the default cutover.\");\n+            System.out.println(\"1582\/10\/10 doesn't exit with the default cutover.\");\n@@ -186,1 +184,1 @@\n-            errln(\"    Didn't throw IllegalArgumentException in non-lenient.\");\n+            fail(\"    Didn't throw IllegalArgumentException in non-lenient.\");\n@@ -193,1 +191,1 @@\n-        logln(Koyomi.getFieldName(field) + \" starting on \" + cal.toDateString());\n+        System.out.println(Koyomi.getFieldName(field) + \" starting on \" + cal.toDateString());\n@@ -196,1 +194,1 @@\n-            logln(i + \"    \" + cal.toDateString());\n+            System.out.println(i + \"    \" + cal.toDateString());\n@@ -198,1 +196,1 @@\n-                errln(\"    \" + cal.toDateString() + \":\\t\" + cal.getMessage());\n+                fail(\"    \" + cal.toDateString() + \":\\t\" + cal.getMessage());\n@@ -207,0 +205,1 @@\n+    @Test\n@@ -209,1 +208,1 @@\n-        logln(\"Today is 2003\/10\/1 Gregorian.\");\n+        System.out.println(\"Today is 2003\/10\/1 Gregorian.\");\n@@ -214,1 +213,1 @@\n-        logln(\"  Changing the cutover date to yesterday...\");\n+        System.out.println(\"  Changing the cutover date to yesterday...\");\n@@ -217,1 +216,1 @@\n-            errln(\"    \" + cal.getMessage());\n+            fail(\"    \" + cal.getMessage());\n@@ -219,1 +218,1 @@\n-        logln(\"  Changing the cutover date to tomorrow...\");\n+        System.out.println(\"  Changing the cutover date to tomorrow...\");\n@@ -222,1 +221,1 @@\n-            errln(\"    \" + cal.getMessage());\n+            fail(\"    \" + cal.getMessage());\n@@ -229,0 +228,1 @@\n+    @Test\n@@ -232,1 +232,1 @@\n-        logln(\"getLeastMaximum should handle cutover year.\\n\"\n+        System.out.println(\"getLeastMaximum should handle cutover year.\\n\"\n@@ -235,1 +235,1 @@\n-            errln(\"    \" + cal.getMessage());\n+            fail(\"    \" + cal.getMessage());\n@@ -238,1 +238,1 @@\n-            errln(\"    \" + cal.getMessage());\n+            fail(\"    \" + cal.getMessage());\n@@ -242,1 +242,1 @@\n-            errln(\"    \" + cal.getMessage());\n+            fail(\"    \" + cal.getMessage());\n@@ -245,1 +245,1 @@\n-            errln(\"    \" + cal.getMessage());\n+            fail(\"    \" + cal.getMessage());\n@@ -248,1 +248,1 @@\n-            errln(\"    \" + cal.getMessage());\n+            fail(\"    \" + cal.getMessage());\n@@ -252,1 +252,1 @@\n-            errln(\"    getLeastMaximum calls modified the object.\");\n+            fail(\"    getLeastMaximum calls modified the object.\");\n@@ -255,1 +255,1 @@\n-            errln(\"    \" + cal.getMessage());\n+            fail(\"    \" + cal.getMessage());\n@@ -258,1 +258,1 @@\n-        logln(\"  changing the date to 1582\/10\/20 for actual min\/max tests\");\n+        System.out.println(\"  changing the date to 1582\/10\/20 for actual min\/max tests\");\n@@ -261,1 +261,1 @@\n-            errln(\"    \" + cal.getMessage());\n+            fail(\"    \" + cal.getMessage());\n@@ -264,1 +264,1 @@\n-            errln(\"    \" + cal.getMessage());\n+            fail(\"    \" + cal.getMessage());\n@@ -268,1 +268,1 @@\n-        logln(\"Change the cutover date to 1970\/1\/5.\");\n+        System.out.println(\"Change the cutover date to 1970\/1\/5.\");\n@@ -273,1 +273,1 @@\n-            errln(\"    \" + cal.getMessage());\n+            fail(\"    \" + cal.getMessage());\n@@ -276,1 +276,1 @@\n-            errln(\"    \" + cal.getMessage());\n+            fail(\"    \" + cal.getMessage());\n@@ -279,1 +279,1 @@\n-            errln(\"    \" + cal.getMessage());\n+            fail(\"    \" + cal.getMessage());\n@@ -283,1 +283,1 @@\n-            errln(\"    \" + cal.getMessage());\n+            fail(\"    \" + cal.getMessage());\n@@ -286,1 +286,1 @@\n-            errln(\"    \" + cal.getMessage());\n+            fail(\"    \" + cal.getMessage());\n@@ -293,0 +293,1 @@\n+    @Test\n@@ -300,1 +301,1 @@\n-            errln(\"test case 1: \" + gc1.getMessage());\n+            fail(\"test case 1: \" + gc1.getMessage());\n@@ -306,1 +307,1 @@\n-            errln(\"test case 2: \" + gc1.getMessage());\n+            fail(\"test case 2: \" + gc1.getMessage());\n@@ -313,0 +314,1 @@\n+    @Test\n@@ -322,1 +324,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n@@ -328,1 +330,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n","filename":"test\/jdk\/java\/util\/Calendar\/GregorianCutoverTest.java","additions":75,"deletions":73,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @library \/java\/text\/testlib\n+ * @run junit JulianTest\n@@ -33,1 +33,1 @@\n-public class JulianTest extends IntlTest {\n+import org.junit.jupiter.api.Test;\n@@ -35,3 +35,3 @@\n-    public static void main(String[] args) throws Exception {\n-        new JulianTest().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class JulianTest {\n@@ -42,0 +42,1 @@\n+    @Test\n@@ -49,1 +50,1 @@\n-            errln(cal.getMessage());\n+            fail(cal.getMessage());\n","filename":"test\/jdk\/java\/util\/Calendar\/JulianTest.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @library \/java\/text\/testlib\n+ * @run junit\/othervm NonLenientTest\n@@ -38,1 +38,2 @@\n-public class NonLenientTest extends IntlTest {\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n@@ -40,12 +41,9 @@\n-    public static void main(String[] args) throws Exception {\n-        Locale reservedLocale = Locale.getDefault();\n-        TimeZone reservedTimeZone = TimeZone.getDefault();\n-        try {\n-            Locale.setDefault(Locale.US);\n-            TimeZone.setDefault(TimeZone.getTimeZone(\"America\/Los_Angeles\"));\n-            new NonLenientTest().run(args);\n-        } finally {\n-            \/\/ restore the reserved locale and time zone\n-            Locale.setDefault(reservedLocale);\n-            TimeZone.setDefault(reservedTimeZone);\n-        }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class NonLenientTest {\n+\n+    \/\/ Change JVM default Locale and TimeZone\n+    @BeforeAll\n+    static void initAll() {\n+        Locale.setDefault(Locale.US);\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"America\/Los_Angeles\"));\n@@ -54,0 +52,2 @@\n+\n+    @Test\n@@ -125,0 +125,1 @@\n+    @Test\n@@ -138,0 +139,1 @@\n+    @Test\n@@ -149,0 +151,1 @@\n+    @Test\n@@ -160,1 +163,1 @@\n-                errln(\"Test failed with field \" + Koyomi.getFieldName(field)\n+                fail(\"Test failed with field \" + Koyomi.getFieldName(field)\n@@ -175,1 +178,1 @@\n-                errln(\"Test failed with field \" + Koyomi.getFieldName(field)\n+                fail(\"Test failed with field \" + Koyomi.getFieldName(field)\n@@ -190,1 +193,1 @@\n-            errln(desc + \" should throw IllegalArgumentException in non-lenient.\");\n+            fail(desc + \" should throw IllegalArgumentException in non-lenient.\");\n@@ -201,1 +204,1 @@\n-                errln(\"    complete() modified fields[\" + Koyomi.getFieldName(i) + \"] got \"\n+                fail(\"    complete() modified fields[\" + Koyomi.getFieldName(i) + \"] got \"\n@@ -208,1 +211,1 @@\n-            errln(\"    complate() modified set states: before 0x\" + toHex(setFields)\n+            fail(\"    complate() modified set states: before 0x\" + toHex(setFields)\n","filename":"test\/jdk\/java\/util\/Calendar\/NonLenientTest.java","additions":23,"deletions":20,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n- * @summary Make sure cloned GregorianCalendar is unchanged by modifying its original.\n+ * @summary Ensure cloned GregorianCalendar is unchanged when modifying its original.\n+ * @run junit bug4028518\n@@ -30,2 +31,7 @@\n-import java.util.GregorianCalendar ;\n-import static java.util.Calendar.*;\n+import java.util.GregorianCalendar;\n+\n+import static java.util.Calendar.DAY_OF_MONTH;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n@@ -35,2 +41,6 @@\n-    public static void main(String[] args)\n-    {\n+    \/*\n+     * Ensure modifying the original GregorianCalendar does not\n+     * modify the cloned one as well\n+     *\/\n+    @Test\n+    public void clonedShouldNotChangeOriginalTest() {\n@@ -39,3 +49,0 @@\n-\n-        printdate(cal1, \"cal1: \") ;\n-        printdate(cal2, \"cal2 - cloned(): \") ;\n@@ -43,12 +50,2 @@\n-        printdate(cal1, \"cal1 after adding 1 day: \") ;\n-        printdate(cal2, \"cal2 should be unmodified: \") ;\n-        if (cal1.get(DAY_OF_MONTH) == cal2.get(DAY_OF_MONTH)) {\n-            throw new RuntimeException(\"cloned GregorianCalendar modified\");\n-        }\n-    }\n-\n-    private static void printdate(GregorianCalendar cal, String string)\n-    {\n-        System.out.println(string + (cal.get(MONTH) + 1)\n-                           + \"\/\" + cal.get(DAY_OF_MONTH)\n-                           + \"\/\" + cal.get(YEAR)) ;\n+        assertNotEquals(cal1.get(DAY_OF_MONTH), cal2.get(DAY_OF_MONTH),\n+                \"Cloned calendar should not have same value as original\");\n","filename":"test\/jdk\/java\/util\/Calendar\/bug4028518.java","additions":18,"deletions":21,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n- * @summary Make sure set(DAY_OF_YEAR, 1) works.\n+ * @summary Ensure set(DAY_OF_YEAR, 1) works.\n+ * @run junit bug4100311\n@@ -34,2 +35,7 @@\n-public class bug4100311\n-{\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class bug4100311 {\n+\n+    \/\/ GregorianCalendar should be able to date to january 1st properly\n@@ -37,2 +43,2 @@\n-    public static void main(String args[])\n-    {\n+    @Test\n+    public void dayOfYearIsOneTest() {\n@@ -42,4 +48,3 @@\n-        Date d = cal.getTime();             \/\/ Should be Jan 1\n-        if (d.getMonth() != 0 || d.getDate() != 1) {\n-            throw new RuntimeException(\"Date isn't Jan 1\");\n-        }\n+        Date d = cal.getTime();\n+        assertEquals(0, d.getMonth(), \"Date: \"+d+\" isn't January 1st\");\n+        assertEquals(1, d.getDate(),\"Date: \"+d+\" isn't January 1st\");\n","filename":"test\/jdk\/java\/util\/Calendar\/bug4100311.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,3 @@\n- * getTimeInMillis() can be called from a user program. (They used to\n- * be protected methods.)\n- * @library \/java\/text\/testlib\n+ *          getTimeInMillis() can be called from a user program. (They used to\n+ *          be protected methods.)\n+ * @run junit bug4243802\n@@ -33,1 +33,3 @@\n-import java.util.*;\n+import java.util.Calendar;\n+import java.util.Locale;\n+import java.util.TimeZone;\n@@ -35,1 +37,3 @@\n-public class bug4243802 extends IntlTest {\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n@@ -37,2 +41,20 @@\n-    public static void main(String[] args) throws Exception {\n-        new bug4243802().run(args);\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class bug4243802 {\n+\n+    \/\/ Save JVM default Locale and TimeZone\n+    private static final TimeZone savedTz = TimeZone.getDefault();\n+    private static final Locale savedLocale = Locale.getDefault();\n+\n+    \/\/ Set custom JVM default Locale and TimeZone\n+    @BeforeAll\n+    static void initAll() {\n+        Locale.setDefault(Locale.US);\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"America\/Los_Angeles\"));\n+    }\n+\n+    \/\/ Restore JVM default Locale and TimeZone\n+    @AfterAll\n+    static void tearDownAll() {\n+        Locale.setDefault(savedLocale);\n+        TimeZone.setDefault(savedTz);\n@@ -41,2 +63,4 @@\n-    \/**\n-     * 4243802: RFE: need way to set the date of a calendar without a Date object\n+    \/*\n+     * Test getTimeInMillis() and setTimeInMillis(). Compare a Calendar\n+     * set with a traditional date to one set using setTimeInMillis(),\n+     * where both Calendars should be of equal times.\n@@ -44,6 +68,9 @@\n-    public void Test4243802() {\n-        TimeZone saveZone = TimeZone.getDefault();\n-        Locale saveLocale = Locale.getDefault();\n-        try {\n-            Locale.setDefault(Locale.US);\n-            TimeZone.setDefault(TimeZone.getTimeZone(\"America\/Los_Angeles\"));\n+    @Test\n+    public void setCalendarWithoutDateTest() {\n+        Calendar cal1 = Calendar.getInstance();\n+        Calendar cal2 = Calendar.getInstance();\n+        cal1.clear();\n+        cal2.clear();\n+        cal1.set(2001, Calendar.JANUARY, 25, 1, 23, 45);\n+        \/\/ Build the second calendar using the getTimeInMillis of the first\n+        cal2.setTimeInMillis(cal1.getTimeInMillis());\n@@ -51,2 +78,8 @@\n-            Calendar cal1 = Calendar.getInstance();\n-            Calendar cal2 = Calendar.getInstance();\n+        assertEquals(2001, cal2.get(Calendar.YEAR), getErrMsg(cal1));\n+        assertEquals(Calendar.JANUARY, cal2.get(Calendar.MONTH), getErrMsg(cal1));\n+        assertEquals(25, cal2.get(Calendar.DAY_OF_MONTH), getErrMsg(cal1));\n+        assertEquals(1, cal2.get(Calendar.HOUR_OF_DAY), getErrMsg(cal1));\n+        assertEquals(23, cal2.get(Calendar.MINUTE), getErrMsg(cal1));\n+        assertEquals(45, cal2.get(Calendar.SECOND), getErrMsg(cal1));\n+        assertEquals(0, cal2.get(Calendar.MILLISECOND), getErrMsg(cal1));\n+    }\n@@ -54,26 +87,10 @@\n-            cal1.clear();\n-            cal2.clear();\n-            cal1.set(2001, Calendar.JANUARY, 25, 1, 23, 45);\n-            cal2.setTimeInMillis(cal1.getTimeInMillis());\n-            if ((cal2.get(Calendar.YEAR) != 2001) ||\n-                (cal2.get(Calendar.MONTH) != Calendar.JANUARY) ||\n-                (cal2.get(Calendar.DAY_OF_MONTH) != 25) ||\n-                (cal2.get(Calendar.HOUR_OF_DAY) != 1) ||\n-                (cal2.get(Calendar.MINUTE) != 23) ||\n-                (cal2.get(Calendar.SECOND) != 45) ||\n-                (cal2.get(Calendar.MILLISECOND) != 0)) {\n-                 errln(\"Failed: expected 1\/25\/2001 1:23:45.000\" +\n-                       \", got \" + (cal2.get(Calendar.MONTH)+1) + \"\/\" +\n-                       cal2.get(Calendar.DAY_OF_MONTH) +\"\/\" +\n-                       cal2.get(Calendar.YEAR) + \" \" +\n-                       cal2.get(Calendar.HOUR_OF_DAY) + \":\" +\n-                       cal2.get(Calendar.MINUTE) + \":\" +\n-                       cal2.get(Calendar.SECOND) + \".\" +\n-                       toMillis(cal2.get(Calendar.MILLISECOND)));\n-            }\n-            logln(\"Passed.\");\n-        }\n-        finally {\n-            Locale.setDefault(saveLocale);\n-            TimeZone.setDefault(saveZone);\n-        }\n+    \/\/ Utility to build a long error message\n+    private static String getErrMsg(Calendar cal) {\n+        return \"Failed: expected 1\/25\/2001 1:23:45.000\" +\n+                \", got \" + (cal.get(Calendar.MONTH)+1) + \"\/\" +\n+                cal.get(Calendar.DAY_OF_MONTH) +\"\/\" +\n+                cal.get(Calendar.YEAR) + \" \" +\n+                cal.get(Calendar.HOUR_OF_DAY) + \":\" +\n+                cal.get(Calendar.MINUTE) + \":\" +\n+                cal.get(Calendar.SECOND) + \".\" +\n+                toMillis(cal.get(Calendar.MILLISECOND));\n@@ -82,2 +99,3 @@\n-    private String toMillis(int m) {\n-        StringBuffer sb = new StringBuffer();\n+    \/\/ Utility to convert value to format of expected milisecond value\n+    private static String toMillis(int m) {\n+        StringBuilder sb = new StringBuilder();\n@@ -90,2 +108,1 @@\n-        sb.append(m);\n-        return sb.toString();\n+        return sb.append(m).toString();\n","filename":"test\/jdk\/java\/util\/Calendar\/bug4243802.java","additions":65,"deletions":48,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,5 +24,1 @@\n-import java.io.*;\n-import java.util.*;\n-import java.text.*;\n-\n-\/**\n+\/*\n@@ -31,2 +27,2 @@\n- * @summary test that Calendar's Serializasion works correctly.\n- * @library \/java\/text\/testlib\n+ * @summary test that Calendar's Serialization works correctly.\n+ * @run junit bug4316678\n@@ -34,1 +30,0 @@\n-public class bug4316678 extends IntlTest {\n@@ -36,3 +31,8 @@\n-    public static void main(String[] args) throws Exception {\n-        new bug4316678().run(args);\n-    }\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Calendar;\n+import java.util.GregorianCalendar;\n+import java.util.TimeZone;\n@@ -40,4 +40,3 @@\n-    public void Test4316678() throws Exception {\n-        GregorianCalendar gc1;\n-        GregorianCalendar gc2;\n-        TimeZone saveZone = TimeZone.getDefault();\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n@@ -45,2 +44,1 @@\n-        try {\n-            TimeZone.setDefault(TimeZone.getTimeZone(\"PST\"));\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -48,5 +46,1 @@\n-            gc1 = new GregorianCalendar(2000, Calendar.OCTOBER, 10);\n-            try (ObjectOutputStream out\n-                    = new ObjectOutputStream(new FileOutputStream(\"bug4316678.ser\"))) {\n-                out.writeObject(gc1);\n-            }\n+public class bug4316678 {\n@@ -54,4 +48,10 @@\n-            try (ObjectInputStream in\n-                    = new ObjectInputStream(new FileInputStream(\"bug4316678.ser\"))) {\n-                gc2 = (GregorianCalendar)in.readObject();\n-            }\n+    private static final String serializedData = \"bug4316678.ser\";\n+\n+    \/\/ Save JVM default TimeZone\n+    private static final TimeZone savedTz = TimeZone.getDefault();\n+\n+    \/\/ Set custom JVM default TimeZone\n+    @BeforeAll\n+    static void initAll() {\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"PST\"));\n+    }\n@@ -59,8 +59,14 @@\n-            gc1.set(Calendar.DATE, 16);\n-            gc2.set(Calendar.DATE, 16);\n-            if (!gc1.getTime().equals(gc2.getTime())) {\n-                errln(\"Invalid Time :\" + gc2.getTime() +\n-                    \", expected :\" + gc1.getTime());\n-            }\n-        } finally {\n-            TimeZone.setDefault(saveZone);\n+    \/\/ Restore JVM default Locale and TimeZone\n+    @AfterAll\n+    static void tearDownAll() {\n+        TimeZone.setDefault(savedTz);\n+    }\n+\n+    \/\/ Test that a serialized GregorianCalendar has the expected values\n+    @Test\n+    public void serializationTest() throws IOException, ClassNotFoundException {\n+        GregorianCalendar gc1 = new GregorianCalendar(2000, Calendar.OCTOBER, 10);\n+        GregorianCalendar gc2;\n+        try (ObjectOutputStream out\n+                = new ObjectOutputStream(new FileOutputStream(serializedData))) {\n+            out.writeObject(gc1);\n@@ -68,0 +74,9 @@\n+\n+        try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(serializedData))) {\n+            gc2 = (GregorianCalendar)in.readObject();\n+        }\n+\n+        gc1.set(Calendar.DATE, 16);\n+        gc2.set(Calendar.DATE, 16);\n+        assertEquals(gc2.getTime(), gc1.getTime(),\n+                \"Times should be equal after serialization\");\n","filename":"test\/jdk\/java\/util\/Calendar\/bug4316678.java","additions":50,"deletions":35,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @library \/java\/text\/testlib\n+ * @run junit bug4372743\n@@ -33,0 +33,1 @@\n+import java.util.stream.Stream;\n@@ -34,1 +35,17 @@\n-import static java.util.GregorianCalendar.*;\n+import static java.util.GregorianCalendar.AD;\n+import static java.util.GregorianCalendar.APRIL;\n+import static java.util.GregorianCalendar.AUGUST;\n+import static java.util.GregorianCalendar.BC;\n+import static java.util.GregorianCalendar.DECEMBER;\n+import static java.util.GregorianCalendar.ERA;\n+import static java.util.GregorianCalendar.FEBRUARY;\n+import static java.util.GregorianCalendar.JANUARY;\n+import static java.util.GregorianCalendar.JULY;\n+import static java.util.GregorianCalendar.JUNE;\n+import static java.util.GregorianCalendar.MARCH;\n+import static java.util.GregorianCalendar.MAY;\n+import static java.util.GregorianCalendar.MONTH;\n+import static java.util.GregorianCalendar.NOVEMBER;\n+import static java.util.GregorianCalendar.OCTOBER;\n+import static java.util.GregorianCalendar.SEPTEMBER;\n+import static java.util.GregorianCalendar.YEAR;\n@@ -36,1 +53,2 @@\n-public class bug4372743 extends IntlTest {\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n@@ -38,2 +56,21 @@\n-    public static void main(String[] args) throws Exception {\n-        new bug4372743().run(args);\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class bug4372743 {\n+\n+    \/\/ Save JVM default timezone\n+    private static final TimeZone savedTz = TimeZone.getDefault();\n+\n+    \/\/ Set custom JVM default timezone\n+    @BeforeAll\n+    static void initAll() {\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"PST\"));\n+    }\n+\n+    \/\/ Restore JVM default timezone\n+    @AfterAll\n+    static void tearDownAll() {\n+        TimeZone.setDefault(savedTz);\n@@ -42,1 +79,50 @@\n-    private int[][] data = {\n+    \/*\n+     * Set GregorianCalendar to (March 3, A.D. 2) and test adding\n+     * to the month field. Ensure that the added field is as expected.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"A_D_Values\")\n+    public void A_D_Test(GregorianCalendar gc, int monthValue) {\n+        for (int i = 0; i < tableSize; i+=(-monthValue)) {\n+            check(gc, i);\n+            gc.add(MONTH, monthValue);\n+        }\n+    }\n+\n+    \/\/ Given in format: (A.D.) GregorianCalendar, amount to add\n+    private static Stream<Arguments> A_D_Values() {\n+        return Stream.of(\n+                Arguments.of(new GregorianCalendar(2, MARCH, 3), -1),\n+                Arguments.of(new GregorianCalendar(2, MARCH, 3), -7));\n+    }\n+\n+    \/*\n+     * Set GregorianCalendar to (March 10, 2 B.C.) and test adding\n+     * to the month field. Ensure that the added field is as expected.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"B_C_Values\")\n+    public void B_C_Test(GregorianCalendar gc, int monthValue) {\n+            gc.add(YEAR, -3);\n+            for (int i = tableSize - 1; i >= 0; i-=monthValue) {\n+                check(gc, i);\n+                gc.add(MONTH, monthValue);\n+            }\n+    }\n+\n+    \/\/ Given in format: (B.C.) GregorianCalendar, amount to add\n+    private static Stream<Arguments> B_C_Values() {\n+        return Stream.of(\n+                Arguments.of(new GregorianCalendar(2, OCTOBER, 10), 1),\n+                Arguments.of(new GregorianCalendar(2, OCTOBER, 10), 8));\n+    }\n+\n+    \/\/ Check golden data array with actual value\n+    private void check(GregorianCalendar gc, int index) {\n+        assertEquals(data[index][ERA], gc.get(ERA), \"Invalid era\");\n+        assertEquals(data[index][YEAR], gc.get(YEAR), \"Invalid year\");\n+        assertEquals(data[index][MONTH], gc.get(MONTH), \"Invalid month\");\n+    }\n+\n+    \/\/ Expected ERA, YEAR, and MONTH combinations\n+    private final int[][] data = {\n@@ -73,57 +159,1 @@\n-    private int tablesize = data.length;\n-\n-    private void check(GregorianCalendar gc, int index) {\n-        if (gc.get(ERA) != data[index][ERA]) {\n-            errln(\"Invalid era :\" + gc.get(ERA)\n-                    + \", expected :\" + data[index][ERA]);\n-        }\n-        if (gc.get(YEAR) != data[index][YEAR]) {\n-            errln(\"Invalid year :\" + gc.get(YEAR)\n-                    + \", expected :\" + data[index][YEAR]);\n-        }\n-        if (gc.get(MONTH) != data[index][MONTH]) {\n-            errln(\"Invalid month :\" + gc.get(MONTH)\n-                    + \", expected :\" + data[index][MONTH]);\n-        }\n-    }\n-\n-    public void Test4372743() {\n-        GregorianCalendar gc;\n-        TimeZone saveZone = TimeZone.getDefault();\n-\n-        try {\n-            TimeZone.setDefault(TimeZone.getTimeZone(\"PST\"));\n-\n-            \/* Set March 3, A.D. 2 *\/\n-            gc = new GregorianCalendar(2, MARCH, 3);\n-            for (int i = 0; i < tablesize; i++) {\n-                check(gc, i);\n-                gc.add(MONTH, -1);\n-            }\n-\n-            \/* Again, Set March 3, A.D. 2 *\/\n-            gc = new GregorianCalendar(2, MARCH, 3);\n-            for (int i = 0; i < tablesize; i += 7) {\n-                check(gc, i);\n-                gc.add(MONTH, -7);\n-            }\n-\n-            \/* Set March 10, 2 B.C. *\/\n-            gc = new GregorianCalendar(2, OCTOBER, 10);\n-            gc.add(YEAR, -3);\n-            for (int i = tablesize - 1; i >= 0; i--) {\n-                check(gc, i);\n-                gc.add(MONTH, 1);\n-            }\n-\n-            \/* Again, Set March 10, 2 B.C. *\/\n-            gc = new GregorianCalendar(2, OCTOBER, 10);\n-            gc.add(YEAR, -3);\n-            for (int i = tablesize - 1; i >= 0; i -= 8) {\n-                check(gc, i);\n-                gc.add(MONTH, 8);\n-            }\n-        } finally {\n-            TimeZone.setDefault(saveZone);\n-        }\n-    }\n+    private final int tableSize = data.length;\n","filename":"test\/jdk\/java\/util\/Calendar\/bug4372743.java","additions":94,"deletions":64,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,4 @@\n- * @summary Make sure that GregorianCalendar doesn't cause IllegalArgumentException at some special situations which are related to the Leap Year.\n- * @library \/java\/text\/testlib\n+ * @summary Make sure that GregorianCalendar doesn't cause\n+ *          IllegalArgumentException at some special situations which are\n+ *          related to the Leap Year.\n+ * @run junit bug4401223\n@@ -34,1 +36,6 @@\n-import static java.util.GregorianCalendar.*;\n+import static java.util.GregorianCalendar.DATE;\n+import static java.util.GregorianCalendar.DAY_OF_YEAR;\n+import static java.util.GregorianCalendar.DECEMBER;\n+import static java.util.GregorianCalendar.FEBRUARY;\n+import static java.util.GregorianCalendar.MONTH;\n+import static java.util.GregorianCalendar.YEAR;\n@@ -36,1 +43,1 @@\n-public class bug4401223 extends IntlTest {\n+import org.junit.jupiter.api.Test;\n@@ -38,3 +45,2 @@\n-    public void Test4401223a() {\n-        int status = 0;\n-        String s = null;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -42,4 +48,9 @@\n-        try {\n-            @SuppressWarnings(\"deprecation\")\n-            Date date = new Date(2000 - 1900, FEBRUARY, 29);\n-            GregorianCalendar gc = new GregorianCalendar();\n+public class bug4401223 {\n+\n+    \/\/ Ensure IAE not thrown for date: 12-29-00\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void checkExceptionTest() {\n+        Date date = new Date(2000 - 1900, FEBRUARY, 29);\n+        GregorianCalendar gc = new GregorianCalendar();\n+        assertDoesNotThrow(() -> {\n@@ -49,10 +60,1 @@\n-            s = \"02\/29\/00 & set(YEAR,2001) = \" + gc.getTime().toString();\n-        } catch (Exception ex) {\n-            status++;\n-            s = \"Exception occurred for 2\/29\/00 & set(YEAR,2001): \" + ex;\n-        }\n-        if (status > 0) {\n-            errln(s);\n-        } else {\n-            logln(s);\n-        }\n+        }, \"Exception occurred for 2\/29\/00 & set(YEAR,2001)\");\n@@ -61,8 +63,7 @@\n-    public void Test4401223b() {\n-        int status = 0;\n-        String s = null;\n-\n-        try {\n-            @SuppressWarnings(\"deprecation\")\n-            Date date = new Date(2000 - 1900, DECEMBER, 31);\n-            GregorianCalendar gc = new GregorianCalendar();\n+    \/\/ Ensure IAE not thrown for date: 12-31-00. Validate expected values.\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void checkExceptionAndValuesTest() {\n+        Date date = new Date(2000 - 1900, DECEMBER, 31);\n+        GregorianCalendar gc = new GregorianCalendar();\n+        assertDoesNotThrow(() -> {\n@@ -72,0 +73,1 @@\n+        }, \"Exception occurred for 12\/31\/00 & set(YEAR,2001)\");\n@@ -73,19 +75,1 @@\n-            if (gc.get(YEAR) != 2001\n-                    || gc.get(MONTH) != DECEMBER\n-                    || gc.get(DATE) != 31\n-                    || gc.get(DAY_OF_YEAR) != 365) {\n-                status++;\n-                s = \"Wrong Date : 12\/31\/00 & set(YEAR,2001) ---> \" + gc.getTime().toString();\n-            } else {\n-                s = \"12\/31\/00 & set(YEAR,2001) = \" + gc.getTime().toString();\n-            }\n-        } catch (Exception ex) {\n-            status++;\n-            s = \"Exception occurred for 12\/31\/00 & set(YEAR,2001) : \" + ex;\n-        }\n-        if (status > 0) {\n-            errln(s);\n-        } else {\n-            logln(s);\n-        }\n-    }\n+        String errMsg = \"Wrong date,  got: \" + gc.getTime();\n@@ -93,2 +77,4 @@\n-    public static void main(String[] args) throws Exception {\n-        new bug4401223().run(args);\n+        assertEquals(2001, gc.get(YEAR), errMsg);\n+        assertEquals(DECEMBER, gc.get(MONTH), errMsg);\n+        assertEquals(31, gc.get(DATE), errMsg);\n+        assertEquals(365, gc.get(DAY_OF_YEAR), errMsg);\n","filename":"test\/jdk\/java\/util\/Calendar\/bug4401223.java","additions":37,"deletions":51,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main bug4409072\n+ * @run junit bug4409072\n@@ -35,1 +35,1 @@\n-public class bug4409072 extends IntlTest {\n+import org.junit.jupiter.api.Test;\n@@ -37,3 +37,3 @@\n-    public static void main(String[] args) throws Exception {\n-        new bug4409072().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class bug4409072 {\n@@ -44,0 +44,1 @@\n+    @Test\n@@ -47,1 +48,1 @@\n-            logln(\"Skipping this test because locale is \" + locale);\n+            System.out.println(\"Skipping this test because locale is \" + locale);\n@@ -414,1 +415,1 @@\n-                    errln(\"Failed : set(WEEK_OF_YEAR=22)\" +\n+                    fail(\"Failed : set(WEEK_OF_YEAR=22)\" +\n@@ -423,1 +424,1 @@\n-                    errln(\"Failed : set(WEEK_OF_YEAR=22)\" +\n+                    fail(\"Failed : set(WEEK_OF_YEAR=22)\" +\n@@ -449,1 +450,1 @@\n-                        errln(\"Failed : set(WEEK_OF_MONTH=1)\" +\n+                        fail(\"Failed : set(WEEK_OF_MONTH=1)\" +\n@@ -473,1 +474,1 @@\n-                        errln(\"Failed : set(WEEK_OF_YEAR=1)\" +\n+                        fail(\"Failed : set(WEEK_OF_YEAR=1)\" +\n@@ -482,1 +483,1 @@\n-                        errln(\"Failed : set(WEEK_OF_YEAR=1)\" +\n+                        fail(\"Failed : set(WEEK_OF_YEAR=1)\" +\n@@ -493,1 +494,1 @@\n-            logln(\"Passed : set() test\");\n+            System.out.println(\"Passed : set() test\");\n@@ -528,1 +529,1 @@\n-                    errln(\"Failed : add(WEEK_OF_YEAR+1)\" +\n+                    fail(\"Failed : add(WEEK_OF_YEAR+1)\" +\n@@ -545,1 +546,1 @@\n-                    errln(\"Failed : add(WEEK_OF_YEAR-1)\" +\n+                    fail(\"Failed : add(WEEK_OF_YEAR-1)\" +\n@@ -553,1 +554,1 @@\n-                    errln(\"Failed : add(-1)\" +\n+                    fail(\"Failed : add(-1)\" +\n@@ -563,1 +564,1 @@\n-            logln(\"Passed : add() test\");\n+            System.out.println(\"Passed : add() test\");\n@@ -625,1 +626,1 @@\n-                    errln(\"Failed : roll(WEEK_OF_MONTH-1)\" +\n+                    fail(\"Failed : roll(WEEK_OF_MONTH-1)\" +\n@@ -652,1 +653,1 @@\n-                    errln(\"Failed : roll(WEEK_OF_YEAR+1)\" +\n+                    fail(\"Failed : roll(WEEK_OF_YEAR+1)\" +\n@@ -673,1 +674,1 @@\n-                    errln(\"Failed : roll(WEEK_OF_YEAR-1)\" +\n+                    fail(\"Failed : roll(WEEK_OF_YEAR-1)\" +\n@@ -683,1 +684,1 @@\n-            logln(\"Passed : roll() test\");\n+            System.out.println(\"Passed : roll() test\");\n","filename":"test\/jdk\/java\/util\/Calendar\/bug4409072.java","additions":22,"deletions":21,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,3 @@\n- * @summary Confirm that GregorianCalendar.roll() works properly during transition from Daylight Saving Time to Standard Time.\n+ * @summary Confirm that GregorianCalendar.roll() works properly during\n+ *          transition from Daylight Saving Time to Standard Time.\n+ * @run junit bug4514831\n@@ -34,1 +36,6 @@\n-import static java.util.GregorianCalendar.*;\n+import static java.util.GregorianCalendar.DAY_OF_MONTH;\n+import static java.util.GregorianCalendar.DAY_OF_WEEK;\n+import static java.util.GregorianCalendar.DAY_OF_WEEK_IN_MONTH;\n+import static java.util.GregorianCalendar.DAY_OF_YEAR;\n+import static java.util.GregorianCalendar.OCTOBER;\n+import static java.util.GregorianCalendar.THURSDAY;\n@@ -36,0 +43,3 @@\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n@@ -37,6 +47,1 @@\n-public class bug4514831 {\n-\n-    public static void main(String[] args) {\n-        Locale savedLocale = Locale.getDefault();\n-        TimeZone savedTimeZone = TimeZone.getDefault();\n-        boolean err = false;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -44,3 +49,7 @@\n-        String golden_data1 = \"27-28 28-29 29-30 30-31 31-1 1-2 2-3 \";\n-        String golden_data2 = \"27-28 28-29 29-30 30-31 31-25 25-26 26-27 \";\n-        String golden_data3 = \"1-8 8-15 15-22 22-29 29-1 1-8 8-15 \";\n+public class bug4514831 {\n+    \/\/ Data of 7 rolls in the form of a string for the respective field\n+    private static final String expectedDayOfYearData = \"27-28 28-29 29-30 30-31 31-1 1-2 2-3 \";\n+    private static final String expectedDayOfWeekData = \"27-28 28-29 29-30 30-31 31-25 25-26 26-27 \";\n+    private static final String expectedDayOfWeekInMonthData = \"1-8 8-15 15-22 22-29 29-1 1-8 8-15 \";\n+    private static final TimeZone savedTz = TimeZone.getDefault();\n+    private static final Locale savedLocale = Locale.getDefault();\n@@ -48,3 +57,6 @@\n-        try {\n-            Locale.setDefault(Locale.US);\n-            TimeZone.setDefault(TimeZone.getTimeZone(\"US\/Pacific\"));\n+    \/\/ Save JVM default Locale and TimeZone\n+    @BeforeAll\n+    void initAll() {\n+        Locale.setDefault(Locale.US);\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"US\/Pacific\"));\n+    }\n@@ -52,12 +64,6 @@\n-            String test_roll = \"\";\n-            GregorianCalendar c_roll = new GregorianCalendar(2001, OCTOBER, 27);\n-            for (int i = 0; i < 7; i++) {\n-                test_roll += c_roll.get(DAY_OF_MONTH) + \"-\";\n-                c_roll.roll(DAY_OF_YEAR, true);\n-                test_roll += c_roll.get(DAY_OF_MONTH) + \" \";\n-            }\n-            if (!test_roll.equals(golden_data1)) {\n-                err = true;\n-                System.err.println(\"Wrong roll(DAY_OF_YEAR) transition: got \"\n-                        + test_roll + \"expected \" + golden_data1);\n-            }\n+    \/\/ Restore JVM default Locale and TimeZone\n+    @AfterAll\n+    void tearDownAll() {\n+        Locale.setDefault(savedLocale);\n+        TimeZone.setDefault(savedTz);\n+    }\n@@ -65,13 +71,16 @@\n-            test_roll = \"\";\n-            c_roll = new GregorianCalendar(2001, OCTOBER, 27);\n-            c_roll.setFirstDayOfWeek(THURSDAY);\n-            for (int i = 0; i < 7; i++) {\n-                test_roll += c_roll.get(DAY_OF_MONTH) + \"-\";\n-                c_roll.roll(DAY_OF_WEEK, true);\n-                test_roll += c_roll.get(DAY_OF_MONTH) + \" \";\n-            }\n-            if (!test_roll.equals(golden_data2)) {\n-                err = true;\n-                System.err.println(\"Wrong roll(DAY_OF_WEEK) transition: got \"\n-                        + test_roll + \"expected \" + golden_data2);\n-            }\n+    \/*\n+     * Test some roll values during transition (DAY_OF_YEAR field). Uses\n+     * the boolean roll method. Roll multiple times and attach the returned\n+     * values to a long string which is then compared to the expected data.\n+     *\/\n+    public void rollDayOfYearTest() {\n+        StringBuilder actualRollData = new StringBuilder();\n+        GregorianCalendar cal = new GregorianCalendar(2001, OCTOBER, 27);\n+        for (int i = 0; i < 7; i++) {\n+            actualRollData.append(cal.get(DAY_OF_MONTH)).append(\"-\");\n+            cal.roll(DAY_OF_YEAR, true);\n+            actualRollData.append(cal.get(DAY_OF_MONTH)).append(\" \");\n+        }\n+        assertEquals(expectedDayOfYearData, actualRollData.toString(),\n+                \"Wrong roll(DAY_OF_YEAR) transition\");\n+    }\n@@ -79,15 +88,13 @@\n-            test_roll = \"\";\n-            c_roll = new GregorianCalendar(2001, OCTOBER, 1);\n-            for (int i = 0; i < 7; i++) {\n-                test_roll += c_roll.get(DAY_OF_MONTH) + \"-\";\n-                c_roll.roll(DAY_OF_WEEK_IN_MONTH, true);\n-                test_roll += c_roll.get(DAY_OF_MONTH) + \" \";\n-            }\n-            if (!test_roll.equals(golden_data3)) {\n-                err = true;\n-                System.err.println(\"Wrong roll(DAY_OF_WEEK_IN_MONTH) transition: got \"\n-                        + test_roll + \"expected \" + golden_data3);\n-            }\n-        } finally {\n-            Locale.setDefault(savedLocale);\n-            TimeZone.setDefault(savedTimeZone);\n+    \/*\n+     * Test some roll values during transition (DAY_OF_WEEK field). Uses\n+     * the boolean roll method. Roll multiple times and attach the returned\n+     * values to a long string which is then compared to the expected data.\n+     *\/\n+    public void rollDayOfWeekTest() {\n+        StringBuilder actualRollData = new StringBuilder();\n+        GregorianCalendar cal = new GregorianCalendar(2001, OCTOBER, 27);\n+        cal.setFirstDayOfWeek(THURSDAY);\n+        for (int i = 0; i < 7; i++) {\n+            actualRollData.append(cal.get(DAY_OF_MONTH)).append(\"-\");\n+            cal.roll(DAY_OF_WEEK, true);\n+            actualRollData.append(cal.get(DAY_OF_MONTH)).append(\" \");\n@@ -95,0 +102,3 @@\n+        assertEquals(expectedDayOfWeekData, actualRollData.toString(),\n+                \"Wrong roll(DAY_OF_WEEK) transition\");\n+    }\n@@ -96,2 +106,12 @@\n-        if (err) {\n-            throw new RuntimeException(\"Wrong roll() transition\");\n+    \/*\n+     * Test some roll values during transition (DAY_OF_WEEK_IN_MONTH field). Uses\n+     * the boolean roll method. Roll multiple times and attach the returned\n+     * values to a long string which is then compared to the expected data.\n+     *\/\n+    public void rollDayOfWeekInMonthTest() {\n+        StringBuilder actualRollData = new StringBuilder();\n+        GregorianCalendar cal = new GregorianCalendar(2001, OCTOBER, 1);\n+        for (int i = 0; i < 7; i++) {\n+            actualRollData.append(cal.get(DAY_OF_MONTH)).append(\"-\");\n+            cal.roll(DAY_OF_WEEK_IN_MONTH, true);\n+            actualRollData.append(cal.get(DAY_OF_MONTH)).append(\" \");\n@@ -99,0 +119,2 @@\n+        assertEquals(expectedDayOfWeekInMonthData, actualRollData.toString(),\n+                \"Wrong roll(DAY_OF_WEEK_IN_MONTH) transition\");\n","filename":"test\/jdk\/java\/util\/Calendar\/bug4514831.java","additions":79,"deletions":57,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @library \/java\/text\/testlib\n+ * @run junit DateRegression\n@@ -32,2 +32,1 @@\n-@SuppressWarnings(\"deprecation\")\n-public class DateRegression extends IntlTest {\n+import org.junit.jupiter.api.Test;\n@@ -35,3 +34,4 @@\n-    public static void main(String[] args) throws Exception {\n-        new DateRegression().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@SuppressWarnings(\"deprecation\")\n+public class DateRegression {\n@@ -42,0 +42,1 @@\n+    @Test\n@@ -61,1 +62,1 @@\n-            errln(\"Fail: Date hashCode misbehaves\");\n+            fail(\"Fail: Date hashCode misbehaves\");\n@@ -67,0 +68,1 @@\n+    @Test\n@@ -73,1 +75,1 @@\n-        logln(\"Midnight = \" + nite + \", Noon = \" + noon);\n+        System.out.println(\"Midnight = \" + nite + \", Noon = \" + noon);\n@@ -76,1 +78,1 @@\n-            errln(\"Fail: Nite\/Noon confused\");\n+            fail(\"Fail: Nite\/Noon confused\");\n@@ -82,0 +84,1 @@\n+    @Test\n@@ -85,2 +88,2 @@\n-        logln(\"Date.parse(2\/10\/97) => \" + d);\n-        if (!d.equals(ref)) errln(\"Fail: Want \" + ref + \" Got \" + d);\n+        System.out.println(\"Date.parse(2\/10\/97) => \" + d);\n+        if (!d.equals(ref)) fail(\"Fail: Want \" + ref + \" Got \" + d);\n@@ -88,2 +91,2 @@\n-        logln(\"Date.parse(10 feb 1997) => \" + d);\n-        if (!d.equals(ref)) errln(\"Fail: Want \" + ref + \" Got \" + d);\n+        System.out.println(\"Date.parse(10 feb 1997) => \" + d);\n+        if (!d.equals(ref)) fail(\"Fail: Want \" + ref + \" Got \" + d);\n@@ -91,2 +94,2 @@\n-        logln(\"Date(2\/10\/97) => \" + d);\n-        if (!d.equals(ref)) errln(\"Fail: Want \" + ref + \" Got \" + d);\n+        System.out.println(\"Date(2\/10\/97) => \" + d);\n+        if (!d.equals(ref)) fail(\"Fail: Want \" + ref + \" Got \" + d);\n@@ -94,2 +97,2 @@\n-        logln(\"Date(10 feb 1997) => \" + d);\n-        if (!d.equals(ref)) errln(\"Fail: Want \" + ref + \" Got \" + d);\n+        System.out.println(\"Date(10 feb 1997) => \" + d);\n+        if (!d.equals(ref)) fail(\"Fail: Want \" + ref + \" Got \" + d);\n@@ -101,0 +104,1 @@\n+    @Test\n@@ -113,1 +117,1 @@\n-                errln(\"Fail: Roundtrip toString\/parse\");\n+                fail(\"Fail: Roundtrip toString\/parse\");\n@@ -124,0 +128,1 @@\n+    @Test\n@@ -127,1 +132,1 @@\n-            errln(\"Fail: Want 1\/2\/1984 Got \" + d);\n+            fail(\"Fail: Want 1\/2\/1984 Got \" + d);\n@@ -130,1 +135,1 @@\n-            errln(\"Fail: Want 2\/3\/2012 Got \" + d);\n+            fail(\"Fail: Want 2\/3\/2012 Got \" + d);\n@@ -133,1 +138,1 @@\n-            errln(\"Fail: Want 3\/4\/2015 Got \" + d);\n+            fail(\"Fail: Want 3\/4\/2015 Got \" + d);\n@@ -143,0 +148,1 @@\n+    @Test\n@@ -149,1 +155,1 @@\n-            errln(\"Fail: Want Feb 29, got \" + d);\n+            fail(\"Fail: Want Feb 29, got \" + d);\n@@ -156,0 +162,1 @@\n+    @Test\n@@ -162,1 +169,1 @@\n-            errln(\"Cloned Date objects share state\");\n+            fail(\"Cloned Date objects share state\");\n@@ -171,0 +178,1 @@\n+    @Test\n@@ -175,1 +183,1 @@\n-            errln(\"Fail: Want \" + exp +\n+            fail(\"Fail: Want \" + exp +\n@@ -184,0 +192,1 @@\n+    @Test\n@@ -186,1 +195,1 @@\n-        logln(time.toString());\n+        System.out.println(time.toString());\n@@ -193,0 +202,1 @@\n+    @Test\n@@ -202,3 +212,3 @@\n-            logln(\"JDK time: \" + jdkCal.getTime().getTime() );\n-            logln(\"JDK time (str): \" + jdkCal.getTime() );\n-            logln(\"Day of month: \" + jdkCal.get(Calendar.DAY_OF_MONTH));\n+            System.out.println(\"JDK time: \" + jdkCal.getTime().getTime() );\n+            System.out.println(\"JDK time (str): \" + jdkCal.getTime() );\n+            System.out.println(\"Day of month: \" + jdkCal.get(Calendar.DAY_OF_MONTH));\n@@ -206,1 +216,1 @@\n-            logln(\"Change over (Oct 15 1582) = \" + co + \" (\" +\n+            System.out.println(\"Change over (Oct 15 1582) = \" + co + \" (\" +\n@@ -214,1 +224,1 @@\n-                errln(\"ERROR: \" + a + \" != \" + b);\n+                fail(\"ERROR: \" + a + \" != \" + b);\n@@ -216,1 +226,1 @@\n-                logln(a + \" = \" + b);\n+                System.out.println(a + \" = \" + b);\n@@ -227,0 +237,1 @@\n+    @Test\n@@ -231,1 +242,1 @@\n-            errln(\"yesr: got \" + y + \", expected 292277094\");\n+            fail(\"yesr: got \" + y + \", expected 292277094\");\n@@ -236,1 +247,1 @@\n-            errln(\"yesr: got \" + y + \", expected 292267155\");\n+            fail(\"yesr: got \" + y + \", expected 292267155\");\n","filename":"test\/jdk\/java\/util\/Date\/DateRegression.java","additions":45,"deletions":34,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @library \/java\/text\/testlib\n+ * @run junit DateTest\n@@ -34,0 +34,4 @@\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n@@ -35,1 +39,1 @@\n-public class DateTest extends IntlTest\n+public class DateTest\n@@ -37,4 +41,0 @@\n-    public static void main(String[] args) throws Exception {\n-        new DateTest().run(args);\n-    }\n-\n@@ -45,0 +45,1 @@\n+    @Test\n@@ -60,1 +61,1 @@\n-                errln(\"Fail: Date.setHours()\/getHours() ignoring default zone\");\n+                fail(\"Fail: Date.setHours()\/getHours() ignoring default zone\");\n@@ -69,0 +70,1 @@\n+    @Test\n@@ -90,1 +92,1 @@\n-                logln(pass == 0 ? \"Normal Date object\" : \"Date with Calendar sub-object\");\n+                System.out.println(pass == 0 ? \"Normal Date object\" : \"Date with Calendar sub-object\");\n@@ -99,1 +101,1 @@\n-                    errln(\"FAIL: new Date(\\\"\" + refstr + \"\\\") x GMT -> \" + d +\n+                    fail(\"FAIL: new Date(\\\"\" + refstr + \"\\\") x GMT -> \" + d +\n@@ -107,1 +109,1 @@\n-                        errln(\"FAIL: GMT Expected \" + names[i] + \" of \" + GMT_EXP[i] +\n+                        fail(\"FAIL: GMT Expected \" + names[i] + \" of \" + GMT_EXP[i] +\n@@ -117,1 +119,1 @@\n-                        errln(\"FAIL: PST Expected \" + names[i] + \" of \" + PST_EXP[i] +\n+                        fail(\"FAIL: PST Expected \" + names[i] + \" of \" + PST_EXP[i] +\n@@ -129,0 +131,1 @@\n+    @Test\n@@ -143,1 +146,1 @@\n-        logln(REPS + \" iterations at \" + perLoop + \" ms\/loop\");\n+        System.out.println(REPS + \" iterations at \" + perLoop + \" ms\/loop\");\n@@ -145,1 +148,1 @@\n-            logln(\"WARNING: Date constructor\/getYear slower than \" +\n+            System.out.println(\"WARNING: Date constructor\/getYear slower than \" +\n@@ -153,0 +156,1 @@\n+    @Test\n@@ -167,1 +171,1 @@\n-            errln( \"Expected: \" +\n+            fail( \"Expected: \" +\n@@ -181,0 +185,1 @@\n+    @Test\n@@ -184,1 +189,1 @@\n-        logln(d1.toString());\n+        System.out.println(d1.toString());\n@@ -186,1 +191,1 @@\n-        logln(d1.toString());\n+        System.out.println(d1.toString());\n@@ -190,1 +195,1 @@\n-            logln(d1.toString());\n+            System.out.println(d1.toString());\n@@ -195,2 +200,2 @@\n-        if (e) errln(\"FAIL: Saw exception for year -800000\");\n-        else logln(\"Pass: No exception for year -800000\");\n+        if (e) fail(\"FAIL: Saw exception for year -800000\");\n+        else System.out.println(\"Pass: No exception for year -800000\");\n@@ -200,0 +205,1 @@\n+    @Test\n@@ -206,1 +212,1 @@\n-        logln(\"d       = \"+d1);\n+        System.out.println(\"d       = \"+d1);\n@@ -208,1 +214,1 @@\n-        logln(\"d+20h   = \"+d2);\n+        System.out.println(\"d+20h   = \"+d2);\n@@ -212,1 +218,1 @@\n-        logln(\"delta   = \" + delta + \"h\");\n+        System.out.println(\"delta   = \" + delta + \"h\");\n@@ -214,1 +220,1 @@\n-        if (delta != 20.0) errln(\"Expected delta of 20; got \" + delta);\n+        if (delta != 20.0) fail(\"Expected delta of 20; got \" + delta);\n@@ -220,1 +226,1 @@\n-        logln(\"d       = \"+t1);\n+        System.out.println(\"d       = \"+t1);\n@@ -224,1 +230,1 @@\n-        logln(\"d+20h   = \"+t2);\n+        System.out.println(\"d+20h   = \"+t2);\n@@ -228,1 +234,1 @@\n-        logln(\"delta   = \" + delta2 + \"h\");\n+        System.out.println(\"delta   = \" + delta2 + \"h\");\n@@ -230,1 +236,1 @@\n-        if (delta != 20.0) errln(\"Expected delta of 20; got \" + delta2);\n+        if (delta != 20.0) fail(\"Expected delta of 20; got \" + delta2);\n","filename":"test\/jdk\/java\/util\/Date\/DateTest.java","additions":34,"deletions":28,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @library \/java\/text\/testlib\n+ * @run junit TimestampTest\n@@ -35,1 +35,1 @@\n-public class TimestampTest extends IntlTest {\n+import org.junit.jupiter.api.Test;\n@@ -37,3 +37,3 @@\n-    public static void main(String[] args) throws Exception {\n-        new TimestampTest().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class TimestampTest {\n@@ -46,0 +46,1 @@\n+    @Test\n@@ -91,1 +92,1 @@\n-            errln(\"ts1.after(ts2) returned \" + result\n+            fail(\"ts1.after(ts2) returned \" + result\n@@ -98,1 +99,1 @@\n-            errln(\"ts1.before(ts2) returned \" + result\n+            fail(\"ts1.before(ts2) returned \" + result\n@@ -105,1 +106,1 @@\n-            errln(\"ts1.equals(ts2) returned \" + result\n+            fail(\"ts1.equals(ts2) returned \" + result\n@@ -112,1 +113,1 @@\n-            errln(\"ts1.compareTo(ts2) returned \" + x + \", expected \"\n+            fail(\"ts1.compareTo(ts2) returned \" + x + \", expected \"\n@@ -125,1 +126,1 @@\n-            errln(\"ts1.getTime() \" + relation(z, \"==\") + \" ts2.getTime(), expected \"\n+            fail(\"ts1.getTime() \" + relation(z, \"==\") + \" ts2.getTime(), expected \"\n","filename":"test\/jdk\/java\/util\/Date\/TimestampTest.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,2 @@\n+ * @comment skip running this test on 32 bit VM\n+ * @requires vm.bits == \"64\"\n","filename":"test\/jdk\/java\/util\/HashMap\/WhiteBoxResizeTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4122700 8282319\n+ * @summary Verify implementation of getAvailableLocales() and availableLocales()\n+ * @run junit AvailableLocalesTest\n+ *\/\n+\n+import java.util.Arrays;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.Arguments;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+\n+public class AvailableLocalesTest {\n+\n+    \/**\n+     * Test that Locale.getAvailableLocales() is non-empty and prints out\n+     * the returned locales - 4122700.\n+     *\/\n+    @Test\n+    public void nonEmptyLocalesTest() {\n+        Locale[] systemLocales = Locale.getAvailableLocales();\n+        assertNotEquals(systemLocales.length, 0, \"Available locale list is empty!\");\n+        System.out.println(\"Found \" + systemLocales.length + \" locales:\");\n+        printLocales(systemLocales);\n+    }\n+\n+    \/**\n+     * Test to validate that the methods: Locale.getAvailableLocales()\n+     * and Locale.availableLocales() contain the same underlying elements\n+     *\/\n+    @Test\n+    public void streamEqualsArrayTest() {\n+        Locale[] arrayLocales = Locale.getAvailableLocales();\n+        Stream<Locale> streamedLocales = Locale.availableLocales();\n+        Locale[] convertedLocales = streamedLocales.toArray(Locale[]::new);\n+        if (Arrays.equals(arrayLocales, convertedLocales)) {\n+            System.out.println(\"$$$ Passed: The underlying elements\" +\n+                    \" of getAvailableLocales() and availableLocales() are the same!\");\n+        } else {\n+            throw new RuntimeException(\"$$$ Error: The underlying elements\" +\n+                    \" of getAvailableLocales() and availableLocales()\" +\n+                    \" are not the same.\");\n+        }\n+    }\n+\n+    \/**\n+     * Test to validate that the stream has the required\n+     * Locale.ROOT and Locale.US.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"requiredLocaleProvider\")\n+    public void requiredLocalesTest(Locale requiredLocale, String localeName) {\n+        if (Locale.availableLocales().anyMatch(loc -> (loc.equals(requiredLocale)))) {\n+            System.out.printf(\"$$$ Passed: Stream has %s!%n\", localeName);\n+        } else {\n+            throw new RuntimeException(String.format(\"$$$ Error:\" +\n+                    \" Stream is missing %s!\", localeName));\n+        }\n+    }\n+\n+    \/\/ Helper method to print out all the system locales\n+    private void printLocales(Locale[] systemLocales) {\n+        Locale[] locales = new Locale[systemLocales.length];\n+        for (int i = 0; i < locales.length; i++) {\n+            Locale lowest = null;\n+            for (Locale systemLocale : systemLocales) {\n+                if (i > 0 && locales[i - 1].toString().compareTo(systemLocale.toString()) >= 0)\n+                    continue;\n+                if (lowest == null || systemLocale.toString().compareTo(lowest.toString()) < 0)\n+                    lowest = systemLocale;\n+            }\n+            locales[i] = lowest;\n+        }\n+        for (Locale locale : locales) {\n+            if (locale.getCountry().length() == 0)\n+                System.out.println(\"    \" + locale.getDisplayLanguage() + \":\");\n+            else {\n+                if (locale.getVariant().length() == 0)\n+                    System.out.println(\"        \" + locale.getDisplayCountry());\n+                else\n+                    System.out.println(\"        \" + locale.getDisplayCountry() + \", \"\n+                            + locale.getDisplayVariant());\n+            }\n+        }\n+    }\n+\n+    \/\/ Data provider for testStreamRequirements\n+    private static Stream<Arguments> requiredLocaleProvider() {\n+        return Stream.of(\n+                Arguments.of(Locale.ROOT, \"Root locale\"),\n+                Arguments.of(Locale.US, \"US locale\")\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/AvailableLocalesTest.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -1,291 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary test ISO639-2 language codes\n- * @library \/java\/text\/testlib\n- * @compile -encoding ascii Bug4175998Test.java\n- * @run main Bug4175998Test\n- * @bug 4175998 8303917\n- *\/\n-\n-\/*\n- *\n- *\n- * (C) Copyright IBM Corp. 1998 - All Rights Reserved\n- *\n- * The original version of this source code and documentation is\n- * copyrighted and owned by IBM. These materials are provided\n- * under terms of a License Agreement between IBM and Sun.\n- * This technology is protected by multiple US and International\n- * patents. This notice and attribution to IBM may not be removed.\n- *\n- *\/\n-\n-import java.io.BufferedReader;\n-import java.io.FileReader;\n-import java.util.*;\n-\n-\/**\n- *  Bug4175998Test verifies that the following bug has been fixed:\n- *  Bug 4175998 - The java.util.Locale.getISO3Language() returns wrong result for a locale with\n- *           language code 'ta'(Tamil).\n- *\/\n-public class Bug4175998Test extends IntlTest {\n-    public static void main(String[] args) throws Exception {\n-        new Bug4175998Test().run(args);\n-        \/\/generateTables();    \/\/uncomment this to regenerate data tables\n-    }\n-\n-    public void testIt() throws Exception {\n-        boolean bad = false;\n-        for (final String[] localeCodes : CODES) {\n-            final Locale l = Locale.of(localeCodes[0]);\n-            final String iso3 = l.getISO3Language();\n-            if (!iso3.equals(localeCodes[1])) {\n-                logln(\"Locale(\" + l + \") returned bad ISO3 language code.\"\n-                        + \"   Got '\" + iso3 + \"' instead of '\" + localeCodes[1] + \"'\");\n-                bad = true;\n-            }\n-        }\n-        if (bad) {\n-            errln(\"Bad ISO3 language codes detected.\");\n-        }\n-    }\n-\n-     private static final String[][] CODES = {\n-         {\"aa\",\"aar\",\"aar\"},\n-         {\"ab\",\"abk\",\"abk\"},\n-         {\"af\",\"afr\",\"afr\"},\n-         {\"ak\",\"aka\",\"aka\"},\n-         {\"sq\",\"sqi\",\"alb\"},\n-         {\"am\",\"amh\",\"amh\"},\n-         {\"ar\",\"ara\",\"ara\"},\n-         {\"an\",\"arg\",\"arg\"},\n-         {\"hy\",\"hye\",\"arm\"},\n-         {\"as\",\"asm\",\"asm\"},\n-         {\"av\",\"ava\",\"ava\"},\n-         {\"ae\",\"ave\",\"ave\"},\n-         {\"ay\",\"aym\",\"aym\"},\n-         {\"az\",\"aze\",\"aze\"},\n-         {\"ba\",\"bak\",\"bak\"},\n-         {\"bm\",\"bam\",\"bam\"},\n-         {\"eu\",\"eus\",\"baq\"},\n-         {\"be\",\"bel\",\"bel\"},\n-         {\"bn\",\"ben\",\"ben\"},\n-         {\"bh\",\"bih\",\"bih\"},\n-         {\"bi\",\"bis\",\"bis\"},\n-         {\"bs\",\"bos\",\"bos\"},\n-         {\"br\",\"bre\",\"bre\"},\n-         {\"bg\",\"bul\",\"bul\"},\n-         {\"my\",\"mya\",\"bur\"},\n-         {\"ca\",\"cat\",\"cat\"},\n-         {\"ch\",\"cha\",\"cha\"},\n-         {\"ce\",\"che\",\"che\"},\n-         {\"zh\",\"zho\",\"chi\"},\n-         {\"cu\",\"chu\",\"chu\"},\n-         {\"cv\",\"chv\",\"chv\"},\n-         {\"kw\",\"cor\",\"cor\"},\n-         {\"co\",\"cos\",\"cos\"},\n-         {\"cr\",\"cre\",\"cre\"},\n-         {\"cs\",\"ces\",\"cze\"},\n-         {\"da\",\"dan\",\"dan\"},\n-         {\"dv\",\"div\",\"div\"},\n-         {\"nl\",\"nld\",\"dut\"},\n-         {\"dz\",\"dzo\",\"dzo\"},\n-         {\"en\",\"eng\",\"eng\"},\n-         {\"eo\",\"epo\",\"epo\"},\n-         {\"et\",\"est\",\"est\"},\n-         {\"ee\",\"ewe\",\"ewe\"},\n-         {\"fo\",\"fao\",\"fao\"},\n-         {\"fj\",\"fij\",\"fij\"},\n-         {\"fi\",\"fin\",\"fin\"},\n-         {\"fr\",\"fra\",\"fre\"},\n-         {\"fy\",\"fry\",\"fry\"},\n-         {\"ff\",\"ful\",\"ful\"},\n-         {\"ka\",\"kat\",\"geo\"},\n-         {\"de\",\"deu\",\"ger\"},\n-         {\"gd\",\"gla\",\"gla\"},\n-         {\"ga\",\"gle\",\"gle\"},\n-         {\"gl\",\"glg\",\"glg\"},\n-         {\"gv\",\"glv\",\"glv\"},\n-         {\"el\",\"ell\",\"gre\"},\n-         {\"gn\",\"grn\",\"grn\"},\n-         {\"gu\",\"guj\",\"guj\"},\n-         {\"ht\",\"hat\",\"hat\"},\n-         {\"ha\",\"hau\",\"hau\"},\n-         {\"he\",\"heb\",\"heb\"},\n-         {\"hz\",\"her\",\"her\"},\n-         {\"hi\",\"hin\",\"hin\"},\n-         {\"ho\",\"hmo\",\"hmo\"},\n-         {\"hr\",\"hrv\",\"hrv\"},\n-         {\"hu\",\"hun\",\"hun\"},\n-         {\"ig\",\"ibo\",\"ibo\"},\n-         {\"is\",\"isl\",\"ice\"},\n-         {\"io\",\"ido\",\"ido\"},\n-         {\"ii\",\"iii\",\"iii\"},\n-         {\"iu\",\"iku\",\"iku\"},\n-         {\"ie\",\"ile\",\"ile\"},\n-         {\"ia\",\"ina\",\"ina\"},\n-         {\"id\",\"ind\",\"ind\"},\n-         {\"ik\",\"ipk\",\"ipk\"},\n-         {\"it\",\"ita\",\"ita\"},\n-         {\"jv\",\"jav\",\"jav\"},\n-         {\"ja\",\"jpn\",\"jpn\"},\n-         {\"kl\",\"kal\",\"kal\"},\n-         {\"kn\",\"kan\",\"kan\"},\n-         {\"ks\",\"kas\",\"kas\"},\n-         {\"kr\",\"kau\",\"kau\"},\n-         {\"kk\",\"kaz\",\"kaz\"},\n-         {\"km\",\"khm\",\"khm\"},\n-         {\"ki\",\"kik\",\"kik\"},\n-         {\"rw\",\"kin\",\"kin\"},\n-         {\"ky\",\"kir\",\"kir\"},\n-         {\"kv\",\"kom\",\"kom\"},\n-         {\"kg\",\"kon\",\"kon\"},\n-         {\"ko\",\"kor\",\"kor\"},\n-         {\"kj\",\"kua\",\"kua\"},\n-         {\"ku\",\"kur\",\"kur\"},\n-         {\"lo\",\"lao\",\"lao\"},\n-         {\"la\",\"lat\",\"lat\"},\n-         {\"lv\",\"lav\",\"lav\"},\n-         {\"li\",\"lim\",\"lim\"},\n-         {\"ln\",\"lin\",\"lin\"},\n-         {\"lt\",\"lit\",\"lit\"},\n-         {\"lb\",\"ltz\",\"ltz\"},\n-         {\"lu\",\"lub\",\"lub\"},\n-         {\"lg\",\"lug\",\"lug\"},\n-         {\"mk\",\"mkd\",\"mac\"},\n-         {\"mh\",\"mah\",\"mah\"},\n-         {\"ml\",\"mal\",\"mal\"},\n-         {\"mi\",\"mri\",\"mao\"},\n-         {\"mr\",\"mar\",\"mar\"},\n-         {\"ms\",\"msa\",\"may\"},\n-         {\"mg\",\"mlg\",\"mlg\"},\n-         {\"mt\",\"mlt\",\"mlt\"},\n-         {\"mn\",\"mon\",\"mon\"},\n-         {\"na\",\"nau\",\"nau\"},\n-         {\"nv\",\"nav\",\"nav\"},\n-         {\"nr\",\"nbl\",\"nbl\"},\n-         {\"nd\",\"nde\",\"nde\"},\n-         {\"ng\",\"ndo\",\"ndo\"},\n-         {\"ne\",\"nep\",\"nep\"},\n-         {\"nn\",\"nno\",\"nno\"},\n-         {\"nb\",\"nob\",\"nob\"},\n-         {\"no\",\"nor\",\"nor\"},\n-         {\"ny\",\"nya\",\"nya\"},\n-         {\"oc\",\"oci\",\"oci\"},\n-         {\"oj\",\"oji\",\"oji\"},\n-         {\"or\",\"ori\",\"ori\"},\n-         {\"om\",\"orm\",\"orm\"},\n-         {\"os\",\"oss\",\"oss\"},\n-         {\"pa\",\"pan\",\"pan\"},\n-         {\"fa\",\"fas\",\"per\"},\n-         {\"pi\",\"pli\",\"pli\"},\n-         {\"pl\",\"pol\",\"pol\"},\n-         {\"pt\",\"por\",\"por\"},\n-         {\"ps\",\"pus\",\"pus\"},\n-         {\"qu\",\"que\",\"que\"},\n-         {\"rm\",\"roh\",\"roh\"},\n-         {\"ro\",\"ron\",\"rum\"},\n-         {\"rn\",\"run\",\"run\"},\n-         {\"ru\",\"rus\",\"rus\"},\n-         {\"sg\",\"sag\",\"sag\"},\n-         {\"sa\",\"san\",\"san\"},\n-         {\"si\",\"sin\",\"sin\"},\n-         {\"sk\",\"slk\",\"slo\"},\n-         {\"sl\",\"slv\",\"slv\"},\n-         {\"se\",\"sme\",\"sme\"},\n-         {\"sm\",\"smo\",\"smo\"},\n-         {\"sn\",\"sna\",\"sna\"},\n-         {\"sd\",\"snd\",\"snd\"},\n-         {\"so\",\"som\",\"som\"},\n-         {\"st\",\"sot\",\"sot\"},\n-         {\"es\",\"spa\",\"spa\"},\n-         {\"sc\",\"srd\",\"srd\"},\n-         {\"sr\",\"srp\",\"srp\"},\n-         {\"ss\",\"ssw\",\"ssw\"},\n-         {\"su\",\"sun\",\"sun\"},\n-         {\"sw\",\"swa\",\"swa\"},\n-         {\"sv\",\"swe\",\"swe\"},\n-         {\"ty\",\"tah\",\"tah\"},\n-         {\"ta\",\"tam\",\"tam\"},\n-         {\"tt\",\"tat\",\"tat\"},\n-         {\"te\",\"tel\",\"tel\"},\n-         {\"tg\",\"tgk\",\"tgk\"},\n-         {\"tl\",\"tgl\",\"tgl\"},\n-         {\"th\",\"tha\",\"tha\"},\n-         {\"bo\",\"bod\",\"tib\"},\n-         {\"ti\",\"tir\",\"tir\"},\n-         {\"to\",\"ton\",\"ton\"},\n-         {\"tn\",\"tsn\",\"tsn\"},\n-         {\"ts\",\"tso\",\"tso\"},\n-         {\"tk\",\"tuk\",\"tuk\"},\n-         {\"tr\",\"tur\",\"tur\"},\n-         {\"tw\",\"twi\",\"twi\"},\n-         {\"ug\",\"uig\",\"uig\"},\n-         {\"uk\",\"ukr\",\"ukr\"},\n-         {\"ur\",\"urd\",\"urd\"},\n-         {\"uz\",\"uzb\",\"uzb\"},\n-         {\"ve\",\"ven\",\"ven\"},\n-         {\"vi\",\"vie\",\"vie\"},\n-         {\"vo\",\"vol\",\"vol\"},\n-         {\"cy\",\"cym\",\"wel\"},\n-         {\"wa\",\"wln\",\"wln\"},\n-         {\"wo\",\"wol\",\"wol\"},\n-         {\"xh\",\"xho\",\"xho\"},\n-         {\"yi\",\"yid\",\"yid\"},\n-         {\"yo\",\"yor\",\"yor\"},\n-         {\"za\",\"zha\",\"zha\"},\n-         {\"zu\",\"zul\",\"zul\"},\n-    };\n-\n-    \/\/ The following code was used to generate the table above from the two ISO standards.\n-    private static final String ISO639 = \"ISO-639-2_utf-8.txt\";\n-    private static void generateTables() {\n-        try {\n-            BufferedReader ISO639File = new BufferedReader(new FileReader(ISO639));\n-            for (String line = ISO639File.readLine(); line != null; line = ISO639File.readLine()) {\n-                String[] tokens= line.split(\"\\\\|\");\n-                String iso639_1 = tokens[2];\n-                String iso639_2B = tokens[1];\n-                String iso639_2T = tokens[0];\n-                if (iso639_1.isEmpty()){\n-                    continue; \/\/ Skip if not both a 639-1 and 639-2 code\n-                }\n-                if (iso639_2B.isEmpty()){\n-                    iso639_2B = iso639_2T; \/\/ Default 639\/B to 639\/T if empty\n-                }\n-                System.out.printf(\"\"\"\n-                        {\"%s\",\"%s\",\"%s\"},\n-                        \"\"\", iso639_1, iso639_2B, iso639_2T);\n-            }\n-        } catch (Exception e) {\n-            System.out.println(e);\n-        }\n-    }\n-}\n-\n-\/\/ CODES generated from https:\/\/www.loc.gov\/standards\/iso639-2\/ISO-639-2_utf-8.txt\n-\/\/ on March 9th, 2023.\n","filename":"test\/jdk\/java\/util\/Locale\/Bug4175998Test.java","additions":0,"deletions":291,"binary":false,"changes":291,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/**\n-    @test\n-    @summary Locale variant should not be uppercased\n-    @run main Bug4210525\n-    @bug 4210525\n-*\/\n-\n-import java.util.Locale;\n-\n-public class Bug4210525 {\n-\n-    public static void main(String[] args) throws Exception {\n-        String language = \"en\";\n-        String country = \"US\";\n-        String variant = \"socal\";\n-\n-        Locale aLocale = Locale.of(language, country, variant);\n-\n-        String localeVariant = aLocale.getVariant();\n-        if (localeVariant.equals(variant)) {\n-            System.out.println(\"passed\");\n-        } else {\n-            System.out.println(\"failed\");\n-            throw new Exception(\"Bug4210525 test failed.\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/Locale\/Bug4210525.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/**\n-    @test\n-    @summary Locale constructor should allow language-only argument\n-    @bug 4316602\n-    @author joconner\n-*\/\n-\n-import java.util.Locale;\n-\n-public class Bug4316602 {\n-\n-    public static void main(String[] args) throws Exception {\n-        String language = \"ja\";\n-        Locale aLocale = Locale.of(language);\n-        if (aLocale.toString().equals(language)) {\n-            System.out.println(\"passed\");\n-        } else {\n-            System.out.println(\"Bug4316602 failed\");\n-            throw new Exception(\"Bug4316602 failed\");\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/util\/Locale\/Bug4316602.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8001562\n- * @summary Verify that getAvailableLocales() in locale sensitive services\n- *     classes return compatible set of locales as in JDK7.\n- * @modules jdk.localedata\n- * @run main Bug8001562\n- *\/\n-\n-import java.text.BreakIterator;\n-import java.text.Collator;\n-import java.text.DateFormat;\n-import java.text.DateFormatSymbols;\n-import java.text.DecimalFormatSymbols;\n-import java.text.NumberFormat;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.stream.Collectors;\n-\n-public class Bug8001562 {\n-\n-    static final List<String> jdk7availTags = List.of(\n-            \"ar\", \"ar-AE\", \"ar-BH\", \"ar-DZ\", \"ar-EG\", \"ar-IQ\", \"ar-JO\", \"ar-KW\",\n-            \"ar-LB\", \"ar-LY\", \"ar-MA\", \"ar-OM\", \"ar-QA\", \"ar-SA\", \"ar-SD\", \"ar-SY\",\n-            \"ar-TN\", \"ar-YE\", \"be\", \"be-BY\", \"bg\", \"bg-BG\", \"ca\", \"ca-ES\", \"cs\",\n-            \"cs-CZ\", \"da\", \"da-DK\", \"de\", \"de-AT\", \"de-CH\", \"de-DE\", \"de-LU\", \"el\",\n-            \"el-CY\", \"el-GR\", \"en\", \"en-AU\", \"en-CA\", \"en-GB\", \"en-IE\", \"en-IN\",\n-            \"en-MT\", \"en-NZ\", \"en-PH\", \"en-SG\", \"en-US\", \"en-ZA\", \"es\", \"es-AR\",\n-            \"es-BO\", \"es-CL\", \"es-CO\", \"es-CR\", \"es-DO\", \"es-EC\", \"es-ES\", \"es-GT\",\n-            \"es-HN\", \"es-MX\", \"es-NI\", \"es-PA\", \"es-PE\", \"es-PR\", \"es-PY\", \"es-SV\",\n-            \"es-US\", \"es-UY\", \"es-VE\", \"et\", \"et-EE\", \"fi\", \"fi-FI\", \"fr\", \"fr-BE\",\n-            \"fr-CA\", \"fr-CH\", \"fr-FR\", \"fr-LU\", \"ga\", \"ga-IE\", \"he\", \"he-IL\",\n-            \"hi-IN\", \"hr\", \"hr-HR\", \"hu\", \"hu-HU\", \"id\", \"id-ID\", \"is\", \"is-IS\",\n-            \"it\", \"it-CH\", \"it-IT\", \"ja\", \"ja-JP\",\n-            \"ja-JP-u-ca-japanese-x-lvariant-JP\", \"ko\", \"ko-KR\", \"lt\", \"lt-LT\", \"lv\",\n-            \"lv-LV\", \"mk\", \"mk-MK\", \"ms\", \"ms-MY\", \"mt\", \"mt-MT\", \"nl\", \"nl-BE\",\n-            \"nl-NL\", \"no\", \"no-NO\", \"no-NO-x-lvariant-NY\", \"pl\", \"pl-PL\", \"pt\",\n-            \"pt-BR\", \"pt-PT\", \"ro\", \"ro-RO\", \"ru\", \"ru-RU\", \"sk\", \"sk-SK\", \"sl\",\n-            \"sl-SI\", \"sq\", \"sq-AL\", \"sr\", \"sr-BA\", \"sr-CS\", \"sr-Latn\", \"sr-Latn-BA\",\n-            \"sr-Latn-ME\", \"sr-Latn-RS\", \"sr-ME\", \"sr-RS\", \"sv\", \"sv-SE\", \"th\",\n-            \"th-TH\", \"th-TH-u-nu-thai-x-lvariant-TH\", \"tr\", \"tr-TR\", \"uk\", \"uk-UA\",\n-            \"vi\", \"vi-VN\", \"zh\", \"zh-CN\", \"zh-HK\", \"zh-SG\", \"zh-TW\");\n-    static List<Locale> jdk7availLocs;\n-\n-    static {\n-        jdk7availLocs = jdk7availTags.stream()\n-                .map(Locale::forLanguageTag)\n-                .collect(Collectors.toList());\n-    }\n-\n-    public static void main(String[] args) {\n-        List<Locale> avail = Arrays.asList(BreakIterator.getAvailableLocales());\n-        diffLocale(BreakIterator.class, avail);\n-\n-        avail = Arrays.asList(Collator.getAvailableLocales());\n-        diffLocale(Collator.class, avail);\n-\n-        avail = Arrays.asList(DateFormat.getAvailableLocales());\n-        diffLocale(DateFormat.class, avail);\n-\n-        avail = Arrays.asList(DateFormatSymbols.getAvailableLocales());\n-        diffLocale(DateFormatSymbols.class, avail);\n-\n-        avail = Arrays.asList(DecimalFormatSymbols.getAvailableLocales());\n-        diffLocale(DecimalFormatSymbols.class, avail);\n-\n-        avail = Arrays.asList(NumberFormat.getAvailableLocales());\n-        diffLocale(NumberFormat.class, avail);\n-\n-        avail = Arrays.asList(Locale.getAvailableLocales());\n-        diffLocale(Locale.class, avail);\n-    }\n-\n-    static void diffLocale(Class<?> c, List<Locale> locs) {\n-        String diff = \"\";\n-\n-        System.out.printf(\"Only in target locales (%s.getAvailableLocales()): \", c.getSimpleName());\n-        for (Locale l : locs) {\n-            if (!jdk7availLocs.contains(l)) {\n-                diff += \"\\\"\" + l.toLanguageTag() + \"\\\", \";\n-            }\n-        }\n-        System.out.println(diff);\n-        diff = \"\";\n-\n-        System.out.printf(\"Only in JDK7 (%s.getAvailableLocales()): \", c.getSimpleName());\n-        for (Locale l : jdk7availLocs) {\n-            if (!locs.contains(l)) {\n-                diff += \"\\\"\" + l.toLanguageTag() + \"\\\", \";\n-            }\n-        }\n-        System.out.println(diff);\n-\n-        if (diff.length() > 0) {\n-            throw new RuntimeException(\"Above locale(s) were not included in the target available locales\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/Locale\/Bug8001562.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8004240\n- * @summary Verify that getAdapterPreference returns an unmodifiable list.\n- * @modules java.base\/sun.util.locale.provider\n- * @compile -XDignore.symbol.file Bug8004240.java\n- * @run main Bug8004240\n- *\/\n-\n-import java.util.List;\n-import sun.util.locale.provider.LocaleProviderAdapter;\n-\n-public class Bug8004240 {\n-\n-    public static void main(String[] args) {\n-        List<LocaleProviderAdapter.Type> types = LocaleProviderAdapter.getAdapterPreference();\n-\n-        try {\n-            types.set(0, null);\n-        } catch (UnsupportedOperationException e) {\n-            \/\/ success\n-            return;\n-        }\n-\n-        throw new RuntimeException(\"LocaleProviderAdapter.getAdapterPrefence() returned a modifiable list.\");\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/Locale\/Bug8004240.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8008577 8138613\n- * @summary Check whether CLDR locale provider adapter is enabled by default\n- * @compile -XDignore.symbol.file Bug8008577.java\n- * @modules java.base\/sun.util.locale.provider\n- * @run main Bug8008577\n- *\/\n-\n-import java.util.Arrays;\n-import java.util.List;\n-import sun.util.locale.provider.LocaleProviderAdapter;\n-\n-public class Bug8008577 {\n-\n-    static final LocaleProviderAdapter.Type[] expected = {\n-        LocaleProviderAdapter.Type.CLDR,\n-        LocaleProviderAdapter.Type.JRE,\n-    };\n-\n-    public static void main(String[] args) {\n-        List<LocaleProviderAdapter.Type> types = LocaleProviderAdapter.getAdapterPreference();\n-        List<LocaleProviderAdapter.Type> expectedList = Arrays.asList(expected);\n-        if (!types.equals(expectedList)) {\n-            throw new RuntimeException(\"Default locale provider adapter list is incorrect\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/Locale\/Bug8008577.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8025703\n- * @summary Verify implementation for Locale matching.\n- * @run main Bug8025703\n- *\/\n-\n-import java.util.*;\n-import java.util.Locale.LanguageRange;\n-\n-public class Bug8025703 {\n-\n-    public static void main(String[] args) {\n-        boolean err = false;\n-\n-        String[][] mappings = {{\"ilw\", \"gal\"},\n-                               {\"meg\", \"cir\"},\n-                               {\"pcr\", \"adx\"},\n-                               {\"xia\", \"acn\"},\n-                               {\"yos\", \"zom\"}};\n-\n-        for (int i = 0; i < mappings.length; i++) {\n-            List<LanguageRange> got = LanguageRange.parse(mappings[i][0]);\n-            ArrayList<LanguageRange> expected = new ArrayList<>();\n-            expected.add(new LanguageRange(mappings[i][0], 1.0));\n-            expected.add(new LanguageRange(mappings[i][1], 1.0));\n-\n-            if (!expected.equals(got)) {\n-                err = true;\n-                System.err.println(\"Incorrect language ranges. \");\n-                for (LanguageRange lr : expected) {\n-                    System.err.println(\"  Expected: range=\"\n-                        + lr.getRange() + \", weight=\" + lr.getWeight());\n-                }\n-                for (LanguageRange lr : got) {\n-                    System.err.println(\"  Got:      range=\"\n-                        + lr.getRange() + \", weight=\" + lr.getWeight());\n-                }\n-            }\n-        }\n-\n-        if (err) {\n-            throw new RuntimeException(\"Failed.\");\n-        }\n-    }\n-\n-}\n-\n","filename":"test\/jdk\/java\/util\/Locale\/Bug8025703.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8026766\n- * @summary Confirm that LanguageRange.toString() returns an expected result.\n- * @run main Bug8026766\n- *\/\n-\n-import java.util.Locale.LanguageRange;\n-\n-public class Bug8026766 {\n-\n-    public static void main(String[] args) {\n-        LanguageRange lr1 = new LanguageRange(\"ja\", 1.0);\n-        LanguageRange lr2 = new LanguageRange(\"fr\", 0.0);\n-\n-        if (!lr1.toString().equals(\"ja\") ||\n-            !lr2.toString().equals(\"fr;q=0.0\")) {\n-            throw new RuntimeException(\"LanguageRange.toString() returned an unexpected result.\");\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/util\/Locale\/Bug8026766.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n- * @test\n- * @bug 8032842 8175539\n- * @summary Checks that the filterTags() and lookup() methods\n- *          preserve the case of matching language tag(s).\n- *          Before 8032842 fix these methods return the matching\n- *          language tag(s) in lowercase.\n- *          Also, checks the filterTags() to return only unique\n- *          (ignoring case considerations) matching tags.\n- *\n- *\/\n-\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Locale.FilteringMode;\n-import java.util.Locale.LanguageRange;\n-\n-public class Bug8032842 {\n-\n-    public static void main(String[] args) {\n-\n-        \/\/ test filterBasic() for preserving the case of matching tags for\n-        \/\/ the language range '*', with no duplicates in the matching tags\n-        testFilter(\"*\", List.of(\"de-CH\", \"hi-in\", \"En-GB\", \"ja-Latn-JP\",\n-                \"JA-JP\", \"en-GB\"),\n-                List.of(\"de-CH\", \"hi-in\", \"En-GB\", \"ja-Latn-JP\", \"JA-JP\"),\n-                FilteringMode.AUTOSELECT_FILTERING);\n-\n-        \/\/ test filterBasic() for preserving the case of matching tags for\n-        \/\/ basic ranges other than *, with no duplicates in the matching tags\n-        testFilter(\"mtm-RU, en-GB\", List.of(\"En-Gb\", \"mTm-RU\", \"en-US\",\n-                \"en-latn\", \"en-GB\"),\n-                List.of(\"mTm-RU\", \"En-Gb\"), FilteringMode.AUTOSELECT_FILTERING);\n-\n-        \/\/ test filterExtended() for preserving the case of matching tags for\n-        \/\/ the language range '*', with no duplicates in the matching tags\n-        testFilter(\"*\", List.of(\"de-CH\", \"hi-in\", \"En-GB\", \"hi-IN\",\n-                \"ja-Latn-JP\", \"JA-JP\"),\n-                List.of(\"de-CH\", \"hi-in\", \"En-GB\", \"ja-Latn-JP\", \"JA-JP\"),\n-                FilteringMode.EXTENDED_FILTERING);\n-\n-        \/\/ test filterExtended() for preserving the case of matching tags for\n-        \/\/ extended ranges other than *, with no duplicates in the matching tags\n-        testFilter(\"*-ch;q=0.5, *-Latn;q=0.4\", List.of(\"fr-CH\", \"de-Ch\",\n-                \"en-latn\", \"en-US\", \"en-Latn\"),\n-                List.of(\"fr-CH\", \"de-Ch\", \"en-latn\"),\n-                FilteringMode.EXTENDED_FILTERING);\n-\n-        \/\/ test lookupTag() for preserving the case of matching tag\n-        testLookup(\"*-ch;q=0.5\", List.of(\"en\", \"fR-cH\"), \"fR-cH\");\n-\n-    }\n-\n-    public static void testFilter(String ranges, List<String> tags,\n-            List<String> expected, FilteringMode mode) {\n-        List<LanguageRange> priorityList = LanguageRange.parse(ranges);\n-        List<String> actual = Locale.filterTags(priorityList, tags, mode);\n-        if (!actual.equals(expected)) {\n-            throw new RuntimeException(\"[filterTags() failed for the language\"\n-                    + \" range: \" + ranges + \", Expected: \" + expected\n-                    + \", Found: \" + actual + \"]\");\n-        }\n-    }\n-\n-    public static void testLookup(String ranges, List<String> tags,\n-            String expected) {\n-        List<LanguageRange> priorityList = LanguageRange.parse(ranges);\n-        String actual = Locale.lookupTag(priorityList, tags);\n-        if (!actual.equals(expected)) {\n-            throw new RuntimeException(\"[lookupTag() failed for the language\"\n-                    + \" range: \" + ranges + \", Expected: \" + expected\n-                    + \", Found: \" + actual + \"]\");\n-        }\n-    }\n-\n-}\n-\n","filename":"test\/jdk\/java\/util\/Locale\/Bug8032842.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8154797\n- * @modules java.base\/sun.util.locale.provider\n- *          java.base\/sun.util.resources\n- *          jdk.localedata\n- * @summary Test for checking HourFormat and GmtFormat resources are retrieved from\n- *  COMPAT and CLDR Providers.\n-*\/\n-\n-import java.util.HashMap;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.ResourceBundle;\n-import sun.util.locale.provider.LocaleProviderAdapter.Type;\n-import sun.util.locale.provider.LocaleProviderAdapter;\n-\n-public class Bug8154797 {\n-    static Map<String, String> expectedResourcesMap = new HashMap<>();\n-    static final String GMT_RESOURCE_KEY = \"timezone.gmtFormat\";\n-    static final String HMT_RESOURCE_KEY = \"timezone.hourFormat\";\n-    static final String GMT = \"Gmt\";\n-    static final String HMT = \"Hmt\";\n-\n-    static void generateExpectedValues() {\n-        expectedResourcesMap.put(\"FR\" + GMT, \"UTC{0}\");\n-        expectedResourcesMap.put(\"FR\" + HMT, \"+HH:mm;\\u2212HH:mm\");\n-        expectedResourcesMap.put(\"FI\" + HMT, \"+H.mm;-H.mm\");\n-        expectedResourcesMap.put(\"FI\" + GMT, \"UTC{0}\");\n-        \/* For  root locale, en_US, de_DE, hi_IN, ja_JP,Root locale resources\n-        * should be returned.\n-         *\/\n-        expectedResourcesMap.put(GMT, \"GMT{0}\"); \/\/Root locale resource\n-        expectedResourcesMap.put(HMT, \"+HH:mm;-HH:mm\"); \/\/Root locale resource\n-    }\n-\n-    static void compareResources(Locale loc) {\n-        String mapKeyHourFormat = HMT, mapKeyGmtFormat = GMT;\n-        ResourceBundle compatBundle, cldrBundle;\n-        compatBundle = LocaleProviderAdapter.forJRE().getLocaleResources(loc)\n-                .getJavaTimeFormatData();\n-        cldrBundle = LocaleProviderAdapter.forType(Type.CLDR)\n-                .getLocaleResources(loc).getJavaTimeFormatData();\n-        if (loc.getCountry() == \"FR\" || loc.getCountry() == \"FI\") {\n-            mapKeyHourFormat = loc.getCountry() + HMT;\n-            mapKeyGmtFormat = loc.getCountry() + GMT;\n-        }\n-\n-        if (!(expectedResourcesMap.get(mapKeyGmtFormat)\n-                .equals(compatBundle.getString(GMT_RESOURCE_KEY))\n-                && expectedResourcesMap.get(mapKeyHourFormat)\n-                .equals(compatBundle.getString(HMT_RESOURCE_KEY))\n-                && expectedResourcesMap.get(mapKeyGmtFormat)\n-                .equals(cldrBundle.getString(GMT_RESOURCE_KEY))\n-                && expectedResourcesMap.get(mapKeyHourFormat)\n-                .equals(cldrBundle.getString(HMT_RESOURCE_KEY)))) {\n-\n-            throw new RuntimeException(\"Retrieved resource does not match with \"\n-                    + \"  expected string for Locale \" + compatBundle.getLocale());\n-\n-        }\n-\n-    }\n-\n-    public static void main(String args[]) {\n-        Bug8154797.generateExpectedValues();\n-        Locale[] locArr = {Locale.of(\"hi\", \"IN\"), Locale.UK, Locale.of(\"fi\", \"FI\"),\n-                           Locale.ROOT, Locale.GERMAN, Locale.JAPANESE,\n-                           Locale.ENGLISH, Locale.FRANCE};\n-        for (Locale loc : locArr) {\n-            Bug8154797.compareResources(loc);\n-        }\n-    }\n-\n-}\n-\n","filename":"test\/jdk\/java\/util\/Locale\/Bug8154797.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4210525\n+ * @summary Locale variant should not be case folded\n+ * @run junit CaseCheckVariant\n+ *\/\n+\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CaseCheckVariant {\n+\n+    static final String LANG = \"en\";\n+    static final String COUNTRY = \"US\";\n+\n+    \/**\n+     * When a locale is created with a given variant, ensure\n+     * that the variant is not case normalized.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"variants\")\n+    public void variantCaseTest(String variant) {\n+        Locale aLocale = Locale.of(LANG, COUNTRY, variant);\n+        String localeVariant = aLocale.getVariant();\n+        assertEquals(localeVariant, variant);\n+    }\n+\n+    private static Stream<String> variants() {\n+        return Stream.of(\n+                \"socal\",\n+                \"Norcal\"\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/CaseCheckVariant.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8154797\n+ * @modules java.base\/sun.util.locale.provider\n+ *          java.base\/sun.util.resources\n+ *          jdk.localedata\n+ * @summary Test for checking HourFormat and GmtFormat resources are retrieved from\n+ * COMPAT and CLDR Providers.\n+ * @run junit CompareProviderFormats\n+*\/\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.ResourceBundle;\n+import java.util.stream.Stream;\n+\n+import sun.util.locale.provider.LocaleProviderAdapter.Type;\n+import sun.util.locale.provider.LocaleProviderAdapter;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class CompareProviderFormats {\n+    static Map<String, String> expectedResourcesMap = new HashMap<>();\n+    static final String GMT_RESOURCE_KEY = \"timezone.gmtFormat\";\n+    static final String HMT_RESOURCE_KEY = \"timezone.hourFormat\";\n+    static final String GMT = \"Gmt\";\n+    static final String HMT = \"Hmt\";\n+\n+    \/**\n+     * Fill the expectedResourcesMap with the desired key \/ values\n+     *\/\n+    @BeforeAll\n+    static void populateResourcesMap() {\n+        expectedResourcesMap.put(\"FR\" + GMT, \"UTC{0}\");\n+        expectedResourcesMap.put(\"FR\" + HMT, \"+HH:mm;\\u2212HH:mm\");\n+        expectedResourcesMap.put(\"FI\" + HMT, \"+H.mm;-H.mm\");\n+        expectedResourcesMap.put(\"FI\" + GMT, \"UTC{0}\");\n+        \/* For root locale, en_US, de_DE, hi_IN, ja_JP, Root locale resources\n+         * should be returned.\n+         *\/\n+        expectedResourcesMap.put(GMT, \"GMT{0}\"); \/\/ Root locale resource\n+        expectedResourcesMap.put(HMT, \"+HH:mm;-HH:mm\"); \/\/ Root locale resource\n+    }\n+\n+    \/**\n+     * For each locale, ensure that the returned resources for gmt and hmt match\n+     * the expected resources for both COMPAT and CLDR\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"localeProvider\")\n+    public void compareResourcesTest(Locale loc) {\n+        compareResources(loc);\n+    }\n+\n+    private void compareResources(Locale loc) {\n+        String mapKeyHourFormat = HMT, mapKeyGmtFormat = GMT;\n+        ResourceBundle compatBundle, cldrBundle;\n+        compatBundle = LocaleProviderAdapter.forJRE().getLocaleResources(loc)\n+                .getJavaTimeFormatData();\n+        cldrBundle = LocaleProviderAdapter.forType(Type.CLDR)\n+                .getLocaleResources(loc).getJavaTimeFormatData();\n+\n+        if (loc.getCountry().equals(\"FR\") || loc.getCountry().equals(\"FI\")) {\n+            mapKeyHourFormat = loc.getCountry() + HMT;\n+            mapKeyGmtFormat = loc.getCountry() + GMT;\n+        }\n+\n+        if (!(expectedResourcesMap.get(mapKeyGmtFormat)\n+                .equals(compatBundle.getString(GMT_RESOURCE_KEY))\n+                && expectedResourcesMap.get(mapKeyHourFormat)\n+                .equals(compatBundle.getString(HMT_RESOURCE_KEY))\n+                && expectedResourcesMap.get(mapKeyGmtFormat)\n+                .equals(cldrBundle.getString(GMT_RESOURCE_KEY))\n+                && expectedResourcesMap.get(mapKeyHourFormat)\n+                .equals(cldrBundle.getString(HMT_RESOURCE_KEY)))) {\n+            throw new RuntimeException(\"Retrieved resource does not match with \"\n+                    + \"  expected string for Locale \" + compatBundle.getLocale());\n+        }\n+    }\n+\n+    private static Stream<Locale> localeProvider() {\n+        return Stream.of(\n+                Locale.of(\"hi\", \"IN\"),\n+                Locale.UK, Locale.of(\"fi\", \"FI\"),\n+                Locale.ROOT, Locale.GERMAN, Locale.JAPANESE,\n+                Locale.ENGLISH, Locale.FRANCE\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/CompareProviderFormats.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8008577 8138613\n+ * @summary Check whether CLDR locale provider adapter is enabled by default\n+ * @compile -XDignore.symbol.file ExpectedAdapterTypes.java\n+ * @modules java.base\/sun.util.locale.provider\n+ * @run junit ExpectedAdapterTypes\n+ *\/\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import sun.util.locale.provider.LocaleProviderAdapter;\n+\n+import org.junit.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class ExpectedAdapterTypes {\n+\n+    static final LocaleProviderAdapter.Type[] expected = {\n+        LocaleProviderAdapter.Type.CLDR,\n+        LocaleProviderAdapter.Type.JRE,\n+    };\n+\n+    \/**\n+     * This test ensures LocaleProviderAdapter.getAdapterPreference() returns\n+     * the correct preferred adapter types. This test should fail whenever a change is made\n+     * to the implementation and the expected list is not updated accordingly.\n+     *\/\n+    @Test\n+    public void correctAdapterListTest() {\n+        List<LocaleProviderAdapter.Type> actualTypes = LocaleProviderAdapter.getAdapterPreference();\n+        List<LocaleProviderAdapter.Type> expectedTypes = Arrays.asList(expected);\n+        assertEquals(actualTypes, expectedTypes, String.format(\"getAdapterPreference() \" +\n+                \"returns: %s, but the expected adapter list returns: %s\", actualTypes, expectedTypes));\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/ExpectedAdapterTypes.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8004240\n+ * @summary Verify that getAdapterPreference returns an unmodifiable list.\n+ * @modules java.base\/sun.util.locale.provider\n+ * @compile -XDignore.symbol.file GetAdapterPreference.java\n+ * @run junit GetAdapterPreference\n+ *\/\n+\n+import java.util.List;\n+import sun.util.locale.provider.LocaleProviderAdapter;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class GetAdapterPreference {\n+\n+    \/**\n+     * Test that the list returned from getAdapterPreference()\n+     * cannot be modified.\n+     *\/\n+    @Test\n+    public void immutableTest() {\n+        List<LocaleProviderAdapter.Type> types = LocaleProviderAdapter.getAdapterPreference();\n+        assertThrows(UnsupportedOperationException.class, () -> types.set(0, null),\n+                \"Trying to modify list returned from LocaleProviderAdapter.getAdapterPreference() did not throw UOE\");\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/GetAdapterPreference.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6312358\n+ * @summary Verify that an NPE is thrown by invoking Locale.getInstance() with\n+ * any argument being null.\n+ * @modules java.base\/java.util:open\n+ * @run junit GetInstanceCheck\n+ *\/\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class GetInstanceCheck {\n+\n+    static Method getInstanceMethod;\n+    static final String NAME = \"getInstance\";\n+\n+    \/**\n+     * Initialize the non-public Locale.getInstance() method.\n+     *\/\n+    @BeforeAll\n+    static void initializeMethod() {\n+        try {\n+            \/\/ Locale.getInstance is not directly accessible.\n+            getInstanceMethod = Locale.class.getDeclaredMethod(\n+                    NAME, String.class, String.class, String.class\n+            );\n+            getInstanceMethod.setAccessible(true);\n+        } catch (java.lang.NoSuchMethodException exc) {\n+            \/\/ The test should fail if we can not test the desired method\n+            fail(String.format(\"Tried to get the method '%s' which was not found,\" +\n+                    \" further testing is not possible, failing test\", NAME));\n+        }\n+    }\n+\n+    \/**\n+     * Exists as sanity check that Locale.getInstance() will not throw\n+     * an NPE if no arguments are null.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"passingArguments\")\n+    public void noNPETest(String language, String country, String variant)\n+            throws IllegalAccessException {\n+        try {\n+            getInstanceMethod.invoke(null, language, country, variant);\n+        } catch (InvocationTargetException exc) {\n+            \/\/ Determine underlying exception\n+            Throwable cause = exc.getCause();\n+            if (exc.getCause() instanceof NullPointerException) {\n+                fail(String.format(\"%s should not be thrown when no args are null\", cause));\n+            } else {\n+                fail(String.format(\"%s unexpectedly thrown, when no exception should be thrown\", cause));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Make sure the Locale.getInstance() method throws an NPE\n+     * if any given argument is null.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"failingArguments\")\n+    public void throwNPETest(String language, String country, String variant)\n+            throws IllegalAccessException {\n+        try {\n+            getInstanceMethod.invoke(null, language, country, variant);\n+            fail(\"Should NPE with any argument set to null\");\n+        } catch (InvocationTargetException exc) {\n+            \/\/ Determine underlying exception\n+            Throwable cause = exc.getCause();\n+            if (cause instanceof NullPointerException) {\n+                System.out.println(\"NPE successfully thrown\");\n+            } else {\n+                fail(cause + \" is thrown, when NPE should have been thrown\");\n+            }\n+        }\n+    }\n+\n+    private static Stream<Arguments> passingArguments() {\n+        return Stream.of(\n+                Arguments.of(\"null\", \"GB\", \"\"),\n+                Arguments.of(\"en\", \"null\", \"\"),\n+                Arguments.of(\"en\", \"GB\", \"null\")\n+        );\n+    }\n+\n+    private static Stream<Arguments> failingArguments() {\n+        return Stream.of(\n+                Arguments.of(null, \"GB\", \"\"),\n+                Arguments.of(\"en\", null, \"\"),\n+                Arguments.of(\"en\", \"GB\", null)\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/GetInstanceCheck.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @run junit ISO3166\n@@ -31,0 +32,1 @@\n+\n@@ -38,1 +40,3 @@\n-public class Bug8071929 {\n+import org.junit.jupiter.api.Test;\n+\n+public class ISO3166 {\n@@ -81,1 +85,2 @@\n-    private static void checkISO3166_1_Alpha2ObsoleteCodes() {\n+    @Test\n+    public void checkISO3166_1_Alpha2ObsoleteCodes() {\n@@ -94,1 +99,2 @@\n-    private static void checkISO3166_3Codes() {\n+    @Test\n+    public void checkISO3166_3Codes() {\n@@ -105,1 +111,2 @@\n-    private static void checkISO3166_1_Alpha3Codes() {\n+    @Test\n+    public void checkISO3166_1_Alpha3Codes() {\n@@ -116,1 +123,2 @@\n-    private static void checkISO3166_1_Alpha2Codes() {\n+    @Test\n+    public void checkISO3166_1_Alpha2Codes() {\n@@ -142,7 +150,0 @@\n-\n-    public static void main(String[] args) {\n-        checkISO3166_1_Alpha2ObsoleteCodes();\n-        checkISO3166_1_Alpha2Codes();\n-        checkISO3166_1_Alpha3Codes();\n-        checkISO3166_3Codes();\n-    }\n","filename":"test\/jdk\/java\/util\/Locale\/ISO3166.java","additions":14,"deletions":13,"binary":false,"changes":27,"previous_filename":"test\/jdk\/java\/util\/Locale\/Bug8071929.java","status":"renamed"},{"patch":"@@ -0,0 +1,297 @@\n+\/*\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary test ISO639-2 language codes\n+ * @library \/java\/text\/testlib\n+ * @compile -encoding ascii ISO639.java\n+ * @bug 4175998 8303917\n+ * @run junit ISO639\n+ *\/\n+\n+\/*\n+ *\n+ *\n+ * (C) Copyright IBM Corp. 1998 - All Rights Reserved\n+ *\n+ * The original version of this source code and documentation is\n+ * copyrighted and owned by IBM. These materials are provided\n+ * under terms of a License Agreement between IBM and Sun.\n+ * This technology is protected by multiple US and International\n+ * patents. This notice and attribution to IBM may not be removed.\n+ *\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class ISO639 {\n+\n+    \/**\n+     * This test verifies for a given locale created from the ISO639 2-letter code,\n+     * the correct ISO639 3-letter code is returned when calling getISO3Language().\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"expectedISO639Codes\")\n+    public void ISO3LetterTest(String ISO2, String expectedISO3) {\n+        Locale loc = Locale.of(ISO2);\n+        String actualISO3 = loc.getISO3Language();\n+        assertEquals(actualISO3, expectedISO3,\n+                String.format(\"The Locale '%s' returned a bad ISO3 language code. \" +\n+                        \"Got '%s' instead of '%s'\", loc, actualISO3, expectedISO3));\n+    }\n+\n+    \/\/ expectedISO639Codes generated from https:\/\/www.loc.gov\/standards\/iso639-2\/ISO-639-2_utf-8.txt\n+    \/\/ on March 9th, 2023.\n+    private static Stream<Arguments> expectedISO639Codes() {\n+        return Stream.of(\n+             Arguments.of(\"aa\",\"aar\",\"aar\"),\n+             Arguments.of(\"ab\",\"abk\",\"abk\"),\n+             Arguments.of(\"af\",\"afr\",\"afr\"),\n+             Arguments.of(\"ak\",\"aka\",\"aka\"),\n+             Arguments.of(\"sq\",\"sqi\",\"alb\"),\n+             Arguments.of(\"am\",\"amh\",\"amh\"),\n+             Arguments.of(\"ar\",\"ara\",\"ara\"),\n+             Arguments.of(\"an\",\"arg\",\"arg\"),\n+             Arguments.of(\"hy\",\"hye\",\"arm\"),\n+             Arguments.of(\"as\",\"asm\",\"asm\"),\n+             Arguments.of(\"av\",\"ava\",\"ava\"),\n+             Arguments.of(\"ae\",\"ave\",\"ave\"),\n+             Arguments.of(\"ay\",\"aym\",\"aym\"),\n+             Arguments.of(\"az\",\"aze\",\"aze\"),\n+             Arguments.of(\"ba\",\"bak\",\"bak\"),\n+             Arguments.of(\"bm\",\"bam\",\"bam\"),\n+             Arguments.of(\"eu\",\"eus\",\"baq\"),\n+             Arguments.of(\"be\",\"bel\",\"bel\"),\n+             Arguments.of(\"bn\",\"ben\",\"ben\"),\n+             Arguments.of(\"bh\",\"bih\",\"bih\"),\n+             Arguments.of(\"bi\",\"bis\",\"bis\"),\n+             Arguments.of(\"bs\",\"bos\",\"bos\"),\n+             Arguments.of(\"br\",\"bre\",\"bre\"),\n+             Arguments.of(\"bg\",\"bul\",\"bul\"),\n+             Arguments.of(\"my\",\"mya\",\"bur\"),\n+             Arguments.of(\"ca\",\"cat\",\"cat\"),\n+             Arguments.of(\"ch\",\"cha\",\"cha\"),\n+             Arguments.of(\"ce\",\"che\",\"che\"),\n+             Arguments.of(\"zh\",\"zho\",\"chi\"),\n+             Arguments.of(\"cu\",\"chu\",\"chu\"),\n+             Arguments.of(\"cv\",\"chv\",\"chv\"),\n+             Arguments.of(\"kw\",\"cor\",\"cor\"),\n+             Arguments.of(\"co\",\"cos\",\"cos\"),\n+             Arguments.of(\"cr\",\"cre\",\"cre\"),\n+             Arguments.of(\"cs\",\"ces\",\"cze\"),\n+             Arguments.of(\"da\",\"dan\",\"dan\"),\n+             Arguments.of(\"dv\",\"div\",\"div\"),\n+             Arguments.of(\"nl\",\"nld\",\"dut\"),\n+             Arguments.of(\"dz\",\"dzo\",\"dzo\"),\n+             Arguments.of(\"en\",\"eng\",\"eng\"),\n+             Arguments.of(\"eo\",\"epo\",\"epo\"),\n+             Arguments.of(\"et\",\"est\",\"est\"),\n+             Arguments.of(\"ee\",\"ewe\",\"ewe\"),\n+             Arguments.of(\"fo\",\"fao\",\"fao\"),\n+             Arguments.of(\"fj\",\"fij\",\"fij\"),\n+             Arguments.of(\"fi\",\"fin\",\"fin\"),\n+             Arguments.of(\"fr\",\"fra\",\"fre\"),\n+             Arguments.of(\"fy\",\"fry\",\"fry\"),\n+             Arguments.of(\"ff\",\"ful\",\"ful\"),\n+             Arguments.of(\"ka\",\"kat\",\"geo\"),\n+             Arguments.of(\"de\",\"deu\",\"ger\"),\n+             Arguments.of(\"gd\",\"gla\",\"gla\"),\n+             Arguments.of(\"ga\",\"gle\",\"gle\"),\n+             Arguments.of(\"gl\",\"glg\",\"glg\"),\n+             Arguments.of(\"gv\",\"glv\",\"glv\"),\n+             Arguments.of(\"el\",\"ell\",\"gre\"),\n+             Arguments.of(\"gn\",\"grn\",\"grn\"),\n+             Arguments.of(\"gu\",\"guj\",\"guj\"),\n+             Arguments.of(\"ht\",\"hat\",\"hat\"),\n+             Arguments.of(\"ha\",\"hau\",\"hau\"),\n+             Arguments.of(\"he\",\"heb\",\"heb\"),\n+             Arguments.of(\"hz\",\"her\",\"her\"),\n+             Arguments.of(\"hi\",\"hin\",\"hin\"),\n+             Arguments.of(\"ho\",\"hmo\",\"hmo\"),\n+             Arguments.of(\"hr\",\"hrv\",\"hrv\"),\n+             Arguments.of(\"hu\",\"hun\",\"hun\"),\n+             Arguments.of(\"ig\",\"ibo\",\"ibo\"),\n+             Arguments.of(\"is\",\"isl\",\"ice\"),\n+             Arguments.of(\"io\",\"ido\",\"ido\"),\n+             Arguments.of(\"ii\",\"iii\",\"iii\"),\n+             Arguments.of(\"iu\",\"iku\",\"iku\"),\n+             Arguments.of(\"ie\",\"ile\",\"ile\"),\n+             Arguments.of(\"ia\",\"ina\",\"ina\"),\n+             Arguments.of(\"id\",\"ind\",\"ind\"),\n+             Arguments.of(\"ik\",\"ipk\",\"ipk\"),\n+             Arguments.of(\"it\",\"ita\",\"ita\"),\n+             Arguments.of(\"jv\",\"jav\",\"jav\"),\n+             Arguments.of(\"ja\",\"jpn\",\"jpn\"),\n+             Arguments.of(\"kl\",\"kal\",\"kal\"),\n+             Arguments.of(\"kn\",\"kan\",\"kan\"),\n+             Arguments.of(\"ks\",\"kas\",\"kas\"),\n+             Arguments.of(\"kr\",\"kau\",\"kau\"),\n+             Arguments.of(\"kk\",\"kaz\",\"kaz\"),\n+             Arguments.of(\"km\",\"khm\",\"khm\"),\n+             Arguments.of(\"ki\",\"kik\",\"kik\"),\n+             Arguments.of(\"rw\",\"kin\",\"kin\"),\n+             Arguments.of(\"ky\",\"kir\",\"kir\"),\n+             Arguments.of(\"kv\",\"kom\",\"kom\"),\n+             Arguments.of(\"kg\",\"kon\",\"kon\"),\n+             Arguments.of(\"ko\",\"kor\",\"kor\"),\n+             Arguments.of(\"kj\",\"kua\",\"kua\"),\n+             Arguments.of(\"ku\",\"kur\",\"kur\"),\n+             Arguments.of(\"lo\",\"lao\",\"lao\"),\n+             Arguments.of(\"la\",\"lat\",\"lat\"),\n+             Arguments.of(\"lv\",\"lav\",\"lav\"),\n+             Arguments.of(\"li\",\"lim\",\"lim\"),\n+             Arguments.of(\"ln\",\"lin\",\"lin\"),\n+             Arguments.of(\"lt\",\"lit\",\"lit\"),\n+             Arguments.of(\"lb\",\"ltz\",\"ltz\"),\n+             Arguments.of(\"lu\",\"lub\",\"lub\"),\n+             Arguments.of(\"lg\",\"lug\",\"lug\"),\n+             Arguments.of(\"mk\",\"mkd\",\"mac\"),\n+             Arguments.of(\"mh\",\"mah\",\"mah\"),\n+             Arguments.of(\"ml\",\"mal\",\"mal\"),\n+             Arguments.of(\"mi\",\"mri\",\"mao\"),\n+             Arguments.of(\"mr\",\"mar\",\"mar\"),\n+             Arguments.of(\"ms\",\"msa\",\"may\"),\n+             Arguments.of(\"mg\",\"mlg\",\"mlg\"),\n+             Arguments.of(\"mt\",\"mlt\",\"mlt\"),\n+             Arguments.of(\"mn\",\"mon\",\"mon\"),\n+             Arguments.of(\"na\",\"nau\",\"nau\"),\n+             Arguments.of(\"nv\",\"nav\",\"nav\"),\n+             Arguments.of(\"nr\",\"nbl\",\"nbl\"),\n+             Arguments.of(\"nd\",\"nde\",\"nde\"),\n+             Arguments.of(\"ng\",\"ndo\",\"ndo\"),\n+             Arguments.of(\"ne\",\"nep\",\"nep\"),\n+             Arguments.of(\"nn\",\"nno\",\"nno\"),\n+             Arguments.of(\"nb\",\"nob\",\"nob\"),\n+             Arguments.of(\"no\",\"nor\",\"nor\"),\n+             Arguments.of(\"ny\",\"nya\",\"nya\"),\n+             Arguments.of(\"oc\",\"oci\",\"oci\"),\n+             Arguments.of(\"oj\",\"oji\",\"oji\"),\n+             Arguments.of(\"or\",\"ori\",\"ori\"),\n+             Arguments.of(\"om\",\"orm\",\"orm\"),\n+             Arguments.of(\"os\",\"oss\",\"oss\"),\n+             Arguments.of(\"pa\",\"pan\",\"pan\"),\n+             Arguments.of(\"fa\",\"fas\",\"per\"),\n+             Arguments.of(\"pi\",\"pli\",\"pli\"),\n+             Arguments.of(\"pl\",\"pol\",\"pol\"),\n+             Arguments.of(\"pt\",\"por\",\"por\"),\n+             Arguments.of(\"ps\",\"pus\",\"pus\"),\n+             Arguments.of(\"qu\",\"que\",\"que\"),\n+             Arguments.of(\"rm\",\"roh\",\"roh\"),\n+             Arguments.of(\"ro\",\"ron\",\"rum\"),\n+             Arguments.of(\"rn\",\"run\",\"run\"),\n+             Arguments.of(\"ru\",\"rus\",\"rus\"),\n+             Arguments.of(\"sg\",\"sag\",\"sag\"),\n+             Arguments.of(\"sa\",\"san\",\"san\"),\n+             Arguments.of(\"si\",\"sin\",\"sin\"),\n+             Arguments.of(\"sk\",\"slk\",\"slo\"),\n+             Arguments.of(\"sl\",\"slv\",\"slv\"),\n+             Arguments.of(\"se\",\"sme\",\"sme\"),\n+             Arguments.of(\"sm\",\"smo\",\"smo\"),\n+             Arguments.of(\"sn\",\"sna\",\"sna\"),\n+             Arguments.of(\"sd\",\"snd\",\"snd\"),\n+             Arguments.of(\"so\",\"som\",\"som\"),\n+             Arguments.of(\"st\",\"sot\",\"sot\"),\n+             Arguments.of(\"es\",\"spa\",\"spa\"),\n+             Arguments.of(\"sc\",\"srd\",\"srd\"),\n+             Arguments.of(\"sr\",\"srp\",\"srp\"),\n+             Arguments.of(\"ss\",\"ssw\",\"ssw\"),\n+             Arguments.of(\"su\",\"sun\",\"sun\"),\n+             Arguments.of(\"sw\",\"swa\",\"swa\"),\n+             Arguments.of(\"sv\",\"swe\",\"swe\"),\n+             Arguments.of(\"ty\",\"tah\",\"tah\"),\n+             Arguments.of(\"ta\",\"tam\",\"tam\"),\n+             Arguments.of(\"tt\",\"tat\",\"tat\"),\n+             Arguments.of(\"te\",\"tel\",\"tel\"),\n+             Arguments.of(\"tg\",\"tgk\",\"tgk\"),\n+             Arguments.of(\"tl\",\"tgl\",\"tgl\"),\n+             Arguments.of(\"th\",\"tha\",\"tha\"),\n+             Arguments.of(\"bo\",\"bod\",\"tib\"),\n+             Arguments.of(\"ti\",\"tir\",\"tir\"),\n+             Arguments.of(\"to\",\"ton\",\"ton\"),\n+             Arguments.of(\"tn\",\"tsn\",\"tsn\"),\n+             Arguments.of(\"ts\",\"tso\",\"tso\"),\n+             Arguments.of(\"tk\",\"tuk\",\"tuk\"),\n+             Arguments.of(\"tr\",\"tur\",\"tur\"),\n+             Arguments.of(\"tw\",\"twi\",\"twi\"),\n+             Arguments.of(\"ug\",\"uig\",\"uig\"),\n+             Arguments.of(\"uk\",\"ukr\",\"ukr\"),\n+             Arguments.of(\"ur\",\"urd\",\"urd\"),\n+             Arguments.of(\"uz\",\"uzb\",\"uzb\"),\n+             Arguments.of(\"ve\",\"ven\",\"ven\"),\n+             Arguments.of(\"vi\",\"vie\",\"vie\"),\n+             Arguments.of(\"vo\",\"vol\",\"vol\"),\n+             Arguments.of(\"cy\",\"cym\",\"wel\"),\n+             Arguments.of(\"wa\",\"wln\",\"wln\"),\n+             Arguments.of(\"wo\",\"wol\",\"wol\"),\n+             Arguments.of(\"xh\",\"xho\",\"xho\"),\n+             Arguments.of(\"yi\",\"yid\",\"yid\"),\n+             Arguments.of(\"yo\",\"yor\",\"yor\"),\n+             Arguments.of(\"za\",\"zha\",\"zha\"),\n+             Arguments.of(\"zu\",\"zul\",\"zul\")\n+        );\n+    }\n+\n+    @Test\n+    @Disabled(\"For updating expected ISO data, NOT an actual test\")\n+    public void getISOData() {\n+        \/\/ Remove @Disabled to generate new ISO Data\n+        generateTables();\n+    }\n+\n+    private static final String ISO639 = \"ISO-639-2_utf-8.txt\";\n+    private static void generateTables() {\n+        try {\n+            BufferedReader ISO639File = new BufferedReader(new FileReader(ISO639));\n+            for (String line = ISO639File.readLine(); line != null; line = ISO639File.readLine()) {\n+                String[] tokens= line.split(\"\\\\|\");\n+                String iso639_1 = tokens[2];\n+                String iso639_2B = tokens[1];\n+                String iso639_2T = tokens[0];\n+                if (iso639_1.isEmpty()){\n+                    continue; \/\/ Skip if not both a 639-1 and 639-2 code\n+                }\n+                if (iso639_2B.isEmpty()){\n+                    iso639_2B = iso639_2T; \/\/ Default 639\/B to 639\/T if empty\n+                }\n+                System.out.printf(\"\"\"\n+                        Arguments.of(\"%s\",\"%s\",\"%s\"),\n+                        \"\"\", iso639_1, iso639_2B, iso639_2T);\n+            }\n+        } catch (Exception e) {\n+            System.out.println(e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/ISO639.java","additions":297,"deletions":0,"binary":false,"changes":297,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8001562\n+ * @summary Verify that getAvailableLocales() in locale sensitive services\n+ * classes return compatible set of locales as in JDK7.\n+ * @modules jdk.localedata\n+ * @run junit JDK7LocaleServiceDiffs\n+ *\/\n+\n+import java.text.BreakIterator;\n+import java.text.Collator;\n+import java.text.DateFormat;\n+import java.text.DateFormatSymbols;\n+import java.text.DecimalFormatSymbols;\n+import java.text.NumberFormat;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class JDK7LocaleServiceDiffs {\n+\n+    static final List<String> jdk7availTags = List.of(\n+            \"ar\", \"ar-AE\", \"ar-BH\", \"ar-DZ\", \"ar-EG\", \"ar-IQ\", \"ar-JO\", \"ar-KW\",\n+            \"ar-LB\", \"ar-LY\", \"ar-MA\", \"ar-OM\", \"ar-QA\", \"ar-SA\", \"ar-SD\", \"ar-SY\",\n+            \"ar-TN\", \"ar-YE\", \"be\", \"be-BY\", \"bg\", \"bg-BG\", \"ca\", \"ca-ES\", \"cs\",\n+            \"cs-CZ\", \"da\", \"da-DK\", \"de\", \"de-AT\", \"de-CH\", \"de-DE\", \"de-LU\", \"el\",\n+            \"el-CY\", \"el-GR\", \"en\", \"en-AU\", \"en-CA\", \"en-GB\", \"en-IE\", \"en-IN\",\n+            \"en-MT\", \"en-NZ\", \"en-PH\", \"en-SG\", \"en-US\", \"en-ZA\", \"es\", \"es-AR\",\n+            \"es-BO\", \"es-CL\", \"es-CO\", \"es-CR\", \"es-DO\", \"es-EC\", \"es-ES\", \"es-GT\",\n+            \"es-HN\", \"es-MX\", \"es-NI\", \"es-PA\", \"es-PE\", \"es-PR\", \"es-PY\", \"es-SV\",\n+            \"es-US\", \"es-UY\", \"es-VE\", \"et\", \"et-EE\", \"fi\", \"fi-FI\", \"fr\", \"fr-BE\",\n+            \"fr-CA\", \"fr-CH\", \"fr-FR\", \"fr-LU\", \"ga\", \"ga-IE\", \"he\", \"he-IL\",\n+            \"hi-IN\", \"hr\", \"hr-HR\", \"hu\", \"hu-HU\", \"id\", \"id-ID\", \"is\", \"is-IS\",\n+            \"it\", \"it-CH\", \"it-IT\", \"ja\", \"ja-JP\",\n+            \"ja-JP-u-ca-japanese-x-lvariant-JP\", \"ko\", \"ko-KR\", \"lt\", \"lt-LT\", \"lv\",\n+            \"lv-LV\", \"mk\", \"mk-MK\", \"ms\", \"ms-MY\", \"mt\", \"mt-MT\", \"nl\", \"nl-BE\",\n+            \"nl-NL\", \"no\", \"no-NO\", \"no-NO-x-lvariant-NY\", \"pl\", \"pl-PL\", \"pt\",\n+            \"pt-BR\", \"pt-PT\", \"ro\", \"ro-RO\", \"ru\", \"ru-RU\", \"sk\", \"sk-SK\", \"sl\",\n+            \"sl-SI\", \"sq\", \"sq-AL\", \"sr\", \"sr-BA\", \"sr-CS\", \"sr-Latn\", \"sr-Latn-BA\",\n+            \"sr-Latn-ME\", \"sr-Latn-RS\", \"sr-ME\", \"sr-RS\", \"sv\", \"sv-SE\", \"th\",\n+            \"th-TH\", \"th-TH-u-nu-thai-x-lvariant-TH\", \"tr\", \"tr-TR\", \"uk\", \"uk-UA\",\n+            \"vi\", \"vi-VN\", \"zh\", \"zh-CN\", \"zh-HK\", \"zh-SG\", \"zh-TW\");\n+    static List<Locale> jdk7availLocs;\n+\n+    static {\n+        jdk7availLocs = jdk7availTags.stream()\n+                .map(Locale::forLanguageTag)\n+                .collect(Collectors.toList());\n+    }\n+\n+    \/**\n+     * This test compares the locales returned by getAvailableLocales() from a\n+     * locale sensitive service to the available JDK7 locales. If the locales from\n+     * a locale sensitive service are found to not contain a JDK7 available tag,\n+     * the test will fail.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serviceProvider\")\n+    public void compatibleLocalesTest(Class<?> c, List<Locale> locs) {\n+        diffLocale(c, locs);\n+    }\n+\n+    static void diffLocale(Class<?> c, List<Locale> locs) {\n+        String diff = \"\";\n+\n+        System.out.printf(\"Only in target locales (%s.getAvailableLocales()): \", c.getSimpleName());\n+        for (Locale l : locs) {\n+            if (!jdk7availLocs.contains(l)) {\n+                diff += \"\\\"\" + l.toLanguageTag() + \"\\\", \";\n+            }\n+        }\n+        System.out.println(diff);\n+        diff = \"\";\n+\n+        System.out.printf(\"Only in JDK7 (%s.getAvailableLocales()): \", c.getSimpleName());\n+        for (Locale l : jdk7availLocs) {\n+            if (!locs.contains(l)) {\n+                diff += \"\\\"\" + l.toLanguageTag() + \"\\\", \";\n+            }\n+        }\n+        System.out.println(diff);\n+\n+        if (diff.length() > 0) {\n+            throw new RuntimeException(\"Above locale(s) were not included in the target available locales\");\n+        }\n+    }\n+\n+    private static Stream<Arguments> serviceProvider() {\n+        return Stream.of(\n+                Arguments.of(BreakIterator.class, Arrays.asList(BreakIterator.getAvailableLocales())),\n+                Arguments.of(Collator.class, Arrays.asList(Collator.getAvailableLocales())),\n+                Arguments.of(DateFormat.class, Arrays.asList(DateFormat.getAvailableLocales())),\n+                Arguments.of(DateFormatSymbols.class, Arrays.asList(DateFormatSymbols.getAvailableLocales())),\n+                Arguments.of(DecimalFormatSymbols.class, Arrays.asList(DecimalFormatSymbols.getAvailableLocales())),\n+                Arguments.of(NumberFormat.class, Arrays.asList(NumberFormat.getAvailableLocales())),\n+                Arguments.of(Locale.class, Arrays.asList(Locale.getAvailableLocales()))\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/JDK7LocaleServiceDiffs.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8026766\n+ * @summary Confirm that LanguageRange.toString() returns an expected result.\n+ * @run junit LRToString\n+ *\/\n+\n+import java.util.Locale.LanguageRange;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class LRToString {\n+\n+    \/**\n+     * This test ensures that the output of LanguageRange.toString()\n+     * returns an expected result, that is, the weight is hidden if it is\n+     * equal to 1.0.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"ranges\")\n+    public void toStringTest(String range, double weight) {\n+        LanguageRange lr = new LanguageRange(range, weight);\n+        String expected = weight == 1.0\n+                ? range\n+                : range+\";q=\"+weight;\n+        assertEquals(lr.toString(), expected);\n+    }\n+\n+    private static Stream<Arguments> ranges() {\n+        return Stream.of(\n+                Arguments.of(\"ja\", 1.0),\n+                Arguments.of(\"de\", 0.5),\n+                Arguments.of(\"fr\", 0.0)\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/LRToString.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8040211 8191404 8203872 8222980 8225435 8241082 8242010 8247432\n+ * @bug 8025703 8040211 8191404 8203872 8222980 8225435 8241082 8242010 8247432\n@@ -48,3 +48,3 @@\n-        + \" en-gb-oed, gti, iba, jks, kdz, kjh, kmb, koj, kru, ksp, kwq, kxe, kzk, lgs, lii, lmm, lsb, lsc, lsn, lsv, lsw, lvi, mtm,\"\n-        + \" ngv, nns, ola, oyb, pat, phr, plu, pnd, pub, rib, rnb, rsn, scv, snz, sqx, suj, szy, taj, tdg, tjj, tjp, tpn, tvx,\"\n-        + \" umi, uss, uth, ysm, zko, wkr;q=0.9, ar-hyw;q=0.8, yug;q=0.5, gfx;q=0.4\";\n+        + \" en-gb-oed, gti, iba, ilw, jks, kdz, kjh, kmb, koj, kru, ksp, kwq, kxe, kzk, lgs, lii, lmm, lsb, lsc, lsn, lsv, lsw, lvi, meg, mtm,\"\n+        + \" ngv, nns, ola, oyb, pat, pcr, phr, plu, pnd, pub, rib, rnb, rsn, scv, snz, sqx, suj, szy, taj, tdg, tjj, tjp, tpn, tvx,\"\n+        + \" umi, uss, uth, xia, yos, ysm, zko, wkr;q=0.9, ar-hyw;q=0.8, yug;q=0.5, gfx;q=0.4\";\n@@ -105,0 +105,2 @@\n+            new LanguageRange(\"ilw\", 1.0),\n+            new LanguageRange(\"gal\", 1.0),\n@@ -143,0 +145,2 @@\n+            new LanguageRange(\"meg\", 1.0),\n+            new LanguageRange(\"cir\", 1.0),\n@@ -157,0 +161,2 @@\n+            new LanguageRange(\"pcr\", 1.0),\n+            new LanguageRange(\"adx\", 1.0),\n@@ -191,0 +197,4 @@\n+            new LanguageRange(\"xia\", 1.0),\n+            new LanguageRange(\"acn\", 1.0),\n+            new LanguageRange(\"yos\", 1.0),\n+            new LanguageRange(\"zom\", 1.0),\n","filename":"test\/jdk\/java\/util\/Locale\/LanguageSubtagRegistryTest.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -23,0 +23,1 @@\n+\n@@ -24,6 +25,6 @@\n-    @test\n-    @bug 4184873\n-    @summary test that locale invariants are preserved across serialization\n-    @library \/java\/text\/testlib\n-    @run main LegacyCodesClassInvariant\n-*\/\n+ * @test\n+ * @bug 4184873\n+ * @summary test that locale invariants are preserved across serialization.\n+ * @run junit LegacyCodesClassInvariant\n+ *\/\n+\n@@ -66,1 +67,0 @@\n-import java.io.FileOutputStream;\n@@ -68,1 +68,0 @@\n-import java.io.ObjectOutputStream;\n@@ -71,0 +70,5 @@\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n@@ -74,9 +78,2 @@\n-public class LegacyCodesClassInvariant extends IntlTest {\n-    public static void main(String[] args) throws Exception {\n-        if (args.length == 1 && args[0].equals(\"prepTest\")) {\n-            prepTest();\n-        } else {\n-            new LegacyCodesClassInvariant().run(args);\n-        }\n-    }\n-\n+public class LegacyCodesClassInvariant {\n+    @Test\n@@ -95,7 +92,2 @@\n-                if (!(expected.equals(loc))) {\n-                    errln(\"Locale didn't maintain invariants for: \"+lang);\n-                    errln(\"         got: \"+loc);\n-                    errln(\"    excpeted: \"+expected);\n-                } else {\n-                    logln(\"Locale \"+lang+\" worked\");\n-                }\n+                assertEquals(expected, loc,\n+                        \"Locale didn't maintain invariants for: \"+lang);\n@@ -105,1 +97,1 @@\n-            errln(e.toString());\n+            fail(e.toString());\n@@ -114,1 +106,1 @@\n-            errln(e.toString());\n+            fail(e.toString());\n@@ -118,22 +110,0 @@\n-\n-    \/**\n-     * Create serialized output files of the test locales.  After they are created, these test\n-     * files should be corrupted (by hand) to contain invalid locale name values.\n-     *\/\n-    private static void prepTest() {\n-        outputLocale(\"he\");\n-        outputLocale(\"yi\");\n-        outputLocale(\"id\");\n-    }\n-\n-    private static void outputLocale(String lang) {\n-        try {\n-            ObjectOutputStream out = new ObjectOutputStream(\n-                    new FileOutputStream(\"LegacyCodesClassInvariant_\"+lang));\n-            out.writeObject(Locale.of(lang, \"XX\"));\n-            out.close();\n-        } catch (Exception e) {\n-            System.out.println(e);\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/util\/Locale\/LegacyCodesClassInvariant.java","additions":18,"deletions":48,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4316602\n+ * @author joconner\n+ * @summary Verify all Locale constructors and of() methods\n+ * @run junit LocaleConstructors\n+ *\/\n+\n+import java.util.Locale;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\/**\n+ * This class tests to ensure that the language, language\/country, and\n+ * language\/country\/variant Locale constructors + of() method are all allowed.\n+ *\/\n+public class LocaleConstructors {\n+\n+    static final String LANG = \"en\";\n+    static final String COUNTRY = \"US\";\n+    static final String VAR = \"socal\";\n+\n+    \/\/ Test Locale constructor and .of() allow (language) argument(s)\n+    @Test\n+    public void langTest() {\n+        Locale aLocale = Locale.of(LANG);\n+        Locale otherLocale = new Locale(LANG);\n+        assertEquals(aLocale.toString(), LANG);\n+        assertEquals(otherLocale.toString(), LANG);\n+    }\n+\n+    \/\/ Test Locale constructor and .of() allow (language, constructor) argument(s)\n+    @Test\n+    public void langCountryTest() {\n+        Locale aLocale = Locale.of(LANG, COUNTRY);\n+        Locale otherLocale = new Locale(LANG, COUNTRY);\n+        assertEquals(aLocale.toString(), String.format(\"%s_%s\",\n+                LANG, COUNTRY));\n+        assertEquals(otherLocale.toString(), String.format(\"%s_%s\",\n+                LANG, COUNTRY));\n+    }\n+\n+    \/\/ Test Locale constructor and .of() allow\n+    \/\/ (language, constructor, variant) argument(s)\n+    @Test\n+    public void langCountryVariantTest() {\n+        Locale aLocale = Locale.of(LANG, COUNTRY, VAR);\n+        Locale otherLocale = new Locale(LANG, COUNTRY, VAR);\n+        assertEquals(aLocale.toString(), String.format(\"%s_%s_%s\",\n+                LANG, COUNTRY, VAR));\n+        assertEquals(otherLocale.toString(), String.format(\"%s_%s_%s\",\n+                LANG, COUNTRY, VAR));\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/LocaleConstructors.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,4 @@\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n@@ -49,1 +53,0 @@\n- * @library \/java\/text\/testlib\n@@ -52,1 +55,1 @@\n- * @run main\/othervm -Djava.locale.providers=JRE,SPI -esa LocaleEnhanceTest\n+ * @run junit\/othervm -Djava.locale.providers=JRE,SPI -esa LocaleEnhanceTest\n@@ -54,8 +57,1 @@\n-public class LocaleEnhanceTest extends IntlTest {\n-\n-    public static void main(String[] args) throws Exception {\n-        List<String> argList = new ArrayList<String>();\n-        argList.addAll(Arrays.asList(args));\n-        argList.add(\"-nothrow\");\n-        new LocaleEnhanceTest().run(argList.toArray(new String[argList.size()]));\n-    }\n+public class LocaleEnhanceTest {\n@@ -86,0 +82,1 @@\n+    @Test\n@@ -134,1 +131,1 @@\n-                errln(msg + e.getMessage());\n+                fail(msg + e.getMessage());\n@@ -149,0 +146,1 @@\n+    @Test\n@@ -191,1 +189,1 @@\n-                errln(msg + e.getMessage());\n+                fail(msg + e.getMessage());\n@@ -200,0 +198,1 @@\n+    @Test\n@@ -243,0 +242,1 @@\n+    @Test\n@@ -269,0 +269,1 @@\n+    @Test\n@@ -285,0 +286,1 @@\n+    @Test\n@@ -323,0 +325,1 @@\n+    @Test\n@@ -337,0 +340,1 @@\n+    @Test\n@@ -357,0 +361,1 @@\n+    @Test\n@@ -366,1 +371,1 @@\n-            errln(\"expected exception on add to extension key set\");\n+            fail(\"expected exception on add to extension key set\");\n@@ -377,0 +382,1 @@\n+    @Test\n@@ -389,0 +395,1 @@\n+    @Test\n@@ -416,0 +423,1 @@\n+    @Test\n@@ -425,1 +433,1 @@\n-            errln(\"expected exception when add to locale key set\");\n+            fail(\"expected exception when add to locale key set\");\n@@ -432,0 +440,1 @@\n+    @Test\n@@ -440,0 +449,1 @@\n+    @Test\n@@ -505,0 +515,1 @@\n+    @Test\n@@ -592,1 +603,1 @@\n-                errln(msg + \" caught exception: \" + e);\n+                fail(msg + \" caught exception: \" + e);\n@@ -610,0 +621,1 @@\n+    @Test\n@@ -627,0 +639,1 @@\n+    @Test\n@@ -638,0 +651,1 @@\n+    @Test\n@@ -691,0 +705,1 @@\n+    @Test\n@@ -733,0 +748,1 @@\n+    @Test\n@@ -750,0 +766,1 @@\n+    @Test\n@@ -795,0 +812,1 @@\n+    @Test\n@@ -831,0 +849,1 @@\n+    @Test\n@@ -868,0 +887,1 @@\n+    @Test\n@@ -920,0 +940,1 @@\n+    @Test\n@@ -1010,0 +1031,1 @@\n+    @Test\n@@ -1041,0 +1063,1 @@\n+    @Test\n@@ -1084,0 +1107,1 @@\n+    @Test\n@@ -1099,0 +1123,1 @@\n+    @Test\n@@ -1111,0 +1136,1 @@\n+    @Test\n@@ -1115,0 +1141,1 @@\n+    @Test\n@@ -1119,0 +1146,1 @@\n+    @Test\n@@ -1164,1 +1192,1 @@\n-                errln(locale + \" encountered exception:\" + e.getLocalizedMessage());\n+                fail(locale + \" encountered exception:\" + e.getLocalizedMessage());\n@@ -1169,0 +1197,1 @@\n+    @Test\n@@ -1187,1 +1216,1 @@\n-            errln(\"'dataDir' is null. serialized.data.dir Property value is \"+dataDirName);\n+            fail(\"'dataDir' is null. serialized.data.dir Property value is \"+dataDirName);\n@@ -1190,1 +1219,1 @@\n-            errln(\"'dataDir' is not a directory. dataDir: \"+dataDir.toString());\n+            fail(\"'dataDir' is not a directory. dataDir: \"+dataDir.toString());\n@@ -1222,1 +1251,1 @@\n-                errln(\"Exception while reading \" + testfile.getAbsolutePath() + \" - \" + e.getMessage());\n+                fail(\"Exception while reading \" + testfile.getAbsolutePath() + \" - \" + e.getMessage());\n@@ -1227,0 +1256,1 @@\n+    @Test\n@@ -1270,0 +1300,1 @@\n+    @Test\n@@ -1289,0 +1320,1 @@\n+    @Test\n@@ -1321,1 +1353,1 @@\n-            errln(msg + \": expected true\");\n+            fail(msg + \": expected true\");\n@@ -1327,1 +1359,1 @@\n-            errln(msg + \": expected false\");\n+            fail(msg + \": expected false\");\n@@ -1339,1 +1371,1 @@\n-            errln(msg + \": expected \" + e + \" but got \" + v);\n+            fail(msg + \": expected \" + e + \" but got \" + v);\n@@ -1348,1 +1380,1 @@\n-            errln(msg + \": expected not equal \" + e);\n+            fail(msg + \": expected not equal \" + e);\n@@ -1354,1 +1386,1 @@\n-            errln(msg + \": expected null but got '\" + o + \"'\");\n+            fail(msg + \": expected null but got '\" + o + \"'\");\n@@ -1360,1 +1392,1 @@\n-            errln(msg + \": expected non null\");\n+            fail(msg + \": expected non null\");\n@@ -1386,1 +1418,1 @@\n-                errln(msg + failMsg);\n+                fail(msg + failMsg);\n","filename":"test\/jdk\/java\/util\/Locale\/LocaleEnhanceTest.java","additions":59,"deletions":27,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @library \/java\/text\/testlib\n@@ -32,2 +31,2 @@\n- * @run main\/othervm -Djava.locale.providers=COMPAT,SPI LocaleTest\n- * @run main\/othervm -Djava.locale.providers=COMPAT,SPI -Djava.locale.useOldISOCodes=true LocaleTest\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT,SPI LocaleTest\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT,SPI -Djava.locale.useOldISOCodes=true LocaleTest\n@@ -89,1 +88,5 @@\n-public class LocaleTest extends IntlTest {\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class LocaleTest {\n@@ -194,4 +197,1 @@\n-    public static void main(String[] args) throws Exception {\n-        new LocaleTest().run(args);\n-    }\n-\n+    @Test\n@@ -201,1 +201,1 @@\n-            logln(\"Testing \" + testLocale + \"...\");\n+            System.out.println(\"Testing \" + testLocale + \"...\");\n@@ -204,1 +204,1 @@\n-                errln(\"  Language code mismatch: \" + testLocale.getLanguage() + \" versus \"\n+                fail(\"  Language code mismatch: \" + testLocale.getLanguage() + \" versus \"\n@@ -208,1 +208,1 @@\n-                errln(\"  Country code mismatch: \" + testLocale.getCountry() + \" versus \"\n+                fail(\"  Country code mismatch: \" + testLocale.getCountry() + \" versus \"\n@@ -212,1 +212,1 @@\n-                errln(\"  Variant code mismatch: \" + testLocale.getVariant() + \" versus \"\n+                fail(\"  Variant code mismatch: \" + testLocale.getVariant() + \" versus \"\n@@ -216,1 +216,1 @@\n-                errln(\"  Locale name mismatch: \" + testLocale.toString() + \" versus \"\n+                fail(\"  Locale name mismatch: \" + testLocale.toString() + \" versus \"\n@@ -221,1 +221,1 @@\n-        logln(\"Same thing without variant codes...\");\n+        System.out.println(\"Same thing without variant codes...\");\n@@ -224,1 +224,1 @@\n-            logln(\"Testing \" + testLocale + \"...\");\n+            System.out.println(\"Testing \" + testLocale + \"...\");\n@@ -227,1 +227,1 @@\n-                errln(\"  Language code mismatch: \" + testLocale.getLanguage() + \" versus \"\n+                fail(\"  Language code mismatch: \" + testLocale.getLanguage() + \" versus \"\n@@ -231,1 +231,1 @@\n-                errln(\"  Country code mismatch: \" + testLocale.getCountry() + \" versus \"\n+                fail(\"  Country code mismatch: \" + testLocale.getCountry() + \" versus \"\n@@ -235,1 +235,1 @@\n-                errln(\"  Variant code mismatch: \" + testLocale.getVariant() + \" versus \\\"\\\"\");\n+                fail(\"  Variant code mismatch: \" + testLocale.getVariant() + \" versus \\\"\\\"\");\n@@ -240,0 +240,1 @@\n+    @Test\n@@ -247,1 +248,1 @@\n-            logln(\"Testing \" + testLocale + \"...\");\n+            System.out.println(\"Testing \" + testLocale + \"...\");\n@@ -250,1 +251,1 @@\n-                errln(\"  ISO-3 language code mismatch: \" + testLocale.getISO3Language()\n+                fail(\"  ISO-3 language code mismatch: \" + testLocale.getISO3Language()\n@@ -254,1 +255,1 @@\n-                errln(\"  ISO-3 country code mismatch: \" + testLocale.getISO3Country()\n+                fail(\"  ISO-3 country code mismatch: \" + testLocale.getISO3Country()\n@@ -260,1 +261,1 @@\n-                errln(\"  LCID mismatch: \" + testLocale.getLCID() + \" versus \"\n+                fail(\"  LCID mismatch: \" + testLocale.getLCID() + \" versus \"\n@@ -272,0 +273,1 @@\n+    @Test\n@@ -280,2 +282,2 @@\n-        logln(\"With default = en_US...\");\n-        logln(\"  In default locale...\");\n+        System.out.println(\"With default = en_US...\");\n+        System.out.println(\"  In default locale...\");\n@@ -283,1 +285,1 @@\n-        logln(\"  In locale = en_US...\");\n+        System.out.println(\"  In locale = en_US...\");\n@@ -285,1 +287,1 @@\n-        logln(\"  In locale = fr_FR...\");\n+        System.out.println(\"  In locale = fr_FR...\");\n@@ -287,1 +289,1 @@\n-        logln(\"  In locale = hr_HR...\");\n+        System.out.println(\"  In locale = hr_HR...\");\n@@ -289,1 +291,1 @@\n-        logln(\"  In locale = el_GR...\");\n+        System.out.println(\"  In locale = el_GR...\");\n@@ -293,2 +295,2 @@\n-        logln(\"With default = fr_FR...\");\n-        logln(\"  In default locale...\");\n+        System.out.println(\"With default = fr_FR...\");\n+        System.out.println(\"  In default locale...\");\n@@ -296,1 +298,1 @@\n-        logln(\"  In locale = en_US...\");\n+        System.out.println(\"  In locale = en_US...\");\n@@ -298,1 +300,1 @@\n-        logln(\"  In locale = fr_FR...\");\n+        System.out.println(\"  In locale = fr_FR...\");\n@@ -300,1 +302,1 @@\n-        logln(\"  In locale = hr_HR...\");\n+        System.out.println(\"  In locale = hr_HR...\");\n@@ -302,1 +304,1 @@\n-        logln(\"  In locale = el_GR...\");\n+        System.out.println(\"  In locale = el_GR...\");\n@@ -312,1 +314,1 @@\n-            errln(\"Default locale should be French, but it's really \" + language);\n+            fail(\"Default locale should be French, but it's really \" + language);\n@@ -314,1 +316,1 @@\n-            errln(\"Default locale should be English, but it's really \" + language);\n+            fail(\"Default locale should be English, but it's really \" + language);\n@@ -319,1 +321,1 @@\n-            logln(\"  Testing \" + testLocale + \"...\");\n+            System.out.println(\"  Testing \" + testLocale + \"...\");\n@@ -376,1 +378,1 @@\n-                errln(\"Display language mismatch: \" + testLang + \" versus \" + expectedLang);\n+                fail(\"Display language mismatch: \" + testLang + \" versus \" + expectedLang);\n@@ -379,1 +381,1 @@\n-                errln(\"Display country mismatch: \" + testCtry + \" versus \" + expectedCtry);\n+                fail(\"Display country mismatch: \" + testCtry + \" versus \" + expectedCtry);\n@@ -382,1 +384,1 @@\n-                errln(\"Display variant mismatch: \" + testVar + \" versus \" + expectedVar);\n+                fail(\"Display variant mismatch: \" + testVar + \" versus \" + expectedVar);\n@@ -385,1 +387,1 @@\n-                errln(\"Display name mismatch: \" + testName + \" versus \" + expectedName);\n+                fail(\"Display name mismatch: \" + testName + \" versus \" + expectedName);\n@@ -391,0 +393,1 @@\n+    @Test\n@@ -398,1 +401,1 @@\n-            errln(\"Some of the test variables point to the same locale!\");\n+            fail(\"Some of the test variables point to the same locale!\");\n@@ -402,1 +405,1 @@\n-            errln(\"clone() failed to produce a valid object!\");\n+            fail(\"clone() failed to produce a valid object!\");\n@@ -406,1 +409,1 @@\n-            errln(\"clone() or equals() failed: objects that should compare equal don't\");\n+            fail(\"clone() or equals() failed: objects that should compare equal don't\");\n@@ -410,1 +413,1 @@\n-            errln(\"equals() failed: objects that shouldn't compare equal do\");\n+            fail(\"equals() failed: objects that shouldn't compare equal do\");\n@@ -418,1 +421,1 @@\n-            errln(\"hashCode() failed: objects that should have the same hash code don't\");\n+            fail(\"hashCode() failed: objects that should have the same hash code don't\");\n@@ -425,0 +428,1 @@\n+    @Test\n@@ -436,1 +440,1 @@\n-            errln(\"getISO3Language() on xx_YY returned \" + result + \" instead of throwing an exception\");\n+            fail(\"getISO3Language() on xx_YY returned \" + result + \" instead of throwing an exception\");\n@@ -446,1 +450,1 @@\n-            errln(\"getISO3Country() on xx_YY returned \" + result + \" instead of throwing an exception\");\n+            fail(\"getISO3Country() on xx_YY returned \" + result + \" instead of throwing an exception\");\n@@ -453,0 +457,1 @@\n+    @Test\n@@ -467,1 +472,1 @@\n-            errln(\"Expected getISOLanguages() to return 188 languages; it returned \" + test.length);\n+            fail(\"Expected getISOLanguages() to return 188 languages; it returned \" + test.length);\n@@ -477,1 +482,1 @@\n-                    errln(\"Couldn't find \" + spotCheck1[i] + \" in language list.\");\n+                    fail(\"Couldn't find \" + spotCheck1[i] + \" in language list.\");\n@@ -483,1 +488,1 @@\n-                errln(test[i] + \" is not all lower case.\");\n+                fail(test[i] + \" is not all lower case.\");\n@@ -486,1 +491,1 @@\n-                errln(test[i] + \" is not two characters long.\");\n+                fail(test[i] + \" is not two characters long.\");\n@@ -489,1 +494,1 @@\n-                errln(test[i] + \" appears in an out-of-order position in the list.\");\n+                fail(test[i] + \" appears in an out-of-order position in the list.\");\n@@ -498,1 +503,1 @@\n-            errln(\"Expected getISOCountries to return 249 countries; it returned \" + test.length);\n+            fail(\"Expected getISOCountries to return 249 countries; it returned \" + test.length);\n@@ -508,1 +513,1 @@\n-                    errln(\"Couldn't find \" + spotCheck2[i] + \" in country list.\");\n+                    fail(\"Couldn't find \" + spotCheck2[i] + \" in country list.\");\n@@ -514,1 +519,1 @@\n-                errln(test[i] + \" is not all upper case.\");\n+                fail(test[i] + \" is not all upper case.\");\n@@ -517,1 +522,1 @@\n-                errln(test[i] + \" is not two characters long.\");\n+                fail(test[i] + \" is not two characters long.\");\n@@ -520,1 +525,1 @@\n-                errln(test[i] + \" appears in an out-of-order position in the list.\");\n+                fail(test[i] + \" appears in an out-of-order position in the list.\");\n@@ -535,1 +540,1 @@\n-            errln(\"Changed internal country code list!\");\n+            fail(\"Changed internal country code list!\");\n@@ -542,1 +547,1 @@\n-            errln(\"Changes internal language code list!\");\n+            fail(\"Changes internal language code list!\");\n@@ -549,0 +554,1 @@\n+    @Test\n@@ -552,1 +558,1 @@\n-            errln(\"Locale.getAvailableLocales() returned no installed locales!\");\n+            fail(\"Locale.getAvailableLocales() returned no installed locales!\");\n@@ -554,1 +560,1 @@\n-            logln(\"Locale.getAvailableLocales() returned a list of \" + locales.length + \" locales.\");\n+            System.out.println(\"Locale.getAvailableLocales() returned a list of \" + locales.length + \" locales.\");\n@@ -556,1 +562,1 @@\n-                logln(locales[i].toString());\n+                System.out.println(locales[i].toString());\n@@ -564,0 +570,1 @@\n+    @Test\n@@ -568,1 +575,1 @@\n-            errln(\"Locale.getAvailableLocales() doesn't clone its internal storage!\");\n+            fail(\"Locale.getAvailableLocales() doesn't clone its internal storage!\");\n@@ -577,0 +584,1 @@\n+    @Test\n@@ -581,1 +589,1 @@\n-            errln(\"Didn't get en as a language for US\");\n+            fail(\"Didn't get en as a language for US\");\n@@ -585,1 +593,1 @@\n-            errln(\"Didn't get fr as a language for FR\");\n+            fail(\"Didn't get fr as a language for FR\");\n@@ -589,1 +597,1 @@\n-            errln(\"Didn't get fr as a language for CH\");\n+            fail(\"Didn't get fr as a language for CH\");\n@@ -591,1 +599,1 @@\n-            errln(\"Didn't get it as a language for CH\");\n+            fail(\"Didn't get it as a language for CH\");\n@@ -593,1 +601,1 @@\n-            errln(\"Didn't get de as a language for CH\");\n+            fail(\"Didn't get de as a language for CH\");\n@@ -597,1 +605,1 @@\n-            errln(\"Didn't get ja as a language for JP\");\n+            fail(\"Didn't get ja as a language for JP\");\n@@ -610,0 +618,1 @@\n+    @Test\n@@ -630,1 +639,1 @@\n-            errln(\"Locale failed to deserialize correctly.\");\n+            fail(\"Locale failed to deserialize correctly.\");\n@@ -637,0 +646,1 @@\n+    @Test\n@@ -649,1 +659,1 @@\n-                errln(\"Got wrong display name for \" + languageCodes[i] + \": Expected \\\"\"\n+                fail(\"Got wrong display name for \" + languageCodes[i] + \": Expected \\\"\"\n@@ -658,0 +668,1 @@\n+    @Test\n@@ -667,1 +678,1 @@\n-                errln(\"Got wrong ISO3 code for \" + iso2Languages[i] + \": Expected \\\"\"\n+                fail(\"Got wrong ISO3 code for \" + iso2Languages[i] + \": Expected \\\"\"\n@@ -678,1 +689,1 @@\n-                errln(\"Got wrong ISO3 code for \" + iso2Countries[i] + \": Expected \\\"\"\n+                fail(\"Got wrong ISO3 code for \" + iso2Countries[i] + \": Expected \\\"\"\n@@ -687,0 +698,1 @@\n+    @Test\n@@ -697,1 +709,1 @@\n-                errln(\"Got back wrong language code for new Hebrew: expected \\\"iw\\\", got \\\"\"\n+                fail(\"Got back wrong language code for new Hebrew: expected \\\"iw\\\", got \\\"\"\n@@ -701,1 +713,1 @@\n-                errln(\"Got back wrong language code for new Yiddish: expected \\\"ji\\\", got \\\"\"\n+                fail(\"Got back wrong language code for new Yiddish: expected \\\"ji\\\", got \\\"\"\n@@ -705,1 +717,1 @@\n-                errln(\"Got back wrong language code for new Indonesian: expected \\\"in\\\", got \\\"\"\n+                fail(\"Got back wrong language code for new Indonesian: expected \\\"in\\\", got \\\"\"\n@@ -710,1 +722,1 @@\n-                errln(\"Got back wrong language code for old Hebrew: expected \\\"he\\\", got \\\"\"\n+                fail(\"Got back wrong language code for old Hebrew: expected \\\"he\\\", got \\\"\"\n@@ -714,1 +726,1 @@\n-                errln(\"Got back wrong language code for old Yiddish: expected \\\"yi\\\", got \\\"\"\n+                fail(\"Got back wrong language code for old Yiddish: expected \\\"yi\\\", got \\\"\"\n@@ -718,1 +730,1 @@\n-                errln(\"Got back wrong language code for old Indonesian: expected \\\"id\\\", got \\\"\"\n+                fail(\"Got back wrong language code for old Indonesian: expected \\\"id\\\", got \\\"\"\n@@ -742,0 +754,1 @@\n+    @Test\n@@ -787,1 +800,1 @@\n-            logln(name);\n+            System.out.println(name);\n@@ -789,1 +802,1 @@\n-                errln(\"Lookup in English failed: expected \\\"\" + englishDisplayNames[i]\n+                fail(\"Lookup in English failed: expected \\\"\" + englishDisplayNames[i]\n@@ -796,1 +809,1 @@\n-            logln(name);\n+            System.out.println(name);\n@@ -798,1 +811,1 @@\n-                errln(\"Lookup in Spanish failed: expected \\\"\" + spanishDisplayNames[i]\n+                fail(\"Lookup in Spanish failed: expected \\\"\" + spanishDisplayNames[i]\n@@ -805,1 +818,1 @@\n-            logln(name);\n+            System.out.println(name);\n@@ -807,1 +820,1 @@\n-                errln(\"Lookup in French failed: expected \\\"\" + frenchDisplayNames[i]\n+                fail(\"Lookup in French failed: expected \\\"\" + frenchDisplayNames[i]\n@@ -819,0 +832,1 @@\n+    @Test\n@@ -830,1 +844,1 @@\n-            errln(\"Locale.getDefault() allowed us to set default to NULL!\");\n+            fail(\"Locale.getDefault() allowed us to set default to NULL!\");\n@@ -833,1 +847,1 @@\n-            errln(\"Trying to set default locale to NULL didn't throw exception!\");\n+            fail(\"Trying to set default locale to NULL didn't throw exception!\");\n@@ -842,0 +856,1 @@\n+    @Test\n@@ -846,1 +861,1 @@\n-            errln(\"Thai currency prefix wrong: expected \\\"\\u0e3f\\\", got \\\"\"\n+            fail(\"Thai currency prefix wrong: expected \\\"\\u0e3f\\\", got \\\"\"\n@@ -850,1 +865,1 @@\n-            errln(\"Thai currency suffix wrong: expected \\\"\\\", got \\\"\"\n+            fail(\"Thai currency suffix wrong: expected \\\"\\\", got \\\"\"\n@@ -868,0 +883,1 @@\n+    @Test\n@@ -881,1 +897,1 @@\n-                    logln(\"Ok: \" + loc.toString()\n+                    System.out.println(\"Ok: \" + loc.toString()\n@@ -884,1 +900,1 @@\n-                    errln(\"Fail: \" + loc.toString()\n+                    fail(\"Fail: \" + loc.toString()\n@@ -897,0 +913,1 @@\n+    @Test\n@@ -911,1 +928,1 @@\n-                errln(\"Fail: Locale.toString(\" + fmt + \")=>\" + loc);\n+                fail(\"Fail: Locale.toString(\" + fmt + \")=>\" + loc);\n@@ -921,0 +938,1 @@\n+    @Test\n@@ -928,1 +946,1 @@\n-                errln(\"Percent for \" + LOC[i] + \" should be 100%, got \" + result);\n+                fail(\"Percent for \" + LOC[i] + \" should be 100%, got \" + result);\n@@ -949,0 +967,1 @@\n+    @Test\n@@ -958,1 +977,1 @@\n-            errln(\"Fail: Monday in Hungarian is wrong\");\n+            fail(\"Fail: Monday in Hungarian is wrong\");\n@@ -966,0 +985,1 @@\n+    @Test\n@@ -969,1 +989,1 @@\n-            errln(\"Fail: First day of week in Russia should be Monday\");\n+            fail(\"Fail: First day of week in Russia should be Monday\");\n@@ -978,0 +998,1 @@\n+    @Test\n@@ -986,1 +1007,1 @@\n-            errln(\"ERROR: getISO3Country() returns: \" + result\n+            fail(\"ERROR: getISO3Country() returns: \" + result\n@@ -998,0 +1019,1 @@\n+    @Test\n@@ -1005,1 +1027,1 @@\n-            errln(\"ERROR: getISO3Language() returns: \" + result\n+            fail(\"ERROR: getISO3Language() returns: \" + result\n@@ -1016,1 +1038,1 @@\n-            errln(\"ERROR: getISO3Language() returns: \" + result\n+            fail(\"ERROR: getISO3Language() returns: \" + result\n@@ -1025,0 +1047,1 @@\n+    @Test\n@@ -1041,1 +1064,1 @@\n-                errln(\"English display-name mismatch: expected \"\n+                fail(\"English display-name mismatch: expected \"\n@@ -1045,1 +1068,1 @@\n-                errln(\"Norwegian display-name mismatch: expected \"\n+                fail(\"Norwegian display-name mismatch: expected \"\n@@ -1055,0 +1078,1 @@\n+    @Test\n@@ -1059,1 +1083,1 @@\n-            errln(\"\\\"nb-NO\\\" and\/or \\\"nn-NO\\\" locale(s) not returned from getAvailableLocales().\");\n+            fail(\"\\\"nb-NO\\\" and\/or \\\"nn-NO\\\" locale(s) not returned from getAvailableLocales().\");\n","filename":"test\/jdk\/java\/util\/Locale\/LocaleTest.java","additions":127,"deletions":103,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8032842 8175539\n+ * @summary Checks that the filterTags() and lookup() methods\n+ *          preserve the case of matching language tag(s).\n+ *          Before 8032842 fix these methods return the matching\n+ *          language tag(s) in lowercase.\n+ *          Also, checks the filterTags() to return only unique\n+ *          (ignoring case considerations) matching tags.\n+ * @run junit PreserveTagCase\n+ *\/\n+\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Locale.FilteringMode;\n+import java.util.Locale.LanguageRange;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class PreserveTagCase {\n+\n+    \/**\n+     * This test ensures that Locale.filterTags() preserves the case of matching\n+     * language tag(s).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"filterProvider\")\n+    public static void testFilterTags(String ranges, List<String> tags,\n+                                  List<String> expected, FilteringMode mode) {\n+        List<LanguageRange> priorityList = LanguageRange.parse(ranges);\n+        List<String> actual = Locale.filterTags(priorityList, tags, mode);\n+        assertEquals(actual, expected, String.format(\"[filterTags() failed for \" +\n+                \"the language range: %s, Expected: %s, Found: %s]\", ranges, expected, actual));\n+    }\n+\n+    \/**\n+     * This test ensures that Locale.lookupTag() preserves the case of matching\n+     * language tag(s).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"lookupProvider\")\n+    public static void testLookupTag(String ranges, List<String> tags,\n+                                  String expected) {\n+        List<LanguageRange> priorityList = LanguageRange.parse(ranges);\n+        String actual = Locale.lookupTag(priorityList, tags);\n+        assertEquals(actual, expected, String.format(\"[lookupTags() failed for \" +\n+                \"the language range: %s, Expected: %s, Found: %s]\", ranges, expected, actual));\n+    }\n+\n+    private static Stream<Arguments> filterProvider() {\n+        return Stream.of(\n+                \/\/ test filterBasic() for preserving the case of matching tags for\n+                \/\/ the language range '*', with no duplicates in the matching tags\n+                Arguments.of(\"*\",\n+                        List.of(\"de-CH\", \"hi-in\", \"En-GB\", \"ja-Latn-JP\", \"JA-JP\", \"en-GB\"),\n+                        List.of(\"de-CH\", \"hi-in\", \"En-GB\", \"ja-Latn-JP\", \"JA-JP\"),\n+                        FilteringMode.AUTOSELECT_FILTERING),\n+                \/\/ test filterBasic() for preserving the case of matching tags for\n+                \/\/ basic ranges other than *, with no duplicates in the matching tags\n+                Arguments.of(\"mtm-RU, en-GB\",\n+                        List.of(\"En-Gb\", \"mTm-RU\", \"en-US\", \"en-latn\", \"en-GB\"),\n+                        List.of(\"mTm-RU\", \"En-Gb\"),\n+                        FilteringMode.AUTOSELECT_FILTERING),\n+                \/\/ test filterExtended() for preserving the case of matching tags for\n+                \/\/ the language range '*', with no duplicates in the matching tags\n+                Arguments.of(\"*\",\n+                        List.of(\"de-CH\", \"hi-in\", \"En-GB\", \"hi-IN\", \"ja-Latn-JP\", \"JA-JP\"),\n+                        List.of(\"de-CH\", \"hi-in\", \"En-GB\", \"ja-Latn-JP\", \"JA-JP\"),\n+                        FilteringMode.EXTENDED_FILTERING),\n+                \/\/ test filterExtended() for preserving the case of matching tags for\n+                \/\/ extended ranges other than *, with no duplicates in the matching tags\n+                Arguments.of(\"*-ch;q=0.5, *-Latn;q=0.4\",\n+                        List.of(\"fr-CH\", \"de-Ch\", \"en-latn\", \"en-US\", \"en-Latn\"),\n+                        List.of(\"fr-CH\", \"de-Ch\", \"en-latn\"),\n+                        FilteringMode.EXTENDED_FILTERING)\n+        );\n+    }\n+\n+    private static Stream<Arguments> lookupProvider() {\n+        return Stream.of(\n+                \/\/ test lookupTag() for preserving the case of matching tag\n+                Arguments.of(\"*-ch;q=0.5\", List.of(\"en\", \"fR-cH\"), \"fR-cH\"),\n+                Arguments.of(\"*-Latn;q=0.4\", List.of(\"en\", \"fR-LATn\"), \"fR-LATn\")\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/PreserveTagCase.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6277243\n+ * @summary Verify that there is Locale.ROOT constant, and it is equal to Locale(\"\", \"\", \"\")\n+ * @run junit RootLocale\n+ *\/\n+\n+import java.util.Locale;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class RootLocale {\n+\n+    \/**\n+     * Locale.ROOT should exist and match an empty Locale given as\n+     * Locale(\"\", \"\", \"\").\n+     *\/\n+    @Test\n+    public void rootTest() {\n+        Locale root = Locale.of(\"\", \"\", \"\");\n+        assertEquals(Locale.ROOT, root, \"Locale.ROOT is not equal to Locale(\\\"\\\", \\\"\\\", \\\"\\\")\");\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Locale\/RootLocale.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n- * @test\n- * @summary Test the implementation\n- * of Locale.availableLocales()\n- * @bug 8282319\n- * @run junit StreamAvailableLocales\n- *\/\n-\n-import java.util.Arrays;\n-import java.util.Locale;\n-import java.util.stream.Stream;\n-import org.junit.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-import org.junit.jupiter.params.provider.Arguments;\n-\n-public class StreamAvailableLocales {\n-\n-    \/**\n-     * Test to validate that the methods: Locale.getAvailableLocales()\n-     * and Locale.availableLocales() contain the same underlying elements\n-     *\/\n-    @Test\n-    public void testStreamEqualsArray() {\n-        Locale[] arrayLocales = Locale.getAvailableLocales();\n-        Stream<Locale> streamedLocales = Locale.availableLocales();\n-        Locale[] convertedLocales = streamedLocales.toArray(Locale[]::new);\n-        if (Arrays.equals(arrayLocales, convertedLocales)) {\n-            System.out.println(\"$$$ Passed: The underlying elements\" +\n-                    \" of getAvailableLocales() and availableLocales() are the same!\");\n-        } else {\n-            throw new RuntimeException(\"$$$ Error: The underlying elements\" +\n-                    \" of getAvailableLocales() and availableLocales()\" +\n-                    \" are not the same.\");\n-        }\n-    }\n-\n-    \/**\n-     * Test to validate that the stream has the required\n-     * Locale.ROOT and Locale.US.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"requiredLocaleProvider\")\n-    public void testStreamRequirements(Locale requiredLocale, String localeName) {\n-        if (Locale.availableLocales().anyMatch(loc -> (loc.equals(requiredLocale)))) {\n-            System.out.printf(\"$$$ Passed: Stream has %s!%n\", localeName);\n-        } else {\n-            throw new RuntimeException(String.format(\"$$$ Error:\" +\n-                    \" Stream is missing %s!\", localeName));\n-        }\n-    }\n-\n-    \/\/ Data provider for testStreamRequirements\n-    private static Stream<Arguments> requiredLocaleProvider() {\n-        return Stream.of(\n-                Arguments.of(Locale.ROOT, \"Root locale\"),\n-                Arguments.of(Locale.US, \"US locale\")\n-        );\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/Locale\/StreamAvailableLocales.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n- * @test\n- * @bug 4122700\n- * @summary Verify that list of available locales is non-empty, and print the list\n- *\/\n-\n-import java.util.Locale;\n-\n-public class bug4122700 {\n-    public static void main(String[] args) throws Exception {\n-        Locale[] systemLocales = Locale.getAvailableLocales();\n-        if (systemLocales.length == 0)\n-            throw new Exception(\"Available locale list is empty!\");\n-        System.out.println(\"Found \" + systemLocales.length + \" locales:\");\n-        Locale[] locales = new Locale[systemLocales.length];\n-        for (int i = 0; i < locales.length; i++) {\n-            Locale lowest = null;\n-            for (int j = 0; j < systemLocales.length; j++) {\n-                if (i > 0 && locales[i - 1].toString().compareTo(systemLocales[j].toString()) >= 0)\n-                    continue;\n-                if (lowest == null || systemLocales[j].toString().compareTo(lowest.toString()) < 0)\n-                    lowest = systemLocales[j];\n-            }\n-            locales[i] = lowest;\n-        }\n-        for (int i = 0; i < locales.length; i++) {\n-            if (locales[i].getCountry().length() == 0)\n-                System.out.println(\"    \" + locales[i].getDisplayLanguage() + \":\");\n-            else {\n-                if (locales[i].getVariant().length() == 0)\n-                    System.out.println(\"        \" + locales[i].getDisplayCountry());\n-                else\n-                    System.out.println(\"        \" + locales[i].getDisplayCountry() + \", \"\n-                                    + locales[i].getDisplayVariant());\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/Locale\/bug4122700.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n- * @test\n- * @bug 6277243\n- * @summary Verify that there is Locale.ROOT constant, and it is equal to Locale(\"\", \"\", \"\")\n- *\/\n-\n-import java.util.Locale;\n-\n-public class bug6277243 {\n-\n-    public static void main(String[] args) throws Exception {\n-        Locale root = Locale.of(\"\", \"\", \"\");\n-        if (!Locale.ROOT.equals(root)) {\n-            throw new RuntimeException(\"Locale.ROOT is not equal to Locale(\\\"\\\", \\\"\\\", \\\"\\\")\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/Locale\/bug6277243.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n- * @test\n- * @bug 6312358\n- * @summary Verify that an NPE is thrown by issueing Locale.getInstance() with\n- *      any argument being null.\n- * @modules java.base\/java.util:open\n- *\/\n-\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.util.Locale;\n-\n-public class bug6312358 {\n-\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        try {\n-            \/\/ Locale.getInstance is not directly accessible.\n-            Method getInstanceMethod = Locale.class.getDeclaredMethod(\n-                \"getInstance\", String.class, String.class, String.class\n-            );\n-            getInstanceMethod.setAccessible(true);\n-\n-            getInstanceMethod.invoke(null, \"null\", \"GB\", \"\");\n-            try {\n-                getInstanceMethod.invoke(null, null, \"GB\", \"\");\n-                throw new RuntimeException(\"Should NPE with language set to null\");\n-            } catch (InvocationTargetException exc) {\n-                Throwable cause = exc.getCause();\n-                if (!(cause instanceof NullPointerException)) {\n-                    throw new RuntimeException(cause+\" is thrown with language set to null\");\n-                }\n-            }\n-\n-            getInstanceMethod.invoke(null, \"en\", \"null\", \"\");\n-            try {\n-                getInstanceMethod.invoke(null, \"en\", null, \"\");\n-                throw new RuntimeException(\"Should NPE with country set to null\");\n-            } catch (InvocationTargetException exc) {\n-                Throwable cause = exc.getCause();\n-                if (!(cause instanceof NullPointerException)) {\n-                    throw new RuntimeException(cause+\" is thrown with country set to null\");\n-                }\n-            }\n-\n-            getInstanceMethod.invoke(null, \"en\", \"GB\", \"null\");\n-            try {\n-                getInstanceMethod.invoke(null, \"en\", \"GB\", null);\n-                throw new RuntimeException(\"Should NPE with variant set to null\");\n-            } catch (InvocationTargetException exc) {\n-                Throwable cause = exc.getCause();\n-                if (!(cause instanceof NullPointerException)) {\n-                    throw new RuntimeException(cause+\" is thrown with variant set to null\");\n-                }\n-            }\n-        } catch (java.lang.NoSuchMethodException exc) {\n-            \/\/ method is not found.  consider it as a success\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/Locale\/bug6312358.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @library \/java\/text\/testlib\n+ * @run junit Bug4322313\n@@ -33,3 +33,2 @@\n-import java.io.*;\n-import java.text.*;\n-import java.util.*;\n+import java.util.Locale;\n+import java.util.TimeZone;\n@@ -37,1 +36,5 @@\n-public class Bug4322313 extends IntlTest {\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class Bug4322313 {\n@@ -83,0 +86,1 @@\n+    @Test\n@@ -109,1 +113,1 @@\n-                        logln(\"\\tPassed [Locale=\" +\n+                        System.out.println(\"\\tPassed [Locale=\" +\n@@ -122,1 +126,1 @@\n-                        logln(\"\\tPassed [Locale=\" +\n+                        System.out.println(\"\\tPassed [Locale=\" +\n@@ -135,1 +139,1 @@\n-                        logln(\"\\tPassed [Locale=\" +\n+                        System.out.println(\"\\tPassed [Locale=\" +\n@@ -153,1 +157,1 @@\n-                        logln(\"\\tPassed [Locale=\" +\n+                        System.out.println(\"\\tPassed [Locale=\" +\n@@ -166,1 +170,1 @@\n-                        logln(\"\\tPassed [Locale=\" +\n+                        System.out.println(\"\\tPassed [Locale=\" +\n@@ -179,1 +183,1 @@\n-                        logln(\"\\tPassed [Locale=\" +\n+                        System.out.println(\"\\tPassed [Locale=\" +\n@@ -221,1 +225,1 @@\n-            errln(\"TimeZone.getTimeZone() test failed\");\n+            fail(\"TimeZone.getTimeZone() test failed\");\n@@ -223,1 +227,1 @@\n-            logln(\"TimeZone.getTimeZone() test passed\");\n+            System.out.println(\"TimeZone.getTimeZone() test passed\");\n@@ -226,4 +230,0 @@\n-\n-    public static void main (String[] args) throws Exception {\n-        new Bug4322313().run(args);\n-    }\n","filename":"test\/jdk\/java\/util\/TimeZone\/Bug4322313.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,1 @@\n- * @library \/java\/text\/testlib\n- * @build Bug6329116 TextFileReader\n- * @run main\/othervm -Djava.locale.providers=COMPAT,SPI Bug6329116\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT,SPI Bug6329116\n@@ -39,1 +37,5 @@\n-public class Bug6329116 extends IntlTest {\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class Bug6329116 {\n@@ -44,7 +46,2 @@\n-    public static void main(String[] args) throws IOException {\n-        if (bug6329116()) {\n-            throw new RuntimeException(\"At least one timezone display name is incorrect.\");\n-        }\n-    }\n-\n-    static boolean bug6329116() throws IOException {\n+    @Test\n+    public void bug6329116() throws IOException {\n@@ -203,1 +200,3 @@\n-        return err;\n+        if (err) {\n+            fail(\"At least one timezone display name is incorrect.\");\n+        }\n","filename":"test\/jdk\/java\/util\/TimeZone\/Bug6329116.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @library \/java\/text\/testlib\n@@ -28,0 +27,1 @@\n+ * @run junit TimeZoneBoundaryTest\n@@ -30,2 +30,10 @@\n-import java.text.*;\n-import java.util.*;\n+import java.text.DateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.SimpleTimeZone;\n+import java.util.TimeZone;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n@@ -37,1 +45,1 @@\n-public class TimeZoneBoundaryTest extends IntlTest\n+public class TimeZoneBoundaryTest\n@@ -60,4 +68,0 @@\n-    public static void main(String[] args) throws Exception {\n-        new TimeZoneBoundaryTest().run(args);\n-    }\n-\n@@ -78,1 +82,1 @@\n-            logln(\"Error: \" + startMode + \" not present in \" + d);\n+            System.out.println(\"Error: \" + startMode + \" not present in \" + d);\n@@ -101,2 +105,2 @@\n-        logln(\"Date Before: \" + showDate(min));\n-        logln(\"Date After:  \" + showDate(max));\n+        System.out.println(\"Date Before: \" + showDate(min));\n+        System.out.println(\"Date After:  \" + showDate(max));\n@@ -107,1 +111,1 @@\n-            logln(\"PASS: Expected boundary at \" + expectedBoundary);\n+            System.out.println(\"PASS: Expected boundary at \" + expectedBoundary);\n@@ -109,1 +113,1 @@\n-            errln(\"FAIL: Expected boundary at \" + expectedBoundary);\n+            fail(\"FAIL: Expected boundary at \" + expectedBoundary);\n@@ -131,1 +135,1 @@\n-            errln(\"FAIL: \" + tz.getID() + \" inDaylightTime(\" +\n+            fail(\"FAIL: \" + tz.getID() + \" inDaylightTime(\" +\n@@ -138,1 +142,1 @@\n-            errln(\"FAIL: \" + tz.getID() + \" inDaylightTime(\" +\n+            fail(\"FAIL: \" + tz.getID() + \" inDaylightTime(\" +\n@@ -157,2 +161,2 @@\n-        logln(tz.getID() + \" Before: \" + showDate(min, tz));\n-        logln(tz.getID() + \" After:  \" + showDate(max, tz));\n+        System.out.println(tz.getID() + \" Before: \" + showDate(min, tz));\n+        System.out.println(tz.getID() + \" After:  \" + showDate(max, tz));\n@@ -164,1 +168,1 @@\n-            logln(\"PASS: Expected boundary at \" + expectedBoundary);\n+            System.out.println(\"PASS: Expected boundary at \" + expectedBoundary);\n@@ -166,1 +170,1 @@\n-            errln(\"FAIL: Expected boundary at \" + expectedBoundary);\n+            fail(\"FAIL: Expected boundary at \" + expectedBoundary);\n@@ -212,1 +216,1 @@\n-        logln(\"-- Verifying time \" + d +\n+        System.out.println(\"-- Verifying time \" + d +\n@@ -216,1 +220,1 @@\n-            logln(\"PASS: inDaylightTime = \" + time_zone.inDaylightTime(d));\n+            System.out.println(\"PASS: inDaylightTime = \" + time_zone.inDaylightTime(d));\n@@ -218,1 +222,1 @@\n-            errln(\"FAIL: inDaylightTime = \" + time_zone.inDaylightTime(d));\n+            fail(\"FAIL: inDaylightTime = \" + time_zone.inDaylightTime(d));\n@@ -221,1 +225,1 @@\n-            logln(\"PASS: useDaylightTime = \" + time_zone.useDaylightTime());\n+            System.out.println(\"PASS: useDaylightTime = \" + time_zone.useDaylightTime());\n@@ -223,1 +227,1 @@\n-            errln(\"FAIL: useDaylightTime = \" + time_zone.useDaylightTime());\n+            fail(\"FAIL: useDaylightTime = \" + time_zone.useDaylightTime());\n@@ -226,1 +230,1 @@\n-            logln(\"PASS: getRawOffset() = \" + expZoneOffset\/(double)ONE_HOUR);\n+            System.out.println(\"PASS: getRawOffset() = \" + expZoneOffset\/(double)ONE_HOUR);\n@@ -228,1 +232,1 @@\n-            errln(\"FAIL: getRawOffset() = \" + time_zone.getRawOffset()\/(double)ONE_HOUR +\n+            fail(\"FAIL: getRawOffset() = \" + time_zone.getRawOffset()\/(double)ONE_HOUR +\n@@ -240,1 +244,1 @@\n-            logln(\"PASS: getOffset() = \" + offset\/(double)ONE_HOUR);\n+            System.out.println(\"PASS: getOffset() = \" + offset\/(double)ONE_HOUR);\n@@ -242,1 +246,1 @@\n-            errln(\"FAIL: getOffset() = \" + offset\/(double)ONE_HOUR +\n+            fail(\"FAIL: getOffset() = \" + offset\/(double)ONE_HOUR +\n@@ -247,0 +251,1 @@\n+    @Test\n@@ -266,1 +271,1 @@\n-            logln(\"========================================\");\n+            System.out.println(\"========================================\");\n@@ -268,1 +273,1 @@\n-            logln(\"========================================\");\n+            System.out.println(\"========================================\");\n@@ -272,1 +277,1 @@\n-            logln(\"========================================\");\n+            System.out.println(\"========================================\");\n@@ -276,1 +281,1 @@\n-            logln(\"========================================\");\n+            System.out.println(\"========================================\");\n@@ -278,1 +283,1 @@\n-            logln(\"========================================\");\n+            System.out.println(\"========================================\");\n@@ -300,1 +305,1 @@\n-            logln(\"Error: inDaylightTime(\" + (new Date(max)) + \") != \" + (!startsInDST));\n+            System.out.println(\"Error: inDaylightTime(\" + (new Date(max)) + \") != \" + (!startsInDST));\n@@ -316,2 +321,2 @@\n-        logln(\"Binary Search Before: \" + showDate(min));\n-        logln(\"Binary Search After:  \" + showDate(max));\n+        System.out.println(\"Binary Search Before: \" + showDate(min));\n+        System.out.println(\"Binary Search After:  \" + showDate(max));\n@@ -323,1 +328,1 @@\n-            logln(\"PASS: Expected boundary at \" + expectedBoundary);\n+            System.out.println(\"PASS: Expected boundary at \" + expectedBoundary);\n@@ -325,1 +330,1 @@\n-            errln(\"FAIL: Expected boundary at \" + expectedBoundary);\n+            fail(\"FAIL: Expected boundary at \" + expectedBoundary);\n@@ -328,24 +333,0 @@\n-    \/*\n-      static void testUsingMillis(Date d, boolean startsInDST)\n-      {\n-      long millis = d.getTime();\n-      long max = millis + (long)(370 * ONE_DAY); \/\/ A year plus extra\n-\n-      boolean lastDST = startsInDST;\n-      while (millis < max)\n-      {\n-      cal.setTime(new Date(millis));\n-      boolean inDaylight = cal.inDaylightTime();\n-\n-      if (inDaylight != lastDST)\n-      {\n-      logln(\"Switch \" + (inDaylight ? \"into\" : \"out of\")\n-      + \" DST at \" + (new Date(millis)));\n-      lastDST = inDaylight;\n-      }\n-\n-      millis += 15*ONE_MINUTE;\n-      }\n-      }\n-      *\/\n-\n@@ -356,60 +337,26 @@\n-    public void TestNewRules()\n-    {\n-        \/\/logln(Locale.getDefault().getDisplayName());\n-        \/\/logln(TimeZone.getDefault().getID());\n-        \/\/logln(new Date(0));\n-\n-        if (true)\n-        {\n-            \/\/ Doesn't matter what the default TimeZone is here, since we\n-            \/\/ are creating our own TimeZone objects.\n-\n-            SimpleTimeZone tz;\n-\n-            logln(\"-----------------------------------------------------------------\");\n-            logln(\"Aug 2ndTues .. Mar 15\");\n-            tz = new SimpleTimeZone(-8*ONE_HOUR, \"Test_1\",\n-                                    Calendar.AUGUST, 2, Calendar.TUESDAY, 2*ONE_HOUR,\n-                                    Calendar.MARCH, 15, 0, 2*ONE_HOUR);\n-            \/\/logln(tz.toString());\n-            logln(\"========================================\");\n-            testUsingBinarySearch(tz, new Date(97,0,1), 858416400000L);\n-            logln(\"========================================\");\n-            testUsingBinarySearch(tz, new Date(97,6,1), 871380000000L);\n-\n-            logln(\"-----------------------------------------------------------------\");\n-            logln(\"Apr Wed>=14 .. Sep Sun<=20\");\n-            tz = new SimpleTimeZone(-8*ONE_HOUR, \"Test_2\",\n-                                    Calendar.APRIL, 14, -Calendar.WEDNESDAY, 2*ONE_HOUR,\n-                                    Calendar.SEPTEMBER, -20, -Calendar.SUNDAY, 2*ONE_HOUR);\n-            \/\/logln(tz.toString());\n-            logln(\"========================================\");\n-            testUsingBinarySearch(tz, new Date(97,0,1), 861184800000L);\n-            logln(\"========================================\");\n-            testUsingBinarySearch(tz, new Date(97,6,1), 874227600000L);\n-        }\n-\n-        \/*\n-          if (true)\n-          {\n-          logln(\"========================================\");\n-          logln(\"Stepping using millis\");\n-          testUsingMillis(new Date(97,0,1), false);\n-          }\n-\n-          if (true)\n-          {\n-          logln(\"========================================\");\n-          logln(\"Stepping using fields\");\n-          testUsingFields(1997, false);\n-          }\n-\n-          if (false)\n-          {\n-          cal.clear();\n-          cal.set(1997, 3, 5, 10, 0);\n-          \/\/    cal.inDaylightTime();\n-          logln(\"Date = \" + cal.getTime());\n-          logln(\"Millis = \" + cal.getTime().getTime()\/3600000);\n-          }\n-          *\/\n+    @Test\n+    public void TestNewRules() {\n+        \/\/ Doesn't matter what the default TimeZone is here, since we\n+        \/\/ are creating our own TimeZone objects.\n+\n+        SimpleTimeZone tz;\n+\n+        System.out.println(\"-----------------------------------------------------------------\");\n+        System.out.println(\"Aug 2ndTues .. Mar 15\");\n+        tz = new SimpleTimeZone(-8*ONE_HOUR, \"Test_1\",\n+                                Calendar.AUGUST, 2, Calendar.TUESDAY, 2*ONE_HOUR,\n+                                Calendar.MARCH, 15, 0, 2*ONE_HOUR);\n+        System.out.println(\"========================================\");\n+        testUsingBinarySearch(tz, new Date(97,0,1), 858416400000L);\n+        System.out.println(\"========================================\");\n+        testUsingBinarySearch(tz, new Date(97,6,1), 871380000000L);\n+\n+        System.out.println(\"-----------------------------------------------------------------\");\n+        System.out.println(\"Apr Wed>=14 .. Sep Sun<=20\");\n+        tz = new SimpleTimeZone(-8*ONE_HOUR, \"Test_2\",\n+                                Calendar.APRIL, 14, -Calendar.WEDNESDAY, 2*ONE_HOUR,\n+                                Calendar.SEPTEMBER, -20, -Calendar.SUNDAY, 2*ONE_HOUR);\n+        System.out.println(\"========================================\");\n+        testUsingBinarySearch(tz, new Date(97,0,1), 861184800000L);\n+        System.out.println(\"========================================\");\n+        testUsingBinarySearch(tz, new Date(97,6,1), 874227600000L);\n@@ -418,13 +365,0 @@\n-    \/\/----------------------------------------------------------------------\n-    \/\/----------------------------------------------------------------------\n-    \/\/----------------------------------------------------------------------\n-    \/\/ Long Bug\n-    \/\/----------------------------------------------------------------------\n-    \/\/----------------------------------------------------------------------\n-    \/\/----------------------------------------------------------------------\n-\n-    \/\/public void Test3()\n-    \/\/{\n-    \/\/    findDaylightBoundaryUsingTimeZone(new Date(97,6,1), true);\n-    \/\/}\n-\n@@ -442,2 +376,2 @@\n-        logln(\"-- Zone \" + z.getID() + \" starts in \" + year + \" with DST = \" + lastState);\n-        logln(\"useDaylightTime = \" + z.useDaylightTime());\n+        System.out.println(\"-- Zone \" + z.getID() + \" starts in \" + year + \" with DST = \" + lastState);\n+        System.out.println(\"useDaylightTime = \" + z.useDaylightTime());\n@@ -450,1 +384,1 @@\n-                logln((state ? \"Entry \" : \"Exit \") +\n+                System.out.println((state ? \"Entry \" : \"Exit \") +\n@@ -459,2 +393,2 @@\n-            if (!lastState && !z.useDaylightTime()) logln(\"No DST\");\n-            else errln(\"FAIL: Timezone<\" + z.getID() + \"> DST all year, or no DST with true useDaylightTime\");\n+            if (!lastState && !z.useDaylightTime()) System.out.println(\"No DST\");\n+            else fail(\"FAIL: Timezone<\" + z.getID() + \"> DST all year, or no DST with true useDaylightTime\");\n@@ -464,1 +398,1 @@\n-            errln(\"FAIL: Timezone<\" + z.getID() + \"> \" + changes + \" changes seen; should see 0 or 2\");\n+            fail(\"FAIL: Timezone<\" + z.getID() + \"> \" + changes + \" changes seen; should see 0 or 2\");\n@@ -468,1 +402,1 @@\n-            errln(\"FAIL: Timezone<\" + z.getID() + \"> useDaylightTime false but 2 changes seen\");\n+            fail(\"FAIL: Timezone<\" + z.getID() + \"> useDaylightTime false but 2 changes seen\");\n@@ -472,1 +406,1 @@\n-            errln(\"FAIL: Timezone<\" + z.getID() + \"> \" + changes + \" changes seen; expected \" + expectedChanges);\n+            fail(\"FAIL: Timezone<\" + z.getID() + \"> \" + changes + \" changes seen; expected \" + expectedChanges);\n@@ -476,0 +410,1 @@\n+    @Test\n","filename":"test\/jdk\/java\/util\/TimeZone\/TimeZoneBoundaryTest.java","additions":79,"deletions":144,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm -Djava.locale.providers=COMPAT,SPI TimeZoneRegression\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT,SPI TimeZoneRegression\n@@ -37,1 +37,1 @@\n-public class TimeZoneRegression extends IntlTest {\n+import org.junit.jupiter.api.Test;\n@@ -39,3 +39,3 @@\n-    public static void main(String[] args) throws Exception {\n-        new TimeZoneRegression().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class TimeZoneRegression {\n@@ -43,0 +43,1 @@\n+    @Test\n@@ -47,1 +48,1 @@\n-            errln(\"Fail: TimeZone should return clones\");\n+            fail(\"Fail: TimeZone should return clones\");\n@@ -52,0 +53,1 @@\n+    @Test\n@@ -55,1 +57,1 @@\n-            errln(\"Fail: Fix test to start with non-DST zone\");\n+            fail(\"Fail: Fix test to start with non-DST zone\");\n@@ -60,1 +62,1 @@\n-            errln(\"Fail: DST not active\");\n+            fail(\"Fail: DST not active\");\n@@ -65,1 +67,1 @@\n-            errln(\"Fail: DST not working as expected\");\n+            fail(\"Fail: DST not working as expected\");\n@@ -77,0 +79,1 @@\n+    @Test\n@@ -116,1 +119,1 @@\n-            errln(\"Fail: TimeZone misbehaving\"); {\n+            fail(\"Fail: TimeZone misbehaving\"); {\n@@ -120,0 +123,1 @@\n+    @Test\n@@ -127,1 +131,1 @@\n-                    errln(\"Fail: Test broken; zones not instantiating\");\n+                    fail(\"Fail: Test broken; zones not instantiating\");\n@@ -143,1 +147,1 @@\n-                    logln(\"TimeZone \" + zone.getID() +\n+                    System.out.println(\"TimeZone \" + zone.getID() +\n@@ -148,1 +152,1 @@\n-            if (!pass) errln(\"Fail: TimeZone serialization\/equality bug\");\n+            if (!pass) fail(\"Fail: TimeZone serialization\/equality bug\");\n@@ -151,1 +155,1 @@\n-            errln(\"Fail: \" + e);\n+            fail(\"Fail: \" + e);\n@@ -155,1 +159,1 @@\n-            errln(\"Fail: \" + e);\n+            fail(\"Fail: \" + e);\n@@ -160,0 +164,1 @@\n+    @Test\n@@ -163,1 +168,1 @@\n-            logln(\"Skipping this test because locale is \" + locale);\n+            System.out.println(\"Skipping this test because locale is \" + locale);\n@@ -193,1 +198,1 @@\n-        if (!pass) errln(\"Fail: TZ API inconsistent\");\n+        if (!pass) fail(\"Fail: TZ API inconsistent\");\n@@ -271,1 +276,1 @@\n-        if (passed) logln(output); else errln(output);\n+        if (passed) System.out.println(output); else fail(output);\n@@ -287,0 +292,1 @@\n+    @Test\n@@ -290,1 +296,1 @@\n-            logln(\"Skipping this test because locale is \" + locale);\n+            System.out.println(\"Skipping this test because locale is \" + locale);\n@@ -316,1 +322,1 @@\n-            errln(\"We're not in Daylight Savings Time and we should be.\\n\");\n+            fail(\"We're not in Daylight Savings Time and we should be.\\n\");\n@@ -333,1 +339,1 @@\n-            errln(\"Offsets should not match when in DST\");\n+            fail(\"Offsets should not match when in DST\");\n@@ -341,0 +347,1 @@\n+    @Test\n@@ -354,1 +361,1 @@\n-                logln(hname + ' ' + ids.length +\n+                System.out.println(hname + ' ' + ids.length +\n@@ -357,1 +364,1 @@\n-                errln(hname + ' ' + \"Fail: \" + e);\n+                fail(hname + ' ' + \"Fail: \" + e);\n@@ -360,1 +367,1 @@\n-        logln(\"Maximum zones per offset = \" + max);\n+        System.out.println(\"Maximum zones per offset = \" + max);\n@@ -363,0 +370,1 @@\n+    @Test\n@@ -368,1 +376,1 @@\n-            errln(\"IllegalArgumentException not thrown by TimeZone.getDisplayName()\");\n+            fail(\"IllegalArgumentException not thrown by TimeZone.getDisplayName()\");\n@@ -376,0 +384,1 @@\n+    @Test\n@@ -407,1 +416,1 @@\n-                        logln(\"Pass: DST savings of \" + savings + \" accepted by \" + method);\n+                        System.out.println(\"Pass: DST savings of \" + savings + \" accepted by \" + method);\n@@ -409,1 +418,1 @@\n-                        errln(\"Fail: DST savings of \" + savings + \" accepted by \" + method);\n+                        fail(\"Fail: DST savings of \" + savings + \" accepted by \" + method);\n@@ -413,1 +422,1 @@\n-                        errln(\"Fail: DST savings of \" + savings + \" to \" + method + \" gave \" + e);\n+                        fail(\"Fail: DST savings of \" + savings + \" to \" + method + \" gave \" + e);\n@@ -415,1 +424,1 @@\n-                        logln(\"Pass: DST savings of \" + savings + \" to \" + method + \" gave \" + e);\n+                        System.out.println(\"Pass: DST savings of \" + savings + \" to \" + method + \" gave \" + e);\n@@ -426,0 +435,1 @@\n+    @Test\n@@ -438,1 +448,1 @@\n-            errln(\"Test is broken -- rewrite it\");\n+            fail(\"Test is broken -- rewrite it\");\n@@ -441,1 +451,1 @@\n-            errln(\"Fail: hasSameRules() broken for zones with rules\");\n+            fail(\"Fail: hasSameRules() broken for zones with rules\");\n@@ -444,3 +454,3 @@\n-            errln(\"Fail: hasSameRules() returns false for zones without rules\");\n-            errln(\"zone 1 = \" + tz1);\n-            errln(\"zone 2 = \" + tz2);\n+            fail(\"Fail: hasSameRules() returns false for zones without rules\");\n+            fail(\"zone 1 = \" + tz1);\n+            fail(\"zone 2 = \" + tz2);\n@@ -454,0 +464,1 @@\n+    @Test\n@@ -499,1 +510,1 @@\n-                errln(\"setStartRule(month=\" + month + \", day=\" + day +\n+                fail(\"setStartRule(month=\" + month + \", day=\" + day +\n@@ -512,1 +523,1 @@\n-                errln(\"setEndRule(month=\" + month + \", day=\" + day +\n+                fail(\"setEndRule(month=\" + month + \", day=\" + day +\n@@ -527,1 +538,1 @@\n-                errln(\"SimpleTimeZone(month=\" + month + \", day=\" + day +\n+                fail(\"SimpleTimeZone(month=\" + month + \", day=\" + day +\n@@ -542,1 +553,1 @@\n-                errln(\"SimpleTimeZone(<start>, month=\" + month + \", day=\" + day +\n+                fail(\"SimpleTimeZone(<start>, month=\" + month + \", day=\" + day +\n@@ -553,0 +564,1 @@\n+    @Test\n@@ -597,1 +609,1 @@\n-                errln(\"Fail: getOffset(\" +\n+                fail(\"Fail: getOffset(\" +\n@@ -608,0 +620,1 @@\n+    @Test\n@@ -615,1 +628,1 @@\n-            errln(\"FAIL: Null allowed in getTimeZone\");\n+            fail(\"FAIL: Null allowed in getTimeZone\");\n@@ -620,1 +633,1 @@\n-            errln(\"FAIL: Null allowed in getDisplayName(3)\");\n+            fail(\"FAIL: Null allowed in getDisplayName(3)\");\n@@ -624,1 +637,1 @@\n-            errln(\"FAIL: Null allowed in getDisplayName(1)\");\n+            fail(\"FAIL: Null allowed in getDisplayName(1)\");\n@@ -628,1 +641,1 @@\n-                errln(\"FAIL: hasSameRules returned true\");\n+                fail(\"FAIL: hasSameRules returned true\");\n@@ -631,1 +644,1 @@\n-            errln(\"FAIL: Null NOT allowed in hasSameRules\");\n+            fail(\"FAIL: Null NOT allowed in hasSameRules\");\n@@ -635,1 +648,1 @@\n-            errln(\"FAIL: Null allowed in inDaylightTime\");\n+            fail(\"FAIL: Null allowed in inDaylightTime\");\n@@ -639,1 +652,1 @@\n-            errln(\"FAIL: Null allowed in setID\");\n+            fail(\"FAIL: Null allowed in setID\");\n@@ -646,1 +659,1 @@\n-            errln(\"FAIL: Null NOT allowed in setDefault\");\n+            fail(\"FAIL: Null NOT allowed in setDefault\");\n@@ -655,1 +668,1 @@\n-            errln(\"FAIL: Null allowed in SimpleTimeZone(2)\");\n+            fail(\"FAIL: Null allowed in SimpleTimeZone(2)\");\n@@ -659,1 +672,1 @@\n-            errln(\"FAIL: Null allowed in SimpleTimeZone(10)\");\n+            fail(\"FAIL: Null allowed in SimpleTimeZone(10)\");\n@@ -663,1 +676,1 @@\n-            errln(\"FAIL: Null allowed in SimpleTimeZone(11)\");\n+            fail(\"FAIL: Null allowed in SimpleTimeZone(11)\");\n@@ -672,0 +685,1 @@\n+    @Test\n@@ -714,1 +728,1 @@\n-                logln(tz.getID() + \":\");\n+                System.out.println(tz.getID() + \":\");\n@@ -717,1 +731,1 @@\n-                    logln(\"\" + i + \": \" + d);\n+                    System.out.println(\"\" + i + \": \" + d);\n@@ -723,1 +737,1 @@\n-                    logln(\"Ok: transition \" + transitionExpected);\n+                    System.out.println(\"Ok: transition \" + transitionExpected);\n@@ -725,1 +739,1 @@\n-                    errln(\"Fail: boundary transition incorrect\");\n+                    fail(\"Fail: boundary transition incorrect\");\n@@ -739,0 +753,1 @@\n+    @Test\n@@ -751,1 +766,1 @@\n-            errln(\"Offsets should be the same (for PST), but got: \" +\n+            fail(\"Offsets should be the same (for PST), but got: \" +\n@@ -770,2 +785,2 @@\n-                logln(t.getTime() + \"  \" + t.get(Calendar.DST_OFFSET));\n-                logln(cal.getTime() + \"  \" + (lastDST=cal.get(Calendar.DST_OFFSET)));\n+                System.out.println(t.getTime() + \"  \" + t.get(Calendar.DST_OFFSET));\n+                System.out.println(cal.getTime() + \"  \" + (lastDST=cal.get(Calendar.DST_OFFSET)));\n@@ -775,1 +790,1 @@\n-            errln(\"Saw \" + transitions + \" transitions; should have seen 4\");\n+            fail(\"Saw \" + transitions + \" transitions; should have seen 4\");\n@@ -783,0 +798,1 @@\n+    @Test\n@@ -830,1 +846,1 @@\n-                errln(\"FAIL: \" + DATA[i] + \" -> \" + DATA[i+1] + \", exp \" + DATA[i+2]);\n+                fail(\"FAIL: \" + DATA[i] + \" -> \" + DATA[i+1] + \", exp \" + DATA[i+2]);\n@@ -838,0 +854,1 @@\n+    @Test\n@@ -842,1 +859,1 @@\n-            errln(\"Failed. No exception has been thrown for DOM -1 startDay\");\n+            fail(\"Failed. No exception has been thrown for DOM -1 startDay\");\n@@ -844,1 +861,1 @@\n-            logln(\"(a) \" + e.getMessage());\n+            System.out.println(\"(a) \" + e.getMessage());\n@@ -848,1 +865,1 @@\n-            errln(\"Failed. No exception has been thrown for DOM -1 endDay\");\n+            fail(\"Failed. No exception has been thrown for DOM -1 endDay\");\n@@ -850,1 +867,1 @@\n-            logln(\"(b) \" + e.getMessage());\n+            System.out.println(\"(b) \" + e.getMessage());\n@@ -854,1 +871,1 @@\n-            errln(\"Failed. No exception has been thrown for DOM -1 startDay +savings\");\n+            fail(\"Failed. No exception has been thrown for DOM -1 startDay +savings\");\n@@ -856,1 +873,1 @@\n-            logln(\"(c) \" + e.getMessage());\n+            System.out.println(\"(c) \" + e.getMessage());\n@@ -860,1 +877,1 @@\n-            errln(\"Failed. No exception has been thrown for DOM -1 endDay +savings\");\n+            fail(\"Failed. No exception has been thrown for DOM -1 endDay +savings\");\n@@ -862,1 +879,1 @@\n-            logln(\"(d) \" + e.getMessage());\n+            System.out.println(\"(d) \" + e.getMessage());\n@@ -868,1 +885,1 @@\n-            errln(\"Failed. No exception has been thrown for DOM -1 setStartRule +savings\");\n+            fail(\"Failed. No exception has been thrown for DOM -1 setStartRule +savings\");\n@@ -870,1 +887,1 @@\n-            logln(\"(e) \" + e.getMessage());\n+            System.out.println(\"(e) \" + e.getMessage());\n@@ -874,1 +891,1 @@\n-            errln(\"Failed. No exception has been thrown for DOM -1 setStartRule\");\n+            fail(\"Failed. No exception has been thrown for DOM -1 setStartRule\");\n@@ -876,1 +893,1 @@\n-            logln(\"(f) \" + e.getMessage());\n+            System.out.println(\"(f) \" + e.getMessage());\n@@ -880,1 +897,1 @@\n-            errln(\"Failed. No exception has been thrown for DOM -1 setEndRule +savings\");\n+            fail(\"Failed. No exception has been thrown for DOM -1 setEndRule +savings\");\n@@ -882,1 +899,1 @@\n-            logln(\"(g) \" + e.getMessage());\n+            System.out.println(\"(g) \" + e.getMessage());\n@@ -886,1 +903,1 @@\n-            errln(\"Failed. No exception has been thrown for DOM -1 setEndRule\");\n+            fail(\"Failed. No exception has been thrown for DOM -1 setEndRule\");\n@@ -888,1 +905,1 @@\n-            logln(\"(h) \" + e.getMessage());\n+            System.out.println(\"(h) \" + e.getMessage());\n@@ -896,0 +913,1 @@\n+    @Test\n@@ -908,1 +926,1 @@\n-            errln(\"FAILED: to get TimeZone.getOffset(2\/29\/96)\");\n+            fail(\"FAILED: to get TimeZone.getOffset(2\/29\/96)\");\n@@ -913,1 +931,1 @@\n-            errln(\"FAILED: TimeZone.getOffset(2\/29\/97) expected to throw Exception.\");\n+            fail(\"FAILED: TimeZone.getOffset(2\/29\/97) expected to throw Exception.\");\n@@ -915,1 +933,1 @@\n-            logln(\"got IllegalArgumentException\");\n+            System.out.println(\"got IllegalArgumentException\");\n@@ -924,0 +942,1 @@\n+    @Test\n@@ -948,1 +967,1 @@\n-                errln(\"wrong hour of day: got: \" + hourOfDay\n+                fail(\"wrong hour of day: got: \" + hourOfDay\n@@ -959,0 +978,1 @@\n+    @Test\n@@ -977,1 +997,1 @@\n-            errln(\"Should still be in DST.\");\n+            fail(\"Should still be in DST.\");\n","filename":"test\/jdk\/java\/util\/TimeZone\/TimeZoneRegression.java","additions":101,"deletions":81,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @library \/java\/text\/testlib\n@@ -32,1 +31,1 @@\n- * @run main TimeZoneTest -verbose\n+ * @run junit TimeZoneTest\n@@ -40,1 +39,5 @@\n-public class TimeZoneTest extends IntlTest\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class TimeZoneTest\n@@ -44,4 +47,0 @@\n-    public static void main(String[] args) throws Exception {\n-        new TimeZoneTest().run(args);\n-    }\n-\n@@ -103,0 +102,1 @@\n+    @Test\n@@ -157,1 +157,1 @@\n-                logln(\"ok \" + referenceZone);\n+                System.out.println(\"ok \" + referenceZone);\n@@ -160,1 +160,1 @@\n-                errln(\"Fail: Expected \" + referenceZone +\n+                fail(\"Fail: Expected \" + referenceZone +\n@@ -244,0 +244,1 @@\n+    @Test\n@@ -274,1 +275,1 @@\n-                logln(id + \" -> generic GMT\");\n+                System.out.println(id + \" -> generic GMT\");\n@@ -286,1 +287,1 @@\n-                logln(id + \" -> \" + zone.getID() + \" GMT\" + offset);\n+                System.out.println(id + \" -> \" + zone.getID() + \" GMT\" + offset);\n@@ -313,0 +314,1 @@\n+    @Test\n@@ -316,1 +318,1 @@\n-        logln(\"PST->\" + name);\n+        System.out.println(\"PST->\" + name);\n@@ -318,1 +320,1 @@\n-            errln(\"Fail: Expected \\\"Pacific Standard Time\\\"\");\n+            fail(\"Fail: Expected \\\"Pacific Standard Time\\\"\");\n@@ -337,1 +339,1 @@\n-                errln(\"Fail: Expected \" + DATA[i+2] + \"; got \" + name);\n+                fail(\"Fail: Expected \" + DATA[i+2] + \"; got \" + name);\n@@ -345,1 +347,1 @@\n-        logln(\"Modified PST inDaylightTime->\" + zone2.inDaylightTime(new Date()));\n+        System.out.println(\"Modified PST inDaylightTime->\" + zone2.inDaylightTime(new Date()));\n@@ -347,1 +349,1 @@\n-        logln(\"Modified PST->\" + name);\n+        System.out.println(\"Modified PST->\" + name);\n@@ -349,1 +351,1 @@\n-            errln(\"Fail: Expected \\\"Pacific Standard Time\\\"\");\n+            fail(\"Fail: Expected \\\"Pacific Standard Time\\\"\");\n@@ -360,1 +362,1 @@\n-        logln(\"PST(zh_CN)->\" + name);\n+        System.out.println(\"PST(zh_CN)->\" + name);\n@@ -372,1 +374,1 @@\n-            logln(\"Warning: Not testing the zh_CN behavior because resource is absent\");\n+            System.out.println(\"Warning: Not testing the zh_CN behavior because resource is absent\");\n@@ -374,1 +376,1 @@\n-                errln(\"Fail: Expected Pacific Standard Time\");\n+                fail(\"Fail: Expected Pacific Standard Time\");\n@@ -383,4 +385,4 @@\n-            errln(\"Fail: Expected GMT-08:00 or something similar\");\n-            errln(\"************************************************************\");\n-            errln(\"THE ABOVE FAILURE MAY JUST MEAN THE LOCALE DATA HAS CHANGED\");\n-            errln(\"************************************************************\");\n+            fail(\"Fail: Expected GMT-08:00 or something similar\\n\"\n+            + \"************************************************************\\n\"\n+            + \"THE ABOVE FAILURE MAY JUST MEAN THE LOCALE DATA HAS CHANGED\\n\"\n+            + \"************************************************************\\n\");\n@@ -392,1 +394,1 @@\n-        logln(\"GMT+90min->\" + name);\n+        System.out.println(\"GMT+90min->\" + name);\n@@ -397,1 +399,1 @@\n-            errln(\"Fail: Expected GMT+01:30 or something similar\");\n+            fail(\"Fail: Expected GMT+01:30 or something similar\");\n@@ -400,0 +402,1 @@\n+    @Test\n@@ -406,1 +409,1 @@\n-            errln(\"FAIL: useDaylightTime should return false\");\n+            fail(\"FAIL: useDaylightTime should return false\");\n@@ -411,1 +414,1 @@\n-            errln(\"FAIL: clone or operator== failed\");\n+            fail(\"FAIL: clone or operator== failed\");\n@@ -415,1 +418,1 @@\n-            errln(\"FAIL: clone or operator!= failed\");\n+            fail(\"FAIL: clone or operator!= failed\");\n@@ -420,1 +423,1 @@\n-            errln(\"FAIL: clone or operator== failed\");\n+            fail(\"FAIL: clone or operator== failed\");\n@@ -424,1 +427,1 @@\n-            errln(\"FAIL: clone or operator!= failed\");\n+            fail(\"FAIL: clone or operator!= failed\");\n@@ -432,1 +435,1 @@\n-                errln(\"FAIL: Default object is identical, not clone\");\n+                fail(\"FAIL: Default object is identical, not clone\");\n@@ -435,1 +438,1 @@\n-                errln(\"FAIL: Default object is not equal\");\n+                fail(\"FAIL: Default object is not equal\");\n@@ -444,0 +447,1 @@\n+    @Test\n@@ -450,1 +454,1 @@\n-        if (zone.useDaylightTime()) errln(\"FAIL: useDaylightTime should return false\");\n+        if (zone.useDaylightTime()) fail(\"FAIL: useDaylightTime should return false\");\n@@ -478,1 +482,1 @@\n-            errln(\"FAIL: Expected start computed as \" + marchOne +\n+            fail(\"FAIL: Expected start computed as \" + marchOne +\n@@ -480,1 +484,1 @@\n-            logln(\"      Should be                  \" + expMarchOne +\n+            System.out.println(\"      Should be                  \" + expMarchOne +\n@@ -487,1 +491,1 @@\n-            errln(\"FAIL: Expected start computed as \" + julyOne +\n+            fail(\"FAIL: Expected start computed as \" + julyOne +\n@@ -489,1 +493,1 @@\n-            logln(\"      Should be                  \" + expJulyOne +\n+            System.out.println(\"      Should be                  \" + expJulyOne +\n@@ -500,1 +504,1 @@\n-            errln(\"FAIL: Start rule broken\");\n+            fail(\"FAIL: Start rule broken\");\n@@ -503,1 +507,1 @@\n-            errln(\"FAIL: End rule broken\");\n+            fail(\"FAIL: End rule broken\");\n@@ -508,1 +512,1 @@\n-            errln(\"FAIL: Start year broken\");\n+            fail(\"FAIL: Start year broken\");\n@@ -521,1 +525,1 @@\n-            logln(\"Error: inDaylightTime(\" + new Date(max) + \") != \" + (!startsInDST));\n+            System.out.println(\"Error: inDaylightTime(\" + new Date(max) + \") != \" + (!startsInDST));\n@@ -535,2 +539,2 @@\n-        logln(\"Binary Search Before: \" + min + \" = \" + new Date(min));\n-        logln(\"Binary Search After:  \" + max + \" = \" + new Date(max));\n+        System.out.println(\"Binary Search Before: \" + min + \" = \" + new Date(min));\n+        System.out.println(\"Binary Search After:  \" + max + \" = \" + new Date(max));\n@@ -543,1 +547,1 @@\n-            logln(\"PASS: Expected bdry:  \" + expectedBoundary + \" = \" + new Date(expectedBoundary));\n+            System.out.println(\"PASS: Expected bdry:  \" + expectedBoundary + \" = \" + new Date(expectedBoundary));\n@@ -545,1 +549,1 @@\n-            errln(\"FAIL: Expected bdry:  \" + expectedBoundary + \" = \" + new Date(expectedBoundary));\n+            fail(\"FAIL: Expected bdry:  \" + expectedBoundary + \" = \" + new Date(expectedBoundary));\n@@ -551,0 +555,1 @@\n+    @Test\n@@ -555,1 +560,1 @@\n-            errln( \"FAIL: TimeZone(PRT) is null\" );\n+            fail( \"FAIL: TimeZone(PRT) is null\" );\n@@ -559,1 +564,1 @@\n-                errln(\"FAIL: Offset for PRT should be -4\");\n+                fail(\"FAIL: Offset for PRT should be -4\");\n@@ -566,0 +571,1 @@\n+    @Test\n@@ -571,1 +577,1 @@\n-        logln(\"The timezone is \" + time_zone.getID());\n+        System.out.println(\"The timezone is \" + time_zone.getID());\n@@ -574,1 +580,1 @@\n-            errln(\"FAIL: inDaylightTime returned false\");\n+            fail(\"FAIL: inDaylightTime returned false\");\n@@ -577,1 +583,1 @@\n-            errln(\"FAIL: useDaylightTime returned false\");\n+            fail(\"FAIL: useDaylightTime returned false\");\n@@ -580,1 +586,1 @@\n-            errln( \"FAIL: getRawOffset returned wrong value\");\n+            fail( \"FAIL: getRawOffset returned wrong value\");\n@@ -588,1 +594,1 @@\n-            errln(\"FAIL: getOffset returned wrong value\");\n+            fail(\"FAIL: getOffset returned wrong value\");\n@@ -592,0 +598,1 @@\n+    @Test\n@@ -602,1 +609,1 @@\n-        logln(buf.toString());\n+        System.out.println(buf.toString());\n@@ -613,1 +620,1 @@\n-        logln(buf.toString());\n+        System.out.println(buf.toString());\n@@ -617,1 +624,1 @@\n-            logln(\"getTimeZone(PST) = \" + tz.getID());\n+            System.out.println(\"getTimeZone(PST) = \" + tz.getID());\n@@ -619,1 +626,1 @@\n-            errln(\"FAIL: getTimeZone(PST) = null\");\n+            fail(\"FAIL: getTimeZone(PST) = null\");\n@@ -623,1 +630,1 @@\n-            logln(\"getTimeZone(America\/Los_Angeles) = \" + tz.getID());\n+            System.out.println(\"getTimeZone(America\/Los_Angeles) = \" + tz.getID());\n@@ -625,1 +632,1 @@\n-            errln(\"FAIL: getTimeZone(PST) = null\");\n+            fail(\"FAIL: getTimeZone(PST) = null\");\n@@ -630,1 +637,1 @@\n-            errln(\"FAIL: getTimeZone(NON_EXISTENT) = null\");\n+            fail(\"FAIL: getTimeZone(NON_EXISTENT) = null\");\n@@ -632,1 +639,1 @@\n-            errln(\"FAIL: getTimeZone(NON_EXISTENT) = \" + tz.getID());\n+            fail(\"FAIL: getTimeZone(NON_EXISTENT) = \" + tz.getID());\n@@ -638,0 +645,1 @@\n+    @Test\n@@ -647,1 +655,1 @@\n-            errln(\"Got back a raw offset of \" + (tz.getRawOffset() \/ millisPerHour) +\n+            fail(\"Got back a raw offset of \" + (tz.getRawOffset() \/ millisPerHour) +\n@@ -650,1 +658,1 @@\n-            errln(\"Test time zone should use DST but claims it doesn't.\");\n+            fail(\"Test time zone should use DST but claims it doesn't.\");\n@@ -652,1 +660,1 @@\n-            errln(\"Set DST offset to 0.5 hour, but got back \" + (tz.getDSTSavings() \/\n+            fail(\"Set DST offset to 0.5 hour, but got back \" + (tz.getDSTSavings() \/\n@@ -658,1 +666,1 @@\n-            errln(\"The offset for 10 AM, 1\/1\/98 should have been -5 hours, but we got \"\n+            fail(\"The offset for 10 AM, 1\/1\/98 should have been -5 hours, but we got \"\n@@ -664,1 +672,1 @@\n-            errln(\"The offset for 10 AM, 6\/1\/98 should have been -4.5 hours, but we got \"\n+            fail(\"The offset for 10 AM, 6\/1\/98 should have been -4.5 hours, but we got \"\n@@ -671,1 +679,1 @@\n-            errln(\"The offset for 10 AM, 1\/1\/98 should have been -5 hours, but we got \"\n+            fail(\"The offset for 10 AM, 1\/1\/98 should have been -5 hours, but we got \"\n@@ -677,1 +685,1 @@\n-            errln(\"The offset for 10 AM, 6\/1\/98 (with a 1-hour DST offset) should have been -4 hours, but we got \"\n+            fail(\"The offset for 10 AM, 6\/1\/98 (with a 1-hour DST offset) should have been -4 hours, but we got \"\n@@ -684,0 +692,1 @@\n+    @Test\n@@ -698,1 +707,1 @@\n-            errln(\"The offset for 10AM, 3\/5\/98 should have been -5 hours, but we got \"\n+            fail(\"The offset for 10AM, 3\/5\/98 should have been -5 hours, but we got \"\n@@ -704,1 +713,1 @@\n-            errln(\"The offset for 10AM, 3\/15\/98 should have been -4 hours, but we got \"\n+            fail(\"The offset for 10AM, 3\/15\/98 should have been -4 hours, but we got \"\n@@ -710,1 +719,1 @@\n-            errln(\"The offset for 10AM, 10\/15\/98 should have been -4 hours, but we got \"\n+            fail(\"The offset for 10AM, 10\/15\/98 should have been -4 hours, but we got \"\n@@ -716,1 +725,1 @@\n-            errln(\"The offset for 10AM, 10\/25\/98 should have been -5 hours, but we got \"\n+            fail(\"The offset for 10AM, 10\/25\/98 should have been -5 hours, but we got \"\n@@ -726,1 +735,1 @@\n-            errln(\"The offset for 10AM, 3\/11\/98 should have been -5 hours, but we got \"\n+            fail(\"The offset for 10AM, 3\/11\/98 should have been -5 hours, but we got \"\n@@ -732,1 +741,1 @@\n-            errln(\"The offset for 10AM, 3\/14\/98 should have been -4 hours, but we got \"\n+            fail(\"The offset for 10AM, 3\/14\/98 should have been -4 hours, but we got \"\n@@ -738,1 +747,1 @@\n-            errln(\"The offset for 10AM, 10\/15\/98 should have been -4 hours, but we got \"\n+            fail(\"The offset for 10AM, 10\/15\/98 should have been -4 hours, but we got \"\n@@ -744,1 +753,1 @@\n-            errln(\"The offset for 10AM, 10\/17\/98 should have been -5 hours, but we got \"\n+            fail(\"The offset for 10AM, 10\/17\/98 should have been -5 hours, but we got \"\n","filename":"test\/jdk\/java\/util\/TimeZone\/TimeZoneTest.java","additions":85,"deletions":76,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @library \/java\/text\/testlib\n@@ -29,0 +28,1 @@\n+ * @run junit TransitionTest\n@@ -39,1 +39,1 @@\n-public class TransitionTest extends IntlTest {\n+import org.junit.jupiter.api.Test;\n@@ -41,3 +41,3 @@\n-    public static void main(String[] args) throws Exception {\n-        new TransitionTest().run(args);\n-    }\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class TransitionTest {\n@@ -45,0 +45,1 @@\n+    @Test\n@@ -80,1 +81,1 @@\n-            errln(\"Wrong DST transition: \" + tz\n+            fail(\"Wrong DST transition: \" + tz\n@@ -91,0 +92,1 @@\n+    @Test\n@@ -124,1 +126,1 @@\n-            errln(\"test#1: wrong offset: got \"+offset+\", expected=\"+expectedOffset);\n+            fail(\"test#1: wrong offset: got \"+offset+\", expected=\"+expectedOffset);\n@@ -153,1 +155,1 @@\n-            errln(\"Wrong offset: got \"+offset+\", expected=\"+expectedOffset);\n+            fail(\"Wrong offset: got \"+offset+\", expected=\"+expectedOffset);\n@@ -182,1 +184,1 @@\n-            errln(\"test#2: wrong offset: got \"+offset+\", expected=\"+expectedOffset);\n+            fail(\"test#2: wrong offset: got \"+offset+\", expected=\"+expectedOffset);\n@@ -212,1 +214,1 @@\n-            errln(\"test#3: wrong offset: got \"+offset+\", expected=\"+expectedOffset);\n+            fail(\"test#3: wrong offset: got \"+offset+\", expected=\"+expectedOffset);\n@@ -246,1 +248,1 @@\n-            errln(\"test#4: wrong offset: got \"+offset+\", expected=\"+expectedOffset);\n+            fail(\"test#4: wrong offset: got \"+offset+\", expected=\"+expectedOffset);\n@@ -275,1 +277,1 @@\n-            errln(\"test#5: wrong offset: got \"+offset+\", expected=\"+expectedOffset);\n+            fail(\"test#5: wrong offset: got \"+offset+\", expected=\"+expectedOffset);\n","filename":"test\/jdk\/java\/util\/TimeZone\/TransitionTest.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -605,1 +605,0 @@\n-            SystemTest.suite(),\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/JSR166TestCase.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * This file is available under and governed by the GNU General Public\n- * License version 2 only, as published by the Free Software Foundation.\n- * However, the following notice accompanied the original version of this\n- * file:\n- *\n- * Written by Doug Lea with assistance from members of JCP JSR-166\n- * Expert Group and released to the public domain, as explained at\n- * http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/\n- * Other contributors include Andrew Wright, Jeffrey Hayes,\n- * Pat Fisher, Mike Judd.\n- *\/\n-\n-import junit.framework.Test;\n-import junit.framework.TestSuite;\n-\n-public class SystemTest extends JSR166TestCase {\n-    public static void main(String[] args) {\n-        main(suite(), args);\n-    }\n-\n-    public static Test suite() {\n-        return new TestSuite(SystemTest.class);\n-    }\n-\n-    \/**\n-     * Worst case rounding for millisecs; set for 60 cycle millis clock.\n-     * This value might need to be changed on JVMs with coarser\n-     * System.currentTimeMillis clocks.\n-     *\/\n-    static final long MILLIS_ROUND = 17;\n-\n-    \/**\n-     * Nanos between readings of millis is no longer than millis (plus\n-     * possible rounding), and vice versa.\n-     * This shows only that nano timing not (much) worse than milli.\n-     *\/\n-    public void testNanoTime() throws InterruptedException {\n-        long m0 = System.currentTimeMillis();\n-        long n0 = System.nanoTime();\n-        Thread.sleep(1);\n-        long m1 = System.currentTimeMillis();\n-        long n1 = System.nanoTime();\n-        Thread.sleep(50);       \/\/ avoid possibly scaled SHORT_DELAY_MS\n-        long m2 = System.currentTimeMillis();\n-        long n2 = System.nanoTime();\n-        Thread.sleep(1);\n-        long m3 = System.currentTimeMillis();\n-        long n3 = System.nanoTime();\n-        assertTrue((n2 - n1) \/ 1_000_000 <= m3 - m0 + MILLIS_ROUND);\n-        assertTrue(m2 - m1 <= (n3 - n0) \/ 1_000_000 + MILLIS_ROUND);\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/SystemTest.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,3 +23,0 @@\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n@@ -27,1 +24,9 @@\n-import java.io.*;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.charset.StandardCharsets;\n@@ -30,1 +35,0 @@\n-import java.util.List;\n@@ -35,1 +39,2 @@\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n@@ -39,2 +44,3 @@\n- * @bug 8226530\n- * @summary ZIP File System tests that leverage DirectoryStream\n+ * @bug 8226530 8303891\n+ * @summary Verify that ZipFile reads size fields using the Zip64 extra\n+ * field when only the 'uncompressed size' field has the ZIP64 \"magic value\" 0xFFFFFFFF\n@@ -42,1 +48,1 @@\n- * @run testng Zip64SizeTest\n+ * @run junit Zip64SizeTest\n@@ -45,2 +51,0 @@\n-\n-    private static final int BUFFER_SIZE = 2048;\n@@ -48,10 +52,9 @@\n-    private static final String ZIP_FILE_NAME = \"Zip64SizeTest.zip\";\n-    \/\/ File that will be created with a size greater than 0xFFFFFFFF\n-    private static final String LARGE_FILE_NAME = \"LargeZipEntry.txt\";\n-    \/\/ File that will be created with a size less than 0xFFFFFFFF\n-    private static final String SMALL_FILE_NAME = \"SmallZipEntry.txt\";\n-    \/\/ List of files to be added to the ZIP file\n-    private static final List<String> ZIP_ENTRIES = List.of(LARGE_FILE_NAME,\n-            SMALL_FILE_NAME);\n-    private static final long LARGE_FILE_SIZE = 5L * 1024L * 1024L * 1024L; \/\/ 5GB\n-    private static final long SMALL_FILE_SIZE = 0x100000L; \/\/ 1024L x 1024L;\n+    private static final Path ZIP_FILE = Path.of(\"Zip64SizeTest.zip\");\n+    \/\/ Contents to write to ZIP entries\n+    private static final byte[] CONTENT = \"Hello\".getBytes(StandardCharsets.UTF_8);\n+    \/\/ This opaque tag will be ignored by ZipEntry.setExtra0\n+    private static final int UNKNOWN_TAG = 0x9902;\n+    \/\/ Tag used when converting the extra field to a real ZIP64 extra field\n+    private static final short ZIP64_TAG = 0x1;\n+    \/\/ Marker value to indicate that the actual value is stored in the ZIP64 extra field\n+    private static final int ZIP64_MAGIC_VALUE = 0xFFFFFFFF;\n@@ -60,3 +63,4 @@\n-     * Validate that if the size of a ZIP entry exceeds 0xFFFFFFFF, that the\n-     * correct size is returned from the ZIP64 Extended information.\n-     * @throws IOException\n+     * Validate that if the 'uncompressed size' of a ZIP CEN header is 0xFFFFFFFF, then the\n+     * actual size is retrieved from the corresponding ZIP64 Extended information field.\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n@@ -65,2 +69,1 @@\n-    private static void validateZipEntrySizes() throws IOException {\n-        createFiles();\n+    public void validateZipEntrySizes() throws IOException {\n@@ -69,2 +72,2 @@\n-        try (ZipFile zip = new ZipFile(ZIP_FILE_NAME)) {\n-            ZipEntry ze = zip.getEntry(LARGE_FILE_NAME);\n+        try (ZipFile zip = new ZipFile(ZIP_FILE.toFile())) {\n+            ZipEntry ze = zip.getEntry(\"first\");\n@@ -72,2 +75,2 @@\n-            assertTrue(ze.getSize() == LARGE_FILE_SIZE);\n-            ze = zip.getEntry(SMALL_FILE_NAME);\n+            assertEquals(CONTENT.length, ze.getSize());\n+            ze = zip.getEntry(\"second\");\n@@ -75,2 +78,1 @@\n-            assertTrue(ze.getSize() == SMALL_FILE_SIZE);\n-\n+            assertEquals(CONTENT.length, ze.getSize());\n@@ -81,2 +83,22 @@\n-     * Delete the files created for use by the test\n-     * @throws IOException if an error occurs deleting the files\n+     * Create a ZIP file with a CEN entry where the 'uncompressed size' is stored in\n+     * the ZIP64 field, but the 'compressed size' is in the CEN field. This makes the\n+     * ZIP64 data block 8 bytes long, which triggers the regression described in 8226530.\n+     *\n+     * The CEN entry for the \"first\" entry will have the following structure:\n+     * (Note the CEN 'Uncompressed Length' being 0xFFFFFFFF and the ZIP64\n+     * 'Uncompressed Size' being 5)\n+     *\n+     * 0081 CENTRAL HEADER #1     02014B50\n+     * 0085 Created Zip Spec      14 '2.0'\n+     * 0086 Created OS            00 'MS-DOS'\n+     * [...] Omitted for brevity\n+     * 0091 CRC                   F7D18982\n+     * 0095 Compressed Length     00000007\n+     * 0099 Uncompressed Length   FFFFFFFF\n+     * [...] Omitted for brevity\n+     * 00AF Filename              'first'\n+     * 00B4 Extra ID #0001        0001 'ZIP64'\n+     * 00B6   Length              0008\n+     * 00B8   Uncompressed Size   0000000000000005\n+     *\n+     * @throws IOException if an error occurs creating the ZIP File\n@@ -84,4 +106,28 @@\n-    private static void deleteFiles() throws IOException {\n-        Files.deleteIfExists(Path.of(ZIP_FILE_NAME));\n-        Files.deleteIfExists(Path.of(LARGE_FILE_NAME));\n-        Files.deleteIfExists(Path.of(SMALL_FILE_NAME));\n+    private static void createZipFile() throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (ZipOutputStream zos = new ZipOutputStream(baos)) {\n+\n+            \/\/ The 'first' entry will store 'uncompressed size' in the Zip64 format\n+            ZipEntry e1 = new ZipEntry(\"first\");\n+\n+            \/\/ Make an extra field with the correct size for an 8-byte 'uncompressed size'\n+            \/\/ Zip64 field. Temporarily use the 'unknown' tag 0x9902 to make\n+            \/\/ ZipEntry.setExtra0 skip parsing this as a Zip64.\n+            \/\/ See APPNOTE.TXT, 4.6.1 Third Party Mappings\n+            byte[] opaqueExtra = createBlankExtra((short) UNKNOWN_TAG, (short) Long.BYTES);\n+            e1.setExtra(opaqueExtra);\n+\n+            zos.putNextEntry(e1);\n+            zos.write(CONTENT);\n+\n+            \/\/ A second entry, not in Zip64 format\n+            ZipEntry e2 = new ZipEntry(\"second\");\n+            zos.putNextEntry(e2);\n+            zos.write(CONTENT);\n+        }\n+\n+        byte[] zip = baos.toByteArray();\n+\n+        \/\/ Update the CEN of 'first' to use the Zip64 format\n+        updateCENHeaderToZip64(zip);\n+        Files.write(ZIP_FILE, zip);\n@@ -91,2 +137,9 @@\n-     * Create the ZIP file adding an entry whose size exceeds 0xFFFFFFFF\n-     * @throws IOException if an error occurs creating the ZIP File\n+     * Update the CEN entry of the \"first\" entry to use ZIP64 format for the\n+     * 'uncompressed size' field. The updated extra field will have the following\n+     * structure:\n+     *\n+     * 00B4 Extra ID #0001        0001 'ZIP64'\n+     * 00B6   Length              0008\n+     * 00B8   Uncompressed Size   0000000000000005\n+     *\n+     * @param zip the ZIP file to update to ZIP64\n@@ -94,19 +147,18 @@\n-    private static void createZipFile() throws IOException {\n-        try (FileOutputStream fos = new FileOutputStream(ZIP_FILE_NAME);\n-             ZipOutputStream zos = new ZipOutputStream(fos)) {\n-            System.out.printf(\"Creating Zip file: %s%n\", ZIP_FILE_NAME);\n-            for (String srcFile : ZIP_ENTRIES) {\n-                System.out.printf(\"...Adding Entry: %s%n\", srcFile);\n-                File fileToZip = new File(srcFile);\n-                try (FileInputStream fis = new FileInputStream(fileToZip)) {\n-                    ZipEntry zipEntry = new ZipEntry(fileToZip.getName());\n-                    zipEntry.setSize(fileToZip.length());\n-                    zos.putNextEntry(zipEntry);\n-                    byte[] bytes = new byte[BUFFER_SIZE];\n-                    int length;\n-                    while ((length = fis.read(bytes)) >= 0) {\n-                        zos.write(bytes, 0, length);\n-                    }\n-                }\n-            }\n-        }\n+    private static void updateCENHeaderToZip64(byte[] zip) {\n+        ByteBuffer buffer = ByteBuffer.wrap(zip).order(ByteOrder.LITTLE_ENDIAN);\n+        \/\/ Find the offset of the first CEN header\n+        int cenOffset = buffer.getInt(zip.length- ZipFile.ENDHDR + ZipFile.ENDOFF);\n+        \/\/ Find the offset of the extra field\n+        int nlen = buffer.getShort(cenOffset + ZipFile.CENNAM);\n+        int extraOffset = cenOffset + ZipFile.CENHDR + nlen;\n+\n+        \/\/ Change the header ID from 'unknown' to ZIP64\n+        buffer.putShort(extraOffset, ZIP64_TAG);\n+        \/\/ Update the 'uncompressed size' ZIP64 value to the actual uncompressed length\n+        int fieldOffset = extraOffset\n+                + Short.BYTES \/\/ TAG\n+                + Short.BYTES; \/\/ data size\n+        buffer.putLong(fieldOffset, CONTENT.length);\n+\n+        \/\/ Set the 'uncompressed size' field of the CEN to 0xFFFFFFFF\n+        buffer.putInt(cenOffset + ZipFile.CENLEN, ZIP64_MAGIC_VALUE);\n@@ -116,2 +168,5 @@\n-     * Create the files that will be added to the ZIP file\n-     * @throws IOException if there is a problem  creating the files\n+     * Create an extra field with the given tag and data block size, and a\n+     * blank data block.\n+     * @return an extra field with the specified tag and size\n+     * @param tag the header id of the extra field\n+     * @param blockSize the size of the extra field's data block\n@@ -119,8 +174,10 @@\n-    private static void createFiles() throws IOException {\n-        try (RandomAccessFile largeFile = new RandomAccessFile(LARGE_FILE_NAME, \"rw\");\n-             RandomAccessFile smallFile = new RandomAccessFile(SMALL_FILE_NAME, \"rw\")) {\n-            System.out.printf(\"Creating %s%n\", LARGE_FILE_NAME);\n-            largeFile.setLength(LARGE_FILE_SIZE);\n-            System.out.printf(\"Creating %s%n\", SMALL_FILE_NAME);\n-            smallFile.setLength(SMALL_FILE_SIZE);\n-        }\n+    private static byte[] createBlankExtra(short tag, short blockSize) {\n+        int size = Short.BYTES  \/\/ tag\n+                + Short.BYTES   \/\/ data block size\n+                + blockSize;   \/\/ data block;\n+\n+        byte[] extra = new byte[size];\n+        ByteBuffer.wrap(extra).order(ByteOrder.LITTLE_ENDIAN)\n+                .putShort(0, tag)\n+                .putShort(Short.BYTES, blockSize);\n+        return extra;\n@@ -133,1 +190,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -142,1 +199,1 @@\n-    @AfterMethod\n+    @AfterEach\n@@ -146,0 +203,8 @@\n+\n+    \/**\n+     * Delete the files created for use by the test\n+     * @throws IOException if an error occurs deleting the files\n+     *\/\n+    private static void deleteFiles() throws IOException {\n+        Files.deleteIfExists(ZIP_FILE);\n+    }\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/Zip64SizeTest.java","additions":137,"deletions":72,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -30,1 +31,0 @@\n-import java.nio.file.Path;\n@@ -51,0 +51,2 @@\n+    private static final int READ_TIMEOUT_SECS = Integer.getInteger(\"readtimeout\", 30);\n+\n@@ -66,14 +68,36 @@\n-            try (DTLSServer server = new DTLSServer(args[0])) {\n-                List<String> command = List.of(\n-                        Path.of(System.getProperty(\"java.home\"), \"bin\", \"java\").toString(),\n-                        \"DTLSWontNegotiateV10\",\n-                        \/\/ if server is \"DTLS\" then the client should be v1.0 and vice versa\n-                        args[0].equals(DTLS) ? DTLSV_1_0 : DTLS,\n-                        Integer.toString(server.getListeningPortNumber())\n-                );\n-\n-                ProcessBuilder builder = new ProcessBuilder(command);\n-                Process p = builder.inheritIO().start();\n-                server.run();\n-                p.destroy();\n-                System.out.println(\"Success: DTLSv1.0 connection was not established.\");\n+            final int totalAttempts = 5;\n+            int tries;\n+            for (tries = 0 ; tries < totalAttempts ; ++tries) {\n+                try {\n+                    System.out.printf(\"Starting server %d\/%d attempts%n\", tries+1, totalAttempts);\n+                    runServer(args[0]);\n+                    break;\n+                } catch (SocketTimeoutException exc) {\n+                    System.out.println(\"The server timed-out waiting for packets from the client.\");\n+                }\n+            }\n+            if (tries == totalAttempts) {\n+                throw new RuntimeException(\"The server\/client communications timed-out after \" + totalAttempts + \" tries.\");\n+            }\n+        }\n+    }\n+\n+    private static void runServer(String protocol) throws Exception {\n+        \/\/ args: protocol\n+        Process clientProcess = null;\n+        try (DTLSServer server = new DTLSServer(protocol)) {\n+            List<String> command = List.of(\n+                    \"DTLSWontNegotiateV10\",\n+                    \/\/ if server is \"DTLS\" then the client should be v1.0 and vice versa\n+                    protocol.equals(DTLS) ? DTLSV_1_0 : DTLS,\n+                    Integer.toString(server.getListeningPortNumber())\n+            );\n+\n+            ProcessBuilder builder = ProcessTools.createTestJavaProcessBuilder(command);\n+            clientProcess = builder.inheritIO().start();\n+            server.run();\n+            System.out.println(\"Success: DTLSv1.0 connection was not established.\");\n+\n+        } finally {\n+            if (clientProcess != null) {\n+                clientProcess.destroy();\n@@ -92,0 +116,3 @@\n+            socket.setSoTimeout(READ_TIMEOUT_SECS * 1000);\n+            log(\"Client listening on port \" + socket.getLocalPort()\n+                    + \". Sending data to server port \" + remotePort);\n@@ -290,0 +317,2 @@\n+            socket.setSoTimeout(READ_TIMEOUT_SECS * 1000);\n+            log(\"Server listening on port: \" + socket.getLocalPort());\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/DTLSWontNegotiateV10.java","additions":45,"deletions":16,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,2 @@\n+import jdk.test.lib.process.ProcessTools;\n+\n@@ -28,1 +30,0 @@\n-import java.nio.file.Path;\n@@ -35,0 +36,1 @@\n+ * @library \/test\/lib\n@@ -45,0 +47,1 @@\n+ * @library \/test\/lib\n@@ -64,1 +67,0 @@\n-                        Path.of(System.getProperty(\"java.home\"), \"bin\", \"java\").toString(),\n@@ -70,1 +72,1 @@\n-                ProcessBuilder builder = new ProcessBuilder(command);\n+                ProcessBuilder builder = ProcessTools.createTestJavaProcessBuilder(command);\n","filename":"test\/jdk\/javax\/net\/ssl\/ciphersuites\/TLSWontNegotiateDisabledCipherAlgos.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 7001133\n+ * @summary OutOfMemoryError by CustomMediaSizeName implementation\n+ * @run main CustomMediaSizeNameOOMETest\n+ * @run main\/timeout=300\/othervm -Xmx8m CustomMediaSizeNameOOMETest\n+*\/\n+\n+import javax.print.PrintService;\n+import javax.print.PrintServiceLookup;\n+\n+public class CustomMediaSizeNameOOMETest {\n+\n+    private static final int MILLIS = 3000;\n+\n+    public static void main(String[] args) {\n+\n+        PrintService[] services = PrintServiceLookup.lookupPrintServices(null, null);\n+        if (services == null || services.length == 0) {\n+            return;\n+        }\n+\n+        for (PrintService service : services) {\n+            service.getUnsupportedAttributes(null, null);\n+        }\n+\n+        long time = System.currentTimeMillis() + MILLIS;\n+\n+        do {\n+            for (int i = 0; i < 2000; i++) {\n+                for (PrintService service : services) {\n+                    service.getAttributes();\n+                }\n+            }\n+        } while (time > System.currentTimeMillis());\n+    }\n+}\n","filename":"test\/jdk\/javax\/print\/CustomMediaSizeNameOOMETest.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+ * @library \/test\/lib\/\n@@ -36,0 +37,2 @@\n+import jdk.test.lib.Asserts;\n+\n@@ -39,2 +42,2 @@\n-import java.net.ServerSocket;\n-import java.net.Socket;\n+import java.lang.ref.Reference;\n+import java.rmi.ConnectIOException;\n@@ -43,1 +46,0 @@\n-import java.rmi.server.RMIClientSocketFactory;\n@@ -53,1 +55,1 @@\n-        public String sayHello() throws RemoteException;\n+        String sayHello() throws RemoteException;\n@@ -56,9 +58,1 @@\n-    public class HelloImpl extends UnicastRemoteObject implements Hello {\n-\n-        public HelloImpl(int port,\n-                         RMIClientSocketFactory csf,\n-                         RMIServerSocketFactory ssf)\n-            throws RemoteException {\n-            super(port, csf, ssf);\n-        }\n-\n+    public class HelloImpl implements Hello {\n@@ -68,61 +62,0 @@\n-\n-        public Remote runServer() throws IOException {\n-            System.out.println(\"Inside HelloImpl::runServer\");\n-            \/\/ Get a remote stub for this RMI object\n-            \/\/\n-            Remote stub = toStub(this);\n-            System.out.println(\"Stub = \" + stub);\n-            return stub;\n-        }\n-    }\n-\n-    public class HelloClient {\n-\n-        public void runClient(Remote stub) throws IOException {\n-            System.out.println(\"Inside HelloClient::runClient\");\n-            \/\/ \"obj\" is the identifier that we'll use to refer\n-            \/\/ to the remote object that implements the \"Hello\"\n-            \/\/ interface\n-            Hello obj = (Hello) stub;\n-            String message = obj.sayHello();\n-            System.out.println(message);\n-        }\n-    }\n-\n-    public static class ClientFactory extends SslRMIClientSocketFactory {\n-\n-        public ClientFactory() {\n-            super();\n-        }\n-\n-        public Socket createSocket(String host, int port) throws IOException {\n-            System.out.println(\"ClientFactory::Calling createSocket(\" +\n-                               host + \",\" + port + \")\");\n-            return super.createSocket(host, port);\n-        }\n-    }\n-\n-    public static class ServerFactory extends SslRMIServerSocketFactory {\n-\n-        public ServerFactory() {\n-            super();\n-        }\n-\n-        public ServerFactory(String[] ciphers,\n-                             String[] protocols,\n-                             boolean need) {\n-            super(ciphers, protocols, need);\n-        }\n-\n-        public ServerFactory(SSLContext context,\n-                             String[] ciphers,\n-                             String[] protocols,\n-                             boolean need) {\n-            super(context, ciphers, protocols, need);\n-        }\n-\n-        public ServerSocket createServerSocket(int port) throws IOException {\n-            System.out.println(\"ServerFactory::Calling createServerSocket(\" +\n-                               port + \")\");\n-            return super.createServerSocket(port);\n-        }\n@@ -131,3 +64,4 @@\n-    public void testRmiCommunication(RMIServerSocketFactory serverFactory, boolean expectException) {\n-\n-        HelloImpl server = null;\n+    public void testRmiCommunication(RMIServerSocketFactory serverSocketFactory) throws Exception {\n+        HelloImpl server = new HelloImpl();\n+        Hello stub = (Hello)UnicastRemoteObject.exportObject(server,\n+                0, new SslRMIClientSocketFactory(), serverSocketFactory);\n@@ -135,17 +69,4 @@\n-            server = new HelloImpl(0,\n-                                    new ClientFactory(),\n-                                    serverFactory);\n-            Remote stub = server.runServer();\n-            HelloClient client = new HelloClient();\n-            client.runClient(stub);\n-            if (expectException) {\n-                throw new RuntimeException(\"Test completed without throwing an expected exception.\");\n-            }\n-\n-        } catch (IOException exc) {\n-            if (!expectException) {\n-                throw new RuntimeException(\"An error occurred during test execution\", exc);\n-            } else {\n-                System.out.println(\"Caught expected exception: \" + exc);\n-            }\n-\n+            String msg = stub.sayHello();\n+            Asserts.assertEquals(\"Hello World!\", msg);\n+        } finally {\n+            Reference.reachabilityFence(server);\n@@ -155,3 +76,2 @@\n-    private static void testServerFactory(String[] cipherSuites, String[] protocol, String expectedMessage) throws Exception {\n-        try {\n-            new ServerFactory(SSLContext.getDefault(),\n+    private static void testSslServerSocketFactory(String[] cipherSuites, String[] protocol) throws Exception {\n+        new SslRMIServerSocketFactory(SSLContext.getDefault(),\n@@ -159,9 +79,0 @@\n-            throw new RuntimeException(\n-                    \"The expected exception for \"+ expectedMessage + \" was not thrown.\");\n-        } catch (IllegalArgumentException exc) {\n-            \/\/ expecting an exception with a specific message\n-            \/\/ anything else is an error\n-            if (!exc.getMessage().toLowerCase().contains(expectedMessage)) {\n-                throw exc;\n-            }\n-        }\n@@ -175,1 +86,2 @@\n-            case 1 -> testRmiCommunication(new ServerFactory(), false);\n+            case 1 ->\n+                testRmiCommunication(new SslRMIServerSocketFactory());\n@@ -178,1 +90,2 @@\n-            case 2 -> testRmiCommunication(new ServerFactory(null, null, false), false);\n+            case 2 ->\n+                testRmiCommunication(new SslRMIServerSocketFactory(null, null, false));\n@@ -181,1 +94,2 @@\n-            case 3 -> testRmiCommunication(new ServerFactory(null, null, null, true), false);\n+            case 3 ->\n+                testRmiCommunication(new SslRMIServerSocketFactory(null, null, null, true));\n@@ -184,2 +98,7 @@\n-            case 4 ->\n-                testServerFactory(new String[]{\"dummy_ciphersuite\"}, null, \"unsupported ciphersuite\");\n+            case 4 -> {\n+                Exception exc = Asserts.assertThrows(IllegalArgumentException.class,\n+                        () -> testSslServerSocketFactory(new String[]{\"dummy_ciphersuite\"}, null));\n+                if (!exc.getMessage().toLowerCase().contains(\"unsupported ciphersuite\")) {\n+                    throw exc;\n+                }\n+            }\n@@ -188,2 +107,7 @@\n-            case 5 ->\n-                testServerFactory(null, new String[]{\"dummy_protocol\"}, \"unsupported protocol\");\n+            case 5 -> {\n+                Exception thrown = Asserts.assertThrows(IllegalArgumentException.class,\n+                        () -> testSslServerSocketFactory(null, new String[]{\"dummy_protocol\"}));\n+                if (!thrown.getMessage().toLowerCase().contains(\"unsupported protocol\")) {\n+                    throw thrown;\n+                }\n+            }\n@@ -195,1 +119,2 @@\n-                testRmiCommunication(new ServerFactory(), true);\n+                Asserts.assertThrows(ConnectIOException.class,\n+                        () -> testRmiCommunication(new SslRMIServerSocketFactory()));\n@@ -202,1 +127,2 @@\n-                testRmiCommunication(new ServerFactory(), true);\n+                Asserts.assertThrows(ConnectIOException.class,\n+                        () -> testRmiCommunication(new SslRMIServerSocketFactory()));\n","filename":"test\/jdk\/javax\/rmi\/ssl\/SSLSocketParametersTest.java","additions":41,"deletions":115,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,3 @@\n+import org.junit.jupiter.api.Test;\n+\n+import javax.script.ScriptEngineFactory;\n@@ -25,0 +28,3 @@\n+import java.util.Optional;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -26,0 +32,8 @@\n+\/*\n+ * @test\n+ * @bug 8196959 8320712\n+ * @summary Verify that ScriptEngineManager can load BadFactory without throwing NPE\n+ * @build BadFactory BadFactoryTest\n+ * @run junit\/othervm BadFactoryTest\n+ * @run junit\/othervm -Djava.security.manager=allow BadFactoryTest\n+ *\/\n@@ -27,1 +41,5 @@\n-    public static void main(String[] args) {\n+\n+    @Test\n+    public void scriptEngineManagerShouldLoadBadFactory() {\n+        \/\/ Check that ScriptEngineManager initializes even in the\n+        \/\/ presence of a ScriptEngineFactory returning nulls\n@@ -29,0 +47,6 @@\n+\n+        \/\/ Sanity check that ScriptEngineManager actually found the BadFactory\n+        Optional<ScriptEngineFactory> badFactory = m.getEngineFactories().stream()\n+                .filter(fac -> fac.getClass() == BadFactory.class)\n+                .findAny();\n+        assertTrue(badFactory.isPresent(), \"BadFactory not found\");\n","filename":"test\/jdk\/javax\/script\/JDK_8196959\/BadFactoryTest.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1,60 +0,0 @@\n-#\n-# Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# @test\n-# @bug 8196959\n-# @summary BadFactory that results in NPE being thrown from ScriptEngineManager\n-#\n-# @build BadFactory BadFactoryTest\n-# @run shell BadFactoryTest.sh\n-\n-if [ \"${TESTSRC}\" = \"\" ]\n-then\n-  echo \"TESTSRC not set.  Test cannot execute.  Failed.\"\n-  exit 1\n-fi\n-\n-. ${TESTSRC}\/..\/CommonSetup.sh\n-\n-echo \"Creating JAR file ...\"\n-\n-$JAR ${TESTTOOLVMOPTS} -cf ${TESTCLASSES}\/badfactory.jar \\\n-    -C ${TESTCLASSES} BadFactory.class \\\n-    -C ${TESTCLASSES} BadFactoryTest.class \\\n-    -C \"${TESTSRC}\" META-INF\/services\/javax.script.ScriptEngineFactory\n-\n-echo \"Running test with security manager ...\"\n-$JAVA ${TESTVMOPTS} -Djava.security.manager -classpath \\\n-  \"${TESTCLASSES}${PS}${TESTCLASSES}\/badfactory.jar\" \\\n-  BadFactoryTest\n-\n-ret=$?\n-if [ $ret -ne 0 ]\n-then\n-  exit $ret\n-fi\n-\n-echo \"Running test without security manager ...\"\n-$JAVA ${TESTVMOPTS} -classpath \\\n-  \"${TESTCLASSES}${PS}${TESTCLASSES}\/badfactory.jar\" \\\n-  BadFactoryTest\n","filename":"test\/jdk\/javax\/script\/JDK_8196959\/BadFactoryTest.sh","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/DE1.gif","binary":true,"status":"deleted"},{"filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/DI1.gif","binary":true,"status":"deleted"},{"filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/DS1.gif","binary":true,"status":"deleted"},{"filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/PR1.gif","binary":true,"status":"deleted"},{"filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/RO1.gif","binary":true,"status":"deleted"},{"filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/RS1.gif","binary":true,"status":"deleted"},{"filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/SE1.gif","binary":true,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,8 +24,4 @@\n-\/* @test\n-   @bug 5049549 7132413\n-   @summary Tests that the proper icon is used for different states.\n-   @library ..\/..\/regtesthelpers\n-   @build Blocker\n-   @run main\/manual bug5049549\n-*\/\n-\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Graphics;\n+import java.awt.image.BufferedImage;\n@@ -42,0 +38,8 @@\n+\/*\n+ * @test\n+ * @bug 5049549 7132413\n+ * @summary Tests that the proper icon is used for different states.\n+ * @library ..\/..\/regtesthelpers\n+ * @build Blocker\n+ * @run main\/manual bug5049549\n+ *\/\n@@ -44,7 +48,7 @@\n-    private static ImageIcon DE = new ImageIcon(bug5049549.class.getResource(\"DE1.gif\"));\n-    private static ImageIcon DI = new ImageIcon(bug5049549.class.getResource(\"DI1.gif\"));\n-    private static ImageIcon DS = new ImageIcon(bug5049549.class.getResource(\"DS1.gif\"));\n-    private static ImageIcon RO = new ImageIcon(bug5049549.class.getResource(\"RO1.gif\"));\n-    private static ImageIcon RS = new ImageIcon(bug5049549.class.getResource(\"RS1.gif\"));\n-    private static ImageIcon SE = new ImageIcon(bug5049549.class.getResource(\"SE1.gif\"));\n-    private static ImageIcon PR = new ImageIcon(bug5049549.class.getResource(\"PR1.gif\"));\n+    private static final Icon DE = generateImage(\"DE\");\n+    private static final Icon DI = generateImage(\"DI\");\n+    private static final Icon DS = generateImage(\"DS\");\n+    private static final Icon RO = generateImage(\"RO\");\n+    private static final Icon RS = generateImage(\"RS\");\n+    private static final Icon SE = generateImage(\"SE\");\n+    private static final Icon PR = generateImage(\"PR\");\n@@ -52,1 +56,15 @@\n-    private static Blocker blocker = new Blocker();\n+    private static final Blocker blocker = new Blocker();\n+\n+    private static Icon generateImage(String str) {\n+        BufferedImage img = new BufferedImage(40, 30,\n+                BufferedImage.TYPE_INT_RGB);\n+        Graphics g = img.createGraphics();\n+        g.setColor(Color.WHITE);\n+        g.fillRect(0, 0, img.getWidth(), img.getHeight());\n+        g.setColor(Color.RED);\n+        Font font = new Font(Font.SANS_SERIF, Font.BOLD, 22);\n+        g.setFont(font);\n+        g.drawString(str, 5, 25);\n+        g.dispose();\n+        return new ImageIcon(img);\n+    }\n","filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/bug5049549.java","additions":35,"deletions":17,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4859570\n+ * @summary SwingUtilities.sharedOwnerFrame is never disposed\n+ * @key headful\n+ *\/\n+\n+import java.awt.Robot;\n+import java.awt.Window;\n+import javax.swing.JDialog;\n+import javax.swing.SwingUtilities;\n+\n+public class bug4859570 {\n+    static Window owner;\n+\n+    public static void main(String[] args) throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            JDialog dialog = new JDialog();\n+            dialog.setTitle(\"bug4859570\");\n+            dialog.setBounds(100, 100, 100, 100);\n+            dialog.setVisible(true);\n+\n+            owner = dialog.getOwner();\n+            dialog.dispose();\n+        });\n+\n+        Robot r = new Robot();\n+        r.waitForIdle();\n+        r.delay(1000);\n+\n+        SwingUtilities.invokeAndWait(() -> {\n+            if (owner.isDisplayable()) {\n+                throw new RuntimeException(\"The shared owner frame should be disposed.\");\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JDialog\/bug4859570.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4936652\n+ * @key headful\n+ * @summary JDialog.setVisible, JDialog.dispose works incorrectly\n+ *\/\n+\n+import javax.swing.JDialog;\n+import javax.swing.SwingUtilities;\n+\n+public class bug4936652 {\n+    public static void main(String[] args) throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            for (int i = 0 ; i < 100; i++) {\n+                System.out.println(\"i: \" + i);\n+                JDialog o = new JDialog();\n+                o.setTitle(\"bug4936652\");\n+                o.setVisible(true);\n+                o.setVisible(false);\n+                o.dispose();\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JDialog\/bug4936652.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4624353\n+ * @summary Tests that Motif FileChooser is not able to show control buttons\n+ * @key headful\n+ * @run main bug4624353\n+ *\/\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import javax.swing.JButton;\n+import javax.swing.JFileChooser;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+public class bug4624353 {\n+    static volatile boolean passed = true;\n+    static JFrame fr;\n+    static JFileChooser fc;\n+\n+    public static void main(String args[]) throws Exception {\n+        UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.motif.MotifLookAndFeel\");\n+\n+        try {\n+            SwingUtilities.invokeAndWait(() -> {\n+                fr = new JFrame(\"bug4624353\");\n+                fc = new JFileChooser();\n+                fc.setControlButtonsAreShown(false);\n+                fr.getContentPane().add(fc);\n+                fr.pack();\n+                fr.setVisible(true);\n+\n+                passAround(fc);\n+            });\n+            if (!passed) {\n+                throw new RuntimeException(\"Test failed\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (fr != null) {\n+                    fr.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    public static void passAround(Container c) {\n+        Component[] list = c.getComponents();\n+        if (list.length == 0) {\n+            return;\n+        }\n+        for (int i = 0; i < list.length; i++) {\n+            if (list[i] != null) {\n+                if ((list[i] instanceof JButton) &&\n+                        \"OK\".equals(((JButton)list[i]).getText())) {\n+                    passed = false;\n+                    return;\n+                }\n+                passAround((Container)list[i]);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/bug4624353.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4673161\n+ * @requires (os.family == \"windows\")\n+ * @summary Tests if JFileChooser preferred size depends on selected files\n+ * @run main bug4673161\n+ *\/\n+\n+import java.awt.Dimension;\n+import java.io.File;\n+import javax.swing.JFileChooser;\n+import javax.swing.UIManager;\n+\n+public class bug4673161 {\n+\n+  public static void main(String[] args) throws Exception {\n+    JFileChooser fc = new JFileChooser();\n+    Dimension d = fc.getPreferredSize();\n+    JFileChooser fc2 = new JFileChooser();\n+    File[] files = new File[50];\n+    for (int i = 0; i < 50; i++) {\n+      files[i] = new File(\"file\" + i);\n+    }\n+    fc2.setSelectedFiles(files);\n+    Dimension d2 = fc2.getPreferredSize();\n+    if (!d.equals(d2)) {\n+      throw new RuntimeException(\"Test failed: JFileChooser preferred \" +\n+              \"size depends on selected files\");\n+    }\n+\n+    UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\");\n+\n+    JFileChooser fc3 = new JFileChooser();\n+    d = fc3.getPreferredSize();\n+    fc2 = new JFileChooser();\n+    files = new File[50];\n+    for (int i = 0; i < 50; i++) {\n+      files[i] = new File(\"file\" + i);\n+    }\n+    fc2.setSelectedFiles(files);\n+    d2 = fc2.getPreferredSize();\n+    if (!d.equals(d2)) {\n+      throw new RuntimeException(\"Test failed: JFileChooser preferred \" +\n+              \"size depends on selected files\");\n+    }\n+  }\n+}\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/bug4673161.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4782168\n+ * @summary Tests if DefaultShellFolder.isHidden() crashes for the\n+           root folder on Solaris\n+ * @modules java.desktop\/sun.awt.shell\n+ * @run main bug4782168\n+ *\/\n+\n+public class bug4782168 {\n+\n+    public static void main(String args[]) throws Exception {\n+        sun.awt.shell.ShellFolder sf = sun.awt.shell.ShellFolder.\n+                getShellFolder(new java.io.File(\"\/\"));\n+        sf.isHidden();\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/bug4782168.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4741926\n+ * @summary JFormattedTextField\/JSpinner always consumes certain key events\n+ * @key headful\n+ * @run main bug4741926\n+ *\/\n+\n+import java.awt.Robot;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.KeyEvent;\n+import java.util.Date;\n+import javax.swing.AbstractAction;\n+import javax.swing.InputMap;\n+import javax.swing.JComponent;\n+import javax.swing.JFormattedTextField;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.KeyStroke;\n+import javax.swing.SwingUtilities;\n+\n+public class bug4741926 {\n+\n+    static MyFormattedTextField ftf;\n+    static JFrame fr;\n+    static Robot robot;\n+    static volatile boolean passed_enter = false;\n+    static volatile boolean passed_escape = false;\n+    static volatile boolean ftfFocused = false;\n+    static volatile boolean keyProcessed = false;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        try {\n+            robot = new Robot();\n+            robot.setAutoDelay(100);\n+            SwingUtilities.invokeAndWait(() -> {\n+                fr = new JFrame(\"Test\");\n+                ftf = new MyFormattedTextField();\n+                ftf.setValue(\"JFormattedTextField\");\n+                JPanel p = (JPanel) fr.getContentPane();\n+                p.add(ftf);\n+                ftf.addFocusListener(new FocusAdapter() {\n+                    public void focusGained(FocusEvent e) {\n+                        ftfFocused = true;\n+                    }\n+                });\n+                InputMap map = p.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);\n+\n+                map.put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0),\n+                        \"enter-action\");\n+                p.getActionMap().put(\"enter-action\", new AbstractAction() {\n+                    public void actionPerformed(ActionEvent e) {\n+                        passed_enter = true;\n+                        keyProcessed = true;\n+                    }\n+                });\n+                map.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0),\n+                        \"escape-action\");\n+                p.getActionMap().put(\"escape-action\", new AbstractAction() {\n+                    public void actionPerformed(ActionEvent e) {\n+                        passed_escape = true;\n+                        keyProcessed = true;\n+                    }\n+                });\n+                fr.pack();\n+                fr.setLocationRelativeTo(null);\n+                fr.setVisible(true);\n+            });\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            test();\n+            if (!(passed_enter && passed_escape)) {\n+                throw new RuntimeException(\"JFormattedTextField consume \" +\n+                        \"Enter\/Escape key event\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (fr != null) {\n+                    fr.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    public static void test() throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            ftf.requestFocus();\n+        });\n+        robot.delay(500);\n+        doTest(KeyEvent.VK_ENTER);\n+        doTest(KeyEvent.VK_ESCAPE);\n+    }\n+\n+    static void doTest(int keyCode) throws InterruptedException {\n+        keyProcessed = false;\n+        KeyEvent key = new KeyEvent(ftf, KeyEvent.KEY_PRESSED,\n+                                    new Date().getTime(), 0,\n+                                    keyCode,\n+                                    KeyEvent.CHAR_UNDEFINED);\n+        ftf.processKey(key);\n+    }\n+\n+    static class MyFormattedTextField extends JFormattedTextField {\n+        public void processKey(KeyEvent e) {\n+            processKeyEvent(e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JFormattedTextField\/bug4741926.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4863121\n+ * @summary JFormattedTextField's NotifyAction should invoke invalidEdit if\n+   commit fails\n+ * @key headful\n+ * @run main bug4863121\n+ *\/\n+\n+import java.awt.Robot;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.KeyEvent;\n+import java.text.Format;\n+import java.text.DecimalFormat;\n+import javax.swing.JFormattedTextField;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+\n+public class bug4863121 {\n+\n+    static TestFormattedTextField ftf;\n+    static JFrame fr;\n+    static Robot robot;\n+\n+    private static volatile boolean focused = false;\n+    private static volatile boolean passed = false;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            robot = new Robot();\n+            robot.setAutoDelay(100);\n+            SwingUtilities.invokeAndWait(() -> {\n+                fr = new JFrame(\"Test\");\n+                ftf = new TestFormattedTextField(new DecimalFormat(\"####\"));\n+                ftf.setText(\"q\");\n+                fr.getContentPane().add(ftf);\n+\n+                ftf.addFocusListener(new FocusAdapter() {\n+                    public void focusGained(FocusEvent e) {\n+                        focused = true;\n+                    }\n+                });\n+                fr.pack();\n+                fr.setLocationRelativeTo(null);\n+                fr.setVisible(true);\n+            });\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            SwingUtilities.invokeAndWait(() -> {\n+                ftf.requestFocus();\n+            });\n+            robot.waitForIdle();\n+            robot.delay(500);\n+            robot.keyPress(KeyEvent.VK_ENTER);\n+            robot.keyRelease(KeyEvent.VK_ENTER);\n+            if (!passed) {\n+                throw new RuntimeException(\"JFormattedTextField's NotifyAction \" +\n+                        \"should invoke invalidEdit if commit fails\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (fr != null) {\n+                    fr.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    public static class TestFormattedTextField extends JFormattedTextField {\n+        public TestFormattedTextField(Format f) {\n+            super(f);\n+        }\n+        protected void invalidEdit() {\n+            passed = true;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JFormattedTextField\/bug4863121.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4886538\n+ * @summary JFormattedTextField not returning correct value (class)\n+ * @run main bug4886538\n+ *\/\n+\n+import javax.swing.JFormattedTextField;\n+import javax.swing.SwingUtilities;\n+import javax.swing.text.DefaultFormatterFactory;\n+\n+public class bug4886538 {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ test default display formatter\n+        TestFormattedTextField field = new TestFormattedTextField(0.0);\n+        field.setFormatter(((DefaultFormatterFactory) field.\n+                getFormatterFactory()).getDisplayFormatter());\n+        field.setText(\"10\");\n+        field.commitEdit();\n+\n+        Object dblValue = field.getValue();\n+        if (!(dblValue instanceof Double)) {\n+            throw new RuntimeException(\"The JFormattedTextField's value \" +\n+                    \"should be instanceof Double\");\n+        }\n+\n+        \/\/ test default editor formatter\n+        field = new TestFormattedTextField(0.0);\n+        field.setFormatter(((DefaultFormatterFactory) field.\n+                getFormatterFactory()).getEditFormatter());\n+        field.setText(\"10\");\n+        field.commitEdit();\n+\n+        dblValue = field.getValue();\n+        if (!(dblValue instanceof Double)) {\n+            throw new RuntimeException(\"The JFormattedTextField's value \" +\n+                    \"should be instanceof Double\");\n+        }\n+\n+    }\n+\n+    static class TestFormattedTextField extends JFormattedTextField {\n+        public TestFormattedTextField(Object value) {\n+            super(value);\n+        }\n+        public void setFormatter(JFormattedTextField.AbstractFormatter formatter) {\n+            super.setFormatter(formatter);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/swing\/JFormattedTextField\/bug4886538.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4768127\n+ * @summary ToolTipManager not removed from components\n+ * @key headful\n+ *\/\n+\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseMotionListener;\n+import javax.swing.JDesktopPane;\n+import javax.swing.JFrame;\n+import javax.swing.JInternalFrame;\n+import javax.swing.JLabel;\n+import javax.swing.SwingUtilities;\n+import javax.swing.ToolTipManager;\n+\n+public class bug4768127 {\n+    static JFrame fr;\n+    static volatile Point p;\n+    static volatile JLabel[] label = new JLabel[2];\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            SwingUtilities.invokeAndWait(() -> {\n+                fr = new JFrame(\"bug4768127\");\n+\n+                JDesktopPane jdp = new JDesktopPane();\n+                JInternalFrame jif1 = new JInternalFrame(\"jif 1\");\n+                JInternalFrame jif2 = new JInternalFrame(\"jif 2\");\n+                label[0] = new JLabel(\"Label 1\");\n+                label[1] = new JLabel(\"Label 2\");\n+\n+                label[0].setToolTipText(\"tooltip 1\");\n+                jif1.getContentPane().add(label[0]);\n+                jif1.setBounds(0, 0, 130, 160);\n+                jif1.setVisible(true);\n+                jdp.add(jif1);\n+\n+                label[1].setToolTipText(\"tooltip 2\");\n+                jif2.getContentPane().add(label[1]);\n+                jif2.setBounds(210, 0, 130, 220);\n+                jif2.setVisible(true);\n+                jdp.add(jif2);\n+\n+                fr.getContentPane().add(jdp);\n+                fr.setLocationRelativeTo(null);\n+\n+                fr.setSize(400, 300);\n+                fr.setVisible(true);\n+            });\n+\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(10);\n+            robot.waitForIdle();\n+            robot.delay(3000);\n+\n+            clickLabel(0, robot);\n+            robot.waitForIdle();\n+            robot.delay(3000);\n+\n+            clickLabel(1, robot);\n+            robot.waitForIdle();\n+            robot.delay(3000);\n+\n+            clickLabel(0, robot);\n+            robot.waitForIdle();\n+            robot.delay(3000);\n+\n+            clickLabel(1, robot);\n+            robot.waitForIdle();\n+            robot.delay(3000);\n+\n+            MouseMotionListener[] mml = label[0].getMouseMotionListeners();\n+            if (mml.length > 0 && mml[0] instanceof ToolTipManager) {\n+                throw new RuntimeException(\"Extra MouseMotionListeners were added to the label \\\"Label 1\\\" by ToolTipManager\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (fr != null) {\n+                    fr.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    static void clickLabel(int i, Robot robot) throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            p = label[i].getLocationOnScreen();\n+        });\n+        final Rectangle rect = label[i].getBounds();\n+        robot.mouseMove(p.x + rect.width \/ 2, p.y + rect.height \/ 2);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+        \/\/Generate mouseMotionEvent\n+        robot.mouseMove(p.x + rect.width \/ 2 + 3, p.y + rect.height \/ 2 + 3);\n+        robot.mouseMove(p.x + rect.width \/ 2, p.y + rect.height \/ 2);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JLabel\/bug4768127.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4822331\n+ * @summary setLaberFor does not transfer focus to the JSpinner editor\n+ * @library \/test\/lib\n+ * @key headful\n+ * @run main bug4822331\n+ *\/\n+\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.KeyEvent;\n+import java.awt.FlowLayout;\n+import java.awt.Robot;\n+import javax.swing.JButton;\n+import javax.swing.JFormattedTextField;\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JSpinner;\n+import javax.swing.SwingUtilities;\n+import jdk.test.lib.Platform;\n+\n+public class bug4822331 {\n+\n+    static JFrame fr;\n+    static JButton button;\n+    static JSpinner spinner;\n+    static volatile boolean tfFocused = false;\n+    static volatile boolean passed = false;\n+\n+    public static void main(String []args) throws Exception {\n+        bug4822331 test = new bug4822331();\n+        test.init();\n+    }\n+\n+    public void init() throws Exception {\n+        try {\n+            SwingUtilities.invokeAndWait(() -> {\n+                fr = new JFrame(\"Test\");\n+                fr.getContentPane().setLayout(new FlowLayout());\n+\n+                button = new JButton(\"Button\");\n+                fr.getContentPane().add(button);\n+\n+                spinner = new JSpinner();\n+                JLabel spinnerLabel = new JLabel(\"spinner\");\n+                spinnerLabel.setDisplayedMnemonic(KeyEvent.VK_S);\n+                spinnerLabel.setLabelFor(spinner);\n+                fr.getContentPane().add(spinnerLabel);\n+                fr.getContentPane().add(spinner);\n+\n+                JSpinner.DefaultEditor editor =\n+                        (JSpinner.DefaultEditor) spinner.getEditor();\n+                JFormattedTextField ftf = editor.getTextField();\n+                ftf.addFocusListener(new FocusAdapter() {\n+                    public void focusGained(FocusEvent e) {\n+                        passed = true;\n+                    }\n+                });\n+                fr.pack();\n+                fr.setVisible(true);\n+            });\n+            start();\n+            if ( !passed ) {\n+                throw new RuntimeException(\"The activation of spinner's \" +\n+                        \"mnemonic didn't focus the editor component.\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (fr != null) {\n+                    fr.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    public void start() throws Exception {\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(50);\n+        robot.delay(1000);\n+        robot.waitForIdle();\n+        button.requestFocus();\n+        if (Platform.isOSX()) {\n+            robot.keyPress(KeyEvent.VK_CONTROL);\n+            robot.keyPress(KeyEvent.VK_ALT);\n+            robot.keyPress(KeyEvent.VK_S);\n+            robot.keyRelease(KeyEvent.VK_S);\n+            robot.keyRelease(KeyEvent.VK_ALT);\n+            robot.keyRelease(KeyEvent.VK_CONTROL);\n+        } else {\n+            robot.keyPress(KeyEvent.VK_ALT);\n+            robot.keyPress(KeyEvent.VK_S);\n+            robot.keyRelease(KeyEvent.VK_S);\n+            robot.keyRelease(KeyEvent.VK_ALT);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JLabel\/bug4822331.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4143592\n+ * @summary Tests the method add(Component, int) of JMenu for insertion\n+            the given component to a specified position of menu\n+ * @run main bug4143592\n+ *\/\n+\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+\n+public class bug4143592 {\n+\n+    public static void main(String[] argv) {\n+        JMenuBar mb = new JMenuBar();\n+        JMenu m = mb.add(new JMenu(\"Order\"));\n+        m.add(\"beginning\");\n+        m.add(\"middle\");\n+        m.add(\"end\");\n+        m.add(new JMenuItem(\"in between\"), 1);\n+        if (!m.getItem(1).getText().equals(\"in between\")) {\n+            throw new RuntimeException(\"Item was inserted incorrectly.\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JMenu\/bug4143592.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4148154\n+ * @summary Tests that menu items created by JMenu.add(Action) method\n+           have right HorizontalTextPosition.\n+ * @run main bug4148154\n+ *\/\n+\n+import java.awt.event.ActionEvent;\n+import javax.swing.AbstractAction;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuItem;\n+\n+public class bug4148154\n+{\n+    public static void main(String[] args) {\n+        JMenu menu = new JMenu();\n+        JMenuItem mi = menu.add(new AbstractAction() {\n+                public void actionPerformed(ActionEvent ev) {}\n+            });\n+        if (mi.getHorizontalTextPosition() != JMenu.LEADING &&\n+            mi.getHorizontalTextPosition() != JMenu.TRAILING) {\n+\n+            throw new RuntimeException(\"Failed:\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JMenu\/bug4148154.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4156316\n+ * @summary checks if JMenu.add(Component) throws NullPointerException\n+ * @run main bug4156316\n+ *\/\n+\n+import javax.swing.JComponent;\n+import javax.swing.JMenu;\n+\n+public class bug4156316 {\n+\n+    public static void main(String[] args) {\n+        JMenu m = new JMenu(\"test\");\n+        m.add(new XComponent());\n+    }\n+\n+    static class XComponent extends JComponent {\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JMenu\/bug4156316.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4161866\n+ * @summary Method AccessibleJMenu.removeAccessibleSelection does not\n+            remove selections correctly\n+ * @run main bug4161866\n+ *\/\n+\n+import javax.accessibility.AccessibleSelection;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+\n+public class bug4161866 {\n+\n+  public static void main(String[] argv) {\n+      JMenuBar mb = new JMenuBar();\n+      JMenu mnu = new JMenu();\n+      AccessibleSelection acs = mnu.getAccessibleContext().\n+              getAccessibleSelection();\n+      mb.add(mnu);\n+      JMenu jm = new JMenu();\n+      mnu.add(jm);\n+      jm.setSelected(true);\n+      acs.addAccessibleSelection(0);\n+      if (!jm.isSelected()) {\n+          throw new RuntimeException(\"Selection should be non-empty...\");\n+      }\n+\n+      acs.removeAccessibleSelection(0);\n+      if (jm.isSelected()) {\n+          throw new RuntimeException(\"Selection still non-empty after \" +\n+                  \"it was removed\");\n+      }\n+  }\n+}\n","filename":"test\/jdk\/javax\/swing\/JMenu\/bug4161866.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4244796\n+ * @summary Tests that JMenu has JMenu(Action) constructor\n+ * @run main bug4244796\n+ *\/\n+\n+import java.awt.event.ActionEvent;\n+import java.beans.PropertyChangeListener;\n+import javax.swing.Action;\n+import javax.swing.JMenu;\n+\n+public class bug4244796 {\n+\n+    \/**\n+      * Auxilliary class implementing Action\n+     *\/\n+    static class NullAction implements Action {\n+        public void addPropertyChangeListener(\n+                       PropertyChangeListener listener) {}\n+        public void removePropertyChangeListener(\n+                       PropertyChangeListener listener) {}\n+        public void putValue(String key, Object value) {}\n+        public void setEnabled(boolean b) {}\n+        public void actionPerformed(ActionEvent e) {}\n+\n+        public Object getValue(String key) { return null; }\n+        public boolean isEnabled() { return false; }\n+    }\n+\n+    public static void main(String[] argv) {\n+        Action action = new NullAction();\n+        JMenu menu = new JMenu(action);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JMenu\/bug4244796.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4767393\n+ * @summary Disabled JMenu is selectable via mnemonic\n+ * @key headful\n+ * @run main bug4767393\n+ *\/\n+\n+import java.awt.Robot;\n+import java.awt.event.KeyEvent;\n+import javax.swing.JFrame;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.SwingUtilities;\n+\n+public class bug4767393 {\n+\n+    public static JFrame mainFrame;\n+    public static JMenuBar menuBar;\n+    public static JMenu menu;\n+    public static JMenu disabled;\n+    public static volatile boolean disabledMenuSelected = true;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            Robot robo = new Robot();\n+            robo.setAutoDelay(100);\n+            SwingUtilities.invokeAndWait(() -> {\n+                mainFrame = new JFrame(\"Bug4767393\");\n+                menuBar = new JMenuBar();\n+                menu = new JMenu(\"File\");\n+                disabled = new JMenu(\"Disabled\");\n+                menuBar.add(menu);\n+                menu.add(\"Menu Item 1\");\n+                menu.add(\"Menu Item 2\");\n+                disabled.setEnabled(false);\n+                disabled.setMnemonic('D');\n+                disabled.add(\"Dummy menu item\");\n+                menu.add(disabled);\n+                menu.add(\"Menu Item 3\");\n+                menu.add(\"Menu Item 4\");\n+                mainFrame.setJMenuBar(menuBar);\n+\n+                mainFrame.setSize(200, 200);\n+                mainFrame.setLocationRelativeTo(null);\n+                mainFrame.setVisible(true);\n+            });\n+            robo.waitForIdle();\n+            robo.delay(500);\n+\n+            robo.keyPress(KeyEvent.VK_F10);\n+            robo.keyRelease(KeyEvent.VK_F10);\n+            robo.keyPress(KeyEvent.VK_DOWN);\n+            robo.keyRelease(KeyEvent.VK_DOWN);\n+            robo.delay(500);\n+            robo.keyPress(KeyEvent.VK_D);\n+            robo.keyRelease(KeyEvent.VK_D);\n+            robo.delay(100);\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                disabledMenuSelected = disabled.isSelected();\n+            });\n+\n+            if (disabledMenuSelected) {\n+                throw new RuntimeException(\"Disabled JMenu is selected\" +\n+                        \" by the mnemonic. Test failed.\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (mainFrame != null) {\n+                    mainFrame.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JMenu\/bug4767393.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4403749\n+ * @summary Tests that keyboard accelerator implementation in JMenuBar is\n+            MenuElement aware\n+ * @key headful\n+ * @run main bug4403749\n+ *\/\n+\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseEvent;\n+\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JPanel;\n+import javax.swing.KeyStroke;\n+import javax.swing.MenuElement;\n+import javax.swing.MenuSelectionManager;\n+import javax.swing.SwingUtilities;\n+\n+public class bug4403749 {\n+    static JFrame frame;\n+    static volatile Point pt;\n+    static volatile Dimension dim;\n+    static volatile boolean passed;\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(100);\n+        try {\n+            SwingUtilities.invokeAndWait(() -> {\n+                frame = new JFrame(\"bug4403749\");\n+                JMenuBar mbar = new JMenuBar();\n+                JMenu menu = new JMenu(\"Menu\");\n+                JPanel panel = new TestMenuElement();\n+                menu.add(panel);\n+                mbar.add(menu);\n+                frame.setJMenuBar(mbar);\n+\n+                frame.getContentPane().add(new JButton(\"\"));\n+                frame.setSize(200, 200);\n+                frame.setLocationRelativeTo(null);\n+                frame.setAlwaysOnTop(true);\n+                frame.setVisible(true);\n+            });\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            SwingUtilities.invokeAndWait(() -> {\n+                pt = frame.getLocationOnScreen();\n+                dim = frame.getSize();\n+            });\n+            robot.mouseMove(pt.x + dim.width \/ 2, pt.y + dim.height \/ 2);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            robot.delay(200);\n+            robot.keyPress(KeyEvent.VK_ALT);\n+            robot.keyPress(KeyEvent.VK_A);\n+            robot.keyRelease(KeyEvent.VK_A);\n+            robot.keyRelease(KeyEvent.VK_ALT);\n+            if (!passed) {\n+                throw new RuntimeException(\"Failed: processKeyBinding wasn't called\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                 }\n+            });\n+        }\n+    }\n+\n+    static class TestMenuElement extends JPanel implements MenuElement {\n+        public void processMouseEvent(MouseEvent event,\n+                                      MenuElement[] path,\n+                                      MenuSelectionManager manager) {}\n+\n+        public void processKeyEvent(KeyEvent event,\n+                                    MenuElement[] path,\n+                                    MenuSelectionManager manager) {}\n+\n+        public void menuSelectionChanged(boolean isIncluded) {}\n+\n+        public MenuElement[] getSubElements() {\n+            return new MenuElement[0];\n+        }\n+\n+        public Component getComponent() {\n+            return this;\n+        }\n+\n+        protected boolean processKeyBinding(KeyStroke ks, KeyEvent e,\n+                                            int condition, boolean pressed) {\n+            passed = true;\n+            return super.processKeyBinding(ks, e, condition, pressed);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JMenuBar\/bug4403749.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4191835\n+ * @summary JOptionPane should allow Dialog as window owner.\n+ * @key headful\n+ * @run main bug4191835\n+ *\/\n+\n+import java.awt.Dialog;\n+import javax.swing.JDialog;\n+import javax.swing.JOptionPane;\n+\n+public class bug4191835 {\n+\n+  public static void main(String[] args) {\n+    JOptionPane op = new JOptionPane();\n+    Dialog dlg = new Dialog(new JDialog());\n+    JDialog jd = op.createDialog(dlg, \"Dialog\");\n+  }\n+}\n","filename":"test\/jdk\/javax\/swing\/JOptionPane\/bug4191835.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4123919\n+ * @requires (os.family == \"windows\")\n+ * @summary JPopupMenu.isPopupTrigger() under a different L&F.\n+ * @key headful\n+ * @run main bug4123919\n+ *\/\n+\n+import javax.swing.JLabel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.UIManager;\n+import javax.swing.SwingUtilities;\n+import java.awt.event.MouseEvent;\n+import java.util.Date;\n+\n+public class bug4123919 {\n+\n+    public static void main(String[] args) throws Exception {\n+        JPopupMenu popup = new JPopupMenu(\"Test\");\n+        JLabel lb = new JLabel();\n+        UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.motif.MotifLookAndFeel\");\n+        SwingUtilities.updateComponentTreeUI(lb);\n+        SwingUtilities.updateComponentTreeUI(popup);\n+        if (!popup.isPopupTrigger(new MouseEvent(lb, MouseEvent.MOUSE_PRESSED,\n+                (new Date()).getTime(), MouseEvent.BUTTON3_MASK, 10, 10, 1, true))) {\n+            throw new RuntimeException(\"JPopupMenu.isPopupTrigger() fails on\" +\n+                    \" MotifLookAndFeel when mouse pressed...\");\n+        }\n+        if (popup.isPopupTrigger(new MouseEvent(lb, MouseEvent.MOUSE_RELEASED,\n+                (new Date()).getTime(), MouseEvent.BUTTON3_MASK, 10, 10, 1, true))) {\n+            throw new RuntimeException(\"JPopupMenu.isPopupTrigger() fails on\" +\n+                    \" MotifLookAndFeel when mouse released...\");\n+        }\n+\n+        UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\");\n+        SwingUtilities.updateComponentTreeUI(lb);\n+        SwingUtilities.updateComponentTreeUI(popup);\n+\n+        if (popup.isPopupTrigger(new MouseEvent(lb, MouseEvent.MOUSE_PRESSED,\n+                (new Date()).getTime(), MouseEvent.BUTTON3_MASK, 10, 10, 1, true))) {\n+            throw new RuntimeException(\"JPopupMenu.isPopupTrigger() fails on\" +\n+                    \" WindowsLookAndFeel when mouse pressed...\");\n+        }\n+        if (!popup.isPopupTrigger(new MouseEvent(lb, MouseEvent.MOUSE_RELEASED,\n+                (new Date()).getTime(), MouseEvent.BUTTON3_MASK, 10, 10, 1, true))) {\n+            throw new RuntimeException(\"JPopupMenu.isPopupTrigger() fails on\" +\n+                    \" WindowsLookAndFeel when mouse released...\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JPopupMenu\/bug4123919.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4197019\n+ * @key headful\n+ * @run main bug4197019\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Graphics;\n+import java.awt.Polygon;\n+import java.awt.event.ActionEvent;\n+\n+import javax.swing.Action;\n+import javax.swing.AbstractAction;\n+import javax.swing.Icon;\n+import javax.swing.JMenuItem;\n+import javax.swing.JMenu;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+public class bug4197019 {\n+    static volatile JMenuItem mi1;\n+    static volatile JMenuItem mi2;\n+    static volatile Icon i2;\n+    static volatile boolean isPassed = false;\n+\n+    public static void main(String[] args) throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            JMenu fileMenu = new JMenu(\"File\");\n+            JPopupMenu p = new JPopupMenu();\n+            Icon i = new ArrowIcon();\n+            Action a = new TestAction(\"Test\", i);\n+            mi1 = fileMenu.add(a);\n+            mi2 = p.add(a);\n+\n+            i2 = new SquareIcon();\n+            a.putValue(Action.SMALL_ICON, i2);\n+\n+            isPassed = (mi2.getIcon() != i2) || (mi1.getIcon() != i2) ||\n+                    (mi1.getIcon() != mi2.getIcon());\n+        });\n+        if (isPassed) {\n+            throw new RuntimeException(\"Failed bug test 4197019\");\n+        }\n+    }\n+\n+    private static class TestAction extends AbstractAction {\n+        public TestAction(String s, Icon i) {\n+            super(s,i);\n+        }\n+        public void actionPerformed(ActionEvent e) {\n+\n+        }\n+    }\n+\n+    private static class ArrowIcon implements Icon {\n+        public void paintIcon(Component c, Graphics g, int x, int y) {\n+            Polygon p = new Polygon();\n+            p.addPoint(x, y);\n+            p.addPoint(x+getIconWidth(), y+getIconHeight()\/2);\n+            p.addPoint(x, y+getIconHeight());\n+            g.fillPolygon(p);\n+\n+        }\n+        public int getIconWidth() { return 4; }\n+        public int getIconHeight() { return 8; }\n+    } \/\/ End class MenuArrowIcon\n+\n+    private static class SquareIcon implements Icon {\n+        public void paintIcon(Component c, Graphics g, int x, int y) {\n+            g.setColor(Color.red);\n+            g.fill3DRect(x,y,4,8,true);\n+        }\n+        public int getIconWidth() { return 8; }\n+        public int getIconHeight() { return 8; }\n+    } \/\/ End class MenuArrowIcon\n+\n+}\n","filename":"test\/jdk\/javax\/swing\/JPopupMenu\/bug4197019.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.swing.JComponent;\n+import javax.swing.JSpinner;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+\n+\/*\n+ * @test\n+ * @bug 4522737\n+ * @summary Cannot serialize JSpinner twice.\n+ * @run main bug4522737\n+ *\/\n+\n+public class bug4522737 {\n+    public static void main(String[] args) throws Exception {\n+        final JComponent originalComponent = new JSpinner();\n+\n+        ByteArrayOutputStream byteArrayOutputStream =\n+                new ByteArrayOutputStream();\n+        ObjectOutputStream objectOutputStream =\n+                new ObjectOutputStream(byteArrayOutputStream);\n+        objectOutputStream.writeObject(originalComponent);\n+\n+        objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);\n+        objectOutputStream.writeObject(originalComponent);\n+\n+        System.out.println(\"Test Passed!\");\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JSpinner\/bug4522737.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.swing.JFormattedTextField;\n+import javax.swing.JFrame;\n+import javax.swing.JSpinner;\n+import javax.swing.SpinnerDateModel;\n+import javax.swing.SpinnerListModel;\n+import javax.swing.SpinnerNumberModel;\n+import javax.swing.SwingUtilities;\n+import java.awt.Font;\n+import java.awt.GridLayout;\n+import java.awt.Robot;\n+\n+\/*\n+ * @test\n+ * @bug 4656590\n+ * @summary JSpinner.setFont() does nothing\n+ * @key headful\n+ * @run main bug4656590\n+ *\/\n+\n+public class bug4656590 {\n+    private static JSpinner[] spinner = new JSpinner[6];\n+    private static Font font = new Font(\"Arial\", Font.BOLD, 24);\n+    private static volatile boolean failed = false;\n+    private static JFrame frame;\n+    private static Robot robot;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            robot = new Robot();\n+            SwingUtilities.invokeAndWait(() -> {\n+                frame = new JFrame();\n+                frame.getContentPane().setLayout(new GridLayout(3, 2));\n+                spinner[0] = new JSpinner();\n+                spinner[0].setModel(new SpinnerNumberModel());\n+                spinner[0].setFont(font);\n+                frame.getContentPane().add(spinner[0]);\n+\n+                spinner[1] = new JSpinner();\n+                spinner[1].setModel(new SpinnerDateModel());\n+                spinner[1].setFont(font);\n+                frame.getContentPane().add(spinner[1]);\n+\n+                spinner[2] = new JSpinner();\n+                spinner[2].setModel(new SpinnerListModel\n+                        (new Object[]{\"one\", \"two\", \"three\"}));\n+                spinner[2].setFont(font);\n+                frame.getContentPane().add(spinner[2]);\n+\n+                spinner[3] = new JSpinner();\n+                spinner[3].setFont(font);\n+                spinner[3].setModel(new SpinnerNumberModel());\n+                frame.getContentPane().add(spinner[3]);\n+\n+                spinner[4] = new JSpinner();\n+                spinner[4].setFont(font);\n+                spinner[4].setModel(new SpinnerDateModel());\n+                frame.getContentPane().add(spinner[4]);\n+\n+                spinner[5] = new JSpinner();\n+                spinner[5].setFont(font);\n+                spinner[5].setModel(new SpinnerListModel\n+                        (new Object[]{\"one\", \"two\", \"three\"}));\n+                frame.getContentPane().add(spinner[5]);\n+                frame.pack();\n+                frame.setVisible(true);\n+            });\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            SwingUtilities.invokeAndWait(() -> {\n+                JFormattedTextField ftf;\n+                for (int i = 1; i < 6; i++) {\n+                    ftf = ((JSpinner.DefaultEditor)\n+                            spinner[i].getEditor()).getTextField();\n+                    if (!ftf.getFont().equals(font)) {\n+                        failed = true;\n+                    }\n+                }\n+            });\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            if (failed) {\n+                throw new RuntimeException(\"JSpinner.setFont() \" +\n+                        \"doesn't set the font properly\");\n+            }\n+            System.out.println(\"Test Passed!\");\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JSpinner\/bug4656590.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.swing.JComponent;\n+import javax.swing.JFrame;\n+import javax.swing.JSpinner;\n+import javax.swing.JTextField;\n+import javax.swing.SpinnerNumberModel;\n+import javax.swing.SwingUtilities;\n+import java.awt.Component;\n+import java.awt.FlowLayout;\n+import java.awt.Robot;\n+\n+\/*\n+ * @test\n+ * @bug 4680204\n+ * @summary JSpinner shows ToolTipText only on it's border\n+ * @key headful\n+ * @run main bug4680204\n+ *\/\n+\n+public class bug4680204 {\n+\n+    private static JSpinner sp1, sp2;\n+    private static final String TOOL_TIP_TEXT = \"ToolTipText\";\n+    private static JFrame frame;\n+    private static Robot robot;\n+    private static volatile boolean failed = false;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            robot = new Robot();\n+            SwingUtilities.invokeAndWait(() -> {\n+                frame = new JFrame();\n+                frame.getContentPane().setLayout(new FlowLayout());\n+\n+                sp1 = new JSpinner(new SpinnerNumberModel(1, 1, 100, 1));\n+                sp1.setToolTipText(TOOL_TIP_TEXT);\n+                frame.getContentPane().add(sp1);\n+\n+                sp2 = new JSpinner();\n+                sp2.setToolTipText(TOOL_TIP_TEXT);\n+                frame.getContentPane().add(sp2);\n+                sp2.setModel(new SpinnerNumberModel(1, 1, 100, 1));\n+                frame.setLocationRelativeTo(null);\n+                frame.pack();\n+                frame.setVisible(true);\n+            });\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            SwingUtilities.invokeAndWait(() -> {\n+                Component[] children = sp1.getComponents();\n+                for (int i = 0; i < children.length; i++) {\n+                    if (children[i] instanceof JSpinner.DefaultEditor) {\n+                        JTextField tf = ((JSpinner.DefaultEditor) children[i]).getTextField();\n+                        if (!TOOL_TIP_TEXT.equals(tf.getToolTipText())) {\n+                            failed = true;\n+                        }\n+                    } else if (children[i] instanceof JComponent) {\n+                        String text = ((JComponent) children[i]).getToolTipText();\n+                        if (!TOOL_TIP_TEXT.equals(text)) {\n+                            failed = true;\n+                        }\n+                    }\n+                }\n+\n+                children = sp2.getComponents();\n+                for (int i = 0; i < children.length; i++) {\n+                    if (children[i] instanceof JSpinner.DefaultEditor) {\n+                        JTextField tf = ((JSpinner.DefaultEditor) children[i]).getTextField();\n+                        if (!TOOL_TIP_TEXT.equals(tf.getToolTipText())) {\n+                            failed = true;\n+                        }\n+                    } else if (children[i] instanceof JComponent) {\n+                        String text = ((JComponent) children[i]).getToolTipText();\n+                        if (!TOOL_TIP_TEXT.equals(text)) {\n+                            failed = true;\n+                        }\n+                    }\n+                }\n+            });\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            if (failed) {\n+                throw new RuntimeException(\"The tooltip text is not correctly set for JSpinner\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+        System.out.println(\"Test Passed!\");\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JSpinner\/bug4680204.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.swing.JButton;\n+import javax.swing.JSpinner;\n+\n+\/*\n+ * @test\n+ * @bug 4862257\n+ * @summary Class cast Exception occurred when JButton is set to JSpinner\n+ * @run main bug4862257\n+ *\/\n+\n+public class bug4862257 {\n+    public static void main(String[] argv) {\n+        JSpinner spinner = new JSpinner();\n+        spinner.setEditor(new JButton(\"JButton\"));\n+        System.out.println(\"Test Passed!\");\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JSpinner\/bug4862257.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.swing.SpinnerDateModel;\n+\n+\/*\n+ * @test\n+ * @bug 5104421\n+ * @summary SpinnerDateModel.setValue(Object) throws exception with incorrect message\n+ * @run main bug5104421\n+ *\/\n+\n+public class bug5104421 {\n+    public static void main(String[] args) {\n+        SpinnerDateModel model = new SpinnerDateModel();\n+        try {\n+            model.setValue(Integer.valueOf(42));\n+        } catch (IllegalArgumentException e) {\n+            if (e.getMessage().toLowerCase().indexOf(\"null value\") != -1) {\n+                throw new RuntimeException(\"SpinnerDateModel.setValue(Object) throws \" +\n+                        \"exception with incorrect message\");\n+            }\n+        }\n+        System.out.println(\"Test Passed!\");\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JSpinner\/bug5104421.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8322239\n+ * @summary [macos] a11y : java.lang.NullPointerException is thrown when\n+ *          focus is moved on the JTabbedPane\n+ * @key headful\n+ * @run main TabbedPaneNPECheck\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Dimension;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.lang.reflect.InvocationTargetException;\n+import javax.accessibility.Accessible;\n+import javax.accessibility.AccessibleComponent;\n+import javax.accessibility.AccessibleContext;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.JTabbedPane;\n+import javax.swing.SwingUtilities;\n+\n+public class TabbedPaneNPECheck {\n+    JTabbedPane pane;\n+    JFrame mainFrame;\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        TabbedPaneNPECheck me = new TabbedPaneNPECheck();\n+        SwingUtilities.invokeAndWait(me::setupGUI);\n+        try {\n+            SwingUtilities.invokeAndWait(me::test);\n+        } finally {\n+            SwingUtilities.invokeAndWait(me::shutdownGUI);\n+        }\n+    }\n+\n+    public void setupGUI() {\n+        mainFrame = new JFrame(\"TabbedPaneNPECheck\");\n+        pane = new JTabbedPane();\n+        Dimension panelSize = new Dimension(200, 200);\n+        for (int i = 0; i < 25; i++) {\n+            JPanel p = new JPanel();\n+            p.setMinimumSize(panelSize);\n+            p.setMaximumSize(panelSize);\n+            p.setSize(panelSize);\n+            pane.addTab(\"Tab no.\" + i, p);\n+        }\n+        mainFrame.setLayout(new BorderLayout());\n+        mainFrame.add(pane, BorderLayout.CENTER);\n+        mainFrame.setLocationRelativeTo(null);\n+        mainFrame.setSize(250, 250);\n+        mainFrame.setVisible(true);\n+    }\n+\n+    public void test() {\n+        AccessibleContext context = pane.getAccessibleContext();\n+        int nChild = context.getAccessibleChildrenCount();\n+        for (int i = 0; i < nChild; i++) {\n+            Accessible accessible = context.getAccessibleChild(i);\n+            if (accessible instanceof AccessibleComponent) {\n+                try {\n+                    AccessibleComponent component = (AccessibleComponent) accessible;\n+                    Point p = component.getLocationOnScreen();\n+                    Rectangle r = component.getBounds();\n+                } catch (NullPointerException npe) {\n+                    throw new RuntimeException(\"Unexpected NullPointerException \" +\n+                            \"while getting accessible component bounds: \", npe);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void shutdownGUI() {\n+        if (mainFrame != null) {\n+            mainFrame.setVisible(false);\n+            mainFrame.dispose();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JTabbedPane\/TabbedPaneNPECheck.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4371134\n+ * @key headful\n+ * @summary displays an animating fps (frames per second)\n+ *  counter.  When the window is dragged from monitor to monitor,\n+ *  the speed of the animation should not change too greatly.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MultimonVImage\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import javax.swing.JViewport;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+\n+public class MultimonVImage {\n+    private static final String instructionsText =\n+            \"This test should be run on any Windows platform that\\n\" +\n+            \"supports multiple monitors.\\n\" +\n+            \"You will see an animating fps (frames per second) counter at\\n\" +\n+            \"the bottom of the window.  Drag the window into the other monitor\\n\" +\n+            \"and that counter should not change drastically.  If the counter\\n\" +\n+            \"is much lower on one monitor than the other (barring situations\\n\" +\n+            \"described below) then the back buffer may not be accelerated\\n\" +\n+            \"on the second monitor and the test fails.\\n\" +\n+            \"Situations in which performance will differ even though there\\n\" +\n+            \"is acceleration on both monitors include:\\n\" +\n+            \"  - different bit depths on each monitor.  The higher the bits\\n\" +\n+            \"    per pixel, the more data to push and the lower the fps number.\\n\" +\n+            \"    Set the bit depths to be the same on both monitors to work\\n\" +\n+            \"    around this issue.\\n\" +\n+            \"  - the amount of acceleration available on each video card differs,\\n\" +\n+            \"    so if your system uses different video cards then you should\\n\" +\n+            \"    expect some difference between the cards.  To work around this\\n\" +\n+            \"    issue, try to use the same or similar video cards for each monitor.\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame passFailJFrame = new PassFailJFrame.Builder()\n+                .title(\"MultimonVImage Instructions\")\n+                .instructions(instructionsText)\n+                .testTimeOut(5)\n+                .rows(25)\n+                .columns(50)\n+                .build();\n+\n+        SwingUtilities.invokeAndWait(() -> {\n+            AnimatingFrame af = new AnimatingFrame();\n+            af.test();\n+            af.run();\n+\n+            PassFailJFrame.addTestWindow(af);\n+            PassFailJFrame.positionTestWindow(af,\n+                    PassFailJFrame.Position.HORIZONTAL);\n+        });\n+\n+        passFailJFrame.awaitAndCheck();\n+    }\n+}\n+\n+class FrameCounter {\n+\n+    String fpsString = \"Calculating...\";\n+    long startTime, endTime;\n+    int numFrames;\n+\n+    public FrameCounter() {\n+        startTime = System.currentTimeMillis();\n+    }\n+\n+    public String addFrame() {\n+        ++numFrames;\n+        return calculateFPS();\n+    }\n+\n+    String calculateFPS() {\n+        endTime = System.currentTimeMillis();\n+        double seconds = ((double) endTime - (double) startTime) \/ 1000;\n+        if (seconds > 1) {\n+            int fps = (int) (numFrames \/ seconds);\n+            fpsString = fps + \" fps\";\n+            startTime = endTime;\n+            numFrames = 0;\n+        }\n+        return fpsString;\n+    }\n+}\n+\n+class AnimatingComponent extends JViewport {\n+\n+    FrameCounter frameCounter;\n+    int boxX, boxY;\n+    int boxW, boxH;\n+    int xStep = 1;\n+\n+    public AnimatingComponent() {\n+        frameCounter = new FrameCounter();\n+        boxX = 0;\n+        boxY = 0;\n+        boxW = 100;\n+        boxH = 100;\n+    }\n+\n+    public void paintComponent(Graphics g) {\n+        boxX += xStep;\n+        if (boxX <= 0 || (boxX + boxW) > getWidth()) {\n+            xStep = -xStep;\n+            boxX += (2 * xStep);\n+        }\n+        g.setColor(Color.white);\n+        g.fillRect(0, 0, getWidth(), getHeight());\n+        g.setColor(Color.green);\n+        for (int i = 0; i < 100; ++i) {\n+            g.fillRect(boxX, boxY, 100, 100);\n+        }\n+        g.setColor(Color.black);\n+        g.drawString(frameCounter.addFrame(), 200, getHeight() - 30);\n+    }\n+}\n+\n+class AnimatingFrame extends JFrame implements Runnable {\n+    JViewport component;\n+    Thread thread;\n+\n+    public AnimatingFrame() {\n+        setSize(500, 500);\n+        setTitle(\"MultimonVImage Demo\");\n+        addWindowListener(new WindowAdapter() {\n+            public void windowClosing(WindowEvent e) {\n+                System.exit(0);\n+            }\n+        });\n+\n+        component = new AnimatingComponent();\n+        component.setPreferredSize(new Dimension(500, 500));\n+        setContentPane(component);\n+        component.setVisible(true);\n+\n+        setLocationRelativeTo(null);\n+        pack();\n+        setVisible(true);\n+    }\n+\n+    public void test() {\n+        thread = new Thread(this);\n+        thread.setPriority(Thread.MIN_PRIORITY);\n+        thread.start();\n+    }\n+\n+    public void run() {\n+        Thread me = Thread.currentThread();\n+        while (thread == me) {\n+            component.repaint();\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/swing\/MultiMonitor\/MultimonVImage.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4322891\n+ * @summary  Tests if image map receives correct coordinates.\n+ * @key headful\n+ * @run main bug4322891\n+*\/\n+\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import javax.swing.JFrame;\n+import javax.swing.JEditorPane;\n+import javax.swing.SwingUtilities;\n+import javax.swing.event.HyperlinkEvent;\n+import javax.swing.event.HyperlinkListener;\n+import javax.swing.text.html.HTMLEditorKit;\n+\n+public class bug4322891 {\n+\n+    private boolean finished = false;\n+    private static boolean passed = false;\n+    private static Robot robot;\n+    private static JFrame f;\n+    private static JEditorPane jep;\n+    private static volatile Point p;\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+        robot.setAutoDelay(100);\n+        try {\n+            bug4322891 test = new bug4322891();\n+            SwingUtilities.invokeAndWait(test::init);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            SwingUtilities.invokeAndWait(() -> {\n+                p = jep.getLocationOnScreen();\n+            });\n+            robot.mouseMove(p.x, p.y);\n+            robot.waitForIdle();\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            for (int i = 1; i < 30; i++) {\n+                robot.mouseMove(p.x + i, p.y + i);\n+                robot.waitForIdle();\n+            }\n+            if (!passed) {\n+                throw new RuntimeException(\"Test failed.\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (f != null) {\n+                    f.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    public void init() {\n+        String text = \"<img src=\\\"aaa\\\" height=100 width=100 usemap=\\\"#mymap\\\">\" +\n+                      \"<map name=\\\"mymap\\\">\" +\n+                      \"<area href=\\\"aaa\\\" shape=rect coords=\\\"0,0,100,100\\\">\" +\n+                      \"<\/map>\";\n+\n+        f = new JFrame();\n+        jep = new JEditorPane();\n+        jep.setEditorKit(new HTMLEditorKit());\n+        jep.setEditable(false);\n+\n+        jep.setText(text);\n+\n+        jep.addHyperlinkListener(new HyperlinkListener() {\n+                                    public void hyperlinkUpdate(HyperlinkEvent e) {\n+                                        passed = true;\n+                                    }\n+                                });\n+        f.getContentPane().add(jep);\n+        f.setSize(500,500);\n+        f.setLocationRelativeTo(null);\n+        f.setVisible(true);\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/swing\/text\/html\/Map\/bug4322891.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4476002\n+ * @summary  Verifies JEditorPane: <ol> list numbers do not pick up color of the list text\n+ * @key headful\n+ * @run main bug4476002\n+*\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.SwingUtilities;\n+\n+public class bug4476002 {\n+\n+    private static boolean passed = true;\n+    private static JLabel htmlComponent;\n+\n+    private static Robot robot;\n+    private static JFrame mainFrame;\n+    private static volatile Point p;\n+    private static volatile Dimension d;\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+\n+        try {\n+            SwingUtilities.invokeAndWait(() -> {\n+                String htmlText =\n+                    \"<html><head><style>\" +\n+                    \"OL { list-style-type: disc; color: red }\" +\n+                    \"<\/style><\/head>\" +\n+                    \"<body><ol><li>wwwww<\/li><\/ol><\/body><\/html>\";\n+\n+                mainFrame = new JFrame(\"bug4476002\");\n+\n+                htmlComponent = new JLabel(htmlText);\n+                mainFrame.getContentPane().add(htmlComponent);\n+\n+                mainFrame.pack();\n+                mainFrame.setLocationRelativeTo(null);\n+                mainFrame.setVisible(true);\n+            });\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            SwingUtilities.invokeAndWait(() -> {\n+                p = htmlComponent.getLocationOnScreen();\n+                d = htmlComponent.getSize();\n+            });\n+            int x0 = p.x;\n+            int y = p.y + d.height\/2;\n+\n+            for (int x = x0; x < x0 + d.width; x++) {\n+                if (robot.getPixelColor(x, y).equals(Color.black)) {\n+                    passed = false;\n+                    break;\n+                }\n+            }\n+            if (!passed) {\n+                throw new RuntimeException(\"Test failed.\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (mainFrame != null) {\n+                    mainFrame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/swing\/text\/html\/StyleSheet\/bug4476002.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4412522\n+ * @summary  Tests if HTML that has comments inside of tables is rendered correctly\n+ * @key headful\n+ * @run main bug4412522\n+*\/\n+\n+import javax.swing.JEditorPane;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+import javax.swing.text.View;\n+import javax.swing.text.html.HTMLEditorKit;\n+\n+import java.awt.Robot;\n+import java.awt.Shape;\n+\n+public class bug4412522 {\n+\n+    private static boolean passed = false;\n+\n+    private static JEditorPane jep;\n+    private static JFrame f;\n+    private static Robot robot;\n+\n+    public void init() {\n+\n+        String text =\n+                \"<html><head><table border>\" +\n+                \"<tr><td>first cell<\/td><td>second cell<\/td><\/tr>\" +\n+                \"<tr><!-- this is a comment --><td>row heading<\/td><\/tr>\" +\n+                \"<\/table><\/body><\/html>\";\n+\n+        JFrame f = new JFrame();\n+        jep = new JEditorPane();\n+        jep.setEditorKit(new HTMLEditorKit());\n+        jep.setEditable(false);\n+\n+        jep.setText(text);\n+\n+        f.getContentPane().add(jep);\n+        f.setSize(500,500);\n+        f.setLocationRelativeTo(null);\n+        f.setVisible(true);\n+    }\n+\n+\n+    public static void main(String args[]) throws Exception {\n+        robot = new Robot();\n+        robot.setAutoDelay(100);\n+        bug4412522 test = new bug4412522();\n+        try {\n+            SwingUtilities.invokeAndWait(() -> test.init());\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            Shape r = jep.getBounds();\n+            View v = jep.getUI().getRootView(jep);\n+            int tableWidth = 0;\n+            int cellsWidth = 0;\n+\n+            while (!(v instanceof javax.swing.text.html.ParagraphView)) {\n+\n+                int n = v.getViewCount();\n+                Shape sh = v.getChildAllocation(n - 1, r);\n+                String viewName = v.getClass().getName();\n+                if (viewName.endsWith(\"TableView\")) {\n+                    tableWidth = r.getBounds().width;\n+                }\n+\n+                if (viewName.endsWith(\"CellView\")) {\n+                    cellsWidth = r.getBounds().x + r.getBounds().width;\n+                }\n+\n+                v = v.getView(n - 1);\n+                if (sh != null) {\n+                    r = sh;\n+                }\n+            }\n+\n+            passed = ((tableWidth - cellsWidth) > 10);\n+            if (!passed) {\n+                throw new RuntimeException(\"Test failed.\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (f != null) {\n+                    f.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/text\/html\/TableView\/bug4412522.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4690812\n+ * @summary  Tests if tables are correctly formatted in some cases\n+ * @key headful\n+ * @run main bug4690812\n+*\/\n+\n+import javax.swing.JEditorPane;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+import javax.swing.text.View;\n+import javax.swing.text.html.HTMLEditorKit;\n+\n+import java.awt.Robot;\n+import java.awt.Shape;\n+\n+public class bug4690812 {\n+\n+    private static boolean passed = false;\n+\n+    private static JEditorPane jep;\n+    private static JFrame f;\n+\n+    public void init() {\n+\n+        String text =\n+            \"<table cellpadding=0 cellspacing=0 border=0 width=100%>\" +\n+            \"<tr><td width=100%>a<\/td><td><\/td><\/tr>\" +\n+            \"<tr><td width=100%>something<\/td>\" +\n+            \"<td width=1><img src=\\\"file:\/a.jpg\\\" width=1 height=1><\/td><\/tr>\" +\n+            \"<\/table>\";\n+\n+        JFrame f = new JFrame();\n+        jep = new JEditorPane();\n+        jep.setEditorKit(new HTMLEditorKit());\n+        jep.setEditable(false);\n+\n+        jep.setText(text);\n+\n+        f.getContentPane().add(jep);\n+        f.setSize(500,500);\n+        f.setLocationRelativeTo(null);\n+        f.setVisible(true);\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        Robot robot = new Robot();\n+        bug4690812 test = new bug4690812();\n+        try {\n+            SwingUtilities.invokeAndWait(() -> test.init());\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            Shape r = jep.getBounds();\n+            View v = jep.getUI().getRootView(jep);\n+            int tableHeight = 0;\n+            while (!(v instanceof javax.swing.text.html.ParagraphView)) {\n+                int n = v.getViewCount();\n+                Shape sh = v.getChildAllocation(n - 1, r);\n+                v = v.getView(n - 1);\n+                if (sh != null) {\n+                    r = sh;\n+                }\n+            }\n+            \/\/ left column in the second table row should have width == 1\n+            passed = (r.getBounds().width == 1) ? true : false;\n+            if (!passed) {\n+                throw new RuntimeException(\"Test failed.\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (f != null) {\n+                    f.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/text\/html\/TableView\/bug4690812.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"","filename":"test\/jdk\/jdk\/internal\/loader\/URLClassPath\/ClassnameCharTest.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/misc\/URLClassPath\/ClassnameCharTest.java","status":"renamed"},{"patch":"","filename":"test\/jdk\/jdk\/internal\/loader\/URLClassPath\/FileLoaderTest.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/misc\/URLClassPath\/FileLoaderTest.java","status":"renamed"},{"patch":"","filename":"test\/jdk\/jdk\/internal\/loader\/URLClassPath\/JarLoaderTest.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/misc\/URLClassPath\/JarLoaderTest.java","status":"renamed"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.test.lib.JDKToolFinder;\n@@ -37,2 +36,0 @@\n- * @summary Verify that an application can be launched when the classpath contains large number of\n- *          jars and the java.protocol.handler.pkgs system property is set\n@@ -43,0 +40,2 @@\n+ * @summary Verify that an application can be launched when the classpath contains large number of\n+ *          jars and the java.protocol.handler.pkgs system property is set\n@@ -129,2 +128,1 @@\n-        String java = JDKToolFinder.getJDKTool(\"java\");\n-        ProcessBuilder pb = new ProcessBuilder(java,\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n","filename":"test\/jdk\/jdk\/internal\/loader\/URLClassPath\/LargeClasspathWithPkgPrefix.java","additions":3,"deletions":5,"binary":false,"changes":8,"previous_filename":"test\/jdk\/sun\/misc\/URLClassPath\/LargeClasspathWithPkgPrefix.java","status":"renamed"},{"patch":"","filename":"test\/jdk\/jdk\/internal\/loader\/URLClassPath\/testclasses.jar","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/misc\/URLClassPath\/testclasses.jar","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n- * @summary Basic test of VM::getRuntimeArguments\n+ * @requires vm.flagless\n@@ -31,0 +31,1 @@\n+ * @summary Basic test of VM::getRuntimeArguments\n@@ -49,1 +50,0 @@\n-    static final String TEST_CLASSES = System.getProperty(\"test.classes\");\n@@ -115,5 +115,3 @@\n-        \/\/ launch a test program\n-        \/\/ $ java <args> -classpath <cpath> RuntimeArguments <vm_options> <expected>\n-        Stream<String> options = Stream.concat(args.stream(),\n-            Stream.of(\"-classpath\", TEST_CLASSES, \"RuntimeArguments\"));\n-\n+        \/\/ launch a test program with classpath set by ProcessTools::createLimitedTestJavaProcessBuilder\n+        \/\/ $ java <args> RuntimeArguments <vm_options> <expected>\n+        Stream<String> options = Stream.concat(args.stream(), Stream.of(\"RuntimeArguments\"));\n","filename":"test\/jdk\/jdk\/internal\/misc\/VM\/RuntimeArguments.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+ *     -XX:CompileOnly=jdk.jfr.event.compiler.TestCompilerCompile::dummyMethod,jdk.jfr.event.compiler.TestCompilerCompile::doTest\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestCompilerCompile.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8159927\n+ * @modules java.base\/jdk.internal.util\n+ * @run main JmodExcludedFiles\n+ * @summary Test that JDK JMOD files do not include native debug symbols\n+ *\/\n+\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import jdk.internal.util.OperatingSystem;\n+\n+public class JmodExcludedFiles {\n+    private static String javaHome = System.getProperty(\"java.home\");\n+\n+    public static void main(String[] args) throws Exception {\n+        Path jmods = Path.of(javaHome, \"jmods\");\n+        try (DirectoryStream<Path> stream = Files.newDirectoryStream(jmods, \"*.jmod\")) {\n+            for (Path jmodFile : stream) {\n+                try (ZipFile zip = new ZipFile(jmodFile.toFile())) {\n+                    JModSymbolFileMatcher jsfm = new JModSymbolFileMatcher(jmodFile.toString());\n+                    if (zip.stream().map(ZipEntry::getName)\n+                                    .anyMatch(jsfm::isNativeDebugSymbol)) {\n+                        throw new RuntimeException(jmodFile + \" is expected not to include native debug symbols\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static class JModSymbolFileMatcher {\n+        private String jmod;\n+\n+        JModSymbolFileMatcher(String jmod) {\n+            this.jmod = jmod;\n+        }\n+\n+        boolean isNativeDebugSymbol(String name) {\n+            int index = name.indexOf(\"\/\");\n+            if (index < 0) {\n+                throw new RuntimeException(\"unexpected entry name: \" + name);\n+            }\n+            String section = name.substring(0, index);\n+            if (section.equals(\"lib\") || section.equals(\"bin\")) {\n+                if (OperatingSystem.isMacOS()) {\n+                    String n = name.substring(index + 1);\n+                    int i = n.indexOf(\"\/\");\n+                    if (i != -1) {\n+                        if (n.substring(0, i).endsWith(\".dSYM\")) {\n+                            System.err.println(\"Found symbols in \" + jmod + \": \" + name);\n+                            return true;\n+                        }\n+                    }\n+                }\n+                if (OperatingSystem.isWindows() && name.endsWith(\".pdb\")) {\n+                    \/\/ on Windows we check if we should have public symbols through --with-external-symbols-in-bundles=public (JDK-8237192)\n+                    String strippedpdb = javaHome + \"\/bin\/\" + name.substring(index + 1, name.length() - 4) + \".stripped.pdb\";\n+                    if (!Files.exists(Paths.get(strippedpdb))) {\n+                        System.err.println(\"Found symbols in \" + jmod + \": \" + name +\n+                                \". No stripped pdb file \" + strippedpdb + \" exists.\");\n+                        return true;\n+                    }\n+                }\n+                if (name.endsWith(\".diz\")\n+                        || name.endsWith(\".debuginfo\")\n+                        || name.endsWith(\".map\")) {\n+                    System.err.println(\"Found symbols in \" + jmod + \": \" + name);\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/modules\/etc\/JmodExcludedFiles.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary Ensure no incubator modules are resolved by default in the image\n+ * @requires vm.flagless\n@@ -32,0 +32,1 @@\n+ * @summary Ensure no incubator modules are resolved by default in the image\n@@ -46,0 +47,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -111,2 +113,0 @@\n-        String[] options = Stream.concat(Stream.of(getJava()), Stream.of(opts))\n-                .toArray(String[]::new);\n@@ -114,1 +114,1 @@\n-        ProcessBuilder pb = new ProcessBuilder(options);\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(opts);\n@@ -158,9 +158,0 @@\n-    static String getJava() {\n-        Path image = Paths.get(JAVA_HOME);\n-        boolean isWindows = System.getProperty(\"os.name\").startsWith(\"Windows\");\n-        Path java = image.resolve(\"bin\").resolve(isWindows ? \"java.exe\" : \"java\");\n-        if (Files.notExists(java))\n-            throw new RuntimeException(java + \" not found\");\n-        return java.toAbsolutePath().toString();\n-    }\n-\n","filename":"test\/jdk\/jdk\/modules\/incubator\/DefaultImage.java","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary Basic test for incubator modules in jmods and images\n+ * @requires vm.flagless\n@@ -35,0 +35,1 @@\n+ * @summary Basic test for incubator modules in jmods and images\n","filename":"test\/jdk\/jdk\/modules\/incubator\/ImageModules.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,5 +24,5 @@\n-import org.testng.Assert;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -30,1 +30,4 @@\n-import java.io.*;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n@@ -32,1 +35,0 @@\n-import java.nio.file.FileSystem;\n@@ -35,1 +37,3 @@\n-import java.util.List;\n+import java.nio.file.attribute.FileTime;\n+import java.time.Instant;\n+import java.util.HashSet;\n@@ -37,0 +41,4 @@\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n@@ -38,0 +46,3 @@\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -39,1 +50,0 @@\n-import static java.lang.String.format;\n@@ -46,2 +56,1 @@\n- * @requires (os.family == \"linux\") | (os.family == \"mac\")\n- * @run testng\/manual TestLocOffsetFromZip64EF\n+ * @run junit TestLocOffsetFromZip64EF\n@@ -51,7 +60,21 @@\n-    private static final String ZIP_FILE_NAME = \"LargeZipTest.zip\";\n-    \/\/ File that will be created with a size greater than 0xFFFFFFFF\n-    private static final String LARGE_FILE_NAME = \"LargeZipEntry.txt\";\n-    \/\/ File that will be created with a size less than 0xFFFFFFFF\n-    private static final String SMALL_FILE_NAME = \"SmallZipEntry.txt\";\n-    \/\/ The size (4GB) of the large file to be created\n-    private static final long LARGE_FILE_SIZE = 4L * 1024L * 1024L * 1024L;\n+    private static final String ZIP_FILE_NAME = \"LocOffsetFromZip64.zip\";\n+\n+    \/\/ Size of the data block of a Zip64 extended information field with long\n+    \/\/ fields for 'uncompressed size', 'compressed size' and 'local header offset'\n+    private static short ZIP64_DATA_SIZE = (short) Long.BYTES \/\/ Uncompressed size\n+            + Long.BYTES     \/\/ Compressed size\n+            + Long.BYTES;    \/\/ Loc offset\n+\n+    \/\/ Size of the extra field header\n+    private static short EXTRA_HEADER_SIZE = Short.BYTES \/\/ tag\n+            + Short.BYTES; \/\/ data size\n+\n+    \/\/ Size of a Zip64 extended information field including the header\n+    private static final int ZIP64_SIZE = EXTRA_HEADER_SIZE + ZIP64_DATA_SIZE;\n+\n+    \/\/ The Zip64 Magic value for 32-bit fields\n+    private static final int ZIP64_MAGIC_VALUE = 0XFFFFFFFF;\n+    \/\/ The 'unknown' tag, see APPNOTE.txt\n+    private static final short UNKNOWN_TAG = (short) 0x9902;\n+    \/\/ The 'Zip64 extended information' tag, see APPNOTE.txt\n+    private static final short ZIP64_TAG = (short) 0x1;\n@@ -61,0 +84,1 @@\n+     *\n@@ -63,1 +87,1 @@\n-    @BeforeClass\n+    @BeforeEach\n@@ -65,1 +89,0 @@\n-        System.out.println(\"In setup\");\n@@ -67,1 +90,0 @@\n-        createFiles();\n@@ -75,1 +97,1 @@\n-    @AfterClass\n+    @AfterEach\n@@ -77,1 +99,0 @@\n-        System.out.println(\"In cleanup\");\n@@ -79,15 +100,0 @@\n-        Files.deleteIfExists(Path.of(LARGE_FILE_NAME));\n-        Files.deleteIfExists(Path.of(SMALL_FILE_NAME));\n-    }\n-\n-    \/**\n-     * Create a Zip file that will result in a Zip64 Extra (EXT) header\n-     * being added to the CEN entry in order to find the LOC offset for\n-     * SMALL_FILE_NAME.\n-     *\/\n-    public static void createZipWithZip64Ext() {\n-        System.out.println(\"Executing zip...\");\n-        List<String> commands = List.of(\"zip\", \"-0\", ZIP_FILE_NAME,\n-                LARGE_FILE_NAME, SMALL_FILE_NAME);\n-        Result rc = run(new ProcessBuilder(commands));\n-        rc.assertSuccess();\n@@ -97,1 +103,1 @@\n-     * DataProvider used to verify that a Zip file that contains a Zip64 Extra\n+     * MethodSource used to verify that a Zip file that contains a Zip64 Extra\n@@ -100,8 +106,7 @@\n-    @DataProvider(name = \"zipInfoTimeMap\")\n-    protected Object[][] zipInfoTimeMap() {\n-        return new Object[][]{\n-                {Map.of()},\n-                {Map.of(\"zipinfo-time\", \"False\")},\n-                {Map.of(\"zipinfo-time\", \"true\")},\n-                {Map.of(\"zipinfo-time\", \"false\")}\n-        };\n+    static Stream<Map<String, String>> zipInfoTimeMap() {\n+        return Stream.of(\n+                Map.of(),\n+                Map.of(\"zipinfo-time\", \"False\"),\n+                Map.of(\"zipinfo-time\", \"true\"),\n+                Map.of(\"zipinfo-time\", \"false\")\n+        );\n@@ -115,1 +120,2 @@\n-    @Test(dataProvider = \"zipInfoTimeMap\")\n+    @ParameterizedTest\n+    @MethodSource(\"zipInfoTimeMap\")\n@@ -117,0 +123,2 @@\n+        Set<String> entries = new HashSet<>();\n+\n@@ -124,0 +132,1 @@\n+                        entries.add(file.getFileName().toString());\n@@ -131,0 +140,2 @@\n+        \/\/ Sanity check that ZIP file had the expected entries\n+        assertEquals(Set.of(\"entry\", \"entry2\", \"entry3\"), entries);\n@@ -142,2 +153,0 @@\n-        }\n-    }\n@@ -145,11 +154,3 @@\n-    \/**\n-     * Create the files that will be added to the ZIP file\n-     * @throws IOException if there is a problem  creating the files\n-     *\/\n-    private static void createFiles() throws IOException {\n-        try (RandomAccessFile file = new RandomAccessFile(LARGE_FILE_NAME, \"rw\")\n-        ) {\n-            System.out.printf(\"Creating %s%n\", LARGE_FILE_NAME);\n-            file.setLength(LARGE_FILE_SIZE);\n-            System.out.printf(\"Creating %s%n\", SMALL_FILE_NAME);\n-            Files.writeString(Path.of(SMALL_FILE_NAME), \"Hello\");\n+            \/\/ Sanity check that ZIP file had the expected entries\n+            assertEquals(zip.stream().map(ZipEntry::getName).collect(Collectors.toSet()),\n+                    Set.of(\"entry\", \"entry2\", \"entry3\"));\n@@ -160,3 +161,16 @@\n-     * Utility method to execute a ProcessBuilder command\n-     * @param pb ProcessBuilder to execute\n-     * @return The Result(s) from the ProcessBuilder execution\n+     * This produces a ZIP with similar features as the one created by 'Info-ZIP' which\n+     * caused 'Extended timestamp' parsing to fail before JDK-8255380.\n+     *\n+     * The issue was sensitive to the ordering of 'Info-ZIP extended timestamp' fields and\n+     * 'Zip64 extended information' fields. ZipOutputStream and 'Info-ZIP' order these differently.\n+     *\n+     * ZipFileSystem tried to read the Local file header while parsing the extended timestamp,\n+     * but if the Zip64 extra field was not read yet, ZipFileSystem would incorrecly try to read\n+     * the Local File header from offset 0xFFFFFFFF.\n+     *\n+     * This method creates a ZIP file which includes a CEN with the following features:\n+     *\n+     * - Its extra field has a 'Info-ZIP extended timestamp' field followed by a\n+     *   'Zip64 extended information' field.\n+     * - The sizes and offset fields values of the CEN are set to 0xFFFFFFFF (Zip64 magic values)\n+     *\n@@ -164,9 +178,3 @@\n-    private static Result run(ProcessBuilder pb) {\n-        Process p;\n-        System.out.printf(\"Running: %s%n\", pb.command());\n-        try {\n-            p = pb.start();\n-        } catch (IOException e) {\n-            throw new RuntimeException(\n-                    format(\"Couldn't start process '%s'\", pb.command()), e);\n-        }\n+    public void createZipWithZip64Ext() throws IOException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        try (ZipOutputStream zo = new ZipOutputStream(out)) {\n@@ -174,7 +182,19 @@\n-        String output;\n-        try {\n-            output = toString(p.getInputStream(), p.getErrorStream());\n-        } catch (IOException e) {\n-            throw new RuntimeException(\n-                    format(\"Couldn't read process output '%s'\", pb.command()), e);\n-        }\n+            ZipEntry e = new ZipEntry(\"entry\");\n+            \/\/ Add an entry, make it STORED and empty to simplify parsing\n+            e.setMethod(ZipEntry.STORED);\n+            e.setSize(0);\n+            e.setCrc(0);\n+            zo.putNextEntry(e);\n+\n+            \/\/ Add an additional entry as a sanity check that we can navigate past the first\n+            ZipEntry e2 = new ZipEntry(\"entry2\");\n+            e2.setMethod(ZipEntry.STORED);\n+            e2.setSize(0);\n+            e2.setCrc(0);\n+            zo.putNextEntry(e2);\n+\n+            \/\/ For good measure, add a third, DEFLATED entry with some content\n+            ZipEntry e3 = new ZipEntry(\"entry3\");\n+            e3.setMethod(ZipEntry.DEFLATED);\n+            zo.putNextEntry(e3);\n+            zo.write(\"Hello\".getBytes(StandardCharsets.UTF_8));\n@@ -182,5 +202,14 @@\n-        try {\n-            p.waitFor();\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(\n-                    format(\"Process hasn't finished '%s'\", pb.command()), e);\n+            zo.closeEntry(); \/\/ At this point, all LOC headers are written.\n+\n+            \/\/ We want the first CEN entry to have two extra fields:\n+            \/\/ 1: A 'Info-Zip extended timestamp' extra field, generated by ZipOutputStream\n+            \/\/       when the following date fields are set:\n+            e.setLastModifiedTime(FileTime.from(Instant.now()));\n+            e.setLastAccessTime(FileTime.from(Instant.now()));\n+\n+            \/\/ 2: An opaque extra field, right-sized for a Zip64 extended field,\n+            \/\/    to be updated below\n+            byte[] zip64 = makeOpaqueExtraField();\n+            e.setExtra(zip64);\n+\n+            zo.finish(); \/\/ Write out CEN and END records\n@@ -188,1 +217,7 @@\n-        return new Result(p.exitValue(), output);\n+\n+        byte[] zip = out.toByteArray();\n+\n+        \/\/ ZIP now has the right structure, but we need to update the CEN to Zip64 format\n+        updateToZip64(zip);\n+        \/\/ Write the ZIP to disk\n+        Files.write(Path.of(ZIP_FILE_NAME), zip);\n@@ -192,5 +227,4 @@\n-     * Utility Method for combining the output from a ProcessBuilder invocation\n-     * @param in1 ProccessBuilder.getInputStream\n-     * @param in2 ProcessBuilder.getErrorStream\n-     * @return The ProcessBuilder output\n-     * @throws IOException if an error occurs\n+     * Returns an opaque extra field with the tag 'unknown', which makes ZipEntry.setExtra ignore it.\n+     * The returned field has the expected field and data size of a Zip64 extended information field\n+     * including the fields 'uncompressed size' (8 bytes), 'compressed size' (8 bytes) and\n+     * 'local header offset' (8 bytes).\n@@ -198,6 +232,8 @@\n-    static String toString(InputStream in1, InputStream in2) throws IOException {\n-        try (ByteArrayOutputStream dst = new ByteArrayOutputStream();\n-             InputStream concatenated = new SequenceInputStream(in1, in2)) {\n-            concatenated.transferTo(dst);\n-            return new String(dst.toByteArray(), StandardCharsets.UTF_8);\n-        }\n+    private static byte[] makeOpaqueExtraField() {\n+        byte[] zip64 = new byte[ZIP64_SIZE];\n+        ByteBuffer buffer = ByteBuffer.wrap(zip64).order(ByteOrder.LITTLE_ENDIAN);\n+        \/\/ Using the 'unknown' tag makes ZipEntry.setExtra ignore it\n+        buffer.putShort(UNKNOWN_TAG);\n+        \/\/ Data size\n+        buffer.putShort(ZIP64_DATA_SIZE);\n+        return zip64;\n@@ -207,1 +243,1 @@\n-     * Utility class used to hold the results from  a ProcessBuilder execution\n+     * Update the CEN record to Zip64 format\n@@ -209,3 +245,1 @@\n-    static class Result {\n-        final int ec;\n-        final String output;\n+    private static void updateToZip64(byte[] bytes) throws IOException {\n@@ -213,8 +247,23 @@\n-        private Result(int ec, String output) {\n-            this.ec = ec;\n-            this.output = output;\n-        }\n-        Result assertSuccess() {\n-            assertTrue(ec == 0, \"Expected ec 0, got: \", ec, \" , output [\", output, \"]\");\n-            return this;\n-        }\n+        ByteBuffer buffer = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        \/\/ Look up CEN offset from the End of central directory header\n+        int cenOff = getCenOffet(buffer);\n+\n+        \/\/ Read name, extra field and comment lengths from CEN\n+        short nlen = buffer.getShort(cenOff + ZipFile.CENNAM);\n+        short elen = buffer.getShort(cenOff + ZipFile.CENEXT);\n+\n+        \/\/ Update CEN sizes and loc offset to 0xFFFFFFFF, meaning\n+        \/\/ actual values should be read from the Zip64 field\n+        buffer.putInt(cenOff + ZipFile.CENLEN, ZIP64_MAGIC_VALUE);\n+        buffer.putInt(cenOff + ZipFile.CENSIZ, ZIP64_MAGIC_VALUE);\n+        buffer.putInt(cenOff + ZipFile.CENOFF, ZIP64_MAGIC_VALUE);\n+\n+        \/\/ Offset of the extra fields\n+        int extraOff = cenOff + ZipFile.CENHDR + nlen;\n+\n+        \/\/ Position at the start of the Zip64 extra field\n+        int zip64ExtraOff = extraOff + elen - ZIP64_SIZE;\n+\n+        \/\/ Update tag \/ Header ID to be the actual Zip64 tag instead of the 'unknown'\n+        buffer.putShort(zip64ExtraOff, ZIP64_TAG);\n@@ -222,7 +271,6 @@\n-    static void assertTrue(boolean cond, Object ... failedArgs) {\n-        if (cond)\n-            return;\n-        StringBuilder sb = new StringBuilder();\n-        for (Object o : failedArgs)\n-            sb.append(o);\n-        Assert.fail(sb.toString());\n+\n+    \/**\n+     * Look up the CEN offset field from the End of central directory header\n+     *\/\n+    private static int getCenOffet(ByteBuffer buffer) {\n+        return buffer.getInt(buffer.capacity() - ZipFile.ENDHDR + ZipFile.ENDOFF);\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/TestLocOffsetFromZip64EF.java","additions":165,"deletions":117,"binary":false,"changes":282,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-import java.io.File;\n@@ -46,1 +45,0 @@\n-import java.util.Properties;\n@@ -49,1 +47,0 @@\n-import jdk.test.lib.process.OutputAnalyzer;\n@@ -51,0 +48,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -90,22 +88,4 @@\n-        var launcher = Path.of(System.getProperty(\"test.nativepath\"), \"NullCallerTest\");\n-        var pb = new ProcessBuilder(launcher.toString());\n-        var env = pb.environment();\n-\n-        var libDir = Platform.libDir().toString();\n-        var vmDir = Platform.jvmLibDir().toString();\n-\n-        \/\/ set up shared library path\n-        var sharedLibraryPathEnvName = Platform.sharedLibraryPathVariableName();\n-        env.compute(sharedLibraryPathEnvName,\n-                (k, v) -> (v == null) ? libDir : v + File.pathSeparator + libDir);\n-        env.compute(sharedLibraryPathEnvName,\n-                (k, v) -> (v == null) ? vmDir : v + File.pathSeparator + vmDir);\n-\n-        \/\/ launch the actual test\n-        System.out.println(\"Launching: \" + launcher + \" shared library path: \" +\n-                env.get(sharedLibraryPathEnvName));\n-        new OutputAnalyzer(pb.start())\n-                .outputTo(System.out)\n-                .errorTo(System.err)\n-                .shouldHaveExitValue(0);\n-\n+        ProcessBuilder pb = ProcessTools.createNativeTestProcessBuilder(\"NullCallerTest\");\n+        System.out.println(\"Launching: \" + pb.command() + \" shared library path: \" +\n+                               pb.environment().get(Platform.sharedLibraryPathVariableName()));\n+        ProcessTools.executeProcess(pb).shouldHaveExitValue(0);\n","filename":"test\/jdk\/jni\/nullCaller\/NullCallerTest.java","additions":6,"deletions":26,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -210,2 +210,1 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop globalsigneccrootcar4 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop globalsigneccrootcar4 CRL\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop globalsigneccrootcar4 DEFAULT\n@@ -220,2 +219,1 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop gtsrootcar1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop gtsrootcar1 CRL\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop gtsrootcar1 DEFAULT\n@@ -230,2 +228,1 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop gtsrootcar2 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop gtsrootcar2 CRL\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop gtsrootcar2 DEFAULT\n@@ -240,2 +237,1 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop gtsrootecccar3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop gtsrootecccar3 CRL\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop gtsrootecccar3 DEFAULT\n@@ -250,2 +246,1 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop gtsrootecccar4 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop gtsrootecccar4 CRL\n+ * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop gtsrootecccar4 DEFAULT\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/CAInterop.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4366799\n+ * @key headful\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary verifies that Windows applications react to palette\n+ * changes in 8-bit mode correctly.\n+ * @run main\/manual PaletteTester\n+*\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Graphics;\n+import java.awt.Image;\n+import java.awt.Frame;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.image.VolatileImage;\n+import javax.swing.ImageIcon;\n+import javax.swing.JPanel;\n+import java.io.File;\n+\n+public class PaletteTester {\n+\n+    static VImageColors demo;\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+        This test should be run on any Windows platform in 8-bit\n+        (256 color) display mode only. To check for errors, run a browser\n+        application (Firefox or Internet Explorer) at the same time\n+        and switch between this test and the browser (by clicking on the\n+        title bars).\n+\n+        The three panels in this test should look roughly the same (there\n+        may be some dithering differences if you switch display modes\n+        during the test, but the overall look should be the same.  If\n+        completely different colors are being used (either for the orange\n+        background fill, the text, the image, or the rectangles), then the\n+        test has failed.\n+        \"\"\";\n+\n+    private static void init() {\n+\n+        int width = 300, height = 300;\n+\n+        demo = new VImageColors();\n+        Frame f = new Frame(\"PaletteTester\");\n+        f.addWindowListener(new WindowAdapter() {\n+            public void windowClosing(WindowEvent e) {}\n+            public void windowDeiconified(WindowEvent e) { demo.start(); }\n+            public void windowIconified(WindowEvent e) { demo.stop(); }\n+        });\n+        f.add(demo);\n+        f.setSize(new Dimension(width, height));\n+        f.setLocationRelativeTo(null);\n+\n+        PassFailJFrame.addTestWindow(f);\n+        PassFailJFrame.positionTestWindow(f, PassFailJFrame.Position.HORIZONTAL);\n+        f.setVisible(true);\n+\n+        demo.start();\n+\n+    }\/\/End  init()\n+\n+    public static void main( String args[] ) throws Exception {\n+\n+        PassFailJFrame passFailJFrame = new PassFailJFrame.Builder()\n+                                        .title(\"PaletteTester Instructions\")\n+                                        .instructions(INSTRUCTIONS)\n+                                        .testTimeOut(5)\n+                                        .rows(15)\n+                                        .columns(40)\n+                                        .screenCapture()\n+                                        .build();\n+\n+        EventQueue.invokeAndWait(PaletteTester::init);\n+\n+\n+        try {\n+            passFailJFrame.awaitAndCheck();\n+        } finally {\n+            demo.stop();\n+        }\n+    }\/\/main\n+}\n+\n+\/\/************ Begin classes defined for the test ****************\n+\n+class VImageColors extends JPanel implements Runnable {\n+\n+    VolatileImage vImage;\n+    Image bImage;\n+    private static int width = 300, height = 300;\n+    private Thread thread;\n+    Color fillColor = new Color(240, 188, 136);\n+    Color textColor = new Color(40, 18, 97);\n+    Color rectColor = new Color(0, 150, 0);\n+    File f = new File(System.getProperty(\"test.src\", \".\"), \"duke.gif\");\n+    Image duke = new ImageIcon(f.toString()).getImage();\n+\n+    public void initOffscreen() {\n+        vImage = this.createVolatileImage(getWidth()\/3, getHeight());\n+        bImage = this.createImage(getWidth()\/3, getHeight());\n+    }\n+\n+    public void paint(Graphics g) {\n+        int width = getWidth();\n+        int height = getHeight();\n+\n+        if (vImage == null) {\n+            initOffscreen();\n+        }\n+\n+        \/\/ Render the left panel via VolatileImage\n+        do {\n+            if (\n+                vImage.validate(getGraphicsConfiguration()) ==\n+                VolatileImage.IMAGE_INCOMPATIBLE)\n+            {\n+                vImage = createVolatileImage(width\/3, height);\n+            }\n+            Graphics vg = vImage.createGraphics();\n+            vg.setColor(fillColor);\n+            vg.fillRect(0, 0, width\/3, height);\n+            vg.drawImage(duke, 0, 0, null);\n+            vg.setColor(textColor);\n+            vg.drawString(\"Vol Image\", 5, height-1);\n+            vg.setColor(rectColor);\n+            vg.drawRect(0, 0, width\/3-1, height-1);\n+            vg.dispose();\n+            g.drawImage(vImage, 0, 0, width\/3, height, null);\n+        } while (vImage.contentsLost());\n+\n+        \/\/ Render the middle panel via BufferedImage\n+        Graphics bg = bImage.getGraphics();\n+        bg.setColor(fillColor);\n+        bg.fillRect(0, 0, width\/3, height);\n+        bg.drawImage(duke, 0, 0, null);\n+        bg.setColor(textColor);\n+        bg.drawString(\"Buff Image\", 5, height-1);\n+        bg.setColor(rectColor);\n+        bg.drawRect(0, 0, width\/3-1, height-1);\n+        bg.dispose();\n+        g.drawImage(bImage, width\/3, 0, width\/3, height, null);\n+\n+        \/\/ Render the right panel directly to the screen\n+        g.setColor(fillColor);\n+        g.fillRect(2*(width\/3), 0, width\/3, height);\n+        g.drawImage(duke, 2*(width\/3), 0, null);\n+        g.setColor(textColor);\n+        g.drawString(\"Screen\", 2*(width\/3) + 5, height-1);\n+        g.setColor(rectColor);\n+        g.drawRect(2*(width\/3), 0, width\/3-1, height-1);\n+\n+    }\n+\n+    public void start() {\n+        thread = new Thread(this);\n+        thread.setPriority(Thread.MIN_PRIORITY);\n+        thread.start();\n+    }\n+\n+    public synchronized void stop() {\n+        thread = null;\n+    }\n+\n+    public void run() {\n+        Thread me = Thread.currentThread();\n+        while (thread == me) {\n+            try {\n+                thread.sleep(100);\n+            } catch (InterruptedException e) { break; }\n+        }\n+        thread = null;\n+    }\n+}\n+\n+\/\/************** End classes defined for the test *******************\n","filename":"test\/jdk\/sun\/awt\/PaletteTester.java","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"","filename":"test\/jdk\/sun\/awt\/duke.gif","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/awt\/image\/VolatileImage\/duke.gif","status":"copied"},{"patch":"@@ -55,1 +55,1 @@\n- * @bug 8012229 8300725 8279216\n+ * @bug 8012229 8300725 8279216 8323210\n","filename":"test\/jdk\/sun\/java2d\/cmm\/ColorConvertOp\/ColCvtAlphaDifferentSrcDst.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- *          would return default \"content\/unknown\"\n+ *          return default \"content\/unknown\"\n@@ -40,1 +40,1 @@\n-import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -52,3 +52,3 @@\n-        ProcessTools.executeCommand(\n-                JDKToolFinder.getTestJDKTool(\"java\"),\n-                \"-cp\", resJar + File.pathSeparator + classes, \"GetContentType\")\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                \"-cp\", resJar + File.pathSeparator + classes, \"GetContentType\");\n+        new OutputAnalyzer(pb.start())\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/jar\/GetContentTypeTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -84,1 +85,0 @@\n-        String java = JDKToolFinder.getTestJDKTool(\"java\");\n@@ -88,4 +88,5 @@\n-            ProcessTools.executeCommand(java, \"-cp\", cp, test)\n-                        .outputTo(System.out)\n-                        .errorTo(System.out)\n-                        .shouldHaveExitValue(0);\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\"-cp\", cp, test);\n+            new OutputAnalyzer(pb.start())\n+                    .outputTo(System.out)\n+                    .errorTo(System.out)\n+                    .shouldHaveExitValue(0);\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/jar\/jarbug\/TestDriver.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,2 @@\n-import jdk.test.lib.JDKToolFinder;\n-import static jdk.test.lib.process.ProcessTools.executeCommand;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n@@ -42,6 +42,7 @@\n-        executeCommand(JDKToolFinder.getTestJDKTool(\"java\"),\n-                       \"--limit-modules\", \"java.base\",\n-                       \"-cp\", classes, \"OtherResources\")\n-                      .outputTo(System.out)\n-                      .errorTo(System.out)\n-                      .shouldHaveExitValue(0);\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                \"--limit-modules\", \"java.base\",\n+                \"-cp\", classes, \"OtherResources\");\n+        new OutputAnalyzer(pb.start())\n+                .outputTo(System.out)\n+                .errorTo(System.out)\n+                .shouldHaveExitValue(0);\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/jrt\/OtherResourcesTest.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,228 +0,0 @@\n-\/*\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.reflect.*;\n-import java.util.Hashtable;\n-import java.util.Enumeration;\n-import java.util.Vector;\n-import java.io.*;\n-import java.text.*;\n-\n-\/**\n- * IntlTest is a base class for tests that can be run conveniently from\n- * the command line as well as under the Java test harness.\n- * <p>\n- * Sub-classes implement a set of methods named Test<something>. Each\n- * of these methods performs some test. Test methods should indicate\n- * errors by calling either err or errln.  This will increment the\n- * errorCount field and may optionally print a message to the log.\n- * Debugging information may also be added to the log via the log\n- * and logln methods.  These methods will add their arguments to the\n- * log only if the test is being run in verbose mode.\n- *\/\n-public class IntlTest {\n-\n-    \/\/------------------------------------------------------------------------\n-    \/\/ Everything below here is boilerplate code that makes it possible\n-    \/\/ to add a new test by simply adding a function to an existing class\n-    \/\/------------------------------------------------------------------------\n-\n-    protected IntlTest() {\n-        \/\/ Create a hashtable containing all the test methods.\n-        testMethods = new Hashtable();\n-        Method[] methods = getClass().getDeclaredMethods();\n-        for( int i=0; i<methods.length; i++ ) {\n-            if( methods[i].getName().startsWith(\"Test\") ) {\n-                testMethods.put( methods[i].getName(), methods[i] );\n-            }\n-        }\n-    }\n-\n-    protected void run(String[] args) throws Exception\n-    {\n-        System.out.println(getClass().getName() + \" {\");\n-        indentLevel++;\n-\n-        \/\/ Set up the log and reference streams.  We use PrintWriters in order to\n-        \/\/ take advantage of character conversion.  The JavaEsc converter will\n-        \/\/ convert Unicode outside the ASCII range to Java's \\\\uxxxx notation.\n-        log = new PrintWriter(System.out,true);\n-\n-        \/\/ Parse the test arguments.  They can be either the flag\n-        \/\/ \"-verbose\" or names of test methods. Create a list of\n-        \/\/ tests to be run.\n-        Vector testsToRun = new Vector( args.length );\n-        for( int i=0; i<args.length; i++ ) {\n-            if( args[i].equals(\"-verbose\") ) {\n-                verbose = true;\n-            }\n-            else if( args[i].equals(\"-prompt\") ) {\n-                prompt = true;\n-            } else if (args[i].equals(\"-nothrow\")) {\n-                nothrow = true;\n-            } else {\n-                Object m = testMethods.get( args[i] );\n-                if( m != null ) {\n-                    testsToRun.addElement( m );\n-                }\n-                else {\n-                    usage();\n-                    return;\n-                }\n-            }\n-        }\n-\n-        \/\/ If no test method names were given explicitly, run them all.\n-        if( testsToRun.size() == 0 ) {\n-            Enumeration methodNames = testMethods.elements();\n-            while( methodNames.hasMoreElements() ) {\n-                testsToRun.addElement( methodNames.nextElement() );\n-            }\n-        }\n-\n-        \/\/ Run the list of tests given in the test arguments\n-        for( int i=0; i<testsToRun.size(); i++ ) {\n-            int oldCount = errorCount;\n-\n-            Method testMethod = (Method)testsToRun.elementAt(i);\n-            writeTestName(testMethod.getName());\n-\n-            try {\n-                testMethod.invoke(this, new Object[0]);\n-            }\n-            catch( IllegalAccessException e ) {\n-                errln(\"Can't acces test method \" + testMethod.getName());\n-            }\n-            catch( InvocationTargetException e ) {\n-                errln(\"Uncaught exception thrown in test method \"\n-                               + testMethod.getName());\n-                e.getTargetException().printStackTrace(this.log);\n-            }\n-            writeTestResult(errorCount - oldCount);\n-        }\n-        indentLevel--;\n-        writeTestResult(errorCount);\n-\n-        if (prompt) {\n-            System.out.println(\"Hit RETURN to exit...\");\n-            try {\n-                System.in.read();\n-            }\n-            catch (IOException e) {\n-                System.out.println(\"Exception: \" + e.toString() + e.getMessage());\n-            }\n-        }\n-        if (nothrow) {\n-            System.exit(errorCount);\n-        }\n-    }\n-\n-    \/**\n-     * Adds given string to the log if we are in verbose mode.\n-     *\/\n-    protected void log( String message ) {\n-        if( verbose ) {\n-            indent(indentLevel + 1);\n-            log.print( message );\n-        }\n-    }\n-\n-    protected void logln( String message ) {\n-        log(message + System.getProperty(\"line.separator\"));\n-    }\n-\n-    \/**\n-     * Report an error\n-     *\/\n-    protected void err( String message ) {\n-        errorCount++;\n-        indent(indentLevel + 1);\n-        log.print( message );\n-        log.flush();\n-\n-        if (!nothrow) {\n-            throw new RuntimeException(message);\n-        }\n-    }\n-\n-    protected void errln( String message ) {\n-        err(message + System.getProperty(\"line.separator\"));\n-    }\n-\n-\n-    protected void writeTestName(String testName) {\n-        indent(indentLevel);\n-        log.print(testName);\n-        log.flush();\n-        needLineFeed = true;\n-    }\n-\n-    protected void writeTestResult(int count) {\n-        if (!needLineFeed) {\n-            indent(indentLevel);\n-            log.print(\"}\");\n-        }\n-        needLineFeed = false;\n-\n-        if (count != 0)\n-            log.println(\" FAILED\");\n-        else\n-            log.println(\" Passed\");\n-    }\n-\n-    private final void indent(int distance) {\n-        if (needLineFeed) {\n-            log.println(\" {\");\n-            needLineFeed = false;\n-        }\n-        log.print(spaces.substring(0, distance * 2));\n-    }\n-\n-    \/**\n-     * Print a usage message for this test class.\n-     *\/\n-    void usage() {\n-        System.out.println(getClass().getName() +\n-                            \": [-verbose] [-nothrow] [-prompt] [test names]\");\n-\n-        System.out.println(\"test names:\");\n-        Enumeration methodNames = testMethods.keys();\n-        while( methodNames.hasMoreElements() ) {\n-            System.out.println(\"\\t\" + methodNames.nextElement() );\n-        }\n-    }\n-\n-    private boolean     prompt = false;\n-    private boolean     nothrow = false;\n-    protected boolean   verbose = false;\n-\n-    private PrintWriter log;\n-    private int         indentLevel = 0;\n-    private boolean     needLineFeed = false;\n-    private int         errorCount = 0;\n-\n-    private Hashtable testMethods;\n-    private final String spaces = \"                                          \";\n-}\n-\n-\/\/eof\n","filename":"test\/jdk\/sun\/util\/resources\/TimeZone\/IntlTest.java","additions":0,"deletions":228,"binary":false,"changes":228,"status":"deleted"},{"patch":"@@ -105,0 +105,1 @@\n+                \"%define _build_id_links none\",\n","filename":"test\/jdk\/tools\/jpackage\/linux\/LinuxResourceTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n- * @summary Check for extended  RPATHs on *nixes\n+ * @summary Check for extended RPATHs on Linux\n+ * @requires os.family == \"linux\"\n@@ -60,1 +61,1 @@\n-            throw new RuntimeException(\"FAILED: RPATH\/RUNPATH strings \" +\n+            throw new RuntimeException(\"FAILED: RPATH strings \" +\n@@ -63,1 +64,1 @@\n-        System.out.println(javacmd + \" contains expected RPATHS\/RUNPATH\");\n+        System.out.println(javacmd + \" contains expected RPATHS\");\n@@ -67,1 +68,1 @@\n-        String expectedRpath = \".*R(UN)?PATH.*\\\\$ORIGIN\/..\/lib.*\";\n+        String expectedRpath = \".*RPATH.*\\\\$ORIGIN\/..\/lib.*\";\n@@ -72,7 +73,4 @@\n-        if (isLinux) {\n-            RunpathTest rp = new RunpathTest();\n-            if (rp.elfreaderCmd == null) {\n-                System.err.println(\"Warning: test passes vacuously\");\n-                return;\n-            }\n-            rp.testRpath();\n+        RunpathTest rp = new RunpathTest();\n+        if (rp.elfreaderCmd == null) {\n+            System.err.println(\"Warning: test passes vacuously\");\n+            return;\n@@ -80,0 +78,1 @@\n+        rp.testRpath();\n","filename":"test\/jdk\/tools\/launcher\/RunpathTest.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -53,2 +53,6 @@\n-        var t = new TestDocletExample();\n-        t.runTests(m -> new Object[] { Path.of(m.getName()) });\n+        try {\n+            var t = new TestDocletExample();\n+            t.runTests(m -> new Object[] { Path.of(m.getName()) });\n+        } catch (SnippetUtils.ConfigurationException e) {\n+            System.err.println(\"NOTE: \" + e.getMessage() + \"; test skipped\");\n+        }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDocletExample\/TestDocletExample.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,1 +61,5 @@\n-        new TestJavaxToolsSnippets().runTests(m -> new Object[] { Path.of(m.getName()) });\n+        try {\n+            new TestJavaxToolsSnippets().runTests(m -> new Object[] { Path.of(m.getName()) });\n+        } catch (SnippetUtils.ConfigurationException e) {\n+            System.err.println(\"NOTE: \" + e.getMessage() + \"; test skipped\");\n+        }\n","filename":"test\/langtools\/tools\/javac\/api\/snippets\/TestJavaxToolsSnippets.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -143,1 +143,0 @@\n-        subtypeNames.sort((s1, s2) -> s1.compareTo(s2));\n@@ -696,0 +695,34 @@\n+\n+    @Test\n+    public void testClientSwapsPermittedSubclassesOrder(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path foo = src.resolve(\"Foo.java\");\n+        Path fooUser = src.resolve(\"FooUser.java\");\n+\n+        tb.writeFile(foo,\n+                \"\"\"\n+                public sealed interface Foo {\n+                    record R1() implements Foo {}\n+                    record R2() implements Foo {}\n+                }\n+                \"\"\");\n+\n+        tb.writeFile(fooUser,\n+                \"\"\"\n+                public class FooUser {\n+                    \/\/ see that the order of arguments differ from the order of subclasses of Foo in the source above\n+                    \/\/ we need to check that the order of permitted subclasses of Foo in the class file corresponds to the\n+                    \/\/ original order in the source code\n+                    public void blah(Foo.R2 a, Foo.R1 b) {}\n+                }\n+                \"\"\");\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .files(fooUser, foo)\n+                .run();\n+        checkSealedClassFile(out, \"Foo.class\", List.of(\"Foo$R1\", \"Foo$R2\"));\n+    }\n","filename":"test\/langtools\/tools\/javac\/sealed\/SealedDiffConfigurationsTest.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -28,3 +28,1 @@\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -36,1 +34,1 @@\n- * @run testng jdk.test.lib.format.ArrayDiffTest\n+ * @run junit jdk.test.lib.format.ArrayDiffTest\n@@ -38,1 +36,1 @@\n-public class ArrayDiffTest {\n+class ArrayDiffTest {\n@@ -41,1 +39,1 @@\n-    public void testEqualArrays() {\n+    void testEqualArrays() {\n@@ -49,1 +47,1 @@\n-    public void testOutputFitsWidth() {\n+    void testOutputFitsWidth() {\n@@ -65,1 +63,1 @@\n-    public void testIntegers() {\n+    void testIntegers() {\n@@ -81,1 +79,1 @@\n-    public void testLongs() {\n+    void testLongs() {\n@@ -97,1 +95,1 @@\n-    public void testFirstElementIsWrong() {\n+    void testFirstElementIsWrong() {\n@@ -113,1 +111,1 @@\n-    public void testOneElementIsEmpty() {\n+    void testOneElementIsEmpty() {\n@@ -129,1 +127,1 @@\n-    public void testOutputDoesntFitWidth() {\n+    void testOutputDoesntFitWidth() {\n@@ -145,1 +143,1 @@\n-    public void testVariableElementWidthOutputDoesntFitWidth() {\n+    void testVariableElementWidthOutputDoesntFitWidth() {\n@@ -161,1 +159,1 @@\n-    public void testContextBefore() {\n+    void testContextBefore() {\n@@ -177,1 +175,1 @@\n-    public void testBoundedBytesWithDifferentWidth() {\n+    void testBoundedBytesWithDifferentWidth() {\n@@ -193,1 +191,1 @@\n-    public void testBoundedFirstElementIsWrong() {\n+    void testBoundedFirstElementIsWrong() {\n@@ -209,1 +207,1 @@\n-    public void testBoundedOneArchiveIsEmpty() {\n+    void testBoundedOneArchiveIsEmpty() {\n@@ -225,1 +223,1 @@\n-    public void testUnboundedOneArchiveIsEmpty() {\n+    void testUnboundedOneArchiveIsEmpty() {\n@@ -241,1 +239,1 @@\n-    public void testUnprintableCharFormatting() {\n+    void testUnprintableCharFormatting() {\n@@ -257,1 +255,1 @@\n-    public void testStringElements() {\n+    void testStringElements() {\n@@ -273,1 +271,1 @@\n-    public void testToStringableObjects() {\n+    void testToStringableObjects() {\n@@ -297,1 +295,1 @@\n-    public void testNullElements() {\n+    void testNullElements() {\n@@ -312,3 +310,3 @@\n-    @Test (expectedExceptions = NullPointerException.class)\n-    public void testFirstArrayIsNull() {\n-        var diff = ArrayDiff.of(null, new String[] {\"a\", \"b\"});\n+    @Test\n+    void testFirstArrayIsNull() {\n+        assertThrows(NullPointerException.class, () -> ArrayDiff.of(null, new String[] {\"a\", \"b\"}));\n@@ -317,3 +315,3 @@\n-    @Test (expectedExceptions = NullPointerException.class)\n-    public void testSecondArrayIsNull() {\n-        var diff = ArrayDiff.of(null, new String[] {\"a\", \"b\"});\n+    @Test\n+    void testSecondArrayIsNull() {\n+        assertThrows(NullPointerException.class, () -> ArrayDiff.of(new String[] {\"a\", \"b\"}, null));\n@@ -334,1 +332,1 @@\n-        public AssertBuilder withDefaultParams() {\n+        AssertBuilder withDefaultParams() {\n@@ -339,1 +337,1 @@\n-        public AssertBuilder withParams(int width, int contextBefore) {\n+        AssertBuilder withParams(int width, int contextBefore) {\n@@ -346,1 +344,1 @@\n-        public AssertBuilder withArrays(Object first, Object second) {\n+        AssertBuilder withArrays(Object first, Object second) {\n@@ -352,1 +350,1 @@\n-        public AssertBuilder thatResultIs(boolean result) {\n+        AssertBuilder thatResultIs(boolean result) {\n@@ -357,1 +355,1 @@\n-        public AssertBuilder thatFormattedValuesAre(\n+        AssertBuilder thatFormattedValuesAre(\n@@ -366,1 +364,1 @@\n-        public void assertTwoWay() {\n+        void assertTwoWay() {\n@@ -385,1 +383,1 @@\n-                assertEquals(diff.format(), expected);\n+                assertEquals(expected, diff.format());\n@@ -404,1 +402,1 @@\n-                assertEquals(diff.format(), expected);\n+                assertEquals(expected, diff.format());\n","filename":"test\/lib-test\/jdk\/test\/lib\/format\/ArrayDiffTest.java","additions":36,"deletions":38,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,1 @@\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -37,1 +36,1 @@\n-import static org.testng.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -45,1 +44,1 @@\n- * @run testng jdk.test.lib.hexdump.ASN1FormatterTest\n+ * @run junit jdk.test.lib.hexdump.ASN1FormatterTest\n@@ -47,2 +46,1 @@\n-@Test\n-public class ASN1FormatterTest {\n+class ASN1FormatterTest {\n@@ -52,1 +50,1 @@\n-    static void testPEM() throws IOException {\n+    void testPEM() throws IOException {\n@@ -67,5 +65,5 @@\n-            Assert.assertEquals(result.lines().count(), 76, \"Lines\");\n-            Assert.assertEquals(result.lines().filter(s -> s.contains(\"SEQUENCE\")).count(),24, \"Sequences\");\n-            Assert.assertEquals(result.lines().filter(s -> s.contains(\"OBJECT ID\")).count(), 17, \"ObjectIDs\");\n-            Assert.assertEquals(result.lines().filter(s -> s.contains(\"UTCTIME\")).count(), 2, \"UTCTIME\");\n-            Assert.assertEquals(result.lines().filter(s -> s.contains(\"BIT STRING\")).count(), 3, \"BitStrings\");\n+            assertEquals(76, result.lines().count(), \"Lines\");\n+            assertEquals(24, result.lines().filter(s -> s.contains(\"SEQUENCE\")).count(),\"Sequences\");\n+            assertEquals(17, result.lines().filter(s -> s.contains(\"OBJECT ID\")).count(), \"ObjectIDs\");\n+            assertEquals(2, result.lines().filter(s -> s.contains(\"UTCTIME\")).count(), \"UTCTIME\");\n+            assertEquals(3, result.lines().filter(s -> s.contains(\"BIT STRING\")).count(), \"BitStrings\");\n@@ -78,1 +76,1 @@\n-    static void dumpPEM() throws IOException {\n+    void dumpPEM() throws IOException {\n@@ -95,5 +93,5 @@\n-            Assert.assertEquals(result.lines().count(), 126, \"Lines\");\n-            Assert.assertEquals(result.lines().filter(s -> s.contains(\"SEQUENCE\")).count(), 24, \"Sequences\");\n-            Assert.assertEquals(result.lines().filter(s -> s.contains(\"OBJECT ID\")).count(), 17, \"ObjectIDs\");\n-            Assert.assertEquals(result.lines().filter(s -> s.contains(\"UTCTIME\")).count(), 2, \"UTCTIME\");\n-            Assert.assertEquals(result.lines().filter(s -> s.contains(\"BIT STRING\")).count(), 3, \"BitStrings\");\n+            assertEquals(126, result.lines().count(), \"Lines\");\n+            assertEquals(24, result.lines().filter(s -> s.contains(\"SEQUENCE\")).count(), \"Sequences\");\n+            assertEquals(17, result.lines().filter(s -> s.contains(\"OBJECT ID\")).count(), \"ObjectIDs\");\n+            assertEquals(2, result.lines().filter(s -> s.contains(\"UTCTIME\")).count(), \"UTCTIME\");\n+            assertEquals(3, result.lines().filter(s -> s.contains(\"BIT STRING\")).count(), \"BitStrings\");\n@@ -106,1 +104,1 @@\n-    static void testIndefinite() {\n+    void testIndefinite() {\n@@ -113,6 +111,6 @@\n-        Assert.assertEquals(result.lines().filter(s -> s.contains(\"OCTET STRING [INDEFINITE]\")).count(),\n-                1, \"Indefinite length\");\n-        Assert.assertEquals(result.lines().filter(s -> s.contains(\";   OCTET STRING [2]\")).count(),\n-                2, \"Octet Sequences\");\n-        Assert.assertEquals(result.lines().filter(s -> s.contains(\";   END-OF-CONTENT\")).count(),\n-                1, \"end of content\");\n+        assertEquals(1, result.lines().filter(s -> s.contains(\"OCTET STRING [INDEFINITE]\")).count(),\n+                \"Indefinite length\");\n+        assertEquals(2, result.lines().filter(s -> s.contains(\";   OCTET STRING [2]\")).count(),\n+                \"Octet Sequences\");\n+        assertEquals(1, result.lines().filter(s -> s.contains(\";   END-OF-CONTENT\")).count(),\n+                \"end of content\");\n@@ -122,1 +120,1 @@\n-    static void testMain() {\n+    void testMain() {\n","filename":"test\/lib-test\/jdk\/test\/lib\/hexdump\/ASN1FormatterTest.java","additions":25,"deletions":27,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,4 @@\n-import org.testng.Assert;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.Arguments;\n@@ -39,0 +40,3 @@\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -46,1 +50,1 @@\n- * @run testng jdk.test.lib.hexdump.HexPrinterTest\n+ * @run junit jdk.test.lib.hexdump.HexPrinterTest\n@@ -48,1 +52,1 @@\n-public class HexPrinterTest {\n+class HexPrinterTest {\n@@ -51,1 +55,1 @@\n-    static void testMinimalToStringByteArray() {\n+    void testMinimalToStringByteArray() {\n@@ -59,15 +63,1 @@\n-        Assert.assertEquals(actual, expected.toString(), \"Minimal format incorrect\");\n-    }\n-\n-    @DataProvider(name = \"ColumnParams\")\n-    Object[][] columnParams() {\n-        return new Object[][]{\n-                {\"%4d: \", \"%d \", 10, \" ; \", 50, HexPrinter.Formatters.PRINTABLE, \"\\n\"},\n-                {\"%03o: \", \"%d \", 16, \" ; \", 50, HexPrinter.Formatters.ofPrimitive(byte.class, \"\"), \"\\n\"},\n-                {\"%5d: \", \"%02x:\", 16, \" ; \", 50, HexPrinter.Formatters.ofPrimitive(byte.class, \"\"), \"\\n\"},\n-                {\"%5d: \", \"%3d\", 16, \" ; \", 50, HexPrinter.Formatters.ofPrimitive(byte.class, \"\"), \"\\n\"},\n-                {\"%05o: \", \"%3o\", 8, \" ; \", 50, HexPrinter.Formatters.ofPrimitive(byte.class, \"\"), \"\\n\"},\n-                {\"%6x: \", \"%02x\", 8, \" | \", 50, HexPrinter.Formatters.ofPrimitive(byte.class, \"%d \"), \"\\n\"},\n-                {\"%2x: \", \"%02x\", 8, \" | \", 50, HexPrinter.Formatters.PRINTABLE, \"\\n\"},\n-                {\"%5d: \", \"%02x\", 16, \" | \", 50, HexPrinter.Formatters.ofPrimitive(short.class, \"%d \"), \"\\n\"},\n-        };\n+        assertEquals(expected.toString(), actual, \"Minimal format incorrect\");\n@@ -76,8 +66,20 @@\n-    @DataProvider(name = \"BuiltinParams\")\n-    Object[][] builtinParams() {\n-        return new Object[][]{\n-                {\"minimal\", \"\", \"%02x\", 16, \"\", 64, HexPrinter.Formatters.NONE, \"\"},\n-                {\"canonical\", \"%08x  \", \"%02x \", 16, \"|\", 31, HexPrinter.Formatters.PRINTABLE, \"|\" + System.lineSeparator()},\n-                {\"simple\", \"%04x: \", \"%02x \", 16, \" \/\/ \", 64, HexPrinter.Formatters.ASCII, System.lineSeparator()},\n-                {\"source\", \"    \", \"(byte)%3d, \", 8, \" \/\/ \", 64, HexPrinter.Formatters.PRINTABLE,  System.lineSeparator()},\n-        };\n+    static Stream<Arguments> columnParams() {\n+        return Stream.of(\n+                Arguments.of(\"%4d: \", \"%d \", 10, \" ; \", 50, HexPrinter.Formatters.PRINTABLE, \"\\n\"),\n+                Arguments.of(\"%03o: \", \"%d \", 16, \" ; \", 50, HexPrinter.Formatters.ofPrimitive(byte.class, \"\"), \"\\n\"),\n+                Arguments.of(\"%5d: \", \"%02x:\", 16, \" ; \", 50, HexPrinter.Formatters.ofPrimitive(byte.class, \"\"), \"\\n\"),\n+                Arguments.of(\"%5d: \", \"%3d\", 16, \" ; \", 50, HexPrinter.Formatters.ofPrimitive(byte.class, \"\"), \"\\n\"),\n+                Arguments.of(\"%05o: \", \"%3o\", 8, \" ; \", 50, HexPrinter.Formatters.ofPrimitive(byte.class, \"\"), \"\\n\"),\n+                Arguments.of(\"%6x: \", \"%02x\", 8, \" | \", 50, HexPrinter.Formatters.ofPrimitive(byte.class, \"%d \"), \"\\n\"),\n+                Arguments.of(\"%2x: \", \"%02x\", 8, \" | \", 50, HexPrinter.Formatters.PRINTABLE, \"\\n\"),\n+                Arguments.of(\"%5d: \", \"%02x\", 16, \" | \", 50, HexPrinter.Formatters.ofPrimitive(short.class, \"%d \"), \"\\n\")\n+        );\n+    }\n+\n+    static Stream<Arguments> builtinParams() {\n+        return Stream.of(\n+                Arguments.of(\"minimal\", \"\", \"%02x\", 16, \"\", 64, HexPrinter.Formatters.NONE, \"\"),\n+                Arguments.of(\"canonical\", \"%08x  \", \"%02x \", 16, \"|\", 31, HexPrinter.Formatters.PRINTABLE, \"|\" + System.lineSeparator()),\n+                Arguments.of(\"simple\", \"%04x: \", \"%02x \", 16, \" \/\/ \", 64, HexPrinter.Formatters.ASCII, System.lineSeparator()),\n+                Arguments.of(\"source\", \"    \", \"(byte)%3d, \", 8, \" \/\/ \", 64, HexPrinter.Formatters.PRINTABLE, System.lineSeparator())\n+        );\n@@ -86,2 +88,3 @@\n-    @Test(dataProvider = \"BuiltinParams\")\n-    public void testBuiltins(String name, String offsetFormat, String binFormat, int colWidth,\n+    @ParameterizedTest\n+    @MethodSource(\"builtinParams\")\n+    void testBuiltins(String name, String offsetFormat, String binFormat, int colWidth,\n@@ -107,1 +110,1 @@\n-        Assert.assertEquals(actual, expected, \"toString of \" + name + \" does not match\");\n+        assertEquals(expected, actual, \"toString of \" + name + \" does not match\");\n@@ -110,2 +113,3 @@\n-    @Test(dataProvider = \"ColumnParams\")\n-    public void testToStringTwoLines(String offsetFormat, String binFormat, int colWidth,\n+    @ParameterizedTest\n+    @MethodSource(\"columnParams\")\n+    void testToStringTwoLines(String offsetFormat, String binFormat, int colWidth,\n@@ -122,1 +126,1 @@\n-    public static void testParams(HexPrinter printer, String offsetFormat, String binFormat, int colWidth,\n+    static void testParams(HexPrinter printer, String offsetFormat, String binFormat, int colWidth,\n@@ -139,1 +143,1 @@\n-                Assert.assertEquals(out.substring(ndx, ndx + l), offset,\n+                assertEquals(offset, out.substring(ndx, ndx + l),\n@@ -146,1 +150,1 @@\n-            Assert.assertEquals(out.substring(ndx, ndx + l), value,\n+            assertEquals(value, out.substring(ndx, ndx + l),\n@@ -152,1 +156,1 @@\n-                Assert.assertEquals(out.substring(ndx, ndx + padding.length()), padding, \"padding\");\n+                assertEquals(padding, out.substring(ndx, ndx + padding.length()), \"padding\");\n@@ -154,1 +158,1 @@\n-                Assert.assertEquals(out.substring(ndx, ndx + annoDelim.length()), annoDelim,\n+                assertEquals(annoDelim, out.substring(ndx, ndx + annoDelim.length()),\n@@ -165,1 +169,1 @@\n-    static void testPrintable() {\n+    void testPrintable() {\n@@ -182,1 +186,1 @@\n-        Assert.assertEquals(actual, expected, \"Formatters.Printable mismatch\");\n+        assertEquals(expected, actual, \"Formatters.Printable mismatch\");\n@@ -186,1 +190,1 @@\n-    static void testASCII() {\n+    void testASCII() {\n@@ -207,15 +211,14 @@\n-        Assert.assertEquals(actual, expected, \"Formatters.ASCII mismatch\");\n-    }\n-\n-    @DataProvider(name = \"PrimitiveFormatters\")\n-    Object[][] formatterParams() {\n-        return new Object[][]{\n-                {byte.class, \"\"},\n-                {byte.class, \"%02x: \"},\n-                {short.class, \"%d \"},\n-                {int.class, \"%08x, \"},\n-                {long.class, \"%16x \"},\n-                {float.class, \"%3.4f \"},\n-                {double.class, \"%6.3g \"},\n-                {boolean.class, \"%b \"},\n-        };\n+        assertEquals(expected, actual, \"Formatters.ASCII mismatch\");\n+    }\n+\n+    static Stream<Arguments> formatterParams() {\n+        return Stream.of(\n+                Arguments.of(byte.class, \"\"),\n+                Arguments.of(byte.class, \"%02x: \"),\n+                Arguments.of(short.class, \"%d \"),\n+                Arguments.of(int.class, \"%08x, \"),\n+                Arguments.of(long.class, \"%16x \"),\n+                Arguments.of(float.class, \"%3.4f \"),\n+                Arguments.of(double.class, \"%6.3g \"),\n+                Arguments.of(boolean.class, \"%b \")\n+        );\n@@ -224,2 +227,3 @@\n-    @Test(dataProvider = \"PrimitiveFormatters\")\n-    public void testFormatter(Class<?> primClass, String fmtString) {\n+    @ParameterizedTest\n+    @MethodSource(\"formatterParams\")\n+    void testFormatter(Class<?> primClass, String fmtString) {\n@@ -238,1 +242,1 @@\n-                Assert.assertEquals(sb.toString(), expected, \"mismatch\");\n+                assertEquals(expected, sb.toString(), \"mismatch\");\n@@ -245,2 +249,2 @@\n-            Assert.assertEquals(in.available(), 0, \"not all input consumed\");\n-            Assert.assertEquals(in2.available(), 0, \"not all 2nd stream input consumed\");\n+            assertEquals(0, in.available(), \"not all input consumed\");\n+            assertEquals(0, in2.available(), \"not all 2nd stream input consumed\");\n@@ -252,2 +256,3 @@\n-    @Test(dataProvider = \"PrimitiveFormatters\")\n-    static void testHexPrinterPrimFormatter(Class<?> primClass, String fmtString) {\n+    @ParameterizedTest\n+    @MethodSource(\"formatterParams\")\n+    void testHexPrinterPrimFormatter(Class<?> primClass, String fmtString) {\n@@ -267,1 +272,1 @@\n-        Assert.assertEquals(actual, expected, \"mismatch\");\n+        assertEquals(expected, actual, \"mismatch\");\n@@ -292,6 +297,5 @@\n-    @DataProvider(name = \"sources\")\n-    Object[][] sources() {\n-        return new Object[][]{\n-                {genBytes(21), 0, -1},\n-                {genBytes(21), 5, 12},\n-        };\n+    static Stream<Arguments> sources() {\n+        return Stream.of(\n+                Arguments.of(genBytes(21), 0, -1),\n+                Arguments.of(genBytes(21), 5, 12)\n+        );\n@@ -300,5 +304,4 @@\n-    @DataProvider(name = \"badsources\")\n-    Object[][] badSources() {\n-        return new Object[][]{\n-                {genBytes(21), 5, 22},\n-        };\n+    static Stream<Arguments> badSources() {\n+        return Stream.of(\n+                Arguments.of(genBytes(21), 5, 22)\n+        );\n@@ -307,1 +310,1 @@\n-    public static byte[] genData(int len) {\n+    static byte[] genData(int len) {\n@@ -317,1 +320,1 @@\n-    public static byte[] genFloat(int len) {\n+    static byte[] genFloat(int len) {\n@@ -330,1 +333,1 @@\n-    public static byte[] genDouble(int len) {\n+    static byte[] genDouble(int len) {\n@@ -343,1 +346,1 @@\n-    public static byte[] genBytes(int len) {\n+    static byte[] genBytes(int len) {\n@@ -350,1 +353,1 @@\n-    public ByteBuffer genByteBuffer(int len) {\n+    ByteBuffer genByteBuffer(int len) {\n@@ -354,1 +357,1 @@\n-    public InputStream genInputStream(int len) {\n+    InputStream genInputStream(int len) {\n@@ -359,1 +362,1 @@\n-    public void testNilPrinterBigBuffer() {\n+    void testNilPrinterBigBuffer() {\n@@ -363,2 +366,9 @@\n-        Assert.assertEquals(r.length(), bytes.length * 2, \"encoded byte wrong size\");\n-        Assert.assertEquals(r.replace(\"00\", \"\").length(), 0, \"contents not all zeros\");\n+        assertEquals(bytes.length * 2, r.length(), \"encoded byte wrong size\");\n+        assertEquals(0, r.replace(\"00\", \"\").length(), \"contents not all zeros\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"badSources\")\n+    void testBadToStringByteBuffer(byte[] bytes, int offset, int length) {\n+        assertThrows(java.lang.IndexOutOfBoundsException.class,\n+                () -> testThrowsForBadToStringByteBuffer(bytes, offset, length));\n@@ -367,3 +377,1 @@\n-    @Test(dataProvider = \"badsources\",\n-            expectedExceptions = java.lang.IndexOutOfBoundsException.class)\n-    public void testBadToStringByteBuffer(byte[] bytes, int offset, int length) {\n+    void testThrowsForBadToStringByteBuffer(byte[] bytes, int offset, int length) {\n@@ -384,1 +392,1 @@\n-        Assert.assertEquals(actual, expected, \"mismatch in format()\");\n+        assertEquals(expected, actual, \"mismatch in format()\");\n@@ -387,2 +395,3 @@\n-    @Test(dataProvider = \"sources\")\n-    public void testToStringByteBuffer(byte[] bytes, int offset, int length) {\n+    @ParameterizedTest\n+    @MethodSource(\"sources\")\n+    void testToStringByteBuffer(byte[] bytes, int offset, int length) {\n@@ -403,1 +412,1 @@\n-        Assert.assertEquals(actual, expected, \"mismatch in format()\");\n+        assertEquals(expected, actual, \"mismatch in format()\");\n@@ -406,2 +415,3 @@\n-    @Test(dataProvider = \"sources\")\n-    public void testFormatBytes(byte[] bytes, int offset, int length) {\n+    @ParameterizedTest\n+    @MethodSource(\"sources\")\n+    void testFormatBytes(byte[] bytes, int offset, int length) {\n@@ -419,1 +429,1 @@\n-        Assert.assertEquals(actual, expected, \"mismatch in format()\");\n+        assertEquals(expected, actual, \"mismatch in format()\");\n@@ -422,2 +432,3 @@\n-    @Test(dataProvider = \"sources\")\n-    public void testFormatByteBuffer(byte[] bytes, int offset, int length) {\n+    @ParameterizedTest\n+    @MethodSource(\"sources\")\n+    void testFormatByteBuffer(byte[] bytes, int offset, int length) {\n@@ -439,1 +450,1 @@\n-        Assert.assertEquals(actual, expected, \"mismatch in format()\");\n+        assertEquals(expected, actual, \"mismatch in format()\");\n@@ -442,2 +453,3 @@\n-    @Test(dataProvider = \"sources\")\n-    public void testFormatInputStream(byte[] bytes, int offset, int length) {\n+    @ParameterizedTest\n+    @MethodSource(\"sources\")\n+    void testFormatInputStream(byte[] bytes, int offset, int length) {\n@@ -453,1 +465,1 @@\n-        Assert.assertEquals(actual, expected, \"mismatch in format()\");\n+        assertEquals(expected, actual, \"mismatch in format()\");\n@@ -456,3 +468,4 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullByteArray() {\n-        HexPrinter.simple().dest(System.out).format((byte[]) null);\n+    @Test\n+    void testNullByteArray() {\n+        assertThrows(NullPointerException.class,\n+                () -> HexPrinter.simple().dest(System.out).format((byte[]) null));\n@@ -461,3 +474,4 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullByteArrayOff() {\n-        HexPrinter.simple().dest(System.out).format((byte[]) null, 0, 1);\n+    @Test\n+    void testNullByteArrayOff() {\n+        assertThrows(NullPointerException.class,\n+                () -> HexPrinter.simple().dest(System.out).format((byte[]) null, 0, 1));\n@@ -466,3 +480,4 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullByteBuffer() {\n-        HexPrinter.simple().dest(System.out).format((ByteBuffer) null);\n+    @Test\n+    void testNullByteBuffer() {\n+        assertThrows(NullPointerException.class,\n+                () -> HexPrinter.simple().dest(System.out).format((ByteBuffer) null));\n@@ -471,3 +486,4 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullByteBufferOff() {\n-        HexPrinter.simple().dest(System.out).format((ByteBuffer) null, 0, 1);\n+    @Test\n+    void testNullByteBufferOff() {\n+        assertThrows(NullPointerException.class,\n+                () -> HexPrinter.simple().dest(System.out).format((ByteBuffer) null, 0, 1));\n@@ -476,3 +492,4 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullInputStream() {\n-        HexPrinter.simple().dest(System.out).format((InputStream) null);\n+    @Test\n+    void testNullInputStream() {\n+        assertThrows(NullPointerException.class, () ->\n+                HexPrinter.simple().dest(System.out).format((InputStream) null));\n","filename":"test\/lib-test\/jdk\/test\/lib\/hexdump\/HexPrinterTest.java","additions":134,"deletions":117,"binary":false,"changes":251,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,4 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.Arguments;\n@@ -50,0 +52,1 @@\n+import java.util.stream.Stream;\n@@ -51,1 +54,1 @@\n-import static org.testng.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -57,1 +60,1 @@\n- * @run testng\/othervm -DDEBUG=true jdk.test.lib.hexdump.ObjectStreamPrinterTest\n+ * @run junit\/othervm -DDEBUG=true jdk.test.lib.hexdump.ObjectStreamPrinterTest\n@@ -64,2 +67,1 @@\n-@Test\n-public class ObjectStreamPrinterTest {\n+class ObjectStreamPrinterTest {\n@@ -70,11 +72,10 @@\n-    @DataProvider(name = \"serializables\")\n-    Object[][] serializables() {\n-        return new Object[][]{\n-                {new Object[]{\"abc\", \"def\"}, 0, 0, 2},\n-                {new Object[]{0, 1}, 2, 2, 0},\n-                {new Object[]{TimeUnit.DAYS, TimeUnit.SECONDS}, 2, 0, 2},\n-                {new Object[]{List.of(\"one\", \"two\", \"three\")}, 1, 1, 3},\n-                {new Object[]{genList()}, 1, 1, 2},\n-                {new Object[]{genMap()}, 1, 1, 5},\n-                {new Object[]{genProxy()}, 5, 2, 9},\n-                {new Object[]{new char[]{'x', 'y', 'z'},\n+    static Stream<Arguments> serializables() {\n+        return Stream.of(\n+                Arguments.of(new Object[]{\"abc\", \"def\"}, 0, 0, 2),\n+                Arguments.of(new Object[]{0, 1}, 2, 2, 0),\n+                Arguments.of(new Object[]{TimeUnit.DAYS, TimeUnit.SECONDS}, 2, 0, 2),\n+                Arguments.of(new Object[]{List.of(\"one\", \"two\", \"three\")}, 1, 1, 3),\n+                Arguments.of(new Object[]{genList()}, 1, 1, 2),\n+                Arguments.of(new Object[]{genMap()}, 1, 1, 5),\n+                Arguments.of(new Object[]{genProxy()}, 5, 2, 9),\n+                Arguments.of(new Object[]{new char[]{'x', 'y', 'z'},\n@@ -84,3 +85,3 @@\n-                        new Object[]{\"first\", 3, 3.14159f}}, 9, 2, 1},\n-                { new Object[] {new XYPair(3, 5)}, 1, 1, 0},\n-        };\n+                        new Object[]{\"first\", 3, 3.14159f}}, 9, 2, 1),\n+                Arguments.of(new Object[] {new XYPair(3, 5)}, 1, 1, 0)\n+        );\n@@ -89,9 +90,8 @@\n-    @DataProvider(name = \"SingleObjects\")\n-    Object[][] sources() {\n-        return new Object[][]{\n-                {\"A Simple\", new A(), 1, 1, 0},\n-                {\"BNoDefaultRO has no call to defaultReadObject\", new BNoDefaultRO(), 2, 1, 1},\n-                {\"BDefaultRO has call to defaultReadObject\", new BDefaultRO(), 2, 1, 1},\n-                {\"CNoDefaultRO extends BNoDefaultRO with no fields\", new CNoDefaultRO(), 3, 1, 3},\n-                {\"CDefaultRO extends BDefaultRO with no fields\", new CDefaultRO(), 3, 1, 3},\n-        };\n+    static Stream<Arguments> sources(){\n+        return Stream.of(\n+                Arguments.of(\"A Simple\", new A(), 1, 1, 0),\n+                Arguments.of(\"BNoDefaultRO has no call to defaultReadObject\", new BNoDefaultRO(), 2, 1, 1),\n+                Arguments.of(\"BDefaultRO has call to defaultReadObject\", new BDefaultRO(), 2, 1, 1),\n+                Arguments.of(\"CNoDefaultRO extends BNoDefaultRO with no fields\", new CNoDefaultRO(), 3, 1, 3),\n+                Arguments.of(\"CDefaultRO extends BDefaultRO with no fields\", new CDefaultRO(), 3, 1, 3)\n+        );\n@@ -112,2 +112,3 @@\n-    @Test(dataProvider = \"serializables\")\n-    public void testFormat(Object[] objs, int descriptors, int objects, int strings) throws IOException {\n+    @ParameterizedTest\n+    @MethodSource(\"serializables\")\n+    void testFormat(Object[] objs, int descriptors, int objects, int strings) throws IOException {\n@@ -136,2 +137,3 @@\n-    @Test(dataProvider = \"serializables\", enabled=true)\n-    static void standAlonePrinter(Object[] objs, int descriptors, int objects, int strings) throws IOException{\n+    @ParameterizedTest\n+    @MethodSource(\"serializables\")\n+    void standAlonePrinter(Object[] objs, int descriptors, int objects, int strings) throws IOException{\n@@ -173,2 +175,3 @@\n-    @Test(dataProvider = \"SingleObjects\")\n-    static void singleObjects(String label, Object o, int descriptors, int objects, int strings) throws IOException {\n+    @ParameterizedTest\n+    @MethodSource(\"sources\")\n+    void singleObjects(String label, Object o, int descriptors, int objects, int strings) throws IOException {\n@@ -201,1 +204,1 @@\n-    static void longString() throws IOException {\n+    void longString() throws IOException {\n@@ -233,1 +236,1 @@\n-    static void testMain() throws IOException {\n+    void testMain() throws IOException {\n@@ -272,1 +275,1 @@\n-        assertEquals(count, expectedCount, \"Occurrences of \" + key);\n+        assertEquals(expectedCount, count, \"Occurrences of \" + key);\n@@ -275,1 +278,1 @@\n-    public static List<String> genList() {\n+    static List<String> genList() {\n@@ -282,1 +285,1 @@\n-    public static Map<String, String> genMap() {\n+    static Map<String, String> genMap() {\n@@ -290,1 +293,1 @@\n-    public static Object genProxy() {\n+    static Object genProxy() {\n","filename":"test\/lib-test\/jdk\/test\/lib\/hexdump\/ObjectStreamPrinterTest.java","additions":45,"deletions":42,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,4 @@\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.Arguments;\n@@ -53,0 +54,1 @@\n+import java.util.stream.Stream;\n@@ -54,1 +56,1 @@\n-import static org.testng.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -61,1 +63,1 @@\n- * @run testng jdk.test.lib.hexdump.StreamDumpTest\n+ * @run junit jdk.test.lib.hexdump.StreamDumpTest\n@@ -68,2 +70,1 @@\n-@Test\n-public class StreamDumpTest {\n+class StreamDumpTest {\n@@ -102,18 +103,17 @@\n-    @DataProvider(name = \"serializables\")\n-    Object[][] serializables() {\n-        return new Object[][] {\n-                {new String[]{testSRC + \"\/openssl.p12.pem\"},\n-                        0, 126, 0},\n-                {new String[]{\"--formatter\", \"jdk.test.lib.hexdump.ASN1Formatter\", testSRC + \"\/openssl.p12.pem\"},\n-                        0, 126, 0},\n-                {new String[]{serializedListPath},\n-                        0, 19, 0},\n-                {new String[]{\"--formatter\", \"jdk.test.lib.hexdump.ObjectStreamPrinter\", serializedListPath},\n-                        0, 19, 0},\n-                {new String[]{},\n-                        1, 2, 0},    \/\/ no file arguments\n-                {new String[]{\"--formatter\"},\n-                        1, 2, 0},       \/\/ --formatter option requires a class name\n-                {new String[]{\"-formatter\", \"jdk.test.lib.hexdump.ObjectStreamPrinter\"},\n-                        1, 2, 0},       \/\/ options start with double \"--\"\n-        };\n+    static Stream<Arguments> serializables() {\n+        return Stream.of(\n+                Arguments.of(new String[]{testSRC + \"\/openssl.p12.pem\"},\n+                        0, 126, 0),\n+                Arguments.of(new String[]{\"--formatter\", \"jdk.test.lib.hexdump.ASN1Formatter\", testSRC + \"\/openssl.p12.pem\"},\n+                        0, 126, 0),\n+                Arguments.of(new String[]{serializedListPath},\n+                        0, 19, 0),\n+                Arguments.of(new String[]{\"--formatter\", \"jdk.test.lib.hexdump.ObjectStreamPrinter\", serializedListPath},\n+                        0, 19, 0),\n+                Arguments.of(new String[]{},\n+                        1, 2, 0),    \/\/ no file arguments\n+                Arguments.of(new String[]{\"--formatter\"},\n+                        1, 2, 0),       \/\/ --formatter option requires a class name\n+                Arguments.of(new String[]{\"-formatter\", \"jdk.test.lib.hexdump.ObjectStreamPrinter\"},\n+                        1, 2, 0)       \/\/ options start with double \"--\"\n+        );\n@@ -129,2 +129,3 @@\n-    @Test(dataProvider=\"serializables\")\n-    static void testStreamDump(String[] args, int expectedStatus, int expectedStdout, int expectedStderr) throws IOException {\n+    @ParameterizedTest\n+    @MethodSource(\"serializables\")\n+    void testStreamDump(String[] args, int expectedStatus, int expectedStdout, int expectedStderr) throws IOException {\n@@ -151,1 +152,1 @@\n-            assertEquals(actualStatus, expectedStatus, \"Unexpected exit status\");\n+            assertEquals(expectedStatus, actualStatus, \"Unexpected exit status\");\n@@ -171,1 +172,1 @@\n-        assertEquals(actualLines, expectedLines, \"Unexpected line count\");\n+        assertEquals(expectedLines, actualLines, \"Unexpected line count\");\n@@ -193,1 +194,1 @@\n-    public static List<String> genList() {\n+    static List<String> genList() {\n@@ -200,1 +201,1 @@\n-    public static Map<String, String> genMap() {\n+    static Map<String, String> genMap() {\n","filename":"test\/lib-test\/jdk\/test\/lib\/hexdump\/StreamDumpTest.java","additions":33,"deletions":32,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -555,0 +555,40 @@\n+    \/**\n+     * A functional interface for executing tests in assertThrownException\n+     *\/\n+    @FunctionalInterface\n+    public interface TestMethod {\n+        void execute() throws Throwable;\n+    }\n+\n+\n+    public static <T extends Throwable> T assertThrows(Class<T> expected, TestMethod testMethod) {\n+        return assertThrows(expected, testMethod, \"An unexpected exception was thrown.\");\n+    }\n+\n+    \/**\n+     * Asserts that the given exception (or a subclass of it) is thrown when\n+     * executing the test method.\n+     *\n+     * If the test method throws the correct exception, the exception is returned\n+     * to the caller for additional validation e.g., comparing the exception\n+     * message.\n+     *\n+     * @param expected The expected exception\n+     * @param testMethod The code to execute that should throw the exception\n+     * @param msg A description of the assumption\n+     * @return The thrown exception.\n+     *\/\n+    public static <T extends Throwable> T assertThrows(Class<T> expected, TestMethod testMethod, String msg) {\n+        try {\n+            testMethod.execute();\n+        } catch (Throwable exc) {\n+            if (expected.isInstance(exc)) {\n+                return (T) exc;\n+            } else {\n+                fail(Objects.toString(msg, \"An unexpected exception was thrown.\")\n+                        + \" Expected \" + expected.getName(), exc);\n+            }\n+        }\n+        throw new RuntimeException(\"No exception was thrown. Expected: \" + expected.getName());\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/Asserts.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,3 @@\n+        \/\/ always print hserr to stderr in the docker tests to avoid\n+        \/\/ trouble accessing it after a crash in the container\n+        this.addJavaOpts(\"-XX:+ErrorFileToStderr\");\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerRunOptions.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -701,1 +701,1 @@\n-    public static OutputAnalyzer executeProcess(String... cmds) throws Throwable {\n+    public static OutputAnalyzer executeProcess(String... cmds) throws Exception {\n@@ -746,2 +746,1 @@\n-    public static OutputAnalyzer executeCommand(String... cmds)\n-            throws Throwable {\n+    public static OutputAnalyzer executeCommand(String... cmds) throws Exception {\n@@ -764,2 +763,1 @@\n-    public static OutputAnalyzer executeCommand(ProcessBuilder pb)\n-            throws Throwable {\n+    public static OutputAnalyzer executeCommand(ProcessBuilder pb) throws Exception {\n","filename":"test\/lib\/jdk\/test\/lib\/process\/ProcessTools.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.security;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.security.SecureRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class SecureRandomBench {\n+\n+    @Benchmark\n+    public SecureRandom create() throws Exception {\n+        return new SecureRandom();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/SecureRandomBench.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"}]}