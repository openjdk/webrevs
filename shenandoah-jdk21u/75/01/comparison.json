{"files":[{"patch":"@@ -38,1 +38,1 @@\n-        default: 'linux-x64, linux-x86, linux-x64-variants, linux-cross-compile, macos-x64, macos-aarch64, windows-x64, windows-aarch64, docs'\n+        default: 'linux-x64, linux-x86-hs, linux-x64-variants, linux-cross-compile, macos-x64, macos-aarch64, windows-x64, windows-aarch64, docs'\n@@ -61,1 +61,1 @@\n-      linux-x86: ${{ steps.include.outputs.linux-x86 }}\n+      linux-x86-hs: ${{ steps.include.outputs.linux-x86-hs }}\n@@ -113,1 +113,1 @@\n-          echo \"linux-x86=$(check_platform linux-x86 linux x86)\" >> $GITHUB_OUTPUT\n+          echo \"linux-x86-hs=$(check_platform linux-x86-hs linux x86)\" >> $GITHUB_OUTPUT\n@@ -137,2 +137,2 @@\n-  build-linux-x86:\n-    name: linux-x86\n+  build-linux-x86-hs:\n+    name: linux-x86-hs\n@@ -143,0 +143,1 @@\n+      make-target: 'hotspot'\n@@ -152,1 +153,1 @@\n-    if: needs.select.outputs.linux-x86 == 'true'\n+    if: needs.select.outputs.linux-x86-hs == 'true'\n@@ -302,10 +303,0 @@\n-  test-linux-x86:\n-    name: linux-x86\n-    needs:\n-      - build-linux-x86\n-    uses: .\/.github\/workflows\/test.yml\n-    with:\n-      platform: linux-x86\n-      bootjdk-platform: linux-x64\n-      runs-on: ubuntu-22.04\n-\n@@ -349,1 +340,1 @@\n-      - build-linux-x86\n+      - build-linux-x86-hs\n@@ -360,1 +351,0 @@\n-      - test-linux-x86\n","filename":".github\/workflows\/main.yml","additions":8,"deletions":18,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+  constexpr SmallRegisterMap() = default;\n+  ~SmallRegisterMap() = default;\n+  NONCOPYABLE(SmallRegisterMap);\n+\n@@ -34,1 +38,4 @@\n-  static constexpr SmallRegisterMap* instance = nullptr;\n+  static const SmallRegisterMap* instance() {\n+    static constexpr SmallRegisterMap the_instance{};\n+    return &the_instance;\n+  }\n@@ -51,11 +58,0 @@\n-  SmallRegisterMap() {}\n-\n-  SmallRegisterMap(const RegisterMap* map) {\n-  #ifdef ASSERT\n-    for(int i = 0; i < RegisterMap::reg_count; i++) {\n-      VMReg r = VMRegImpl::as_VMReg(i);\n-      if (map->location(r, (intptr_t*)nullptr) != nullptr) assert_is_rfp(r);\n-    }\n-  #endif\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/smallRegisterMap_aarch64.inline.hpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+  constexpr SmallRegisterMap() = default;\n+  ~SmallRegisterMap() = default;\n+  NONCOPYABLE(SmallRegisterMap);\n+\n@@ -34,1 +38,4 @@\n-  static constexpr SmallRegisterMap* instance = nullptr;\n+  static const SmallRegisterMap* instance() {\n+    static constexpr SmallRegisterMap the_instance{};\n+    return &the_instance;\n+  }\n@@ -49,6 +56,0 @@\n-  SmallRegisterMap() {}\n-\n-  SmallRegisterMap(const RegisterMap* map) {\n-    Unimplemented();\n-  }\n-\n","filename":"src\/hotspot\/cpu\/arm\/smallRegisterMap_arm.inline.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+  constexpr SmallRegisterMap() = default;\n+  ~SmallRegisterMap() = default;\n+  NONCOPYABLE(SmallRegisterMap);\n+\n@@ -34,2 +38,5 @@\n-  static constexpr SmallRegisterMap* instance = nullptr;\n-public:\n+  static const SmallRegisterMap* instance() {\n+    static constexpr SmallRegisterMap the_instance{};\n+    return &the_instance;\n+  }\n+\n@@ -47,13 +54,0 @@\n-  SmallRegisterMap() {}\n-\n-  SmallRegisterMap(const RegisterMap* map) {\n-#ifdef ASSERT\n-  for(int i = 0; i < RegisterMap::reg_count; i++) {\n-    VMReg r = VMRegImpl::as_VMReg(i);\n-    if (map->location(r, (intptr_t*)nullptr) != nullptr) {\n-      assert(false, \"Reg: %s\", r->name()); \/\/ Should not reach here\n-    }\n-  }\n-#endif\n-  }\n-\n","filename":"src\/hotspot\/cpu\/ppc\/smallRegisterMap_ppc.inline.hpp","additions":9,"deletions":15,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+  constexpr SmallRegisterMap() = default;\n+  ~SmallRegisterMap() = default;\n+  NONCOPYABLE(SmallRegisterMap);\n+\n@@ -34,1 +38,4 @@\n-  static constexpr SmallRegisterMap* instance = nullptr;\n+  static const SmallRegisterMap* instance() {\n+    static constexpr SmallRegisterMap the_instance{};\n+    return &the_instance;\n+  }\n@@ -51,11 +58,0 @@\n-  SmallRegisterMap() {}\n-\n-  SmallRegisterMap(const RegisterMap* map) {\n-  #ifdef ASSERT\n-    for(int i = 0; i < RegisterMap::reg_count; i++) {\n-      VMReg r = VMRegImpl::as_VMReg(i);\n-      if (map->location(r, (intptr_t*)nullptr) != nullptr) assert_is_fp(r);\n-    }\n-  #endif\n-  }\n-\n","filename":"src\/hotspot\/cpu\/riscv\/smallRegisterMap_riscv.inline.hpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+  constexpr SmallRegisterMap() = default;\n+  ~SmallRegisterMap() = default;\n+  NONCOPYABLE(SmallRegisterMap);\n+\n@@ -34,1 +38,4 @@\n-  static constexpr SmallRegisterMap* instance = nullptr;\n+  static const SmallRegisterMap* instance() {\n+    static constexpr SmallRegisterMap the_instance{};\n+    return &the_instance;\n+  }\n@@ -49,6 +56,0 @@\n-  SmallRegisterMap() {}\n-\n-  SmallRegisterMap(const RegisterMap* map) {\n-    Unimplemented();\n-  }\n-\n","filename":"src\/hotspot\/cpu\/s390\/smallRegisterMap_s390.inline.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+  constexpr SmallRegisterMap() = default;\n+  ~SmallRegisterMap() = default;\n+  NONCOPYABLE(SmallRegisterMap);\n+\n@@ -34,1 +38,5 @@\n-  static constexpr SmallRegisterMap* instance = nullptr;\n+  static const SmallRegisterMap* instance() {\n+    static constexpr SmallRegisterMap the_instance{};\n+    return &the_instance;\n+  }\n+\n@@ -51,11 +59,0 @@\n-  SmallRegisterMap() {}\n-\n-  SmallRegisterMap(const RegisterMap* map) {\n-  #ifdef ASSERT\n-    for(int i = 0; i < RegisterMap::reg_count; i++) {\n-      VMReg r = VMRegImpl::as_VMReg(i);\n-      if (map->location(r, (intptr_t*)nullptr) != nullptr) assert_is_rbp(r);\n-    }\n-  #endif\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/smallRegisterMap_x86.inline.hpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+  constexpr SmallRegisterMap() = default;\n+  ~SmallRegisterMap() = default;\n+  NONCOPYABLE(SmallRegisterMap);\n+\n@@ -34,1 +38,4 @@\n-  static constexpr SmallRegisterMap* instance = nullptr;\n+  static const SmallRegisterMap* instance() {\n+    static constexpr SmallRegisterMap the_instance{};\n+    return &the_instance;\n+  }\n@@ -49,6 +56,0 @@\n-  SmallRegisterMap() {}\n-\n-  SmallRegisterMap(const RegisterMap* map) {\n-    Unimplemented();\n-  }\n-\n","filename":"src\/hotspot\/cpu\/zero\/smallRegisterMap_zero.inline.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -134,1 +134,4 @@\n-          strcat(buf, \" \");\n+          \/\/ Feature string is expected to be in multi-character form\n+          \/\/ like rvc, rvv, etc so that it will be easier to specify\n+          \/\/ target feature string in tests.\n+          strcat(buf, \" rv\");\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-  if (avg_cycle_time > allocation_headroom \/ avg_alloc_rate) {\n+  if (avg_cycle_time * avg_alloc_rate > allocation_headroom) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -370,2 +370,4 @@\n-      \/\/ Try deduplicate\n-      try_deduplicate(context, obj);\n+      if (!finalizable) {\n+        \/\/ Try deduplicate\n+        try_deduplicate(context, obj);\n+      }\n","filename":"src\/hotspot\/share\/gc\/x\/xMark.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -460,2 +460,4 @@\n-      \/\/ Try deduplicate\n-      try_deduplicate(context, obj);\n+      if (!finalizable) {\n+        \/\/ Try deduplicate\n+        try_deduplicate(context, obj);\n+      }\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,3 +67,0 @@\n-#ifdef ASSERT\n-    _resource_allocate_bit_mask = false;\n-#endif\n@@ -178,3 +175,7 @@\n-#ifdef ASSERT\n-  _resource_allocate_bit_mask = true;\n-#endif\n+}\n+\n+InterpreterOopMap::~InterpreterOopMap() {\n+  if (has_valid_mask() && mask_size() > small_mask_limit) {\n+    assert(_bit_mask[0] != 0, \"should have pointer to C heap\");\n+    FREE_C_HEAP_ARRAY(uintptr_t, _bit_mask[0]);\n+  }\n@@ -400,3 +401,5 @@\n-void InterpreterOopMap::resource_copy(OopMapCacheEntry* from) {\n-  assert(_resource_allocate_bit_mask,\n-    \"Should not resource allocate the _bit_mask\");\n+void InterpreterOopMap::copy_from(const OopMapCacheEntry* src) {\n+  \/\/ The expectation is that this InterpreterOopMap is recently created\n+  \/\/ and empty. It is used to get a copy of a cached entry.\n+  assert(!has_valid_mask(), \"InterpreterOopMap object can only be filled once\");\n+  assert(src->has_valid_mask(), \"Cannot copy entry with an invalid mask\");\n@@ -404,5 +407,5 @@\n-  set_method(from->method());\n-  set_bci(from->bci());\n-  set_mask_size(from->mask_size());\n-  set_expression_stack_size(from->expression_stack_size());\n-  _num_oops = from->num_oops();\n+  set_method(src->method());\n+  set_bci(src->bci());\n+  set_mask_size(src->mask_size());\n+  set_expression_stack_size(src->expression_stack_size());\n+  _num_oops = src->num_oops();\n@@ -411,3 +414,2 @@\n-  if (from->mask_size() <= small_mask_limit) {\n-    memcpy((void *)_bit_mask, (void *)from->_bit_mask,\n-      mask_word_size() * BytesPerWord);\n+  if (src->mask_size() <= small_mask_limit) {\n+    memcpy(_bit_mask, src->_bit_mask, mask_word_size() * BytesPerWord);\n@@ -415,14 +417,2 @@\n-    \/\/ The expectation is that this InterpreterOopMap is a recently created\n-    \/\/ and empty. It is used to get a copy of a cached entry.\n-    \/\/ If the bit mask has a value, it should be in the\n-    \/\/ resource area.\n-    assert(_bit_mask[0] == 0 ||\n-      Thread::current()->resource_area()->contains((void*)_bit_mask[0]),\n-      \"The bit mask should have been allocated from a resource area\");\n-    \/\/ Allocate the bit_mask from a Resource area for performance.  Allocating\n-    \/\/ from the C heap as is done for OopMapCache has a significant\n-    \/\/ performance impact.\n-    _bit_mask[0] = (uintptr_t) NEW_RESOURCE_ARRAY(uintptr_t, mask_word_size());\n-    assert(_bit_mask[0] != 0, \"bit mask was not allocated\");\n-    memcpy((void*) _bit_mask[0], (void*) from->_bit_mask[0],\n-      mask_word_size() * BytesPerWord);\n+    _bit_mask[0] = (uintptr_t) NEW_C_HEAP_ARRAY(uintptr_t, mask_word_size(), mtClass);\n+    memcpy((void*) _bit_mask[0], (void*) src->_bit_mask[0], mask_word_size() * BytesPerWord);\n@@ -444,2 +434,1 @@\n-  _array  = NEW_C_HEAP_ARRAY(OopMapCacheEntry*, _size, mtClass);\n-  for(int i = 0; i < _size; i++) _array[i] = nullptr;\n+  for(int i = 0; i < size; i++) _array[i] = nullptr;\n@@ -450,1 +439,0 @@\n-  assert(_array != nullptr, \"sanity check\");\n@@ -453,2 +441,0 @@\n-  \/\/ Deallocate array\n-  FREE_C_HEAP_ARRAY(OopMapCacheEntry*, _array);\n@@ -458,1 +444,1 @@\n-  return Atomic::load_acquire(&(_array[i % _size]));\n+  return Atomic::load_acquire(&(_array[i % size]));\n@@ -462,1 +448,1 @@\n-  return Atomic::cmpxchg(&_array[i % _size], old, entry) == old;\n+  return Atomic::cmpxchg(&_array[i % size], old, entry) == old;\n@@ -466,1 +452,1 @@\n-  for (int i = 0; i < _size; i++) {\n+  for (int i = 0; i < size; i++) {\n@@ -477,1 +463,1 @@\n-  for (int i = 0; i < _size; i++) {\n+  for (int i = 0; i < size; i++) {\n@@ -512,1 +498,1 @@\n-    for (int i = 0; i < _probe_depth; i++) {\n+    for (int i = 0; i < probe_depth; i++) {\n@@ -515,1 +501,1 @@\n-        entry_for->resource_copy(entry);\n+        entry_for->copy_from(entry);\n@@ -529,1 +515,1 @@\n-  entry_for->resource_copy(tmp);\n+  entry_for->copy_from(tmp);\n@@ -541,1 +527,1 @@\n-  for (int i = 0; i < _probe_depth; i++) {\n+  for (int i = 0; i < probe_depth; i++) {\n@@ -629,1 +615,3 @@\n-  entry->resource_copy(tmp);\n+  if (tmp->has_valid_mask()) {\n+    entry->copy_from(tmp);\n+  }\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":34,"deletions":46,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-\/\/ bit_mask can fit into two words it is stored in\n+\/\/ bit_mask can fit into four words it is stored in\n@@ -42,3 +42,4 @@\n-\/\/ For InterpreterOopMap the bit_mask is allocated in\n-\/\/ a resource area for better performance.  InterpreterOopMap\n-\/\/ should only be created and deleted during same garbage collection.\n+\/\/ For InterpreterOopMap the bit_mask is allocated in the C heap\n+\/\/ to avoid issues with allocations from the resource area that have\n+\/\/ to live accross the oop closure. InterpreterOopMap should only be\n+\/\/ created and deleted during the same garbage collection.\n@@ -85,1 +86,1 @@\n-  int            _mask_size;      \/\/ the mask size in bits\n+  int            _mask_size;      \/\/ the mask size in bits (USHRT_MAX if invalid)\n@@ -129,0 +130,1 @@\n+  ~InterpreterOopMap();\n@@ -130,5 +132,5 @@\n-  \/\/ Copy the OopMapCacheEntry in parameter \"from\" into this\n-  \/\/ InterpreterOopMap.  If the _bit_mask[0] in \"from\" points to\n-  \/\/ allocated space (i.e., the bit mask was to large to hold\n-  \/\/ in-line), allocate the space from a Resource area.\n-  void resource_copy(OopMapCacheEntry* from);\n+  \/\/ Copy the OopMapCacheEntry in parameter \"src\" into this\n+  \/\/ InterpreterOopMap.  If the _bit_mask[0] in \"src\" points to\n+  \/\/ allocated space (i.e., the bit mask was too large to hold\n+  \/\/ in-line), allocate the space from the C heap.\n+  void copy_from(const OopMapCacheEntry* src);\n@@ -146,0 +148,2 @@\n+  \/\/ Determines if a valid mask has been computed\n+  bool has_valid_mask() const { return _mask_size != USHRT_MAX; }\n@@ -151,3 +155,2 @@\n-  enum { _size        = 32,     \/\/ Use fixed size for now\n-         _probe_depth = 3       \/\/ probe depth in case of collisions\n-  };\n+  static constexpr int size = 32;        \/\/ Use fixed size for now\n+  static constexpr int probe_depth = 3;  \/\/ probe depth in case of collisions\n@@ -155,1 +158,1 @@\n-  OopMapCacheEntry* volatile * _array;\n+  OopMapCacheEntry* volatile _array[size];\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.hpp","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-       f.next(SmallRegisterMap::instance)) {\n+       f.next(SmallRegisterMap::instance())) {\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-  const SmallRegisterMap* map = SmallRegisterMap::instance;\n+  const SmallRegisterMap* map = SmallRegisterMap::instance();\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1518,2 +1518,6 @@\n-    memset(ret.waiters, 0, ret.waiter_count * sizeof(jthread *));\n-    memset(ret.notify_waiters, 0, ret.notify_waiter_count * sizeof(jthread *));\n+    if (ret.waiters != nullptr) {\n+      memset(ret.waiters, 0, ret.waiter_count * sizeof(jthread *));\n+    }\n+    if (ret.notify_waiters != nullptr) {\n+      memset(ret.notify_waiters, 0, ret.notify_waiter_count * sizeof(jthread *));\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1863,1 +1863,1 @@\n-  f.next(SmallRegisterMap::instance, true \/* stop *\/);\n+  f.next(SmallRegisterMap::instance(), true \/* stop *\/);\n@@ -2073,1 +2073,1 @@\n-  _stream.next(SmallRegisterMap::instance);\n+  _stream.next(SmallRegisterMap::instance());\n@@ -2181,1 +2181,1 @@\n-    _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance);\n+    _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance());\n@@ -2224,1 +2224,1 @@\n-    _cont.tail()->fix_thawed_frame(caller, SmallRegisterMap::instance);\n+    _cont.tail()->fix_thawed_frame(caller, SmallRegisterMap::instance());\n@@ -2241,1 +2241,1 @@\n-    _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance);\n+    _cont.tail()->do_barriers<stackChunkOopDesc::BarrierType::Store>(_stream, SmallRegisterMap::instance());\n@@ -2300,1 +2300,1 @@\n-    _cont.tail()->fix_thawed_frame(caller, SmallRegisterMap::instance);\n+    _cont.tail()->fix_thawed_frame(caller, SmallRegisterMap::instance());\n@@ -2382,1 +2382,1 @@\n-  chunk->fix_thawed_frame(f, SmallRegisterMap::instance); \/\/ can only fix caller after push_return_frame (due to callee saved regs)\n+  chunk->fix_thawed_frame(f, SmallRegisterMap::instance()); \/\/ can only fix caller after push_return_frame (due to callee saved regs)\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -955,1 +955,0 @@\n-  ResourceMark rm(thread);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -207,1 +207,0 @@\n-        Objects.requireNonNull(key, \"key must not be null\");\n@@ -209,0 +208,7 @@\n+        return getNoCheckStale(key);\n+    }\n+\n+    \/\/ Internal get(key) without removing stale references that would modify the keyset.\n+    \/\/ Use when iterating or streaming over the keys to avoid ConcurrentModificationException.\n+    private V getNoCheckStale(Object key) {\n+        Objects.requireNonNull(key, \"key must not be null\");\n@@ -279,1 +285,1 @@\n-                .map(k -> new AbstractMap.SimpleEntry<>(k, get(k)))\n+                .map(k -> new AbstractMap.SimpleEntry<>(k, getNoCheckStale(k)))\n@@ -323,1 +329,1 @@\n-                .map(k -> k + \"=\" + get(k))\n+                .map(k -> k + \"=\" + getNoCheckStale(k))\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeyMap.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,1 @@\n-      if (getMethod().getName().asString().equals(\"wait\") &&\n+      if (getMethod().getName().asString().equals(\"wait0\") &&\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/JavaVFrame.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,0 +72,3 @@\n+  \/\/ Caveat: BufferUpdater is not MT-safe. We use it only for testing.\n+  \/\/ We would observe missing loglines if we interleaved buffers.\n+  \/\/ Emit all logs between constructor and destructor of BufferUpdater.\n@@ -73,3 +76,1 @@\n-    auto writer = AsyncLogWriter::instance();\n-    if (writer != nullptr) {\n-      const size_t sz = 2000;\n+    const size_t sz = 2000;\n@@ -77,3 +78,4 @@\n-      \/\/ shrink async buffer.\n-      AsyncLogWriter::BufferUpdater saver(1024);\n-      LogMessage(logging) lm;\n+    \/\/ shrink async buffer.\n+    AsyncLogWriter::BufferUpdater saver(1024);\n+    test_asynclog_ls(); \/\/ roughly 200 bytes.\n+    LogMessage(logging) lm;\n@@ -81,5 +83,3 @@\n-      \/\/ write more messages than its capacity in burst\n-      for (size_t i = 0; i < sz; ++i) {\n-        lm.debug(\"a lot of log...\");\n-      }\n-      lm.flush();\n+    \/\/ write more messages than its capacity in burst\n+    for (size_t i = 0; i < sz; ++i) {\n+      lm.debug(\"a lot of log...\");\n@@ -87,0 +87,1 @@\n+    lm.flush();\n@@ -96,2 +97,1 @@\n-      \/\/ at least see \"header\"\n-      return fclose(f) == 0 && sz == written && sz >= 6;\n+      return fclose(f) == 0 && sz == written;\n@@ -247,0 +247,4 @@\n+  if (AsyncLogWriter::instance() == nullptr) {\n+    return;\n+  }\n+\n@@ -249,5 +253,1 @@\n-\n-  AsyncLogWriter::flush();\n-  if (AsyncLogWriter::instance() != nullptr) {\n-    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n-  }\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n@@ -258,1 +258,0 @@\n-  fprintf(stdout, \"header\");\n@@ -261,2 +260,7 @@\n-  test_asynclog_ls();\n-  test_asynclog_drop_messages();\n+  bool async = AsyncLogWriter::instance() != nullptr;\n+  if (async) {\n+    test_asynclog_drop_messages();\n+    AsyncLogWriter::flush();\n+  } else {\n+    test_asynclog_ls();\n+  }\n@@ -264,1 +268,0 @@\n-  AsyncLogWriter::flush();\n@@ -266,1 +269,0 @@\n-\n@@ -268,1 +270,0 @@\n-    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"header\"));\n@@ -273,1 +274,1 @@\n-    if (AsyncLogWriter::instance() != nullptr) {\n+    if (async) {\n@@ -281,1 +282,0 @@\n-  fprintf(stderr, \"header\");\n@@ -284,2 +284,7 @@\n-  test_asynclog_ls();\n-  test_asynclog_drop_messages();\n+  bool async = AsyncLogWriter::instance() != nullptr;\n+  if (async) {\n+    test_asynclog_drop_messages();\n+    AsyncLogWriter::flush();\n+  } else {\n+    test_asynclog_ls();\n+  }\n@@ -287,1 +292,0 @@\n-  AsyncLogWriter::flush();\n@@ -289,1 +293,0 @@\n-\n@@ -291,1 +294,0 @@\n-    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"header\"));\n@@ -296,1 +298,1 @@\n-    if (AsyncLogWriter::instance() != nullptr) {\n+    if (async) {\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":34,"deletions":32,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -111,0 +111,21 @@\n+    \/**\n+     * Accepts a single pair composed of a platform string followed by a true\/false\n+     * value where a true value necessitates that we are currently testing on that platform and vice-versa.\n+     * IR checks are enforced only if the specified platform constraint is met.\n+     *\/\n+    String[] applyIfPlatform() default {};\n+\n+    \/**\n+     * Accepts a list of pairs where each pair is composed of a platform string followed by a true\/false\n+     * value where a true value necessitates that we are currently testing on that platform and vice-versa.\n+     * IR checks are enforced only if all the specified platform constraints are met.\n+     *\/\n+    String[] applyIfPlatformAnd() default {};\n+\n+    \/**\n+     * Accepts a list of pairs where each pair is composed of a platform string followed by a true\/false\n+     * value where a true value necessitates that we are currently testing on that platform and vice-versa.\n+     * IR checks are enforced if any of the specified platform constraints are met.\n+     *\/\n+    String[] applyIfPlatformOr() default {};\n+\n@@ -113,1 +134,1 @@\n-     * value where a true value necessities existence of CPU feature and vice-versa.\n+     * value where a true value necessitates existence of CPU feature and vice-versa.\n@@ -120,1 +141,1 @@\n-     * value where a true value necessities existence of target feature and vice-versa.\n+     * value where a true value necessitates existence of target feature and vice-versa.\n@@ -127,1 +148,1 @@\n-     * value where a true value necessities existence of target feature and vice-versa.\n+     * value where a true value necessitates existence of target feature and vice-versa.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IR.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -127,2 +127,8 @@\n-Sometimes, an `@IR` rule should only be applied if a certain CPU feature is present. This can be done with\n-the attributes `applyIfCPUFeatureXXX` in [@IR](.\/IR.java) which follow the same logic as the `applyIfXXX` methods for flags in the previous section. If a `@Test` annotated method has multiple preconditions (for example `applyIf` and `applyIfCPUFeature`), they are evaluated as a logical conjunction. An example with `applyIfCPUFeatureXXX` can be found in [TestCPUFeatureCheck](..\/..\/..\/testlibrary_tests\/ir_framework\/tests\/TestCPUFeatureCheck.java) (internal framework test).\n+Sometimes, an `@IR` rule should only be applied if a certain CPU feature is present. This can be done with the attributes `applyIfCPUFeatureXXX` in [@IR](.\/IR.java) which follow the same logic as the `applyIfXXX` methods for flags in the previous section. An example with `applyIfCPUFeatureXXX` can be found in [TestCPUFeatureCheck](..\/..\/..\/testlibrary_tests\/ir_framework\/tests\/TestCPUFeatureCheck.java) (internal framework test).\n+\n+If a `@Test` annotated method has multiple preconditions (for example `applyIf` and `applyIfCPUFeature`), they are evaluated as a logical conjunction. It's worth noting that flags in `applyIf` are checked only if the CPU features in `applyIfCPUFeature` are matched when they are both specified. This avoids the VM flag being evaluated on hardware that does not support it. An example with both `applyIfCPUFeatureXXX` and `applyIfXXX` can be found in [TestPreconditions](..\/..\/..\/testlibrary_tests\/ir_framework\/tests\/TestPreconditions.java) (internal framework test).\n+\n+#### Disable\/Enable IR Rules based on Platform\n+`@IR` rules based on the platform can be specified using `applyIfPlatformXXX` in [@IR](.\/IR.java). A reference for using these attributes can be found in [TestPlatformChecks](..\/..\/..\/testlibrary_tests\/ir_framework\/tests\/TestPlatformChecks.java) (internal framework test).\n+\n+Platform attributes are evaluated as a logical conjunction, and take precedence over VM Flag attributes. An example with both `applyIfPlatformXXX` and `applyIfXXX` can be found in [TestPreconditions](..\/..\/..\/testlibrary_tests\/ir_framework\/tests\/TestPreconditions.java) (internal framework test).\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/README.md","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.test.lib.Platform;\n@@ -58,0 +59,21 @@\n+    \/\/ Platforms for use in IR preconditions. Please verify that e.g. there is\n+    \/\/ a corresponding use in a jtreg @requires annotation before adding new platforms,\n+    \/\/ as adding non-existent platforms can lead to skipped tests.\n+    private static final List<String> irTestingPlatforms = new ArrayList<String>(Arrays.asList(\n+        \/\/ os.family\n+        \"linux\",\n+        \"mac\",\n+        \"windows\",\n+        \/\/ vm.simpleArch\n+        \"aarch64\",\n+        \"arm\",\n+        \"ppc\",\n+        \"riscv64\",\n+        \"s390\",\n+        \"x64\",\n+        \"x86\",\n+        \/\/ corresponds to vm.bits\n+        \"32-bit\",\n+        \"64-bit\"\n+    ));\n+\n@@ -81,1 +103,3 @@\n-        \"sve\"\n+        \"sve\",\n+        \/\/ Riscv64\n+        \"rvv\"\n@@ -135,5 +159,2 @@\n-        } else if (irAnno.applyIf().length != 0 && !hasAllRequiredFlags(irAnno.applyIf(), \"applyIf\")) {\n-            printDisableReason(m, \"Flag constraint not met (applyIf)\", irAnno.applyIf(), ruleIndex, ruleMax);\n-            return false;\n-        } else if (irAnno.applyIfNot().length != 0 && !hasNoRequiredFlags(irAnno.applyIfNot(), \"applyIfNot\")) {\n-            printDisableReason(m, \"Flag constraint not met (applyIfNot)\", irAnno.applyIfNot(), ruleIndex, ruleMax);\n+        } else if (irAnno.applyIfPlatform().length != 0 && !hasAllRequiredPlatform(irAnno.applyIfPlatform())) {\n+            printDisableReason(m, \"Constraint not met (applyIfPlatform)\", irAnno.applyIfPlatform(), ruleIndex, ruleMax);\n@@ -141,2 +162,2 @@\n-        } else if (irAnno.applyIfAnd().length != 0 && !hasAllRequiredFlags(irAnno.applyIfAnd(), \"applyIfAnd\")) {\n-            printDisableReason(m, \"Not all flag constraints are met (applyIfAnd)\", irAnno.applyIfAnd(), ruleIndex, ruleMax);\n+        } else if (irAnno.applyIfPlatformAnd().length != 0 && !hasAllRequiredPlatform(irAnno.applyIfPlatformAnd())) {\n+            printDisableReason(m, \"Not all constraints are met (applyIfPlatformAnd)\", irAnno.applyIfPlatformAnd(), ruleIndex, ruleMax);\n@@ -144,2 +165,2 @@\n-        } else if (irAnno.applyIfOr().length != 0 && hasNoRequiredFlags(irAnno.applyIfOr(), \"applyIfOr\")) {\n-            printDisableReason(m, \"None of the flag constraints met (applyIfOr)\", irAnno.applyIfOr(), ruleIndex, ruleMax);\n+        } else if (irAnno.applyIfPlatformOr().length != 0 && !hasAnyRequiredPlatform(irAnno.applyIfPlatformOr())) {\n+            printDisableReason(m, \"None of the constraints are met (applyIfPlatformOr)\", irAnno.applyIfPlatformOr(), ruleIndex, ruleMax);\n@@ -156,0 +177,12 @@\n+        } else if (irAnno.applyIf().length != 0 && !hasAllRequiredFlags(irAnno.applyIf(), \"applyIf\")) {\n+            printDisableReason(m, \"Flag constraint not met (applyIf)\", irAnno.applyIf(), ruleIndex, ruleMax);\n+            return false;\n+        } else if (irAnno.applyIfNot().length != 0 && !hasNoRequiredFlags(irAnno.applyIfNot(), \"applyIfNot\")) {\n+            printDisableReason(m, \"Flag constraint not met (applyIfNot)\", irAnno.applyIfNot(), ruleIndex, ruleMax);\n+            return false;\n+        } else if (irAnno.applyIfAnd().length != 0 && !hasAllRequiredFlags(irAnno.applyIfAnd(), \"applyIfAnd\")) {\n+            printDisableReason(m, \"Not all flag constraints are met (applyIfAnd)\", irAnno.applyIfAnd(), ruleIndex, ruleMax);\n+            return false;\n+        } else if (irAnno.applyIfOr().length != 0 && hasNoRequiredFlags(irAnno.applyIfOr(), \"applyIfOr\")) {\n+            printDisableReason(m, \"None of the flag constraints met (applyIfOr)\", irAnno.applyIfOr(), ruleIndex, ruleMax);\n+            return false;\n@@ -166,0 +199,1 @@\n+        int platformConstraints = 0;\n@@ -182,0 +216,15 @@\n+        if (irAnno.applyIfPlatform().length != 0) {\n+            platformConstraints++;\n+            TestFormat.checkNoThrow(irAnno.applyIfPlatform().length == 2,\n+                                    \"applyIfPlatform expects single platform pair\" + failAt());\n+        }\n+        if (irAnno.applyIfPlatformAnd().length != 0) {\n+            platformConstraints++;\n+            TestFormat.checkNoThrow(irAnno.applyIfPlatformAnd().length % 2 == 0,\n+                                    \"applyIfPlatformAnd expects more than one platform pair\" + failAt());\n+        }\n+        if (irAnno.applyIfPlatformOr().length != 0) {\n+            platformConstraints++;\n+            TestFormat.checkNoThrow(irAnno.applyIfPlatformOr().length % 2 == 0,\n+                                    \"applyIfPlatformOr expects more than one platform pair\" + failAt());\n+        }\n@@ -203,0 +252,1 @@\n+        TestFormat.checkNoThrow(platformConstraints <= 1, \"Can only specify one platform constraint\" + failAt());\n@@ -236,0 +286,76 @@\n+    private boolean hasAllRequiredPlatform(String[] andRules) {\n+        boolean returnValue = true;\n+        for (int i = 0; i < andRules.length; i++) {\n+            String platform = andRules[i].trim();\n+            i++;\n+            String value = andRules[i].trim();\n+            returnValue &= checkPlatform(platform, value);\n+        }\n+        return returnValue;\n+    }\n+\n+    private boolean hasAnyRequiredPlatform(String[] orRules) {\n+        boolean returnValue = false;\n+        for (int i = 0; i < orRules.length; i++) {\n+            String platform = orRules[i].trim();\n+            i++;\n+            String value = orRules[i].trim();\n+            returnValue |= checkPlatform(platform, value);\n+        }\n+        return returnValue;\n+    }\n+\n+    private boolean checkPlatform(String platform, String value) {\n+        if (platform.isEmpty()) {\n+            TestFormat.failNoThrow(\"Provided empty platform\" + failAt());\n+            return false;\n+        }\n+        if (value.isEmpty()) {\n+            TestFormat.failNoThrow(\"Provided empty value for platform \" + platform + failAt());\n+            return false;\n+        }\n+\n+        if (!irTestingPlatforms.contains(platform)) {\n+            TestFormat.failNoThrow(\"Provided platform is not in verified list: \" + platform + failAt());\n+            return false;\n+        }\n+\n+        boolean trueValue = value.contains(\"true\");\n+        boolean falseValue = value.contains(\"false\");\n+\n+        if (!trueValue && !falseValue) {\n+            TestFormat.failNoThrow(\"Provided incorrect value for platform \" + platform + failAt());\n+            return false;\n+        }\n+\n+        String os = \"\";\n+        if (Platform.isLinux()) {\n+            os = \"linux\";\n+        } else if (Platform.isOSX()) {\n+            os = \"mac\";\n+        } else if (Platform.isWindows()) {\n+            os = \"windows\";\n+        }\n+\n+        String arch = \"\";\n+        if (Platform.isAArch64()) {\n+            arch = \"aarch64\";\n+        } else if (Platform.isARM()) {\n+            arch = \"arm\";\n+        } else if (Platform.isPPC()) {\n+            arch = \"ppc\";\n+        } else if (Platform.isRISCV64()) {\n+            arch = \"riscv64\";\n+        } else if (Platform.isS390x()) {\n+            arch = \"s390\";\n+        } else if (Platform.isX64()) {\n+            arch = \"x64\";\n+        } else if (Platform.isX86()) {\n+            arch = \"x86\";\n+        }\n+\n+        String currentPlatform = os + \" \" + arch + \" \" + (Platform.is32bit() ? \"32-bit\" : \"64-bit\");\n+\n+        return (trueValue && currentPlatform.contains(platform)) || (falseValue && !currentPlatform.contains(platform));\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":136,"deletions":10,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @requires vm.bits == \"64\"\n@@ -96,1 +95,2 @@\n-    @IR(applyIfCPUFeature = {\"avx2\", \"true\"},\n+    @IR(applyIfPlatform = {\"32-bit\", \"false\"},\n+        applyIfCPUFeature = {\"avx2\", \"true\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRed_Long.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2022, 2023, Arm Limited. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorLogicalOpIdentityTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+    private static Object lockObj = new Object();\n@@ -39,0 +40,10 @@\n+    public static void waitMethod() {\n+        synchronized (lockObj) {\n+            try {\n+                lockObj.wait(300000);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n@@ -44,0 +55,1 @@\n+        Thread objectWait = new Thread(() -> waitMethod());\n@@ -49,0 +61,1 @@\n+        objectWait.start();\n@@ -56,1 +69,2 @@\n-               (primitiveLock.getState() != Thread.State.TIMED_WAITING)) {\n+               (primitiveLock.getState() != Thread.State.TIMED_WAITING) ||\n+               (objectWait.getState() != Thread.State.TIMED_WAITING)) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/LingeredAppWithLock.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+ * @bug 8185796 8335743\n@@ -60,1 +61,2 @@\n-                \"^\\\\s+- locked <0x[0-9a-f]+> \\\\(a java\\\\.lang\\\\.Class for int\\\\)$\"));\n+                \"^\\\\s+- locked <0x[0-9a-f]+> \\\\(a java\\\\.lang\\\\.Class for int\\\\)$\",\n+                \"^\\\\s+- waiting on (<0x[0-9a-f]+> \\\\(a java\\\\.lang\\\\.Object\\\\)|<no object reference available>)$\"));\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestClhsdbJstackLock.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+ * @bug 8185796 8335743\n@@ -67,0 +68,1 @@\n+            out.shouldMatch(\"^\\\\s+- waiting on (<0x[0-9a-f]+> \\\\(a java\\\\.lang\\\\.Object\\\\)|<no object reference available>)$\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackLock.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n+\n+\/*\n+ * @test 8280120\n+ * @summary Add attribute to IR to enable\/disable IR matching based on the architecture\n+ * @library \/test\/lib \/\n+ * @run driver ir_framework.tests.TestPlatformChecks\n+ *\/\n+\n+public class TestPlatformChecks {\n+    private static final int SIZE = 1000;\n+    private static int[] a = new int[SIZE];\n+    private static int[] b = new int[SIZE];\n+    private static int[] res = new int[SIZE];\n+\n+    public static void setup() {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = i;\n+            b[i] = i;\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        setup();\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\"},\n+        applyIfPlatform = {\"x64\", \"true\"},\n+        applyIfCPUFeature = {\"sse4.1\", \"true\"})\n+    public static void test1() {\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] + b[i];\n+        }\n+    }\n+\n+    \/\/ IR rule is enforced if all the platform constraints hold\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\"},\n+        applyIfPlatformAnd = {\"x64\", \"true\", \"linux\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"true\"})\n+    public static void test2() {\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] + b[i];\n+        }\n+    }\n+\n+    \/\/ IR rule is enforced if any of the platform constraints hold\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\"},\n+        applyIfPlatformOr = {\"linux\", \"true\", \"mac\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"avx2\", \"true\"})\n+    public static void test3() {\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] + b[i];\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestPlatformChecks.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -59,1 +59,68 @@\n-    public static void testApplyBoth() {}\n+    public static void testApplyBoth1() {}\n+\n+    \/\/ The IR check should not be applied on aarch64, because the \"applyIfAnd\"\n+    \/\/ condition returns false as the VM is run with LoopMaxUnroll=8.\n+    \/\/ Note that precondition `applyIfCPUFeature` will be evaluated first with\n+    \/\/ early return. Hence the IR check should not be applied on non-aarch64\n+    \/\/ systems, and no exception is thrown because we are not checking the value\n+    \/\/ of the unsupported \"UseSVE\" flag on non-aarch64 systems.\n+    @Test\n+    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n+        applyIfAnd = {\"UseSVE\", \"= 0\", \"LoopMaxUnroll\", \"= 0\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyBoth2() {}\n+\n+    \/\/ The IR check should not be applied on x86, because the \"applyIfAnd\"\n+    \/\/ condition returns false as the VM is run with LoopMaxUnroll=8.\n+    \/\/ Note that precondition `applyIfCPUFeature` will be evaluated first with\n+    \/\/ early return. Hence the IR check should not be applied on non-avx systems,\n+    \/\/ and no exception is thrown because we are not checking the value of the\n+    \/\/ unsupported \"UseAVX\" flag on non-avx systems.\n+    @Test\n+    @IR(applyIfCPUFeature = {\"avx\", \"true\"},\n+        applyIfAnd = {\"UseAVX\", \"= 2\", \"LoopMaxUnroll\", \"= 0\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyBoth3() {}\n+\n+    \/\/ The IR check should not be applied, since OS can not be both linux and mac.\n+    @Test\n+    @IR(applyIfPlatformAnd = {\"linux\", \"true\", \"mac\", \"true\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyBothOs() {}\n+\n+    \/\/ The IR check should not be applied, since we can't have both 32-bit and 64-bit data model.\n+    @Test\n+    @IR(applyIfPlatformAnd = {\"32-bit\", \"true\", \"64-bit\", \"true\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyBothDataModel() {}\n+\n+    \/\/ The IR check should not be applied, since the arch can't be both x64 and aarch64.\n+    @Test\n+    @IR(applyIfPlatformAnd = {\"x64\", \"true\", \"aarch64\", \"true\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyBothArch() {}\n+\n+    \/\/ Platform versions of testApplyBoth2\/3.\n+    @Test\n+    @IR(applyIfPlatform = {\"aarch64\", \"true\"},\n+        applyIfAnd = {\"UseSVE\", \"= 0\", \"LoopMaxUnroll\", \"= 0\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyPlatformSVE() {}\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"},\n+        applyIfAnd = {\"UseAVX\", \"= 2\", \"LoopMaxUnroll\", \"= 0\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyPlatformAVX() {}\n+\n+    @Test\n+    @IR(applyIfPlatformAnd = {\"x64\", \"true\", \"linux\", \"true\"},\n+        applyIfAnd = {\"UseAVX\", \"= 2\", \"LoopMaxUnroll\", \"= 0\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyPlatformAVXAnd() {}\n+\n+    @Test\n+    @IR(applyIfPlatformOr = {\"x64\", \"true\", \"x86\", \"true\"},\n+        applyIfAnd = {\"UseSSE\", \"= 4\", \"LoopMaxUnroll\", \"= 0\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyPlatformSSEOr() {}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestPreconditions.java","additions":68,"deletions":1,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @run main\/othervm ThreadCpuTimeArray\n","filename":"test\/jdk\/com\/sun\/management\/ThreadMXBean\/ThreadCpuTimeArray.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import java.nio.file.FileStore;\n@@ -50,0 +51,1 @@\n+import org.testng.SkipException;\n@@ -210,2 +212,7 @@\n-        if (!Files.getFileStore(Paths.get(\".\"))\n-                  .supportsFileAttributeView(PosixFileAttributeView.class)) {\n+        FileStore fs;\n+        try {\n+            fs = Files.getFileStore(Paths.get(\".\"));\n+        } catch (IOException e) {\n+            throw new SkipException(\"WARNING: IOException occurred: \" + e + \", Skipping testDumpDirNotWritable test.\");\n+        }\n+        if (!fs.supportsFileAttributeView(PosixFileAttributeView.class)) {\n@@ -213,6 +220,1 @@\n-            \/\/ We would like to skip the test with a cause with\n-            \/\/     throw new SkipException(\"Posix not supported\");\n-            \/\/ but jtreg will report failure so we just pass the test\n-            \/\/ which we can look at if jtreg changed its behavior\n-            System.out.println(\"WARNING: POSIX is not supported. Skipping testDumpDirNotWritable test.\");\n-            return;\n+            throw new SkipException(\"WARNING: POSIX is not supported. Skipping testDumpDirNotWritable test.\");\n@@ -230,2 +232,1 @@\n-                System.out.println(\"WARNING: The dump directory is writeable. Skipping testDumpDirNotWritable test.\");\n-                return;\n+                throw new SkipException(\"WARNING: The dump directory is writeable. Skipping testDumpDirNotWritable test.\");\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LogGeneratedClassesTest.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+\n@@ -45,2 +46,4 @@\n-            test(dc);\n-            test(dc);\n+            InetAddress lo = InetAddress.getLoopbackAddress();\n+            System.out.println(\"Testing with default family and \" + lo);\n+            test(dc, lo);\n+            test(dc, lo);\n@@ -52,2 +55,4 @@\n-                test(dc);\n-                test(dc);\n+                InetAddress lo4 = InetAddress.ofLiteral(\"127.0.0.1\");\n+                System.out.println(\"Testing with INET family and \" + lo4);\n+                test(dc, lo4);\n+                test(dc, lo4);\n@@ -60,2 +65,4 @@\n-                test(dc);\n-                test(dc);\n+                InetAddress lo6 = InetAddress.ofLiteral(\"::1\");\n+                System.out.println(\"Testing with INET6 family and \" + lo6);\n+                test(dc, lo6);\n+                test(dc, lo6);\n@@ -66,0 +73,4 @@\n+    static int getLocalPort(DatagramChannel ch) throws IOException {\n+        return ((InetSocketAddress) ch.getLocalAddress()).getPort();\n+    }\n+\n@@ -71,1 +82,1 @@\n-    static void test(DatagramChannel dc) throws IOException {\n+    static void test(DatagramChannel dc, InetAddress lo) throws IOException {\n@@ -73,1 +84,1 @@\n-            server.bind(new InetSocketAddress(0));\n+            server.bind(new InetSocketAddress(lo, 0));\n@@ -75,2 +86,4 @@\n-            InetAddress lh = InetAddress.getLocalHost();\n-            dc.connect(new InetSocketAddress(lh, server.socket().getLocalPort()));\n+            SocketAddress dcbound = dc.getLocalAddress();\n+            dc.connect(new InetSocketAddress(lo, server.socket().getLocalPort()));\n+            System.out.println(\"dc bound to \" + dcbound + \" and connected from \" +\n+                    dc.getLocalAddress() + \" to \" + dc.getRemoteAddress());\n@@ -80,2 +93,8 @@\n-            ByteBuffer bb = ByteBuffer.allocate(100);\n-            server.receive(bb);\n+            if (getLocalPort(dc) != getLocalPort(server)) {\n+                ByteBuffer bb = ByteBuffer.allocate(100);\n+                server.receive(bb);\n+            } else {\n+                \/\/ some systems may allow dc and server to bind to the same port.\n+                \/\/ when that happen the datagram may never be received\n+                System.out.println(\"Server and clients are bound to the same port: skipping receive\");\n+            }\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Disconnect.java","additions":32,"deletions":13,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-        Path tmp = null;\n+        Path currentDir = null;\n@@ -75,1 +75,1 @@\n-            tmp = Files.createTempFile(\"this\", \"that\");\n+            currentDir = Files.createTempFile(Path.of(\".\"), \"this\", \"that\");\n@@ -77,1 +77,1 @@\n-                Files.getFileStore(tmp).supportsFileAttributeView(\"posix\");\n+                Files.getFileStore(currentDir).supportsFileAttributeView(\"posix\");\n@@ -81,1 +81,1 @@\n-            if (tmp != null) {\n+            if (currentDir != null) {\n@@ -83,1 +83,1 @@\n-                    Files.delete(tmp);\n+                    Files.delete(currentDir);\n@@ -145,0 +145,1 @@\n+        Path currentDir = Path.of(\".\");\n@@ -148,1 +149,1 @@\n-                    source = Files.createTempFile(\"file\", \"dat\");\n+                    source = Files.createTempFile(currentDir, \"file\", \"dat\");\n@@ -150,1 +151,1 @@\n-                    source = Files.createTempDirectory(\"dir\");\n+                    source = Files.createTempDirectory(currentDir, \"dir\");\n@@ -152,1 +153,1 @@\n-                    linkTarget = Files.createTempFile(\"link\", \"target\");\n+                    linkTarget = Files.createTempFile(currentDir, \"link\", \"target\");\n@@ -166,1 +167,1 @@\n-                target = Files.createTempFile(\"file\", \"target\");\n+                target = Files.createTempFile(currentDir, \"file\", \"target\");\n","filename":"test\/jdk\/java\/nio\/file\/Files\/CopyMoveVariations.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -146,17 +147,27 @@\n-        CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT + 1);\n-\n-        try (Recording r = new Recording()) {\n-            r.start();\n-            List<Emitter> emitters = new ArrayList<>();\n-            for (int i = 0; i < THREAD_COUNT; i++) {\n-                Emitter e = new Emitter(barrier);\n-                e.start();\n-                emitters.add(e);\n-            }\n-            \/\/ Thread buffers should now have one event each\n-            barrier.await();\n-            \/\/ Add another event to each thread buffer, so\n-            \/\/ events are bound to come out of order when they\n-            \/\/ are flushed\n-            for (Emitter e : emitters) {\n-                e.join();\n+        while (true) {\n+            CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT + 1);\n+            try (Recording r = new Recording()) {\n+                r.start();\n+                List<Emitter> emitters = new ArrayList<>();\n+                for (int i = 0; i < THREAD_COUNT; i++) {\n+                    Emitter e = new Emitter(barrier);\n+                    e.start();\n+                    emitters.add(e);\n+                }\n+                \/\/ Thread buffers should now have one event each\n+                barrier.await();\n+                \/\/ Add another event to each thread buffer, so\n+                \/\/ events are bound to come out of order when they\n+                \/\/ are flushed\n+                for (Emitter e : emitters) {\n+                    e.join();\n+                }\n+                r.stop();\n+                Path p = Utils.createTempFile(\"recording\", \".jfr\");\n+                r.dump(p);\n+                \/\/ Order is only guaranteed within a segment.\n+                int segments = countSegments(p);\n+                if (segments < 2) {\n+                    return p;\n+                }\n+                System.out.println(\"File contains more than one segment (\" + segments + \"). Retrying.\");\n@@ -164,4 +175,9 @@\n-            r.stop();\n-            Path p = Utils.createTempFile(\"recording\", \".jfr\");\n-            r.dump(p);\n-            return p;\n+        }\n+    }\n+\n+    private static int countSegments(Path file) throws Exception {\n+        AtomicInteger segments = new AtomicInteger();\n+        try (EventStream es = EventStream.openFile(file)) {\n+            es.onFlush(segments::incrementAndGet);\n+            es.start();\n+            return segments.get();\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/filestream\/TestOrdered.java","additions":37,"deletions":21,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,9 +74,11 @@\n-\n-        try (Recording r = new Recording()) {\n-            r.enable(EventNames.OldObjectSample).withStackTrace().with(\"cutoff\", \"infinity\");\n-            r.start();\n-            listenerLeak();\n-            r.stop();\n-            List<RecordedEvent> events = Events.fromRecording(r);\n-            if (OldObjects.countMatchingEvents(events, Stuff[].class, null, null, -1, \"listenerLeak\") == 0) {\n-                throw new Exception(\"Could not find leak with \" + Stuff[].class);\n+        while (true) {\n+            try (Recording r = new Recording()) {\n+                r.enable(EventNames.OldObjectSample).withStackTrace().with(\"cutoff\", \"infinity\");\n+                r.start();\n+                listenerLeak();\n+                r.stop();\n+                List<RecordedEvent> events = Events.fromRecording(r);\n+                if (OldObjects.countMatchingEvents(events, Stuff[].class, null, null, -1, \"listenerLeak\") != 0) {\n+                    return; \/\/ Success\n+                }\n+                System.out.println(\"Could not find leak with \" + Stuff[].class + \". Retrying.\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestListenerLeak.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"}]}