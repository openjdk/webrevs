{"files":[{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+  replay_files=$(ls $report_dir\/$base_path\/replay*.log 2> \/dev\/null || true)\n@@ -48,1 +49,0 @@\n-\n@@ -76,0 +76,14 @@\n+  if [[ \"$replay_files\" != \"\" ]]; then\n+    echo '<details><summary>View HotSpot replay file<\/summary>'\n+    echo ''\n+    for replay in $replay_files; do\n+      echo '```'\n+      echo \"$replay:\"\n+      echo ''\n+      cat \"$replay\"\n+      echo '```'\n+    done\n+\n+    echo '<\/details>'\n+    echo ''\n+  fi\n","filename":".github\/scripts\/gen-test-results.sh","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+          - 'hs\/tier1 compiler not-xcomp'\n@@ -95,1 +96,1 @@\n-            test-suite: 'test\/hotspot\/jtreg\/:tier1_compiler_2 test\/hotspot\/jtreg\/:tier1_compiler_not_xcomp'\n+            test-suite: 'test\/hotspot\/jtreg\/:tier1_compiler_2'\n@@ -102,0 +103,4 @@\n+          - test-name: 'hs\/tier1 compiler not-xcomp'\n+            test-suite: 'test\/hotspot\/jtreg\/:tier1_compiler_not_xcomp'\n+            debug-suffix: -debug\n+\n","filename":".github\/workflows\/test.yml","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2355,0 +2355,5 @@\n+    } else if (_method->intrinsic_id() == vmIntrinsicID::_ensureMaterializedForStackWalk) {\n+      \/\/ The NOP here is purely to ensure that eliding a call to\n+      \/\/ JVM_EnsureMaterializedForStackWalk doesn't change the code size.\n+      __ nop();\n+      __ block_comment(\"call JVM_EnsureMaterializedForStackWalk (elided)\");\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,129 +34,0 @@\n-#ifdef M68K\n-\n-\/*\n- * __m68k_cmpxchg\n- *\n- * Atomically store newval in *ptr if *ptr is equal to oldval for user space.\n- * Returns newval on success and oldval if no exchange happened.\n- * This implementation is processor specific and works on\n- * 68020 68030 68040 and 68060.\n- *\n- * It will not work on ColdFire, 68000 and 68010 since they lack the CAS\n- * instruction.\n- * Using a kernelhelper would be better for arch complete implementation.\n- *\n- *\/\n-\n-static inline int __m68k_cmpxchg(int oldval, int newval, volatile int *ptr) {\n-  int ret;\n-  __asm __volatile (\"cas%.l %0,%2,%1\"\n-                   : \"=d\" (ret), \"+m\" (*(ptr))\n-                   : \"d\" (newval), \"0\" (oldval));\n-  return ret;\n-}\n-\n-\/* Perform an atomic compare and swap: if the current value of `*PTR'\n-   is OLDVAL, then write NEWVAL into `*PTR'.  Return the contents of\n-   `*PTR' before the operation.*\/\n-static inline int m68k_compare_and_swap(int newval,\n-                                        volatile int *ptr,\n-                                        int oldval) {\n-  for (;;) {\n-      int prev = *ptr;\n-      if (prev != oldval)\n-        return prev;\n-\n-      if (__m68k_cmpxchg (prev, newval, ptr) == newval)\n-        \/\/ Success.\n-        return prev;\n-\n-      \/\/ We failed even though prev == oldval.  Try again.\n-    }\n-}\n-\n-\/* Atomically add an int to memory.  *\/\n-static inline int m68k_add_then_fetch(int add_value, volatile int *ptr) {\n-  for (;;) {\n-      \/\/ Loop until success.\n-\n-      int prev = *ptr;\n-\n-      if (__m68k_cmpxchg (prev, prev + add_value, ptr) == prev + add_value)\n-        return prev + add_value;\n-    }\n-}\n-\n-\/* Atomically write VALUE into `*PTR' and returns the previous\n-   contents of `*PTR'.  *\/\n-static inline int m68k_lock_test_and_set(int newval, volatile int *ptr) {\n-  for (;;) {\n-      \/\/ Loop until success.\n-      int prev = *ptr;\n-\n-      if (__m68k_cmpxchg (prev, newval, ptr) == prev)\n-        return prev;\n-    }\n-}\n-#endif \/\/ M68K\n-\n-#ifdef ARM\n-\n-\/*\n- * __kernel_cmpxchg\n- *\n- * Atomically store newval in *ptr if *ptr is equal to oldval for user space.\n- * Return zero if *ptr was changed or non-zero if no exchange happened.\n- * The C flag is also set if *ptr was changed to allow for assembly\n- * optimization in the calling code.\n- *\n- *\/\n-\n-typedef int (__kernel_cmpxchg_t)(int oldval, int newval, volatile int *ptr);\n-#define __kernel_cmpxchg (*(__kernel_cmpxchg_t *) 0xffff0fc0)\n-\n-\n-\n-\/* Perform an atomic compare and swap: if the current value of `*PTR'\n-   is OLDVAL, then write NEWVAL into `*PTR'.  Return the contents of\n-   `*PTR' before the operation.*\/\n-static inline int arm_compare_and_swap(int newval,\n-                                       volatile int *ptr,\n-                                       int oldval) {\n-  for (;;) {\n-      int prev = *ptr;\n-      if (prev != oldval)\n-        return prev;\n-\n-      if (__kernel_cmpxchg (prev, newval, ptr) == 0)\n-        \/\/ Success.\n-        return prev;\n-\n-      \/\/ We failed even though prev == oldval.  Try again.\n-    }\n-}\n-\n-\/* Atomically add an int to memory.  *\/\n-static inline int arm_add_then_fetch(int add_value, volatile int *ptr) {\n-  for (;;) {\n-      \/\/ Loop until a __kernel_cmpxchg succeeds.\n-\n-      int prev = *ptr;\n-\n-      if (__kernel_cmpxchg (prev, prev + add_value, ptr) == 0)\n-        return prev + add_value;\n-    }\n-}\n-\n-\/* Atomically write VALUE into `*PTR' and returns the previous\n-   contents of `*PTR'.  *\/\n-static inline int arm_lock_test_and_set(int newval, volatile int *ptr) {\n-  for (;;) {\n-      \/\/ Loop until a __kernel_cmpxchg succeeds.\n-      int prev = *ptr;\n-\n-      if (__kernel_cmpxchg (prev, newval, ptr) == 0)\n-        return prev;\n-    }\n-}\n-#endif \/\/ ARM\n-\n@@ -181,6 +52,0 @@\n-#ifdef ARM\n-  return add_using_helper<int>(arm_add_then_fetch, dest, add_value);\n-#else\n-#ifdef M68K\n-  return add_using_helper<int>(m68k_add_then_fetch, dest, add_value);\n-#else\n@@ -190,2 +55,0 @@\n-#endif \/\/ M68K\n-#endif \/\/ ARM\n@@ -212,17 +75,3 @@\n-#ifdef ARM\n-  return xchg_using_helper<int>(arm_lock_test_and_set, dest, exchange_value);\n-#else\n-#ifdef M68K\n-  return xchg_using_helper<int>(m68k_lock_test_and_set, dest, exchange_value);\n-#else\n-  \/\/ __sync_lock_test_and_set is a bizarrely named atomic exchange\n-  \/\/ operation.  Note that some platforms only support this with the\n-  \/\/ limitation that the only valid value to store is the immediate\n-  \/\/ constant 1.  There is a test for this in JNI_CreateJavaVM().\n-  T result = __sync_lock_test_and_set (dest, exchange_value);\n-  \/\/ All atomic operations are expected to be full memory barriers\n-  \/\/ (see atomic.hpp). However, __sync_lock_test_and_set is not\n-  \/\/ a full memory barrier, but an acquire barrier. Hence, this added\n-  \/\/ barrier. Some platforms (notably ARM) have peculiarities with\n-  \/\/ their barrier implementations, delegate it to OrderAccess.\n-  OrderAccess::fence();\n+  FULL_MEM_BARRIER;\n+  T result = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELAXED);\n+  FULL_MEM_BARRIER;\n@@ -230,2 +79,0 @@\n-#endif \/\/ M68K\n-#endif \/\/ ARM\n@@ -240,2 +87,3 @@\n-  T result = __sync_lock_test_and_set (dest, exchange_value);\n-  OrderAccess::fence();\n+  FULL_MEM_BARRIER;\n+  T result = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELAXED);\n+  FULL_MEM_BARRIER;\n@@ -256,6 +104,0 @@\n-#ifdef ARM\n-  return cmpxchg_using_helper<int>(arm_compare_and_swap, dest, compare_value, exchange_value);\n-#else\n-#ifdef M68K\n-  return cmpxchg_using_helper<int>(m68k_compare_and_swap, dest, compare_value, exchange_value);\n-#else\n@@ -268,2 +110,0 @@\n-#endif \/\/ M68K\n-#endif \/\/ ARM\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/atomic_bsd_zero.hpp","additions":6,"deletions":166,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -334,16 +334,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ Implementations of atomic operations not supported by processors.\n-\/\/  -- http:\/\/gcc.gnu.org\/onlinedocs\/gcc-4.2.1\/gcc\/Atomic-Builtins.html\n-\n-#ifndef _LP64\n-extern \"C\" {\n-  long long unsigned int __sync_val_compare_and_swap_8(\n-    volatile void *ptr,\n-    long long unsigned int oldval,\n-    long long unsigned int newval) {\n-    ShouldNotCallThis();\n-    return 0; \/\/ silence compiler warnings\n-  }\n-};\n-#endif \/\/ !_LP64\n-\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/os_bsd_zero.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -74,11 +74,3 @@\n-  \/\/ __sync_lock_test_and_set is a bizarrely named atomic exchange\n-  \/\/ operation.  Note that some platforms only support this with the\n-  \/\/ limitation that the only valid value to store is the immediate\n-  \/\/ constant 1.  There is a test for this in JNI_CreateJavaVM().\n-  T result = __sync_lock_test_and_set (dest, exchange_value);\n-  \/\/ All atomic operations are expected to be full memory barriers\n-  \/\/ (see atomic.hpp). However, __sync_lock_test_and_set is not\n-  \/\/ a full memory barrier, but an acquire barrier. Hence, this added\n-  \/\/ barrier. Some platforms (notably ARM) have peculiarities with\n-  \/\/ their barrier implementations, delegate it to OrderAccess.\n-  OrderAccess::fence();\n+  FULL_MEM_BARRIER;\n+  T result = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELAXED);\n+  FULL_MEM_BARRIER;\n@@ -94,2 +86,3 @@\n-  T result = __sync_lock_test_and_set (dest, exchange_value);\n-  OrderAccess::fence();\n+  FULL_MEM_BARRIER;\n+  T result = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELAXED);\n+  FULL_MEM_BARRIER;\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/atomic_linux_zero.hpp","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -495,16 +495,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ Implementations of atomic operations not supported by processors.\n-\/\/  -- http:\/\/gcc.gnu.org\/onlinedocs\/gcc-4.2.1\/gcc\/Atomic-Builtins.html\n-\n-#ifndef _LP64\n-extern \"C\" {\n-  long long unsigned int __sync_val_compare_and_swap_8(\n-    volatile void *ptr,\n-    long long unsigned int oldval,\n-    long long unsigned int newval) {\n-    ShouldNotCallThis();\n-    return 0; \/\/ silence compiler warnings\n-  }\n-};\n-#endif \/\/ !_LP64\n-\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -144,1 +145,8 @@\n-void WorkerThreads::set_indirectly_suspendible_threads() {\n+template <typename Function>\n+void WorkerThreads::threads_do_f(Function function) const {\n+  for (uint i = 0; i < _created_workers; i++) {\n+    function(_workers[i]);\n+  }\n+}\n+\n+void WorkerThreads::set_indirect_states() {\n@@ -146,2 +154,7 @@\n-  class SetIndirectlySuspendibleThreadClosure : public ThreadClosure {\n-    virtual void do_thread(Thread* thread) {\n+  const bool is_suspendible = Thread::current()->is_suspendible_thread();\n+  const bool is_safepointed = Thread::current()->is_VM_thread() && SafepointSynchronize::is_at_safepoint();\n+\n+  threads_do_f([&](Thread* thread) {\n+    assert(!thread->is_indirectly_suspendible_thread(), \"Unexpected\");\n+    assert(!thread->is_indirectly_safepoint_thread(), \"Unexpected\");\n+    if (is_suspendible) {\n@@ -150,6 +163,4 @@\n-  };\n-\n-  if (Thread::current()->is_suspendible_thread()) {\n-    SetIndirectlySuspendibleThreadClosure cl;\n-    threads_do(&cl);\n-  }\n+    if (is_safepointed) {\n+      thread->set_indirectly_safepoint_thread();\n+    }\n+  });\n@@ -159,1 +170,1 @@\n-void WorkerThreads::clear_indirectly_suspendible_threads() {\n+void WorkerThreads::clear_indirect_states() {\n@@ -161,10 +172,4 @@\n-  class ClearIndirectlySuspendibleThreadClosure : public ThreadClosure {\n-    virtual void do_thread(Thread* thread) {\n-      thread->clear_indirectly_suspendible_thread();\n-    }\n-  };\n-\n-  if (Thread::current()->is_suspendible_thread()) {\n-    ClearIndirectlySuspendibleThreadClosure cl;\n-    threads_do(&cl);\n-  }\n+  threads_do_f([&](Thread* thread) {\n+    thread->clear_indirectly_suspendible_thread();\n+    thread->clear_indirectly_safepoint_thread();\n+  });\n@@ -175,1 +180,1 @@\n-  set_indirectly_suspendible_threads();\n+  set_indirect_states();\n@@ -177,1 +182,1 @@\n-  clear_indirectly_suspendible_threads();\n+  clear_indirect_states();\n","filename":"src\/hotspot\/share\/gc\/shared\/workerThread.cpp","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -96,2 +96,2 @@\n-  void set_indirectly_suspendible_threads();\n-  void clear_indirectly_suspendible_threads();\n+  void set_indirect_states();\n+  void clear_indirect_states();\n@@ -114,0 +114,2 @@\n+  template <typename Function>\n+  void threads_do_f(Function function) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/workerThread.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-    ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);\n+    ShenandoahSuspendibleThreadSetJoiner stsj;\n@@ -67,0 +67,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1657,1 +1657,1 @@\n-      ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);\n+      ShenandoahSuspendibleThreadSetJoiner stsj;\n@@ -2782,1 +2782,1 @@\n-      ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);\n+      ShenandoahSuspendibleThreadSetJoiner stsj;\n@@ -3230,3 +3230,1 @@\n-  if (ShenandoahSuspendibleWorkers) {\n-    SuspendibleThreadSet::synchronize();\n-  }\n+  SuspendibleThreadSet::synchronize();\n@@ -3236,3 +3234,1 @@\n-  if (ShenandoahSuspendibleWorkers) {\n-    SuspendibleThreadSet::desynchronize();\n-  }\n+  SuspendibleThreadSet::desynchronize();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -252,1 +252,1 @@\n-  if (sts_active && ShenandoahSuspendibleWorkers && !cancelled_gc()) {\n+  if (sts_active && !cancelled_gc()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-      ShenandoahSuspendibleThreadSetLeaver stsl(CANCELLABLE && ShenandoahSuspendibleWorkers);\n+      ShenandoahSuspendibleThreadSetLeaver stsl(CANCELLABLE);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -552,3 +552,0 @@\n-  product(bool, ShenandoahSuspendibleWorkers, true, EXPERIMENTAL,           \\\n-          \"Suspend concurrent GC worker threads at safepoints\")             \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"code\/codeCache.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"gc\/z\/zVerify.hpp\"\n@@ -36,1 +36,0 @@\n-#include \"runtime\/continuation.hpp\"\n@@ -323,8 +322,0 @@\n-inline void z_assert_is_barrier_safe() {\n-  assert(!Thread::current()->is_ConcurrentGC_thread() ||          \/* Need extra checks for ConcurrentGCThreads *\/\n-         Thread::current()->is_suspendible_thread() ||            \/* Thread prevents safepoints *\/\n-         Thread::current()->is_indirectly_suspendible_thread() || \/* Coordinator thread prevents safepoints *\/\n-         SafepointSynchronize::is_at_safepoint(),                 \/* Is at safepoint *\/\n-         \"Shouldn't perform load barrier\");\n-}\n-\n@@ -333,1 +324,1 @@\n-  z_assert_is_barrier_safe();\n+  z_verify_safepoints_are_blocked();\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.inline.hpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -288,0 +288,4 @@\n+bool ZGeneration::is_relocate_queue_active() const {\n+  return _relocate.is_queue_active();\n+}\n+\n@@ -1495,1 +1499,1 @@\n-  \/\/ TODO: The STS joiner is only needed to satisfy z_assert_is_barrier_safe that doesn't\n+  \/\/ TODO: The STS joiner is only needed to satisfy ZBarrier::assert_is_state_barrier_safe that doesn't\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -169,0 +169,1 @@\n+  bool is_relocate_queue_active() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/z\/zVerify.hpp\"\n@@ -34,0 +35,9 @@\n+  \/\/ This is a good place to make sure that we can't concurrently iterate over\n+  \/\/ objects while VMThread operations think they have exclusive access to the\n+  \/\/ object graph.\n+  \/\/\n+  \/\/ One example that have caused problems is the JFR Leak Profiler, which\n+  \/\/ sets the mark word to a value that makes the object arrays look like\n+  \/\/ invisible objects.\n+  z_verify_safepoints_are_blocked();\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zIterator.inline.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+    _is_active(false),\n@@ -106,0 +107,14 @@\n+void ZRelocateQueue::activate(uint nworkers) {\n+  _is_active = true;\n+  join(nworkers);\n+}\n+\n+void ZRelocateQueue::deactivate() {\n+  Atomic::store(&_is_active, false);\n+  clear();\n+}\n+\n+bool ZRelocateQueue::is_active() const {\n+  return Atomic::load(&_is_active);\n+}\n+\n@@ -330,1 +345,1 @@\n-  _queue.join(workers()->active_workers());\n+  _queue.activate(workers()->active_workers());\n@@ -1091,0 +1106,3 @@\n+\n+    \/\/ Signal that we're not using the queue anymore. Used mostly for asserts.\n+    _queue->deactivate();\n@@ -1235,2 +1253,0 @@\n-\n-  _queue.clear();\n@@ -1319,0 +1335,4 @@\n+\n+bool ZRelocate::is_queue_active() const {\n+  return _queue.is_active();\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  volatile bool        _is_active;\n@@ -56,0 +57,4 @@\n+  void activate(uint nworkers);\n+  void deactivate();\n+  bool is_active() const;\n+\n@@ -102,0 +107,2 @@\n+\n+  bool is_queue_active() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -109,0 +109,3 @@\n+    \/\/ Join the STS to block out VMThreads while running promote_barrier_on_young_oop_field\n+    SuspendibleThreadSetJoiner sts_joiner;\n+\n@@ -114,0 +117,2 @@\n+\n+      SuspendibleThreadSet::yield();\n@@ -121,0 +126,2 @@\n+\n+      SuspendibleThreadSet::yield();\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/z\/zBarrier.hpp\"\n@@ -36,1 +37,1 @@\n-  z_assert_is_barrier_safe();\n+  z_verify_safepoints_are_blocked();\n","filename":"src\/hotspot\/share\/gc\/z\/zUncoloredRoot.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,1 +46,2 @@\n-#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -51,0 +52,1 @@\n+#include \"runtime\/thread.hpp\"\n@@ -56,0 +58,49 @@\n+#ifdef ASSERT\n+\n+\/\/ Used to verify that safepoints operations can't be scheduled concurrently\n+\/\/ with callers to this function. Typically used to verify that object oops\n+\/\/ and headers are safe to access.\n+void z_verify_safepoints_are_blocked() {\n+  Thread* current = Thread::current();\n+\n+  if (current->is_ConcurrentGC_thread()) {\n+    assert(current->is_suspendible_thread(), \/\/ Thread prevents safepoints\n+        \"Safepoints are not blocked by current thread\");\n+\n+  } else if (current->is_Worker_thread()) {\n+    assert(\/\/ Check if ...\n+        \/\/ the thread prevents safepoints\n+        current->is_suspendible_thread() ||\n+        \/\/ the coordinator thread is the safepointing VMThread\n+        current->is_indirectly_safepoint_thread() ||\n+        \/\/ the coordinator thread prevents safepoints\n+        current->is_indirectly_suspendible_thread() ||\n+        \/\/ the RelocateQueue prevents safepoints\n+        \/\/\n+        \/\/ RelocateQueue acts as a pseudo STS leaver\/joiner and blocks\n+        \/\/ safepoints. There's currently no infrastructure  to check if the\n+        \/\/ current thread is active or not, so check the global states instead.\n+        ZGeneration::young()->is_relocate_queue_active() ||\n+        ZGeneration::old()->is_relocate_queue_active(),\n+        \"Safepoints are not blocked by current thread\");\n+\n+  } else if (current->is_Java_thread()) {\n+    JavaThreadState state = JavaThread::cast(current)->thread_state();\n+    assert(state == _thread_in_Java || state == _thread_in_vm || state == _thread_new,\n+        \"Safepoints are not blocked by current thread from state: %d\", state);\n+\n+  } else if (current->is_JfrSampler_thread()) {\n+    \/\/ The JFR sampler thread blocks out safepoints with this lock.\n+    assert_lock_strong(Threads_lock);\n+\n+  } else if (current->is_VM_thread()) {\n+    \/\/ The VM Thread doesn't schedule new safepoints while executing\n+    \/\/ other safepoint or handshake operations.\n+\n+  } else {\n+    fatal(\"Unexpected thread type\");\n+  }\n+}\n+\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":52,"deletions":1,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+NOT_DEBUG(inline) void z_verify_safepoints_are_blocked() NOT_DEBUG_RETURN;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -240,1 +240,5 @@\n-  assert(n->in(0) == nullptr, \"divisions with zero check should already have bailed out earlier in split-if\");\n+  if (n->in(0) != nullptr) {\n+    \/\/ Cannot split through phi if Div or Mod node has a control dependency to a zero check.\n+    return true;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+  DEBUG_ONLY(clear_indirectly_safepoint_thread();)\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -209,0 +209,1 @@\n+  DEBUG_ONLY(bool _indirectly_safepoint_thread;)\n@@ -227,0 +228,4 @@\n+\n+  void set_indirectly_safepoint_thread()   { _indirectly_safepoint_thread = true; }\n+  void clear_indirectly_safepoint_thread() { _indirectly_safepoint_thread = false; }\n+  bool is_indirectly_safepoint_thread()    { return _indirectly_safepoint_thread; }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -398,4 +398,1 @@\n-\/*\n- * Input is sockaddr just because all clients have it.\n- *\/\n-static void convertIPv4ToIPv6(const struct sockaddr *addr4, struct in6_addr *addr6) {\n+static void convertIPv4ToIPv6(const struct in_addr *addr4, struct in6_addr *addr6) {\n@@ -404,1 +401,0 @@\n-    struct in_addr *a4 = &(((struct sockaddr_in*)addr4)->sin_addr);\n@@ -409,1 +405,1 @@\n-    memcpy(&(addr6->s6_addr[12]), &(a4->s_addr), 4);\n+    memcpy(&(addr6->s6_addr[12]), &(addr4->s_addr), 4);\n@@ -418,22 +414,3 @@\n-    struct addrinfo hints;\n-    struct addrinfo *addrInfo = NULL;\n-    jdwpTransportError err;\n-\n-    \/*\n-     * To parse both IPv4 and IPv6 need to specify AF_UNSPEC family\n-     * (with AF_INET6 IPv4 addresses are not parsed even with AI_V4MAPPED and AI_ALL flags).\n-     *\/\n-    memset (&hints, 0, sizeof(hints));\n-    hints.ai_family = AF_UNSPEC;            \/\/ IPv6 or mapped IPv4\n-    hints.ai_socktype = SOCK_STREAM;\n-    hints.ai_protocol = IPPROTO_TCP;\n-    hints.ai_flags = AI_NUMERICHOST;        \/\/ only numeric addresses, no resolution\n-\n-    err = getAddrInfo(buffer, strlen(buffer), NULL, &hints, &addrInfo);\n-\n-    if (err != JDWPTRANSPORT_ERROR_NONE) {\n-        return err;\n-    }\n-\n-    if (addrInfo->ai_family == AF_INET6) {\n-        memcpy(result, &(((struct sockaddr_in6 *)(addrInfo->ai_addr))->sin6_addr), sizeof(*result));\n+    struct in_addr addr;\n+    struct in6_addr addr6;\n+    if (inet_pton(AF_INET6, buffer, &addr6) == 1) {\n@@ -441,4 +418,3 @@\n-    } else {    \/\/ IPv4 address - convert to mapped IPv6\n-        struct in6_addr addr6;\n-        convertIPv4ToIPv6(addrInfo->ai_addr, &addr6);\n-        memcpy(result, &addr6, sizeof(*result));\n+    } else if (inet_pton(AF_INET, buffer, &addr) == 1) {\n+        \/\/ IPv4 address - convert to mapped IPv6\n+        convertIPv4ToIPv6(&addr, &addr6);\n@@ -446,0 +422,2 @@\n+    } else {\n+        return JDWPTRANSPORT_ERROR_IO_ERROR;\n@@ -448,1 +426,1 @@\n-    dbgsysFreeAddrInfo(addrInfo);\n+    memcpy(result, &addr6, sizeof(*result));\n@@ -606,1 +584,2 @@\n-        convertIPv4ToIPv6((struct sockaddr *)peer, &tmp);\n+        struct in_addr *addr4 = &(((struct sockaddr_in*)peer)->sin_addr);\n+        convertIPv4ToIPv6(addr4, &tmp);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libdt_socket\/socketTransport.c","additions":13,"deletions":34,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=normal\n+ * @bug 8323101\n+ * @summary Test split_thru_phi with pinned divisions\/modulo that have phi as inputs.\n+ * @run main\/othervm -Xbatch\n+ *                   -XX:CompileCommand=compileonly,compiler.splitif.TestSplitDivThroughPhiWithControl::*\n+ *                   compiler.splitif.TestSplitDivThroughPhiWithControl\n+ *\/\n+\n+\/*\n+ * @test id=fuzzer\n+ * @bug 8323101\n+ * @summary Test split_thru_phi with pinned divisions\/modulo that have phi as inputs.\n+ * @run main\/othervm -Xbatch -XX:PerMethodTrapLimit=0\n+ *                   -XX:CompileCommand=compileonly,compiler.splitif.TestSplitDivThroughPhiWithControl::*\n+ *                   compiler.splitif.TestSplitDivThroughPhiWithControl\n+ *\/\n+\n+package compiler.splitif;\n+\n+public class TestSplitDivThroughPhiWithControl {\n+    static int divisorInt = 34;\n+    static int iFld;\n+    static int x;\n+    static int y;\n+    static long divisorLong = 34L;\n+    static long lFld;\n+    static long lFld2;\n+    static long lFld3;\n+    static boolean flag;\n+\n+    static int[] iArr = new int[400];\n+\n+    public static void main(String[] strArr) {\n+        iArr[0] = 52329;\n+        for (int i = 0; i < 10000; i++) {\n+            flag = i % 3 == 0;                 \/\/ Avoid unstable if trap\n+            divisorInt = i % 2 == 0 ? 0 : 23;  \/\/ Avoid div by zero trap\n+            divisorLong = divisorInt;          \/\/ Avoid div by zero trap\n+            try {\n+                testIntDiv();\n+            } catch (ArithmeticException e) {\n+                \/\/ Expected.\n+            }\n+\n+            try {\n+                testIntMod();\n+            } catch (ArithmeticException e) {\n+                \/\/ Expected.\n+            }\n+\n+            try {\n+                testLongDiv(); \/\/ Currently does not trigger due to JDK-8323652\n+            } catch (ArithmeticException e) {\n+                \/\/ Expected.\n+            }\n+\n+            try {\n+                testLongMod(); \/\/ Currently does not trigger due to JDK-8323652\n+            } catch (ArithmeticException e) {\n+                \/\/ Expected.\n+            }\n+\n+            testFuzzer();\n+        }\n+    }\n+\n+    static void testIntDiv() {\n+        int a;\n+\n+        for (int j = 0; j < 100; j++) {\n+            y += 5;\n+            int sub = j - 3; \/\/ AddI\n+            int div = (sub \/ divisorInt); \/\/ DivI with AddI input\n+\n+            if (flag) {\n+                a = y;\n+            } else {\n+                a = 2;\n+            }\n+            \/\/ Region\n+\n+            \/\/ Use StoreI with AddI input. Store needs to be split through Region in Split-If which is done together\n+            \/\/ with AddI.\n+            iFld = sub;\n+\n+            if (a < 3) { \/\/ If that's split in Split-If\n+                \/\/ Use of DivI -> after Split-If, DivI gets a Phi input that merges the split AddI nodes.\n+                \/\/ -> triggers assert that we should not find pinned div nodes in cannot_split_division().\n+                x = div;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as testIntDiv() but with ModI\n+    static void testIntMod() {\n+        int a;\n+\n+        for (int j = 0; j < 100; j++) {\n+            y += 5;\n+            int sub = j - 3;\n+            int mod = (sub % divisorInt);\n+\n+            if (flag) {\n+                a = y;\n+            } else {\n+                a = 2;\n+            }\n+\n+            iFld = sub;\n+\n+            if (a < 3) {\n+                x = mod; \/\/ Only StoreI visited first but not mod since it's an input\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as testIntDiv() but with DivL\n+    static void testLongDiv() {\n+        long a;\n+\n+        for (int j = 0; j < 100; j++) {\n+            y += 5;\n+            long sub = j - 3;\n+            long div = (sub \/ divisorLong);\n+\n+            if (flag) {\n+                a = lFld2;\n+            } else {\n+                a = 2;\n+            }\n+\n+            lFld = sub;\n+\n+            if (a < 3) {\n+                lFld3 = div;\n+            }\n+        }\n+    }\n+\n+\n+    \/\/ Same as testIntDiv() but with ModL\n+    static void testLongMod() {\n+        long a;\n+\n+        for (long j = 0; j < 100; j++) {\n+            lFld2 += 5;\n+            long sub = j - 3;\n+            long mod = (sub % divisorLong);\n+\n+            if (flag) {\n+                a = lFld2;\n+            } else {\n+                a = 2;\n+            }\n+\n+            lFld = sub;\n+\n+            if (a < 3) {\n+                lFld3 = mod; \/\/ Only StoreI visited first but not mod since it's an input\n+            }\n+        }\n+    }\n+\n+    \/\/ Original fuzzer crash\n+    static void testFuzzer() {\n+        int i19, i21 = 4928, i23 = 14;\n+        for (int i = 5; i < 100; i++) {\n+            i19 = i23;\n+            int j = 1;\n+            while (true) {\n+                try {\n+                    i21 = (iArr[0] \/ 34);\n+                    i23 = (j % i21);\n+                } catch (ArithmeticException a_e) {\n+                }\n+                iArr = iArr;\n+                iFld = i21;\n+                iArr[1] += 5;\n+                if (j == 1000) {\n+                    break;\n+                }\n+                j++;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/splitif\/TestSplitDivThroughPhiWithControl.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayCopyTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayIndexFillTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   -XX:+OptimizeFill\n+ *                   compiler.vectorization.runner.ArrayInvariantFillTest\n@@ -40,1 +45,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n@@ -69,0 +74,1 @@\n+        applyIf = {\"OptimizeFill\", \"false\"},\n@@ -70,0 +76,3 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"OptimizeFill\", \"true\"},\n+        counts = {IRNode.REPLICATE_B, \"0\"})\n@@ -80,0 +89,1 @@\n+        applyIf = {\"OptimizeFill\", \"false\"},\n@@ -81,0 +91,3 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"OptimizeFill\", \"true\"},\n+        counts = {IRNode.REPLICATE_S, \"0\"})\n@@ -91,0 +104,1 @@\n+        applyIf = {\"OptimizeFill\", \"false\"},\n@@ -92,0 +106,3 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"OptimizeFill\", \"true\"},\n+        counts = {IRNode.REPLICATE_S, \"0\"})\n@@ -102,0 +119,1 @@\n+        applyIf = {\"OptimizeFill\", \"false\"},\n@@ -103,0 +121,3 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"OptimizeFill\", \"true\"},\n+        counts = {IRNode.REPLICATE_I, \"0\"})\n@@ -124,0 +145,1 @@\n+        applyIf = {\"OptimizeFill\", \"false\"},\n@@ -125,0 +147,3 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"OptimizeFill\", \"true\"},\n+        counts = {IRNode.REPLICATE_F, \"0\"})\n@@ -180,0 +205,1 @@\n+        applyIf = {\"OptimizeFill\", \"false\"},\n@@ -181,0 +207,3 @@\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"OptimizeFill\", \"true\"},\n+        counts = {IRNode.REPLICATE_I, \"0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayInvariantFillTest.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayShiftOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayTypeConvertTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayUnsafeOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicBooleanOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicByteOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicCharOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicDoubleOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicFloatOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicIntOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicLongOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicShortOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n@@ -280,1 +280,1 @@\n-            res[i] *= bytes[i + 3];\n+            res[i] += bytes[i + 3];\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopArrayIndexComputeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopCombinedOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopControlFlowTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopLiveOutNodesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,2 +39,2 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n- * @requires (os.arch==\"amd64\" | os.arch==\"x86_64\" | os.simpleArch == \"aarch64\")\n+ * @requires (os.simpleArch == \"x64\") | (os.simpleArch == \"aarch64\")\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopRangeStrideTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopReductionOpTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/MultipleLoopsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @requires vm.compiler2.enabled & vm.flagless\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/StripMinedLoopTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,4 +28,0 @@\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n@@ -37,3 +33,0 @@\n-import java.io.File;\n-\n-import jdk.test.lib.Platform;\n@@ -54,2 +47,0 @@\n-    private static final long COMP_THRES_SECONDS = 30;\n-\n@@ -57,0 +48,2 @@\n+        Class klass = getClass();\n+\n@@ -58,1 +51,1 @@\n-        \/\/ For each method annotated with @Test in the test method, this test runner\n+        \/\/ For each method annotated with \"@Test\" in test classes, this test runner\n@@ -62,3 +55,0 @@\n-        \/\/ And each test method should not throw any exceptions.\n-        Class klass = getClass();\n-        \/\/ Add extra VM options to verify experimental auto-vectorization\n@@ -83,2 +73,0 @@\n-        \/\/ Add extra VM options to enable more auto-vectorization chances\n-        irTest.addFlags(\"-XX:-OptimizeFill\");\n@@ -120,3 +108,3 @@\n-        \/\/ Lock compilation and inovke the method to get reference result from\n-        \/\/ the interpreter\n-        WB.lockCompilation();\n+        \/\/ Temporarily disable the compiler and invoke the method to get reference\n+        \/\/ result from the interpreter\n+        WB.setBooleanVMFlag(\"UseCompiler\", false);\n@@ -130,1 +118,1 @@\n-        WB.unlockCompilation();\n+        WB.setBooleanVMFlag(\"UseCompiler\", true);\n@@ -136,4 +124,1 @@\n-            if (System.currentTimeMillis() - enqueueTime > COMP_THRES_SECONDS * 1000) {\n-                fail(\"Method is not compiled after \" + COMP_THRES_SECONDS + \"s.\");\n-            }\n-            Thread.sleep(50 \/*ms*\/);\n+            Thread.sleep(100 \/*ms*\/);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/VectorizationTestRunner.java","additions":8,"deletions":23,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -80,6 +80,0 @@\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=aggressive\n- *      -XX:+ShenandoahSuspendibleWorkers\n- *      TestAllocObjects\n- *\n@@ -101,5 +95,0 @@\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive\n- *      -XX:+ShenandoahSuspendibleWorkers\n- *      TestAllocObjects\n@@ -131,5 +120,0 @@\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=static\n- *      -XX:+ShenandoahSuspendibleWorkers\n- *      TestAllocObjects\n@@ -146,5 +130,0 @@\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=compact\n- *      -XX:+ShenandoahSuspendibleWorkers\n- *      TestAllocObjects\n@@ -196,5 +175,0 @@\n- *\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *      -XX:+ShenandoahSuspendibleWorkers\n- *      TestAllocObjects\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocObjects.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,2 +147,1 @@\n-        return Platform.jvmLibDir().resolve((Platform.isWindows() ? \"\" : \"lib\")\n-                + \"jsig.\" + Platform.sharedLibraryExt());\n+        return Platform.jvmLibDir().resolve(Platform.buildSharedLibraryName(\"jsig\"));\n","filename":"test\/hotspot\/jtreg\/runtime\/signal\/SigTestDriver.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,8 +42,1 @@\n-        String libname;\n-        if (Platform.isWindows()) {\n-            libname = name + \".dll\";\n-        } else if (Platform.isOSX()) {\n-            libname = \"lib\" + name + \".dylib\";\n-        } else {\n-            libname = \"lib\" + name + \".so\";\n-        }\n+        String libname = Platform.buildSharedLibraryName(name);\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/jvmti\/AttachFailed\/AttachFailedTestBase.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-        Path libpath = Paths.get(jdkPath, jdkLibPath(), sharedObjectName(\"instrument\"));\n+        Path libpath = Paths.get(jdkPath, jdkLibPath(), Platform.buildSharedLibraryName(\"instrument\"));\n@@ -160,13 +160,0 @@\n-    \/**\n-     * Build name of shared object according to platform rules\n-     *\/\n-    public static String sharedObjectName(String name) {\n-        if (Platform.isWindows()) {\n-            return name + \".dll\";\n-        }\n-        if (Platform.isOSX()) {\n-            return \"lib\" + name + \".dylib\";\n-        }\n-        return \"lib\" + name + \".so\";\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/jvmti\/LoadAgentDcmdTest.java","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,19 +47,3 @@\n-\n-        String osDependentBaseString = null;\n-        if (Platform.isAix()) {\n-            osDependentBaseString = \"lib%s.so\";\n-        } else if (Platform.isLinux()) {\n-            osDependentBaseString = \"lib%s.so\";\n-        } else if (Platform.isOSX()) {\n-            osDependentBaseString = \"lib%s.dylib\";\n-        } else if (Platform.isWindows()) {\n-            osDependentBaseString = \"%s.dll\";\n-        }\n-\n-        if (osDependentBaseString == null) {\n-            Assert.fail(\"Unsupported OS\");\n-        }\n-\n-        output.shouldContain(String.format(osDependentBaseString, \"jvm\"));\n-        output.shouldContain(String.format(osDependentBaseString, \"java\"));\n-        output.shouldContain(String.format(osDependentBaseString, \"management\"));\n+        output.shouldContain(Platform.buildSharedLibraryName(\"jvm\"));\n+        output.shouldContain(Platform.buildSharedLibraryName(\"java\"));\n+        output.shouldContain(Platform.buildSharedLibraryName(\"management\"));\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/DynLibsTest.java","additions":4,"deletions":20,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-                        .resolve(libname(args[0]))\n+                        .resolve(Platform.buildSharedLibraryName(args[0]))\n@@ -42,1 +42,1 @@\n-            Path dst = dstDir.resolve(libname(args[i])).toAbsolutePath();\n+            Path dst = dstDir.resolve(Platform.buildSharedLibraryName(args[i])).toAbsolutePath();\n@@ -51,7 +51,0 @@\n-\n-    private static String libname(String name) {\n-        return String.format(\"%s%s.%s\",\n-                Platform.isWindows() ? \"\" : \"lib\",\n-                name,\n-                Platform.sharedLibraryExt());\n-    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NativeLibraryCopier.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -82,3 +82,2 @@\n-        String prefix = Platform.isWindows() ? \"\" : \"lib\";\n-        String libname1 = prefix + JVMTI_AGENT1_LIB + \".\" + Platform.sharedLibraryExt();\n-        String libname2 = prefix + JVMTI_AGENT2_LIB + \".\" + Platform.sharedLibraryExt();\n+        String libname1 = Platform.buildSharedLibraryName(JVMTI_AGENT1_LIB);\n+        String libname2 = Platform.buildSharedLibraryName(JVMTI_AGENT2_LIB);\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/DynamicLoadWarningTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,0 +121,2 @@\n+        \/\/ Set date to 2024-01-01 to satisfy cert constraints\n+        params.setDate(new java.util.Date(1704067200000l));\n","filename":"test\/jdk\/java\/security\/cert\/CertPathBuilder\/akiExt\/AKISerialNumber.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4813831\n+ * @summary Verifies contents of table cells in HTML in JEditorPane wraps correctly\n+ * @key headful\n+ * @run main bug4813831\n+*\/\n+\n+import javax.swing.JEditorPane;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+import javax.swing.text.View;\n+import javax.swing.text.ParagraphView;\n+import javax.swing.text.html.HTMLEditorKit;\n+\n+import java.awt.Robot;\n+import java.awt.Shape;\n+\n+public class bug4813831 {\n+\n+    private static boolean passed = false;\n+    private boolean finished = false;\n+\n+    private static JEditorPane jep;\n+    private static JFrame f;\n+\n+    public void init() {\n+\n+        String text =\n+            \"<html><body>\" +\n+            \"<table border><tr>\" +\n+            \"<td align=center>XXXXXXXXXXXXXX<BR>X<BR>X<\/td>\" +\n+            \"<\/tr><\/table>\" +\n+            \"<\/body><\/html>\";\n+\n+        f = new JFrame();\n+        jep = new JEditorPane();\n+        jep.setEditorKit(new HTMLEditorKit());\n+        jep.setEditable(false);\n+\n+        jep.setText(text);\n+\n+        f.getContentPane().add(jep);\n+        f.setSize(20,500);\n+        f.setLocationRelativeTo(null);\n+        f.setVisible(true);\n+    }\n+\n+\n+    public static void main(String args[]) throws Exception {\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(100);\n+        bug4813831 test = new bug4813831();\n+        try {\n+            SwingUtilities.invokeAndWait(() -> test.init());\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            Shape r = jep.getBounds();\n+            View v = jep.getUI().getRootView(jep);\n+            do {\n+                int n = v.getViewCount();\n+                Shape sh = v.getChildAllocation(n - 1, r);\n+                if (sh != null) {\n+                    r = sh;\n+                }\n+                v = v.getView(n - 1);\n+            } while (!(v instanceof ParagraphView));\n+\n+            int n = v.getViewCount();\n+            \/\/ there should be 3 lines or more (if the first long line was wrapped) in a cell\n+            passed = n >= 3;\n+\n+            if (passed) {\n+                Shape sh = v.getChildAllocation(n - 2, r);\n+                int x1 = sh.getBounds().x;\n+                sh = v.getChildAllocation(n - 1, r);\n+                int x2 = sh.getBounds().x;\n+                System.out.println(\"x1: \" + x1 + \" x2: \" + x2);\n+                \/\/ lines should be equally aligned\n+                passed = (x1 == x2);\n+            }\n+            if (!passed) {\n+                throw new RuntimeException(\"Test failed.\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (f != null) {\n+                    f.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/text\/html\/TableView\/bug4813831.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4480602\n+ * @summary Verifies if DefaultTreeCellEditor.inHitRegion() incorrectly\n+ *          handles row bounds\n+ * @key headful\n+ * @run main bug4480602\n+*\/\n+\n+import java.awt.ComponentOrientation;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.MouseEvent;\n+import javax.swing.JFrame;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTree;\n+import javax.swing.tree.DefaultMutableTreeNode;\n+import javax.swing.tree.DefaultTreeCellEditor;\n+import javax.swing.tree.DefaultTreeCellRenderer;\n+import javax.swing.SwingUtilities;\n+\n+import java.util.Date;\n+\n+public class bug4480602 {\n+\n+    static JTree tree;\n+    static JFrame fr;\n+    static MyTreeCellEditor editor;\n+\n+    static Robot robot;\n+    boolean passed = false;\n+    boolean do_test = false;\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(100);\n+        try {\n+            SwingUtilities.invokeAndWait(() -> {\n+                fr = new JFrame(\"Test\");\n+\n+                String s = \"0\\u05D01\\u05D02\\u05D03\\u05D04\\u05D05\";\n+                DefaultMutableTreeNode root = new DefaultMutableTreeNode(s);\n+                root.add(new DefaultMutableTreeNode(s));\n+                root.add(new DefaultMutableTreeNode(s));\n+\n+                tree = new JTree(root);\n+                editor = new MyTreeCellEditor(tree, new DefaultTreeCellRenderer());\n+                tree.setCellEditor(editor);\n+                tree.setComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);\n+                tree.setEditable(true);\n+                JScrollPane sp = new JScrollPane(tree);\n+                fr.getContentPane().add(sp);\n+\n+                fr.setSize(250,200);\n+                fr.setLocationRelativeTo(null);\n+                fr.setVisible(true);\n+            });\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            SwingUtilities.invokeAndWait(() -> {\n+                Rectangle rect = tree.getRowBounds(1);\n+                editor.testTreeCellEditor(rect);\n+            });\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (fr != null) {\n+                    fr.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    static class MyTreeCellEditor extends DefaultTreeCellEditor {\n+\n+        public MyTreeCellEditor(JTree tree, DefaultTreeCellRenderer renderer) {\n+            super(tree, renderer);\n+        }\n+\n+        public void testTreeCellEditor(Rectangle rect) {\n+            int x = rect.x + 10;\n+            int y = rect.y + rect.height \/ 2;\n+            MouseEvent me = new MouseEvent(tree,\n+                                           MouseEvent.MOUSE_PRESSED,\n+                                           (new Date()).getTime(),\n+                                           MouseEvent.BUTTON1_DOWN_MASK,\n+                                           rect.x + 10, rect.y + 10,\n+                                           1, true);\n+            isCellEditable(me);\n+\n+            if (tree == null) {\n+                throw new RuntimeException(\"isCellEditable() should set the tree\");\n+            }\n+            if (lastRow != 1) {\n+                throw new RuntimeException(\"isCellEditable() should set the lastRow\");\n+            }\n+            if (offset == 0) {\n+                throw new RuntimeException(\"isCellEditable() should determine offset\");\n+            }\n+\n+            if (!inHitRegion(x,y)) {\n+                throw new RuntimeException(\"Hit region should contain point (\"+x+\", \"+y+\")\");\n+            }\n+            x = rect.x + rect.width - 10;\n+            if (inHitRegion(x,y)) {\n+                throw new RuntimeException(\"Hit region shouldn't contain point (\"+x+\", \"+y+\")\");\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/swing\/tree\/DefaultTreeCellEditor\/bug4480602.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4180224\n+ * @summary DefaultTreeCellRenderer.hasFocus protected (not private) now.\n+ * @key headful\n+ * @run main bug4180224\n+*\/\n+\n+import javax.swing.tree.DefaultTreeCellRenderer;\n+\n+public class bug4180224 {\n+\n+    static class MyDTCR extends DefaultTreeCellRenderer {\n+        void test() {\n+            hasFocus = false;\n+        }\n+    }\n+\n+    public static void main(String[] argv) {\n+        MyDTCR m = new MyDTCR();\n+        m.test();\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/tree\/DefaultTreeCellRenderer\/bug4180224.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4745001\n+ * @summary JTree with setLargeModel(true) not display correctly\n+ *          when we expand\/collapse nodes\n+ * @key headful\n+ * @run main bug4745001\n+*\/\n+\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Robot;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JTree;\n+import javax.swing.tree.DefaultMutableTreeNode;\n+import javax.swing.tree.DefaultTreeModel;\n+import javax.swing.tree.TreePath;\n+import javax.swing.event.TreeExpansionEvent;\n+import javax.swing.event.TreeExpansionListener;\n+import javax.swing.SwingUtilities;\n+\n+public class bug4745001 {\n+\n+    static JTree tree;\n+    static JFrame fr;\n+    boolean stateChanged;\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(100);\n+        bug4745001 test = new bug4745001();\n+        try {\n+            SwingUtilities.invokeAndWait(() -> test.init());\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            test.start();\n+            robot.delay(1000);\n+            test.destroy();\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (fr != null) {\n+                    fr.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    public void init() {\n+        fr = new JFrame(\"Test\");\n+        fr.getContentPane().setLayout(new FlowLayout());\n+\n+        tree = new JTree();\n+        tree.setRowHeight(20);\n+        tree.setLargeModel(true);\n+        tree.setPreferredSize(new Dimension(100, 400));\n+        tree.setRootVisible(false);\n+        tree.setShowsRootHandles(true);\n+\n+        DefaultMutableTreeNode root = new DefaultMutableTreeNode(\"\");\n+        DefaultMutableTreeNode a = new DefaultMutableTreeNode(\"a\");\n+        DefaultMutableTreeNode b = new DefaultMutableTreeNode(\"b\");\n+        DefaultMutableTreeNode c = new DefaultMutableTreeNode(\"c\");\n+        root.add(a);\n+        root.add(b);\n+        root.add(c);\n+        b.add(new DefaultMutableTreeNode(\"b1\"));\n+        c.add(new DefaultMutableTreeNode(\"c2\"));\n+        tree.setModel(new DefaultTreeModel(root));\n+\n+        fr.getContentPane().add(tree);\n+\n+        tree.addTreeExpansionListener(new TreeExpansionListener() {\n+            public void treeExpanded(TreeExpansionEvent e) {\n+                TreePath path = e.getPath();\n+                if (path != null) {\n+                    DefaultMutableTreeNode node =\n+                        (DefaultMutableTreeNode)path.getLastPathComponent();\n+                    node.removeAllChildren();\n+                    String s = (String)node.getUserObject();\n+                    node.add(new DefaultMutableTreeNode(s + \"1\"));\n+                    node.add(new DefaultMutableTreeNode(s + \"2\"));\n+                    node.add(new DefaultMutableTreeNode(s + \"3\"));\n+                    DefaultTreeModel model = (DefaultTreeModel)tree.getModel();\n+                    model.nodeStructureChanged(node);\n+                    synchronized (bug4745001.this) {\n+                        stateChanged = true;\n+                        bug4745001.this.notifyAll();\n+                    }\n+                }\n+            }\n+\n+            public void treeCollapsed(TreeExpansionEvent e) {\n+                synchronized (bug4745001.this) {\n+                    stateChanged = true;\n+                    bug4745001.this.notifyAll();\n+                }\n+            }\n+        });\n+\n+        fr.pack();\n+        fr.setVisible(true);\n+    }\n+\n+    void changeNodeStateForRow(final int row, final boolean expand) throws Exception {\n+        try {\n+            stateChanged = false;\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+                public void run() {\n+                    try {\n+                        if (expand) {\n+                            tree.expandRow(row);\n+                        } else {\n+                            tree.collapseRow(row);\n+                        }\n+                    } catch (Exception ex) {\n+                        ex.printStackTrace();\n+                    }\n+                 }\n+            });\n+            synchronized (this) {\n+                while (!stateChanged) {\n+                    bug4745001.this.wait();\n+                }\n+            }\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+        }\n+    }\n+\n+    public void start() throws Exception {\n+        \/\/ expand node \"c\"\n+        changeNodeStateForRow(2, true);\n+        \/\/ expand node \"b\"\n+        changeNodeStateForRow(1, true);\n+        \/\/ collapse node \"c\"\n+        changeNodeStateForRow(1, false);\n+    }\n+\n+    String[] expected = new String[] {\"a\", \"b\", \"c\", \"c1\", \"c2\", \"c3\"};\n+\n+    public void destroy() {\n+        for (int i = 0; i < expected.length; i++) {\n+            Object obj = tree.getPathForRow(i).getLastPathComponent();\n+            if (!obj.toString().equals(expected[i])) {\n+                throw new RuntimeException(\"Unexpected node at row \"+i);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/swing\/tree\/FixedHeightLayoutCache\/bug4745001.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,15 +73,0 @@\n-        String libTemplate = null;\n-        if (Platform.isWindows()) {\n-            libTemplate = \"%s.dll\";\n-        } else if (Platform.isOSX()) {\n-            libTemplate = \"lib%s.dylib\";\n-        } else if (Platform.isLinux()) {\n-            libTemplate = \"lib%s.so\";\n-        } else if (Platform.isAix()) {\n-            libTemplate = \"lib%s.so\";\n-        }\n-\n-        if (libTemplate == null) {\n-            throw new Exception(\"Unsupported OS\");\n-        }\n-\n@@ -91,1 +76,1 @@\n-            libs.add(String.format(libTemplate, name));\n+            libs.add(Platform.buildSharedLibraryName(name));\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestNativeLibrariesEvent.java","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -380,0 +380,21 @@\n+    \/**\n+     * Returns the usual file prefix of a shared library, e.g. \"lib\" on linux, empty on windows.\n+     * @return file name prefix\n+     *\/\n+    public static String sharedLibraryPrefix() {\n+        if (isWindows()) {\n+            return \"\";\n+        } else {\n+            return \"lib\";\n+        }\n+    }\n+\n+    \/**\n+     * Returns the usual full shared lib name of a name without prefix and extension, e.g. for jsig\n+     * \"libjsig.so\" on linux, \"jsig.dll\" on windows.\n+     * @return the full shared lib name\n+     *\/\n+    public static String buildSharedLibraryName(String name) {\n+        return sharedLibraryPrefix() + name + \".\" + sharedLibraryExt();\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/Platform.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"}]}