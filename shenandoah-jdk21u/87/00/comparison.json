{"files":[{"patch":"@@ -99,1 +99,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -98,1 +98,0 @@\n-\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-    ShenandoahHeapRegion* r = data[idx]._region;\n+    ShenandoahHeapRegion* r = data[idx].get_region();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    ShenandoahHeapRegion* r = data[idx]._region;\n+    ShenandoahHeapRegion* r = data[idx].get_region();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-    ShenandoahHeapRegion* r = data[idx]._region;\n+    ShenandoahHeapRegion* r = data[idx].get_region();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,2 +119,1 @@\n-          candidates[cand_idx]._region = region;\n-          candidates[cand_idx]._u._garbage = garbage;\n+          candidates[cand_idx].set_region_and_garbage(region, garbage);\n@@ -236,1 +235,1 @@\n-    ShenandoahHeapRegion* r = data[idx]._region;\n+    ShenandoahHeapRegion* r = data[idx].get_region();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGenerationalHeuristics.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-    ShenandoahHeapRegion* r = data[idx]._region;\n+    ShenandoahHeapRegion* r = data[idx].get_region();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGlobalHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  if (a._u._garbage > b._u._garbage)\n+  if (a.get_garbage() > b.get_garbage()) {\n@@ -41,1 +41,1 @@\n-  else if (a._u._garbage < b._u._garbage)\n+  } else if (a.get_garbage() < b.get_garbage()) {\n@@ -43,1 +43,3 @@\n-  else return 0;\n+  } else {\n+    return 0;\n+  }\n@@ -61,0 +63,5 @@\n+#ifdef ASSERT\n+  for (size_t i = 0; i < num_regions; i++) {\n+    _region_data[i].clear();\n+  }\n+#endif\n@@ -110,2 +117,1 @@\n-        candidates[cand_idx]._region = region;\n-        candidates[cand_idx]._u._garbage = garbage;\n+        candidates[cand_idx].set_region_and_garbage(region, garbage);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -72,0 +72,6 @@\n+#ifdef ASSERT\n+  enum UnionTag {\n+    is_uninitialized, is_garbage, is_live_data\n+  };\n+#endif\n+\n@@ -75,1 +81,2 @@\n-  typedef struct {\n+  class RegionData {\n+    private:\n@@ -80,2 +87,49 @@\n-    } _u;\n-  } RegionData;\n+    } _region_union;\n+#ifdef ASSERT\n+    UnionTag _union_tag;\n+#endif\n+    public:\n+\n+#ifdef ASSERT\n+    inline void clear() {\n+      _union_tag = is_uninitialized;\n+    }\n+#endif\n+\n+    inline void set_region_and_garbage(ShenandoahHeapRegion* region, size_t garbage) {\n+      _region = region;\n+      _region_union._garbage = garbage;\n+#ifdef ASSERT\n+      _union_tag = is_garbage;\n+#endif\n+    }\n+\n+    inline void set_region_and_livedata(ShenandoahHeapRegion* region, size_t live) {\n+      _region = region;\n+      _region_union._live_data = live;\n+#ifdef ASSERT\n+      _union_tag = is_live_data;\n+#endif\n+    }\n+\n+    inline ShenandoahHeapRegion* get_region() const {\n+#ifdef ASSERT\n+      assert(_union_tag != is_uninitialized, \"Cannot fetch region from uninialized RegionData\");\n+#endif\n+      return _region;\n+    }\n+\n+    inline size_t get_garbage() const {\n+#ifdef ASSERT\n+      assert(_union_tag == is_garbage, \"Invalid union fetch\");\n+#endif\n+      return _region_union._garbage;\n+    }\n+\n+    inline size_t get_livedata() const {\n+#ifdef ASSERT\n+      assert(_union_tag == is_live_data, \"Invalid union fetch\");\n+#endif\n+      return _region_union._live_data;\n+    }\n+  };\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":57,"deletions":3,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  if (a._u._live_data < b._u._live_data)\n+  if (a.get_livedata() < b.get_livedata()) {\n@@ -43,1 +43,1 @@\n-  else if (a._u._live_data > b._u._live_data)\n+  } else if (a.get_livedata() > b.get_livedata()) {\n@@ -45,1 +45,3 @@\n-  else return 0;\n+  } else {\n+    return 0;\n+  }\n@@ -50,1 +52,1 @@\n-  if (a._region->index() < b._region->index()) {\n+  if (a.get_region()->index() < b.get_region()->index()) {\n@@ -52,1 +54,1 @@\n-  } else if (a._region->index() > b._region->index()) {\n+  } else if (a.get_region()->index() > b.get_region()->index()) {\n@@ -247,1 +249,1 @@\n-    ShenandoahHeapRegion* region = _region_data[i]._region;\n+    ShenandoahHeapRegion* region = _region_data[i].get_region();\n@@ -267,1 +269,1 @@\n-    ShenandoahHeapRegion* region = _region_data[search]._region;\n+    ShenandoahHeapRegion* region = _region_data[search].get_region();\n@@ -297,1 +299,1 @@\n-    if (skipped._region->is_pinned()) {\n+    if (skipped.get_region()->is_pinned()) {\n@@ -299,2 +301,1 @@\n-      available_slot._region = skipped._region;\n-      available_slot._u._live_data = skipped._u._live_data;\n+      available_slot.set_region_and_livedata(skipped.get_region(), skipped.get_livedata());\n@@ -343,2 +344,1 @@\n-        candidates[cand_idx]._region = region;\n-        candidates[cand_idx]._u._live_data = live_bytes;\n+        candidates[cand_idx].set_region_and_livedata(region, live_bytes);\n@@ -394,1 +394,1 @@\n-    size_t live = candidates[i]._u._live_data;\n+    size_t live = candidates[i].get_livedata();\n@@ -400,2 +400,3 @@\n-    size_t region_garbage = candidates[i]._region->garbage();\n-    size_t region_free = candidates[i]._region->free();\n+    ShenandoahHeapRegion* r = candidates[i].get_region();\n+    size_t region_garbage = r->garbage();\n+    size_t region_free = r->free();\n@@ -427,2 +428,2 @@\n-    const size_t first_unselected_old_region = candidates[_last_old_collection_candidate]._region->index();\n-    const size_t last_unselected_old_region = candidates[cand_idx - 1]._region->index();\n+    const size_t first_unselected_old_region = candidates[_last_old_collection_candidate].get_region()->index();\n+    const size_t last_unselected_old_region = candidates[cand_idx - 1].get_region()->index();\n@@ -439,1 +440,1 @@\n-      ShenandoahHeapRegion* r = candidates[_last_old_collection_candidate]._region;\n+      ShenandoahHeapRegion* r = candidates[_last_old_collection_candidate].get_region();\n@@ -442,1 +443,1 @@\n-      const size_t region_garbage = candidates[_last_old_collection_candidate]._region->garbage();\n+      const size_t region_garbage = r->garbage();\n@@ -451,1 +452,2 @@\n-      span_of_uncollected_regions = 1 + last_unselected_old_region - candidates[_last_old_collection_candidate]._region->index();\n+      span_of_uncollected_regions =\n+        1 + last_unselected_old_region - candidates[_last_old_collection_candidate].get_region()->index();\n@@ -502,1 +504,1 @@\n-    ShenandoahHeapRegion* next = _region_data[_next_old_collection_candidate]._region;\n+    ShenandoahHeapRegion* next = _region_data[_next_old_collection_candidate].get_region();\n@@ -525,1 +527,1 @@\n-    *buffer++ = _region_data[index++]._region;\n+    *buffer++ = _region_data[index++].get_region();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":24,"deletions":22,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-    ShenandoahHeapRegion* r = data[idx]._region;\n+    ShenandoahHeapRegion* r = data[idx].get_region();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahPassiveHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    ShenandoahHeapRegion* r = data[idx]._region;\n+    ShenandoahHeapRegion* r = data[idx].get_region();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    ShenandoahHeapRegion* r = data[idx]._region;\n+    ShenandoahHeapRegion* r = data[idx].get_region();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,3 +137,0 @@\n-      \/\/ retire_plab may register the remnant filler object with the remembered set scanner without a lock.\n-      \/\/ This is safe because it is assured that each PLAB is a whole-number multiple of card-mark memory size and each\n-      \/\/ PLAB is aligned with the start of each card's memory range.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -274,1 +274,0 @@\n-  \/\/ Humongous regions are promoted on demand and are accounted for by normal Full GC mechanisms.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -549,0 +549,1 @@\n+    \/\/ No lock is necessary because the PLAB memory is aligned on card boundaries.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}