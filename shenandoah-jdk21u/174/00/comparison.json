{"files":[{"patch":"@@ -80,0 +80,1 @@\n+    _shenandoah_humongous_allocation_failure,\n","filename":"src\/hotspot\/share\/gc\/shared\/gcCause.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -191,0 +191,1 @@\n+    log_trigger(\"GC start is already pending\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-  _old_gen(generation),\n@@ -572,1 +571,1 @@\n-    size_t old_available = _old_gen->available() \/ HeapWordSize;\n+    size_t old_available = _old_generation->available() \/ HeapWordSize;\n@@ -574,1 +573,1 @@\n-    size_t old_unaffiliated_available = _old_gen->free_unaffiliated_regions() * region_size_words;\n+    size_t old_unaffiliated_available = _old_generation->free_unaffiliated_regions() * region_size_words;\n@@ -608,2 +607,2 @@\n-  size_t old_used = _old_gen->used() + _old_gen->get_humongous_waste();\n-  size_t trigger_threshold = _old_gen->usage_trigger_threshold();\n+  size_t old_used = _old_generation->used() + _old_generation->get_humongous_waste();\n+  size_t trigger_threshold = _old_generation->usage_trigger_threshold();\n@@ -613,1 +612,1 @@\n-         _old_gen->used(), _old_gen->get_humongous_waste(), _heap->capacity());\n+         _old_generation->used(), _old_generation->get_humongous_waste(), _heap->capacity());\n@@ -625,0 +624,17 @@\n+bool ShenandoahOldHeuristics::should_resume_old_cycle() {\n+  \/\/ If we are preparing to mark old, or if we are already marking old, then try to continue that work.\n+  if (_old_generation->is_concurrent_mark_in_progress()) {\n+    assert(_old_generation->state() == ShenandoahOldGeneration::MARKING, \"Unexpected old gen state: %s\", _old_generation->state_name());\n+    log_trigger(\"Resume marking old\");\n+    return true;\n+  }\n+\n+  if (_old_generation->is_preparing_for_mark()) {\n+    assert(_old_generation->state() == ShenandoahOldGeneration::FILLING, \"Unexpected old gen state: %s\", _old_generation->state_name());\n+    log_trigger(\"Resume preparing to mark old\");\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n@@ -626,6 +642,8 @@\n-  \/\/ Cannot start a new old-gen GC until previous one has finished.\n-  \/\/\n-  \/\/ Future refinement: under certain circumstances, we might be more sophisticated about this choice.\n-  \/\/ For example, we could choose to abandon the previous old collection before it has completed evacuations.\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  if (!_old_generation->can_start_gc() || heap->collection_set()->has_old_regions()) {\n+\n+  const ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (_old_generation->is_doing_mixed_evacuations()) {\n+    \/\/ Do not try to start an old cycle if we are waiting for old regions to be evacuated (we need\n+    \/\/ a young cycle for this). Note that the young heuristic has a feature to expedite old evacuations.\n+    \/\/ Future refinement: under certain circumstances, we might be more sophisticated about this choice.\n+    \/\/ For example, we could choose to abandon the previous old collection before it has completed evacuations.\n+    log_debug(gc)(\"Not starting an old cycle because we are waiting for mixed evacuations\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":30,"deletions":12,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-  ShenandoahOldGeneration* _old_gen;\n@@ -189,0 +188,3 @@\n+  \/\/ Returns true if the old generation needs to prepare for marking, or continue marking.\n+  bool should_resume_old_cycle();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-bool ShenandoahCollectorPolicy::is_at_shutdown() {\n+bool ShenandoahCollectorPolicy::is_at_shutdown() const {\n@@ -130,1 +130,1 @@\n-bool is_explicit_gc(GCCause::Cause cause) {\n+bool ShenandoahCollectorPolicy::is_explicit_gc(GCCause::Cause cause) {\n@@ -132,1 +132,3 @@\n-      || GCCause::is_serviceability_requested_gc(cause);\n+      || GCCause::is_serviceability_requested_gc(cause)\n+      || cause == GCCause::_wb_full_gc\n+      || cause == GCCause::_wb_young_gc;\n@@ -139,1 +141,1 @@\n-      && !is_explicit_gc(cause);\n+      && !ShenandoahCollectorPolicy::is_explicit_gc(cause);\n@@ -144,1 +146,2 @@\n-  return is_explicit_gc(cause)\n+  return ShenandoahCollectorPolicy::is_explicit_gc(cause)\n+      || ShenandoahCollectorPolicy::is_shenandoah_gc(cause)\n@@ -156,0 +159,16 @@\n+bool ShenandoahCollectorPolicy::is_shenandoah_gc(GCCause::Cause cause) {\n+  return cause == GCCause::_allocation_failure\n+      || cause == GCCause::_shenandoah_stop_vm\n+      || cause == GCCause::_shenandoah_allocation_failure_evac\n+      || cause == GCCause::_shenandoah_humongous_allocation_failure\n+      || cause == GCCause::_shenandoah_concurrent_gc\n+      || cause == GCCause::_shenandoah_upgrade_to_full_gc;\n+}\n+\n+\n+bool ShenandoahCollectorPolicy::is_allocation_failure(GCCause::Cause cause) {\n+  return cause == GCCause::_allocation_failure\n+      || cause == GCCause::_shenandoah_allocation_failure_evac\n+      || cause == GCCause::_shenandoah_humongous_allocation_failure;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.cpp","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  bool is_at_shutdown();\n+  bool is_at_shutdown() const;\n@@ -82,1 +82,1 @@\n-  ShenandoahTracer* tracer() {return _tracer;}\n+  ShenandoahTracer* tracer() const {return _tracer;}\n@@ -93,1 +93,1 @@\n-  inline size_t consecutive_degenerated_gc_count() const {\n+  size_t consecutive_degenerated_gc_count() const {\n@@ -97,0 +97,2 @@\n+  static bool is_allocation_failure(GCCause::Cause cause);\n+  static bool is_shenandoah_gc(GCCause::Cause cause);\n@@ -98,0 +100,1 @@\n+  static bool is_explicit_gc(GCCause::Cause cause);\n@@ -101,1 +104,1 @@\n-  inline size_t consecutive_young_gc_count() const {\n+  size_t consecutive_young_gc_count() const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-\n@@ -63,1 +62,6 @@\n-  while (!in_graceful_shutdown() && !should_terminate()) {\n+  while (!should_terminate()) {\n+    const GCCause::Cause cancelled_cause = heap->cancelled_cause();\n+    if (cancelled_cause == GCCause::_shenandoah_stop_vm) {\n+      break;\n+    }\n+\n@@ -65,1 +69,1 @@\n-    const bool alloc_failure_pending = _alloc_failure_gc.is_set();\n+    const bool alloc_failure_pending = ShenandoahCollectorPolicy::is_allocation_failure(cancelled_cause);\n@@ -167,2 +171,2 @@\n-      \/\/ If this was the allocation failure GC cycle, notify waiters about it\n-      if (alloc_failure_pending) {\n+      \/\/ If this cycle completed without being cancelled, notify waiters about it\n+      if (!heap->cancelled_gc()) {\n@@ -258,5 +262,0 @@\n-\n-  \/\/ Wait for the actual stop(), can't leave run_service() earlier.\n-  while (!should_terminate()) {\n-    os::naked_short_sleep(ShenandoahControlIntervalMin);\n-  }\n@@ -326,2 +325,5 @@\n-    assert (is_alloc_failure_gc() || in_graceful_shutdown(), \"Cancel GC either for alloc failure GC, or gracefully exiting\");\n-    if (!in_graceful_shutdown()) {\n+    if (heap->cancelled_cause() == GCCause::_shenandoah_stop_vm) {\n+      return true;\n+    }\n+\n+    if (ShenandoahCollectorPolicy::is_allocation_failure(heap->cancelled_cause())) {\n@@ -331,0 +333,1 @@\n+      return true;\n@@ -332,1 +335,2 @@\n-    return true;\n+\n+    fatal(\"Unexpected reason for cancellation: %s\", GCCause::to_string(heap->cancelled_cause()));\n@@ -338,1 +342,1 @@\n-  \/\/ Nothing to do here.\n+  ShenandoahHeap::heap()->cancel_gc(GCCause::_shenandoah_stop_vm);\n@@ -367,0 +371,5 @@\n+  if (should_terminate()) {\n+    log_info(gc)(\"Control thread is terminating, no more GCs\");\n+    return;\n+  }\n+\n@@ -389,1 +398,1 @@\n-  while (current_gc_id < required_gc_id) {\n+  while (current_gc_id < required_gc_id && !should_terminate()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":24,"deletions":15,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n@@ -40,8 +41,0 @@\n-void ShenandoahController::prepare_for_graceful_shutdown() {\n-  _graceful_shutdown.set();\n-}\n-\n-bool ShenandoahController::in_graceful_shutdown() {\n-  return _graceful_shutdown.is_set();\n-}\n-\n@@ -56,3 +49,1 @@\n-void ShenandoahController::handle_alloc_failure(ShenandoahAllocRequest& req, bool block) {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n+void ShenandoahController::handle_alloc_failure(const ShenandoahAllocRequest& req, bool block) {\n@@ -60,1 +51,0 @@\n-  bool is_humongous = ShenandoahHeapRegion::requires_humongous(req.size());\n@@ -62,5 +52,2 @@\n-  if (try_set_alloc_failure_gc(is_humongous)) {\n-    \/\/ Only report the first allocation failure\n-    log_info(gc)(\"Failed to allocate %s, \" SIZE_FORMAT \"%s\",\n-                 req.type_string(),\n-                 byte_size_in_proper_unit(req.size() * HeapWordSize), proper_unit_for_byte_size(req.size() * HeapWordSize));\n+  const bool is_humongous = ShenandoahHeapRegion::requires_humongous(req.size());\n+  const GCCause::Cause cause = is_humongous ? GCCause::_shenandoah_humongous_allocation_failure : GCCause::_allocation_failure;\n@@ -68,2 +55,4 @@\n-    \/\/ Now that alloc failure GC is scheduled, we can abort everything else\n-    heap->cancel_gc(GCCause::_allocation_failure);\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  if (heap->cancel_gc(cause)) {\n+    log_info(gc)(\"Failed to allocate %s, \" PROPERFMT, req.type_string(), PROPERFMTARGS(req.size() * HeapWordSize));\n+    request_gc(cause);\n@@ -72,1 +61,0 @@\n-\n@@ -75,1 +63,1 @@\n-    while (is_alloc_failure_gc()) {\n+    while (!should_terminate() && ShenandoahCollectorPolicy::is_allocation_failure(heap->cancelled_cause())) {\n@@ -82,2 +70,0 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  bool is_humongous = ShenandoahHeapRegion::requires_humongous(words);\n@@ -85,5 +71,3 @@\n-  if (try_set_alloc_failure_gc(is_humongous)) {\n-    \/\/ Only report the first allocation failure\n-    log_info(gc)(\"Failed to allocate \" SIZE_FORMAT \"%s for evacuation\",\n-                 byte_size_in_proper_unit(words * HeapWordSize), proper_unit_for_byte_size(words * HeapWordSize));\n-  }\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  const bool is_humongous = ShenandoahHeapRegion::requires_humongous(words);\n+  const GCCause::Cause cause = is_humongous ? GCCause::_shenandoah_humongous_allocation_failure : GCCause::_shenandoah_allocation_failure_evac;\n@@ -91,2 +75,3 @@\n-  \/\/ Forcefully report allocation failure\n-  heap->cancel_gc(GCCause::_shenandoah_allocation_failure_evac);\n+  if (heap->cancel_gc(cause)) {\n+    log_info(gc)(\"Failed to allocate \" PROPERFMT \" for evacuation\", PROPERFMTARGS(words * HeapWordSize));\n+  }\n@@ -96,2 +81,0 @@\n-  _alloc_failure_gc.unset();\n-  _humongous_alloc_failure_gc.unset();\n@@ -102,11 +85,0 @@\n-bool ShenandoahController::try_set_alloc_failure_gc(bool is_humongous) {\n-  if (is_humongous) {\n-    _humongous_alloc_failure_gc.try_set();\n-  }\n-  return _alloc_failure_gc.try_set();\n-}\n-\n-bool ShenandoahController::is_alloc_failure_gc() {\n-  return _alloc_failure_gc.is_set();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.cpp","additions":15,"deletions":43,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-  ShenandoahSharedFlag _graceful_shutdown;\n-\n@@ -44,0 +42,1 @@\n+  \/\/ A monotonically increasing GC count.\n@@ -48,3 +47,0 @@\n-  ShenandoahSharedFlag _alloc_failure_gc;\n-  ShenandoahSharedFlag _humongous_alloc_failure_gc;\n-\n@@ -57,0 +53,3 @@\n+  \/\/ Increments the internal GC count.\n+  void update_gc_id();\n+\n@@ -59,1 +58,0 @@\n-    ConcurrentGCThread(),\n@@ -71,2 +69,2 @@\n-  \/\/ until another cycle runs and clears the alloc failure gc flag.\n-  void handle_alloc_failure(ShenandoahAllocRequest& req, bool block);\n+  \/\/ until another cycle completes successfully.\n+  void handle_alloc_failure(const ShenandoahAllocRequest& req, bool block);\n@@ -78,3 +76,0 @@\n-  \/\/ Return true if setting the flag which indicates allocation failure succeeds.\n-  bool try_set_alloc_failure_gc(bool is_humongous);\n-\n@@ -84,3 +79,0 @@\n-  \/\/ True if allocation failure flag has been set.\n-  bool is_alloc_failure_gc();\n-\n@@ -91,7 +83,0 @@\n-  size_t reset_allocs_seen();\n-\n-  \/\/ These essentially allows to cancel a collection cycle for the\n-  \/\/ purpose of shutting down the JVM, without trying to start a degenerated\n-  \/\/ cycle.\n-  void prepare_for_graceful_shutdown();\n-  bool in_graceful_shutdown();\n@@ -99,0 +84,2 @@\n+  \/\/ Zeros out the number of allocations seen since the last GC cycle.\n+  size_t reset_allocs_seen();\n@@ -100,2 +87,1 @@\n-  \/\/ Returns the internal gc count used by the control thread. Probably\n-  \/\/ doesn't need to be exposed.\n+  \/\/ Return the value of a monotonic increasing GC count, maintained by the control thread.\n@@ -103,1 +89,0 @@\n-  void update_gc_id();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.hpp","additions":9,"deletions":24,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -49,0 +48,1 @@\n+#include \"utilities\/events.hpp\"\n@@ -51,3 +51,1 @@\n-  ShenandoahController(),\n-  _control_lock(Mutex::nosafepoint - 2, \"ShenandoahControlGC_lock\", true),\n-  _regulator_lock(Mutex::nosafepoint - 2, \"ShenandoahRegulatorGC_lock\", true),\n+  _control_lock(Mutex::nosafepoint - 2, \"ShenandoahGCRequest_lock\", true),\n@@ -55,4 +53,5 @@\n-  _requested_generation(GLOBAL),\n-  _degen_point(ShenandoahGC::_degenerated_outside_cycle),\n-  _degen_generation(nullptr),\n-  _mode(none) {\n+  _requested_generation(nullptr),\n+  _gc_mode(none),\n+  _degen_point(ShenandoahGC::_degenerated_unset),\n+  _heap(ShenandoahGenerationalHeap::heap()),\n+  _age_period(0) {\n@@ -65,1 +64,0 @@\n-  ShenandoahGenerationalHeap* const heap = ShenandoahGenerationalHeap::heap();\n@@ -67,4 +65,3 @@\n-  const GCMode default_mode = concurrent_normal;\n-  ShenandoahGenerationType generation = GLOBAL;\n-\n-  uint age_period = 0;\n+  const int64_t wait_ms = ShenandoahPacing ? ShenandoahControlIntervalMin : 0;\n+  ShenandoahGCRequest request;\n+  while (!should_terminate()) {\n@@ -72,1 +69,2 @@\n-  ShenandoahCollectorPolicy* const policy = heap->shenandoah_policy();\n+    \/\/ This control loop iteration has seen this much allocation.\n+    const size_t allocs_seen = reset_allocs_seen();\n@@ -74,6 +72,0 @@\n-  \/\/ Heuristics are notified of allocation failures here and other outcomes\n-  \/\/ of the cycle. They're also used here to control whether the Nth consecutive\n-  \/\/ degenerated cycle should be 'promoted' to a full cycle. The decision to\n-  \/\/ trigger a cycle or not is evaluated on the regulator thread.\n-  ShenandoahHeuristics* global_heuristics = heap->global_generation()->heuristics();\n-  while (!in_graceful_shutdown() && !should_terminate()) {\n@@ -81,2 +73,1 @@\n-    const bool alloc_failure_pending = _alloc_failure_gc.is_set();\n-    const bool humongous_alloc_failure_pending = _humongous_alloc_failure_gc.is_set();\n+    check_for_request(request);\n@@ -84,1 +75,3 @@\n-    GCCause::Cause cause = Atomic::xchg(&_requested_gc_cause, GCCause::_no_gc);\n+    if (request.cause == GCCause::_shenandoah_stop_vm) {\n+      break;\n+    }\n@@ -86,1 +79,8 @@\n-    const bool is_gc_requested = ShenandoahCollectorPolicy::is_requested_gc(cause);\n+    if (request.cause != GCCause::_no_gc) {\n+      run_gc_cycle(request);\n+    } else {\n+      \/\/ Report to pacer that we have seen this many words allocated\n+      if (ShenandoahPacing && (allocs_seen > 0)) {\n+        _heap->pacer()->report_alloc(allocs_seen);\n+      }\n+    }\n@@ -88,2 +88,10 @@\n-    \/\/ This control loop iteration has seen this much allocation.\n-    const size_t allocs_seen = reset_allocs_seen();\n+    \/\/ If the cycle was cancelled, continue the next iteration to deal with it. Otherwise,\n+    \/\/ if there was no other cycle requested, cleanup and wait for the next request.\n+    if (!_heap->cancelled_gc()) {\n+      MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n+      if (_requested_gc_cause == GCCause::_no_gc) {\n+        set_gc_mode(ml, none);\n+        ml.wait(wait_ms);\n+      }\n+    }\n+  }\n@@ -91,2 +99,5 @@\n-    \/\/ Check if we have seen a new target for soft max heap size.\n-    const bool soft_max_changed = heap->check_soft_max_changed();\n+  \/\/ In case any threads are waiting for a cycle to happen, notify them so they observe the shutdown.\n+  notify_gc_waiters();\n+  notify_alloc_failure_waiters();\n+  set_gc_mode(stopped);\n+}\n@@ -94,3 +105,9 @@\n-    \/\/ Choose which GC mode to run in. The block below should select a single mode.\n-    set_gc_mode(none);\n-    ShenandoahGC::ShenandoahDegenPoint degen_point = ShenandoahGC::_degenerated_unset;\n+void ShenandoahGenerationalControlThread::stop_service() {\n+  log_debug(gc, thread)(\"Stopping control thread\");\n+  MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n+  _heap->cancel_gc(GCCause::_shenandoah_stop_vm);\n+  _requested_gc_cause = GCCause::_shenandoah_stop_vm;\n+  notify_cancellation(ml, GCCause::_shenandoah_stop_vm);\n+  \/\/ We can't wait here because it may interfere with the active cycle's ability\n+  \/\/ to reach a safepoint (this runs on a java thread).\n+}\n@@ -98,3 +115,16 @@\n-    if (alloc_failure_pending) {\n-      \/\/ Allocation failure takes precedence: we have to deal with it first thing\n-      cause = GCCause::_allocation_failure;\n+void ShenandoahGenerationalControlThread::check_for_request(ShenandoahGCRequest& request) {\n+  \/\/ Hold the lock while we read request cause and generation\n+  MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n+  if (_heap->cancelled_gc()) {\n+    \/\/ The previous request was cancelled. Either it was cancelled for an allocation\n+    \/\/ failure (degenerated cycle), or old marking was cancelled to run a young collection.\n+    \/\/ In either case, the correct generation for the next cycle can be determined by\n+    \/\/ the cancellation cause.\n+    request.cause = _heap->cancelled_cause();\n+    if (request.cause == GCCause::_shenandoah_concurrent_gc) {\n+      request.generation = _heap->young_generation();\n+      _heap->clear_cancelled_gc(false);\n+    }\n+  } else {\n+    request.cause = _requested_gc_cause;\n+    request.generation = _requested_generation;\n@@ -102,3 +132,5 @@\n-      \/\/ Consume the degen point, and seed it with default value\n-      degen_point = _degen_point;\n-      _degen_point = ShenandoahGC::_degenerated_outside_cycle;\n+    \/\/ Only clear these if we made a request from them. In the case of a cancelled gc,\n+    \/\/ we do not want to inadvertently lose this pending request.\n+    _requested_gc_cause = GCCause::_no_gc;\n+    _requested_generation = nullptr;\n+  }\n@@ -106,5 +138,3 @@\n-      if (degen_point == ShenandoahGC::_degenerated_outside_cycle) {\n-        _degen_generation = heap->young_generation();\n-      } else {\n-        assert(_degen_generation != nullptr, \"Need to know which generation to resume\");\n-      }\n+  if (request.cause == GCCause::_no_gc || request.cause == GCCause::_shenandoah_stop_vm) {\n+    return;\n+  }\n@@ -112,3 +142,10 @@\n-      ShenandoahHeuristics* heuristics = _degen_generation->heuristics();\n-      generation = _degen_generation->type();\n-      bool old_gen_evacuation_failed = heap->old_generation()->clear_failed_evacuation();\n+  GCMode mode;\n+  if (ShenandoahCollectorPolicy::is_allocation_failure(request.cause)) {\n+    mode = prepare_for_allocation_failure_gc(request);\n+  } else if (ShenandoahCollectorPolicy::is_explicit_gc(request.cause)) {\n+    mode = prepare_for_explicit_gc(request);\n+  } else {\n+    mode = prepare_for_concurrent_gc(request);\n+  }\n+  set_gc_mode(ml, mode);\n+}\n@@ -116,1 +153,1 @@\n-      heuristics->log_trigger(\"Handle Allocation Failure\");\n+ShenandoahGenerationalControlThread::GCMode ShenandoahGenerationalControlThread::prepare_for_allocation_failure_gc(ShenandoahGCRequest &request) {\n@@ -118,16 +155,8 @@\n-      \/\/ Do not bother with degenerated cycle if old generation evacuation failed or if humongous allocation failed\n-      if (ShenandoahDegeneratedGC && heuristics->should_degenerate_cycle() &&\n-          !old_gen_evacuation_failed && !humongous_alloc_failure_pending) {\n-        heuristics->record_allocation_failure_gc();\n-        policy->record_alloc_failure_to_degenerated(degen_point);\n-        set_gc_mode(stw_degenerated);\n-      } else {\n-        heuristics->record_allocation_failure_gc();\n-        policy->record_alloc_failure_to_full();\n-        generation = GLOBAL;\n-        set_gc_mode(stw_full);\n-      }\n-    } else if (is_gc_requested) {\n-      generation = GLOBAL;\n-      global_heuristics->log_trigger(\"GC request (%s)\", GCCause::to_string(cause));\n-      global_heuristics->record_requested_gc();\n+  if (_degen_point == ShenandoahGC::_degenerated_unset) {\n+    _degen_point = ShenandoahGC::_degenerated_outside_cycle;\n+    request.generation = _heap->young_generation();\n+  } else if (request.generation->is_old()) {\n+    \/\/ This means we degenerated during the young bootstrap for the old generation\n+    \/\/ cycle. The following degenerated cycle should therefore also be young.\n+    request.generation = _heap->young_generation();\n+  }\n@@ -135,20 +164,2 @@\n-      if (ShenandoahCollectorPolicy::should_run_full_gc(cause)) {\n-        set_gc_mode(stw_full);\n-      } else {\n-        set_gc_mode(default_mode);\n-        \/\/ Unload and clean up everything\n-        heap->set_unload_classes(global_heuristics->can_unload_classes());\n-      }\n-    } else {\n-      \/\/ We should only be here if the regulator requested a cycle or if\n-      \/\/ there is an old generation mark in progress.\n-      if (cause == GCCause::_shenandoah_concurrent_gc) {\n-        if (_requested_generation == OLD && heap->old_generation()->is_doing_mixed_evacuations()) {\n-          \/\/ If a request to start an old cycle arrived while an old cycle was running, but _before_\n-          \/\/ it chose any regions for evacuation we don't want to start a new old cycle. Rather, we want\n-          \/\/ the heuristic to run a young collection so that we can evacuate some old regions.\n-          assert(!heap->is_concurrent_old_mark_in_progress(), \"Should not be running mixed collections and concurrent marking\");\n-          generation = YOUNG;\n-        } else {\n-          generation = _requested_generation;\n-        }\n+  ShenandoahHeuristics* heuristics = request.generation->heuristics();\n+  bool old_gen_evacuation_failed = _heap->old_generation()->clear_failed_evacuation();\n@@ -156,2 +167,1 @@\n-        \/\/ preemption was requested or this is a regular cycle\n-        set_gc_mode(default_mode);\n+  heuristics->log_trigger(\"Handle Allocation Failure\");\n@@ -159,4 +169,13 @@\n-        \/\/ Don't start a new old marking if there is one already in progress\n-        if (generation == OLD && heap->is_concurrent_old_mark_in_progress()) {\n-          set_gc_mode(servicing_old);\n-        }\n+  \/\/ Do not bother with degenerated cycle if old generation evacuation failed or if humongous allocation failed\n+  if (ShenandoahDegeneratedGC && heuristics->should_degenerate_cycle() &&\n+      !old_gen_evacuation_failed && request.cause != GCCause::_shenandoah_humongous_allocation_failure) {\n+    heuristics->record_allocation_failure_gc();\n+    _heap->shenandoah_policy()->record_alloc_failure_to_degenerated(_degen_point);\n+    return stw_degenerated;\n+  } else {\n+    heuristics->record_allocation_failure_gc();\n+    _heap->shenandoah_policy()->record_alloc_failure_to_full();\n+    request.generation = _heap->global_generation();\n+    return stw_full;\n+  }\n+}\n@@ -164,18 +183,5 @@\n-        if (generation == GLOBAL) {\n-          heap->set_unload_classes(global_heuristics->should_unload_classes());\n-        } else {\n-          heap->set_unload_classes(false);\n-        }\n-      } else if (heap->is_concurrent_old_mark_in_progress() || heap->is_prepare_for_old_mark_in_progress()) {\n-        \/\/ Nobody asked us to do anything, but we have an old-generation mark or old-generation preparation for\n-        \/\/ mixed evacuation in progress, so resume working on that.\n-        log_info(gc)(\"Resume old GC: marking is%s in progress, preparing is%s in progress\",\n-                     heap->is_concurrent_old_mark_in_progress() ? \"\" : \" NOT\",\n-                     heap->is_prepare_for_old_mark_in_progress() ? \"\" : \" NOT\");\n-\n-        cause = GCCause::_shenandoah_concurrent_gc;\n-        generation = OLD;\n-        set_gc_mode(servicing_old);\n-        heap->set_unload_classes(false);\n-      }\n-    }\n+ShenandoahGenerationalControlThread::GCMode ShenandoahGenerationalControlThread::prepare_for_explicit_gc(ShenandoahGCRequest &request) const {\n+  ShenandoahHeuristics* global_heuristics = _heap->global_generation()->heuristics();\n+  request.generation = _heap->global_generation();\n+  global_heuristics->log_trigger(\"GC request (%s)\", GCCause::to_string(request.cause));\n+  global_heuristics->record_requested_gc();\n@@ -183,2 +189,9 @@\n-    const bool gc_requested = (gc_mode() != none);\n-    assert (!gc_requested || cause != GCCause::_no_gc, \"GC cause should be set\");\n+  if (ShenandoahCollectorPolicy::should_run_full_gc(request.cause)) {\n+    return stw_full;;\n+  } else {\n+    \/\/ Unload and clean up everything. Note that this is an _explicit_ request and so does not use\n+    \/\/ the same `should_unload_classes` call as the regulator's concurrent gc request.\n+    _heap->set_unload_classes(global_heuristics->can_unload_classes());\n+    return concurrent_normal;\n+  }\n+}\n@@ -186,3 +199,3 @@\n-    if (gc_requested) {\n-      \/\/ Cannot uncommit bitmap slices during concurrent reset\n-      ShenandoahNoUncommitMark forbid_region_uncommit(heap);\n+ShenandoahGenerationalControlThread::GCMode ShenandoahGenerationalControlThread::prepare_for_concurrent_gc(const ShenandoahGCRequest &request) const {\n+  assert(!(request.generation->is_old() && _heap->old_generation()->is_doing_mixed_evacuations()),\n+             \"Old heuristic should not request cycles while it waits for mixed evacuations\");\n@@ -190,5 +203,6 @@\n-      \/\/ Blow away all soft references on this cycle, if handling allocation failure,\n-      \/\/ either implicit or explicit GC request, or we are requested to do so unconditionally.\n-      if (generation == GLOBAL && (alloc_failure_pending || is_gc_requested || ShenandoahAlwaysClearSoftRefs)) {\n-        heap->soft_ref_policy()->set_should_clear_all_soft_refs(true);\n-      }\n+  if (request.generation->is_global()) {\n+    ShenandoahHeuristics* global_heuristics = _heap->global_generation()->heuristics();\n+    _heap->set_unload_classes(global_heuristics->should_unload_classes());\n+  } else {\n+    _heap->set_unload_classes(false);\n+  }\n@@ -196,54 +210,3 @@\n-      \/\/ GC is starting, bump the internal ID\n-      update_gc_id();\n-\n-      heap->reset_bytes_allocated_since_gc_start();\n-\n-      MetaspaceCombinedStats meta_sizes = MetaspaceUtils::get_combined_statistics();\n-\n-      \/\/ If GC was requested, we are sampling the counters even without actual triggers\n-      \/\/ from allocation machinery. This captures GC phases more accurately.\n-      heap->set_forced_counters_update(true);\n-\n-      \/\/ If GC was requested, we better dump freeset data for performance debugging\n-      heap->free_set()->log_status_under_lock();\n-\n-      \/\/ In case this is a degenerated cycle, remember whether original cycle was aging.\n-      const bool was_aging_cycle = heap->is_aging_cycle();\n-      heap->set_aging_cycle(false);\n-\n-      switch (gc_mode()) {\n-        case concurrent_normal: {\n-          \/\/ At this point:\n-          \/\/  if (generation == YOUNG), this is a normal YOUNG cycle\n-          \/\/  if (generation == OLD), this is a bootstrap OLD cycle\n-          \/\/  if (generation == GLOBAL), this is a GLOBAL cycle triggered by System.gc()\n-          \/\/ In all three cases, we want to age old objects if this is an aging cycle\n-          if (age_period-- == 0) {\n-             heap->set_aging_cycle(true);\n-             age_period = ShenandoahAgingCyclePeriod - 1;\n-          }\n-          service_concurrent_normal_cycle(heap, generation, cause);\n-          break;\n-        }\n-        case stw_degenerated: {\n-          heap->set_aging_cycle(was_aging_cycle);\n-          service_stw_degenerated_cycle(cause, degen_point);\n-          break;\n-        }\n-        case stw_full: {\n-          if (age_period-- == 0) {\n-            heap->set_aging_cycle(true);\n-            age_period = ShenandoahAgingCyclePeriod - 1;\n-          }\n-          service_stw_full_cycle(cause);\n-          break;\n-        }\n-        case servicing_old: {\n-          assert(generation == OLD, \"Expected old generation here\");\n-          GCIdMark gc_id_mark;\n-          service_concurrent_old_cycle(heap, cause);\n-          break;\n-        }\n-        default:\n-          ShouldNotReachHere();\n-      }\n+  \/\/ preemption was requested or this is a regular cycle\n+  return request.generation->is_old() ? servicing_old : concurrent_normal;\n+}\n@@ -251,4 +214,8 @@\n-      \/\/ If this was the requested GC cycle, notify waiters about it\n-      if (is_gc_requested) {\n-        notify_gc_waiters();\n-      }\n+void ShenandoahGenerationalControlThread::maybe_set_aging_cycle() {\n+  if (_age_period-- == 0) {\n+    _heap->set_aging_cycle(true);\n+    _age_period = ShenandoahAgingCyclePeriod - 1;\n+  } else {\n+    _heap->set_aging_cycle(false);\n+  }\n+}\n@@ -256,4 +223,1 @@\n-      \/\/ If this was the allocation failure GC cycle, notify waiters about it\n-      if (alloc_failure_pending) {\n-        notify_alloc_failure_waiters();\n-      }\n+void ShenandoahGenerationalControlThread::run_gc_cycle(const ShenandoahGCRequest& request) {\n@@ -261,3 +225,2 @@\n-      \/\/ Report current free set state at the end of cycle, whether\n-      \/\/ it is a normal completion, or the abort.\n-      heap->free_set()->log_status_under_lock();\n+  log_debug(gc, thread)(\"Starting GC (%s): %s, %s\", gc_mode_name(gc_mode()), GCCause::to_string(request.cause), request.generation->name());\n+  assert(gc_mode() != none, \"GC mode cannot be none here\");\n@@ -265,7 +228,5 @@\n-      {\n-        \/\/ Notify Universe about new heap usage. This has implications for\n-        \/\/ global soft refs policy, and we better report it every time heap\n-        \/\/ usage goes down.\n-        ShenandoahHeapLocker locker(heap->lock());\n-        heap->update_capacity_and_used_at_gc();\n-      }\n+  \/\/ Blow away all soft references on this cycle, if handling allocation failure,\n+  \/\/ either implicit or explicit GC request, or we are requested to do so unconditionally.\n+  if (request.generation->is_global() && (ShenandoahCollectorPolicy::is_allocation_failure(request.cause) || ShenandoahCollectorPolicy::is_explicit_gc(request.cause) || ShenandoahAlwaysClearSoftRefs)) {\n+    _heap->soft_ref_policy()->set_should_clear_all_soft_refs(true);\n+  }\n@@ -273,2 +234,2 @@\n-      \/\/ Signal that we have completed a visit to all live objects.\n-      heap->record_whole_heap_examined_timestamp();\n+  \/\/ GC is starting, bump the internal ID\n+  update_gc_id();\n@@ -276,4 +237,1 @@\n-      \/\/ Disable forced counters update, and update counters one more time\n-      \/\/ to capture the state at the end of GC session.\n-      heap->handle_force_counters_update();\n-      heap->set_forced_counters_update(false);\n+  _heap->reset_bytes_allocated_since_gc_start();\n@@ -281,2 +239,1 @@\n-      \/\/ Retract forceful part of soft refs policy\n-      heap->soft_ref_policy()->set_should_clear_all_soft_refs(false);\n+  MetaspaceCombinedStats meta_sizes = MetaspaceUtils::get_combined_statistics();\n@@ -284,4 +241,3 @@\n-      \/\/ Clear metaspace oom flag, if current cycle unloaded classes\n-      if (heap->unload_classes()) {\n-        global_heuristics->clear_metaspace_oom();\n-      }\n+  \/\/ If GC was requested, we are sampling the counters even without actual triggers\n+  \/\/ from allocation machinery. This captures GC phases more accurately.\n+  _heap->set_forced_counters_update(true);\n@@ -289,1 +245,2 @@\n-      process_phase_timings(heap);\n+  \/\/ If GC was requested, we better dump freeset data for performance debugging\n+  _heap->free_set()->log_status_under_lock();\n@@ -291,2 +248,3 @@\n-      \/\/ Print Metaspace change following GC (if logging is enabled).\n-      MetaspaceUtils::print_metaspace_change(meta_sizes);\n+  {\n+    \/\/ Cannot uncommit bitmap slices during concurrent reset\n+    ShenandoahNoUncommitMark forbid_region_uncommit(_heap);\n@@ -294,3 +252,4 @@\n-      \/\/ GC is over, we are at idle now\n-      if (ShenandoahPacing) {\n-        heap->pacer()->setup_for_idle();\n+    switch (gc_mode()) {\n+      case concurrent_normal: {\n+        service_concurrent_normal_cycle(request);\n+        break;\n@@ -298,4 +257,3 @@\n-    } else {\n-      \/\/ Report to pacer that we have seen this many words allocated\n-      if (ShenandoahPacing && (allocs_seen > 0)) {\n-        heap->pacer()->report_alloc(allocs_seen);\n+      case stw_degenerated: {\n+        service_stw_degenerated_cycle(request);\n+        break;\n@@ -303,9 +261,9 @@\n-    }\n-\n-    \/\/ Check if we have seen a new target for soft max heap size or if a gc was requested.\n-    \/\/ Either of these conditions will attempt to uncommit regions.\n-    if (ShenandoahUncommit) {\n-      if (heap->check_soft_max_changed()) {\n-        heap->notify_soft_max_changed();\n-      } else if (is_gc_requested) {\n-        heap->notify_explicit_gc_requested();\n+      case stw_full: {\n+        service_stw_full_cycle(request.cause);\n+        break;\n+      }\n+      case servicing_old: {\n+        assert(request.generation->is_old(), \"Expected old generation here\");\n+        GCIdMark gc_id_mark;\n+        service_concurrent_old_cycle(request);\n+        break;\n@@ -313,0 +271,2 @@\n+      default:\n+        ShouldNotReachHere();\n@@ -314,0 +274,1 @@\n+  }\n@@ -315,7 +276,3 @@\n-    \/\/ Wait for ShenandoahControlIntervalMax unless there was an allocation failure or another request was made mid-cycle.\n-    if (!is_alloc_failure_gc() && _requested_gc_cause == GCCause::_no_gc) {\n-      \/\/ The timed wait is necessary because this thread has a responsibility to send\n-      \/\/ 'alloc_words' to the pacer when it does not perform a GC.\n-      MonitorLocker lock(&_control_lock, Mutex::_no_safepoint_check_flag);\n-      lock.wait(ShenandoahControlIntervalMax);\n-    }\n+  \/\/ If this was the requested GC cycle, notify waiters about it\n+  if (ShenandoahCollectorPolicy::is_explicit_gc(request.cause)) {\n+    notify_gc_waiters();\n@@ -324,1 +281,4 @@\n-  set_gc_mode(stopped);\n+  \/\/ If this cycle completed successfully, notify threads waiting to retry allocation\n+  if (!_heap->cancelled_gc()) {\n+    notify_alloc_failure_waiters();\n+  }\n@@ -326,3 +286,43 @@\n-  \/\/ Wait for the actual stop(), can't leave run_service() earlier.\n-  while (!should_terminate()) {\n-    os::naked_short_sleep(ShenandoahControlIntervalMin);\n+  \/\/ Report current free set state at the end of cycle, whether\n+  \/\/ it is a normal completion, or the abort.\n+  _heap->free_set()->log_status_under_lock();\n+\n+  \/\/ Notify Universe about new heap usage. This has implications for\n+  \/\/ global soft refs policy, and we better report it every time heap\n+  \/\/ usage goes down.\n+  _heap->update_capacity_and_used_at_gc();\n+\n+  \/\/ Signal that we have completed a visit to all live objects.\n+  _heap->record_whole_heap_examined_timestamp();\n+\n+  \/\/ Disable forced counters update, and update counters one more time\n+  \/\/ to capture the state at the end of GC session.\n+  _heap->handle_force_counters_update();\n+  _heap->set_forced_counters_update(false);\n+\n+  \/\/ Retract forceful part of soft refs policy\n+  _heap->soft_ref_policy()->set_should_clear_all_soft_refs(false);\n+\n+  \/\/ Clear metaspace oom flag, if current cycle unloaded classes\n+  if (_heap->unload_classes()) {\n+    _heap->global_generation()->heuristics()->clear_metaspace_oom();\n+  }\n+\n+  process_phase_timings();\n+\n+  \/\/ Print Metaspace change following GC (if logging is enabled).\n+  MetaspaceUtils::print_metaspace_change(meta_sizes);\n+\n+  \/\/ GC is over, we are at idle now\n+  if (ShenandoahPacing) {\n+    _heap->pacer()->setup_for_idle();\n+  }\n+\n+  \/\/ Check if we have seen a new target for soft max heap size or if a gc was requested.\n+  \/\/ Either of these conditions will attempt to uncommit regions.\n+  if (ShenandoahUncommit) {\n+    if (_heap->check_soft_max_changed()) {\n+      _heap->notify_soft_max_changed();\n+    } else if (ShenandoahCollectorPolicy::is_explicit_gc(request.cause)) {\n+      _heap->notify_explicit_gc_requested();\n+    }\n@@ -330,0 +330,3 @@\n+\n+  log_debug(gc, thread)(\"Completed GC (%s): %s, %s, cancelled: %s\",\n+    gc_mode_name(gc_mode()), GCCause::to_string(request.cause), request.generation->name(), GCCause::to_string(_heap->cancelled_cause()));\n@@ -332,1 +335,1 @@\n-void ShenandoahGenerationalControlThread::process_phase_timings(const ShenandoahGenerationalHeap* heap) {\n+void ShenandoahGenerationalControlThread::process_phase_timings() const {\n@@ -334,1 +337,1 @@\n-  heap->phase_timings()->flush_par_workers_to_cycle();\n+  _heap->phase_timings()->flush_par_workers_to_cycle();\n@@ -336,1 +339,1 @@\n-    heap->pacer()->flush_stats_to_cycle();\n+    _heap->pacer()->flush_stats_to_cycle();\n@@ -339,1 +342,1 @@\n-  ShenandoahEvacuationTracker* evac_tracker = heap->evac_tracker();\n+  ShenandoahEvacuationTracker* evac_tracker = _heap->evac_tracker();\n@@ -348,1 +351,1 @@\n-      heap->phase_timings()->print_cycle_on(&ls);\n+      _heap->phase_timings()->print_cycle_on(&ls);\n@@ -352,1 +355,1 @@\n-        heap->pacer()->print_cycle_on(&ls);\n+        _heap->pacer()->print_cycle_on(&ls);\n@@ -358,1 +361,1 @@\n-  heap->phase_timings()->flush_cycle_to_global();\n+  _heap->phase_timings()->flush_cycle_to_global();\n@@ -386,3 +389,1 @@\n-void ShenandoahGenerationalControlThread::service_concurrent_normal_cycle(ShenandoahGenerationalHeap* heap,\n-                                                                          const ShenandoahGenerationType generation,\n-                                                                          GCCause::Cause cause) {\n+void ShenandoahGenerationalControlThread::service_concurrent_normal_cycle(const ShenandoahGCRequest& request) {\n@@ -390,23 +391,5 @@\n-  switch (generation) {\n-    case YOUNG: {\n-      \/\/ Run a young cycle. This might or might not, have interrupted an ongoing\n-      \/\/ concurrent mark in the old generation. We need to think about promotions\n-      \/\/ in this case. Promoted objects should be above the TAMS in the old regions\n-      \/\/ they end up in, but we have to be sure we don't promote into any regions\n-      \/\/ that are in the cset.\n-      log_info(gc, ergo)(\"Start GC cycle (Young)\");\n-      service_concurrent_cycle(heap->young_generation(), cause, false);\n-      break;\n-    }\n-    case OLD: {\n-      log_info(gc, ergo)(\"Start GC cycle (Old)\");\n-      service_concurrent_old_cycle(heap, cause);\n-      break;\n-    }\n-    case GLOBAL: {\n-      log_info(gc, ergo)(\"Start GC cycle (Global)\");\n-      service_concurrent_cycle(heap->global_generation(), cause, false);\n-      break;\n-    }\n-    default:\n-      ShouldNotReachHere();\n+  log_info(gc, ergo)(\"Start GC cycle (%s)\", request.generation->name());\n+  if (request.generation->is_old()) {\n+    service_concurrent_old_cycle(request);\n+  } else {\n+    service_concurrent_cycle(request.generation, request.cause, false);\n@@ -416,3 +399,3 @@\n-void ShenandoahGenerationalControlThread::service_concurrent_old_cycle(ShenandoahGenerationalHeap* heap, GCCause::Cause &cause) {\n-  ShenandoahOldGeneration* old_generation = heap->old_generation();\n-  ShenandoahYoungGeneration* young_generation = heap->young_generation();\n+void ShenandoahGenerationalControlThread::service_concurrent_old_cycle(const ShenandoahGCRequest& request) {\n+  ShenandoahOldGeneration* old_generation = _heap->old_generation();\n+  ShenandoahYoungGeneration* young_generation = _heap->young_generation();\n@@ -421,1 +404,1 @@\n-  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+  TraceCollectorStats tcs(_heap->monitoring_support()->concurrent_collection_counters());\n@@ -425,1 +408,2 @@\n-      ShenandoahGCSession session(cause, old_generation);\n+      ShenandoahGCSession session(request.cause, old_generation);\n+      assert(gc_mode() == servicing_old, \"Filling should be servicing old\");\n@@ -437,1 +421,1 @@\n-        log_info(gc)(\"Preparation for old generation cycle was cancelled\");\n+        log_info(gc, thread)(\"Preparation for old generation cycle was cancelled\");\n@@ -455,4 +439,3 @@\n-      ShenandoahGCSession session(cause, young_generation);\n-      service_concurrent_cycle(heap, young_generation, cause, true);\n-      process_phase_timings(heap);\n-      if (heap->cancelled_gc()) {\n+      service_concurrent_cycle(young_generation, request.cause, true);\n+      process_phase_timings();\n+      if (_heap->cancelled_gc()) {\n@@ -465,4 +448,1 @@\n-      \/\/ Reset the degenerated point. Normally this would happen at the top\n-      \/\/ of the control loop, but here we have just completed a young cycle\n-      \/\/ which has bootstrapped the old concurrent marking.\n-      _degen_point = ShenandoahGC::_degenerated_outside_cycle;\n+      assert(_degen_point == ShenandoahGC::_degenerated_unset, \"Degen point should not be set if gc wasn't cancelled\");\n@@ -477,2 +457,2 @@\n-      ShenandoahGCSession session(cause, old_generation);\n-      bool marking_complete = resume_concurrent_old_cycle(old_generation, cause);\n+      ShenandoahGCSession session(request.cause, old_generation);\n+      bool marking_complete = resume_concurrent_old_cycle(old_generation, request.cause);\n@@ -482,2 +462,2 @@\n-          heap->mmu_tracker()->record_old_marking_increment(true);\n-          heap->log_heap_status(\"At end of Concurrent Old Marking finishing increment\");\n+          _heap->mmu_tracker()->record_old_marking_increment(true);\n+          _heap->log_heap_status(\"At end of Concurrent Old Marking finishing increment\");\n@@ -486,2 +466,2 @@\n-        heap->mmu_tracker()->record_old_marking_increment(false);\n-        heap->log_heap_status(\"At end of Concurrent Old Marking increment\");\n+        _heap->mmu_tracker()->record_old_marking_increment(false);\n+        _heap->log_heap_status(\"At end of Concurrent Old Marking increment\");\n@@ -497,1 +477,1 @@\n-  assert(ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress(), \"Old mark should be in progress\");\n+  assert(_heap->is_concurrent_old_mark_in_progress(), \"Old mark should be in progress\");\n@@ -500,2 +480,0 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n@@ -507,1 +485,1 @@\n-    heap->notify_gc_progress();\n+    _heap->notify_gc_progress();\n@@ -511,1 +489,1 @@\n-  if (heap->cancelled_gc()) {\n+  if (_heap->cancelled_gc()) {\n@@ -522,2 +500,2 @@\n-    if (_requested_gc_cause == GCCause::_shenandoah_concurrent_gc) {\n-      heap->shenandoah_policy()->record_interrupted_old();\n+    if (cause == GCCause::_shenandoah_concurrent_gc) {\n+      _heap->shenandoah_policy()->record_interrupted_old();\n@@ -530,37 +508,43 @@\n-void ShenandoahGenerationalControlThread::service_concurrent_cycle(ShenandoahGeneration* generation, GCCause::Cause cause, bool do_old_gc_bootstrap) {\n-  \/\/ Normal cycle goes via all concurrent phases. If allocation failure (af) happens during\n-  \/\/ any of the concurrent phases, it first degrades to Degenerated GC and completes GC there.\n-  \/\/ If second allocation failure happens during Degenerated GC cycle (for example, when GC\n-  \/\/ tries to evac something and no memory is available), cycle degrades to Full GC.\n-  \/\/\n-  \/\/ There are also a shortcut through the normal cycle: immediate garbage shortcut, when\n-  \/\/ heuristics says there are no regions to compact, and all the collection comes from immediately\n-  \/\/ reclaimable regions.\n-  \/\/\n-  \/\/ ................................................................................................\n-  \/\/\n-  \/\/                                    (immediate garbage shortcut)                Concurrent GC\n-  \/\/                             \/-------------------------------------------\\\n-  \/\/                             |                                           |\n-  \/\/                             |                                           |\n-  \/\/                             |                                           |\n-  \/\/                             |                                           v\n-  \/\/ [START] ----> Conc Mark ----o----> Conc Evac --o--> Conc Update-Refs ---o----> [END]\n-  \/\/                   |                    |                 |              ^\n-  \/\/                   | (af)               | (af)            | (af)         |\n-  \/\/ ..................|....................|.................|..............|.......................\n-  \/\/                   |                    |                 |              |\n-  \/\/                   |                    |                 |              |      Degenerated GC\n-  \/\/                   v                    v                 v              |\n-  \/\/               STW Mark ----------> STW Evac ----> STW Update-Refs ----->o\n-  \/\/                   |                    |                 |              ^\n-  \/\/                   | (af)               | (af)            | (af)         |\n-  \/\/ ..................|....................|.................|..............|.......................\n-  \/\/                   |                    |                 |              |\n-  \/\/                   |                    v                 |              |      Full GC\n-  \/\/                   \\------------------->o<----------------\/              |\n-  \/\/                                        |                                |\n-  \/\/                                        v                                |\n-  \/\/                                      Full GC  --------------------------\/\n-  \/\/\n-  if (check_cancellation_or_degen(ShenandoahGC::_degenerated_outside_cycle)) return;\n+\/\/ Normal cycle goes via all concurrent phases. If allocation failure (af) happens during\n+\/\/ any of the concurrent phases, it first degrades to Degenerated GC and completes GC there.\n+\/\/ If second allocation failure happens during Degenerated GC cycle (for example, when GC\n+\/\/ tries to evac something and no memory is available), cycle degrades to Full GC.\n+\/\/\n+\/\/ There are also a shortcut through the normal cycle: immediate garbage shortcut, when\n+\/\/ heuristics says there are no regions to compact, and all the collection comes from immediately\n+\/\/ reclaimable regions.\n+\/\/\n+\/\/ ................................................................................................\n+\/\/\n+\/\/                                    (immediate garbage shortcut)                Concurrent GC\n+\/\/                             \/-------------------------------------------\\\n+\/\/                             |                                           |\n+\/\/                             |                                           |\n+\/\/                             |                                           |\n+\/\/                             |                                           v\n+\/\/ [START] ----> Conc Mark ----o----> Conc Evac --o--> Conc Update-Refs ---o----> [END]\n+\/\/                   |                    |                 |              ^\n+\/\/                   | (af)               | (af)            | (af)         |\n+\/\/ ..................|....................|.................|..............|.......................\n+\/\/                   |                    |                 |              |\n+\/\/                   |                    |                 |              |      Degenerated GC\n+\/\/                   v                    v                 v              |\n+\/\/               STW Mark ----------> STW Evac ----> STW Update-Refs ----->o\n+\/\/                   |                    |                 |              ^\n+\/\/                   | (af)               | (af)            | (af)         |\n+\/\/ ..................|....................|.................|..............|.......................\n+\/\/                   |                    |                 |              |\n+\/\/                   |                    v                 |              |      Full GC\n+\/\/                   \\------------------->o<----------------\/              |\n+\/\/                                        |                                |\n+\/\/                                        v                                |\n+\/\/                                      Full GC  --------------------------\/\n+\/\/\n+void ShenandoahGenerationalControlThread::service_concurrent_cycle(ShenandoahGeneration* generation,\n+                                                                   GCCause::Cause cause,\n+                                                                   bool do_old_gc_bootstrap) {\n+  \/\/ At this point:\n+  \/\/  if (generation == YOUNG), this is a normal young cycle or a bootstrap cycle\n+  \/\/  if (generation == GLOBAL), this is a GLOBAL cycle\n+  \/\/ In either case, we want to age old objects if this is an aging cycle\n+  maybe_set_aging_cycle();\n@@ -568,1 +552,0 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -570,1 +553,1 @@\n-  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+  TraceCollectorStats tcs(_heap->monitoring_support()->concurrent_collection_counters());\n@@ -572,7 +555,0 @@\n-  service_concurrent_cycle(heap, generation, cause, do_old_gc_bootstrap);\n-}\n-\n-void ShenandoahGenerationalControlThread::service_concurrent_cycle(ShenandoahHeap* heap,\n-                                                       ShenandoahGeneration* generation,\n-                                                       GCCause::Cause& cause,\n-                                                       bool do_old_gc_bootstrap) {\n@@ -584,1 +560,1 @@\n-    heap->notify_gc_progress();\n+    _heap->notify_gc_progress();\n@@ -587,1 +563,1 @@\n-    assert(heap->cancelled_gc(), \"Must have been cancelled\");\n+    assert(_heap->cancelled_gc(), \"Must have been cancelled\");\n@@ -589,4 +565,0 @@\n-\n-    \/\/ Concurrent young-gen collection degenerates to young\n-    \/\/ collection.  Same for global collections.\n-    _degen_generation = generation;\n@@ -594,0 +566,1 @@\n+\n@@ -595,1 +568,1 @@\n-  ShenandoahMmuTracker* mmu_tracker = heap->mmu_tracker();\n+  ShenandoahMmuTracker* mmu_tracker = _heap->mmu_tracker();\n@@ -597,1 +570,1 @@\n-    if (heap->cancelled_gc()) {\n+    if (_heap->cancelled_gc()) {\n@@ -604,1 +577,1 @@\n-      if (heap->collection_set()->has_old_regions()) {\n+      if (_heap->collection_set()->has_old_regions()) {\n@@ -615,1 +588,1 @@\n-    if (heap->cancelled_gc()) {\n+    if (_heap->cancelled_gc()) {\n@@ -623,1 +596,1 @@\n-  heap->log_heap_status(msg);\n+  _heap->log_heap_status(msg);\n@@ -627,2 +600,1 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  if (!heap->cancelled_gc()) {\n+  if (!_heap->cancelled_gc()) {\n@@ -632,10 +604,3 @@\n-  if (in_graceful_shutdown()) {\n-    return true;\n-  }\n-\n-  assert(_degen_point == ShenandoahGC::_degenerated_outside_cycle,\n-         \"Should not be set yet: %s\", ShenandoahGC::degen_point_to_string(_degen_point));\n-\n-  if (is_alloc_failure_gc()) {\n-    _degen_point = point;\n-    _preemption_requested.unset();\n+  if (_heap->cancelled_cause() == GCCause::_shenandoah_stop_vm\n+    || _heap->cancelled_cause() == GCCause::_shenandoah_concurrent_gc) {\n+    log_debug(gc, thread)(\"Cancellation detected, reason: %s\", GCCause::to_string(_heap->cancelled_cause()));\n@@ -645,9 +610,3 @@\n-  if (_preemption_requested.is_set()) {\n-    assert(_requested_generation == YOUNG, \"Only young GCs may preempt old.\");\n-    _preemption_requested.unset();\n-\n-    \/\/ Old generation marking is only cancellable during concurrent marking.\n-    \/\/ Once final mark is complete, the code does not check again for cancellation.\n-    \/\/ If old generation was cancelled for an allocation failure, we wouldn't\n-    \/\/ make it to this case. The calling code is responsible for forcing a\n-    \/\/ cancellation due to allocation failure into a degenerated cycle.\n+  if (ShenandoahCollectorPolicy::is_allocation_failure(_heap->cancelled_cause())) {\n+    assert(_degen_point == ShenandoahGC::_degenerated_unset,\n+           \"Should not be set yet: %s\", ShenandoahGC::degen_point_to_string(_degen_point));\n@@ -655,1 +614,3 @@\n-    heap->clear_cancelled_gc(false \/* clear oom handler *\/);\n+    log_debug(gc, thread)(\"Cancellation detected:, reason: %s, degen point: %s\",\n+                          GCCause::to_string(_heap->cancelled_cause()),\n+                          ShenandoahGC::degen_point_to_string(_degen_point));\n@@ -663,4 +624,0 @@\n-void ShenandoahGenerationalControlThread::stop_service() {\n-  \/\/ Nothing to do here.\n-}\n-\n@@ -668,2 +625,0 @@\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n-\n@@ -671,2 +626,2 @@\n-  ShenandoahGCSession session(cause, heap->global_generation());\n-\n+  ShenandoahGCSession session(cause, _heap->global_generation());\n+  maybe_set_aging_cycle();\n@@ -675,0 +630,1 @@\n+  _degen_point = ShenandoahGC::_degenerated_unset;\n@@ -677,4 +633,2 @@\n-void ShenandoahGenerationalControlThread::service_stw_degenerated_cycle(GCCause::Cause cause,\n-                                                            ShenandoahGC::ShenandoahDegenPoint point) {\n-  assert(point != ShenandoahGC::_degenerated_unset, \"Degenerated point should be set\");\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+void ShenandoahGenerationalControlThread::service_stw_degenerated_cycle(const ShenandoahGCRequest& request) {\n+  assert(_degen_point != ShenandoahGC::_degenerated_unset, \"Degenerated point should be set\");\n@@ -683,1 +637,1 @@\n-  ShenandoahGCSession session(cause, _degen_generation);\n+  ShenandoahGCSession session(request.cause, request.generation);\n@@ -685,2 +639,3 @@\n-  ShenandoahDegenGC gc(point, _degen_generation);\n-  gc.collect(cause);\n+  ShenandoahDegenGC gc(_degen_point, request.generation);\n+  gc.collect(request.cause);\n+  _degen_point = ShenandoahGC::_degenerated_unset;\n@@ -688,4 +643,4 @@\n-  assert(heap->young_generation()->task_queues()->is_empty(), \"Unexpected young generation marking tasks\");\n-  if (_degen_generation->is_global()) {\n-    assert(heap->old_generation()->task_queues()->is_empty(), \"Unexpected old generation marking tasks\");\n-    assert(heap->global_generation()->task_queues()->is_empty(), \"Unexpected global generation marking tasks\");\n+  assert(_heap->young_generation()->task_queues()->is_empty(), \"Unexpected young generation marking tasks\");\n+  if (request.generation->is_global()) {\n+    assert(_heap->old_generation()->task_queues()->is_empty(), \"Unexpected old generation marking tasks\");\n+    assert(_heap->global_generation()->task_queues()->is_empty(), \"Unexpected global generation marking tasks\");\n@@ -693,2 +648,2 @@\n-    assert(_degen_generation->is_young(), \"Expected degenerated young cycle, if not global.\");\n-    ShenandoahOldGeneration* old = heap->old_generation();\n+    assert(request.generation->is_young(), \"Expected degenerated young cycle, if not global.\");\n+    ShenandoahOldGeneration* old = _heap->old_generation();\n@@ -702,1 +657,5 @@\n-  if (ShenandoahCollectorPolicy::should_handle_requested_gc(cause)) {\n+  if (ShenandoahCollectorPolicy::is_allocation_failure(cause)) {\n+    \/\/ GC should already be cancelled. Here we are just notifying the control thread to\n+    \/\/ wake up and handle the cancellation request, so we don't need to set _requested_gc_cause.\n+    notify_cancellation(cause);\n+  } else if (ShenandoahCollectorPolicy::should_handle_requested_gc(cause)) {\n@@ -707,2 +666,2 @@\n-bool ShenandoahGenerationalControlThread::request_concurrent_gc(ShenandoahGenerationType generation) {\n-  if (_preemption_requested.is_set() || _requested_gc_cause != GCCause::_no_gc || ShenandoahHeap::heap()->cancelled_gc()) {\n+bool ShenandoahGenerationalControlThread::request_concurrent_gc(ShenandoahGeneration* generation) {\n+  if (_heap->cancelled_gc()) {\n@@ -710,2 +669,1 @@\n-    log_debug(gc, thread)(\"Reject request for concurrent gc: preemption_requested: %s, gc_requested: %s, gc_cancelled: %s\",\n-                          BOOL_TO_STR(_preemption_requested.is_set()),\n+    log_debug(gc, thread)(\"Reject request for concurrent gc: gc_requested: %s, gc_cancelled: %s\",\n@@ -713,1 +671,1 @@\n-                          BOOL_TO_STR(ShenandoahHeap::heap()->cancelled_gc()));\n+                          BOOL_TO_STR(_heap->cancelled_gc()));\n@@ -717,4 +675,4 @@\n-  if (gc_mode() == none) {\n-    GCCause::Cause existing = Atomic::cmpxchg(&_requested_gc_cause, GCCause::_no_gc, GCCause::_shenandoah_concurrent_gc);\n-    if (existing != GCCause::_no_gc) {\n-      log_debug(gc, thread)(\"Reject request for concurrent gc because another gc is pending: %s\", GCCause::to_string(existing));\n+  MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n+  if (gc_mode() == servicing_old) {\n+    if (!preempt_old_marking(generation)) {\n+      log_debug(gc, thread)(\"Cannot start young, old collection is not preemptible\");\n@@ -724,5 +682,5 @@\n-    _requested_generation = generation;\n-    notify_control_thread();\n-\n-    MonitorLocker ml(&_regulator_lock, Mutex::_no_safepoint_check_flag);\n-    while (gc_mode() == none) {\n+    \/\/ Cancel the old GC and wait for the control thread to start servicing the new request.\n+    log_info(gc)(\"Preempting old generation mark to allow %s GC\", generation->name());\n+    while (gc_mode() == servicing_old) {\n+      ShenandoahHeap::heap()->cancel_gc(GCCause::_shenandoah_concurrent_gc);\n+      notify_cancellation(ml, GCCause::_shenandoah_concurrent_gc);\n@@ -734,13 +692,7 @@\n-  if (preempt_old_marking(generation)) {\n-    assert(gc_mode() == servicing_old, \"Expected to be servicing old, but was: %s.\", gc_mode_name(gc_mode()));\n-    GCCause::Cause existing = Atomic::cmpxchg(&_requested_gc_cause, GCCause::_no_gc, GCCause::_shenandoah_concurrent_gc);\n-    if (existing != GCCause::_no_gc) {\n-      log_debug(gc, thread)(\"Reject request to interrupt old gc because another gc is pending: %s\", GCCause::to_string(existing));\n-      return false;\n-    }\n-\n-    log_info(gc)(\"Preempting old generation mark to allow %s GC\", shenandoah_generation_name(generation));\n-    _requested_generation = generation;\n-    _preemption_requested.set();\n-    ShenandoahHeap::heap()->cancel_gc(GCCause::_shenandoah_concurrent_gc);\n-    notify_control_thread();\n+  if (gc_mode() == none) {\n+    const size_t current_gc_id = get_gc_id();\n+    while (gc_mode() == none && current_gc_id == get_gc_id()) {\n+      if (_requested_gc_cause != GCCause::_no_gc) {\n+        log_debug(gc, thread)(\"Reject request for concurrent gc because another gc is pending: %s\", GCCause::to_string(_requested_gc_cause));\n+        return false;\n+      }\n@@ -748,2 +700,1 @@\n-    MonitorLocker ml(&_regulator_lock, Mutex::_no_safepoint_check_flag);\n-    while (gc_mode() == servicing_old) {\n+      notify_control_thread(ml, GCCause::_shenandoah_concurrent_gc, generation);\n@@ -755,0 +706,1 @@\n+\n@@ -761,3 +713,22 @@\n-void ShenandoahGenerationalControlThread::notify_control_thread() {\n-  MonitorLocker locker(&_control_lock, Mutex::_no_safepoint_check_flag);\n-  _control_lock.notify();\n+void ShenandoahGenerationalControlThread::notify_control_thread(GCCause::Cause cause, ShenandoahGeneration* generation) {\n+  MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n+  notify_control_thread(ml, cause, generation);\n+}\n+\n+void ShenandoahGenerationalControlThread::notify_control_thread(MonitorLocker& ml, GCCause::Cause cause, ShenandoahGeneration* generation) {\n+  assert(_control_lock.is_locked(), \"Request lock must be held here\");\n+  log_debug(gc, thread)(\"Notify control (%s): %s, %s\", gc_mode_name(gc_mode()), GCCause::to_string(cause), generation->name());\n+  _requested_gc_cause = cause;\n+  _requested_generation = generation;\n+  ml.notify();\n+}\n+\n+void ShenandoahGenerationalControlThread::notify_cancellation(GCCause::Cause cause) {\n+  MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n+  notify_cancellation(ml, cause);\n+}\n+\n+void ShenandoahGenerationalControlThread::notify_cancellation(MonitorLocker& ml, GCCause::Cause cause) {\n+  assert(_heap->cancelled_gc(), \"GC should already be cancelled\");\n+  log_debug(gc,thread)(\"Notify control (%s): %s\", gc_mode_name(gc_mode()), GCCause::to_string(cause));\n+  ml.notify();\n@@ -766,2 +737,2 @@\n-bool ShenandoahGenerationalControlThread::preempt_old_marking(ShenandoahGenerationType generation) {\n-  return (generation == YOUNG) && _allow_old_preemption.try_unset();\n+bool ShenandoahGenerationalControlThread::preempt_old_marking(ShenandoahGeneration* generation) {\n+  return generation->is_young() && _allow_old_preemption.try_unset();\n@@ -776,2 +747,1 @@\n-    Atomic::xchg(&_requested_gc_cause, cause);\n-    notify_control_thread();\n+    notify_control_thread(cause, ShenandoahHeap::heap()->global_generation());\n@@ -792,11 +762,4 @@\n-  size_t required_gc_id = current_gc_id + 1;\n-  while (current_gc_id < required_gc_id) {\n-    \/\/ This races with the regulator thread to start a concurrent gc and the\n-    \/\/ control thread to clear it at the start of a cycle. Threads here are\n-    \/\/ allowed to escalate a heuristic's request for concurrent gc.\n-    GCCause::Cause existing = Atomic::xchg(&_requested_gc_cause, cause);\n-    if (existing != GCCause::_no_gc) {\n-      log_debug(gc, thread)(\"GC request supersedes existing request: %s\", GCCause::to_string(existing));\n-    }\n-\n-    notify_control_thread();\n+  const size_t required_gc_id = current_gc_id + 1;\n+  while (current_gc_id < required_gc_id && !should_terminate()) {\n+    \/\/ Make requests to run a global cycle until at least one is completed\n+    notify_control_thread(cause, ShenandoahHeap::heap()->global_generation());\n@@ -813,1 +776,1 @@\n-const char* ShenandoahGenerationalControlThread::gc_mode_name(ShenandoahGenerationalControlThread::GCMode mode) {\n+const char* ShenandoahGenerationalControlThread::gc_mode_name(GCMode mode) {\n@@ -826,5 +789,10 @@\n-void ShenandoahGenerationalControlThread::set_gc_mode(ShenandoahGenerationalControlThread::GCMode new_mode) {\n-  if (_mode != new_mode) {\n-    log_debug(gc)(\"Transition from: %s to: %s\", gc_mode_name(_mode), gc_mode_name(new_mode));\n-    MonitorLocker ml(&_regulator_lock, Mutex::_no_safepoint_check_flag);\n-    _mode = new_mode;\n+void ShenandoahGenerationalControlThread::set_gc_mode(GCMode new_mode) {\n+  MonitorLocker ml(&_control_lock, Mutex::_no_safepoint_check_flag);\n+  set_gc_mode(ml, new_mode);\n+}\n+\n+void ShenandoahGenerationalControlThread::set_gc_mode(MonitorLocker& ml, GCMode new_mode) {\n+  if (_gc_mode != new_mode) {\n+    log_debug(gc, thread)(\"Transition from: %s to: %s\", gc_mode_name(_gc_mode), gc_mode_name(new_mode));\n+    EventMark event(\"Control thread transition from: %s, to %s\", gc_mode_name(_gc_mode), gc_mode_name(new_mode));\n+    _gc_mode = new_mode;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":412,"deletions":444,"binary":false,"changes":856,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"gc\/shenandoah\/shenandoahGenerationType.hpp\"\n@@ -33,1 +32,0 @@\n-#include \"gc\/shenandoah\/shenandoahPadding.hpp\"\n@@ -35,0 +33,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -55,0 +54,7 @@\n+  class ShenandoahGCRequest {\n+  public:\n+    ShenandoahGCRequest() : generation(nullptr), cause(GCCause::_no_gc) {}\n+    ShenandoahGeneration* generation;\n+    GCCause::Cause cause;\n+  };\n+\n@@ -56,0 +62,2 @@\n+  \/\/ This lock is used to coordinate setting the _requested_gc_cause, _requested generation\n+  \/\/ and _gc_mode. It is important that these be changed together and have a consistent view.\n@@ -57,4 +65,0 @@\n-  Monitor _regulator_lock;\n-\n-  ShenandoahSharedFlag _allow_old_preemption;\n-  ShenandoahSharedFlag _preemption_requested;\n@@ -62,0 +66,2 @@\n+  \/\/ Represents a normal (non cancellation) gc request. This can be set by mutators (System.gc,\n+  \/\/ whitebox gc, etc.) or by the regulator thread when the heuristics want to start a cycle.\n@@ -63,1 +69,11 @@\n-  volatile ShenandoahGenerationType _requested_generation;\n+\n+  \/\/ This is the generation the request should operate on.\n+  ShenandoahGeneration* _requested_generation;\n+\n+  \/\/ The mode is read frequently by requesting threads and only ever written by the control thread.\n+  \/\/ This may be read without taking the _control_lock, but should be read again under the lock\n+  \/\/ before making any state changes (double-checked locking idiom).\n+  volatile GCMode _gc_mode;\n+\n+  \/\/ Only the control thread knows the correct degeneration point. This is used to have the\n+  \/\/ control thread resume a STW cycle from the point where the concurrent cycle was cancelled.\n@@ -65,1 +81,0 @@\n-  ShenandoahGeneration* _degen_generation;\n@@ -67,3 +82,9 @@\n-  shenandoah_padding(0);\n-  volatile GCMode _mode;\n-  shenandoah_padding(1);\n+  \/\/ A reference to the heap\n+  ShenandoahGenerationalHeap* _heap;\n+\n+  \/\/ This is used to keep track of whether to age objects during the current cycle.\n+  uint _age_period;\n+\n+  \/\/ This is true when the old generation cycle is in an interruptible phase (i.e., marking or\n+  \/\/ preparing for mark).\n+  ShenandoahSharedFlag _allow_old_preemption;\n@@ -80,1 +101,1 @@\n-  bool request_concurrent_gc(ShenandoahGenerationType generation);\n+  bool request_concurrent_gc(ShenandoahGeneration* generation);\n@@ -82,2 +103,3 @@\n-  GCMode gc_mode() {\n-    return _mode;\n+  \/\/ Returns the current state of the control thread\n+  GCMode gc_mode() const {\n+    return _gc_mode;\n@@ -86,1 +108,0 @@\n-\n@@ -90,0 +111,3 @@\n+  \/\/ Executes one GC cycle\n+  void run_gc_cycle(const ShenandoahGCRequest& request);\n+\n@@ -92,0 +116,2 @@\n+\n+  \/\/ Various service methods handle different gc cycle types\n@@ -94,1 +120,3 @@\n-  void service_stw_degenerated_cycle(GCCause::Cause cause, ShenandoahGC::ShenandoahDegenPoint point);\n+  void service_stw_degenerated_cycle(const ShenandoahGCRequest& request);\n+  void service_concurrent_normal_cycle(const ShenandoahGCRequest& request);\n+  void service_concurrent_old_cycle(const ShenandoahGCRequest& request);\n@@ -98,2 +126,1 @@\n-  \/\/ Handle GC request.\n-  \/\/ Blocks until GC is over.\n+  \/\/ Blocks until at least one global GC cycle is complete.\n@@ -102,3 +129,0 @@\n-  bool is_explicit_gc(GCCause::Cause cause) const;\n-  bool is_implicit_gc(GCCause::Cause cause) const;\n-\n@@ -106,1 +130,1 @@\n-  bool preempt_old_marking(ShenandoahGenerationType generation);\n+  bool preempt_old_marking(ShenandoahGeneration* generation);\n@@ -108,8 +132,2 @@\n-  void process_phase_timings(const ShenandoahGenerationalHeap* heap);\n-\n-  void service_concurrent_normal_cycle(ShenandoahGenerationalHeap* heap,\n-                                       ShenandoahGenerationType generation,\n-                                       GCCause::Cause cause);\n-\n-  void service_concurrent_old_cycle(ShenandoahGenerationalHeap* heap,\n-                                    GCCause::Cause &cause);\n+  \/\/ Flushes cycle timings to global timings and prints the phase timings for the last completed cycle.\n+  void process_phase_timings() const;\n@@ -117,0 +135,2 @@\n+  \/\/ Set the gc mode and post a notification if it has changed. The overloaded variant should be used\n+  \/\/ when the _control_lock is already held.\n@@ -118,0 +138,1 @@\n+  void set_gc_mode(MonitorLocker& ml, GCMode new_mode);\n@@ -119,0 +140,1 @@\n+  \/\/ Return printable name for the given gc mode.\n@@ -121,1 +143,12 @@\n-  void notify_control_thread();\n+  \/\/ Takes the request lock and updates the requested cause and generation, then notifies the control thread.\n+  \/\/ The overloaded variant should be used when the _control_lock is already held.\n+  void notify_control_thread(GCCause::Cause cause, ShenandoahGeneration* generation);\n+  void notify_control_thread(MonitorLocker& ml, GCCause::Cause cause, ShenandoahGeneration* generation);\n+\n+  \/\/ Notifies the control thread, but does not update the requested cause or generation.\n+  \/\/ The overloaded variant should be used when the _control_lock is already held.\n+  void notify_cancellation(GCCause::Cause cause);\n+  void notify_cancellation(MonitorLocker& ml, GCCause::Cause cause);\n+\n+  \/\/ Configure the heap to age objects and regions if the aging period has elapsed.\n+  void maybe_set_aging_cycle();\n@@ -123,4 +156,3 @@\n-  void service_concurrent_cycle(ShenandoahHeap* heap,\n-                                ShenandoahGeneration* generation,\n-                                GCCause::Cause &cause,\n-                                bool do_old_gc_bootstrap);\n+  \/\/ Take the _control_lock and check for a request to run a gc cycle. If a request is found,\n+  \/\/ the `prepare` methods are used to configure the heap and update heuristics accordingly.\n+  void check_for_request(ShenandoahGCRequest& request);\n@@ -128,0 +160,3 @@\n+  GCMode prepare_for_allocation_failure_gc(ShenandoahGCRequest &request);\n+  GCMode prepare_for_explicit_gc(ShenandoahGCRequest &request) const;\n+  GCMode prepare_for_concurrent_gc(const ShenandoahGCRequest &request) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.hpp","additions":70,"deletions":35,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -559,0 +559,1 @@\n+  _cancelled_gc.set(GCCause::_no_gc);\n@@ -954,2 +955,2 @@\n-      size_t original_count = shenandoah_policy()->full_gc_count();\n-      while ((result == nullptr) && (original_count == shenandoah_policy()->full_gc_count())) {\n+      const size_t original_count = shenandoah_policy()->full_gc_count();\n+      while (result == nullptr && should_retry_allocation(original_count)) {\n@@ -960,1 +961,1 @@\n-        \/\/ If our allocation request has been satisifed after it initially failed, we count this as good gc progress\n+        \/\/ If our allocation request has been satisfied after it initially failed, we count this as good gc progress\n@@ -1011,0 +1012,5 @@\n+inline bool ShenandoahHeap::should_retry_allocation(size_t original_full_gc_count) const {\n+  return shenandoah_policy()->full_gc_count() == original_full_gc_count\n+      && !shenandoah_policy()->is_at_shutdown();\n+}\n+\n@@ -2081,3 +2087,3 @@\n-bool ShenandoahHeap::try_cancel_gc() {\n-  jbyte prev = _cancelled_gc.cmpxchg(CANCELLED, CANCELLABLE);\n-  return prev == CANCELLABLE;\n+bool ShenandoahHeap::try_cancel_gc(GCCause::Cause cause) {\n+  const GCCause::Cause prev = _cancelled_gc.xchg(cause);\n+  return prev == GCCause::_no_gc || prev == GCCause::_shenandoah_concurrent_gc;\n@@ -2097,2 +2103,2 @@\n-void ShenandoahHeap::cancel_gc(GCCause::Cause cause) {\n-  if (try_cancel_gc()) {\n+bool ShenandoahHeap::cancel_gc(GCCause::Cause cause) {\n+  if (try_cancel_gc(cause)) {\n@@ -2100,1 +2106,1 @@\n-    log_info(gc)(\"%s\", msg.buffer());\n+    log_info(gc,thread)(\"%s\", msg.buffer());\n@@ -2103,0 +2109,1 @@\n+    return true;\n@@ -2104,0 +2111,1 @@\n+  return false;\n@@ -2116,1 +2124,1 @@\n-  \/\/ Step 0a. Stop reporting on gc thread cpu utilization\n+  \/\/ Step 1. Stop reporting on gc thread cpu utilization\n@@ -2119,9 +2127,1 @@\n-  \/\/ Step 1. Notify control thread that we are in shutdown.\n-  \/\/ Note that we cannot do that with stop(), because stop() is blocking and waits for the actual shutdown.\n-  \/\/ Doing stop() here would wait for the normal GC cycle to complete, never falling through to cancel below.\n-  control_thread()->prepare_for_graceful_shutdown();\n-\n-  \/\/ Step 2. Notify GC workers that we are cancelling GC.\n-  cancel_gc(GCCause::_shenandoah_stop_vm);\n-\n-  \/\/ Step 3. Wait until GC worker exits normally.\n+  \/\/ Step 2. Wait until GC worker exits normally (this will cancel any ongoing GC).\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -433,10 +433,2 @@\n-  enum CancelState {\n-    \/\/ Normal state. GC has not been cancelled and is open for cancellation.\n-    \/\/ Worker threads can suspend for safepoint.\n-    CANCELLABLE,\n-\n-    \/\/ GC has been cancelled. Worker threads can not suspend for\n-    \/\/ safepoint but must finish their work as soon as possible.\n-    CANCELLED\n-  };\n-\n+  \/\/ Records the time of the first successful cancellation request. This is used to measure\n+  \/\/ the responsiveness of the heuristic when starting a cycle.\n@@ -444,1 +436,3 @@\n-  ShenandoahSharedEnumFlag<CancelState> _cancelled_gc;\n+\n+  \/\/ Indicates the reason the current GC has been cancelled (GCCause::_no_gc means the gc is not cancelled).\n+  ShenandoahSharedEnumFlag<GCCause::Cause> _cancelled_gc;\n@@ -450,1 +444,1 @@\n-  bool try_cancel_gc();\n+  bool try_cancel_gc(GCCause::Cause cause);\n@@ -453,0 +447,1 @@\n+  \/\/ True if gc has been cancelled\n@@ -454,0 +449,2 @@\n+\n+  \/\/ Used by workers in the GC cycle to detect cancellation and honor STS requirements\n@@ -456,0 +453,5 @@\n+  \/\/ This indicates the reason the last GC cycle was cancelled.\n+  inline GCCause::Cause cancelled_cause() const;\n+\n+  \/\/ Clears the cancellation cause and optionally resets the oom handler (cancelling an\n+  \/\/ old mark does _not_ touch the oom handler).\n@@ -459,1 +461,0 @@\n-  void cancel_gc(GCCause::Cause cause);\n@@ -461,1 +462,3 @@\n-public:\n+  \/\/ Returns true if and only if this call caused a gc to be cancelled.\n+  bool cancel_gc(GCCause::Cause cause);\n+\n@@ -693,0 +696,3 @@\n+  \/\/ We want to retry an unsuccessful attempt at allocation until at least a full gc.\n+  bool should_retry_allocation(size_t original_full_gc_count) const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":20,"deletions":14,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -254,1 +254,1 @@\n-  return _cancelled_gc.get() == CANCELLED;\n+  return _cancelled_gc.get() != GCCause::_no_gc;\n@@ -266,0 +266,4 @@\n+inline GCCause::Cause ShenandoahHeap::cancelled_cause() const {\n+  return _cancelled_gc.get();\n+}\n+\n@@ -267,1 +271,1 @@\n-  _cancelled_gc.set(CANCELLABLE);\n+  _cancelled_gc.set(GCCause::_no_gc);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -500,1 +500,1 @@\n-    log_debug(gc)(\"Old generation transition from %s to %s\", state_name(_state), state_name(new_state));\n+    log_debug(gc, thread)(\"Old generation transition from %s to %s\", state_name(_state), state_name(new_state));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  ConcurrentGCThread(),\n+  _heap(ShenandoahHeap::heap()),\n@@ -42,4 +42,3 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  _old_heuristics = heap->old_generation()->heuristics();\n-  _young_heuristics = heap->young_generation()->heuristics();\n-  _global_heuristics = heap->global_generation()->heuristics();\n+  _old_heuristics = _heap->old_generation()->heuristics();\n+  _young_heuristics = _heap->young_generation()->heuristics();\n+  _global_heuristics = _heap->global_generation()->heuristics();\n@@ -66,1 +65,1 @@\n-        if (request_concurrent_gc(GLOBAL)) {\n+        if (request_concurrent_gc(_heap->global_generation())) {\n@@ -79,1 +78,1 @@\n-          } else if (request_concurrent_gc(YOUNG)) {\n+          } else if (request_concurrent_gc(_heap->young_generation())) {\n@@ -83,0 +82,5 @@\n+        } else if (_old_heuristics->should_resume_old_cycle() || _old_heuristics->should_start_gc()) {\n+          if (request_concurrent_gc(_heap->old_generation())) {\n+            _old_heuristics->cancel_trigger_request();\n+            log_debug(gc)(\"Heuristics request to resume old collection accepted\");\n+          }\n@@ -136,2 +140,2 @@\n-bool ShenandoahRegulatorThread::start_old_cycle() {\n-  return _old_heuristics->should_start_gc() && request_concurrent_gc(OLD);\n+bool ShenandoahRegulatorThread::start_old_cycle() const {\n+  return _old_heuristics->should_start_gc() && request_concurrent_gc(_heap->old_generation());\n@@ -140,2 +144,2 @@\n-bool ShenandoahRegulatorThread::start_young_cycle() {\n-  return _young_heuristics->should_start_gc() && request_concurrent_gc(YOUNG);\n+bool ShenandoahRegulatorThread::start_young_cycle() const {\n+  return _young_heuristics->should_start_gc() && request_concurrent_gc(_heap->young_generation());\n@@ -144,2 +148,2 @@\n-bool ShenandoahRegulatorThread::start_global_cycle() {\n-  return _global_heuristics->should_start_gc() && request_concurrent_gc(GLOBAL);\n+bool ShenandoahRegulatorThread::start_global_cycle() const {\n+  return _global_heuristics->should_start_gc() && request_concurrent_gc(_heap->global_generation());\n@@ -148,1 +152,1 @@\n-bool ShenandoahRegulatorThread::request_concurrent_gc(ShenandoahGenerationType generation) {\n+bool ShenandoahRegulatorThread::request_concurrent_gc(ShenandoahGeneration* generation) const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+class ShenandoahHeap;\n@@ -30,0 +31,1 @@\n+class ShenandoahGeneration;\n@@ -31,0 +33,1 @@\n+class ShenandoahOldHeuristics;\n@@ -61,3 +64,4 @@\n-  bool start_old_cycle();\n-  bool start_young_cycle();\n-  bool start_global_cycle();\n+  bool start_old_cycle() const;\n+  bool start_young_cycle() const;\n+  bool start_global_cycle() const;\n+  bool resume_old_cycle();\n@@ -73,1 +77,1 @@\n-  bool request_concurrent_gc(ShenandoahGenerationType generation);\n+  bool request_concurrent_gc(ShenandoahGeneration* generation) const;\n@@ -75,0 +79,1 @@\n+  ShenandoahHeap* _heap;\n@@ -77,1 +82,1 @@\n-  ShenandoahHeuristics* _old_heuristics;\n+  ShenandoahOldHeuristics* _old_heuristics;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.hpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -480,1 +480,1 @@\n-  log_info(gc, remset)(\"Scan remembered set using bitmap: %s\", BOOL_TO_STR(old_bitmap_stable));\n+  log_debug(gc, remset)(\"Scan remembered set using bitmap: %s\", BOOL_TO_STR(old_bitmap_stable));\n@@ -658,1 +658,1 @@\n-  log_info(gc, remset)(\"Scan remembered set using bitmap: %s\", BOOL_TO_STR(old_bitmap_stable));\n+  log_debug(gc, remset)(\"Scan remembered set using bitmap: %s\", BOOL_TO_STR(old_bitmap_stable));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -215,0 +215,1 @@\n+  typedef uint32_t EnumValueType;\n@@ -216,1 +217,1 @@\n-  volatile ShenandoahSharedValue value;\n+  volatile EnumValueType value;\n@@ -225,2 +226,2 @@\n-    assert (v < (sizeof(ShenandoahSharedValue) * CHAR_MAX), \"sanity\");\n-    Atomic::release_store_fence(&value, (ShenandoahSharedValue)v);\n+    assert (v < (sizeof(EnumValueType) * CHAR_MAX), \"sanity\");\n+    Atomic::release_store_fence(&value, (EnumValueType)v);\n@@ -235,2 +236,2 @@\n-    assert (new_value < (sizeof(ShenandoahSharedValue) * CHAR_MAX), \"sanity\");\n-    return (T)Atomic::cmpxchg(&value, (ShenandoahSharedValue)expected, (ShenandoahSharedValue)new_value);\n+    assert (new_value < (sizeof(EnumValueType) * CHAR_MAX), \"sanity\");\n+    return (T)Atomic::cmpxchg(&value, (EnumValueType)expected, (EnumValueType)new_value);\n@@ -239,1 +240,7 @@\n-  volatile ShenandoahSharedValue* addr_of() {\n+  T xchg(T new_value) {\n+    assert (new_value >= 0, \"sanity\");\n+    assert (new_value < (sizeof(EnumValueType) * CHAR_MAX), \"sanity\");\n+    return (T)Atomic::xchg(&value, (EnumValueType)new_value);\n+  }\n+\n+  volatile EnumValueType* addr_of() {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSharedVariables.hpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"}]}