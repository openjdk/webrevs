{"files":[{"patch":"@@ -328,1 +328,1 @@\n-    \/\/ Cycle is complete\n+    \/\/ Cycle is complete.  There were no failed allocation requests and no degeneration, so count this as good progress.\n@@ -330,1 +330,1 @@\n-    heap->global_generation()->heuristics()->record_success_concurrent(gc.abbreviated());\n+    heap->global_generation()->heuristics()->record_success_concurrent();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -997,30 +997,0 @@\n-    \/\/ Block until control thread reacted, then retry allocation.\n-    \/\/\n-    \/\/ It might happen that one of the threads requesting allocation would unblock\n-    \/\/ way later after GC happened, only to fail the second allocation, because\n-    \/\/ other threads have already depleted the free storage. In this case, a better\n-    \/\/ strategy is to try again, as long as GC makes progress (or until at least\n-    \/\/ one full GC has completed).\n-\n-    size_t original_count = shenandoah_policy()->full_gc_count();\n-\n-    \/\/ Stop retrying and return nullptr to cause OOMError exception if our allocation failed even after:\n-    \/\/   a) We experienced a GC that had good progress, or\n-    \/\/   b) We experienced at least one Full GC (whether or not it had good progress)\n-    \/\/\n-    \/\/ TODO: Rather than require a Full GC before throwing OOMError, it might be more appropriate for handle_alloc_failure()\n-    \/\/       to trigger a concurrent GLOBAL GC, and throw OOMError if we cannot allocate even after GLOBAL GC has finished.\n-    \/\/       There is no \"perfect\" solution here:\n-    \/\/\n-    \/\/        1. As currently implemented, there may be a race between multiple allocating threads, both attempting\n-    \/\/           to allocate very large objects.  The first thread to retry its allocation might succeed and the second\n-    \/\/           thread to retry its allocation might fail (because the first thread consumed the newly available memory).\n-    \/\/           So the second thread experiences OOMError even through another GC would have reclaimed the memory it wanted\n-    \/\/           to allocate.\n-    \/\/        2. A GLOBAL GC won't necessarily reclaim all garbage.  Following a concurrent Generational GLOBAL GC, we may\n-    \/\/           need to perform multiple concurrent mixed evacuations in order to reclaim all of the dead memory identified\n-    \/\/           by the GLOBAL GC mark.  However, the first evacuation performed by the GLOBAL GC will normally reclaim\n-    \/\/           a significant amount of garbage (as guided by garbage first heuristic).  If this is not enough memory\n-    \/\/           to satisfy the pending allocation request, we are in \"dire straits\", and a fail-fast OOMError is probably\n-    \/\/           the better remediation than repeated attempts to allocate following repeated GC cycles.\n-\n@@ -1028,0 +998,14 @@\n+      \/\/ Block until control thread reacted, then retry allocation.\n+      \/\/\n+      \/\/ It might happen that one of the threads requesting allocation would unblock\n+      \/\/ way later after GC happened, only to fail the second allocation, because\n+      \/\/ other threads have already depleted the free storage. In this case, a better\n+      \/\/ strategy is to try again, until at least one full GC has completed.\n+      \/\/\n+      \/\/ Stop retrying and return nullptr to cause OOMError exception if our allocation failed even after:\n+      \/\/   a) We experienced a GC that had good progress, or\n+      \/\/   b) We experienced at least one Full GC (whether or not it had good progress)\n+      \/\/\n+      \/\/ TODO: Consider GLOBAL GC rather than Full GC to remediate OOM condition: https:\/\/bugs.openjdk.org\/browse\/JDK-8335910\n+\n+      size_t original_count = shenandoah_policy()->full_gc_count();\n@@ -1032,1 +1016,2 @@\n-      if ((result != nullptr) && mode()->is_generational()) {\n+      if (result != nullptr) {\n+        \/\/ If our allocation request has been satisifed after it initially failed, we count this as good gc progress\n@@ -1035,5 +1020,7 @@\n-    }\n-    if (log_is_enabled(Debug, gc, alloc)) {\n-      ResourceMark rm;\n-      log_debug(gc, alloc)(\"Thread: %s, Result: \" PTR_FORMAT \", Request: %s, Size: \" SIZE_FORMAT \", Original: \" SIZE_FORMAT \", Latest: \" SIZE_FORMAT,\n-                           Thread::current()->name(), p2i(result), req.type_string(), req.size(), original_count, get_gc_no_progress_count());\n+      if (log_is_enabled(Debug, gc, alloc)) {\n+        ResourceMark rm;\n+        log_debug(gc, alloc)(\"Thread: %s, Result: \" PTR_FORMAT \", Request: %s, Size: \" SIZE_FORMAT\n+                             \", Original: \" SIZE_FORMAT \", Latest: \" SIZE_FORMAT,\n+                             Thread::current()->name(), p2i(result), req.type_string(), req.size(),\n+                             original_count, get_gc_no_progress_count());\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":23,"deletions":36,"binary":false,"changes":59,"status":"modified"}]}