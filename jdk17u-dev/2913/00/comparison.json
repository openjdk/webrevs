{"files":[{"patch":"@@ -560,1 +560,0 @@\n-    java\/util\/zip\/ZipFile\/TestTooManyEntries.java \\\n","filename":"test\/jdk\/TEST.groups","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8272746\n+ * @summary Verify that ZipFile rejects a ZIP with a CEN size which does not fit in a Java byte array\n+ * @run junit CenSizeTooLarge\n+ *\/\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class CenSizeTooLarge {\n+    \/\/ Maximum allowed CEN size allowed by the ZipFile implementation\n+    static final int MAX_CEN_SIZE = Integer.MAX_VALUE - ZipFile.ENDHDR - 1;\n+\n+    \/**\n+     * From the APPNOTE.txt specification:\n+     *    4.4.10 file name length: (2 bytes)\n+     *    4.4.11 extra field length: (2 bytes)\n+     *    4.4.12 file comment length: (2 bytes)\n+     *\n+     *        The length of the file name, extra field, and comment\n+     *        fields respectively.  The combined length of any\n+     *        directory record and these three fields SHOULD NOT\n+     *        generally exceed 65,535 bytes.\n+     *\n+     *  Since ZipOutputStream does not enforce the 'combined length' clause,\n+     *  we simply use 65,535 (0xFFFF) for the purpose of this test.\n+     *\/\n+    static final int MAX_EXTRA_FIELD_SIZE = 65_535;\n+\n+    \/\/ Data size (unsigned short)\n+    \/\/ Field size minus the leading header 'tag' and 'data size' fields (2 bytes each)\n+    static final short MAX_DATA_SIZE = (short) (MAX_EXTRA_FIELD_SIZE - 2 * Short.BYTES);\n+\n+    \/\/ Tag for the 'unknown' field type, specified in APPNOTE.txt 'Third party mappings'\n+    static final short UNKNOWN_ZIP_TAG = (short) 0x9902;\n+\n+    \/\/ Entry names produced in this test are fixed-length\n+    public static final int NAME_LENGTH = 10;\n+\n+    \/\/ Use a shared LocalDateTime on all entries to save processing time\n+    static final LocalDateTime TIME_LOCAL = LocalDateTime.now();\n+\n+    \/\/ The size of one CEN header, including the name and the extra field\n+    static final int CEN_HEADER_SIZE = ZipFile.CENHDR + NAME_LENGTH + MAX_EXTRA_FIELD_SIZE;\n+\n+    \/\/ The number of entries needed to exceed the MAX_CEN_SIZE\n+    static final int NUM_ENTRIES = (MAX_CEN_SIZE \/ CEN_HEADER_SIZE) + 1;\n+\n+    \/\/ Helps SparseOutputStream detect write of the last CEN entry\n+    private static final String LAST_CEN_COMMENT = \"LastCEN\";\n+    private static final byte[] LAST_CEN_COMMENT_BYTES = LAST_CEN_COMMENT.getBytes(StandardCharsets.UTF_8);\n+\n+    \/\/ Expected ZipException message when the CEN does not fit in a Java byte array\n+    private static final String CEN_TOO_LARGE_MESSAGE = \"invalid END header (central directory size too large)\";\n+\n+    \/\/ Zip file to create for testing\n+    private File hugeZipFile;\n+\n+    \/**\n+     * Create a zip file with a CEN size which does not fit within a Java byte array\n+     *\/\n+    @Before\n+    public void setup() throws IOException {\n+        hugeZipFile = new File(\"cen-too-large.zip\");\n+        hugeZipFile.deleteOnExit();\n+\n+        try (OutputStream out = new SparseOutputStream(new FileOutputStream(hugeZipFile));\n+             ZipOutputStream zip = new ZipOutputStream(out)) {\n+\n+            \/\/ Keep track of entries so we can update extra data before the CEN is written\n+            ZipEntry[] entries = new ZipEntry[NUM_ENTRIES];\n+\n+            \/\/ Add entries until MAX_CEN_SIZE is reached\n+            for (int i = 0; i < NUM_ENTRIES; i++) {\n+                \/\/ Create a fixed-length name for the entry\n+                String name = Integer.toString(i);\n+                name = \"0\".repeat(NAME_LENGTH - name.length()) + name;\n+\n+                \/\/ Create and track the entry\n+                ZipEntry entry = entries[i] = new ZipEntry(name);\n+\n+                \/\/ Use STORED for faster processing\n+                entry.setMethod(ZipEntry.STORED);\n+                entry.setSize(0);\n+                entry.setCrc(0);\n+\n+                \/\/ Set the time\/date field for faster processing\n+                entry.setTimeLocal(TIME_LOCAL);\n+\n+                if (i == NUM_ENTRIES -1) {\n+                    \/\/ Help SparseOutputStream detect the last CEN entry write\n+                    entry.setComment(LAST_CEN_COMMENT);\n+                }\n+                \/\/ Add the entry\n+                zip.putNextEntry(entry);\n+\n+\n+            }\n+            \/\/ Finish writing the last entry\n+            zip.closeEntry();\n+\n+            \/\/ Before the CEN headers are written, set the extra data on each entry\n+            byte[] extra = makeLargeExtraField();\n+            for (ZipEntry entry : entries) {\n+                entry.setExtra(extra);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Validates that a ZipException is thrown with the expected message when\n+     * the ZipFile is initialized with a ZIP whose CEN exeeds {@link #MAX_CEN_SIZE}\n+     *\/\n+    @Test\n+    public void centralDirectoryTooLargeToFitInByteArray() {\n+        ZipException ex = assertThrows(ZipException.class, () -> new ZipFile(hugeZipFile));\n+        assertEquals(CEN_TOO_LARGE_MESSAGE, ex.getMessage());\n+    }\n+\n+    \/**\n+     * We can reduce the number of written CEN headers by making each CEN header maximally large.\n+     * We do this by adding the extra field produced by this method to each CEN header.\n+     * <p>\n+     * The structure of an extra field is as follows:\n+     * <p>\n+     * Header ID  (Two bytes, describes the type of the field, also called 'tag')\n+     * Data Size  (Two byte short)\n+     * Data Block (Contents depend on field type)\n+     *\/\n+    private byte[] makeLargeExtraField() {\n+        \/\/ Make a maximally sized extra field\n+        byte[] extra = new byte[MAX_EXTRA_FIELD_SIZE];\n+        \/\/ Little-endian ByteBuffer for updating the header fields\n+        ByteBuffer buffer = ByteBuffer.wrap(extra).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        \/\/ We use the 'unknown' tag, specified in APPNOTE.TXT, 4.6.1 Third party mappings'\n+        buffer.putShort(UNKNOWN_ZIP_TAG);\n+\n+        \/\/ Size of the actual (empty) data\n+        buffer.putShort(MAX_DATA_SIZE);\n+        return extra;\n+    }\n+\n+    \/**\n+     * By writing sparse 'holes' until the last CEN is detected, we can save disk space\n+     * used by this test from ~2GB to ~4K. Instances of this class should be passed\n+     * directly to the ZipOutputStream constructor, without any buffering. Otherwise,\n+     * writes from ZipOutputStream may not be detected correctly.\n+     *\/\n+    private static class SparseOutputStream extends FilterOutputStream {\n+        private final FileChannel channel;\n+        private boolean sparse = true; \/\/ True until the last CEN is written\n+        private long position = 0;\n+\n+        public SparseOutputStream(FileOutputStream fos) {\n+            super(fos);\n+            this.channel = fos.getChannel();\n+        }\n+\n+        @Override\n+        public void write(byte[] b, int off, int len) throws IOException {\n+            position += len;\n+            if (sparse) {\n+                \/\/ Until finding the last CEN, we don't actually write anything,\n+                \/\/ but instead simply advance the position, creating a sparse file\n+                channel.position(position);\n+                \/\/ Check for last CEN record\n+                if (Arrays.equals(LAST_CEN_COMMENT_BYTES, 0, LAST_CEN_COMMENT_BYTES.length, b, off, len)) {\n+                    \/\/ From here on, write actual bytes\n+                    sparse = false;\n+                }\n+            } else {\n+                \/\/ Regular write\n+                out.write(b, off, len);\n+            }\n+        }\n+\n+        @Override\n+        public void write(int b) throws IOException {\n+            position++;\n+            if (sparse) {\n+                channel.position(position);\n+            } else {\n+                out.write(b);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/CenSizeTooLarge.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 8272746\n- * @summary ZipFile can't open big file (NegativeArraySizeException)\n- * @requires (sun.arch.data.model == \"64\" & os.maxMemory > 8g)\n- * @run testng\/manual\/othervm -Xmx8g TestTooManyEntries\n- *\/\n-\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.Test;\n-\n-import java.io.File;\n-import java.io.BufferedOutputStream;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipException;\n-import java.util.zip.ZipFile;\n-import java.util.zip.ZipOutputStream;\n-import java.util.UUID;\n-\n-import static org.testng.Assert.assertThrows;\n-\n-public class TestTooManyEntries {\n-    \/\/ Number of directories in the zip file\n-    private static final int DIR_COUNT = 25000;\n-    \/\/ Number of entries per directory\n-    private static final int ENTRIES_IN_DIR = 1000;\n-\n-    \/\/ Zip file to create for testing\n-    private File hugeZipFile;\n-\n-    \/**\n-     * Create a zip file and add entries that exceed the CEN limit.\n-     * @throws IOException if an error occurs creating the ZIP File\n-     *\/\n-    @BeforeTest\n-    public void setup() throws IOException {\n-        hugeZipFile = File.createTempFile(\"hugeZip\", \".zip\", new File(\".\"));\n-        hugeZipFile.deleteOnExit();\n-        long startTime = System.currentTimeMillis();\n-        try (ZipOutputStream zip = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(hugeZipFile)))) {\n-            for (int dirN = 0; dirN < DIR_COUNT; dirN++) {\n-                String dirName = UUID.randomUUID() + \"\/\";\n-                for (int fileN = 0; fileN < ENTRIES_IN_DIR; fileN++) {\n-                    ZipEntry entry = new ZipEntry(dirName + UUID.randomUUID());\n-                    zip.putNextEntry(entry);\n-                    zip.closeEntry(); \/\/ all files are empty\n-                }\n-                if ((dirN + 1) % 1000 == 0) {\n-                    System.out.printf(\"%s \/ %s of entries written, file size is %sMb (%ss)%n\",\n-                            (dirN + 1) * ENTRIES_IN_DIR, DIR_COUNT * ENTRIES_IN_DIR, hugeZipFile.length() \/ 1024 \/ 1024,\n-                            (System.currentTimeMillis() - startTime) \/ 1000);\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Validates that the ZipException is thrown when the ZipFile class\n-     * is initialized with a zip file whose entries exceed the CEN limit.\n-     *\/\n-    @Test\n-    public void test() {\n-        assertThrows(ZipException.class, () -> new ZipFile(hugeZipFile));\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/TestTooManyEntries.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"}]}