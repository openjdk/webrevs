{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n-    interface AnInterface {\n-        public int getInt();\n+    interface FirstInterface {\n+        public int getIntFirst();\n@@ -46,1 +46,1 @@\n-        public int get1();\n+        public int getIntSecond();\n@@ -49,10 +49,2 @@\n-    interface OnlyHasOneImplInterface {\n-        public int getLong();\n-    }\n-\n-    interface AloneInterface {\n-        public int getNumber();\n-    }\n-\n-    class SingleImplementor implements OnlyHasOneImplInterface {\n-        public int getLong() {\n+    class FirstClass implements FirstInterface, SecondInterface {\n+        public int getIntFirst() {\n@@ -61,4 +53,0 @@\n-    }\n-\n-    class Extender1 extends SingleImplementor {\n-    }\n@@ -66,2 +54,1 @@\n-    class FirstClass implements AnInterface {\n-        public int getInt() {\n+        public int getIntSecond() {\n@@ -72,2 +59,2 @@\n-    class SecondClass implements AnInterface {\n-        public int getInt() {\n+    class SecondClass implements FirstInterface, SecondInterface {\n+        public int getIntFirst() {\n@@ -76,1 +63,0 @@\n-    }\n@@ -78,3 +64,2 @@\n-    class ThirdClass implements AnInterface {\n-        public int getInt() {\n-            return -3;\n+        public int getIntSecond() {\n+            return 1;\n@@ -84,3 +69,3 @@\n-    class FourthClass implements AnInterface {\n-        public int getInt() {\n-            return -4;\n+    class ThirdClass implements FirstInterface, SecondInterface {\n+        public int getIntFirst() {\n+            return -3;\n@@ -88,1 +73,0 @@\n-    }\n@@ -90,3 +74,2 @@\n-    class FifthClass implements AnInterface {\n-        public int getInt() {\n-            return -5;\n+        public int getIntSecond() {\n+            return 1;\n@@ -96,3 +79,3 @@\n-    class MultiClass1 implements AnInterface, SecondInterface {\n-        public int get1() {\n-            return 1;\n+    class FourthClass implements FirstInterface, SecondInterface {\n+        public int getIntFirst() {\n+            return -4;\n@@ -101,2 +84,2 @@\n-        public int getInt() {\n-            return 2;\n+        public int getIntSecond() {\n+            return 1;\n@@ -106,7 +89,3 @@\n-    class MultiClass2 implements AnInterface, SecondInterface {\n-        public int get1() {\n-            return -1;\n-        }\n-\n-        public int getInt() {\n-            return -2;\n+    class FifthClass implements FirstInterface, SecondInterface {\n+        public int getIntFirst() {\n+            return -5;\n@@ -114,1 +93,0 @@\n-    }\n@@ -116,3 +94,2 @@\n-    class Aloner implements AloneInterface {\n-        public int getNumber() {\n-            return 7;\n+        public int getIntSecond() {\n+            return 1;\n@@ -122,17 +99,2 @@\n-    public Object dummy1;\n-\n-    public Object dummy2;\n-\n-    public Object dummy3;\n-\n-    public AnInterface multi1a, multi2a;\n-\n-    public SecondInterface multi1b, multi2b;\n-\n-    public Object multic, multic2;\n-\n-    public AnInterface[] as = new AnInterface[5];\n-\n-    public AnInterface multi;\n-\n-    public OnlyHasOneImplInterface single1;\n+    final int asLength = 5;\n+    public FirstInterface[] as = new FirstInterface[asLength];\n@@ -140,5 +102,0 @@\n-    public OnlyHasOneImplInterface single2;\n-\n-    public AloneInterface alone;\n-\n-    int count;\n@@ -148,3 +105,0 @@\n-        dummy1 = new FirstClass();\n-        dummy2 = new SecondClass();\n-        dummy3 = new ThirdClass();\n@@ -156,27 +110,0 @@\n-        MultiClass1 mc1 = new MultiClass1();\n-        multi1a = mc1;\n-        multi1b = mc1;\n-        multic = mc1;\n-        MultiClass2 mc2 = new MultiClass2();\n-        multi2a = mc2;\n-        multi2b = mc2;\n-        multic2 = mc2;\n-        single1 = new SingleImplementor();\n-        single2 = new Extender1();\n-        alone = new Aloner();\n-    }\n-\n-    private void swapMultiParts() {\n-        AnInterface tmpa = multi1a;\n-        SecondInterface tmpb = multi1b;\n-        multi1a = multi2a;\n-        multi2a = tmpa;\n-        multi1b = multi2b;\n-        multi2b = tmpb;\n-    }\n-\n-    @SuppressWarnings(\"unused\")\n-    private void swapMulti() {\n-        Object tmp = multic;\n-        multic = multic2;\n-        multic2 = tmp;\n@@ -186,2 +113,2 @@\n-     * Tests a call where there are multiple implementors but only one of the implementors is every used here so the\n-     * call-site is monomorphic\n+     * Tests a call where there are multiple implementors but only one of the\n+     * implementors is every used here so the call-site is monomorphic\n@@ -191,7 +118,1 @@\n-        return as[0].getInt();\n-    }\n-\n-    \/** Tests a interface call that only has one single implementation *\/\n-    @Benchmark\n-    public int testSingle() {\n-        return alone.getNumber();\n+        return as[0].getIntFirst();\n@@ -200,15 +121,1 @@\n-    \/**\n-     * Tests a call where there is a single implementation but multiple classes that inherit that implementation and both\n-     * these implementors are used.\n-     *\/\n-    @Benchmark\n-    public int testSingle2() {\n-        OnlyHasOneImplInterface oi;\n-        if ((count & 1) == 0) {\n-            oi = single1;\n-        } else {\n-            oi = single2;\n-        }\n-        count++;\n-        return oi.getLong();\n-    }\n+    int l = 0;\n@@ -217,2 +124,2 @@\n-     * Tests calling two different interface methods in two different interfaces on the same receiver. Make sure to switch\n-     * between two different types of receivers to achieve polymorhpism\n+     * Interface call address computation within loop but the receiver preexists\n+     * the loop and the ac can be moved outside of the loop\n@@ -221,9 +128,4 @@\n-    public void testCall2Poly2(Blackhole bh) {\n-        bh.consume(multi1a.getInt());\n-        bh.consume(multi1b.get1());\n-        swapMultiParts();\n-    }\n-\n-    @Benchmark\n-    public int testCallMulti1Poly2NoSwap() {\n-        return multi1a.getInt();\n+    public int test1stInt2Types() {\n+        FirstInterface ai = as[l];\n+        l = 1 - l;\n+        return ai.getIntFirst();\n@@ -232,4 +134,0 @@\n-    \/**\n-     * This test goes together with Multi2 below It tests if a class implements multiple interfaces if the different\n-     * interfaces take different amounts of time (They do for hotspot)\n-     *\/\n@@ -237,3 +135,4 @@\n-    public int testCallMulti1Poly2() {\n-        swapMultiParts();\n-        return multi1a.getInt();\n+    public int test1stInt3Types() {\n+        FirstInterface ai = as[l];\n+        l = ++ l % 3;\n+        return ai.getIntFirst();\n@@ -242,4 +141,0 @@\n-    \/**\n-     * This test goes together with Multi2 below It tests if a class implements multiple interfaces if the different\n-     * interfaces take different amounts of time (They do for hotspot)\n-     *\/\n@@ -247,3 +142,4 @@\n-    public int testCallMulti2Poly2() {\n-        swapMultiParts();\n-        return multi1b.get1();\n+    public int test1stInt5Types() {\n+        FirstInterface ai = as[l];\n+        l = ++ l % asLength;\n+        return ai.getIntFirst();\n@@ -252,1 +148,0 @@\n-    \/** Interface call with three different receivers *\/\n@@ -254,4 +149,4 @@\n-    public void testCallPoly3(Blackhole bh) {\n-        for (int kk = 0; kk < 3; kk++) {\n-            bh.consume(as[kk].getInt());\n-        }\n+    public int test2ndInt2Types() {\n+        SecondInterface ai = (SecondInterface) as[l];\n+        l = 1 - l;\n+        return ai.getIntSecond();\n@@ -260,1 +155,0 @@\n-    \/** Interface call with five different receivers. *\/\n@@ -262,4 +156,4 @@\n-    public void testCallPoly5(Blackhole bh) {\n-        for (int kk = 0; kk < 5; kk++) {\n-            bh.consume(as[kk].getInt());\n-        }\n+    public int test2ndInt3Types() {\n+        SecondInterface ai = (SecondInterface) as[l];\n+        l = ++ l % 3;\n+        return ai.getIntSecond();\n@@ -268,6 +162,0 @@\n-    int l;\n-\n-    \/**\n-     * Interface call address computation within loop but the receiver preexists the loop and the ac can be moved outside\n-     * of the loop\n-     *\/\n@@ -275,4 +163,4 @@\n-    public int testAC1() {\n-        AnInterface ai = as[l];\n-        l = 1 - l;\n-        return ai.getInt();\n+    public int test2ndInt5Types() {\n+        SecondInterface ai = (SecondInterface) as[l];\n+        l = ++ l % asLength;\n+        return ai.getIntSecond();\n@@ -281,6 +169,0 @@\n-    \/** Tests an interface cast followed by an interface call. *\/\n-    @Benchmark\n-    public int testInterfaceCastAndCall() throws Exception {\n-        return ((AnInterface) dummy1).getInt() + ((AnInterface) dummy2).getInt()\n-                + ((AnInterface) dummy3).getInt();\n-    }\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/InterfaceCalls.java","additions":58,"deletions":176,"binary":false,"changes":234,"status":"modified"}]}