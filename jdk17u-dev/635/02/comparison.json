{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1493,1 +1493,2 @@\n-void JvmtiExport::post_object_free(JvmtiEnv* env, jlong tag) {\n+void JvmtiExport::post_object_free(JvmtiEnv* env, GrowableArray<jlong>* objects) {\n+  assert(objects != NULL, \"Nothing to post\");\n@@ -1499,0 +1500,3 @@\n+  JavaThread* javaThread = JavaThread::current();\n+  JvmtiThreadEventMark jem(javaThread);\n+  JvmtiJavaThreadEventTransition jet(javaThread);\n@@ -1501,1 +1505,3 @@\n-    (*callback)(env->jvmti_external(), tag);\n+    for (int index = 0; index < objects->length(); index++) {\n+      (*callback)(env->jvmti_external(), objects->at(index));\n+    }\n@@ -2335,1 +2341,1 @@\n-    JvmtiThreadState *state = thread->as_Java_thread()->jvmti_thread_state();\n+    JvmtiThreadState *state = thread->as_Java_Thread()->jvmti_thread_state();\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -373,1 +373,1 @@\n-  static void post_object_free(JvmtiEnv* env, jlong tag) NOT_JVMTI_RETURN;\n+  static void post_object_free(JvmtiEnv* env, GrowableArray<jlong>* objects) NOT_JVMTI_RETURN;\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,2 @@\n-  _needs_cleaning(false) {\n+  _needs_cleaning(false),\n+  _posting_events(false) {\n@@ -138,4 +139,2 @@\n-\/\/ this tagmap table.  The calls from a JavaThread only rehash, posting is\n-\/\/ only done before heap walks.\n-void JvmtiTagMap::check_hashmap(bool post_events) {\n-  assert(!post_events || SafepointSynchronize::is_at_safepoint(), \"precondition\");\n+\/\/ this tagmap table.\n+void JvmtiTagMap::check_hashmap(GrowableArray<jlong>* objects) {\n@@ -147,1 +146,1 @@\n-      post_events &&\n+      objects != NULL &&\n@@ -149,1 +148,1 @@\n-    remove_dead_entries_locked(true \/* post_object_free *\/);\n+    remove_dead_entries_locked(objects);\n@@ -159,1 +158,1 @@\n-void JvmtiTagMap::check_hashmaps_for_heapwalk() {\n+void JvmtiTagMap::check_hashmaps_for_heapwalk(GrowableArray<jlong>* objects) {\n@@ -170,1 +169,1 @@\n-      tag_map->check_hashmap(\/*post_events*\/ true);\n+      tag_map->check_hashmap(objects);\n@@ -361,1 +360,1 @@\n-  check_hashmap(\/*post_events*\/ false);\n+  check_hashmap(NULL);  \/* don't collect dead objects *\/\n@@ -396,1 +395,1 @@\n-  check_hashmap(\/*post_events*\/ false);\n+  check_hashmap(NULL); \/* don't collect dead objects *\/\n@@ -891,0 +890,1 @@\n+  GrowableArray<jlong>* const _dead_objects;\n@@ -892,1 +892,2 @@\n-  VM_HeapIterateOperation(ObjectClosure* blk) { _blk = blk; }\n+  VM_HeapIterateOperation(ObjectClosure* blk, GrowableArray<jlong>* objects) :\n+    _blk(blk), _dead_objects(objects) { }\n@@ -899,1 +900,1 @@\n-    JvmtiTagMap::check_hashmaps_for_heapwalk();\n+    JvmtiTagMap::check_hashmaps_for_heapwalk(_dead_objects);\n@@ -1138,8 +1139,14 @@\n-  MutexLocker ml(Heap_lock);\n-  IterateOverHeapObjectClosure blk(this,\n-                                   klass,\n-                                   object_filter,\n-                                   heap_object_callback,\n-                                   user_data);\n-  VM_HeapIterateOperation op(&blk);\n-  VMThread::execute(&op);\n+  Arena dead_object_arena(mtServiceability);\n+  GrowableArray <jlong> dead_objects(&dead_object_arena, 10, 0, 0);\n+  {\n+    MutexLocker ml(Heap_lock);\n+    IterateOverHeapObjectClosure blk(this,\n+                                     klass,\n+                                     object_filter,\n+                                     heap_object_callback,\n+                                     user_data);\n+    VM_HeapIterateOperation op(&blk, &dead_objects);\n+    VMThread::execute(&op);\n+  }\n+  \/\/ Post events outside of Heap_lock\n+  post_dead_objects(&dead_objects);\n@@ -1158,8 +1165,15 @@\n-  MutexLocker ml(Heap_lock);\n-  IterateThroughHeapObjectClosure blk(this,\n-                                      klass,\n-                                      heap_filter,\n-                                      callbacks,\n-                                      user_data);\n-  VM_HeapIterateOperation op(&blk);\n-  VMThread::execute(&op);\n+\n+  Arena dead_object_arena(mtServiceability);\n+  GrowableArray<jlong> dead_objects(&dead_object_arena, 10, 0, 0);\n+  {\n+    MutexLocker ml(Heap_lock);\n+    IterateThroughHeapObjectClosure blk(this,\n+                                        klass,\n+                                        heap_filter,\n+                                        callbacks,\n+                                        user_data);\n+    VM_HeapIterateOperation op(&blk, &dead_objects);\n+    VMThread::execute(&op);\n+  }\n+  \/\/ Post events outside of Heap_lock\n+  post_dead_objects(&dead_objects);\n@@ -1168,1 +1182,1 @@\n-void JvmtiTagMap::remove_dead_entries_locked(bool post_object_free) {\n+void JvmtiTagMap::remove_dead_entries_locked(GrowableArray<jlong>* objects) {\n@@ -1172,1 +1186,3 @@\n-    post_object_free = post_object_free && env()->is_enabled(JVMTI_EVENT_OBJECT_FREE);\n+    if (!env()->is_enabled(JVMTI_EVENT_OBJECT_FREE)) {\n+      objects = NULL;\n+    }\n@@ -1174,2 +1190,2 @@\n-                           (post_object_free ? \" and posting\" : \"\"));\n-    hashmap()->remove_dead_entries(env(), post_object_free);\n+                           ((objects != NULL) ? \" and posting\" : \"\"));\n+    hashmap()->remove_dead_entries(objects);\n@@ -1180,1 +1196,1 @@\n-void JvmtiTagMap::remove_dead_entries(bool post_object_free) {\n+void JvmtiTagMap::remove_dead_entries(GrowableArray<jlong>* objects) {\n@@ -1182,1 +1198,1 @@\n-  remove_dead_entries_locked(post_object_free);\n+  remove_dead_entries_locked(objects);\n@@ -1185,7 +1201,5 @@\n-class VM_JvmtiPostObjectFree: public VM_Operation {\n-  JvmtiTagMap* _tag_map;\n- public:\n-  VM_JvmtiPostObjectFree(JvmtiTagMap* tag_map) : _tag_map(tag_map) {}\n-  VMOp_Type type() const { return VMOp_Cleanup; }\n-  void doit() {\n-    _tag_map->remove_dead_entries(true \/* post_object_free *\/);\n+void JvmtiTagMap::post_dead_objects(GrowableArray<jlong>* const objects) {\n+  assert(Thread::current()->is_Java_thread(), \"Must post from JavaThread\");\n+  if (objects != NULL && objects->length() > 0) {\n+    JvmtiExport::post_object_free(env(), objects);\n+    log_info(jvmti)(\"%d free object posted\", objects->length());\n@@ -1193,0 +1207,1 @@\n+}\n@@ -1194,8 +1209,5 @@\n-  \/\/ Doesn't need a safepoint, just the VM thread\n-  virtual bool evaluate_at_safepoint() const { return false; }\n-};\n-\n-\/\/ PostObjectFree can't be called by JavaThread, so call it from the VM thread.\n-void JvmtiTagMap::post_dead_objects_on_vm_thread() {\n-  VM_JvmtiPostObjectFree op(this);\n-  VMThread::execute(&op);\n+void JvmtiTagMap::remove_and_post_dead_objects() {\n+  ResourceMark rm;\n+  GrowableArray<jlong> objects;\n+  remove_dead_entries(&objects);\n+  post_dead_objects(&objects);\n@@ -1208,1 +1220,6 @@\n-      MutexLocker ml(lock(), Mutex::_no_safepoint_check_flag);\n+      MonitorLocker ml(lock(), Mutex::_no_safepoint_check_flag);\n+      \/\/ If another thread is posting events, let it finish\n+      while (_posting_events) {\n+        ml.wait();\n+      }\n+\n@@ -1213,0 +1230,1 @@\n+      _posting_events = true;\n@@ -1216,1 +1234,6 @@\n-    post_dead_objects_on_vm_thread();\n+    remove_and_post_dead_objects();\n+    {\n+      MonitorLocker ml(lock(), Mutex::_no_safepoint_check_flag);\n+      _posting_events = false;\n+      ml.notify_all();\n+    }\n@@ -1218,1 +1241,1 @@\n-    remove_dead_entries(false);\n+    remove_dead_entries(NULL);\n@@ -1330,3 +1353,0 @@\n-  if (collector.some_dead_found() && env()->is_enabled(JVMTI_EVENT_OBJECT_FREE)) {\n-    post_dead_objects_on_vm_thread();\n-  }\n@@ -2379,0 +2399,3 @@\n+  \/\/ Dead object tags in JvmtiTagMap\n+  GrowableArray<jlong>* _dead_objects;\n+\n@@ -2420,1 +2443,2 @@\n-                       const void* user_data);\n+                       const void* user_data,\n+                       GrowableArray<jlong>* objects);\n@@ -2425,1 +2449,2 @@\n-                       const void* user_data);\n+                       const void* user_data,\n+                       GrowableArray<jlong>* objects);\n@@ -2437,1 +2462,2 @@\n-                                           const void* user_data) {\n+                                           const void* user_data,\n+                                           GrowableArray<jlong>* objects) {\n@@ -2446,0 +2472,1 @@\n+  _dead_objects = objects;\n@@ -2454,1 +2481,2 @@\n-                                           const void* user_data) {\n+                                           const void* user_data,\n+                                           GrowableArray<jlong>* objects) {\n@@ -2463,0 +2491,1 @@\n+  _dead_objects = objects;\n@@ -2933,1 +2962,1 @@\n-  JvmtiTagMap::check_hashmaps_for_heapwalk();\n+  JvmtiTagMap::check_hashmaps_for_heapwalk(_dead_objects);\n@@ -2981,4 +3010,10 @@\n-  MutexLocker ml(Heap_lock);\n-  BasicHeapWalkContext context(heap_root_callback, stack_ref_callback, object_ref_callback);\n-  VM_HeapWalkOperation op(this, Handle(), context, user_data);\n-  VMThread::execute(&op);\n+  Arena dead_object_arena(mtServiceability);\n+  GrowableArray<jlong> dead_objects(&dead_object_arena, 10, 0, 0);\n+  {\n+    MutexLocker ml(Heap_lock);\n+    BasicHeapWalkContext context(heap_root_callback, stack_ref_callback, object_ref_callback);\n+    VM_HeapWalkOperation op(this, Handle(), context, user_data, &dead_objects);\n+    VMThread::execute(&op);\n+  }\n+  \/\/ Post events outside of Heap_lock\n+  post_dead_objects(&dead_objects);\n@@ -2994,4 +3029,10 @@\n-  MutexLocker ml(Heap_lock);\n-  BasicHeapWalkContext context(NULL, NULL, object_ref_callback);\n-  VM_HeapWalkOperation op(this, initial_object, context, user_data);\n-  VMThread::execute(&op);\n+  Arena dead_object_arena(mtServiceability);\n+  GrowableArray<jlong> dead_objects(&dead_object_arena, 10, 0, 0);\n+  {\n+    MutexLocker ml(Heap_lock);\n+    BasicHeapWalkContext context(NULL, NULL, object_ref_callback);\n+    VM_HeapWalkOperation op(this, initial_object, context, user_data, &dead_objects);\n+    VMThread::execute(&op);\n+  }\n+  \/\/ Post events outside of Heap_lock\n+  post_dead_objects(&dead_objects);\n@@ -3015,4 +3056,11 @@\n-  MutexLocker ml(Heap_lock);\n-  AdvancedHeapWalkContext context(heap_filter, klass, callbacks);\n-  VM_HeapWalkOperation op(this, initial_object, context, user_data);\n-  VMThread::execute(&op);\n+\n+  Arena dead_object_arena(mtServiceability);\n+  GrowableArray<jlong> dead_objects(&dead_object_arena, 10, 0, 0);\n+  {\n+    MutexLocker ml(Heap_lock);\n+    AdvancedHeapWalkContext context(heap_filter, klass, callbacks);\n+    VM_HeapWalkOperation op(this, initial_object, context, user_data, &dead_objects);\n+    VMThread::execute(&op);\n+  }\n+  \/\/ Post events outside of Heap_lock\n+  post_dead_objects(&dead_objects);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":122,"deletions":74,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-  Mutex                 _lock;                      \/\/ lock for this tag map\n+  Monitor               _lock;                      \/\/ lock for this tag map\n@@ -45,0 +45,1 @@\n+  bool                  _posting_events;\n@@ -54,1 +55,1 @@\n-  void check_hashmap(bool post_events);\n+  void check_hashmap(GrowableArray<jlong>* objects);\n@@ -57,1 +58,0 @@\n-  void post_dead_objects_on_vm_thread();\n@@ -62,1 +62,1 @@\n-  inline Mutex* lock()                      { return &_lock; }\n+  inline Monitor* lock()                    { return &_lock; }\n@@ -112,0 +112,4 @@\n+  void remove_and_post_dead_objects();\n+  void remove_dead_entries(GrowableArray<jlong>* objects);\n+  void remove_dead_entries_locked(GrowableArray<jlong>* objects);\n+  void post_dead_objects(GrowableArray<jlong>* const objects);\n@@ -113,4 +117,1 @@\n-  void remove_dead_entries(bool post_object_free);\n-  void remove_dead_entries_locked(bool post_object_free);\n-\n-  static void check_hashmaps_for_heapwalk();\n+  static void check_hashmaps_for_heapwalk(GrowableArray<jlong>* objects);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.hpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -189,2 +189,3 @@\n-\/\/ Serially remove entries for dead oops from the table, and notify jvmti.\n-void JvmtiTagMapTable::remove_dead_entries(JvmtiEnv* env, bool post_object_free) {\n+\/\/ Serially remove entries for dead oops from the table and store dead oops'\n+\/\/ tag in objects array if provided.\n+void JvmtiTagMapTable::remove_dead_entries(GrowableArray<jlong>* objects) {\n@@ -209,3 +210,3 @@\n-        \/\/ post the event to the profiler\n-        if (post_object_free) {\n-          JvmtiExport::post_object_free(env, tag);\n+        \/\/ collect object tags for posting JVMTI events later\n+        if (objects != NULL) {\n+          objects->append(tag);\n@@ -213,1 +214,0 @@\n-\n@@ -220,2 +220,2 @@\n-  log_info(jvmti, table) (\"JvmtiTagMap entries counted %d removed %d; %s\",\n-                          oops_counted, oops_removed, post_object_free ? \"free object posted\" : \"no posting\");\n+  log_info(jvmti, table) (\"JvmtiTagMap entries counted %d removed %d\",\n+                          oops_counted, oops_removed);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,2 +90,2 @@\n-  \/\/ Cleanup cleared entries and post\n-  void remove_dead_entries(JvmtiEnv* env, bool post_object_free);\n+  \/\/ Cleanup cleared entries and store dead object tags in objects array\n+  void remove_dead_entries(GrowableArray<jlong>* objects);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"eventHandler.h\"\n@@ -49,2 +50,1 @@\n- * A bag containing all the deleted classes' signatures. Must be accessed under\n- * classTrackLock.\n+ * Invoke the callback when classes are freed.\n@@ -52,13 +52,1 @@\n-struct bag* deletedSignatures;\n-\n-\/*\n- * Lock to keep integrity of deletedSignatures.\n- *\/\n-static jrawMonitorID classTrackLock;\n-\n-\/*\n- * Invoke the callback when classes are freed, find and record the signature\n- * in deletedSignatures. Those are only used in addPreparedClass() by the\n- * same thread.\n- *\/\n-static void JNICALL\n+void JNICALL\n@@ -67,35 +55,1 @@\n-    debugMonitorEnter(classTrackLock);\n-    if (deletedSignatures == NULL) {\n-      debugMonitorExit(classTrackLock);\n-      return;\n-    }\n-    *(char**)bagAdd(deletedSignatures) = (char*)jlong_to_ptr(tag);\n-\n-    debugMonitorExit(classTrackLock);\n-}\n-\n-\/*\n- * Called after class unloads have occurred.\n- * The signatures of classes which were unloaded are returned.\n- *\/\n-struct bag *\n-classTrack_processUnloads(JNIEnv *env)\n-{\n-    if (deletedSignatures == NULL) {\n-      return NULL;\n-    }\n-\n-    \/* Allocate new bag outside classTrackLock lock to avoid deadlock.\n-     *\n-     * Note: jvmtiAllocate\/jvmtiDeallocate() may be blocked by ongoing safepoints.\n-     * It is dangerous to call them (via bagCreateBag\/bagDestroyBag()) while holding monitor(s),\n-     * because jvmti may post events, e.g. JVMTI_EVENT_OBJECT_FREE at safepoints and event processing\n-     * code may acquire the same monitor(s), e.g. classTrackLock in cbTrackingObjectFree(),\n-     * which can lead to deadlock.\n-     *\/\n-    struct bag* new_bag = bagCreateBag(sizeof(char*), 10);\n-    debugMonitorEnter(classTrackLock);\n-    struct bag* deleted = deletedSignatures;\n-    deletedSignatures = new_bag;\n-    debugMonitorExit(classTrackLock);\n-    return deleted;\n+    eventHandler_synthesizeUnloadEvent((char*)jlong_to_ptr(tag), getEnv());\n@@ -104,3 +58,0 @@\n-\/*\n- * Add a class to the prepared class table.\n- *\/\n@@ -165,2 +116,0 @@\n-    deletedSignatures = NULL;\n-    classTrackLock = debugMonitorCreate(\"Deleted class tag lock\");\n@@ -198,41 +147,0 @@\n-\n-\/*\n- * Called to activate class-tracking when a listener registers for EI_GC_FINISH.\n- *\/\n-void\n-classTrack_activate(JNIEnv *env)\n-{\n-    \/\/ Allocate bag outside classTrackLock lock to avoid deadlock.\n-    \/\/ See comments in classTrack_processUnloads() for details.\n-    struct bag* new_bag = bagCreateBag(sizeof(char*), 1000);\n-    debugMonitorEnter(classTrackLock);\n-    deletedSignatures = new_bag;\n-    debugMonitorExit(classTrackLock);\n-}\n-\n-static jboolean\n-cleanDeleted(void *signatureVoid, void *arg)\n-{\n-    char* sig = *(char**)signatureVoid;\n-    jvmtiDeallocate(sig);\n-    return JNI_TRUE;\n-}\n-\n-\/*\n- * Called when agent detaches.\n- *\/\n-void\n-classTrack_reset(void)\n-{\n-    debugMonitorEnter(classTrackLock);\n-    struct bag* to_delete = deletedSignatures;\n-    deletedSignatures = NULL;\n-    debugMonitorExit(classTrackLock);\n-\n-    \/\/ Deallocate bag outside classTrackLock to avoid deadlock.\n-    \/\/ See comments in classTrack_processUnloads() for details.\n-    if (to_delete != NULL) {\n-      bagEnumerateOver(to_delete, cleanDeleted, NULL);\n-      bagDestroyBag(to_delete);\n-    }\n-}\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/classTrack.c","additions":4,"deletions":96,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -795,1 +795,0 @@\n-    classTrack_reset();\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugInit.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -460,7 +460,3 @@\n-\/* A bagEnumerateFunction.  Create a synthetic class unload event\n- * for every class no longer present.  Analogous to event_callback\n- * combined with a handler in a unload specific (no event\n- * structure) kind of way.\n- *\/\n-static jboolean\n-synthesizeUnloadEvent(void *signatureVoid, void *envVoid)\n+\/* Create a synthetic class unload event for the specified signature. *\/\n+jboolean\n+eventHandler_synthesizeUnloadEvent(char *signature, JNIEnv *env)\n@@ -468,2 +464,0 @@\n-    JNIEnv *env = (JNIEnv *)envVoid;\n-    char *signature = *(char **)signatureVoid;\n@@ -563,13 +557,2 @@\n-    \/* See if a garbage collection finish event happened earlier.\n-     *\n-     * Note: The \"if\" is an optimization to avoid entering the lock on every\n-     *       event; garbageCollected may be zapped before we enter\n-     *       the lock but then this just becomes one big no-op.\n-     *\/\n-    if ( garbageCollected > 0 ) {\n-        struct bag *unloadedSignatures = NULL;\n-\n-        \/* We want to compact the hash table of all\n-         * objects sent to the front end by removing objects that have\n-         * been collected.\n-         *\/\n+    \/* See if a garbage collection finish event happened earlier. *\/\n+    if ( garbageCollected > 0) {\n@@ -577,6 +560,0 @@\n-\n-        \/* We also need to simulate the class unload events. *\/\n-\n-        debugMonitorEnter(handlerLock);\n-\n-        \/* Clear garbage collection counter *\/\n@@ -584,12 +561,0 @@\n-\n-        \/* Analyze which class unloads occurred *\/\n-        unloadedSignatures = classTrack_processUnloads(env);\n-\n-        debugMonitorExit(handlerLock);\n-\n-        \/* Generate the synthetic class unload events and\/or just cleanup.  *\/\n-        if ( unloadedSignatures != NULL ) {\n-            (void)bagEnumerateOver(unloadedSignatures, synthesizeUnloadEvent,\n-                             (void *)env);\n-            bagDestroyBag(unloadedSignatures);\n-        }\n@@ -1630,3 +1595,0 @@\n-    if (node->ei == EI_GC_FINISH) {\n-        classTrack_activate(getEnv());\n-    }\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":5,"deletions":43,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+jboolean eventHandler_synthesizeUnloadEvent(char *signature, JNIEnv *env);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8256811\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/native ClassUnloadEventTest run\n+ *\/\n+\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.Label;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.test.lib.classloader.ClassUnloadCommon;\n+\n+import com.sun.jdi.*;\n+import com.sun.jdi.connect.*;\n+import com.sun.jdi.event.*;\n+import com.sun.jdi.request.*;\n+\n+import java.util.*;\n+import java.io.*;\n+\n+public class ClassUnloadEventTest {\n+    static final String CLASS_NAME_PREFIX = \"SampleClass__\";\n+    static final String CLASS_NAME_ALT_PREFIX = CLASS_NAME_PREFIX + \"Alt__\";\n+    static final int NUM_CLASSES = 10;\n+    static final int NUM_ALT_CLASSES = NUM_CLASSES \/ 2;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            runDebuggee();\n+        } else {\n+            runDebugger();\n+        }\n+    }\n+\n+    private static class TestClassLoader extends ClassLoader implements Opcodes {\n+        private static byte[] generateSampleClass(String name) {\n+            ClassWriter cw = new ClassWriter(0);\n+\n+            cw.visit(52, ACC_SUPER | ACC_PUBLIC, name, null, \"java\/lang\/Object\", null);\n+            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"m\", \"()V\", null, null);\n+            mv.visitCode();\n+            mv.visitInsn(RETURN);\n+            mv.visitMaxs(0, 0);\n+            mv.visitEnd();\n+            cw.visitEnd();\n+            return cw.toByteArray();\n+        }\n+\n+        @Override\n+        protected Class<?> findClass(String name) throws ClassNotFoundException {\n+            if (name.startsWith(CLASS_NAME_PREFIX)) {\n+                byte[] bytecode = generateSampleClass(name);\n+                return defineClass(name, bytecode, 0, bytecode.length);\n+            } else {\n+                return super.findClass(name);\n+            }\n+        }\n+    }\n+\n+    private static void runDebuggee() {\n+        System.out.println(\"Running debuggee\");\n+        ClassLoader loader = new TestClassLoader();\n+        for (int index = 0; index < NUM_CLASSES; index++) {\n+            try {\n+                if (index < NUM_ALT_CLASSES) {\n+                    Class.forName(CLASS_NAME_ALT_PREFIX + index, true, loader);\n+                } else {\n+                    Class.forName(CLASS_NAME_PREFIX + index, true, loader);\n+                }\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Failed to create Sample class\");\n+            }\n+        }\n+        loader = null;\n+        \/\/ Trigger class unloading\n+        ClassUnloadCommon.triggerUnloading();\n+    }\n+\n+    private static void runDebugger() throws Exception {\n+        System.out.println(\"Running debugger\");\n+        HashSet<String> unloadedSampleClasses = new HashSet<>();\n+        HashSet<String> unloadedSampleClasses_alt = new HashSet<>();\n+        VirtualMachine vm = null;\n+        vm = connectAndLaunchVM();\n+        ClassUnloadRequest classUnloadRequest = vm.eventRequestManager().createClassUnloadRequest();\n+        classUnloadRequest.addClassFilter(CLASS_NAME_PREFIX + \"*\");\n+        classUnloadRequest.enable();\n+\n+        ClassUnloadRequest classUnloadRequest_alt = vm.eventRequestManager().createClassUnloadRequest();\n+        classUnloadRequest_alt.addClassFilter(CLASS_NAME_ALT_PREFIX + \"*\");\n+        classUnloadRequest_alt.enable();\n+\n+        EventSet eventSet = null;\n+        boolean exited = false;\n+        while (!exited && (eventSet = vm.eventQueue().remove()) != null) {\n+            System.out.println(\"EventSet: \" + eventSet);\n+            for (Event event : eventSet) {\n+                if (event instanceof ClassUnloadEvent) {\n+                    String className = ((ClassUnloadEvent)event).className();\n+\n+                    \/\/ The unloaded class should always match CLASS_NAME_PREFIX.\n+                    if (className.indexOf(CLASS_NAME_PREFIX) == -1) {\n+                        throw new RuntimeException(\"FAILED: Unexpected unloaded class: \" + className);\n+                    }\n+\n+                    \/\/ Unloaded classes with ALT names should only occur on the classUnloadRequest_alt.\n+                    if (event.request() == classUnloadRequest_alt) {\n+                        unloadedSampleClasses_alt.add(className);\n+                        if (className.indexOf(CLASS_NAME_ALT_PREFIX) == -1) {\n+                            throw new RuntimeException(\"FAILED: non-alt class unload event for classUnloadRequest_alt.\");\n+                        }\n+                    } else {\n+                        unloadedSampleClasses.add(className);\n+                    }\n+\n+                    \/\/ If the unloaded class matches the ALT prefix, then we should have\n+                    \/\/ unload events in this EventSet for each of the two ClassUnloadRequesta.\n+                    int expectedEventSetSize;\n+                    if (className.indexOf(CLASS_NAME_ALT_PREFIX) != -1) {\n+                        expectedEventSetSize = 2;\n+                    } else {\n+                        expectedEventSetSize = 1;\n+                    }\n+                    if (eventSet.size() != expectedEventSetSize) {\n+                        throw new RuntimeException(\"FAILED: Unexpected eventSet size: \" + eventSet.size());\n+                    }\n+                }\n+\n+                if (event instanceof VMDeathEvent) {\n+                    exited = true;\n+                    break;\n+                }\n+            }\n+            eventSet.resume();\n+        }\n+\n+        if (unloadedSampleClasses.size() != NUM_CLASSES) {\n+            throw new RuntimeException(\"Wrong number of class unload events: expected \" + NUM_CLASSES + \" got \" + unloadedSampleClasses.size());\n+        }\n+        if (unloadedSampleClasses_alt.size() != NUM_ALT_CLASSES) {\n+            throw new RuntimeException(\"Wrong number of alt class unload events: expected \" + NUM_ALT_CLASSES + \" got \" + unloadedSampleClasses_alt.size());\n+        }\n+    }\n+\n+    private static VirtualMachine connectAndLaunchVM() throws IOException,\n+                                                              IllegalConnectorArgumentsException,\n+                                                              VMStartException {\n+        LaunchingConnector launchingConnector = Bootstrap.virtualMachineManager().defaultConnector();\n+        Map<String, Connector.Argument> arguments = launchingConnector.defaultArguments();\n+        arguments.get(\"main\").setValue(ClassUnloadEventTest.class.getName());\n+        arguments.get(\"options\").setValue(\"--add-exports java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\");\n+        return launchingConnector.launch(arguments);\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/ClassUnloadEventTest.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"}]}