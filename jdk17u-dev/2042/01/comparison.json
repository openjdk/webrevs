{"files":[{"patch":"@@ -1320,10 +1320,9 @@\n-            \/\/ Expect: 100-Continue was set, so check the return code for\n-            \/\/ Acceptance\n-            int oldTimeout = http.getReadTimeout();\n-            boolean enforceTimeOut = false;\n-            boolean timedOut = false;\n-            if (oldTimeout <= 0) {\n-                \/\/ 5s read timeout in case the server doesn't understand\n-                \/\/ Expect: 100-Continue\n-                http.setReadTimeout(5000);\n-                enforceTimeOut = true;\n+        \/\/ Expect: 100-Continue was set, so check the return code for\n+        \/\/ Acceptance\n+        int oldTimeout = http.getReadTimeout();\n+        boolean timedOut = false;\n+        boolean tempTimeOutSet = false;\n+        if (oldTimeout <= 0 || oldTimeout > 5000) {\n+            if (logger.isLoggable(PlatformLogger.Level.FINE)) {\n+                logger.fine(\"Timeout currently set to \" +\n+                        oldTimeout + \" temporarily setting it to 5 seconds\");\n@@ -1331,0 +1330,5 @@\n+            \/\/ 5s read timeout in case the server doesn't understand\n+            \/\/ Expect: 100-Continue\n+            http.setReadTimeout(5000);\n+            tempTimeOutSet = true;\n+        }\n@@ -1332,8 +1336,6 @@\n-            try {\n-                http.parseHTTP(responses, pi, this);\n-            } catch (SocketTimeoutException se) {\n-                if (!enforceTimeOut) {\n-                    throw se;\n-                }\n-                timedOut = true;\n-                http.setIgnoreContinue(true);\n+        try {\n+            http.parseHTTP(responses, pi, this);\n+        } catch (SocketTimeoutException se) {\n+            if (logger.isLoggable(PlatformLogger.Level.FINE)) {\n+                logger.fine(\"SocketTimeoutException caught,\" +\n+                        \" will attempt to send body regardless\");\n@@ -1341,14 +1343,18 @@\n-            if (!timedOut) {\n-                \/\/ Can't use getResponseCode() yet\n-                String resp = responses.getValue(0);\n-                \/\/ Parse the response which is of the form:\n-                \/\/ HTTP\/1.1 417 Expectation Failed\n-                \/\/ HTTP\/1.1 100 Continue\n-                if (resp != null && resp.startsWith(\"HTTP\/\")) {\n-                    String[] sa = resp.split(\"\\\\s+\");\n-                    responseCode = -1;\n-                    try {\n-                        \/\/ Response code is 2nd token on the line\n-                        if (sa.length > 1)\n-                            responseCode = Integer.parseInt(sa[1]);\n-                    } catch (NumberFormatException numberFormatException) {\n+            timedOut = true;\n+        }\n+\n+        if (!timedOut) {\n+            \/\/ Can't use getResponseCode() yet\n+            String resp = responses.getValue(0);\n+            \/\/ Parse the response which is of the form:\n+            \/\/ HTTP\/1.1 417 Expectation Failed\n+            \/\/ HTTP\/1.1 100 Continue\n+            if (resp != null && resp.startsWith(\"HTTP\/\")) {\n+                String[] sa = resp.split(\"\\\\s+\");\n+                responseCode = -1;\n+                try {\n+                    \/\/ Response code is 2nd token on the line\n+                    if (sa.length > 1)\n+                        responseCode = Integer.parseInt(sa[1]);\n+                    if (logger.isLoggable(PlatformLogger.Level.FINE)) {\n+                        logger.fine(\"response code received \" + responseCode);\n@@ -1356,3 +1362,1 @@\n-                }\n-                if (responseCode != 100) {\n-                    throw new ProtocolException(\"Server rejected operation\");\n+                } catch (NumberFormatException numberFormatException) {\n@@ -1361,0 +1365,5 @@\n+            if (responseCode != 100) {\n+                \/\/ responseCode will be returned to caller\n+                throw new ProtocolException(\"Server rejected operation\");\n+            }\n+        }\n@@ -1362,0 +1371,5 @@\n+        \/\/ If timeout was changed, restore to original value\n+        if (tempTimeOutSet) {\n+            if (logger.isLoggable(PlatformLogger.Level.FINE)) {\n+                logger.fine(\"Restoring original timeout : \" + oldTimeout);\n+            }\n@@ -1363,0 +1377,1 @@\n+        }\n@@ -1364,3 +1379,9 @@\n-            responseCode = -1;\n-            responses.reset();\n-            \/\/ Proceed\n+        \/\/ Ignore any future 100 continue messages\n+        http.setIgnoreContinue(true);\n+        if (logger.isLoggable(PlatformLogger.Level.FINE)) {\n+            logger.fine(\"Set Ignore Continue to true\");\n+        }\n+\n+        responseCode = -1;\n+        responses.reset();\n+        \/\/ Proceed\n@@ -1435,1 +1456,0 @@\n-                http.setIgnoreContinue(false);\n@@ -1444,0 +1464,1 @@\n+                http.setIgnoreContinue(false);\n@@ -1485,0 +1506,1 @@\n+    \/\/ Streaming returns true if there is a request body to send\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpURLConnection.java","additions":61,"deletions":39,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -0,0 +1,437 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8054022\n+ * @summary Verify that expect 100-continue doesn't hang\n+ * @library \/test\/lib\n+ * @run junit\/othervm HttpURLConnectionExpectContinueTest\n+ *\/\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.*;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class HttpURLConnectionExpectContinueTest {\n+\n+    class Control {\n+        volatile ServerSocket serverSocket = null;\n+        volatile boolean stop = false;\n+        volatile boolean respondWith100Continue = false;\n+        volatile boolean write100ContinueTwice = false;\n+        volatile String response = null;\n+    }\n+\n+    private Thread serverThread = null;\n+    private volatile Control control;\n+    static final Logger logger;\n+\n+    static {\n+        logger = Logger.getLogger(\"sun.net.www.protocol.http.HttpURLConnection\");\n+        logger.setLevel(Level.ALL);\n+        Logger.getLogger(\"\").getHandlers()[0].setLevel(Level.ALL);\n+    }\n+\n+    @BeforeAll\n+    public void startServerSocket() throws Exception {\n+        Control control = this.control = new Control();\n+\n+        control.serverSocket = new ServerSocket();\n+        control.serverSocket.setReuseAddress(true);\n+        control.serverSocket.bind(new InetSocketAddress(\"127.0.0.1\", 54321));\n+        Runnable runnable = () -> {\n+            while (!control.stop) {\n+                try {\n+                    Socket socket = control.serverSocket.accept();\n+                    InputStream inputStream = socket.getInputStream();\n+                    InputStreamReader inputStreamReader = new InputStreamReader(inputStream);\n+\n+                    StringBuilder stringBuilder = new StringBuilder();\n+\n+                    \/\/ Read initial request\n+                    byte b;\n+                    while (true) {\n+                        b = (byte) inputStreamReader.read();\n+                        stringBuilder.append((char) b);\n+\n+                        if (stringBuilder.length() >= 4) {\n+                            char[] lastBytes = new char[4];\n+                            stringBuilder.getChars(\n+                                    stringBuilder.length() - 4,\n+                                    stringBuilder.length(), lastBytes, 0);\n+                            if (Arrays.equals(lastBytes, new char[]{'\\r', '\\n', '\\r', '\\n'})) {\n+                                break;\n+                            }\n+                        }\n+                    }\n+\n+                    OutputStream outputStream = socket.getOutputStream();\n+\n+                    String header = stringBuilder.toString();\n+                    String contentLengthString = \"Content-Length:\";\n+\n+                    \/\/ send 100 continue responses if set by test\n+                    if (control.respondWith100Continue) {\n+                        outputStream.write(\"HTTP\/1.1 100 Continue\\r\\n\\r\\n\".getBytes());\n+                        outputStream.flush();\n+                        if (control.write100ContinueTwice) {\n+                            outputStream.write(\"HTTP\/1.1 100 Continue\\r\\n\\r\\n\".getBytes());\n+                            outputStream.flush();\n+                        }\n+                    }\n+\n+                    \/\/ expect main request to be received\n+                    int idx = header.indexOf(contentLengthString);\n+\n+                    if (idx >= 0) {\n+                        String substr = header.substring(idx + contentLengthString.length());\n+                        idx = substr.indexOf('\\r');\n+                        substr = substr.substring(0, idx);\n+                        int contentLength = Integer.parseInt(substr.trim());\n+\n+                        StringBuilder contentLengthBuilder = new StringBuilder();\n+                        for (int i = 0; i < contentLength; i++) {\n+                            b = (byte) inputStreamReader.read();\n+                            contentLengthBuilder.append((char) b);\n+                        }\n+\n+                    } else {\n+                        StringBuilder contentLengthBuilder = new StringBuilder();\n+                        while (true) {\n+                            b = (byte) inputStreamReader.read();\n+                            contentLengthBuilder.append((char) b);\n+\n+                            if (contentLengthBuilder.length() >= 2) {\n+                                char[] lastBytes = new char[2];\n+                                contentLengthBuilder.getChars(\n+                                        contentLengthBuilder.length() - 2,\n+                                        contentLengthBuilder.length(), lastBytes, 0);\n+                                if (Arrays.equals(lastBytes, new char[]{'\\r', '\\n'})) {\n+                                    String lengthInHex =\n+                                            contentLengthBuilder.substring(0, contentLengthBuilder.length() - 2);\n+\n+                                    int contentLength = Integer.parseInt(lengthInHex, 16);\n+                                    char[] body = new char[contentLength];\n+                                    inputStreamReader.read(body);\n+                                    break;\n+                                    \/\/ normally we have to parse more data,\n+                                    \/\/ but for simplicity we expect no more chunks...\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    \/\/ send response\n+                    outputStream.write(control.response.getBytes());\n+                    outputStream.flush();\n+                } catch (SocketException e) {\n+                    \/\/ ignore\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        };\n+        serverThread = new Thread(runnable);\n+        serverThread.start();\n+    }\n+\n+    @AfterAll\n+    public void stopServerSocket() throws Exception {\n+        Control control = this.control;\n+        control.stop = true;\n+        control.serverSocket.close();\n+        serverThread.join();\n+    }\n+\n+    @Test\n+    public void testNonChunkedRequestAndNoExpect100ContinueResponse() throws Exception {\n+        String body = \"testNonChunkedRequestAndNoExpect100ContinueResponse\";\n+        Control control = this.control;\n+        control.response = \"HTTP\/1.1 200 OK\\r\\n\" +\n+                \"Connection: close\\r\\n\" +\n+                \"Content-Length: \" + body.length() + \"\\r\\n\" +\n+                \"\\r\\n\" +\n+                body + \"\\r\\n\";\n+        control.respondWith100Continue = false;\n+        control.write100ContinueTwice = false;\n+\n+        HttpURLConnection connection = createConnection();\n+        OutputStream outputStream = connection.getOutputStream();\n+        outputStream.write(body.getBytes());\n+        outputStream.close();\n+\n+        int responseCode = connection.getResponseCode();\n+        String responseBody = new String(connection.getInputStream().readAllBytes(), StandardCharsets.UTF_8).strip();\n+        System.err.println(\"response body: \" + responseBody);\n+        assertTrue(responseCode == 200,\n+                String.format(\"Expected 200 response, instead received %s\", responseCode));\n+        assertTrue(body.equals(responseBody),\n+                String.format(\"Expected response %s, instead received %s\", body, responseBody));\n+    }\n+\n+    @Test\n+    public void testNonChunkedRequestWithExpect100ContinueResponse() throws Exception {\n+        String body = \"testNonChunkedRequestWithExpect100ContinueResponse\";\n+        Control control = this.control;\n+        control.response = \"HTTP\/1.1 200 OK\\r\\n\" +\n+                \"Connection: close\\r\\n\" +\n+                \"Content-Length: \" + body.length() + \"\\r\\n\" +\n+                \"\\r\\n\" +\n+                body + \"\\r\\n\";\n+        control.respondWith100Continue = true;\n+        control.write100ContinueTwice = false;\n+\n+        HttpURLConnection connection = createConnection();\n+        OutputStream outputStream = connection.getOutputStream();\n+        outputStream.write(body.getBytes());\n+        outputStream.close();\n+\n+        int responseCode = connection.getResponseCode();\n+        String responseBody = new String(connection.getInputStream().readAllBytes(), StandardCharsets.UTF_8).strip();\n+        System.err.println(\"response body: \" + responseBody);\n+        assertTrue(responseCode == 200,\n+                String.format(\"Expected 200 response, instead received %s\", responseCode));\n+        assertTrue(body.equals(responseBody),\n+                String.format(\"Expected response %s, instead received %s\", body, responseBody));\n+    }\n+\n+    @Test\n+    public void testNonChunkedRequestWithDoubleExpect100ContinueResponse() throws Exception {\n+        String body = \"testNonChunkedRequestWithDoubleExpect100ContinueResponse\";\n+        Control control = this.control;\n+        control.response = \"HTTP\/1.1 200 OK\\r\\n\" +\n+                \"Connection: close\\r\\n\" +\n+                \"Content-Length: \" + body.length() + \"\\r\\n\" +\n+                \"\\r\\n\" +\n+                body + \"\\r\\n\";\n+        control.respondWith100Continue = true;\n+        control.write100ContinueTwice = true;\n+\n+        HttpURLConnection connection = createConnection();\n+        OutputStream outputStream = connection.getOutputStream();\n+        outputStream.write(body.getBytes());\n+        outputStream.close();\n+\n+        int responseCode = connection.getResponseCode();\n+        String responseBody = new String(connection.getInputStream().readAllBytes(), StandardCharsets.UTF_8).strip();\n+        System.err.println(\"response body: \" + responseBody);\n+        assertTrue(responseCode == 200,\n+                String.format(\"Expected 200 response, instead received %s\", responseCode));\n+        assertTrue(body.equals(responseBody),\n+                String.format(\"Expected response %s, instead received %s\", body, responseBody));\n+    }\n+\n+    @Test\n+    public void testChunkedRequestAndNoExpect100ContinueResponse() throws Exception {\n+        String body = \"testChunkedRequestAndNoExpect100ContinueResponse\";\n+        Control control = this.control;\n+        control.response = \"HTTP\/1.1 200 OK\\r\\n\" +\n+                \"Connection: close\\r\\n\" +\n+                \"Content-Length: \" + body.length() + \"\\r\\n\" +\n+                \"\\r\\n\" +\n+                body + \"\\r\\n\";\n+        control.respondWith100Continue = false;\n+        control.write100ContinueTwice = false;\n+\n+        HttpURLConnection connection = createConnection();\n+        connection.setChunkedStreamingMode(body.length() \/ 2);\n+        OutputStream outputStream = connection.getOutputStream();\n+        outputStream.write(body.getBytes());\n+        outputStream.close();\n+\n+        int responseCode = connection.getResponseCode();\n+        String responseBody = new String(connection.getInputStream().readAllBytes(), StandardCharsets.UTF_8).strip();\n+        System.err.println(\"response body: \" + responseBody);\n+        assertTrue(responseCode == 200,\n+                String.format(\"Expected 200 response, instead received %s\", responseCode));\n+        assertTrue(body.equals(responseBody),\n+                String.format(\"Expected response %s, instead received %s\", body, responseBody));\n+    }\n+\n+    @Test\n+    public void testChunkedRequestWithExpect100ContinueResponse() throws Exception {\n+        String body = \"testChunkedRequestWithExpect100ContinueResponse\";\n+        Control control = this.control;\n+        control.response = \"HTTP\/1.1 200 OK\\r\\n\" +\n+                \"Connection: close\\r\\n\" +\n+                \"Content-Length: \" + body.length() + \"\\r\\n\" +\n+                \"\\r\\n\" +\n+                body + \"\\r\\n\";\n+        control.respondWith100Continue = true;\n+        control.write100ContinueTwice = false;\n+\n+        HttpURLConnection connection = createConnection();\n+        connection.setChunkedStreamingMode(body.length() \/ 2);\n+        OutputStream outputStream = connection.getOutputStream();\n+        outputStream.write(body.getBytes());\n+        outputStream.close();\n+\n+        int responseCode = connection.getResponseCode();\n+        String responseBody = new String(connection.getInputStream().readAllBytes(), StandardCharsets.UTF_8).strip();\n+        System.err.println(\"response body: \" + responseBody);\n+        assertTrue(responseCode == 200,\n+                String.format(\"Expected 200 response, instead received %s\", responseCode));\n+        assertTrue(body.equals(responseBody),\n+                String.format(\"Expected response %s, instead received %s\", body, responseBody));\n+    }\n+\n+    @Test\n+    public void testChunkedRequestWithDoubleExpect100ContinueResponse() throws Exception {\n+        String body = \"testChunkedRequestWithDoubleExpect100ContinueResponse\";\n+        Control control = this.control;\n+        control.response = \"HTTP\/1.1 200 OK\\r\\n\" +\n+                \"Connection: close\\r\\n\" +\n+                \"Content-Length: \" + body.length() + \"\\r\\n\" +\n+                \"\\r\\n\" +\n+                body + \"\\r\\n\";\n+        control.respondWith100Continue = true;\n+        control.write100ContinueTwice = true;\n+\n+        HttpURLConnection connection = createConnection();\n+        connection.setChunkedStreamingMode(body.length() \/ 2);\n+        OutputStream outputStream = connection.getOutputStream();\n+        outputStream.write(body.getBytes());\n+        outputStream.close();\n+\n+        int responseCode = connection.getResponseCode();\n+        String responseBody = new String(connection.getInputStream().readAllBytes(), StandardCharsets.UTF_8).strip();\n+        System.err.println(\"response body: \" + responseBody);\n+        assertTrue(responseCode == 200,\n+                String.format(\"Expected 200 response, instead received %s\", responseCode));\n+        assertTrue(body.equals(responseBody),\n+                String.format(\"Expected response %s, instead received %s\", body, responseBody));\n+    }\n+\n+    @Test\n+    public void testFixedLengthRequestAndNoExpect100ContinueResponse() throws Exception {\n+        String body = \"testFixedLengthRequestAndNoExpect100ContinueResponse\";\n+        Control control = this.control;\n+        control.response = \"HTTP\/1.1 200 OK\\r\\n\" +\n+                \"Connection: close\\r\\n\" +\n+                \"Content-Length: \" + body.length() + \"\\r\\n\" +\n+                \"\\r\\n\" +\n+                body + \"\\r\\n\";\n+        control.respondWith100Continue = false;\n+        control.write100ContinueTwice = false;\n+\n+        HttpURLConnection connection = createConnection();\n+        connection.setFixedLengthStreamingMode(body.length());\n+        OutputStream outputStream = connection.getOutputStream();\n+        outputStream.write(body.getBytes());\n+        outputStream.close();\n+\n+        int responseCode = connection.getResponseCode();\n+        String responseBody = new String(connection.getInputStream().readAllBytes(), StandardCharsets.UTF_8).strip();\n+        System.err.println(\"response body: \" + responseBody);\n+        assertTrue(responseCode == 200,\n+                String.format(\"Expected 200 response, instead received %s\", responseCode));\n+        assertTrue(body.equals(responseBody),\n+                String.format(\"Expected response %s, instead received %s\", body, responseBody));\n+    }\n+\n+    @Test\n+    public void testFixedLengthRequestWithExpect100ContinueResponse() throws Exception {\n+        String body = \"testFixedLengthRequestWithExpect100ContinueResponse\";\n+        Control control = this.control;\n+        control.response = \"HTTP\/1.1 200 OK\\r\\n\" +\n+                \"Connection: close\\r\\n\" +\n+                \"Content-Length: \" + body.length() + \"\\r\\n\" +\n+                \"\\r\\n\" +\n+                body + \"\\r\\n\";\n+        control.respondWith100Continue = true;\n+        control.write100ContinueTwice = false;\n+\n+        HttpURLConnection connection = createConnection();\n+        connection.setFixedLengthStreamingMode(body.getBytes().length);\n+        OutputStream outputStream = connection.getOutputStream();\n+        outputStream.write(body.getBytes());\n+        outputStream.close();\n+\n+        int responseCode = connection.getResponseCode();\n+        String responseBody = new String(connection.getInputStream().readAllBytes(), StandardCharsets.UTF_8).strip();\n+        System.err.println(\"response body: \" + responseBody);\n+        assertTrue(responseCode == 200,\n+                String.format(\"Expected 200 response, instead received %s\", responseCode));\n+        assertTrue(body.equals(responseBody),\n+                String.format(\"Expected response %s, instead received %s\", body, responseBody));\n+    }\n+\n+    @Test\n+    public void testFixedLengthRequestWithDoubleExpect100ContinueResponse() throws Exception {\n+        String body = \"testFixedLengthRequestWithDoubleExpect100ContinueResponse\";\n+        Control control = this.control;\n+        control.response = \"HTTP\/1.1 200 OK\\r\\n\" +\n+                \"Connection: close\\r\\n\" +\n+                \"Content-Length: \" + body.length() + \"\\r\\n\" +\n+                \"\\r\\n\" +\n+                body + \"\\r\\n\";\n+        control.respondWith100Continue = true;\n+        control.write100ContinueTwice = true;\n+\n+        HttpURLConnection connection = createConnection();\n+        connection.setFixedLengthStreamingMode(body.getBytes().length);\n+        OutputStream outputStream = connection.getOutputStream();\n+        outputStream.write(body.getBytes());\n+        outputStream.close();\n+\n+        int responseCode = connection.getResponseCode();\n+        String responseBody = new String(connection.getInputStream().readAllBytes(), StandardCharsets.UTF_8).strip();\n+        System.err.println(\"response body: \" + responseBody);\n+        assertTrue(responseCode == 200,\n+                String.format(\"Expected 200 response, instead received %s\", responseCode));\n+        assertTrue(body.equals(responseBody),\n+                String.format(\"Expected response %s, instead received %s\", body, responseBody));\n+    }\n+\n+    \/\/ Creates a connection with all the common settings used in each test\n+    private HttpURLConnection createConnection() throws IOException {\n+        URL url = new URL(\"http:\/\/localhost:\" + control.serverSocket.getLocalPort());\n+\n+        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+        connection.setDoOutput(true);\n+        connection.setConnectTimeout(1000);\n+        connection.setReadTimeout(5000);\n+        connection.setUseCaches(false);\n+        connection.setInstanceFollowRedirects(false);\n+        connection.setRequestMethod(\"POST\");\n+        connection.setRequestProperty(\"Connection\", \"Close\");\n+        connection.setRequestProperty(\"Expect\", \"100-Continue\");\n+\n+        return connection;\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/HttpURLConnection\/HttpURLConnectionExpectContinueTest.java","additions":437,"deletions":0,"binary":false,"changes":437,"status":"added"}]}