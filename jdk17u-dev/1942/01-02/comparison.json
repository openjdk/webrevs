{"files":[{"patch":"@@ -103,1 +103,1 @@\n-    return query[key].value & value_mask != 0;\n+    return (query[key].value & value_mask) != 0;\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/riscv_hwprobe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -152,2 +152,12 @@\n-  int i = 0;\n-  while (_feature_list[i] != nullptr) {\n+  for (int i = 0; _feature_list[i] != nullptr; i++) {\n+    if (_feature_list[i]->feature_bit() == HWCAP_ISA_V) {\n+      \/\/ Special case for V: some dev boards only support RVV version 0.7, while\n+      \/\/ the OpenJDK only supports RVV version 1.0. These two versions are not\n+      \/\/ compatible with each other. Given the V bit is set through HWCAP on\n+      \/\/ some custom kernels, regardless of the version, it can lead to\n+      \/\/ generating V instructions on boards that don't support RVV version 1.0\n+      \/\/ (ex: Sipeed LicheePi), leading to a SIGILL.\n+      \/\/ That is an acceptable workaround as only Linux Kernel v6.5+ supports V,\n+      \/\/ and that version already support hwprobe anyway\n+      continue;\n+    }\n@@ -157,1 +167,0 @@\n-    i++;\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"}]}