{"files":[{"patch":"@@ -31,1 +31,1 @@\n-DEFAULT_VERSION_UPDATE=12\n+DEFAULT_VERSION_UPDATE=13\n@@ -36,1 +36,1 @@\n-DEFAULT_VERSION_DATE=2024-07-16\n+DEFAULT_VERSION_DATE=2024-10-15\n@@ -42,1 +42,1 @@\n-DEFAULT_PROMOTED_VERSION_PRE=\n+DEFAULT_PROMOTED_VERSION_PRE=ea\n","filename":"make\/conf\/version-numbers.conf","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,0 +59,25 @@\n+Symbol* volatile TempSymbolCleanupDelayer::_queue[QueueSize] = {};\n+volatile uint TempSymbolCleanupDelayer::_index = 0;\n+\n+\/\/ Keep this symbol alive for some time to allow for reuse.\n+\/\/ Temp symbols for the same string can often be created in quick succession,\n+\/\/ and this queue allows them to be reused instead of churning.\n+void TempSymbolCleanupDelayer::delay_cleanup(Symbol* sym) {\n+  assert(sym != nullptr, \"precondition\");\n+  sym->increment_refcount();\n+  uint i = Atomic::add(&_index, 1u) % QueueSize;\n+  Symbol* old = Atomic::xchg(&_queue[i], sym);\n+  if (old != nullptr) {\n+    old->decrement_refcount();\n+  }\n+}\n+\n+void TempSymbolCleanupDelayer::drain_queue() {\n+  for (uint i = 0; i < QueueSize; i++) {\n+    Symbol* sym = Atomic::xchg(&_queue[i], (Symbol*) nullptr);\n+    if (sym != nullptr) {\n+      sym->decrement_refcount();\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -223,1 +224,1 @@\n-      sprintf(p, \"\\\\u%04x\", c);\n+      os::snprintf_checked(p, 7, \"\\\\u%04x\", c);  \/\/ counting terminating zero in\n@@ -521,1 +522,1 @@\n-      sprintf(p, \"\\\\u%04x\", c);\n+      os::snprintf_checked(p, 7, \"\\\\u%04x\", c);\n","filename":"src\/hotspot\/share\/utilities\/utf8.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}