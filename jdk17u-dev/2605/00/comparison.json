{"files":[{"patch":"@@ -0,0 +1,277 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import javax.swing.JFileChooser;\n+\n+\/*\n+ * @test\n+ * @bug 8325179\n+ * @requires os.family == \"windows\"\n+ * @summary Verifies there's only one BasicDirectoryModel.FilesLoader thread\n+ *          at any given moment\n+ * @run main\/othervm -Djava.awt.headless=true LoaderThreadCount\n+ *\/\n+public final class LoaderThreadCount extends ThreadGroup {\n+    \/** Initial number of files. *\/\n+    private static final long NUMBER_OF_FILES = 500;\n+\n+    \/**\n+     * Number of threads running {@code fileChooser.rescanCurrentDirectory()}.\n+     *\/\n+    private static final int NUMBER_OF_THREADS = 5;\n+\n+    \/** Number of snapshots with live threads. *\/\n+    private static final int SNAPSHOTS = 20;\n+\n+    \/** The barrier to synchronise scanner threads and capturing live threads. *\/\n+    private static final CyclicBarrier start = new CyclicBarrier(NUMBER_OF_THREADS + 1);\n+\n+    \/** List of scanner threads. *\/\n+    private static final List<Thread> threads = new ArrayList<>(NUMBER_OF_THREADS);\n+\n+    \/**\n+     * Stores an exception caught by any of the threads.\n+     * If more exceptions are caught, they're added as suppressed exceptions.\n+     *\/\n+    private static final AtomicReference<Throwable> exception =\n+            new AtomicReference<>();\n+\n+    \/**\n+     * Stores an {@code IOException} thrown while removing the files.\n+     *\/\n+    private static final AtomicReference<IOException> ioException =\n+            new AtomicReference<>();\n+\n+\n+    public static void main(String[] args) throws Throwable {\n+        try {\n+            \/\/ Start the test in its own thread group to catch and handle\n+            \/\/ all thrown exceptions, in particular in\n+            \/\/ BasicDirectoryModel.FilesLoader which is created by Swing.\n+            ThreadGroup threadGroup = new LoaderThreadCount();\n+            Thread runner = new Thread(threadGroup,\n+                                       LoaderThreadCount::wrapper,\n+                                       \"Test Runner\");\n+            runner.start();\n+            runner.join();\n+        } catch (Throwable throwable) {\n+            handleException(throwable);\n+        }\n+\n+        if (ioException.get() != null) {\n+            System.err.println(\"An error occurred while removing files:\");\n+            ioException.get().printStackTrace();\n+        }\n+\n+        if (exception.get() != null) {\n+            throw exception.get();\n+        }\n+    }\n+\n+    private static void wrapper() {\n+        final long timeStart = System.currentTimeMillis();\n+        try {\n+            runTest(timeStart);\n+        } catch (Throwable throwable) {\n+            handleException(throwable);\n+        } finally {\n+            System.out.printf(\"Duration: %,d\\n\",\n+                              (System.currentTimeMillis() - timeStart));\n+        }\n+    }\n+\n+    private static void runTest(final long timeStart) throws Throwable {\n+        final Path temp = Files.createDirectory(Paths.get(\"fileChooser-concurrency-\" + timeStart));\n+\n+        try {\n+            createFiles(temp);\n+\n+            final JFileChooser fc = new JFileChooser(temp.toFile());\n+\n+            threads.addAll(Stream.generate(() -> new Thread(new Scanner(fc)))\n+                                 .limit(NUMBER_OF_THREADS)\n+                                 .toList());\n+            threads.forEach(Thread::start);\n+\n+            \/\/ Create snapshots of live threads\n+            List<Thread[]> threadsCapture =\n+                    Stream.generate(LoaderThreadCount::getThreadSnapshot)\n+                          .limit(SNAPSHOTS)\n+                          .toList();\n+\n+            threads.forEach(Thread::interrupt);\n+\n+            List<Long> loaderCount =\n+                    threadsCapture.stream()\n+                                  .map(ta -> Arrays.stream(ta)\n+                                                   .filter(Objects::nonNull)\n+                                                   .map(Thread::getName)\n+                                                   .filter(tn -> tn.startsWith(\"Basic L&F File Loading Thread\"))\n+                                                   .count())\n+                                  .filter(c -> c > 0)\n+                                  .toList();\n+\n+            if (loaderCount.isEmpty()) {\n+                throw new RuntimeException(\"Invalid results: no loader threads detected\");\n+            }\n+\n+            System.out.println(\"Number of snapshots: \" + loaderCount.size());\n+\n+            long ones = loaderCount.stream()\n+                                   .filter(n -> n == 1)\n+                                   .count();\n+            long twos = loaderCount.stream()\n+                                   .filter(n -> n == 2)\n+                                   .count();\n+            long count = loaderCount.stream()\n+                                    .filter(n -> n > 2)\n+                                    .count();\n+            System.out.println(\"Number of snapshots where number of loader threads:\");\n+            System.out.println(\"  = 1: \" + ones);\n+            System.out.println(\"  = 2: \" + twos);\n+            System.out.println(\"  > 2: \" + count);\n+            if (count > loaderCount.size() \/ 2) {\n+                throw new RuntimeException(\"Detected \" + count + \" snapshots \"\n+                                           + \"with several loading threads\");\n+            }\n+        } catch (Throwable e) {\n+            threads.forEach(Thread::interrupt);\n+            throw e;\n+        } finally {\n+            deleteFiles(temp);\n+            deleteFile(temp);\n+        }\n+    }\n+\n+    private static Thread[] getThreadSnapshot() {\n+        try {\n+            start.await();\n+            \/\/ Allow for the scanner threads to initiate re-scanning\n+            Thread.sleep(10);\n+\n+            Thread[] array = new Thread[Thread.activeCount()];\n+            Thread.currentThread()\n+                  .getThreadGroup()\n+                  .enumerate(array, false);\n+\n+            \/\/ Additional delay between captures\n+            Thread.sleep(500);\n+\n+            return array;\n+        } catch (InterruptedException | BrokenBarrierException e) {\n+            handleException(e);\n+            throw new RuntimeException(\"getThreadSnapshot is interrupted\");\n+        }\n+    }\n+\n+\n+    private LoaderThreadCount() {\n+        super(\"bdmConcurrency\");\n+    }\n+\n+    @Override\n+    public void uncaughtException(Thread t, Throwable e) {\n+        handleException(t, e);\n+    }\n+\n+    private static void handleException(Throwable throwable) {\n+        handleException(Thread.currentThread(), throwable);\n+    }\n+\n+    private static void handleException(final Thread thread,\n+                                        final Throwable throwable) {\n+        System.err.println(\"Exception in \" + thread.getName() + \": \"\n+                           + throwable.getClass()\n+                           + (throwable.getMessage() != null\n+                              ? \": \" + throwable.getMessage()\n+                              : \"\"));\n+        if (!exception.compareAndSet(null, throwable)) {\n+            exception.get().addSuppressed(throwable);\n+        }\n+        threads.stream()\n+               .filter(t -> t != thread)\n+               .forEach(Thread::interrupt);\n+    }\n+\n+\n+    private record Scanner(JFileChooser fileChooser)\n+            implements Runnable {\n+\n+        @Override\n+        public void run() {\n+            try {\n+                do {\n+                    start.await();\n+                    fileChooser.rescanCurrentDirectory();\n+                } while (!Thread.interrupted());\n+            } catch (InterruptedException | BrokenBarrierException e) {\n+                \/\/ Just exit the loop\n+            }\n+        }\n+    }\n+\n+    private static void createFiles(final Path parent) {\n+        LongStream.range(0, LoaderThreadCount.NUMBER_OF_FILES)\n+                  .mapToObj(n -> parent.resolve(n + \".file\"))\n+                  .forEach(LoaderThreadCount::createFile);\n+    }\n+\n+    private static void createFile(final Path file) {\n+        try {\n+            Files.createFile(file);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static void deleteFiles(final Path parent) throws IOException {\n+        try (var stream = Files.walk(parent)) {\n+            stream.filter(p -> p != parent)\n+                  .forEach(LoaderThreadCount::deleteFile);\n+        }\n+    }\n+\n+    private static void deleteFile(final Path file) {\n+        try {\n+            Files.delete(file);\n+        } catch (IOException e) {\n+            if (!ioException.compareAndSet(null, e)) {\n+                ioException.get().addSuppressed(e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/plaf\/basic\/BasicDirectoryModel\/LoaderThreadCount.java","additions":277,"deletions":0,"binary":false,"changes":277,"status":"added"}]}