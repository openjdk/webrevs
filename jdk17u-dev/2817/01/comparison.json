{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n@@ -34,0 +36,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -37,1 +40,3 @@\n-import java.io.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -40,0 +45,2 @@\n+import static jdk.test.lib.process.ProcessTools.*;\n+\n@@ -59,1 +66,1 @@\n-    public static void main(String[] args) throws Exception {\n+    public static void main(String[] args) throws Throwable {\n@@ -80,4 +87,2 @@\n-                String command = System.getProperty(\"java.home\") +\n-                    File.separator + \"bin\" + File.separator + \"java Assert\";\n-\n-                StringBuffer commandString = new StringBuffer(command);\n+                List<String> commands = new ArrayList<>();\n+                commands.add(\"Assert\");\n@@ -85,5 +90,2 @@\n-                    commandString.append(\" \"+switches[j]);\n-\n-                Process p = null;\n-                p = Runtime.getRuntime().exec(commandString.toString());\n-\n+                    commands.add(Integer.toString(switches[j]));\n+                OutputAnalyzer outputAnalyzer = executeCommand(createLimitedTestJavaProcessBuilder(commands));\n@@ -91,7 +93,3 @@\n-                    BufferedReader blah = new BufferedReader(\n-                                          new InputStreamReader(p.getInputStream()));\n-                    String outString = blah.readLine();\n-                    while (outString != null) {\n-                        System.out.println(\"from BufferedReader:\"+outString);\n-                        outString = blah.readLine();\n-                    }\n+                    outputAnalyzer.asLines()\n+                                  .stream()\n+                                  .forEach(s -> System.out.println(s));\n@@ -99,3 +97,1 @@\n-\n-                p.waitFor();\n-                int result = p.exitValue();\n+                int result = outputAnalyzer.getExitValue();\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/Assert.java","additions":18,"deletions":22,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires vm.flagless\n@@ -44,0 +45,2 @@\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -121,2 +124,3 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(args);\n-        int res = pb.directory(tmpFolder).inheritIO().start().waitFor();\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(args)\n+                                        .directory(tmpFolder);\n+        int res = ProcessTools.executeProcess(pb).getExitValue();\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/GetSystemPackage.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-import java.util.Map;\n@@ -47,1 +46,0 @@\n-import jdk.test.lib.JDKToolFinder;\n@@ -147,2 +145,0 @@\n-        String javapath = JDKToolFinder.getJDKTool(\"java\");\n-\n@@ -150,1 +146,0 @@\n-        cmdLine.add(javapath);\n@@ -155,12 +150,3 @@\n-\n-        System.out.println(\"Command line: \" + cmdLine);\n-        ProcessBuilder pb =\n-            new ProcessBuilder(cmdLine.stream().toArray(String[]::new));\n-\n-        \/\/ change working directory\n-        pb.directory(dir.toFile());\n-\n-        \/\/ remove CLASSPATH environment variable\n-        Map<String,String> env = pb.environment();\n-        String value = env.remove(\"CLASSPATH\");\n-\n+        ProcessBuilder pb = createTestJavaProcessBuilder(cmdLine);\n+        pb.directory(dir.toFile()); \/\/ change working directory\n+        pb.environment().remove(\"CLASSPATH\"); \/\/ remove CLASSPATH environment variable\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/getResource\/GetResource.java","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"CondyNestedResolution\");\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\"CondyNestedResolution\");\n","filename":"test\/jdk\/java\/lang\/invoke\/condy\/CondyNestedResolutionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,1 @@\n-import jdk.test.lib.JDKToolFinder;\n-import jdk.test.lib.process.ProcessTools;\n+import static jdk.test.lib.process.ProcessTools.*;\n@@ -46,1 +45,0 @@\n-    static final String JAVA_LAUNCHER = JDKToolFinder.getJDKTool(\"java\");\n@@ -62,2 +60,3 @@\n-        ProcessTools.executeCommand(JAVA_LAUNCHER, \"-cp\", classpath, TEST_MAIN_CLASS)\n-                    .shouldHaveExitValue(0);\n+        executeCommand(createTestJavaProcessBuilder(\"-cp\", classpath,\n+                                                    TEST_MAIN_CLASS))\n+                .shouldHaveExitValue(0);\n@@ -75,5 +74,4 @@\n-        ProcessTools.executeCommand(JAVA_LAUNCHER,\n-                                    \"-cp\", TEST_CLASS_PATH,\n-                                    \"-p\", modules.toString(),\n-                                    \"-m\", TEST_MODULE + \"\/\" + TEST_MAIN_CLASS)\n-                    .shouldHaveExitValue(0);\n+        executeCommand(createTestJavaProcessBuilder(\"-cp\", TEST_CLASS_PATH,\n+                                                    \"-p\", modules.toString(),\n+                                                    \"-m\", TEST_MODULE + \"\/\" + TEST_MAIN_CLASS))\n+                .shouldHaveExitValue(0);\n","filename":"test\/jdk\/java\/lang\/invoke\/findSpecial\/FindSpecialTest.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,171 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.BufferedReader;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.nio.charset.Charset;\n-import java.nio.file.Files;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n-\n-\/*\n- * support infrastructure to invoke a java class from the command line\n- *\/\n-class LUtils {\n-    static final com.sun.tools.javac.Main javac =\n-            new com.sun.tools.javac.Main();\n-    static final File cwd = new File(\".\").getAbsoluteFile();\n-    static final String JAVAHOME = System.getProperty(\"java.home\");\n-    static final boolean isWindows =\n-            System.getProperty(\"os.name\", \"unknown\").startsWith(\"Windows\");\n-    static final File JAVA_BIN_FILE = new File(JAVAHOME, \"bin\");\n-    static final File JAVA_CMD = new File(JAVA_BIN_FILE,\n-            isWindows ? \"java.exe\" : \"java\");\n-    static final File JAR_BIN_FILE = new File(JAVAHOME, \"bin\");\n-    static final File JAR_CMD = new File(JAR_BIN_FILE,\n-            isWindows ? \"jar.exe\" : \"jar\");\n-\n-    protected LUtils() {\n-    }\n-\n-    public static void compile(String... args) {\n-        if (javac.compile(args) != 0) {\n-            throw new RuntimeException(\"compilation fails\");\n-        }\n-    }\n-\n-    static void createFile(File outFile, List<String> content) {\n-        try {\n-            Files.write(outFile.getAbsoluteFile().toPath(), content,\n-                    Charset.defaultCharset());\n-        } catch (IOException ex) {\n-            throw new RuntimeException(ex);\n-        }\n-    }\n-\n-    static File getClassFile(File javaFile) {\n-        return javaFile.getName().endsWith(\".java\")\n-                ? new File(javaFile.getName().replace(\".java\", \".class\"))\n-                : null;\n-    }\n-\n-    static String getSimpleName(File inFile) {\n-        String fname = inFile.getName();\n-        return fname.substring(0, fname.indexOf(\".\"));\n-    }\n-\n-    static TestResult doExec(String... cmds) {\n-        return doExec(null, null, cmds);\n-    }\n-\n-    \/*\n-     * A method which executes a java cmd and returns the results in a container\n-     *\/\n-    static TestResult doExec(Map<String, String> envToSet,\n-            java.util.Set<String> envToRemove, String... cmds) {\n-        String cmdStr = \"\";\n-        for (String x : cmds) {\n-            cmdStr = cmdStr.concat(x + \" \");\n-        }\n-        ProcessBuilder pb = new ProcessBuilder(cmds);\n-        Map<String, String> env = pb.environment();\n-        if (envToRemove != null) {\n-            for (String key : envToRemove) {\n-                env.remove(key);\n-            }\n-        }\n-        if (envToSet != null) {\n-            env.putAll(envToSet);\n-        }\n-        BufferedReader rdr = null;\n-        try {\n-            List<String> outputList = new ArrayList<>();\n-            pb.redirectErrorStream(true);\n-            Process p = pb.start();\n-            rdr = new BufferedReader(new InputStreamReader(p.getInputStream()));\n-            String in = rdr.readLine();\n-            while (in != null) {\n-                outputList.add(in);\n-                in = rdr.readLine();\n-            }\n-            p.waitFor();\n-            p.destroy();\n-\n-            return new TestResult(cmdStr, p.exitValue(), outputList,\n-                    env, new Throwable(\"current stack of the test\"));\n-        } catch (Exception ex) {\n-            ex.printStackTrace();\n-            throw new RuntimeException(ex.getMessage());\n-        }\n-    }\n-\n-    static class TestResult {\n-        String cmd;\n-        int exitValue;\n-        List<String> testOutput;\n-        Map<String, String> env;\n-        Throwable t;\n-\n-        public TestResult(String str, int rv, List<String> oList,\n-                Map<String, String> env, Throwable t) {\n-            cmd = str;\n-            exitValue = rv;\n-            testOutput = oList;\n-            this.env = env;\n-            this.t = t;\n-        }\n-\n-        void assertZero(String message) {\n-            if (exitValue != 0) {\n-                System.err.println(this);\n-                throw new RuntimeException(message);\n-            }\n-        }\n-\n-        @Override\n-        public String toString() {\n-            StringWriter sw = new StringWriter();\n-            PrintWriter status = new PrintWriter(sw);\n-            status.println(\"Cmd: \" + cmd);\n-            status.println(\"Return code: \" + exitValue);\n-            status.println(\"Environment variable:\");\n-            for (String x : env.keySet()) {\n-                status.println(\"\\t\" + x + \"=\" + env.get(x));\n-            }\n-            status.println(\"Output:\");\n-            for (String x : testOutput) {\n-                status.println(\"\\t\" + x);\n-            }\n-            status.println(\"Exception:\");\n-            status.println(t.getMessage());\n-            t.printStackTrace(status);\n-\n-            return sw.getBuffer().toString();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LUtils.java","additions":0,"deletions":171,"binary":false,"changes":171,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n- * @summary tests DoPrivileged action (implemented as lambda expressions) by\n- * inserting them into the BootClassPath.\n+ * @library \/test\/lib\/\n@@ -31,1 +30,1 @@\n- * @compile -XDignore.symbol.file LambdaAccessControlDoPrivilegedTest.java LUtils.java\n+ * @compile LambdaAccessControlDoPrivilegedTest.java\n@@ -33,0 +32,2 @@\n+ * @summary tests DoPrivileged action (implemented as lambda expressions) by\n+ * inserting them into the BootClassPath.\n@@ -34,1 +35,6 @@\n-import java.io.File;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -37,0 +43,3 @@\n+import java.util.spi.ToolProvider;\n+\n+import static jdk.test.lib.process.ProcessTools.*;\n@@ -38,2 +47,2 @@\n-public class LambdaAccessControlDoPrivilegedTest extends LUtils {\n-    public static void main(String... args) {\n+public class LambdaAccessControlDoPrivilegedTest {\n+    public static void main(String... args) throws Exception {\n@@ -50,3 +59,3 @@\n-        File doprivJava = new File(\"DoPriv.java\");\n-        File doprivClass = getClassFile(doprivJava);\n-        createFile(doprivJava, scratch);\n+        Path doprivJava = Path.of(\"DoPriv.java\");\n+        Path doprivClass = Path.of(\"DoPriv.class\");\n+        Files.write(doprivJava, scratch, Charset.defaultCharset());\n@@ -62,3 +71,29 @@\n-        File barJava = new File(\"Bar.java\");\n-        File barClass = getClassFile(barJava);\n-        createFile(barJava, scratch);\n+        Path barJava = Path.of(\"Bar.java\");\n+        Path barClass = Path.of(\"Bar.class\");\n+        Files.write(barJava, scratch, Charset.defaultCharset());\n+\n+        compile(barJava.toString(), doprivJava.toString());\n+\n+        jar(\"cvf\", \"foo.jar\", doprivClass.toString());\n+        Files.delete(doprivJava);\n+        Files.delete(doprivClass);\n+\n+        ProcessBuilder pb = createTestJavaProcessBuilder(\n+                                \"-Xbootclasspath\/a:foo.jar\",\n+                                \"-cp\", \".\",\n+                                \"-Djava.security.manager=allow\",\n+                                \"Bar\");\n+        executeProcess(pb).shouldHaveExitValue(0);\n+\n+        Files.delete(barJava);\n+        Files.delete(barClass);\n+        Files.delete(Path.of(\"foo.jar\"));\n+    }\n+\n+    static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\").orElseThrow();\n+    static final ToolProvider JAVAC = ToolProvider.findFirst(\"javac\").orElseThrow();\n+    static void compile(String... args) throws IOException {\n+        if (JAVAC.run(System.out, System.err, args) != 0) {\n+            throw new RuntimeException(\"compilation fails\");\n+        }\n+    }\n@@ -66,9 +101,4 @@\n-        String[] javacArgs = {barJava.getName(), doprivJava.getName()};\n-        compile(javacArgs);\n-        File jarFile = new File(\"foo.jar\");\n-        String[] jargs = {\"cvf\", jarFile.getName(), doprivClass.getName()};\n-        TestResult tr = doExec(JAR_CMD.getAbsolutePath(),\n-                                \"cvf\", jarFile.getName(),\n-                                doprivClass.getName());\n-        if (tr.exitValue != 0){\n-            throw new RuntimeException(tr.toString());\n+    static void jar(String... args) {\n+        int rc = JAR_TOOL.run(System.out, System.err, args);\n+        if (rc != 0){\n+            throw new RuntimeException(\"fail to create JAR file\");\n@@ -76,11 +106,0 @@\n-        doprivJava.delete();\n-        doprivClass.delete();\n-        tr = doExec(JAVA_CMD.getAbsolutePath(),\n-                    \"-Xbootclasspath\/a:foo.jar\",\n-                    \"-cp\", \".\",\n-                    \"-Djava.security.manager=allow\",\n-                    \"Bar\");\n-        tr.assertZero(\"testDoPrivileged fails\");\n-        barJava.delete();\n-        barClass.delete();\n-        jarFile.delete();\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LambdaAccessControlDoPrivilegedTest.java","additions":52,"deletions":33,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @summary tests Lambda expression with a a security manager at top level\n@@ -29,2 +28,0 @@\n- * @compile -XDignore.symbol.file LambdaAccessControlTest.java LUtils.java\n- *\n@@ -32,0 +29,1 @@\n+ * @summary tests Lambda expression with a security manager at top level\n@@ -34,1 +32,1 @@\n-public class LambdaAccessControlTest extends LUtils {\n+public class LambdaAccessControlTest {\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LambdaAccessControlTest.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,2 +27,1 @@\n- * @summary ensures that j.l.i.InvokerByteCodeGenerator and ASM visitMethodInsn\n- * generate  bytecodes with correct constant pool references\n+ * @library \/test\/lib\/\n@@ -32,1 +31,1 @@\n- * @compile -XDignore.symbol.file LambdaAsm.java LUtils.java\n+ * @compile LambdaAsm.java\n@@ -34,0 +33,2 @@\n+ * @summary ensures that j.l.i.InvokerByteCodeGenerator and ASM visitMethodInsn\n+ * generate  bytecodes with correct constant pool references\n@@ -43,1 +44,3 @@\n-import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n@@ -49,0 +52,2 @@\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -52,0 +57,1 @@\n+import static jdk.test.lib.process.ProcessTools.*;\n@@ -54,0 +60,3 @@\n+    static final Path DUMP_LAMBDA_PROXY_CLASS_FILES = Path.of(\"DUMP_LAMBDA_PROXY_CLASS_FILES\");\n+    static final Path SRC = Path.of(\"src\");\n+    static final Path CLASSES = Path.of(\"classes\");\n@@ -55,3 +64,1 @@\n-    static final File TestFile = new File(\"A.java\");\n-\n-    static void init() {\n+    static void init() throws Exception {\n@@ -59,8 +66,5 @@\n-        LUtils.compile(TestFile.getName());\n-        LUtils.TestResult tr = LUtils.doExec(LUtils.JAVA_CMD.getAbsolutePath(),\n-                \"-Djdk.internal.lambda.dumpProxyClasses=.\",\n-                \"-cp\", \".\", \"A\");\n-        if (tr.exitValue != 0) {\n-            System.out.println(\"Error: \" + tr.toString());\n-            throw new RuntimeException(\"could not create proxy classes\");\n-        }\n+        CompilerUtils.compile(SRC, CLASSES);\n+        OutputAnalyzer outputAnalyzer = executeProcess(createTestJavaProcessBuilder(\n+                \"-Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles=true\",\n+                \"-cp\", CLASSES.toString(), \"A\"));\n+        outputAnalyzer.shouldHaveExitValue(0);\n@@ -69,1 +73,1 @@\n-    static void emitCode() {\n+    static void emitCode() throws IOException {\n@@ -91,1 +95,4 @@\n-        LUtils.createFile(TestFile, scratch);\n+\n+        Path testFile = SRC.resolve(\"A.java\");\n+        Files.createDirectories(SRC);\n+        Files.write(testFile, scratch, Charset.defaultCharset());\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LambdaAsm.java","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Synthetic frames should be hidden in exceptions\n+ * @library \/test\/lib\/\n@@ -30,1 +30,1 @@\n- * @compile -XDignore.symbol.file LUtils.java LambdaStackTrace.java\n+ * @compile LambdaStackTrace.java\n@@ -32,0 +32,1 @@\n+ * @summary Synthetic frames should be hidden in exceptions\n@@ -35,0 +36,1 @@\n+import jdk.test.lib.compiler.CompilerUtils;\n@@ -36,2 +38,0 @@\n-import java.io.File;\n-import java.io.FileOutputStream;\n@@ -41,0 +41,3 @@\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -50,1 +53,1 @@\n-    static File classes = new File(System.getProperty(\"test.classes\"));\n+    static Path CLASSES = Path.of(System.getProperty(\"test.classes\", \".\"));\n@@ -124,6 +127,2 @@\n-        try (FileOutputStream fw = new FileOutputStream(new File(classes, \"Maker.class\"))) {\n-            fw.write(generateMaker());\n-        }\n-        try (FileOutputStream fw = new FileOutputStream(new File(classes, \"StringMaker.class\"))) {\n-            fw.write(generateStringMaker());\n-        }\n+        Files.write(CLASSES.resolve(\"Maker.class\"), generateMaker());\n+        Files.write(CLASSES.resolve(\"StringMaker.class\"), generateStringMaker());\n@@ -157,1 +156,1 @@\n-    static void emitCode(File f) {\n+    static void emitCode(Path file) throws IOException {\n@@ -169,1 +168,2 @@\n-        LUtils.createFile(f, scratch);\n+\n+        Files.write(file, scratch, Charset.defaultCharset());\n@@ -172,2 +172,5 @@\n-    static void compileCaller() {\n-        File caller = new File(classes, \"Caller.java\");\n+    static void compileCaller() throws IOException {\n+        Path src = Path.of(\"src\");\n+        Files.createDirectories(src);\n+\n+        Path caller = src.resolve(\"Caller.java\");\n@@ -175,1 +178,1 @@\n-        LUtils.compile(\"-cp\", classes.getAbsolutePath(), \"-d\", classes.getAbsolutePath(), caller.getAbsolutePath());\n+        CompilerUtils.compile(src, CLASSES, \"-cp\", CLASSES.toAbsolutePath().toString());\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LambdaStackTrace.java","additions":19,"deletions":16,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -26,2 +26,3 @@\n- * @bug 8023524\n- * @summary tests logging generated classes for lambda\n+ * @bug 8023524 8304846\n+ * @requires vm.flagless\n+ * @library \/test\/lib\/\n@@ -32,0 +33,1 @@\n+ * @summary tests logging generated classes for lambda\n@@ -33,1 +35,0 @@\n-import java.io.File;\n@@ -35,0 +36,1 @@\n+import java.nio.charset.Charset;\n@@ -43,0 +45,2 @@\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -46,1 +50,0 @@\n-import org.testng.SkipException;\n@@ -49,0 +52,1 @@\n+import static jdk.test.lib.process.ProcessTools.*;\n@@ -53,1 +57,3 @@\n-public class LogGeneratedClassesTest extends LUtils {\n+public class LogGeneratedClassesTest {\n+    static final Path DUMP_LAMBDA_PROXY_CLASS_FILES = Path.of(\"DUMP_LAMBDA_PROXY_CLASS_FILES\");\n+    static final Path CLASSES = Path.of(\"classes\").toAbsolutePath();\n@@ -76,3 +82,2 @@\n-        File test = new File(\"TestLambda.java\");\n-        createFile(test, scratch);\n-        compile(\"-d\", \".\", test.getName());\n+        Path testLambda = Path.of(\"TestLambda.java\");\n+        Files.write(testLambda, scratch, Charset.defaultCharset());\n@@ -93,3 +98,2 @@\n-        test = new File(\"LongPackageName.java\");\n-        createFile(test, scratch);\n-        compile(\"-d\", \".\", test.getName());\n+        Path lpnTest = Path.of(\"LongPackageName.java\");\n+        Files.write(lpnTest, scratch, Charset.defaultCharset());\n@@ -102,0 +106,1 @@\n+        CompilerUtils.compile(Path.of(\".\"), CLASSES);\n@@ -115,3 +120,3 @@\n-    public void testNotLogging() {\n-        TestResult tr = doExec(JAVA_CMD.getAbsolutePath(),\n-                               \"-cp\", \".\",\n+    public void testNotLogging() throws Exception {\n+        ProcessBuilder pb = createLimitedTestJavaProcessBuilder(\n+                               \"-cp\", CLASSES.toString(),\n@@ -120,1 +125,1 @@\n-        tr.assertZero(\"Should still return 0\");\n+        executeProcess(pb).shouldHaveExitValue(0);\n@@ -124,4 +129,6 @@\n-    public void testLogging() throws IOException {\n-        assertTrue(Files.exists(Paths.get(\"dump\")));\n-        TestResult tr = doExec(JAVA_CMD.getAbsolutePath(),\n-                               \"-cp\", \".\",\n+    public void testLogging() throws Exception {\n+        Path testDir = Path.of(\"dump\");\n+        Path dumpDir = testDir.resolve(DUMP_LAMBDA_PROXY_CLASS_FILES);\n+        Files.createDirectory(testDir);\n+        ProcessBuilder pb = createLimitedTestJavaProcessBuilder(\n+                               \"-cp\", CLASSES.toString(),\n@@ -129,2 +136,4 @@\n-                               \"-Djdk.internal.lambda.dumpProxyClasses=dump\",\n-                               \"com.example.TestLambda\");\n+                               \"-Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles\",\n+                               \"com.example.TestLambda\").directory(testDir.toFile());\n+        executeProcess(pb).shouldHaveExitValue(0);\n+\n@@ -137,2 +146,1 @@\n-                2, \"Two lambda captured\");\n-        tr.assertZero(\"Should still return 0\");\n+                        2, \"Two lambda captured\");\n@@ -142,13 +150,21 @@\n-    public void testDumpDirNotExist() throws IOException {\n-        assertFalse(Files.exists(Paths.get(\"notExist\")));\n-        TestResult tr = doExec(JAVA_CMD.getAbsolutePath(),\n-                               \"-cp\", \".\",\n-                               \"-Djava.security.manager=allow\",\n-                               \"-Djdk.internal.lambda.dumpProxyClasses=notExist\",\n-                               \"com.example.TestLambda\");\n-        assertEquals(tr.testOutput.stream()\n-                                  .filter(s -> s.startsWith(\"WARNING\"))\n-                                  .filter(s -> s.contains(\"does not exist\"))\n-                                  .count(),\n-                     1, \"only show error once\");\n-        tr.assertZero(\"Should still return 0\");\n+    public void testDumpDirNotExist() throws Exception {\n+        Path testDir = Path.of(\"NotExist\");\n+        Path dumpDir = testDir.resolve(DUMP_LAMBDA_PROXY_CLASS_FILES);\n+        Files.createDirectory(testDir);\n+        TestUtil.removeAll(dumpDir);\n+        assertFalse(Files.exists(dumpDir));\n+\n+        ProcessBuilder pb = createLimitedTestJavaProcessBuilder(\n+                                \"-cp\", CLASSES.toString(),\n+                                \"-Djava.security.manager=allow\",\n+                                \"-Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles\",\n+                                \"com.example.TestLambda\").directory(testDir.toFile());\n+        executeProcess(pb).shouldHaveExitValue(0);\n+\n+        \/\/ The dump directory will be created if not exist\n+        assertEquals(Files.find(\n+                        dumpDir,\n+                        99,\n+                        (p, a) -> p.startsWith(dumpDir.resolve(\"com\/example\"))\n+                                && a.isRegularFile()).count(),\n+                        2, \"Two lambda captured\");\n@@ -158,13 +174,14 @@\n-    public void testDumpDirIsFile() throws IOException {\n-        assertTrue(Files.isRegularFile(Paths.get(\"file\")));\n-        TestResult tr = doExec(JAVA_CMD.getAbsolutePath(),\n-                               \"-cp\", \".\",\n-                               \"-Djava.security.manager=allow\",\n-                               \"-Djdk.internal.lambda.dumpProxyClasses=file\",\n-                               \"com.example.TestLambda\");\n-        assertEquals(tr.testOutput.stream()\n-                                  .filter(s -> s.startsWith(\"WARNING\"))\n-                                  .filter(s -> s.contains(\"not a directory\"))\n-                                  .count(),\n-                     1, \"only show error once\");\n-        tr.assertZero(\"Should still return 0\");\n+    public void testDumpDirIsFile() throws Exception {\n+        Path testDir = Path.of(\"notDir\");\n+        Path dumpFile = testDir.resolve(DUMP_LAMBDA_PROXY_CLASS_FILES);\n+        Files.createDirectory(testDir);\n+        Files.createFile(dumpFile);\n+        assertTrue(Files.isRegularFile(dumpFile));\n+        ProcessBuilder pb = createLimitedTestJavaProcessBuilder(\n+                                \"-cp\", CLASSES.toString(),\n+                                \"-Djava.security.manager=allow\",\n+                                \"-Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles\",\n+                                \"com.example.TestLambda\").directory(testDir.toFile());\n+        executeProcess(pb)\n+                .shouldContain(\"DUMP_LAMBDA_PROXY_CLASS_FILES is not a directory\")\n+                .shouldNotHaveExitValue(0);\n@@ -197,1 +214,1 @@\n-    public void testDumpDirNotWritable() throws IOException {\n+    public void testDumpDirNotWritable() throws Exception {\n@@ -219,2 +236,2 @@\n-            TestResult tr = doExec(JAVA_CMD.getAbsolutePath(),\n-                                   \"-cp\", \".\",\n+            ProcessBuilder pb = createLimitedTestJavaProcessBuilder(\n+                                   \"-cp\", CLASSES.toString(),\n@@ -222,8 +239,5 @@\n-                                   \"-Djdk.internal.lambda.dumpProxyClasses=readOnly\",\n-                                   \"com.example.TestLambda\");\n-            assertEquals(tr.testOutput.stream()\n-                                      .filter(s -> s.startsWith(\"WARNING\"))\n-                                      .filter(s -> s.contains(\"not writable\"))\n-                                      .count(),\n-                         1, \"only show error once\");\n-            tr.assertZero(\"Should still return 0\");\n+                                   \"-Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles\",\n+                                   \"com.example.TestLambda\").directory(testDir.toFile());\n+            executeProcess(pb)\n+                    .shouldContain(\"DUMP_LAMBDA_PROXY_CLASS_FILES is not writable\")\n+                    .shouldNotHaveExitValue(0);\n@@ -236,8 +250,13 @@\n-    public void testLoggingException() throws IOException {\n-        assertTrue(Files.exists(Paths.get(\"dumpLong\")));\n-        TestResult tr = doExec(JAVA_CMD.getAbsolutePath(),\n-                               \"-cp\", \".\",\n-                                \"-Djava.security.manager=allow\",\n-                               \"-Djdk.internal.lambda.dumpProxyClasses=dumpLong\",\n-                               longFQCN);\n-        assertEquals(tr.testOutput.stream()\n+    public void testLoggingException() throws Exception {\n+        Path testDir = Path.of(\"dumpLong\");\n+        Path dumpDir = testDir.resolve(DUMP_LAMBDA_PROXY_CLASS_FILES);\n+        Files.createDirectories(dumpDir.resolve(\"com\/example\/nonsense\"));\n+        Files.createFile(dumpDir.resolve(\"com\/example\/nonsense\/nonsense\"));\n+        ProcessBuilder pb = createLimitedTestJavaProcessBuilder(\n+                               \"-cp\", CLASSES.toString(),\n+                               \"-Djava.security.manager=allow\",\n+                               \"-Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles\",\n+                               longFQCN).directory(testDir.toFile());\n+        OutputAnalyzer outputAnalyzer = executeProcess(pb);\n+        outputAnalyzer.shouldHaveExitValue(0);\n+        assertEquals(outputAnalyzer.asLines().stream()\n@@ -264,1 +283,0 @@\n-        tr.assertZero(\"Should still return 0\");\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LogGeneratedClassesTest.java","additions":87,"deletions":69,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,0 @@\n-import java.io.File;\n-import java.util.Map;\n@@ -40,5 +38,1 @@\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n+import jdk.test.lib.process.ProcessTools;\n@@ -47,18 +41,5 @@\n-    public static void main(String[] args) throws IOException {\n-        Path launcher = Paths.get(System.getProperty(\"test.nativepath\"), \"CallerAccessTest\");\n-        ProcessBuilder pb = new ProcessBuilder(launcher.toString());\n-        Map<String, String> env = pb.environment();\n-\n-        String libDir = Platform.libDir().toString();\n-        String vmDir = Platform.jvmLibDir().toString();\n-\n-        \/\/ set up shared library path\n-        String sharedLibraryPathEnvName = Platform.sharedLibraryPathVariableName();\n-        env.compute(sharedLibraryPathEnvName,\n-                    (k, v) -> (v == null) ? libDir : v + File.pathSeparator + libDir);\n-        env.compute(sharedLibraryPathEnvName,\n-                    (k, v) -> (v == null) ? vmDir : v + File.pathSeparator + vmDir);\n-\n-        System.out.println(\"Launching: \" + launcher + \" shared library path: \" +\n-                           env.get(sharedLibraryPathEnvName));\n-        new OutputAnalyzer(pb.start()).shouldHaveExitValue(0);\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createNativeTestProcessBuilder(\"CallerAccessTest\");\n+        System.out.println(\"Launching: \" + pb.command() + \" shared library path: \" +\n+                           pb.environment().get(Platform.sharedLibraryPathVariableName()));\n+        ProcessTools.executeProcess(pb).shouldHaveExitValue(0);\n","filename":"test\/jdk\/java\/lang\/reflect\/exeCallerAccessTest\/CallerAccessTest.java","additions":7,"deletions":26,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.test.lib.JDKToolFinder;\n@@ -37,2 +36,0 @@\n- * @summary Verify that an application can be launched when the classpath contains large number of\n- *          jars and the java.protocol.handler.pkgs system property is set\n@@ -43,0 +40,2 @@\n+ * @summary Verify that an application can be launched when the classpath contains large number of\n+ *          jars and the java.protocol.handler.pkgs system property is set\n@@ -129,2 +128,1 @@\n-        String java = JDKToolFinder.getJDKTool(\"java\");\n-        ProcessBuilder pb = new ProcessBuilder(java,\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n","filename":"test\/jdk\/jdk\/internal\/loader\/URLClassPath\/LargeClasspathWithPkgPrefix.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @summary Basic test of VM::getRuntimeArguments\n+ * @requires vm.flagless\n@@ -31,0 +31,1 @@\n+ * @summary Basic test of VM::getRuntimeArguments\n@@ -43,1 +44,24 @@\n-    static final String TEST_CLASSES = System.getProperty(\"test.classes\");\n+    static final List<String> VM_OPTIONS = getInitialOptions();\n+\n+    \/*\n+     * Read jdk\/internal\/vm\/options resource from the runtime image.\n+     * If present, the runtime image was created with jlink --add-options and\n+     * the java launcher launches the application as if\n+     *   $ java @options <app>\n+     * The VM options listed in the jdk\/internal\/vm\/options resource file\n+     * are passed to the VM.\n+     *\/\n+    static List<String> getInitialOptions() {\n+        ModuleReference mref = ModuleFinder.ofSystem().find(\"java.base\").orElseThrow();\n+        try (ModuleReader reader = mref.open()) {\n+            InputStream in = reader.open(\"jdk\/internal\/vm\/options\").orElse(null);\n+            if (in != null) {\n+                \/\/ support the simplest form for now: whitespace-separated\n+                return List.of(new String(in.readAllBytes()).split(\"\\s\"));\n+            } else {\n+                return List.of();\n+            }\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n@@ -85,8 +109,8 @@\n-        \/\/ launch a test program\n-        \/\/ $ java <runtime-arguments> -classpath <cpath> RuntimeArguments <expected>\n-\n-        Stream<String> options = Stream.concat(args.stream(),\n-            Stream.of(\"-classpath\", TEST_CLASSES, \"RuntimeArguments\"));\n-\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-            Stream.concat(options, expected.stream())\n+        \/\/ launch a test program with classpath set by ProcessTools::createLimitedTestJavaProcessBuilder\n+        \/\/ $ java <args> RuntimeArguments <vm_options> <expected>\n+        Stream<String> options = Stream.concat(args.stream(), Stream.of(\"RuntimeArguments\"));\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \/\/ The runtime image may be created with jlink --add-options\n+            \/\/ The initial VM options will be included in the result\n+            \/\/ returned by VM.getRuntimeArguments()\n+            Stream.concat(options, Stream.concat(VM_OPTIONS.stream(), expected.stream()))\n","filename":"test\/jdk\/jdk\/internal\/misc\/VM\/RuntimeArguments.java","additions":34,"deletions":10,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary Ensure no incubator modules are resolved by default in the image\n+ * @requires vm.flagless\n@@ -32,0 +32,1 @@\n+ * @summary Ensure no incubator modules are resolved by default in the image\n@@ -46,0 +47,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -111,2 +113,0 @@\n-        String[] options = Stream.concat(Stream.of(getJava()), Stream.of(opts))\n-                .toArray(String[]::new);\n@@ -114,1 +114,1 @@\n-        ProcessBuilder pb = new ProcessBuilder(options);\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(opts);\n@@ -158,9 +158,0 @@\n-    static String getJava() {\n-        Path image = Paths.get(JAVA_HOME);\n-        boolean isWindows = System.getProperty(\"os.name\").startsWith(\"Windows\");\n-        Path java = image.resolve(\"bin\").resolve(isWindows ? \"java.exe\" : \"java\");\n-        if (Files.notExists(java))\n-            throw new RuntimeException(java + \" not found\");\n-        return java.toAbsolutePath().toString();\n-    }\n-\n","filename":"test\/jdk\/jdk\/modules\/incubator\/DefaultImage.java","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary Basic test for incubator modules in jmods and images\n+ * @requires vm.flagless\n@@ -35,0 +35,1 @@\n+ * @summary Basic test for incubator modules in jmods and images\n","filename":"test\/jdk\/jdk\/modules\/incubator\/ImageModules.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}