{"files":[{"patch":"@@ -108,0 +108,3 @@\n+     * If obuffer is null\/zero-sized, do not allocate a new buffer.\n+     * This reduces allocation for AEAD ciphers that never return data from update\n+     *\n@@ -111,0 +114,3 @@\n+        if (obuffer == null || obuffer.length == 0) {\n+            return;\n+        }\n@@ -112,1 +118,1 @@\n-        if (obuffer == null || obuffer.length < minLen) {\n+        if (obuffer.length < minLen) {\n@@ -145,1 +151,6 @@\n-                ofinish = cipher.doFinal(obuffer, 0);\n+                if (obuffer != null && obuffer.length > 0) {\n+                    ofinish = cipher.doFinal(obuffer, 0);\n+                } else {\n+                    obuffer = cipher.doFinal();\n+                    ofinish = obuffer.length;\n+                }\n@@ -158,1 +169,8 @@\n-            ofinish = cipher.update(ibuffer, 0, readin, obuffer, ostart);\n+            \/\/ initial obuffer is assigned by update\/doFinal;\n+            \/\/ for AEAD ciphers, obuffer is always null or zero-length here\n+            if (obuffer != null && obuffer.length > 0) {\n+                ofinish = cipher.update(ibuffer, 0, readin, obuffer, ostart);\n+            } else {\n+                obuffer = cipher.update(ibuffer, 0, readin);\n+                ofinish = (obuffer != null) ? obuffer.length : 0;\n+            }\n@@ -345,1 +363,5 @@\n-                cipher.doFinal(obuffer, 0);\n+                if (obuffer != null && obuffer.length > 0) {\n+                    cipher.doFinal(obuffer, 0);\n+                } else {\n+                    cipher.doFinal();\n+                }\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/CipherInputStream.java","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.crypto.full;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.CipherInputStream;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStream;\n+\n+\/**\n+ * This performance test runs AES\/GCM encryption and decryption using CipherInputStream.\n+ *\n+ * This test rotates the IV and creates a new GCMParameterSpec for each encrypt\n+ * benchmark operation\n+ *\/\n+\n+public class AESGCMCipherInputStream extends CryptoBase {\n+\n+    @Param({\"128\"})\n+    private int keyLength;\n+\n+    @Param({\"16384\", \"1048576\"})\n+    private int dataSize;\n+\n+    byte[] encryptedData;\n+    byte[] in;\n+    ByteArrayOutputStream out;\n+    private Cipher encryptCipher;\n+    private Cipher decryptCipher;\n+    SecretKeySpec ks;\n+    GCMParameterSpec gcm_spec;\n+    byte[] iv;\n+\n+    private static final int IV_BUFFER_SIZE = 32;\n+    private static final int IV_MODULO = IV_BUFFER_SIZE - 16;\n+    int iv_index = 0;\n+\n+    private int next_iv_index() {\n+        int r = iv_index;\n+        iv_index = (iv_index + 1) % IV_MODULO;\n+        return r;\n+    }\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        setupProvider();\n+\n+        \/\/ Setup key material\n+        byte[] keystring = fillSecureRandom(new byte[keyLength \/ 8]);\n+        ks = new SecretKeySpec(keystring, \"AES\");\n+        iv = fillSecureRandom(new byte[IV_BUFFER_SIZE]);\n+        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n+\n+        \/\/ Setup Cipher classes\n+        encryptCipher = makeCipher(prov, \"AES\/GCM\/NoPadding\");\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n+        decryptCipher = makeCipher(prov, \"AES\/GCM\/NoPadding\");\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+            encryptCipher.getParameters().\n+                getParameterSpec(GCMParameterSpec.class));\n+\n+        \/\/ Setup input\/output buffers\n+        in = fillRandom(new byte[dataSize]);\n+        encryptedData = new byte[encryptCipher.getOutputSize(in.length)];\n+        out = new ByteArrayOutputStream(encryptedData.length);\n+        encryptCipher.doFinal(in, 0, in.length, encryptedData, 0);\n+    }\n+\n+    @Benchmark\n+    public byte[] encrypt() throws Exception {\n+        out.reset();\n+        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n+        ByteArrayInputStream fin = new ByteArrayInputStream(in);\n+        InputStream cin = new CipherInputStream(fin, encryptCipher);\n+\n+        cin.transferTo(out);\n+        return out.toByteArray();\n+    }\n+\n+    @Benchmark\n+    public byte[] decrypt() throws Exception {\n+        out.reset();\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+                encryptCipher.getParameters().\n+                        getParameterSpec(GCMParameterSpec.class));\n+        ByteArrayInputStream fin = new ByteArrayInputStream(encryptedData);\n+        InputStream cin = new CipherInputStream(fin, decryptCipher);\n+\n+        cin.transferTo(out);\n+        return out.toByteArray();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/AESGCMCipherInputStream.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"}]}