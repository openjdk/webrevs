{"files":[{"patch":"@@ -1045,37 +1045,13 @@\n-            Collection<String> checkedKeyTypes = new HashSet<>();\n-            List<String> supportedKeyTypes = new ArrayList<>();\n-            for (SignatureScheme ss : hc.peerRequestedCertSignSchemes) {\n-                if (checkedKeyTypes.contains(ss.keyAlgorithm)) {\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                        SSLLogger.warning(\n-                            \"Unsupported authentication scheme: \" + ss.name);\n-                    }\n-                    continue;\n-                }\n-                checkedKeyTypes.add(ss.keyAlgorithm);\n-\n-                \/\/ Don't select a signature scheme unless we will be able to\n-                \/\/ produce a CertificateVerify message later\n-                if (SignatureScheme.getPreferableAlgorithm(\n-                        hc.algorithmConstraints,\n-                        hc.peerRequestedSignatureSchemes,\n-                        ss, hc.negotiatedProtocol) == null) {\n-\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                        SSLLogger.warning(\n-                            \"Unable to produce CertificateVerify for \" +\n-                            \"signature scheme: \" + ss.name);\n-                    }\n-                    continue;\n-                }\n-\n-                X509Authentication ka = X509Authentication.valueOf(ss);\n-                if (ka == null) {\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                        SSLLogger.warning(\n-                            \"Unsupported authentication scheme: \" + ss.name);\n-                    }\n-                    continue;\n-                }\n-                supportedKeyTypes.add(ss.keyAlgorithm);\n-            }\n+            String[] supportedKeyTypes = hc.peerRequestedCertSignSchemes\n+                    .stream()\n+                    .map(ss -> ss.keyAlgorithm)\n+                    .distinct()\n+                    .filter(ka -> SignatureScheme.getPreferableAlgorithm(   \/\/ Don't select a signature scheme unless\n+                            hc.algorithmConstraints,                        \/\/  we will be able to produce\n+                            hc.peerRequestedSignatureSchemes,               \/\/  a CertificateVerify message later\n+                            ka, hc.negotiatedProtocol) != null\n+                            || SSLLogger.logWarning(\"ssl,handshake\",\n+                                    \"Unable to produce CertificateVerify for key algorithm: \" + ka))\n+                    .filter(ka -> X509Authentication.valueOfKeyAlgorithm(ka) != null\n+                            || SSLLogger.logWarning(\"ssl,handshake\", \"Unsupported key algorithm: \" + ka))\n+                    .toArray(String[]::new);\n@@ -1084,1 +1060,1 @@\n-                    .createPossession(hc, supportedKeyTypes.toArray(String[]::new));\n+                    .createPossession(hc, supportedKeyTypes);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateMessage.java","additions":14,"deletions":38,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.util.Collection;\n@@ -37,1 +36,0 @@\n-import java.util.HashSet;\n@@ -763,50 +761,19 @@\n-            Collection<String> checkedKeyTypes = new HashSet<>();\n-            List<String> supportedKeyTypes = new ArrayList<>();\n-            for (SignatureScheme ss : hc.peerRequestedCertSignSchemes) {\n-                if (checkedKeyTypes.contains(ss.keyAlgorithm)) {\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                        SSLLogger.warning(\n-                            \"Unsupported authentication scheme: \" + ss.name);\n-                    }\n-                    continue;\n-                }\n-                checkedKeyTypes.add(ss.keyAlgorithm);\n-\n-                \/\/ Don't select a signature scheme unless we will be able to\n-                \/\/ produce a CertificateVerify message later\n-                if (SignatureScheme.getPreferableAlgorithm(\n-                        hc.algorithmConstraints,\n-                        hc.peerRequestedSignatureSchemes,\n-                        ss, hc.negotiatedProtocol) == null) {\n-\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                        SSLLogger.warning(\n-                            \"Unable to produce CertificateVerify for \" +\n-                            \"signature scheme: \" + ss.name);\n-                    }\n-                    continue;\n-                }\n-\n-                X509Authentication ka = X509Authentication.valueOf(ss);\n-                if (ka == null) {\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                        SSLLogger.warning(\n-                            \"Unsupported authentication scheme: \" + ss.name);\n-                    }\n-                    continue;\n-                } else {\n-                    \/\/ Any auth object will have a set of allowed key types.\n-                    \/\/ This set should share at least one common algorithm with\n-                    \/\/ the CR's allowed key types.\n-                    if (Collections.disjoint(crKeyTypes,\n-                            Arrays.asList(ka.keyTypes))) {\n-                        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                            SSLLogger.warning(\n-                                    \"Unsupported authentication scheme: \" +\n-                                            ss.name);\n-                        }\n-                        continue;\n-                    }\n-                }\n-                supportedKeyTypes.add(ss.keyAlgorithm);\n-            }\n+            String[] supportedKeyTypes = hc.peerRequestedCertSignSchemes\n+                    .stream()\n+                    .map(ss -> ss.keyAlgorithm)\n+                    .distinct()\n+                    .filter(ka -> SignatureScheme.getPreferableAlgorithm(   \/\/ Don't select a signature scheme unless\n+                            hc.algorithmConstraints,                        \/\/  we will be able to produce\n+                            hc.peerRequestedSignatureSchemes,               \/\/  a CertificateVerify message later\n+                            ka, hc.negotiatedProtocol) != null\n+                            || SSLLogger.logWarning(\"ssl,handshake\",\n+                                    \"Unable to produce CertificateVerify for key algorithm: \" + ka))\n+                    .filter(ka -> {\n+                        var xa = X509Authentication.valueOfKeyAlgorithm(ka);\n+                        \/\/ Any auth object will have a set of allowed key types.\n+                        \/\/ This set should share at least one common algorithm with\n+                        \/\/ the CR's allowed key types.\n+                        return xa != null && !Collections.disjoint(crKeyTypes, Arrays.asList(xa.keyTypes))\n+                                || SSLLogger.logWarning(\"ssl,handshake\", \"Unsupported key algorithm: \" + ka);\n+                    })\n+                    .toArray(String[]::new);\n@@ -815,1 +782,1 @@\n-                    .createPossession(hc, supportedKeyTypes.toArray(String[]::new));\n+                    .createPossession(hc, supportedKeyTypes);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateRequest.java","additions":20,"deletions":53,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -213,0 +213,9 @@\n+    \/\/ Logs a warning message and always returns false. This method\n+    \/\/ can be used as an OR Predicate to add a log in a stream filter.\n+    public static boolean logWarning(String option, String s) {\n+        if (SSLLogger.isOn && SSLLogger.isOn(option)) {\n+            SSLLogger.warning(s);\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLLogger.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -458,1 +458,1 @@\n-            SignatureScheme certScheme,\n+            String keyAlgorithm,\n@@ -464,1 +464,1 @@\n-                    certScheme.keyAlgorithm.equalsIgnoreCase(ss.keyAlgorithm) &&\n+                    keyAlgorithm.equalsIgnoreCase(ss.keyAlgorithm) &&\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureScheme.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    static X509Authentication valueOf(SignatureScheme signatureScheme) {\n+    static X509Authentication valueOfKeyAlgorithm(String keyAlgorithm) {\n@@ -77,1 +77,1 @@\n-            if (au.keyAlgorithm.equals(signatureScheme.keyAlgorithm)) {\n+            if (au.keyAlgorithm.equals(keyAlgorithm)) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509Authentication.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}