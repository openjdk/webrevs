{"files":[{"patch":"@@ -186,0 +186,1 @@\n+JVM_ReportFinalizationComplete\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+#include \"services\/finalizerService.hpp\"\n@@ -1606,1 +1607,1 @@\n-\n+      MANAGEMENT_ONLY(FinalizerService::purge_unloaded();)\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -756,0 +756,6 @@\n+\/*\n+ * java.lang.ref.Finalizer\n+ *\/\n+JNIEXPORT void JNICALL\n+JVM_ReportFinalizationComplete(JNIEnv *env, jobject finalizee);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-static bool find_field(InstanceKlass* ik,\n+static bool find_field(const InstanceKlass* ik,\n@@ -398,1 +398,1 @@\n-static void lookup_field(JfrJavaArguments* args, InstanceKlass* klass, fieldDescriptor* fd, bool static_field) {\n+static void lookup_field(JfrJavaArguments* args, const InstanceKlass* ik, fieldDescriptor* fd, bool static_field) {\n@@ -400,2 +400,2 @@\n-  assert(klass != NULL, \"invariant\");\n-  assert(klass->is_initialized(), \"invariant\");\n+  assert(ik != NULL, \"invariant\");\n+  assert(ik->is_initialized(), \"invariant\");\n@@ -403,1 +403,12 @@\n-  find_field(klass, args->name(), args->signature(), fd, static_field, true);\n+  find_field(ik, args->name(), args->signature(), fd, static_field, true);\n+}\n+\n+static void read_field(JfrJavaArguments* args, JavaValue* result, Thread* thread) {\n+  const bool static_field = !args->has_receiver();\n+  fieldDescriptor fd;\n+  const InstanceKlass* const ik = static_cast<InstanceKlass*>(args->klass());\n+  lookup_field(args, ik, &fd, static_field);\n+  assert(fd.offset() > 0, \"invariant\");\n+  HandleMark hm(thread);\n+  Handle h_oop(static_field ? Handle(thread, ik->java_mirror()) : Handle(thread, args->receiver()));\n+  read_specialized_field(result, h_oop, &fd);\n@@ -410,1 +421,0 @@\n-\n@@ -413,8 +423,1 @@\n-  const bool static_field = !args->has_receiver();\n-  fieldDescriptor fd;\n-  lookup_field(args, klass, &fd, static_field);\n-  assert(fd.offset() > 0, \"invariant\");\n-\n-  HandleMark hm(THREAD);\n-  Handle h_oop(static_field ? Handle(THREAD, klass->java_mirror()) : Handle(THREAD, args->receiver()));\n-  read_specialized_field(result, h_oop, &fd);\n+  read_field(args, result, static_cast<Thread*>(THREAD));\n@@ -451,0 +454,5 @@\n+void JfrJavaSupport::get_field(JfrJavaArguments* args, Thread* thread) {\n+  assert(args != NULL, \"invariant\");\n+  read_field(args, args->result(), thread);\n+}\n+\n@@ -490,1 +498,1 @@\n-static char* allocate_string(bool c_heap, int length, JavaThread* jt) {\n+static char* allocate_string(bool c_heap, int length, Thread* thread) {\n@@ -492,1 +500,1 @@\n-                  NEW_RESOURCE_ARRAY_IN_THREAD(jt, char, length);\n+                  NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, length);\n@@ -495,2 +503,1 @@\n-const char* JfrJavaSupport::c_str(oop string, JavaThread* t, bool c_heap \/* false *\/) {\n-  DEBUG_ONLY(check_java_thread_in_vm(t));\n+const char* JfrJavaSupport::c_str(oop string, Thread* thread, bool c_heap \/* false *\/) {\n@@ -501,1 +508,1 @@\n-    str = allocate_string(c_heap, length + 1, t);\n+    str = allocate_string(c_heap, length + 1, thread);\n@@ -503,1 +510,0 @@\n-      JfrJavaSupport::throw_out_of_memory_error(\"Unable to allocate native memory\", t);\n@@ -511,3 +517,2 @@\n-const char* JfrJavaSupport::c_str(jstring string, JavaThread* t, bool c_heap \/* false *\/) {\n-  DEBUG_ONLY(check_java_thread_in_vm(t));\n-  return string != NULL ? c_str(resolve_non_null(string), t, c_heap) : NULL;\n+const char* JfrJavaSupport::c_str(jstring string, Thread* thread, bool c_heap \/* false *\/) {\n+  return string != NULL ? c_str(resolve_non_null(string), thread, c_heap) : NULL;\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":28,"deletions":23,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+  static void get_field(JfrJavaArguments* args, Thread* thread);\n@@ -78,2 +79,2 @@\n-  static const char* c_str(jstring string, JavaThread* jt, bool c_heap = false);\n-  static const char* c_str(oop string, JavaThread* jt, bool c_heap = false);\n+  static const char* c_str(jstring string, Thread* thread, bool c_heap = false);\n+  static const char* c_str(oop string, Thread* thread, bool c_heap = false);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1102,0 +1102,7 @@\n+  <Event name=\"FinalizerStatistics\" category=\"Java Application, Statistics\" label=\"Finalizer Statistics\" description=\"Per class statistics about finalizers\" thread=\"false\" startTime=\"false\" period=\"endChunk\">\n+    <Field type=\"Class\" name=\"finalizableClass\" label=\"Class Overriding Finalize\" \/>\n+    <Field type=\"Symbol\" name=\"codeSource\" label=\"Code Source\" description=\"URL from where the class was loaded\" \/>\n+    <Field type=\"ulong\" name=\"objects\" label=\"Finalizable Objects on Heap\" description=\"Number of objects on heap that can be finalized\" \/>\n+    <Field type=\"ulong\" name=\"totalFinalizersRun\" label=\"Finalizers Run\" description=\"Total number of finalizers run since JVM start\" \/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#if INCLUDE_MANAGEMENT\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n+#include \"jfr\/periodic\/jfrFinalizerStatisticsEvent.hpp\"\n+#include \"jfr\/support\/jfrSymbolTable.hpp\"\n+#include \"jfr\/utilities\/jfrTime.hpp\"\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"services\/finalizerService.hpp\"\n+\n+static oop get_codesource(oop pd, Thread* thread) {\n+  assert(pd != NULL, \"invariant\");\n+  assert(thread != NULL, \"invariant\");\n+  JavaValue result(T_OBJECT);\n+  JfrJavaArguments args(&result);\n+  args.set_klass(pd->klass());\n+  args.set_name(\"codesource\");\n+  args.set_signature(\"Ljava\/security\/CodeSource;\");\n+  args.set_receiver(pd);\n+  JfrJavaSupport::get_field(&args, thread);\n+  return result.get_oop();\n+}\n+\n+\/\/ Caller needs ResourceMark\n+static const char* get_locationNoFragString(oop codesource, Thread* thread) {\n+  assert(codesource != NULL, \"invariant\");\n+  assert(thread != NULL, \"invariant\");\n+  JavaValue result(T_OBJECT);\n+  JfrJavaArguments args(&result);\n+  args.set_klass(codesource->klass());\n+  args.set_name(\"locationNoFragString\");\n+  args.set_signature(\"Ljava\/lang\/String;\");\n+  args.set_receiver(codesource);\n+  JfrJavaSupport::get_field(&args, thread);\n+  const oop string_oop = result.get_oop();\n+  return string_oop != NULL ? JfrJavaSupport::c_str(string_oop, thread) : NULL;\n+}\n+\n+\/\/ Caller needs ResourceMark\n+static const char* codesource(const InstanceKlass* ik, Thread* thread) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(thread != NULL, \"invariant\");\n+  oop pd = java_lang_Class::protection_domain(ik->java_mirror());\n+  if (pd == NULL) {\n+    return NULL;\n+  }\n+  oop codesource = get_codesource(pd, thread);\n+  return codesource != NULL ? get_locationNoFragString(codesource, thread) : NULL;\n+}\n+\n+static void send_event(const FinalizerEntry* fe, const InstanceKlass* ik, const JfrTicks& timestamp, Thread* thread) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(ik->has_finalizer(), \"invariant\");\n+  assert(thread != NULL, \"invariant\");\n+  const char* const url = codesource(ik, thread);\n+  const traceid url_symbol_id = url != NULL ? JfrSymbolTable::add(url) : 0;\n+  EventFinalizerStatistics event(UNTIMED);\n+  event.set_endtime(timestamp);\n+  event.set_finalizableClass(ik);\n+  event.set_codeSource(url_symbol_id);\n+  if (fe == NULL) {\n+    event.set_objects(0);\n+    event.set_totalFinalizersRun(0);\n+  } else {\n+    assert(fe->klass() == ik, \"invariant\");\n+    event.set_objects(fe->objects_on_heap());\n+    event.set_totalFinalizersRun(fe->total_finalizers_run());\n+  }\n+  event.commit();\n+}\n+\n+void JfrFinalizerStatisticsEvent::send_unload_event(const InstanceKlass* ik) {\n+  Thread* const thread = Thread::current();\n+  ResourceMark rm(thread);\n+  send_event(FinalizerService::lookup(ik, thread), ik, JfrTicks::now(), thread);\n+}\n+\n+\/\/ Finalizer events generated by the periodic task will all have the same timestamp.\n+\n+class FinalizerStatisticsEventClosure : public FinalizerEntryClosure {\n+ private:\n+  Thread* _thread;\n+  const JfrTicks _timestamp;\n+ public:\n+  FinalizerStatisticsEventClosure(Thread* thread) : _thread(thread), _timestamp(JfrTicks::now()) {}\n+  virtual bool do_entry(const FinalizerEntry* fe) {\n+    assert(fe != NULL, \"invariant\");\n+    send_event(fe, fe->klass(), _timestamp, _thread);\n+    return true;\n+  }\n+};\n+\n+void JfrFinalizerStatisticsEvent::generate_events() {\n+  Thread* const thread = Thread::current();\n+  ResourceMark rm(thread);\n+  FinalizerStatisticsEventClosure fsec(thread);\n+  MutexLocker lock(ClassLoaderDataGraph_lock); \/\/ To prevent entries from being removed by class unloading.\n+  FinalizerService::do_entries(&fsec, thread);\n+}\n+\n+#endif \/\/ INCLUDE_MANAGEMENT\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrFinalizerStatisticsEvent.cpp","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_PERIODIC_JFRFINALIZERSTATISTICSEVENT_HPP\n+#define SHARE_JFR_PERIODIC_JFRFINALIZERSTATISTICSEVENT_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+class InstanceKlass;\n+\n+class JfrFinalizerStatisticsEvent : AllStatic {\n+ public:\n+  static void send_unload_event(const InstanceKlass* ik) NOT_MANAGEMENT_RETURN;\n+  static void generate_events() NOT_MANAGEMENT_RETURN;\n+};\n+\n+#endif \/\/ SHARE_JFR_PERIODIC_JFRFINALIZERSTATISTICSEVENT_HPP\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrFinalizerStatisticsEvent.hpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"jfr\/periodic\/jfrFinalizerStatisticsEvent.hpp\"\n@@ -475,0 +476,1 @@\n+#if INCLUDE_MANAGEMENT\n@@ -479,0 +481,3 @@\n+#else\n+  log_debug(jfr, system)(\"Unable to generate requestable event ClassLoadingStatistics. The required jvm feature 'management' is missing.\");\n+#endif\n@@ -638,1 +643,0 @@\n-\n@@ -647,0 +651,8 @@\n+\n+TRACE_REQUEST_FUNC(FinalizerStatistics) {\n+#if INCLUDE_MANAGEMENT\n+  JfrFinalizerStatisticsEvent::generate_events();\n+#else\n+  log_debug(jfr, system)(\"Unable to generate requestable event FinalizerStatistics. The required jvm feature 'management' is missing.\");\n+#endif\n+}\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-typedef const JfrSymbolId::SymbolEntry* SymbolEntryPtr;\n-typedef const JfrSymbolId::CStringEntry* CStringEntryPtr;\n+typedef const JfrSymbolTable::SymbolEntry* SymbolEntryPtr;\n+typedef const JfrSymbolTable::StringEntry* StringEntryPtr;\n@@ -67,12 +67,1 @@\n-static bool _clear_artifacts = false;\n-\n-\/\/ incremented on each rotation\n-static u8 checkpoint_id = 1;\n-\n-\/\/ creates a unique id by combining a checkpoint relative symbol id (2^24)\n-\/\/ with the current checkpoint id (2^40)\n-#define CREATE_SYMBOL_ID(sym_id) (((u8)((checkpoint_id << 24) | sym_id)))\n-\n-static traceid create_symbol_id(traceid artifact_id) {\n-  return artifact_id != 0 ? CREATE_SYMBOL_ID(artifact_id) : 0;\n-}\n+static bool _initial_type_set = true;\n@@ -89,1 +78,1 @@\n-  return _clear_artifacts && !_class_unload;\n+  return _initial_type_set && !_class_unload;\n@@ -97,1 +86,1 @@\n-  return klass != NULL ? create_symbol_id(_artifacts->mark(klass, leakp)) : 0;\n+  return klass != NULL ? _artifacts->mark(klass, leakp) : 0;\n@@ -101,1 +90,1 @@\n-  return symbol != NULL ? create_symbol_id(_artifacts->mark(symbol, leakp)) : 0;\n+  return symbol != NULL ? _artifacts->mark(symbol, leakp) : 0;\n@@ -105,1 +94,1 @@\n-  return create_symbol_id(_artifacts->bootstrap_name(leakp));\n+  return _artifacts->bootstrap_name(leakp);\n@@ -930,1 +919,1 @@\n-void set_serialized<JfrSymbolId::SymbolEntry>(SymbolEntryPtr ptr) {\n+void set_serialized<JfrSymbolTable::SymbolEntry>(SymbolEntryPtr ptr) {\n@@ -937,1 +926,1 @@\n-void set_serialized<JfrSymbolId::CStringEntry>(CStringEntryPtr ptr) {\n+void set_serialized<JfrSymbolTable::StringEntry>(StringEntryPtr ptr) {\n@@ -947,1 +936,1 @@\n-  writer->write(create_symbol_id(entry->id()));\n+  writer->write(entry->id());\n@@ -965,1 +954,1 @@\n-static int write_cstring(JfrCheckpointWriter* writer, CStringEntryPtr entry, bool leakp) {\n+static int write_string(JfrCheckpointWriter* writer, StringEntryPtr entry, bool leakp) {\n@@ -968,1 +957,1 @@\n-  writer->write(create_symbol_id(entry->id()));\n+  writer->write(entry->id());\n@@ -973,1 +962,1 @@\n-int write__cstring(JfrCheckpointWriter* writer, const void* e) {\n+int write__string(JfrCheckpointWriter* writer, const void* e) {\n@@ -975,1 +964,1 @@\n-  CStringEntryPtr entry = (CStringEntryPtr)e;\n+  StringEntryPtr entry = (StringEntryPtr)e;\n@@ -977,1 +966,1 @@\n-  return write_cstring(writer, entry, false);\n+  return write_string(writer, entry, false);\n@@ -980,1 +969,1 @@\n-int write__cstring__leakp(JfrCheckpointWriter* writer, const void* e) {\n+int write__string__leakp(JfrCheckpointWriter* writer, const void* e) {\n@@ -982,2 +971,2 @@\n-  CStringEntryPtr entry = (CStringEntryPtr)e;\n-  return write_cstring(writer, entry, true);\n+  StringEntryPtr entry = (StringEntryPtr)e;\n+  return write_string(writer, entry, true);\n@@ -989,3 +978,3 @@\n-typedef SymbolPredicate<CStringEntryPtr, false> CStringPredicate;\n-typedef JfrPredicatedTypeWriterImplHost<CStringEntryPtr, CStringPredicate, write__cstring> CStringEntryWriterImpl;\n-typedef JfrTypeWriterHost<CStringEntryWriterImpl, TYPE_SYMBOL> CStringEntryWriter;\n+typedef SymbolPredicate<StringEntryPtr, false> StringPredicate;\n+typedef JfrPredicatedTypeWriterImplHost<StringEntryPtr, StringPredicate, write__string> StringEntryWriterImpl;\n+typedef JfrTypeWriterHost<StringEntryWriterImpl, TYPE_SYMBOL> StringEntryWriter;\n@@ -997,4 +986,4 @@\n-typedef SymbolPredicate<CStringEntryPtr, true> LeakCStringPredicate;\n-typedef JfrPredicatedTypeWriterImplHost<CStringEntryPtr, LeakCStringPredicate, write__cstring__leakp> LeakCStringEntryWriterImpl;\n-typedef JfrTypeWriterHost<LeakCStringEntryWriterImpl, TYPE_SYMBOL> LeakCStringEntryWriter;\n-typedef CompositeFunctor<CStringEntryPtr, LeakCStringEntryWriter, CStringEntryWriter> CompositeCStringWriter;\n+typedef SymbolPredicate<StringEntryPtr, true> LeakStringPredicate;\n+typedef JfrPredicatedTypeWriterImplHost<StringEntryPtr, LeakStringPredicate, write__string__leakp> LeakStringEntryWriterImpl;\n+typedef JfrTypeWriterHost<LeakStringEntryWriterImpl, TYPE_SYMBOL> LeakStringEntryWriter;\n+typedef CompositeFunctor<StringEntryPtr, LeakStringEntryWriter, StringEntryWriter> CompositeStringWriter;\n@@ -1008,6 +997,6 @@\n-  CStringEntryWriter ccsw(_writer, _class_unload, true); \/\/ skip header\n-  LeakCStringEntryWriter lccsw(_leakp_writer, _class_unload, true); \/\/ skip header\n-  CompositeCStringWriter cccsw(&lccsw, &ccsw);\n-  _artifacts->iterate_cstrings(cccsw);\n-  sw.add(ccsw.count());\n-  lsw.add(lccsw.count());\n+  StringEntryWriter sew(_writer, _class_unload, true); \/\/ skip header\n+  LeakStringEntryWriter lsew(_leakp_writer, _class_unload, true); \/\/ skip header\n+  CompositeStringWriter csew(&lsew, &sew);\n+  _artifacts->iterate_strings(csew);\n+  sw.add(sew.count());\n+  lsw.add(lsew.count());\n@@ -1025,3 +1014,3 @@\n-  CStringEntryWriter csw(_writer, _class_unload, true); \/\/ skip header\n-  _artifacts->iterate_cstrings(csw);\n-  sw.add(csw.count());\n+  StringEntryWriter sew(_writer, _class_unload, true); \/\/ skip header\n+  _artifacts->iterate_strings(sew);\n+  sw.add(sew.count());\n@@ -1046,2 +1035,2 @@\n-    _clear_artifacts = true;\n-    ++checkpoint_id;\n+    _artifacts->increment_checkpoint_id();\n+    _initial_type_set = true;\n@@ -1049,1 +1038,1 @@\n-    _clear_artifacts = false;\n+    _initial_type_set = false;\n@@ -1062,1 +1051,1 @@\n-    _artifacts->initialize(class_unload, _clear_artifacts);\n+    _artifacts->initialize(class_unload);\n@@ -1097,1 +1086,3 @@\n-  _clear_artifacts = true;\n+  if (_artifacts != NULL) {\n+    _artifacts->clear();\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":41,"deletions":50,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -33,219 +33,1 @@\n-static JfrSymbolId::CStringEntry* bootstrap = NULL;\n-\n-JfrSymbolId::JfrSymbolId() :\n-  _sym_table(new SymbolTable(this)),\n-  _cstring_table(new CStringTable(this)),\n-  _sym_list(NULL),\n-  _cstring_list(NULL),\n-  _sym_query(NULL),\n-  _cstring_query(NULL),\n-  _symbol_id_counter(1),\n-  _class_unload(false) {\n-  assert(_sym_table != NULL, \"invariant\");\n-  assert(_cstring_table != NULL, \"invariant\");\n-  bootstrap = new CStringEntry(0, (const char*)&BOOTSTRAP_LOADER_NAME);\n-  assert(bootstrap != NULL, \"invariant\");\n-  bootstrap->set_id(1);\n-  _cstring_list = bootstrap;\n-}\n-\n-JfrSymbolId::~JfrSymbolId() {\n-  clear();\n-  delete _sym_table;\n-  delete _cstring_table;\n-  delete bootstrap;\n-}\n-\n-void JfrSymbolId::clear() {\n-  assert(_sym_table != NULL, \"invariant\");\n-  if (_sym_table->has_entries()) {\n-    _sym_table->clear_entries();\n-  }\n-  assert(!_sym_table->has_entries(), \"invariant\");\n-\n-  assert(_cstring_table != NULL, \"invariant\");\n-  if (_cstring_table->has_entries()) {\n-    _cstring_table->clear_entries();\n-  }\n-  assert(!_cstring_table->has_entries(), \"invariant\");\n-\n-  _sym_list = NULL;\n-  _symbol_id_counter = 1;\n-\n-  _sym_query = NULL;\n-  _cstring_query = NULL;\n-\n-  assert(bootstrap != NULL, \"invariant\");\n-  bootstrap->reset();\n-  _cstring_list = bootstrap;\n-}\n-\n-void JfrSymbolId::set_class_unload(bool class_unload) {\n-  _class_unload = class_unload;\n-}\n-\n-void JfrSymbolId::on_link(const SymbolEntry* entry) {\n-  assert(entry != NULL, \"invariant\");\n-  const_cast<Symbol*>(entry->literal())->increment_refcount();\n-  assert(entry->id() == 0, \"invariant\");\n-  entry->set_id(++_symbol_id_counter);\n-  entry->set_list_next(_sym_list);\n-  _sym_list = entry;\n-}\n-\n-bool JfrSymbolId::on_equals(uintptr_t hash, const SymbolEntry* entry) {\n-  assert(entry != NULL, \"invariant\");\n-  assert(entry->hash() == hash, \"invariant\");\n-  assert(_sym_query != NULL, \"invariant\");\n-  return _sym_query == entry->literal();\n-}\n-\n-void JfrSymbolId::on_unlink(const SymbolEntry* entry) {\n-  assert(entry != NULL, \"invariant\");\n-  const_cast<Symbol*>(entry->literal())->decrement_refcount();\n-}\n-\n-static const char* resource_to_cstring(const char* resource_str) {\n-  assert(resource_str != NULL, \"invariant\");\n-  const size_t length = strlen(resource_str);\n-  char* const c_string = JfrCHeapObj::new_array<char>(length + 1);\n-  assert(c_string != NULL, \"invariant\");\n-  strncpy(c_string, resource_str, length + 1);\n-  return c_string;\n-}\n-\n-void JfrSymbolId::on_link(const CStringEntry* entry) {\n-  assert(entry != NULL, \"invariant\");\n-  assert(entry->id() == 0, \"invariant\");\n-  entry->set_id(++_symbol_id_counter);\n-  const_cast<CStringEntry*>(entry)->set_literal(resource_to_cstring(entry->literal()));\n-  entry->set_list_next(_cstring_list);\n-  _cstring_list = entry;\n-}\n-\n-static bool string_compare(const char* query, const char* candidate) {\n-  assert(query != NULL, \"invariant\");\n-  assert(candidate != NULL, \"invariant\");\n-  const size_t length = strlen(query);\n-  return strncmp(query, candidate, length) == 0;\n-}\n-\n-bool JfrSymbolId::on_equals(uintptr_t hash, const CStringEntry* entry) {\n-  assert(entry != NULL, \"invariant\");\n-  assert(entry->hash() == hash, \"invariant\");\n-  assert(_cstring_query != NULL, \"invariant\");\n-  return string_compare(_cstring_query, entry->literal());\n-}\n-\n-void JfrSymbolId::on_unlink(const CStringEntry* entry) {\n-  assert(entry != NULL, \"invariant\");\n-  JfrCHeapObj::free(const_cast<char*>(entry->literal()), strlen(entry->literal() + 1));\n-}\n-\n-traceid JfrSymbolId::bootstrap_name(bool leakp) {\n-  assert(bootstrap != NULL, \"invariant\");\n-  if (leakp) {\n-    bootstrap->set_leakp();\n-  }\n-  return 1;\n-}\n-\n-traceid JfrSymbolId::mark(const Symbol* symbol, bool leakp) {\n-  assert(symbol != NULL, \"invariant\");\n-  return mark((uintptr_t)symbol->identity_hash(), symbol, leakp);\n-}\n-\n-traceid JfrSymbolId::mark(uintptr_t hash, const Symbol* data, bool leakp) {\n-  assert(data != NULL, \"invariant\");\n-  assert(_sym_table != NULL, \"invariant\");\n-  _sym_query = data;\n-  const SymbolEntry& entry = _sym_table->lookup_put(hash, data);\n-  if (_class_unload) {\n-    entry.set_unloading();\n-  }\n-  if (leakp) {\n-    entry.set_leakp();\n-  }\n-  return entry.id();\n-}\n-\n-traceid JfrSymbolId::mark(uintptr_t hash, const char* str, bool leakp) {\n-  assert(str != NULL, \"invariant\");\n-  assert(_cstring_table != NULL, \"invariant\");\n-  _cstring_query = str;\n-  const CStringEntry& entry = _cstring_table->lookup_put(hash, str);\n-  if (_class_unload) {\n-    entry.set_unloading();\n-  }\n-  if (leakp) {\n-    entry.set_leakp();\n-  }\n-  return entry.id();\n-}\n-\n-\/*\n-* hidden classes symbol is the external name +\n-* the address of its InstanceKlass slash appended:\n-*   java.lang.invoke.LambdaForm$BMH\/22626602\n-*\n-* caller needs ResourceMark\n-*\/\n-\n-uintptr_t JfrSymbolId::hidden_klass_name_hash(const InstanceKlass* ik) {\n-  assert(ik != NULL, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  const oop mirror = ik->java_mirror_no_keepalive();\n-  assert(mirror != NULL, \"invariant\");\n-  return (uintptr_t)mirror->identity_hash();\n-}\n-\n-static const char* create_hidden_klass_symbol(const InstanceKlass* ik, uintptr_t hash) {\n-  assert(ik != NULL, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  assert(hash != 0, \"invariant\");\n-  char* hidden_symbol = NULL;\n-  const oop mirror = ik->java_mirror_no_keepalive();\n-  assert(mirror != NULL, \"invariant\");\n-  char hash_buf[40];\n-  sprintf(hash_buf, \"\/\" UINTX_FORMAT, hash);\n-  const size_t hash_len = strlen(hash_buf);\n-  const size_t result_len = ik->name()->utf8_length();\n-  hidden_symbol = NEW_RESOURCE_ARRAY(char, result_len + hash_len + 1);\n-  ik->name()->as_klass_external_name(hidden_symbol, (int)result_len + 1);\n-  assert(strlen(hidden_symbol) == result_len, \"invariant\");\n-  strcpy(hidden_symbol + result_len, hash_buf);\n-  assert(strlen(hidden_symbol) == result_len + hash_len, \"invariant\");\n-  return hidden_symbol;\n-}\n-\n-bool JfrSymbolId::is_hidden_klass(const Klass* k) {\n-  assert(k != NULL, \"invariant\");\n-  return k->is_instance_klass() && ((const InstanceKlass*)k)->is_hidden();\n-}\n-\n-traceid JfrSymbolId::mark_hidden_klass_name(const InstanceKlass* ik, bool leakp) {\n-  assert(ik != NULL, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  const uintptr_t hash = hidden_klass_name_hash(ik);\n-  const char* const hidden_symbol = create_hidden_klass_symbol(ik, hash);\n-  return mark(hash, hidden_symbol, leakp);\n-}\n-\n-traceid JfrSymbolId::mark(const Klass* k, bool leakp) {\n-  assert(k != NULL, \"invariant\");\n-  traceid symbol_id = 0;\n-  if (is_hidden_klass(k)) {\n-    assert(k->is_instance_klass(), \"invariant\");\n-    symbol_id = mark_hidden_klass_name((const InstanceKlass*)k, leakp);\n-  }\n-  if (0 == symbol_id) {\n-    Symbol* const sym = k->name();\n-    if (sym != NULL) {\n-      symbol_id = mark(sym, leakp);\n-    }\n-  }\n-  assert(symbol_id > 0, \"a symbol handler must mark the symbol for writing\");\n-  return symbol_id;\n-}\n-\n-JfrArtifactSet::JfrArtifactSet(bool class_unload) : _symbol_id(new JfrSymbolId()),\n+JfrArtifactSet::JfrArtifactSet(bool class_unload) : _symbol_table(NULL),\n@@ -261,4 +43,4 @@\n-void JfrArtifactSet::initialize(bool class_unload, bool clear \/* false *\/) {\n-  assert(_symbol_id != NULL, \"invariant\");\n-  if (clear) {\n-    _symbol_id->clear();\n+void JfrArtifactSet::initialize(bool class_unload) {\n+  if (_symbol_table == NULL) {\n+    _symbol_table = JfrSymbolTable::create();\n+    assert(_symbol_table != NULL, \"invariant\");\n@@ -266,1 +48,2 @@\n-  _symbol_id->set_class_unload(class_unload);\n+  assert(_symbol_table != NULL, \"invariant\");\n+  _symbol_table->set_class_unload(class_unload);\n@@ -273,0 +56,6 @@\n+void JfrArtifactSet::clear() {\n+  if (_symbol_table != NULL) {\n+    _symbol_table->clear();\n+  }\n+}\n+\n@@ -274,2 +63,1 @@\n-  _symbol_id->clear();\n-  delete _symbol_id;\n+  delete _symbol_table;\n@@ -280,1 +68,1 @@\n-  return _symbol_id->bootstrap_name(leakp);\n+  return _symbol_table->bootstrap_name(leakp);\n@@ -285,1 +73,1 @@\n-  return _symbol_id->mark_hidden_klass_name((const InstanceKlass*)klass, leakp);\n+  return _symbol_table->mark_hidden_klass_name((const InstanceKlass*)klass, leakp);\n@@ -289,1 +77,1 @@\n-  return _symbol_id->mark(hash, sym, leakp);\n+  return _symbol_table->mark(hash, sym, leakp);\n@@ -293,1 +81,1 @@\n-  return _symbol_id->mark(klass, leakp);\n+  return _symbol_table->mark(klass, leakp);\n@@ -297,1 +85,1 @@\n-  return _symbol_id->mark(symbol, leakp);\n+  return _symbol_table->mark(symbol, leakp);\n@@ -301,1 +89,1 @@\n-  return _symbol_id->mark(hash, str, leakp);\n+  return _symbol_table->mark(hash, str, leakp);\n@@ -327,0 +115,6 @@\n+\n+void JfrArtifactSet::increment_checkpoint_id() {\n+  assert(_symbol_table != NULL, \"invariant\");\n+  _symbol_table->increment_checkpoint_id();\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.cpp","additions":26,"deletions":232,"binary":false,"changes":258,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"jfr\/support\/jfrSymbolTable.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"jfr\/utilities\/jfrHashtable.hpp\"\n@@ -190,92 +190,0 @@\n-template <typename T, typename IdType>\n-class ListEntry : public JfrHashtableEntry<T, IdType> {\n- public:\n-  ListEntry(uintptr_t hash, const T& data) : JfrHashtableEntry<T, IdType>(hash, data),\n-    _list_next(NULL), _serialized(false), _unloading(false), _leakp(false) {}\n-  const ListEntry<T, IdType>* list_next() const { return _list_next; }\n-  void reset() const {\n-    _list_next = NULL; _serialized = false; _unloading = false; _leakp = false;\n-  }\n-  void set_list_next(const ListEntry<T, IdType>* next) const { _list_next = next; }\n-  bool is_serialized() const { return _serialized; }\n-  void set_serialized() const { _serialized = true; }\n-  bool is_unloading() const { return _unloading; }\n-  void set_unloading() const { _unloading = true; }\n-  bool is_leakp() const { return _leakp; }\n-  void set_leakp() const { _leakp = true; }\n- private:\n-  mutable const ListEntry<T, IdType>* _list_next;\n-  mutable bool _serialized;\n-  mutable bool _unloading;\n-  mutable bool _leakp;\n-};\n-\n-class JfrSymbolId : public JfrCHeapObj {\n-  template <typename, typename, template<typename, typename> class, typename, size_t>\n-  friend class HashTableHost;\n-  typedef HashTableHost<const Symbol*, traceid, ListEntry, JfrSymbolId> SymbolTable;\n-  typedef HashTableHost<const char*, traceid, ListEntry, JfrSymbolId> CStringTable;\n-  friend class JfrArtifactSet;\n- public:\n-  typedef SymbolTable::HashEntry SymbolEntry;\n-  typedef CStringTable::HashEntry CStringEntry;\n- private:\n-  SymbolTable* _sym_table;\n-  CStringTable* _cstring_table;\n-  const SymbolEntry* _sym_list;\n-  const CStringEntry* _cstring_list;\n-  const Symbol* _sym_query;\n-  const char* _cstring_query;\n-  traceid _symbol_id_counter;\n-  bool _class_unload;\n-\n-  \/\/ hashtable(s) callbacks\n-  void on_link(const SymbolEntry* entry);\n-  bool on_equals(uintptr_t hash, const SymbolEntry* entry);\n-  void on_unlink(const SymbolEntry* entry);\n-  void on_link(const CStringEntry* entry);\n-  bool on_equals(uintptr_t hash, const CStringEntry* entry);\n-  void on_unlink(const CStringEntry* entry);\n-\n-  template <typename Functor, typename T>\n-  void iterate(Functor& functor, const T* list) {\n-    const T* symbol = list;\n-    while (symbol != NULL) {\n-      const T* next = symbol->list_next();\n-      functor(symbol);\n-      symbol = next;\n-    }\n-  }\n-\n-  traceid mark_hidden_klass_name(const InstanceKlass* k, bool leakp);\n-  bool is_hidden_klass(const Klass* k);\n-  uintptr_t hidden_klass_name_hash(const InstanceKlass* ik);\n-\n- public:\n-  JfrSymbolId();\n-  ~JfrSymbolId();\n-\n-  void clear();\n-  void set_class_unload(bool class_unload);\n-\n-  traceid mark(uintptr_t hash, const Symbol* sym, bool leakp);\n-  traceid mark(const Klass* k, bool leakp);\n-  traceid mark(const Symbol* symbol, bool leakp);\n-  traceid mark(uintptr_t hash, const char* str, bool leakp);\n-  traceid bootstrap_name(bool leakp);\n-\n-  template <typename Functor>\n-  void iterate_symbols(Functor& functor) {\n-    iterate(functor, _sym_list);\n-  }\n-\n-  template <typename Functor>\n-  void iterate_cstrings(Functor& functor) {\n-    iterate(functor, _cstring_list);\n-  }\n-\n-  bool has_entries() const { return has_symbol_entries() || has_cstring_entries(); }\n-  bool has_symbol_entries() const { return _sym_list != NULL; }\n-  bool has_cstring_entries() const { return _cstring_list != NULL; }\n-};\n-\n@@ -298,1 +206,1 @@\n-  JfrSymbolId* _symbol_id;\n+  JfrSymbolTable* _symbol_table;\n@@ -308,1 +216,2 @@\n-  void initialize(bool class_unload, bool clear = false);\n+  void initialize(bool class_unload);\n+  void clear();\n@@ -317,3 +226,3 @@\n-  const JfrSymbolId::SymbolEntry* map_symbol(const Symbol* symbol) const;\n-  const JfrSymbolId::SymbolEntry* map_symbol(uintptr_t hash) const;\n-  const JfrSymbolId::CStringEntry* map_cstring(uintptr_t hash) const;\n+  const JfrSymbolTable::SymbolEntry* map_symbol(const Symbol* symbol) const;\n+  const JfrSymbolTable::SymbolEntry* map_symbol(uintptr_t hash) const;\n+  const JfrSymbolTable::StringEntry* map_string(uintptr_t hash) const;\n@@ -326,0 +235,1 @@\n+  void increment_checkpoint_id();\n@@ -338,1 +248,1 @@\n-    _symbol_id->iterate_symbols(functor);\n+    _symbol_table->iterate_symbols(functor);\n@@ -342,2 +252,2 @@\n-  void iterate_cstrings(T& functor) {\n-    _symbol_id->iterate_cstrings(functor);\n+  void iterate_strings(T& functor) {\n+    _symbol_table->iterate_strings(functor);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp","additions":11,"deletions":101,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"runtime\/handles.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -113,1 +115,3 @@\n-  MonitorLocker msg_lock(JfrMsg_lock);\n+  NoHandleMark nhm;\n+  ThreadBlockInVM transition(JavaThread::current());\n+  MonitorLocker msg_lock(JfrMsg_lock, Mutex::_no_safepoint_check_flag);\n@@ -171,1 +175,1 @@\n-  MutexLocker msg_lock(JfrMsg_lock);\n+  assert(JfrMsg_lock->owned_by_self(), \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrPostBox.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -54,0 +54,4 @@\n+    \/\/ Run as _thread_in_native to minimize impact on safepoint synchronization.\n+    NoHandleMark nhm;\n+    ThreadToNativeFromVM transition(thread);\n+\n@@ -57,1 +61,2 @@\n-    MutexLocker msg_lock(JfrMsg_lock);\n+\n+    MonitorLocker msg_lock(JfrMsg_lock, Mutex::_no_safepoint_check_flag);\n@@ -62,1 +67,1 @@\n-        JfrMsg_lock->wait();\n+        msg_lock.wait();\n@@ -65,1 +70,0 @@\n-      JfrMsg_lock->unlock();\n@@ -67,4 +71,1 @@\n-        \/\/ Run as _thread_in_native as much a possible\n-        \/\/ to minimize impact on safepoint synchronizations.\n-        NoHandleMark nhm;\n-        ThreadToNativeFromVM transition(thread);\n+        MutexUnlocker mul(JfrMsg_lock, Mutex::_no_safepoint_check_flag);\n@@ -85,1 +86,0 @@\n-      JfrMsg_lock->lock();\n@@ -92,2 +92,2 @@\n-\n-  } \/\/ JfrMsg_lock scope\n+    post_box.notify_collection_stop();\n+  } \/\/ JfrMsg_lock scope and the thread returns to _thread_in_vm\n@@ -96,1 +96,0 @@\n-  post_box.notify_collection_stop();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderThreadLoop.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"jfr\/periodic\/jfrFinalizerStatisticsEvent.hpp\"\n@@ -31,0 +33,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -110,0 +113,12 @@\n+#if INCLUDE_MANAGEMENT\n+static void send_finalizer_event(const Klass* k) {\n+  if (!k->is_instance_klass()) {\n+    return;\n+  }\n+  const InstanceKlass* const ik = InstanceKlass::cast(k);\n+  if (ik->has_finalizer()) {\n+    JfrFinalizerStatisticsEvent::send_unload_event(ik);\n+  }\n+}\n+#endif\n+\n@@ -113,0 +128,1 @@\n+  MANAGEMENT_ONLY(send_finalizer_event(k);)\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrKlassUnloading.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,316 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"classfile\/classLoaderData.hpp\"\n+#include \"jfr\/support\/jfrSymbolTable.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/symbol.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+\n+\/\/ incremented on each rotation\n+static u8 checkpoint_id = 1;\n+\n+\/\/ creates a unique id by combining a checkpoint relative symbol id (2^24)\n+\/\/ with the current checkpoint id (2^40)\n+#define CREATE_SYMBOL_ID(sym_id) (((u8)((checkpoint_id << 24) | sym_id)))\n+\n+static traceid create_symbol_id(traceid artifact_id) {\n+  return artifact_id != 0 ? CREATE_SYMBOL_ID(artifact_id) : 0;\n+}\n+\n+static uintptr_t string_hash(const char* str) {\n+  return java_lang_String::hash_code(reinterpret_cast<const jbyte*>(str), static_cast<int>(strlen(str)));\n+}\n+\n+static JfrSymbolTable::StringEntry* bootstrap = NULL;\n+\n+static JfrSymbolTable* _instance = NULL;\n+\n+static JfrSymbolTable& instance() {\n+  assert(_instance != NULL, \"invariant\");\n+  return *_instance;\n+}\n+\n+JfrSymbolTable* JfrSymbolTable::create() {\n+  assert(_instance == NULL, \"invariant\");\n+  assert_lock_strong(ClassLoaderDataGraph_lock);\n+  _instance = new JfrSymbolTable();\n+  return _instance;\n+}\n+\n+void JfrSymbolTable::destroy() {\n+  assert_lock_strong(ClassLoaderDataGraph_lock);\n+  if (_instance != NULL) {\n+    delete _instance;\n+    _instance = NULL;\n+  }\n+  assert(_instance == NULL, \"invariant\");\n+}\n+\n+JfrSymbolTable::JfrSymbolTable() :\n+  _symbols(new Symbols(this)),\n+  _strings(new Strings(this)),\n+  _symbol_list(NULL),\n+  _string_list(NULL),\n+  _symbol_query(NULL),\n+  _string_query(NULL),\n+  _id_counter(1),\n+  _class_unload(false) {\n+  assert(_symbols != NULL, \"invariant\");\n+  assert(_strings != NULL, \"invariant\");\n+  bootstrap = new StringEntry(0, (const char*)&BOOTSTRAP_LOADER_NAME);\n+  assert(bootstrap != NULL, \"invariant\");\n+  bootstrap->set_id(create_symbol_id(1));\n+  _string_list = bootstrap;\n+}\n+\n+JfrSymbolTable::~JfrSymbolTable() {\n+  clear();\n+  delete _symbols;\n+  delete _strings;\n+  delete bootstrap;\n+}\n+\n+void JfrSymbolTable::clear() {\n+  assert(_symbols != NULL, \"invariant\");\n+  if (_symbols->has_entries()) {\n+    _symbols->clear_entries();\n+  }\n+  assert(!_symbols->has_entries(), \"invariant\");\n+\n+  assert(_strings != NULL, \"invariant\");\n+  if (_strings->has_entries()) {\n+    _strings->clear_entries();\n+  }\n+  assert(!_strings->has_entries(), \"invariant\");\n+\n+  _symbol_list = NULL;\n+  _id_counter = 1;\n+\n+  _symbol_query = NULL;\n+  _string_query = NULL;\n+\n+  assert(bootstrap != NULL, \"invariant\");\n+  bootstrap->reset();\n+  _string_list = bootstrap;\n+}\n+\n+void JfrSymbolTable::set_class_unload(bool class_unload) {\n+  _class_unload = class_unload;\n+}\n+\n+void JfrSymbolTable::increment_checkpoint_id() {\n+  assert_lock_strong(ClassLoaderDataGraph_lock);\n+  clear();\n+  ++checkpoint_id;\n+}\n+\n+template <typename T>\n+inline void JfrSymbolTable::assign_id(T* entry) {\n+  assert(entry != NULL, \"invariant\");\n+  assert(entry->id() == 0, \"invariant\");\n+  entry->set_id(create_symbol_id(++_id_counter));\n+}\n+\n+void JfrSymbolTable::on_link(const SymbolEntry* entry) {\n+  assign_id(entry);\n+  const_cast<Symbol*>(entry->literal())->increment_refcount();\n+  entry->set_list_next(_symbol_list);\n+  _symbol_list = entry;\n+}\n+\n+bool JfrSymbolTable::on_equals(uintptr_t hash, const SymbolEntry* entry) {\n+  assert(entry != NULL, \"invariant\");\n+  assert(entry->hash() == hash, \"invariant\");\n+  assert(_symbol_query != NULL, \"invariant\");\n+  return _symbol_query == entry->literal();\n+}\n+\n+void JfrSymbolTable::on_unlink(const SymbolEntry* entry) {\n+  assert(entry != NULL, \"invariant\");\n+  const_cast<Symbol*>(entry->literal())->decrement_refcount();\n+}\n+\n+static const char* resource_to_c_heap_string(const char* resource_str) {\n+  assert(resource_str != NULL, \"invariant\");\n+  const size_t length = strlen(resource_str);\n+  char* const c_string = JfrCHeapObj::new_array<char>(length + 1);\n+  assert(c_string != NULL, \"invariant\");\n+  strncpy(c_string, resource_str, length + 1);\n+  return c_string;\n+}\n+\n+void JfrSymbolTable::on_link(const StringEntry* entry) {\n+  assign_id(entry);\n+  const_cast<StringEntry*>(entry)->set_literal(resource_to_c_heap_string(entry->literal()));\n+  entry->set_list_next(_string_list);\n+  _string_list = entry;\n+}\n+\n+static bool string_compare(const char* query, const char* candidate) {\n+  assert(query != NULL, \"invariant\");\n+  assert(candidate != NULL, \"invariant\");\n+  const size_t length = strlen(query);\n+  return strncmp(query, candidate, length) == 0;\n+}\n+\n+bool JfrSymbolTable::on_equals(uintptr_t hash, const StringEntry* entry) {\n+  assert(entry != NULL, \"invariant\");\n+  assert(entry->hash() == hash, \"invariant\");\n+  assert(_string_query != NULL, \"invariant\");\n+  return string_compare(_string_query, entry->literal());\n+}\n+\n+void JfrSymbolTable::on_unlink(const StringEntry* entry) {\n+  assert(entry != NULL, \"invariant\");\n+  JfrCHeapObj::free(const_cast<char*>(entry->literal()), strlen(entry->literal() + 1));\n+}\n+\n+traceid JfrSymbolTable::bootstrap_name(bool leakp) {\n+  assert(bootstrap != NULL, \"invariant\");\n+  if (leakp) {\n+    bootstrap->set_leakp();\n+  }\n+  return bootstrap->id();\n+}\n+\n+traceid JfrSymbolTable::mark(const Symbol* sym, bool leakp \/* false *\/) {\n+  assert(sym != NULL, \"invariant\");\n+  return mark((uintptr_t)sym->identity_hash(), sym, leakp);\n+}\n+\n+traceid JfrSymbolTable::mark(uintptr_t hash, const Symbol* sym, bool leakp) {\n+  assert(sym != NULL, \"invariant\");\n+  assert(_symbols != NULL, \"invariant\");\n+  _symbol_query = sym;\n+  const SymbolEntry& entry = _symbols->lookup_put(hash, sym);\n+  if (_class_unload) {\n+    entry.set_unloading();\n+  }\n+  if (leakp) {\n+    entry.set_leakp();\n+  }\n+  return entry.id();\n+}\n+\n+traceid JfrSymbolTable::mark(const char* str, bool leakp \/* false*\/) {\n+  return mark(string_hash(str), str, leakp);\n+}\n+\n+traceid JfrSymbolTable::mark(uintptr_t hash, const char* str, bool leakp) {\n+  assert(str != NULL, \"invariant\");\n+  assert(_strings != NULL, \"invariant\");\n+  _string_query = str;\n+  const StringEntry& entry = _strings->lookup_put(hash, str);\n+  if (_class_unload) {\n+    entry.set_unloading();\n+  }\n+  if (leakp) {\n+    entry.set_leakp();\n+  }\n+  return entry.id();\n+}\n+\n+\/*\n+* hidden classes symbol is the external name +\n+* the address of its InstanceKlass slash appended:\n+*   java.lang.invoke.LambdaForm$BMH\/22626602\n+*\n+* caller needs ResourceMark\n+*\/\n+\n+uintptr_t JfrSymbolTable::hidden_klass_name_hash(const InstanceKlass* ik) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(ik->is_hidden(), \"invariant\");\n+  const oop mirror = ik->java_mirror_no_keepalive();\n+  assert(mirror != NULL, \"invariant\");\n+  return (uintptr_t)mirror->identity_hash();\n+}\n+\n+static const char* create_hidden_klass_symbol(const InstanceKlass* ik, uintptr_t hash) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(ik->is_hidden(), \"invariant\");\n+  assert(hash != 0, \"invariant\");\n+  char* hidden_symbol = NULL;\n+  const oop mirror = ik->java_mirror_no_keepalive();\n+  assert(mirror != NULL, \"invariant\");\n+  char hash_buf[40];\n+  sprintf(hash_buf, \"\/\" UINTX_FORMAT, hash);\n+  const size_t hash_len = strlen(hash_buf);\n+  const size_t result_len = ik->name()->utf8_length();\n+  hidden_symbol = NEW_RESOURCE_ARRAY(char, result_len + hash_len + 1);\n+  ik->name()->as_klass_external_name(hidden_symbol, (int)result_len + 1);\n+  assert(strlen(hidden_symbol) == result_len, \"invariant\");\n+  strcpy(hidden_symbol + result_len, hash_buf);\n+  assert(strlen(hidden_symbol) == result_len + hash_len, \"invariant\");\n+  return hidden_symbol;\n+}\n+\n+bool JfrSymbolTable::is_hidden_klass(const Klass* k) {\n+  assert(k != NULL, \"invariant\");\n+  return k->is_instance_klass() && ((const InstanceKlass*)k)->is_hidden();\n+}\n+\n+traceid JfrSymbolTable::mark_hidden_klass_name(const InstanceKlass* ik, bool leakp) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(ik->is_hidden(), \"invariant\");\n+  const uintptr_t hash = hidden_klass_name_hash(ik);\n+  const char* const hidden_symbol = create_hidden_klass_symbol(ik, hash);\n+  return mark(hash, hidden_symbol, leakp);\n+}\n+\n+traceid JfrSymbolTable::mark(const Klass* k, bool leakp) {\n+  assert(k != NULL, \"invariant\");\n+  traceid symbol_id = 0;\n+  if (is_hidden_klass(k)) {\n+    assert(k->is_instance_klass(), \"invariant\");\n+    symbol_id = mark_hidden_klass_name((const InstanceKlass*)k, leakp);\n+  } else {\n+    Symbol* const sym = k->name();\n+    if (sym != NULL) {\n+      symbol_id = mark(sym, leakp);\n+    }\n+  }\n+  assert(symbol_id > 0, \"a symbol handler must mark the symbol for writing\");\n+  return symbol_id;\n+}\n+\n+template <typename T>\n+traceid JfrSymbolTable::add_impl(const T* sym) {\n+  assert(sym != NULL, \"invariant\");\n+  assert(_instance != NULL, \"invariant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  return instance().mark(sym);\n+}\n+\n+traceid JfrSymbolTable::add(const Symbol* sym) {\n+  return add_impl(sym);\n+}\n+\n+traceid JfrSymbolTable::add(const char* str) {\n+  return add_impl(str);\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.cpp","additions":316,"deletions":0,"binary":false,"changes":316,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_SUPPORT_JFRSYMBOLTABLE_HPP\n+#define SHARE_JFR_SUPPORT_JFRSYMBOLTABLE_HPP\n+\n+#include \"jfr\/utilities\/jfrHashtable.hpp\"\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+\n+template <typename T, typename IdType>\n+class ListEntry : public JfrHashtableEntry<T, IdType> {\n+ public:\n+  ListEntry(uintptr_t hash, const T& data) : JfrHashtableEntry<T, IdType>(hash, data),\n+    _list_next(NULL), _serialized(false), _unloading(false), _leakp(false) {}\n+  const ListEntry<T, IdType>* list_next() const { return _list_next; }\n+  void reset() const {\n+    _list_next = NULL; _serialized = false; _unloading = false; _leakp = false;\n+  }\n+  void set_list_next(const ListEntry<T, IdType>* next) const { _list_next = next; }\n+  bool is_serialized() const { return _serialized; }\n+  void set_serialized() const { _serialized = true; }\n+  bool is_unloading() const { return _unloading; }\n+  void set_unloading() const { _unloading = true; }\n+  bool is_leakp() const { return _leakp; }\n+  void set_leakp() const { _leakp = true; }\n+ private:\n+  mutable const ListEntry<T, IdType>* _list_next;\n+  mutable bool _serialized;\n+  mutable bool _unloading;\n+  mutable bool _leakp;\n+};\n+\n+\/*\n+ * This table maps an oop\/Symbol* or a char* to the Jfr type 'Symbol'.\n+ *\n+ * It provides an interface over the corresponding constant pool (TYPE_SYMBOL),\n+ * which is represented in the binary format as a sequence of checkpoint events.\n+ * The returned id can be used as a foreign key, but please note that the id is\n+ * epoch-relative, and is therefore only valid in the current epoch \/ chunk.\n+ * The table is cleared as part of rotation.\n+ *\n+ * Caller must ensure mutual exclusion by means of the ClassLoaderDataGraph_lock or by safepointing.\n+ *\/\n+class JfrSymbolTable : public JfrCHeapObj {\n+  template <typename, typename, template<typename, typename> class, typename, size_t>\n+  friend class HashTableHost;\n+  typedef HashTableHost<const Symbol*, traceid, ListEntry, JfrSymbolTable> Symbols;\n+  typedef HashTableHost<const char*, traceid, ListEntry, JfrSymbolTable> Strings;\n+  friend class JfrArtifactSet;\n+\n+ public:\n+  typedef Symbols::HashEntry SymbolEntry;\n+  typedef Strings::HashEntry StringEntry;\n+\n+  static traceid add(const Symbol* sym);\n+  static traceid add(const char* str);\n+\n+ private:\n+  Symbols* _symbols;\n+  Strings* _strings;\n+  const SymbolEntry* _symbol_list;\n+  const StringEntry* _string_list;\n+  const Symbol* _symbol_query;\n+  const char* _string_query;\n+  traceid _id_counter;\n+  bool _class_unload;\n+\n+  JfrSymbolTable();\n+  ~JfrSymbolTable();\n+  static JfrSymbolTable* create();\n+  static void destroy();\n+\n+  void clear();\n+  void increment_checkpoint_id();\n+  void set_class_unload(bool class_unload);\n+\n+  traceid mark(uintptr_t hash, const Symbol* sym, bool leakp);\n+  traceid mark(const Klass* k, bool leakp);\n+  traceid mark(const Symbol* sym, bool leakp = false);\n+  traceid mark(const char* str, bool leakp = false);\n+  traceid mark(uintptr_t hash, const char* str, bool leakp);\n+  traceid bootstrap_name(bool leakp);\n+\n+  bool has_entries() const { return has_symbol_entries() || has_string_entries(); }\n+  bool has_symbol_entries() const { return _symbol_list != NULL; }\n+  bool has_string_entries() const { return _string_list != NULL; }\n+\n+  traceid mark_hidden_klass_name(const InstanceKlass* k, bool leakp);\n+  bool is_hidden_klass(const Klass* k);\n+  uintptr_t hidden_klass_name_hash(const InstanceKlass* ik);\n+\n+  \/\/ hashtable(s) callbacks\n+  void on_link(const SymbolEntry* entry);\n+  bool on_equals(uintptr_t hash, const SymbolEntry* entry);\n+  void on_unlink(const SymbolEntry* entry);\n+  void on_link(const StringEntry* entry);\n+  bool on_equals(uintptr_t hash, const StringEntry* entry);\n+  void on_unlink(const StringEntry* entry);\n+\n+  template <typename T>\n+  static traceid add_impl(const T* sym);\n+\n+  template <typename T>\n+  void assign_id(T* entry);\n+\n+  template <typename Functor>\n+  void iterate_symbols(Functor& functor) {\n+    iterate(functor, _symbol_list);\n+  }\n+\n+  template <typename Functor>\n+  void iterate_strings(Functor& functor) {\n+    iterate(functor, _string_list);\n+  }\n+\n+  template <typename Functor, typename T>\n+  void iterate(Functor& functor, const T* list) {\n+    const T* symbol = list;\n+    while (symbol != NULL) {\n+      const T* next = symbol->list_next();\n+      functor(symbol);\n+      symbol = next;\n+    }\n+  }\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_JFRSYMBOLTABLE_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.hpp","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -75,0 +75,1 @@\n+  LOG_TAG(finalizer) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+#include \"services\/finalizerService.hpp\"\n@@ -99,1 +100,0 @@\n-\n@@ -1367,1 +1367,1 @@\n-  methodHandle mh (THREAD, Universe::finalizer_register_method());\n+  methodHandle mh(THREAD, Universe::finalizer_register_method());\n@@ -1369,0 +1369,1 @@\n+  MANAGEMENT_ONLY(FinalizerService::on_register(h_i(), THREAD);)\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -107,0 +107,3 @@\n+#if INCLUDE_MANAGEMENT\n+#include \"services\/finalizerService.hpp\"\n+#endif\n@@ -684,0 +687,6 @@\n+\/\/ java.lang.ref.Finalizer \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+JVM_ENTRY(void, JVM_ReportFinalizationComplete(JNIEnv * env, jobject finalizee))\n+  MANAGEMENT_ONLY(FinalizerService::on_complete(JNIHandles::resolve_non_null(finalizee), THREAD);)\n+JVM_END\n+\n@@ -3856,0 +3865,1 @@\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"services\/finalizerService.hpp\"\n@@ -144,0 +145,1 @@\n+    bool finalizerservice_work = false;\n@@ -174,0 +176,1 @@\n+              (finalizerservice_work = FinalizerService::has_work()) |\n@@ -201,0 +204,4 @@\n+    if (finalizerservice_work) {\n+      FinalizerService::do_concurrent_work(jt);\n+    }\n+\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -122,4 +122,8 @@\n-void ClassLoadingService::notify_class_unloaded(InstanceKlass* k) {\n-  DTRACE_CLASSLOAD_PROBE(unloaded, k, false);\n-  \/\/ Classes that can be unloaded must be non-shared\n-  _classes_unloaded_count->inc();\n+bool ClassLoadingService::set_verbose(bool verbose) {\n+  MutexLocker m(Management_lock);\n+  \/\/ verbose will be set to the previous value\n+  LogLevelType level = verbose ? LogLevel::Info : LogLevel::Off;\n+  LogConfiguration::configure_stdout(level, false, LOG_TAGS(class, load));\n+  reset_trace_class_unloading();\n+  return verbose;\n+}\n@@ -127,4 +131,7 @@\n-  if (UsePerfData) {\n-    \/\/ add the class size\n-    size_t size = compute_class_size(k);\n-    _classbytes_unloaded->inc(size);\n+\/\/ Caller to this function must own Management_lock\n+void ClassLoadingService::reset_trace_class_unloading() {\n+  assert(Management_lock->owned_by_self(), \"Must own the Management_lock\");\n+  bool value = MemoryService::get_verbose() || ClassLoadingService::get_verbose();\n+  LogLevelType level = value ? LogLevel::Info : LogLevel::Off;\n+  LogConfiguration::configure_stdout(level, false, LOG_TAGS(class, unload));\n+}\n@@ -132,8 +139,2 @@\n-    \/\/ Compute method size & subtract from running total.\n-    \/\/ We are called during phase 1 of mark sweep, so it's\n-    \/\/ still ok to iterate through Method*s here.\n-    Array<Method*>* methods = k->methods();\n-    for (int i = 0; i < methods->length(); i++) {\n-      _class_methods_size->inc(-methods->at(i)->size());\n-    }\n-  }\n+jlong ClassLoadingService::loaded_class_count() {\n+  return _classes_loaded_count->get_value() + _shared_classes_loaded_count->get_value();\n@@ -142,6 +143,3 @@\n-void ClassLoadingService::notify_class_loaded(InstanceKlass* k, bool shared_class) {\n-  DTRACE_CLASSLOAD_PROBE(loaded, k, shared_class);\n-  PerfCounter* classes_counter = (shared_class ? _shared_classes_loaded_count\n-                                               : _classes_loaded_count);\n-  \/\/ increment the count\n-  classes_counter->inc();\n+jlong ClassLoadingService::unloaded_class_count() {\n+  return _classes_unloaded_count->get_value() + _shared_classes_unloaded_count->get_value();\n+}\n@@ -149,7 +147,2 @@\n-  if (UsePerfData) {\n-    PerfCounter* classbytes_counter = (shared_class ? _shared_classbytes_loaded\n-                                                    : _classbytes_loaded);\n-    \/\/ add the class size\n-    size_t size = compute_class_size(k);\n-    classbytes_counter->inc(size);\n-  }\n+jlong ClassLoadingService::loaded_class_bytes() {\n+  return UsePerfData ? _classbytes_loaded->get_value() + _shared_classbytes_loaded->get_value() : -1;\n@@ -158,2 +151,7 @@\n-size_t ClassLoadingService::compute_class_size(InstanceKlass* k) {\n-  \/\/ lifted from ClassStatistics.do_class(Klass* k)\n+jlong ClassLoadingService::unloaded_class_bytes() {\n+  return UsePerfData ? _classbytes_unloaded->get_value() + _shared_classbytes_unloaded->get_value() : -1;\n+}\n+\n+jlong ClassLoadingService::loaded_shared_class_count() {\n+  return _shared_classes_loaded_count->get_value();\n+}\n@@ -161,1 +159,3 @@\n-  size_t class_size = 0;\n+jlong ClassLoadingService::unloaded_shared_class_count() {\n+  return _shared_classes_unloaded_count->get_value();\n+}\n@@ -163,1 +163,3 @@\n-  class_size += k->size();\n+jlong ClassLoadingService::loaded_shared_class_bytes() {\n+  return UsePerfData ? _shared_classbytes_loaded->get_value() : -1;\n+}\n@@ -165,0 +167,11 @@\n+jlong ClassLoadingService::unloaded_shared_class_bytes() {\n+  return UsePerfData ? _shared_classbytes_unloaded->get_value() : -1;\n+}\n+\n+jlong ClassLoadingService::class_method_data_size() {\n+  return UsePerfData ? _class_methods_size->get_value() : -1;\n+}\n+\n+static size_t compute_class_size(InstanceKlass* k) {\n+  \/\/ lifted from ClassStatistics.do_class(Klass* k)\n+  size_t class_size = k->size();\n@@ -180,7 +193,14 @@\n-bool ClassLoadingService::set_verbose(bool verbose) {\n-  MutexLocker m(Management_lock);\n-  \/\/ verbose will be set to the previous value\n-  LogLevelType level = verbose ? LogLevel::Info : LogLevel::Off;\n-  LogConfiguration::configure_stdout(level, false, LOG_TAGS(class, load));\n-  reset_trace_class_unloading();\n-  return verbose;\n+void ClassLoadingService::notify_class_loaded(InstanceKlass* k, bool shared_class) {\n+  DTRACE_CLASSLOAD_PROBE(loaded, k, shared_class);\n+  PerfCounter* classes_counter = (shared_class ? _shared_classes_loaded_count\n+                                               : _classes_loaded_count);\n+  \/\/ increment the count\n+  classes_counter->inc();\n+\n+  if (UsePerfData) {\n+    PerfCounter* classbytes_counter = (shared_class ? _shared_classbytes_loaded\n+                                                    : _classbytes_loaded);\n+    \/\/ add the class size\n+    size_t size = compute_class_size(k);\n+    classbytes_counter->inc(size);\n+  }\n@@ -189,6 +209,18 @@\n-\/\/ Caller to this function must own Management_lock\n-void ClassLoadingService::reset_trace_class_unloading() {\n-  assert(Management_lock->owned_by_self(), \"Must own the Management_lock\");\n-  bool value = MemoryService::get_verbose() || ClassLoadingService::get_verbose();\n-  LogLevelType level = value ? LogLevel::Info : LogLevel::Off;\n-  LogConfiguration::configure_stdout(level, false, LOG_TAGS(class, unload));\n+void ClassLoadingService::notify_class_unloaded(InstanceKlass* k) {\n+  DTRACE_CLASSLOAD_PROBE(unloaded, k, false);\n+  \/\/ Classes that can be unloaded must be non-shared\n+  _classes_unloaded_count->inc();\n+\n+  if (UsePerfData) {\n+    \/\/ add the class size\n+    size_t size = compute_class_size(k);\n+    _classbytes_unloaded->inc(size);\n+\n+    \/\/ Compute method size & subtract from running total.\n+    \/\/ We are called during phase 1 of mark sweep, so it's\n+    \/\/ still ok to iterate through Method*s here.\n+    Array<Method*>* methods = k->methods();\n+    for (int i = 0; i < methods->length(); i++) {\n+      _class_methods_size->inc(-methods->at(i)->size());\n+    }\n+  }\n","filename":"src\/hotspot\/share\/services\/classLoadingService.cpp","additions":78,"deletions":46,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-private:\n+ private:\n@@ -53,7 +53,3 @@\n-  static size_t compute_class_size(InstanceKlass* k);\n-\n-public:\n-  static void init();\n-\n-  static bool get_verbose() { return log_is_enabled(Info, class, load); }\n-  static bool set_verbose(bool verbose);\n+ public:\n+  static void init() NOT_MANAGEMENT_RETURN;\n+  static bool set_verbose(bool verbose) NOT_MANAGEMENT_RETURN_(false);\n@@ -61,45 +57,10 @@\n-\n-  static jlong loaded_class_count() {\n-    return _classes_loaded_count->get_value() + _shared_classes_loaded_count->get_value();\n-  }\n-  static jlong unloaded_class_count() {\n-    return _classes_unloaded_count->get_value() + _shared_classes_unloaded_count->get_value();\n-  }\n-  static jlong loaded_class_bytes() {\n-    if (UsePerfData) {\n-      return _classbytes_loaded->get_value() + _shared_classbytes_loaded->get_value();\n-    } else {\n-      return -1;\n-    }\n-  }\n-  static jlong unloaded_class_bytes() {\n-    if (UsePerfData) {\n-      return _classbytes_unloaded->get_value() + _shared_classbytes_unloaded->get_value();\n-    } else {\n-      return -1;\n-    }\n-  }\n-\n-  static jlong loaded_shared_class_count() {\n-    return _shared_classes_loaded_count->get_value();\n-  }\n-  static jlong unloaded_shared_class_count() {\n-    return _shared_classes_unloaded_count->get_value();\n-  }\n-  static jlong loaded_shared_class_bytes() {\n-    if (UsePerfData) {\n-      return _shared_classbytes_loaded->get_value();\n-    } else {\n-      return -1;\n-    }\n-  }\n-  static jlong unloaded_shared_class_bytes() {\n-    if (UsePerfData) {\n-      return _shared_classbytes_unloaded->get_value();\n-    } else {\n-      return -1;\n-    }\n-  }\n-  static jlong class_method_data_size() {\n-    return (UsePerfData ? _class_methods_size->get_value() : -1);\n-  }\n+  static jlong loaded_class_count() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong unloaded_class_count() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong loaded_class_bytes() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong unloaded_class_bytes() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong loaded_shared_class_count() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong unloaded_shared_class_count() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong loaded_shared_class_bytes() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong unloaded_shared_class_bytes() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong class_method_data_size() NOT_MANAGEMENT_RETURN_(0L);\n+  static bool get_verbose() { return log_is_enabled(Info, class, load); }\n","filename":"src\/hotspot\/share\/services\/classLoadingService.hpp","additions":14,"deletions":53,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -0,0 +1,313 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#if INCLUDE_MANAGEMENT\n+#include \"classfile\/classLoaderDataGraph.inline.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"services\/finalizerService.hpp\"\n+#include \"utilities\/concurrentHashTableTasks.inline.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+FinalizerEntry::FinalizerEntry(const InstanceKlass* ik) :\n+    _ik(ik),\n+    _objects_on_heap(0),\n+    _total_finalizers_run(0) {}\n+\n+const InstanceKlass* FinalizerEntry::klass() const {\n+  return _ik;\n+}\n+\n+uintptr_t FinalizerEntry::objects_on_heap() const {\n+  return Atomic::load(&_objects_on_heap);\n+}\n+\n+uintptr_t FinalizerEntry::total_finalizers_run() const {\n+  return Atomic::load(&_total_finalizers_run);\n+}\n+\n+void FinalizerEntry::on_register() {\n+  Atomic::inc(&_objects_on_heap, memory_order_relaxed);\n+}\n+\n+void FinalizerEntry::on_complete() {\n+  Atomic::inc(&_total_finalizers_run, memory_order_relaxed);\n+  Atomic::dec(&_objects_on_heap, memory_order_relaxed);\n+}\n+\n+static inline uintx hash_function(const InstanceKlass* ik) {\n+  assert(ik != nullptr, \"invariant\");\n+  return primitive_hash(ik);\n+}\n+\n+static inline uintx hash_function(const FinalizerEntry* fe) {\n+  return hash_function(fe->klass());\n+}\n+\n+class FinalizerEntryLookup : StackObj {\n+ private:\n+  const InstanceKlass* const _ik;\n+ public:\n+  FinalizerEntryLookup(const InstanceKlass* ik) : _ik(ik) {}\n+  uintx get_hash() const { return hash_function(_ik); }\n+  bool equals(FinalizerEntry** value, bool* is_dead) {\n+    assert(value != nullptr, \"invariant\");\n+    assert(*value != nullptr, \"invariant\");\n+    return (*value)->klass() == _ik;\n+  }\n+};\n+\n+class FinalizerTableConfig : public AllStatic {\n+ public:\n+  typedef FinalizerEntry* Value;  \/\/ value of the Node in the hashtable\n+\n+  static uintx get_hash(Value const& value, bool* is_dead) {\n+    return hash_function(value);\n+  }\n+  static void* allocate_node(void* context, size_t size, Value const& value) {\n+    return AllocateHeap(size, mtServiceability);\n+  }\n+  static void free_node(void* context, void* memory, Value const& value) {\n+    FreeHeap(memory);\n+  }\n+};\n+\n+typedef ConcurrentHashTable<FinalizerTableConfig, mtServiceability> FinalizerHashtable;\n+static FinalizerHashtable* _table = nullptr;\n+static const size_t DEFAULT_TABLE_SIZE = 2048;\n+\/\/ 2^24 is max size, like StringTable.\n+static const size_t MAX_SIZE = 24;\n+static volatile bool _has_work = false;\n+\n+static size_t ceil_log2(size_t value) {\n+  size_t ret;\n+  for (ret = 1; ((size_t)1 << ret) < value; ++ret);\n+  return ret;\n+}\n+\n+class FinalizerEntryLookupResult {\n+ private:\n+  FinalizerEntry* _result;\n+ public:\n+  FinalizerEntryLookupResult() : _result(nullptr) {}\n+  void operator()(FinalizerEntry* node) {\n+    assert(node != nullptr, \"invariant\");\n+    _result = node;\n+  }\n+  FinalizerEntry* result() const { return _result; }\n+};\n+\n+class FinalizerEntryLookupGet {\n+ private:\n+  FinalizerEntry* _result;\n+ public:\n+  FinalizerEntryLookupGet() : _result(nullptr) {}\n+  void operator()(FinalizerEntry** node) {\n+    assert(node != nullptr, \"invariant\");\n+    _result = *node;\n+  }\n+  FinalizerEntry* result() const { return _result; }\n+};\n+\n+static inline void set_has_work(bool value) {\n+  Atomic::store(&_has_work, value);\n+}\n+\n+static inline bool has_work() {\n+  return Atomic::load(&_has_work);\n+}\n+\n+static void request_resize() {\n+  if (!has_work()) {\n+    MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+    if (!has_work()) {\n+      set_has_work(true);\n+      Service_lock->notify_all();\n+    }\n+  }\n+}\n+\n+static FinalizerEntry* add_to_table_if_needed(const InstanceKlass* ik, Thread* thread) {\n+  FinalizerEntryLookup lookup(ik);\n+  FinalizerEntry* entry = nullptr;\n+  bool grow_hint = false;\n+  do {\n+    \/\/ We have looked up the entry once, proceed with insertion.\n+    entry = new FinalizerEntry(ik);\n+    if (_table->insert(thread, lookup, entry, &grow_hint)) {\n+      break;\n+    }\n+    \/\/ In case another thread did a concurrent add, return value already in the table.\n+    \/\/ This could fail if the entry got deleted concurrently, so loop back until success.\n+    FinalizerEntryLookupGet felg;\n+    if (_table->get(thread, lookup, felg, &grow_hint)) {\n+      entry = felg.result();\n+      break;\n+    }\n+  } while (true);\n+  if (grow_hint) {\n+    request_resize();\n+  }\n+  assert(entry != nullptr, \"invariant\");\n+  return entry;\n+}\n+\n+static void do_table_concurrent_work(JavaThread* jt) {\n+  if (!_table->is_max_size_reached()) {\n+    FinalizerHashtable::GrowTask gt(_table);\n+    if (!gt.prepare(jt)) {\n+      return;\n+    }\n+    while (gt.do_task(jt)) {\n+      gt.pause(jt);\n+      {\n+        ThreadBlockInVM tbivm(jt);\n+      }\n+      gt.cont(jt);\n+    }\n+    gt.done(jt);\n+  }\n+  set_has_work(false);\n+}\n+\n+bool FinalizerService::has_work() {\n+  return ::has_work();\n+}\n+\n+void FinalizerService::do_concurrent_work(JavaThread* service_thread) {\n+  assert(service_thread != nullptr, \"invariant\");\n+  assert(has_work(), \"invariant\");\n+  do_table_concurrent_work(service_thread);\n+}\n+\n+void FinalizerService::init() {\n+  assert(_table == nullptr, \"invariant\");\n+  const size_t start_size_log_2 = ceil_log2(DEFAULT_TABLE_SIZE);\n+  _table = new FinalizerHashtable(start_size_log_2, MAX_SIZE);\n+}\n+\n+static FinalizerEntry* lookup_entry(const InstanceKlass* ik, Thread* thread) {\n+  FinalizerEntryLookup lookup(ik);\n+  FinalizerEntryLookupGet felg;\n+  _table->get(thread, lookup, felg);\n+  return felg.result();\n+}\n+\n+const FinalizerEntry* FinalizerService::lookup(const InstanceKlass* ik, Thread* thread) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(thread != nullptr, \"invariant\");\n+  assert(ik->has_finalizer(), \"invariant\");\n+  return lookup_entry(ik, thread);\n+}\n+\n+\/\/ Add if not exist.\n+static FinalizerEntry* get_entry(const InstanceKlass* ik, Thread* thread) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(ik->has_finalizer(), \"invariant\");\n+  FinalizerEntry* const entry = lookup_entry(ik, thread);\n+  return entry != nullptr ? entry : add_to_table_if_needed(ik, thread);\n+}\n+\n+static FinalizerEntry* get_entry(oop finalizee, Thread* thread) {\n+  assert(finalizee != nullptr, \"invariant\");\n+  assert(finalizee->is_instance(), \"invariant\");\n+  return get_entry(InstanceKlass::cast(finalizee->klass()), thread);\n+}\n+\n+static void log_registered(oop finalizee, Thread* thread) {\n+  ResourceMark rm(thread);\n+  const intptr_t identity_hash = ObjectSynchronizer::FastHashCode(thread, finalizee);\n+  log_info(finalizer)(\"Registered object (\" INTPTR_FORMAT \") of class %s as finalizable\", identity_hash, finalizee->klass()->external_name());\n+}\n+\n+void FinalizerService::on_register(oop finalizee, Thread* thread) {\n+  FinalizerEntry* const fe = get_entry(finalizee, thread);\n+  assert(fe != nullptr, \"invariant\");\n+  fe->on_register();\n+  if (log_is_enabled(Info, finalizer)) {\n+    log_registered(finalizee, thread);\n+  }\n+}\n+\n+static void log_completed(oop finalizee, Thread* thread) {\n+  ResourceMark rm(thread);\n+  const intptr_t identity_hash = ObjectSynchronizer::FastHashCode(thread, finalizee);\n+  log_info(finalizer)(\"Finalizer was run for object (\" INTPTR_FORMAT \") of class %s\", identity_hash, finalizee->klass()->external_name());\n+}\n+\n+void FinalizerService::on_complete(oop finalizee, JavaThread* finalizer_thread) {\n+  FinalizerEntry* const fe = get_entry(finalizee, finalizer_thread);\n+  assert(fe != nullptr, \"invariant\");\n+  fe->on_complete();\n+  if (log_is_enabled(Info, finalizer)) {\n+    log_completed(finalizee, finalizer_thread);\n+  }\n+}\n+\n+class FinalizerScan : public StackObj {\n+ private:\n+  FinalizerEntryClosure* _closure;\n+ public:\n+  FinalizerScan(FinalizerEntryClosure* closure) : _closure(closure) {}\n+  bool operator()(FinalizerEntry** fe) {\n+    return _closure->do_entry(*fe);\n+  }\n+};\n+\n+void FinalizerService::do_entries(FinalizerEntryClosure* closure, Thread* thread) {\n+  assert(closure != nullptr, \"invariant\");\n+  FinalizerScan scan(closure);\n+  _table->do_scan(thread, scan);\n+}\n+\n+static bool remove_entry(const InstanceKlass* ik) {\n+  assert(ik != nullptr, \"invariant\");\n+  FinalizerEntryLookup lookup(ik);\n+  return _table->remove(Thread::current(), lookup);\n+}\n+\n+static void on_unloading(Klass* klass) {\n+  assert(klass != nullptr, \"invariant\");\n+  if (!klass->is_instance_klass()) {\n+    return;\n+  }\n+  const InstanceKlass* const ik = InstanceKlass::cast(klass);\n+  if (ik->has_finalizer()) {\n+    remove_entry(ik);\n+  }\n+}\n+\n+void FinalizerService::purge_unloaded() {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  ClassLoaderDataGraph::classes_unloading_do(&on_unloading);\n+}\n+\n+#endif \/\/ INCLUDE_MANAGEMENT\n","filename":"src\/hotspot\/share\/services\/finalizerService.cpp","additions":313,"deletions":0,"binary":false,"changes":313,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_FINALIZERSERVICE_HPP\n+#define SHARE_SERVICES_FINALIZERSERVICE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+class InstanceKlass;\n+class JavaThread;\n+class Thread;\n+\n+class FinalizerEntry : public CHeapObj<mtServiceability> {\n+ private:\n+  const InstanceKlass* const _ik;\n+  uintptr_t _objects_on_heap;\n+  uintptr_t _total_finalizers_run;\n+ public:\n+  FinalizerEntry(const InstanceKlass* ik);\n+  const InstanceKlass* klass() const NOT_MANAGEMENT_RETURN_(nullptr);\n+  uintptr_t objects_on_heap() const NOT_MANAGEMENT_RETURN_(0L);\n+  uintptr_t total_finalizers_run() const NOT_MANAGEMENT_RETURN_(0L);\n+  void on_register() NOT_MANAGEMENT_RETURN;\n+  void on_complete() NOT_MANAGEMENT_RETURN;\n+};\n+\n+class FinalizerEntryClosure : public StackObj {\n+ public:\n+  virtual bool do_entry(const FinalizerEntry* fe) = 0;\n+};\n+\n+class FinalizerService : AllStatic {\n+  friend class ServiceThread;\n+ private:\n+  static bool has_work() NOT_MANAGEMENT_RETURN_(false);\n+  static void do_concurrent_work(JavaThread* service_thread) NOT_MANAGEMENT_RETURN;\n+ public:\n+  static void init() NOT_MANAGEMENT_RETURN;\n+  static void purge_unloaded() NOT_MANAGEMENT_RETURN;\n+  static void on_register(oop finalizee, Thread* thread) NOT_MANAGEMENT_RETURN;\n+  static void on_complete(oop finalizee, JavaThread* finalizer_thread) NOT_MANAGEMENT_RETURN;\n+  static void do_entries(FinalizerEntryClosure* closure, Thread* thread) NOT_MANAGEMENT_RETURN;\n+  static const FinalizerEntry* lookup(const InstanceKlass* ik, Thread* thread) NOT_MANAGEMENT_RETURN_(nullptr);\n+};\n+\n+#endif \/\/ SHARE_SERVICES_FINALIZERSERVICE_HPP\n","filename":"src\/hotspot\/share\/services\/finalizerService.hpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -58,0 +58,1 @@\n+#include \"services\/finalizerService.hpp\"\n@@ -97,0 +98,1 @@\n+  FinalizerService::init();\n@@ -209,0 +211,9 @@\n+\n+void Management::record_vm_init_completed() {\n+  \/\/ Initialize the timestamp to get the current time\n+  _vm_init_done_time->set_value(os::javaTimeMillis());\n+\n+  \/\/ Update the timestamp to the vm init done time\n+  _stamp.update();\n+}\n+\n@@ -219,0 +230,8 @@\n+jlong Management::begin_vm_creation_time() {\n+  return _begin_vm_creation_time->get_value();\n+}\n+\n+jlong Management::vm_init_done_time() {\n+  return _vm_init_done_time->get_value();\n+}\n+\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -73,3 +73,1 @@\n-  static void  record_vm_init_completed() {\n-    \/\/ Initialize the timestamp to get the current time\n-    _vm_init_done_time->set_value(os::javaTimeMillis());\n+  static void  record_vm_init_completed() NOT_MANAGEMENT_RETURN;\n@@ -77,10 +75,2 @@\n-    \/\/ Update the timestamp to the vm init done time\n-    _stamp.update();\n-  }\n-\n-  static jlong begin_vm_creation_time() {\n-    return _begin_vm_creation_time->get_value();\n-  }\n-  static jlong vm_init_done_time() {\n-    return _vm_init_done_time->get_value();\n-  }\n+  static jlong begin_vm_creation_time() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong vm_init_done_time() NOT_MANAGEMENT_RETURN_(0L);\n","filename":"src\/hotspot\/share\/services\/management.hpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+#define MANAGEMENT_ONLY(x) x\n@@ -132,0 +133,1 @@\n+#define MANAGEMENT_ONLY(x)\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+                reportComplete(finalizee);\n@@ -98,0 +99,2 @@\n+    private static native void reportComplete(Object finalizee);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Finalizer.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvm.h\"\n+\n+#include \"java_lang_ref_Finalizer.h\"\n+\n+JNIEXPORT void JNICALL\n+Java_java_lang_ref_Finalizer_reportComplete(JNIEnv* env, jclass cls, jobject finalizee) {\n+    JVM_ReportFinalizationComplete(env, finalizee);\n+}\n+\n+\n","filename":"src\/java.base\/share\/native\/libjava\/Finalizer.c","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -828,0 +828,5 @@\n+    <event name=\"jdk.FinalizerStatistics\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">endChunk<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -828,0 +828,5 @@\n+    <event name=\"jdk.FinalizerStatistics\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">endChunk<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.runtime;\n+\n+import java.util.List;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.jfr.TestClassLoader;\n+\n+\/**\n+ * @test\n+ * @summary The test verifies that classes overriding finalize() are represented as events.\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm -Xlog:class+unload,finalizer -Xmx16m jdk.jfr.event.runtime.TestFinalizerStatisticsEvent\n+ *\/\n+\n+public final class TestFinalizerStatisticsEvent {\n+    private final static String TEST_CLASS_NAME = \"jdk.jfr.event.runtime.TestFinalizerStatisticsEvent$TestClassOverridingFinalize\";\n+    private final static String TEST_CLASS_UNLOAD_NAME = \"jdk.jfr.event.runtime.TestFinalizerStatisticsEvent$TestClassUnloadOverridingFinalize\";\n+    private final static String EVENT_PATH = EventNames.FinalizerStatistics;\n+\n+    \/\/ Declare as public static to prevent the compiler from optimizing away all unread writes\n+    public static TestClassLoader unloadableClassLoader;\n+    public static Class<?> unloadOverrideClass;\n+    public static Object overridingInstance;\n+\n+    public static void main(String[] args) throws Throwable {\n+        Recording recording1 = new Recording();\n+        recording1.enable(EVENT_PATH);\n+        Recording recording2 = new Recording();\n+        recording2.enable(EVENT_PATH);\n+        recording1.start();\n+        allocateAndGC();\n+        recording2.start(); \/\/ rotation writes an event for TEST_CLASS_NAME into recording1\n+        unloadableClassLoader = new TestClassLoader();\n+        unloadOverrideClass = unloadableClassLoader.loadClass(TEST_CLASS_UNLOAD_NAME);\n+        unloadOverrideClass = null;\n+        unloadableClassLoader = null;\n+        allocateAndGC(); \/\/ the unloading of class TEST_CLASS_UNLOAD_NAME is intercepted and an event is written into both recording1 and recording2\n+        recording2.stop(); \/\/ rotation writes an event for TEST_CLASS_NAME into both recording1 and recording2\n+        allocateAndGC();\n+        recording1.stop(); \/\/ rotation writes an event for TEST_CLASS_NAME into recording1 which now has 4 events reflecting this test case (3 chunks + 1 unload)\n+\n+        try {\n+            verify(recording2);\n+            verify(recording1);\n+        }\n+        finally {\n+            recording2.close();\n+            recording1.close();\n+        }\n+    }\n+\n+    private static void allocateAndGC() {\n+        overridingInstance = new TestClassOverridingFinalize();\n+        overridingInstance = null;\n+        System.gc();\n+    }\n+\n+    private static void verify(Recording recording) throws Throwable {\n+        boolean foundTestClassName = false;\n+        boolean foundTestClassUnloadName = false;\n+        List<RecordedEvent> events = Events.fromRecording(recording);\n+        Events.hasEvents(events);\n+        for (RecordedEvent event : events) {\n+          System.out.println(\"Event:\" + event);\n+          RecordedClass overridingClass = event.getValue(\"finalizableClass\");\n+          switch (overridingClass.getName()) {\n+              case TEST_CLASS_NAME: {\n+                  Asserts.assertTrue(event.getString(\"codeSource\").startsWith(\"file:\/\/\"));\n+                  foundTestClassName = true;\n+                  break;\n+              }\n+              case TEST_CLASS_UNLOAD_NAME: {\n+                  Asserts.assertTrue(event.getString(\"codeSource\").startsWith(\"file:\/\/\"));\n+                  foundTestClassUnloadName = true;\n+                  break;\n+              }\n+          }\n+        }\n+        Asserts.assertTrue(foundTestClassName, \"The class: \" + TEST_CLASS_NAME + \" overriding finalize() is not found\");\n+        Asserts.assertTrue(foundTestClassUnloadName, \"The class: \" + TEST_CLASS_UNLOAD_NAME + \" overriding finalize() is not found\");\n+    }\n+\n+    static public class TestClassOverridingFinalize {\n+        public boolean finalized = false;\n+\n+        @Override\n+        protected void finalize() {\n+            finalized = true;\n+        }\n+    }\n+\n+    static public class TestClassUnloadOverridingFinalize {\n+        public boolean finalized = false;\n+\n+        @Override\n+        protected void finalize() {\n+            finalized = true;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestFinalizerStatisticsEvent.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -94,0 +94,1 @@\n+    public static final String FinalizerStatistics = PREFIX + \"FinalizerStatistics\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+import java.net.URL;\n+import java.security.cert.Certificate;\n+import java.security.CodeSource;\n+import java.security.ProtectionDomain;\n@@ -56,1 +60,4 @@\n-                return defineClass(name, buf, 0, buf.length);\n+                URL url = getResource(resourceName);\n+                CodeSource cs = new CodeSource(url, (Certificate[])null);\n+                ProtectionDomain pd = new ProtectionDomain(cs, null);\n+                return defineClass(name, buf, 0, buf.length, pd);\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/TestClassLoader.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}