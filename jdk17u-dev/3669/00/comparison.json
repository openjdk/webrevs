{"files":[{"patch":"@@ -42,0 +42,1 @@\n+import java.util.concurrent.Flow.Subscription;\n@@ -213,1 +214,1 @@\n-                exchange.responseSubscriberCompleted(this);\n+                exchange.unregisterResponseSubscriber(this);\n@@ -218,0 +219,8 @@\n+\n+        @Override\n+        protected void onCancel() {\n+            \/\/ If the subscription is cancelled the\n+            \/\/ subscriber may or may not get completed.\n+            \/\/ Therefore we need to unregister it\n+            exchange.unregisterResponseSubscriber(this);\n+        }\n@@ -267,1 +276,1 @@\n-    void registerResponseSubscriber(Http1ResponseBodySubscriber<T> subscriber) {\n+    private void registerResponseSubscriber(Http1ResponseBodySubscriber<T> subscriber) {\n@@ -282,2 +291,2 @@\n-    void responseSubscriberCompleted(HttpBodySubscriberWrapper<T> subscriber) {\n-        client.subscriberCompleted(subscriber);\n+    private void unregisterResponseSubscriber(Http1ResponseBodySubscriber<T> subscriber) {\n+        client.unregisterSubscriber(subscriber);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Exchange.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -399,0 +399,1 @@\n+    private final AtomicLong pendingSubscribersCount = new AtomicLong();\n@@ -540,1 +541,6 @@\n-                    subscribers.add(subscriber);\n+                    if (subscribers.add(subscriber)) {\n+                        long count = pendingSubscribersCount.incrementAndGet();\n+                        if (debug.on()) {\n+                            debug.log(\"body subscriber registered: \" + count);\n+                        }\n+                    }\n@@ -548,2 +554,7 @@\n-    public void subscriberCompleted(HttpBodySubscriberWrapper<?> subscriber) {\n-        subscribers.remove(subscriber);\n+    public void unregisterSubscriber(HttpBodySubscriberWrapper<?> subscriber) {\n+        if (subscribers.remove(subscriber)) {\n+            long count = pendingSubscribersCount.decrementAndGet();\n+            if (debug.on()) {\n+                debug.log(\"body subscriber unregistered: \" + count);\n+            }\n+        }\n@@ -619,1 +630,1 @@\n-        if (count == 0 && facade() == null) {\n+        if (count == 0 && facadeRef.refersTo(null)) {\n@@ -641,1 +652,1 @@\n-        if (count == 0 && facade() == null) {\n+        if (count == 0 && facadeRef.refersTo(null)) {\n@@ -663,1 +674,1 @@\n-        if (count == 0 && facade() == null) {\n+        if (count == 0 && facadeRef.refersTo(null)) {\n@@ -689,0 +700,1 @@\n+        final AtomicLong subscribersCount;\n@@ -698,0 +710,1 @@\n+                          AtomicLong subscribers,\n@@ -707,0 +720,1 @@\n+            this.subscribersCount = subscribers;\n@@ -712,0 +726,4 @@\n+        public long getOutstandingSubscribers() {\n+            return subscribersCount.get();\n+        }\n+        @Override\n@@ -751,0 +769,1 @@\n+                pendingSubscribersCount,\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -360,2 +360,2 @@\n-    private void subscriberCompleted(Http2StreamResponseSubscriber<?> subscriber) {\n-        client().subscriberCompleted(subscriber);\n+    private void unregisterResponseSubscriber(Http2StreamResponseSubscriber<?> subscriber) {\n+        client().unregisterSubscriber(subscriber);\n@@ -1664,1 +1664,1 @@\n-                Stream.this.subscriberCompleted(this);\n+                Stream.this.unregisterResponseSubscriber(this);\n@@ -1669,0 +1669,4 @@\n+        @Override\n+        protected void onCancel() {\n+            Stream.this.unregisterResponseSubscriber(this);\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.Objects;\n@@ -64,1 +65,1 @@\n-    volatile Subscription subscription;\n+    volatile SubscriptionWrapper subscription;\n@@ -70,0 +71,21 @@\n+    private class SubscriptionWrapper implements Subscription {\n+        final Subscription subscription;\n+        SubscriptionWrapper(Subscription s) {\n+            this.subscription = Objects.requireNonNull(s);\n+        }\n+        @Override\n+        public void request(long n) {\n+            subscription.request(n);\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            try {\n+                subscription.cancel();\n+                onCancel();\n+            } catch (Throwable t) {\n+                onError(t);\n+            }\n+        }\n+    }\n+\n@@ -100,0 +122,8 @@\n+    \/**\n+     * Called when the subscriber cancels its subscription.\n+     * @apiNote\n+     * This method may be used by subclasses to perform cleanup\n+     * actions after a subscription has been cancelled.\n+     *\/\n+    protected void onCancel() { }\n+\n@@ -140,1 +170,0 @@\n-        this.subscription = subscription;\n@@ -145,1 +174,2 @@\n-                userSubscriber.onSubscribe(subscription);\n+                SubscriptionWrapper wrapped = new SubscriptionWrapper(subscription);\n+                userSubscriber.onSubscribe(this.subscription = wrapped);\n@@ -159,0 +189,1 @@\n+            SubscriptionWrapper subscription = this.subscription;\n@@ -160,1 +191,1 @@\n-                subscription.cancel();\n+                subscription.subscription.cancel();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/HttpBodySubscriberWrapper.java","additions":35,"deletions":4,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -62,0 +62,2 @@\n+        \/\/ number of body subscribers not yet completed or canceled\n+        long getOutstandingSubscribers();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/OperationTrackers.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import java.lang.ref.Reference;\n@@ -380,0 +381,7 @@\n+\n+            var error = TRACKER.check(1,\n+                    (t) -> t.getOutstandingOperations() > 0 || t.getOutstandingSubscribers() > 0,\n+                    \"subscribers for testGetSendAsync(%s)\\n\\t step [%s]\".formatted(req.uri(), i),\n+                    false);\n+            Reference.reachabilityFence(client);\n+            if (error != null) throw error;\n@@ -484,0 +492,7 @@\n+\n+            var error = TRACKER.check(1,\n+                    (t) -> t.getOutstandingOperations() > 0 || t.getOutstandingSubscribers() > 0,\n+                    \"subscribers for testPostSendAsync(%s)\\n\\t step [%s]\".formatted(req.uri(), i),\n+                    false);\n+            Reference.reachabilityFence(client);\n+            if (error != null) throw error;\n@@ -539,0 +554,7 @@\n+\n+            var error = TRACKER.check(1,\n+                    (t) -> t.getOutstandingOperations() > 0 || t.getOutstandingSubscribers() > 0,\n+                    \"subscribers for testPostInterrupt(%s)\\n\\t step [%s]\".formatted(req.uri(), i),\n+                    false);\n+            Reference.reachabilityFence(client);\n+            if (error != null) throw error;\n","filename":"test\/jdk\/java\/net\/httpclient\/CancelRequestTest.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,448 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8294916\n+ * @summary Tests that closing a streaming handler (ofInputStream()\/ofLines())\n+ *      without reading all the bytes unregisters the underlying subscriber.\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.common.HttpServerAdapters jdk.test.lib.net.SimpleSSLContext\n+ *        ReferenceTracker CancelStreamedBodyTest\n+ * @run testng\/othervm -Djdk.internal.httpclient.debug=true\n+ *                     CancelStreamedBodyTest\n+ *\/\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+import jdk.internal.net.http.common.OperationTrackers.Tracker;\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.ITestContext;\n+import org.testng.ITestResult;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.ref.Reference;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpConnectTimeoutException;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandler;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+\n+import static java.lang.System.arraycopy;\n+import static java.lang.System.out;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class CancelStreamedBodyTest implements HttpServerAdapters {\n+\n+    SSLContext sslContext;\n+    HttpTestServer httpTestServer;    \/\/ HTTP\/1.1    [ 4 servers ]\n+    HttpTestServer httpsTestServer;   \/\/ HTTPS\/1.1\n+    HttpTestServer http2TestServer;   \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;  \/\/ HTTP\/2 ( h2  )\n+    String httpURI;\n+    String httpsURI;\n+    String http2URI;\n+    String https2URI;\n+\n+    static final long SERVER_LATENCY = 75;\n+    static final int ITERATION_COUNT = 3;\n+    \/\/ a shared executor helps reduce the amount of threads created by the test\n+    static final Executor executor = new TestExecutor(Executors.newCachedThreadPool());\n+    static final ConcurrentMap<String, Throwable> FAILURES = new ConcurrentHashMap<>();\n+    static volatile boolean tasksFailed;\n+    static final AtomicLong serverCount = new AtomicLong();\n+    static final AtomicLong clientCount = new AtomicLong();\n+    static final long start = System.nanoTime();\n+    public static String now() {\n+        long now = System.nanoTime() - start;\n+        long secs = now \/ 1000_000_000;\n+        long mill = (now % 1000_000_000) \/ 1000_000;\n+        long nan = now % 1000_000;\n+        return String.format(\"[%d s, %d ms, %d ns] \", secs, mill, nan);\n+    }\n+\n+    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+    private volatile HttpClient sharedClient;\n+\n+    static class TestExecutor implements Executor {\n+        final AtomicLong tasks = new AtomicLong();\n+        Executor executor;\n+        TestExecutor(Executor executor) {\n+            this.executor = executor;\n+        }\n+\n+        @Override\n+        public void execute(Runnable command) {\n+            long id = tasks.incrementAndGet();\n+            executor.execute(() -> {\n+                try {\n+                    command.run();\n+                } catch (Throwable t) {\n+                    tasksFailed = true;\n+                    System.out.printf(now() + \"Task %s failed: %s%n\", id, t);\n+                    System.err.printf(now() + \"Task %s failed: %s%n\", id, t);\n+                    FAILURES.putIfAbsent(\"Task \" + id, t);\n+                    throw t;\n+                }\n+            });\n+        }\n+    }\n+\n+    protected boolean stopAfterFirstFailure() {\n+        return Boolean.getBoolean(\"jdk.internal.httpclient.debug\");\n+    }\n+\n+    final AtomicReference<SkipException> skiptests = new AtomicReference<>();\n+    void checkSkip() {\n+        var skip = skiptests.get();\n+        if (skip != null) throw skip;\n+    }\n+    static String name(ITestResult result) {\n+        var params = result.getParameters();\n+        return result.getName()\n+                + (params == null ? \"()\" : Arrays.toString(result.getParameters()));\n+    }\n+\n+    @BeforeMethod\n+    void beforeMethod(ITestContext context) {\n+        if (stopAfterFirstFailure() && context.getFailedTests().size() > 0) {\n+            if (skiptests.get() == null) {\n+                SkipException skip = new SkipException(\"some tests failed\");\n+                skip.setStackTrace(new StackTraceElement[0]);\n+                skiptests.compareAndSet(null, skip);\n+            }\n+        }\n+    }\n+\n+    @AfterClass\n+    static final void printFailedTests(ITestContext context) {\n+        out.println(\"\\n=========================\");\n+        var failed = context.getFailedTests().getAllResults().stream()\n+                .collect(Collectors.toMap(r -> name(r), ITestResult::getThrowable));\n+        FAILURES.putAll(failed);\n+        try {\n+            out.printf(\"%n%sCreated %d servers and %d clients%n\",\n+                    now(), serverCount.get(), clientCount.get());\n+            if (FAILURES.isEmpty()) return;\n+            out.println(\"Failed tests: \");\n+            FAILURES.entrySet().forEach((e) -> {\n+                out.printf(\"\\t%s: %s%n\", e.getKey(), e.getValue());\n+                e.getValue().printStackTrace(out);\n+            });\n+            if (tasksFailed) {\n+                System.out.println(\"WARNING: Some tasks failed\");\n+            }\n+        } finally {\n+            out.println(\"\\n=========================\\n\");\n+        }\n+    }\n+\n+    private String[] uris() {\n+        return new String[] {\n+                httpURI,\n+                httpsURI,\n+                http2URI,\n+                https2URI,\n+        };\n+    }\n+\n+\n+    @DataProvider(name = \"urls\")\n+    public Object[][] alltests() {\n+        String[] uris = uris();\n+        Object[][] result = new Object[uris.length * 2][];\n+        int i = 0;\n+        for (boolean sameClient : List.of(false, true)) {\n+            for (String uri : uris()) {\n+                String path = sameClient ? \"same\" : \"new\";\n+                result[i++] = new Object[]{uri + path, sameClient};\n+            }\n+        }\n+        assert i == uris.length * 2;\n+        return result;\n+    }\n+\n+    private HttpClient makeNewClient() {\n+        clientCount.incrementAndGet();\n+        var client = HttpClient.newBuilder()\n+                .proxy(HttpClient.Builder.NO_PROXY)\n+                .executor(executor)\n+                .sslContext(sslContext)\n+                .build();\n+        \/\/ It is OK to even track the shared client here:\n+        \/\/ the test methods will verify that the client has shut down\n+        \/\/ only if it's not the shared client.\n+        \/\/ Only the teardown() method verify that the shared client\n+        \/\/ has shut down in this test.\n+        return TRACKER.track(client);\n+    }\n+\n+    HttpClient newHttpClient(boolean share) {\n+        if (!share) return makeNewClient();\n+        HttpClient shared = sharedClient;\n+        if (shared != null) return shared;\n+        synchronized (this) {\n+            shared = sharedClient;\n+            if (shared == null) {\n+                shared = sharedClient = makeNewClient();\n+            }\n+            return shared;\n+        }\n+    }\n+\n+    final static String BODY = \"Some string |\\n that ?\\n can |\\n be split ?\\n several |\\n ways.\";\n+\n+\n+    @Test(dataProvider = \"urls\")\n+    public void testAsLines(String uri, boolean sameClient)\n+            throws Exception {\n+        checkSkip();\n+        HttpClient client = null;\n+        uri = uri + \"\/testAsLines\";\n+        out.printf(\"%n%s testAsLines(%s, %b)%n\", now(), uri, sameClient);\n+        for (int i=0; i< ITERATION_COUNT; i++) {\n+            if (!sameClient || client == null)\n+                client = newHttpClient(sameClient);\n+            var tracker = TRACKER.getTracker(client);\n+\n+            HttpRequest req = HttpRequest.newBuilder(URI.create(uri))\n+                    .GET()\n+                    .build();\n+            List<String> lines;\n+            for (int j = 0; j < 2; j++) {\n+                try (Stream<String> body = client.send(req, BodyHandlers.ofLines()).body()) {\n+                    lines = body.limit(j).toList();\n+                    assertEquals(lines, BODY.replaceAll(\"\\\\||\\\\?\", \"\")\n+                            .lines().limit(j).toList());\n+                }\n+                \/\/ Only check our still alive client for outstanding operations\n+                \/\/ and outstanding subscribers here: it should have none.\n+                var error = TRACKER.check(tracker, 500,\n+                        (t) -> t.getOutstandingOperations() > 0 || t.getOutstandingSubscribers() > 0,\n+                        \"subscribers for testAsLines(%s)\\n\\t step [%s,%s]\".formatted(req.uri(), i,j),\n+                        false);\n+                Reference.reachabilityFence(client);\n+                if (error != null) throw error;\n+            }\n+            \/\/ The shared client is only shut down at the end.\n+            \/\/ Skip shutdown check for the shared client.\n+            if (sameClient) continue;\n+            client = null;\n+            System.gc();\n+            var error = TRACKER.check(tracker, 500);\n+            if (error != null) throw error;\n+        }\n+    }\n+\n+    @Test(dataProvider = \"urls\")\n+    public void testInputStream(String uri, boolean sameClient)\n+            throws Exception {\n+        checkSkip();\n+        HttpClient client = null;\n+        uri = uri + \"\/testInputStream\";\n+        out.printf(\"%n%s testInputStream(%s, %b)%n\", now(), uri, sameClient);\n+        for (int i=0; i< ITERATION_COUNT; i++) {\n+            if (!sameClient || client == null)\n+                client = newHttpClient(sameClient);\n+            var tracker = TRACKER.getTracker(client);\n+\n+            HttpRequest req = HttpRequest.newBuilder(URI.create(uri))\n+                    .GET()\n+                    .build();\n+            int read = -1;\n+            for (int j = 0; j < 2; j++) {\n+                try (InputStream is = client.send(req, BodyHandlers.ofInputStream()).body()) {\n+                    for (int k = 0; k < j; k++) {\n+                        read = is.read();\n+                        assertEquals(read, BODY.charAt(k));\n+                    }\n+                }\n+                \/\/ Only check our still alive client for outstanding operations\n+                \/\/ and outstanding subscribers here: it should have none.\n+                var error = TRACKER.check(tracker, 1,\n+                        (t) -> t.getOutstandingOperations() > 0 || t.getOutstandingSubscribers() > 0,\n+                        \"subscribers for testInputStream(%s)\\n\\t step [%s,%s]\".formatted(req.uri(), i,j),\n+                        false);\n+                Reference.reachabilityFence(client);\n+                if (error != null) throw error;\n+            }\n+            \/\/ The shared client is only shut down at the end.\n+            \/\/ Skip shutdown check for the shared client.\n+            if (sameClient) continue;\n+            client = null;\n+            System.gc();\n+            var error = TRACKER.check(tracker, 1);\n+            if (error != null) throw error;\n+        }\n+    }\n+\n+\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        \/\/ HTTP\/1.1\n+        HttpTestHandler h1_chunkHandler = new HTTPSlowHandler();\n+        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer.addHandler(h1_chunkHandler, \"\/http1\/x\/\");\n+        httpURI = \"http:\/\/\" + httpTestServer.serverAuthority() + \"\/http1\/x\/\";\n+\n+        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n+        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer.addHandler(h1_chunkHandler, \"\/https1\/x\/\");\n+        httpsURI = \"https:\/\/\" + httpsTestServer.serverAuthority() + \"\/https1\/x\/\";\n+\n+        \/\/ HTTP\/2\n+        HttpTestHandler h2_chunkedHandler = new HTTPSlowHandler();\n+\n+        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer.addHandler(h2_chunkedHandler, \"\/http2\/x\/\");\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/x\/\";\n+\n+        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer.addHandler(h2_chunkedHandler, \"\/https2\/x\/\");\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/x\/\";\n+\n+        serverCount.addAndGet(4);\n+        httpTestServer.start();\n+        httpsTestServer.start();\n+        http2TestServer.start();\n+        https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        String sharedClientName =\n+                sharedClient == null ? null : sharedClient.toString();\n+        sharedClient = null;\n+        \/\/ check that the shared client (and any other client) have\n+        \/\/ properly shut down\n+        System.gc();\n+        Thread.sleep(100);\n+        AssertionError fail = TRACKER.check(500);\n+        try {\n+            httpTestServer.stop();\n+            httpsTestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+        } finally {\n+            if (fail != null) {\n+                if (sharedClientName != null) {\n+                    System.err.println(\"Shared client name is: \" + sharedClientName);\n+                }\n+                throw fail;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A handler that slowly sends back a body to give time for the\n+     * the request to get cancelled before the body is fully received.\n+     *\/\n+    static class HTTPSlowHandler implements HttpTestHandler {\n+        @Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            try {\n+                out.println(\"HTTPSlowHandler received request to \" + t.getRequestURI());\n+                System.err.println(\"HTTPSlowHandler received request to \" + t.getRequestURI());\n+\n+                byte[] req;\n+                try (InputStream is = t.getRequestBody()) {\n+                    req = is.readAllBytes();\n+                }\n+\n+                \/\/ we're not expecting a request body.\n+                \/\/ if we receive any, pretend we're a teapot.\n+                int status = req.length == 0 ? 200 : 418;\n+                t.sendResponseHeaders(status, -1); \/\/ chunked\/variable\n+                try (OutputStream os = t.getResponseBody()) {\n+                    \/\/ lets split the response in several chunks...\n+                    String msg = (req != null && req.length != 0)\n+                            ? new String(req, UTF_8)\n+                            : BODY;\n+                    String[] str = msg.split(\"\\\\|\");\n+                    for (var s : str) {\n+                        req = s.getBytes(UTF_8);\n+                        os.write(req);\n+                        os.flush();\n+                        out.printf(\"Server wrote %d bytes%n\", req.length);\n+                        try {\n+                            Thread.sleep(SERVER_LATENCY);\n+                        } catch (InterruptedException x) {\n+                            \/\/ OK\n+                        }\n+                    }\n+                }\n+            } catch (Throwable e) {\n+                out.println(\"HTTPSlowHandler: unexpected exception: \" + e);\n+                e.printStackTrace();\n+                throw e;\n+            } finally {\n+                out.printf(\"HTTPSlowHandler reply sent: %s%n\", t.getRequestURI());\n+                System.err.printf(\"HTTPSlowHandler reply sent: %s%n\", t.getRequestURI());\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/CancelStreamedBodyTest.java","additions":448,"deletions":0,"binary":false,"changes":448,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.Objects;\n@@ -64,0 +65,5 @@\n+    public StringBuilder diagnose(Tracker tracker, StringBuilder warnings, Predicate<Tracker> hasOutstanding) {\n+        checkOutstandingOperations(warnings, tracker, hasOutstanding);\n+        return warnings;\n+    }\n+\n@@ -66,1 +72,1 @@\n-            checkOutstandingOperations(warnings, tracker, hasOutstanding);\n+            diagnose(tracker, warnings, hasOutstanding);\n@@ -75,0 +81,4 @@\n+    public boolean hasOutstandingSubscribers() {\n+        return TRACKERS.stream().anyMatch(t -> t.getOutstandingSubscribers() > 0);\n+    }\n+\n@@ -89,0 +99,10 @@\n+    public AssertionError check(Tracker tracker, long graceDelayMs) {\n+        Predicate<Tracker> hasOperations = (t) -> t.getOutstandingOperations() > 0;\n+        Predicate<Tracker> hasSubscribers = (t) -> t.getOutstandingSubscribers() > 0;\n+        return check(tracker, graceDelayMs,\n+                hasOperations.or(hasSubscribers)\n+                        .or(Tracker::isFacadeReferenced)\n+                        .or(Tracker::isSelectorAlive),\n+                \"outstanding operations or unreleased resources\", false);\n+    }\n+\n@@ -90,0 +110,2 @@\n+        Predicate<Tracker> hasOperations = (t) -> t.getOutstandingOperations() > 0;\n+        Predicate<Tracker> hasSubscribers = (t) -> t.getOutstandingSubscribers() > 0;\n@@ -91,2 +113,4 @@\n-                (t) -> t.getOutstandingHttpOperations() > 0,\n-                \"outstanding operations\", true);\n+                hasOperations.or(hasSubscribers)\n+                .or(Tracker::isFacadeReferenced)\n+                .or(Tracker::isSelectorAlive),\n+        \"outstanding operations or unreleased resources\", true);\n@@ -176,0 +200,43 @@\n+    public Tracker getTracker(HttpClient client) {\n+        return OperationTrackers.getTracker(Objects.requireNonNull(client));\n+    }\n+\n+    public AssertionError check(Tracker tracker,\n+                                long graceDelayMs,\n+                                Predicate<Tracker> hasOutstanding,\n+                                String description,\n+                                boolean printThreads) {\n+        AssertionError fail = null;\n+        graceDelayMs = Math.max(graceDelayMs, 100);\n+        long delay = Math.min(graceDelayMs, 10);\n+        var count = delay > 0 ? graceDelayMs \/ delay : 1;\n+        for (int i = 0; i < count; i++) {\n+            if (hasOutstanding.test(tracker)) {\n+                System.gc();\n+                try {\n+                    if (i == 0) {\n+                        System.out.println(\"Waiting for HTTP operations to terminate...\");\n+                    }\n+                    Thread.sleep(Math.min(graceDelayMs, Math.max(delay, 1)));\n+                } catch (InterruptedException x) {\n+                    \/\/ OK\n+                }\n+            } else break;\n+        }\n+        if (hasOutstanding.test(tracker)) {\n+            StringBuilder warnings = diagnose(tracker, new StringBuilder(), hasOutstanding);\n+            if (hasOutstanding.test(tracker)) {\n+                fail = new AssertionError(warnings.toString());\n+            }\n+        } else {\n+            System.out.println(\"PASSED: No \" + description + \" found in \" + tracker.getName());\n+        }\n+        if (fail != null) {\n+            if (printThreads && tracker.isSelectorAlive()) {\n+                printThreads(\"Some selector manager threads are still alive: \", System.out);\n+                printThreads(\"Some selector manager threads are still alive: \", System.err);\n+            }\n+        }\n+        return fail;\n+    }\n+\n@@ -246,0 +313,1 @@\n+            warning.append(\"\\n\\tPending Subscribers: \" + tracker.getOutstandingSubscribers());\n@@ -270,0 +338,1 @@\n+        Predicate<Tracker> hasPendingSubscribers = (t) -> t.getOutstandingSubscribers() > 0;\n@@ -271,1 +340,3 @@\n-                isAlive.or(hasPendingRequests).or(hasPendingConnections),\n+                isAlive.or(hasPendingRequests)\n+                        .or(hasPendingConnections)\n+                        .or(hasPendingSubscribers),\n","filename":"test\/jdk\/java\/net\/httpclient\/ReferenceTracker.java","additions":75,"deletions":4,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,2 @@\n+import java.lang.ref.Reference;\n+import java.lang.ref.WeakReference;\n@@ -38,0 +40,2 @@\n+import java.util.concurrent.TimeUnit;\n+\n@@ -82,0 +86,1 @@\n+        Reference<HttpClient> reference = new WeakReference<>(client);\n@@ -154,0 +159,1 @@\n+\n@@ -157,1 +163,2 @@\n-                        HttpResponse<?> r = client.send(req, BodyHandlers.replacing(null));\n+                        HttpClient httpClient = reference.get();\n+                        HttpResponse<?> r = httpClient.send(req, BodyHandlers.replacing(null));\n@@ -176,1 +183,25 @@\n-            executor.shutdownNow();\n+            \/\/ shuts down the executor and awaits its termination\n+            \/\/executor.close();\n+            \/\/ In 17, ExecutorService does not implement close().\n+            \/\/ I derived this from the implementation of the method\n+            \/\/ in 21.\n+            {\n+                boolean terminated = executor.isTerminated();\n+                if (!terminated) {\n+                    executor.shutdown();\n+                    boolean interrupted = false;\n+                    while (!terminated) {\n+                        try {\n+                            terminated = executor.awaitTermination(1L, TimeUnit.DAYS);\n+                        } catch (InterruptedException e) {\n+                            if (!interrupted) {\n+                                executor.shutdownNow();\n+                                interrupted = true;\n+                            }\n+                        }\n+                    }\n+                    if (interrupted) {\n+                        Thread.currentThread().interrupt();\n+                    }\n+                }\n+            }\n@@ -185,0 +216,3 @@\n+            Reference.reachabilityFence(client);\n+            client = null;\n+            System.gc();\n@@ -186,1 +220,1 @@\n-                Thread.sleep(100);\n+                Thread.sleep(10);\n","filename":"test\/jdk\/java\/net\/httpclient\/SmallTimeout.java","additions":38,"deletions":4,"binary":false,"changes":42,"status":"modified"}]}