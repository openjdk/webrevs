{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,4 @@\n+    \/\/ this will be set to true only when the peer explicitly states (through a GOAWAY frame or\n+    \/\/ a relevant error code in reset frame) that the corresponding stream (id) wasn't processed\n+    private volatile boolean unprocessedByPeer;\n+\n@@ -267,0 +271,9 @@\n+\n+    final boolean isUnprocessedByPeer() {\n+        return this.unprocessedByPeer;\n+    }\n+\n+    \/\/ Marks the exchange as unprocessed by the peer\n+    final void markUnprocessedByPeer() {\n+        this.unprocessedByPeer = true;\n+    }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ExchangeImpl.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -320,0 +321,1 @@\n+    private final AtomicLong lastProcessedStreamInGoAway = new AtomicLong(-1);\n@@ -712,1 +714,3 @@\n-            if (connection.channel().isOpen()) {\n+            \/\/ we send a GOAWAY frame only if the remote side hasn't already indicated\n+            \/\/ the intention to close the connection by previously sending a GOAWAY of its own\n+            if (connection.channel().isOpen() && !isMarked(closedState, HALF_CLOSED_REMOTE)) {\n@@ -1235,7 +1239,40 @@\n-    private void handleGoAway(GoAwayFrame frame)\n-        throws IOException\n-    {\n-        if (markHalfClosedLRemote()) {\n-            shutdown(new IOException(\n-                    connection.channel().getLocalAddress()\n-                            + \": GOAWAY received\"));\n+    private void handleGoAway(final GoAwayFrame frame) {\n+        final long lastProcessedStream = frame.getLastStream();\n+        assert lastProcessedStream >= 0 : \"unexpected last stream id: \"\n+                + lastProcessedStream + \" in GOAWAY frame\";\n+\n+        markHalfClosedRemote();\n+        setFinalStream(); \/\/ don't allow any new streams on this connection\n+        if (debug.on()) {\n+            debug.log(\"processing incoming GOAWAY with last processed stream id:%s in frame %s\",\n+                    lastProcessedStream, frame);\n+        }\n+        \/\/ see if this connection has previously received a GOAWAY from the peer and if yes\n+        \/\/ then check if this new last processed stream id is lesser than the previous\n+        \/\/ known last processed stream id. Only update the last processed stream id if the new\n+        \/\/ one is lesser than the previous one.\n+        long prevLastProcessed = lastProcessedStreamInGoAway.get();\n+        while (prevLastProcessed == -1 || lastProcessedStream < prevLastProcessed) {\n+            if (lastProcessedStreamInGoAway.compareAndSet(prevLastProcessed,\n+                    lastProcessedStream)) {\n+                break;\n+            }\n+            prevLastProcessed = lastProcessedStreamInGoAway.get();\n+        }\n+        handlePeerUnprocessedStreams(lastProcessedStreamInGoAway.get());\n+    }\n+\n+    private void handlePeerUnprocessedStreams(final long lastProcessedStream) {\n+        final AtomicInteger numClosed = new AtomicInteger(); \/\/ atomic merely to allow usage within lambda\n+        streams.forEach((id, exchange) -> {\n+            if (id > lastProcessedStream) {\n+                \/\/ any streams with an stream id higher than the last processed stream\n+                \/\/ can be retried (on a new connection). we close the exchange as unprocessed\n+                \/\/ to facilitate the retrying.\n+                client2.client().theExecutor().ensureExecutedAsync(exchange::closeAsUnprocessed);\n+                numClosed.incrementAndGet();\n+            }\n+        });\n+        if (debug.on()) {\n+            debug.log(numClosed.get() + \" stream(s), with id greater than \" + lastProcessedStream\n+                    + \", will be closed as unprocessed\");\n@@ -1719,1 +1756,1 @@\n-    private boolean markHalfClosedLRemote() {\n+    private boolean markHalfClosedRemote() {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":46,"deletions":9,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    volatile boolean expiredOnce;\n+    volatile boolean retriedOnce;\n@@ -456,1 +456,1 @@\n-                                expiredOnce = false;\n+                                retriedOnce = false;\n@@ -469,1 +469,1 @@\n-                        CompletableFuture<Response> errorCF = getExceptionalCF(ex);\n+                        CompletableFuture<Response> errorCF = getExceptionalCF(ex, exch.exchImpl);\n@@ -541,1 +541,1 @@\n-    private CompletableFuture<Response> getExceptionalCF(Throwable t) {\n+    private CompletableFuture<Response> getExceptionalCF(Throwable t, ExchangeImpl<?> exchImpl) {\n@@ -547,0 +547,1 @@\n+        final boolean retryAsUnprocessed = exchImpl != null && exchImpl.isUnprocessedByPeer();\n@@ -551,1 +552,1 @@\n-        } else if (retryOnFailure(t)) {\n+        } else if (retryAsUnprocessed || retryOnFailure(t)) {\n@@ -558,2 +559,4 @@\n-                if (!canRetryRequest(currentreq)) {\n-                    return failedFuture(cause); \/\/ fails with original cause\n+                if (!retryAsUnprocessed && !canRetryRequest(currentreq)) {\n+                    \/\/ a (peer) processed request which cannot be retried, fail with\n+                    \/\/ the original cause\n+                    return failedFuture(cause);\n@@ -565,1 +568,1 @@\n-            if (!expiredOnce) {\n+            if (!retriedOnce) {\n@@ -567,2 +570,3 @@\n-                    debug.log(t.getClass().getSimpleName() + \" (async): retrying...\", t);\n-                expiredOnce = true;\n+                    debug.log(t.getClass().getSimpleName()\n+                            + \" (async): retrying \" + currentreq + \" due to: \", t);\n+                retriedOnce = true;\n@@ -579,1 +583,1 @@\n-                            + \" (async): already retried once.\", t);\n+                            + \" (async): already retried once \" + currentreq, t);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/MultiExchange.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -639,6 +639,24 @@\n-                int error = frame.getErrorCode();\n-                IOException e = new IOException(\"Received RST_STREAM: \"\n-                        + ErrorFrame.stringForCode(error));\n-                if (errorRef.compareAndSet(null, e)) {\n-                    if (subscriber != null) {\n-                        subscriber.onError(e);\n+                final int error = frame.getErrorCode();\n+                \/\/ A REFUSED_STREAM error code implies that the stream wasn't processed by the\n+                \/\/ peer and the client is free to retry the request afresh.\n+                if (error == ErrorFrame.REFUSED_STREAM) {\n+                    \/\/ Here we arrange for the request to be retried. Note that we don't call\n+                    \/\/ closeAsUnprocessed() method here because the \"closed\" state is already set\n+                    \/\/ to true a few lines above and calling close() from within\n+                    \/\/ closeAsUnprocessed() will end up being a no-op. We instead do the additional\n+                    \/\/ bookkeeping here.\n+                    markUnprocessedByPeer();\n+                    errorRef.compareAndSet(null, new IOException(\"request not processed by peer\"));\n+                    if (debug.on()) {\n+                        debug.log(\"request unprocessed by peer (REFUSED_STREAM) \" + this.request);\n+                    }\n+                } else {\n+                    final String reason = ErrorFrame.stringForCode(error);\n+                    final IOException failureCause = new IOException(\"Received RST_STREAM: \" + reason);\n+                    if (debug.on()) {\n+                        debug.log(streamid + \" received RST_STREAM with code: \" + reason);\n+                    }\n+                    if (errorRef.compareAndSet(null, failureCause)) {\n+                        if (subscriber != null) {\n+                            subscriber.onError(failureCause);\n+                        }\n@@ -647,1 +665,2 @@\n-                completeResponseExceptionally(e);\n+                final Throwable failureCause = errorRef.get();\n+                completeResponseExceptionally(failureCause);\n@@ -649,1 +668,1 @@\n-                    requestBodyCF.completeExceptionally(errorRef.get()); \/\/ we may be sending the body..\n+                    requestBodyCF.completeExceptionally(failureCause); \/\/ we may be sending the body..\n@@ -652,1 +671,1 @@\n-                    responseBodyCF.completeExceptionally(errorRef.get());\n+                    responseBodyCF.completeExceptionally(failureCause);\n@@ -1635,1 +1654,29 @@\n-        return connection.dbgString() + \"\/Stream(\"+streamid+\")\";\n+        final int id = streamid;\n+        final String sid = id == 0 ? \"?\" : String.valueOf(id);\n+        return connection.dbgString() + \"\/Stream(\" + sid + \")\";\n+    }\n+\n+    \/**\n+     * An unprocessed exchange is one that hasn't been processed by a peer. The local end of the\n+     * connection would be notified about such exchanges when it receives a GOAWAY frame with\n+     * a stream id that tells which exchanges have been unprocessed.\n+     * This method is called on such unprocessed exchanges and the implementation of this method\n+     * will arrange for the request, corresponding to this exchange, to be retried afresh on a\n+     * new connection.\n+     *\/\n+    void closeAsUnprocessed() {\n+        try {\n+            \/\/ We arrange for the request to be retried on a new connection as allowed by the RFC-9113\n+            markUnprocessedByPeer();\n+            this.errorRef.compareAndSet(null, new IOException(\"request not processed by peer\"));\n+            if (debug.on()) {\n+                debug.log(\"closing \" + this.request + \" as unprocessed by peer\");\n+            }\n+            \/\/ close the exchange and complete the response CF exceptionally\n+            close();\n+            completeResponseExceptionally(this.errorRef.get());\n+        } finally {\n+            \/\/ decrementStreamsCount isn't really needed but we do it to make sure\n+            \/\/ the log messages, where these counts\/states get reported, show the accurate state.\n+            connection.decrementStreamsCount(streamid);\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":57,"deletions":10,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,6 @@\n-            \/\/ Odd stream numbers (client streams) should have been registered.\n+            \/\/ A client initiated stream might be closed (as unprocessed, due to a\n+            \/\/ GOAWAY received on the connection) even before the stream is\n+            \/\/ registered with this WindowController instance (when sending out request headers).\n+            \/\/ Thus, for client initiated streams, we don't enforce the presence of the\n+            \/\/ stream in the registered \"streams\" map.\n+\n@@ -107,3 +112,1 @@\n-            if (old == null && isClientStream) {\n-                throw new InternalError(\"Expected entry for streamid: \" + streamid);\n-            } else if (old != null && !isClientStream) {\n+            if (old != null && !isClientStream) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/WindowController.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,3 @@\n-        return super.toString() + \" Debugdata: \" + new String(debugData, UTF_8);\n+        return super.toString()\n+                + \" lastStreamId=\" + lastStream\n+                + \", Debugdata: \" + new String(debugData, UTF_8);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/frame\/GoAwayFrame.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+import java.util.function.Predicate;\n@@ -243,0 +244,1 @@\n+        public abstract String getConnectionKey();\n@@ -257,1 +259,1 @@\n-            return new Http2TestExchangeImpl(exchange);\n+            return new H2ExchangeImpl(exchange);\n@@ -313,0 +315,6 @@\n+\n+            @Override\n+            public String getConnectionKey() {\n+                return exchange.getLocalAddress() + \"->\" + exchange.getRemoteAddress();\n+            }\n+\n@@ -319,1 +327,1 @@\n-        private static final class Http2TestExchangeImpl extends HttpTestExchange {\n+        private static final class H2ExchangeImpl extends HttpTestExchange {\n@@ -321,1 +329,1 @@\n-            Http2TestExchangeImpl(Http2TestExchange exch) {\n+            H2ExchangeImpl(Http2TestExchange exch) {\n@@ -374,0 +382,5 @@\n+            @Override\n+            public String getConnectionKey() {\n+                return exchange.getConnectionKey();\n+            }\n+\n@@ -719,0 +732,1 @@\n+        public abstract void setRequestApprover(final Predicate<String> approver);\n@@ -867,0 +881,5 @@\n+\n+            @Override\n+            public void setRequestApprover(final Predicate<String> approver) {\n+                throw new UnsupportedOperationException(\"not supported\");\n+            }\n@@ -918,0 +937,5 @@\n+\n+            @Override\n+            public void setRequestApprover(final Predicate<String> approver) {\n+                this.impl.setRequestApprover(approver);\n+            }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/common\/HttpServerAdapters.java","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,0 +87,6 @@\n+\n+    \/**\n+     * {@return the identification of the connection on which this exchange is being\n+     * processed}\n+     *\/\n+    String getConnectionKey();\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestExchange.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -219,0 +219,5 @@\n+    @Override\n+    public String getConnectionKey() {\n+        return conn.connectionKey();\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestExchangeImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import java.util.function.Predicate;\n+\n@@ -62,0 +64,2 @@\n+    \/\/ request approver which takes the server connection key as the input\n+    private volatile Predicate<String> newRequestApprover;\n@@ -288,0 +292,8 @@\n+    public void setRequestApprover(final Predicate<String> approver) {\n+        this.newRequestApprover = approver;\n+    }\n+\n+    Predicate<String> getRequestApprover() {\n+        return this.newRequestApprover;\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServer.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+import java.util.Set;\n@@ -83,0 +84,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -86,0 +88,1 @@\n+import java.util.function.Predicate;\n@@ -89,0 +92,1 @@\n+import static jdk.internal.net.http.frame.ErrorFrame.REFUSED_STREAM;\n@@ -118,0 +122,4 @@\n+    \/\/ the max stream id of a processed H2 request. -1 implies none were processed.\n+    private final AtomicInteger maxProcessedRequestStreamId = new AtomicInteger(-1);\n+    \/\/ the stream id that was sent in a GOAWAY frame. -1 implies no GOAWAY frame was sent.\n+    private final AtomicInteger goAwayRequestStreamId = new AtomicInteger(-1);\n@@ -242,5 +250,23 @@\n-    void goAway(int error) throws IOException {\n-        int laststream = nextstream >= 3 ? nextstream - 2 : 1;\n-\n-        GoAwayFrame go = new GoAwayFrame(laststream, error);\n-        outputQ.put(go);\n+    private void sendGoAway(final int error) throws IOException {\n+        int maxProcessedStreamId = maxProcessedRequestStreamId.get();\n+        if (maxProcessedStreamId == -1) {\n+            maxProcessedStreamId = 0;\n+        }\n+        boolean send = false;\n+        int currentGoAwayReqStrmId = goAwayRequestStreamId.get();\n+        \/\/ update the last processed stream id and send a goaway frame if the new last processed\n+        \/\/ stream id is lesser than the last processed stream id sent in\n+        \/\/ a previous goaway frame (if any)\n+        while (currentGoAwayReqStrmId == -1 || maxProcessedStreamId < currentGoAwayReqStrmId) {\n+            if (goAwayRequestStreamId.compareAndSet(currentGoAwayReqStrmId, maxProcessedStreamId)) {\n+                send = true;\n+                break;\n+            }\n+            currentGoAwayReqStrmId = goAwayRequestStreamId.get();\n+        }\n+        if (!send) {\n+            return;\n+        }\n+        final GoAwayFrame frame = new GoAwayFrame(maxProcessedStreamId, error);\n+        outputQ.put(frame);\n+        System.err.println(\"Sending GOAWAY frame \" + frame + \" from server connection \" + this);\n@@ -339,2 +365,3 @@\n-            if (error != -1)\n-                goAway(error);\n+            if (error != -1) {\n+                sendGoAway(error);\n+            }\n@@ -622,0 +649,8 @@\n+        \/\/ skip processing the request if configured to do so\n+        final String connKey = connectionKey();\n+        if (!shouldProcessNewHTTPRequest(connKey)) {\n+            System.err.println(\"Rejecting primordial stream 1 and sending GOAWAY\" +\n+                    \" on server connection \" + connKey + \", for request: \" + path);\n+            sendGoAway(ErrorFrame.NO_ERROR);\n+            return;\n+        }\n@@ -630,0 +665,1 @@\n+        maxProcessedRequestStreamId.set(1);\n@@ -635,0 +671,12 @@\n+    private boolean shouldProcessNewHTTPRequest(final String serverConnKey) {\n+        final Predicate<String> approver = this.server.getRequestApprover();\n+        if (approver == null) {\n+            return true; \/\/ process the request\n+        }\n+        return approver.test(serverConnKey);\n+    }\n+\n+    final String connectionKey() {\n+        return this.server.getAddress() + \"->\" + this.socket.getRemoteSocketAddress();\n+    }\n+\n@@ -642,1 +690,1 @@\n-            throw new IOException(\"unexpected stream id\");\n+            throw new IOException(\"unexpected stream id: \" + streamid);\n@@ -673,1 +721,1 @@\n-        if (disallowedHeader.isPresent())\n+        if (disallowedHeader.isPresent()) {\n@@ -675,0 +723,1 @@\n+        }\n@@ -676,1 +725,10 @@\n-\n+        \/\/ skip processing the request if the server is configured to do so\n+        final String connKey = connectionKey();\n+        final String path = headers.firstValue(\":path\").orElse(\"\");\n+        if (!shouldProcessNewHTTPRequest(connKey)) {\n+            System.err.println(\"Rejecting stream \" + streamid\n+                    + \" and sending GOAWAY on server connection \"\n+                    + connKey + \", for request: \" + path);\n+            sendGoAway(ErrorFrame.NO_ERROR);\n+            return;\n+        }\n@@ -679,0 +737,8 @@\n+        \/\/ keep track of the largest request id that we have processed\n+        int currentLargest = maxProcessedRequestStreamId.get();\n+        while (streamid > currentLargest) {\n+            if (maxProcessedRequestStreamId.compareAndSet(currentLargest, streamid)) {\n+                break;\n+            }\n+            currentLargest = maxProcessedRequestStreamId.get();\n+        }\n@@ -776,0 +842,2 @@\n+                    System.err.println(\"EOF reached on connection \" + connectionKey()\n+                            + \", will no longer accept incoming frames\");\n@@ -799,0 +867,11 @@\n+                            final int streamId = frame.streamid();\n+                            final int finalProcessedStreamId = goAwayRequestStreamId.get();\n+                            \/\/ if we already sent a goaway, then don't create new streams with\n+                            \/\/ higher stream ids.\n+                            if (finalProcessedStreamId != -1 && streamId > finalProcessedStreamId) {\n+                                System.err.println(connectionKey() + \" resetting stream \" + streamId\n+                                        + \" as REFUSED_STREAM\");\n+                                final ResetFrame rst = new ResetFrame(streamId, REFUSED_STREAM);\n+                                outputQ.put(rst);\n+                                continue;\n+                            }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServerConnection.java","additions":89,"deletions":10,"binary":false,"changes":99,"status":"modified"}]}