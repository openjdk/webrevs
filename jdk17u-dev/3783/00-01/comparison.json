{"files":[{"patch":"@@ -0,0 +1,339 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.util.ArrayList;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestExchange;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestHandler;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/*\n+ * @test\n+ * @bug 8335181\n+ * @summary verify that the HttpClient correctly handles incoming GOAWAY frames and\n+ *          retries any unprocessed requests on a new connection\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.common.HttpServerAdapters\n+ *        jdk.test.lib.net.SimpleSSLContext\n+ * @run junit H2GoAwayTest\n+ *\/\n+public class H2GoAwayTest {\n+    private static final String REQ_PATH = \"\/test\";\n+    private static HttpTestServer server;\n+    private static String REQ_URI_BASE;\n+    private static SSLContext sslCtx;\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        sslCtx = new SimpleSSLContext().get();\n+        assertNotNull(sslCtx, \"SSLContext couldn't be created\");\n+        server = HttpTestServer.create(HTTP_2, sslCtx);\n+        server.addHandler(new Handler(), REQ_PATH);\n+        server.start();\n+        System.out.println(\"Server started at \" + server.getAddress());\n+        REQ_URI_BASE = URIBuilder.newBuilder().scheme(\"https\")\n+                .loopback()\n+                .port(server.getAddress().getPort())\n+                .path(REQ_PATH)\n+                .build().toString();\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        if (server != null) {\n+            System.out.println(\"Stopping server at \" + server.getAddress());\n+            server.stop();\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that when several requests are sent using send() and the server\n+     * connection is configured to send a GOAWAY after processing only a few requests, then\n+     * the remaining requests are retried on a different connection\n+     *\/\n+    @Test\n+    public void testSequential() throws Exception {\n+        final LimitedPerConnRequestApprover reqApprover = new LimitedPerConnRequestApprover();\n+        server.setRequestApprover(reqApprover::allowNewRequest);\n+        final HttpClient client = HttpClient.newBuilder().version(HTTP_2)\n+            .sslContext(sslCtx).build();\n+        try {\n+            final String[] reqMethods = {\"HEAD\", \"GET\", \"POST\"};\n+            for (final String reqMethod : reqMethods) {\n+                final int numReqs = LimitedPerConnRequestApprover.MAX_REQS_PER_CONN + 3;\n+                final Set<String> connectionKeys = new LinkedHashSet<>();\n+                for (int i = 1; i <= numReqs; i++) {\n+                    final URI reqURI = new URI(REQ_URI_BASE + \"?seq&\" + reqMethod + \"=\" + i);\n+                    final HttpRequest req = HttpRequest.newBuilder()\n+                            .uri(reqURI)\n+                            .method(reqMethod, HttpRequest.BodyPublishers.noBody())\n+                            .build();\n+                    System.out.println(\"initiating request \" + req);\n+                    final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString());\n+                    final String respBody = resp.body();\n+                    System.out.println(\"received response: \" + respBody);\n+                    assertEquals(200, resp.statusCode(),\n+                            \"unexpected status code for request \" + resp.request());\n+                    \/\/ response body is the logical key of the connection on which the\n+                    \/\/ request was handled\n+                    connectionKeys.add(respBody);\n+                }\n+                System.out.println(\"connections involved in handling the requests: \"\n+                        + connectionKeys);\n+                \/\/ all requests have finished, we now just do a basic check that\n+                \/\/ more than one connection was involved in processing these requests\n+                assertEquals(2, connectionKeys.size(),\n+                        \"unexpected number of connections \" + connectionKeys);\n+            }\n+        } finally {\n+            server.setRequestApprover(null); \/\/ reset\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that when a server responds with a GOAWAY and then never processes the new retried\n+     * requests on a new connection too, then the application code receives the request failure.\n+     * This tests the send() API of the HttpClient.\n+     *\/\n+    @Test\n+    public void testUnprocessedRaisesException() throws Exception {\n+        final HttpClient client = HttpClient.newBuilder().version(HTTP_2)\n+            .sslContext(sslCtx).build();\n+        {\n+            final Random random = new Random();\n+            final String[] reqMethods = {\"HEAD\", \"GET\", \"POST\"};\n+            for (final String reqMethod : reqMethods) {\n+                final int maxAllowedReqs = 2;\n+                final int numReqs = maxAllowedReqs + 3; \/\/ 3 more requests than max allowed\n+                \/\/ configure the approver\n+                final LimitedRequestApprover reqApprover = new LimitedRequestApprover(maxAllowedReqs);\n+                server.setRequestApprover(reqApprover::allowNewRequest);\n+                try {\n+                    int numSuccess = 0;\n+                    int numFailed = 0;\n+                    for (int i = 1; i <= numReqs; i++) {\n+                        final String reqQueryPart = \"?sync&\" + reqMethod + \"=\" + i;\n+                        final URI reqURI = new URI(REQ_URI_BASE + reqQueryPart);\n+                        final HttpRequest req = HttpRequest.newBuilder()\n+                                .uri(reqURI)\n+                                .method(reqMethod, HttpRequest.BodyPublishers.noBody())\n+                                .build();\n+                        System.out.println(\"initiating request \" + req);\n+                        if (i <= maxAllowedReqs) {\n+                            \/\/ expected to successfully complete\n+                            numSuccess++;\n+                            final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString());\n+                            final String respBody = resp.body();\n+                            System.out.println(\"received response: \" + respBody);\n+                            assertEquals(200, resp.statusCode(),\n+                                    \"unexpected status code for request \" + resp.request());\n+                        } else {\n+                            \/\/ expected to fail as unprocessed\n+                            try {\n+                                final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString());\n+                                fail(\"Request was expected to fail as unprocessed,\"\n+                                        + \" but got response: \" + resp.body() + \", status code: \"\n+                                        + resp.statusCode());\n+                            } catch (IOException ioe) {\n+                                \/\/ verify it failed for the right reason\n+                                if (ioe.getMessage() == null\n+                                        || !ioe.getMessage().contains(\"request not processed by peer\")) {\n+                                    \/\/ propagate the original failure\n+                                    throw ioe;\n+                                }\n+                                numFailed++; \/\/ failed due to right reason\n+                                System.out.println(\"received expected failure: \" + ioe\n+                                        + \", for request \" + reqURI);\n+                            }\n+                        }\n+                    }\n+                    \/\/ verify the correct number of requests succeeded\/failed\n+                    assertEquals(maxAllowedReqs, numSuccess, \"unexpected number of requests succeeded\");\n+                    assertEquals((numReqs - maxAllowedReqs), numFailed, \"unexpected number of requests failed\");\n+                } finally {\n+                    server.setRequestApprover(null); \/\/ reset\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that when a server responds with a GOAWAY and then never processes the new retried\n+     * requests on a new connection too, then the application code receives the request failure.\n+     * This tests the sendAsync() API of the HttpClient.\n+     *\/\n+    @Test\n+    public void testUnprocessedRaisesExceptionAsync() throws Throwable {\n+        final HttpClient client = HttpClient.newBuilder().version(HTTP_2)\n+            .sslContext(sslCtx).build();\n+        {\n+            final Random random = new Random();\n+            final String[] reqMethods = {\"HEAD\", \"GET\", \"POST\"};\n+            for (final String reqMethod : reqMethods) {\n+                final int maxAllowedReqs = 2;\n+                final int numReqs = maxAllowedReqs + 3; \/\/ 3 more requests than max allowed\n+                \/\/ configure the approver\n+                final LimitedRequestApprover reqApprover = new LimitedRequestApprover(maxAllowedReqs);\n+                server.setRequestApprover(reqApprover::allowNewRequest);\n+                try {\n+                    final List<Future<HttpResponse<String>>> futures = new ArrayList<>();\n+                    for (int i = 1; i <= numReqs; i++) {\n+                        final URI reqURI = new URI(REQ_URI_BASE + \"?async&\" + reqMethod + \"=\" + i);\n+                        final HttpRequest req = HttpRequest.newBuilder()\n+                                .uri(reqURI)\n+                                .method(reqMethod, HttpRequest.BodyPublishers.noBody())\n+                                .build();\n+                        System.out.println(\"initiating request \" + req);\n+                        final Future<HttpResponse<String>> f = client.sendAsync(req, BodyHandlers.ofString());\n+                        futures.add(f);\n+                    }\n+                    \/\/ wait for responses\n+                    int numFailed = 0;\n+                    int numSuccess = 0;\n+                    for (int i = 1; i <= numReqs; i++) {\n+                        final String reqQueryPart = \"?async&\" + reqMethod + \"=\" + i;\n+                        try {\n+                            System.out.println(\"waiting response of request \"\n+                                    + REQ_URI_BASE + reqQueryPart);\n+                            final HttpResponse<String> resp = futures.get(i - 1).get();\n+                            numSuccess++;\n+                            final String respBody = resp.body();\n+                            System.out.println(\"request: \" + resp.request()\n+                                    + \", received response: \" + respBody);\n+                            assertEquals(200, resp.statusCode(),\n+                                    \"unexpected status code for request \" + resp.request());\n+                        } catch (ExecutionException ee) {\n+                            final Throwable cause = ee.getCause();\n+                            if (!(cause instanceof IOException ioe)) {\n+                                throw cause;\n+                            }\n+                            \/\/ verify it failed for the right reason\n+                            if (ioe.getMessage() == null\n+                                    || !ioe.getMessage().contains(\"request not processed by peer\")) {\n+                                \/\/ propagate the original failure\n+                                throw ioe;\n+                            }\n+                            numFailed++; \/\/ failed due to the right reason\n+                            System.out.println(\"received expected failure: \" + ioe\n+                                    + \", for request \" + REQ_URI_BASE + reqQueryPart);\n+                        }\n+                    }\n+                    \/\/ verify the correct number of requests succeeded\/failed\n+                    assertEquals(maxAllowedReqs, numSuccess, \"unexpected number of requests succeeded\");\n+                    assertEquals((numReqs - maxAllowedReqs), numFailed, \"unexpected number of requests failed\");\n+                } finally {\n+                    server.setRequestApprover(null); \/\/ reset\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ only allows fixed number of requests, irrespective of which server connection handles\n+    \/\/ it. requests that are rejected will either be sent a GOAWAY on the connection\n+    \/\/ or a RST_FRAME with a REFUSED_STREAM on the stream\n+    private static final class LimitedRequestApprover {\n+        private final int maxAllowedReqs;\n+        private final AtomicInteger numApproved = new AtomicInteger();\n+\n+        private LimitedRequestApprover(final int maxAllowedReqs) {\n+            this.maxAllowedReqs = maxAllowedReqs;\n+        }\n+\n+        public boolean allowNewRequest(final String serverConnKey) {\n+            final int approved = numApproved.incrementAndGet();\n+            return approved <= maxAllowedReqs;\n+        }\n+    }\n+\n+    \/\/ allows a certain number of requests per server connection.\n+    \/\/ requests that are rejected will either be sent a GOAWAY on the connection\n+    \/\/ or a RST_FRAME with a REFUSED_STREAM on the stream\n+    private static final class LimitedPerConnRequestApprover {\n+        private static final int MAX_REQS_PER_CONN = 6;\n+        private final Map<String, AtomicInteger> numApproved =\n+                new ConcurrentHashMap<>();\n+        private final Map<String, AtomicInteger> numDisapproved =\n+                new ConcurrentHashMap<>();\n+\n+        public boolean allowNewRequest(final String serverConnKey) {\n+            final AtomicInteger approved = numApproved.computeIfAbsent(serverConnKey,\n+                    (k) -> new AtomicInteger());\n+            int curr = approved.get();\n+            while (curr < MAX_REQS_PER_CONN) {\n+                if (approved.compareAndSet(curr, curr + 1)) {\n+                    return true; \/\/ new request allowed\n+                }\n+                curr = approved.get();\n+            }\n+            final AtomicInteger disapproved = numDisapproved.computeIfAbsent(serverConnKey,\n+                    (k) -> new AtomicInteger());\n+            final int numUnprocessed = disapproved.incrementAndGet();\n+            System.out.println(approved.get() + \" processed, \"\n+                    + numUnprocessed + \" unprocessed requests on connection \" + serverConnKey);\n+            return false;\n+        }\n+    }\n+\n+    private static final class Handler implements HttpTestHandler {\n+\n+        @Override\n+        public void handle(final HttpTestExchange exchange) throws IOException {\n+            final String connectionKey = exchange.getConnectionKey();\n+            System.out.println(\"responding to request: \" + exchange.getRequestURI()\n+                    + \" on connection \" + connectionKey);\n+            final byte[] response = connectionKey.getBytes(UTF_8);\n+            exchange.sendResponseHeaders(200, response.length);\n+            try (final OutputStream os = exchange.getResponseBody()) {\n+                os.write(response);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/H2GoAwayTest.java","additions":339,"deletions":0,"binary":false,"changes":339,"status":"added"}]}