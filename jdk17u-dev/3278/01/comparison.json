{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.security.ProviderException;\n@@ -60,0 +59,1 @@\n+    \/\/ cannot be final as it's re-assigned for deserialization\n@@ -74,0 +74,129 @@\n+    private static class DHComponents {\n+        final BigInteger x;\n+        final BigInteger p;\n+        final BigInteger g;\n+        final int l;\n+        final byte[] key;\n+\n+        DHComponents(BigInteger x, BigInteger p, BigInteger g, int l,\n+                byte[] key) {\n+            this.x = x;\n+            this.p = p;\n+            this.g = g;\n+            this.l = l;\n+            this.key = key;\n+        }\n+    }\n+\n+    \/\/ parses the specified encoding into a DHComponents object\n+    private static DHComponents decode(byte[] encodedKey)\n+            throws IOException {\n+        DerValue val = null;\n+\n+        try {\n+            val = new DerValue(encodedKey);\n+            if (val.tag != DerValue.tag_Sequence) {\n+                throw new IOException(\"Key not a SEQUENCE\");\n+            }\n+\n+            \/\/ version\n+            BigInteger parsedVersion = val.data.getBigInteger();\n+            if (!parsedVersion.equals(PKCS8_VERSION)) {\n+                throw new IOException(\"version mismatch: (supported: \" +\n+                        PKCS8_VERSION + \", parsed: \" + parsedVersion);\n+            }\n+\n+            \/\/ privateKeyAlgorithm\n+            DerValue algid = val.data.getDerValue();\n+            if (algid.tag != DerValue.tag_Sequence) {\n+                throw new IOException(\"AlgId is not a SEQUENCE\");\n+            }\n+            DerInputStream derInStream = algid.toDerInputStream();\n+            ObjectIdentifier oid = derInStream.getOID();\n+            if (oid == null) {\n+                throw new IOException(\"Null OID\");\n+            }\n+            if (derInStream.available() == 0) {\n+                throw new IOException(\"Parameters missing\");\n+            }\n+            \/\/ parse the parameters\n+            DerValue params = derInStream.getDerValue();\n+            if (params.tag == DerValue.tag_Null) {\n+                throw new IOException(\"Null parameters\");\n+            }\n+            if (params.tag != DerValue.tag_Sequence) {\n+                throw new IOException(\"Parameters not a SEQUENCE\");\n+            }\n+            params.data.reset();\n+            BigInteger p = params.data.getBigInteger();\n+            BigInteger g = params.data.getBigInteger();\n+            \/\/ Private-value length is OPTIONAL\n+            int l = (params.data.available() != 0 ?\n+                    params.data.getInteger() : 0);\n+            \/\/ should have no trailing data\n+            if (params.data.available() != 0) {\n+                throw new IOException(\"Extra parameter data\");\n+            }\n+\n+            \/\/ privateKey\n+            byte[] key = val.data.getOctetString();\n+            DerInputStream in = new DerInputStream(key);\n+            BigInteger x = in.getBigInteger();\n+\n+            \/\/ should have no trailing data\n+            if (val.data.available() != 0) {\n+                throw new IOException(\"Excess trailing data\");\n+            }\n+            return new DHComponents(x, p, g, l, key);\n+        } catch (NumberFormatException e) {\n+            throw new IOException(\"Error parsing key encoding\", e);\n+        } finally {\n+            if (val != null) {\n+                val.clear();\n+            }\n+        }\n+    }\n+\n+    \/\/ Generates the ASN.1 encoding\n+    private static byte[] encode(BigInteger p, BigInteger g, int l,\n+            byte[] key) {\n+        DerOutputStream tmp = new DerOutputStream();\n+        byte[] encoded;\n+        try {\n+        \/\/ version\n+        tmp.putInteger(PKCS8_VERSION);\n+\n+        \/\/ privateKeyAlgorithm\n+        DerOutputStream algid = new DerOutputStream();\n+\n+        \/\/ store OID\n+        algid.putOID(DHPublicKey.DH_OID);\n+        \/\/ encode parameters\n+        DerOutputStream params = new DerOutputStream();\n+        params.putInteger(p);\n+        params.putInteger(g);\n+        if (l != 0) {\n+            params.putInteger(l);\n+        }\n+        \/\/ wrap parameters into SEQUENCE\n+        DerValue paramSequence = new DerValue(DerValue.tag_Sequence,\n+                params.toByteArray());\n+        \/\/ store parameter SEQUENCE in algid\n+        algid.putDerValue(paramSequence);\n+        \/\/ wrap algid into SEQUENCE\n+        tmp.write(DerValue.tag_Sequence, algid);\n+\n+        \/\/ privateKey\n+        tmp.putOctetString(key);\n+\n+        \/\/ make it a SEQUENCE\n+        DerValue val = DerValue.wrap(DerValue.tag_Sequence, tmp);\n+        encoded = val.toByteArray();\n+        val.clear();\n+        } catch (IOException e) {\n+            \/\/ Ignore, see JDK-8297065.\n+            encoded = null;\n+        }\n+      return encoded;\n+    }\n+\n@@ -81,2 +210,0 @@\n-     *\n-     * @throws ProviderException if the key cannot be encoded\n@@ -85,1 +212,1 @@\n-        throws InvalidKeyException {\n+            throws InvalidKeyException {\n@@ -98,2 +225,0 @@\n-     *\n-     * @throws ProviderException if the key cannot be encoded\n@@ -106,0 +231,3 @@\n+\n+        byte[] xbytes = x.toByteArray();\n+        DerValue val = new DerValue(DerValue.tag_Integer, xbytes);\n@@ -107,2 +235,0 @@\n-            byte[] xbytes = x.toByteArray();\n-            DerValue val = new DerValue(DerValue.tag_Integer, xbytes);\n@@ -110,3 +236,0 @@\n-            val.clear();\n-            Arrays.fill(xbytes, (byte)0);\n-            encode();\n@@ -114,1 +237,4 @@\n-            throw new ProviderException(\"Cannot produce ASN.1 encoding\", e);\n+            \/\/ Ignore, see JDK-8297065.\n+        } finally {\n+            val.clear();\n+            Arrays.fill(xbytes, (byte) 0);\n@@ -116,0 +242,1 @@\n+        this.encodedKey = encode(p, g, l, key);\n@@ -127,1 +254,2 @@\n-        DerValue val = null;\n+        this.encodedKey = encodedKey.clone();\n+        DHComponents dc;\n@@ -129,62 +257,3 @@\n-            val = new DerValue(encodedKey);\n-            if (val.tag != DerValue.tag_Sequence) {\n-                throw new InvalidKeyException (\"Key not a SEQUENCE\");\n-            }\n-\n-            \/\/\n-            \/\/ version\n-            \/\/\n-            BigInteger parsedVersion = val.data.getBigInteger();\n-            if (!parsedVersion.equals(PKCS8_VERSION)) {\n-                throw new IOException(\"version mismatch: (supported: \" +\n-                                      PKCS8_VERSION + \", parsed: \" +\n-                                      parsedVersion);\n-            }\n-\n-            \/\/\n-            \/\/ privateKeyAlgorithm\n-            \/\/\n-            DerValue algid = val.data.getDerValue();\n-            if (algid.tag != DerValue.tag_Sequence) {\n-                throw new InvalidKeyException(\"AlgId is not a SEQUENCE\");\n-            }\n-            DerInputStream derInStream = algid.toDerInputStream();\n-            ObjectIdentifier oid = derInStream.getOID();\n-            if (oid == null) {\n-                throw new InvalidKeyException(\"Null OID\");\n-            }\n-            if (derInStream.available() == 0) {\n-                throw new InvalidKeyException(\"Parameters missing\");\n-            }\n-            \/\/ parse the parameters\n-            DerValue params = derInStream.getDerValue();\n-            if (params.tag == DerValue.tag_Null) {\n-                throw new InvalidKeyException(\"Null parameters\");\n-            }\n-            if (params.tag != DerValue.tag_Sequence) {\n-                throw new InvalidKeyException(\"Parameters not a SEQUENCE\");\n-            }\n-            params.data.reset();\n-            this.p = params.data.getBigInteger();\n-            this.g = params.data.getBigInteger();\n-            \/\/ Private-value length is OPTIONAL\n-            if (params.data.available() != 0) {\n-                this.l = params.data.getInteger();\n-            }\n-            if (params.data.available() != 0) {\n-                throw new InvalidKeyException(\"Extra parameter data\");\n-            }\n-\n-            \/\/\n-            \/\/ privateKey\n-            \/\/\n-            this.key = val.data.getOctetString();\n-            parseKeyBits();\n-\n-            this.encodedKey = encodedKey.clone();\n-        } catch (IOException | NumberFormatException e) {\n-            throw new InvalidKeyException(\"Error parsing key encoding\", e);\n-        } finally {\n-            if (val != null) {\n-                val.clear();\n-            }\n+            dc = decode(this.encodedKey);\n+        } catch (IOException e) {\n+            throw new InvalidKeyException(\"Invalid encoding\", e);\n@@ -192,0 +261,5 @@\n+        this.x = dc.x;\n+        this.p = dc.p;\n+        this.g = dc.g;\n+        this.l = dc.l;\n+        this.key = dc.key;\n@@ -212,1 +286,0 @@\n-        encode();\n@@ -216,49 +289,0 @@\n-    \/**\n-     * Generate the encodedKey field if it has not been calculated.\n-     * Could generate null.\n-     *\/\n-    private void encode() {\n-        if (this.encodedKey == null) {\n-            try {\n-                DerOutputStream tmp = new DerOutputStream();\n-\n-                \/\/\n-                \/\/ version\n-                \/\/\n-                tmp.putInteger(PKCS8_VERSION);\n-\n-                \/\/\n-                \/\/ privateKeyAlgorithm\n-                \/\/\n-                DerOutputStream algid = new DerOutputStream();\n-\n-                \/\/ store OID\n-                algid.putOID(DHPublicKey.DH_OID);\n-                \/\/ encode parameters\n-                DerOutputStream params = new DerOutputStream();\n-                params.putInteger(this.p);\n-                params.putInteger(this.g);\n-                if (this.l != 0) {\n-                    params.putInteger(this.l);\n-                }\n-                \/\/ wrap parameters into SEQUENCE\n-                DerValue paramSequence = new DerValue(DerValue.tag_Sequence,\n-                                                      params.toByteArray());\n-                \/\/ store parameter SEQUENCE in algid\n-                algid.putDerValue(paramSequence);\n-                \/\/ wrap algid into SEQUENCE\n-                tmp.write(DerValue.tag_Sequence, algid);\n-\n-                \/\/ privateKey\n-                tmp.putOctetString(this.key);\n-\n-                \/\/ make it a SEQUENCE\n-                DerValue val = DerValue.wrap(DerValue.tag_Sequence, tmp);\n-                this.encodedKey = val.toByteArray();\n-                val.clear();\n-            } catch (IOException e) {\n-                throw new AssertionError(e);\n-            }\n-        }\n-    }\n-\n@@ -287,12 +311,0 @@\n-    private void parseKeyBits() throws InvalidKeyException {\n-        try {\n-            DerInputStream in = new DerInputStream(this.key);\n-            this.x = in.getBigInteger();\n-        } catch (IOException e) {\n-            InvalidKeyException ike = new InvalidKeyException(\n-                \"Error parsing key encoding: \" + e.getMessage());\n-            ike.initCause(e);\n-            throw ike;\n-        }\n-    }\n-\n@@ -331,4 +343,1 @@\n-        encode();\n-        return new KeyRep(KeyRep.Type.PRIVATE,\n-                getAlgorithm(),\n-                getFormat(),\n+        return new KeyRep(KeyRep.Type.PRIVATE, getAlgorithm(), getFormat(),\n@@ -354,1 +363,0 @@\n-        this.key = key.clone();\n@@ -359,1 +367,23 @@\n-        this.encodedKey = encodedKey.clone();\n+        \/\/ check if the \"encodedKey\" value matches the deserialized fields\n+        DHComponents c;\n+        byte[] encodedKeyIntern = encodedKey.clone();\n+        try {\n+            c = decode(encodedKeyIntern);\n+        } catch (IOException e) {\n+            InvalidObjectException ioe = new InvalidObjectException(\"Invalid encoding\");\n+            if (ioe != null) {\n+                ioe.initCause(e);\n+            }\n+            throw ioe;\n+        }\n+        if (!Arrays.equals(c.key, key) || !c.x.equals(x) || !c.p.equals(p)\n+                || !c.g.equals(g) || c.l != l) {\n+            throw new InvalidObjectException(\n+                    \"encoded key not matching internal fields\");\n+        }\n+        \/\/ zero out external arrays\n+        Arrays.fill(key, (byte)0x00);\n+        Arrays.fill(encodedKey, (byte)0x00);\n+        \/\/ use self-created internal copies\n+        this.key = c.key;\n+        this.encodedKey = encodedKeyIntern;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHPrivateKey.java","additions":174,"deletions":144,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.Arrays;\n@@ -74,0 +75,116 @@\n+    private static class DHComponents {\n+        final BigInteger y;\n+        final BigInteger p;\n+        final BigInteger g;\n+        final int l;\n+        final byte[] key;\n+\n+        DHComponents(BigInteger y, BigInteger p, BigInteger g, int l,\n+                byte[] key) {\n+            this.y = y;\n+            this.p = p;\n+            this.g = g;\n+            this.l = l;\n+            this.key = key;\n+        }\n+    }\n+\n+    \/\/ parses the specified encoding into a DHComponents object\n+    private static DHComponents decode(byte[] encodedKey)\n+            throws IOException {\n+        DerValue val = null;\n+\n+        try {\n+            val = new DerValue(encodedKey);\n+            if (val.tag != DerValue.tag_Sequence) {\n+                throw new IOException(\"Invalid key format\");\n+            }\n+\n+            \/\/ algorithm identifier\n+            DerValue algid = val.data.getDerValue();\n+            if (algid.tag != DerValue.tag_Sequence) {\n+                throw new IOException(\"AlgId is not a SEQUENCE\");\n+            }\n+            DerInputStream derInStream = algid.toDerInputStream();\n+            ObjectIdentifier oid = derInStream.getOID();\n+            if (oid == null) {\n+                throw new IOException(\"Null OID\");\n+            }\n+            if (derInStream.available() == 0) {\n+                throw new IOException(\"Parameters missing\");\n+            }\n+\n+            \/\/ parse the parameters\n+            DerValue params = derInStream.getDerValue();\n+            if (params.tag == DerValue.tag_Null) {\n+                throw new IOException(\"Null parameters\");\n+            }\n+            if (params.tag != DerValue.tag_Sequence) {\n+                throw new IOException(\"Parameters not a SEQUENCE\");\n+            }\n+            params.data.reset();\n+\n+            BigInteger p = params.data.getBigInteger();\n+            BigInteger g = params.data.getBigInteger();\n+            \/\/ Private-value length is OPTIONAL\n+            int l = (params.data.available() != 0 ? params.data.getInteger() :\n+                    0);\n+            if (params.data.available() != 0) {\n+                throw new IOException(\"Extra parameter data\");\n+            }\n+\n+            \/\/ publickey\n+            byte[] key = val.data.getBitString();\n+            DerInputStream in = new DerInputStream(key);\n+            BigInteger y = in.getBigInteger();\n+\n+            if (val.data.available() != 0) {\n+                throw new IOException(\"Excess key data\");\n+            }\n+            return new DHComponents(y, p, g, l, key);\n+        } catch (NumberFormatException e) {\n+            throw new IOException(\"Error parsing key encoding\", e);\n+        }\n+    }\n+\n+    \/\/ generates the ASN.1 encoding\n+    private static byte[] encode(BigInteger p, BigInteger g, int l,\n+            byte[] key) {\n+        DerOutputStream algid = new DerOutputStream();\n+        DerOutputStream derKey;\n+\n+        try {\n+        \/\/ store oid in algid\n+        algid.putOID(DH_OID);\n+\n+        \/\/ encode parameters\n+        DerOutputStream params = new DerOutputStream();\n+        params.putInteger(p);\n+        params.putInteger(g);\n+        if (l != 0) {\n+            params.putInteger(l);\n+        }\n+\n+        \/\/ wrap parameters into SEQUENCE\n+        DerValue paramSequence = new DerValue(DerValue.tag_Sequence,\n+                params.toByteArray());\n+        \/\/ store parameter SEQUENCE in algid\n+        algid.putDerValue(paramSequence);\n+\n+        \/\/ wrap algid into SEQUENCE, and store it in key encoding\n+        DerOutputStream tmpDerKey = new DerOutputStream();\n+        tmpDerKey.write(DerValue.tag_Sequence, algid);\n+\n+        \/\/ store key data\n+        tmpDerKey.putBitString(key);\n+\n+        \/\/ wrap algid and key into SEQUENCE\n+        derKey = new DerOutputStream();\n+        derKey.write(DerValue.tag_Sequence, tmpDerKey);\n+        } catch (IOException e) {\n+            \/\/ Ignore, see JDK-8297065.\n+            derKey = null;\n+        }\n+        return derKey.toByteArray();\n+    }\n+\n@@ -109,1 +226,1 @@\n-            this.encodedKey = getEncoded();\n+            this.encodedKey = encode(p, g, l, key);\n@@ -124,52 +241,1 @@\n-        InputStream inStream = new ByteArrayInputStream(encodedKey);\n-        try {\n-            DerValue derKeyVal = new DerValue(inStream);\n-            if (derKeyVal.tag != DerValue.tag_Sequence) {\n-                throw new InvalidKeyException (\"Invalid key format\");\n-            }\n-\n-            \/*\n-             * Parse the algorithm identifier\n-             *\/\n-            DerValue algid = derKeyVal.data.getDerValue();\n-            if (algid.tag != DerValue.tag_Sequence) {\n-                throw new InvalidKeyException(\"AlgId is not a SEQUENCE\");\n-            }\n-            DerInputStream derInStream = algid.toDerInputStream();\n-            ObjectIdentifier oid = derInStream.getOID();\n-            if (oid == null) {\n-                throw new InvalidKeyException(\"Null OID\");\n-            }\n-            if (derInStream.available() == 0) {\n-                throw new InvalidKeyException(\"Parameters missing\");\n-            }\n-\n-            \/*\n-             * Parse the parameters\n-             *\/\n-            DerValue params = derInStream.getDerValue();\n-            if (params.tag == DerValue.tag_Null) {\n-                throw new InvalidKeyException(\"Null parameters\");\n-            }\n-            if (params.tag != DerValue.tag_Sequence) {\n-                throw new InvalidKeyException(\"Parameters not a SEQUENCE\");\n-            }\n-            params.data.reset();\n-            this.p = params.data.getBigInteger();\n-            this.g = params.data.getBigInteger();\n-            \/\/ Private-value length is OPTIONAL\n-            if (params.data.available() != 0) {\n-                this.l = params.data.getInteger();\n-            }\n-            if (params.data.available() != 0) {\n-                throw new InvalidKeyException(\"Extra parameter data\");\n-            }\n-\n-            \/*\n-             * Parse the key\n-             *\/\n-            this.key = derKeyVal.data.getBitString();\n-            parseKeyBits();\n-            if (derKeyVal.data.available() != 0) {\n-                throw new InvalidKeyException(\"Excess key data\");\n-            }\n+        this.encodedKey = encodedKey.clone();\n@@ -177,3 +243,5 @@\n-            this.encodedKey = encodedKey.clone();\n-        } catch (IOException | NumberFormatException e) {\n-            throw new InvalidKeyException(\"Error parsing key encoding\", e);\n+        DHComponents dc;\n+        try {\n+            dc = decode(this.encodedKey);\n+        } catch (IOException e) {\n+            throw new InvalidKeyException(\"Invalid encoding\", e);\n@@ -181,0 +249,5 @@\n+        this.y = dc.y;\n+        this.p = dc.p;\n+        this.g = dc.g;\n+        this.l = dc.l;\n+        this.key = dc.key;\n@@ -201,35 +274,0 @@\n-        if (this.encodedKey == null) {\n-            try {\n-                DerOutputStream algid = new DerOutputStream();\n-\n-                \/\/ store oid in algid\n-                algid.putOID(DH_OID);\n-\n-                \/\/ encode parameters\n-                DerOutputStream params = new DerOutputStream();\n-                params.putInteger(this.p);\n-                params.putInteger(this.g);\n-                if (this.l != 0) {\n-                    params.putInteger(this.l);\n-                }\n-                \/\/ wrap parameters into SEQUENCE\n-                DerValue paramSequence = new DerValue(DerValue.tag_Sequence,\n-                                                      params.toByteArray());\n-                \/\/ store parameter SEQUENCE in algid\n-                algid.putDerValue(paramSequence);\n-\n-                \/\/ wrap algid into SEQUENCE, and store it in key encoding\n-                DerOutputStream tmpDerKey = new DerOutputStream();\n-                tmpDerKey.write(DerValue.tag_Sequence, algid);\n-\n-                \/\/ store key data\n-                tmpDerKey.putBitString(this.key);\n-\n-                \/\/ wrap algid and key into SEQUENCE\n-                DerOutputStream derKey = new DerOutputStream();\n-                derKey.write(DerValue.tag_Sequence, tmpDerKey);\n-                this.encodedKey = derKey.toByteArray();\n-            } catch (IOException e) {\n-                return null;\n-            }\n-        }\n@@ -272,1 +310,1 @@\n-        if (this.l != 0)\n+        if (this.l != 0) {\n@@ -274,10 +312,0 @@\n-        return sb.toString();\n-    }\n-\n-    private void parseKeyBits() throws InvalidKeyException {\n-        try {\n-            DerInputStream in = new DerInputStream(this.key);\n-            this.y = in.getBigInteger();\n-        } catch (IOException e) {\n-            throw new InvalidKeyException(\n-                \"Error parsing key encoding: \" + e.toString());\n@@ -285,0 +313,1 @@\n+        return sb.toString();\n@@ -323,1 +352,1 @@\n-                        getEncoded());\n+                        encodedKey);\n@@ -342,1 +371,0 @@\n-        this.key = key.clone();\n@@ -347,1 +375,23 @@\n-        this.encodedKey = encodedKey.clone();\n+        \/\/ check if the \"encodedKey\" value matches the deserialized fields\n+        DHComponents c;\n+        byte[] encodedKeyIntern = encodedKey.clone();\n+        try {\n+            c = decode(encodedKeyIntern);\n+        } catch (IOException e) {\n+            InvalidObjectException ioe = new InvalidObjectException(\"Invalid encoding\");\n+            if (ioe != null) {\n+                ioe.initCause(e);\n+            }\n+            throw ioe;\n+        }\n+        if (!Arrays.equals(c.key, key) || !c.y.equals(y) || !c.p.equals(p)\n+                || !c.g.equals(g) || c.l != l) {\n+            throw new InvalidObjectException(\n+                    \"encoded key not matching internal fields\");\n+        }\n+        \/\/ zero out external arrays\n+        Arrays.fill(key, (byte)0x00);\n+        Arrays.fill(encodedKey, (byte)0x00);\n+        \/\/ use self-created internal copies\n+        this.key = c.key;\n+        this.encodedKey = encodedKeyIntern;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHPublicKey.java","additions":156,"deletions":106,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -199,17 +199,19 @@\n-       \/**\n-        * Restores the state of this object from the stream.\n-        *\n-        * @param  stream the {@code ObjectInputStream} from which data is read\n-        * @throws IOException if an I\/O error occurs\n-        * @throws ClassNotFoundException if a serialized class cannot be loaded\n-        *\/\n-       @java.io.Serial\n-       private void readObject(ObjectInputStream stream)\n-               throws IOException, ClassNotFoundException {\n-           stream.defaultReadObject();\n-           if ((key == null) || (key.length == 0)) {\n-               throw new InvalidObjectException(\"TlsMasterSecretKey is null\");\n-           }\n-           key = key.clone();\n-       }\n-   }\n+        \/**\n+         * Restores the state of this object from the stream.\n+         *\n+         * @param  stream the {@code ObjectInputStream} from which data is read\n+         * @throws IOException if an I\/O error occurs\n+         * @throws ClassNotFoundException if a serialized class cannot be loaded\n+         *\/\n+        @java.io.Serial\n+        private void readObject(ObjectInputStream stream)\n+                throws IOException, ClassNotFoundException {\n+            stream.defaultReadObject();\n+            if (key == null || key.length == 0) {\n+                throw new InvalidObjectException(\"TlsMasterSecretKey is null\");\n+            }\n+            byte[] temp = key;\n+            this.key = temp.clone();\n+            Arrays.fill(temp, (byte)0);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/TlsMasterSecretGenerator.java","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -406,0 +406,5 @@\n+\n+        if (perms == null) {\n+            throw new InvalidObjectException(\"perms can't be null\");\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/security\/Permissions.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,4 +155,4 @@\n-        throws IOException, InvalidKeyException, SignatureException {\n-            \/\/ creating a stream pipe-line, from a to b\n-            ByteArrayOutputStream b = new ByteArrayOutputStream();\n-            ObjectOutput a = new ObjectOutputStream(b);\n+            throws IOException, InvalidKeyException, SignatureException {\n+        \/\/ creating a stream pipe-line, from a to b\n+        ByteArrayOutputStream b = new ByteArrayOutputStream();\n+        ObjectOutput a = new ObjectOutputStream(b);\n@@ -160,6 +160,6 @@\n-            \/\/ write and flush the object content to byte array\n-            a.writeObject(object);\n-            a.flush();\n-            a.close();\n-            this.content = b.toByteArray();\n-            b.close();\n+        \/\/ write and flush the object content to byte array\n+        a.writeObject(object);\n+        a.flush();\n+        a.close();\n+        this.content = b.toByteArray();\n+        b.close();\n@@ -167,2 +167,2 @@\n-            \/\/ now sign the encapsulated object\n-            this.sign(signingKey, signingEngine);\n+        \/\/ now sign the encapsulated object\n+        this.sign(signingKey, signingEngine);\n@@ -248,6 +248,6 @@\n-        throws InvalidKeyException, SignatureException {\n-            \/\/ initialize the signing engine\n-            signingEngine.initSign(signingKey);\n-            signingEngine.update(this.content.clone());\n-            this.signature = signingEngine.sign().clone();\n-            this.thealgorithm = signingEngine.getAlgorithm();\n+            throws InvalidKeyException, SignatureException {\n+        \/\/ initialize the signing engine\n+        signingEngine.initSign(signingKey);\n+        signingEngine.update(this.content.clone());\n+        this.signature = signingEngine.sign();\n+        this.thealgorithm = signingEngine.getAlgorithm();\n@@ -266,5 +266,11 @@\n-        throws IOException, ClassNotFoundException {\n-            ObjectInputStream.GetField fields = s.readFields();\n-            content = ((byte[])fields.get(\"content\", null)).clone();\n-            signature = ((byte[])fields.get(\"signature\", null)).clone();\n-            thealgorithm = (String)fields.get(\"thealgorithm\", null);\n+            throws IOException, ClassNotFoundException {\n+       ObjectInputStream.GetField fields = s.readFields();\n+       byte[] c = (byte[]) fields.get(\"content\", null);\n+       byte[] sig = (byte[]) fields.get(\"signature\", null);\n+       String a = (String) fields.get(\"thealgorithm\", null);\n+       if (c == null || sig == null || a == null) {\n+           throw new InvalidObjectException(\"One or more null fields\");\n+       }\n+       content = c.clone();\n+       signature = sig.clone();\n+       thealgorithm = a;\n","filename":"src\/java.base\/share\/classes\/java\/security\/SignedObject.java","additions":30,"deletions":24,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-        if (timestamp == null || signerCertPath == null) {\n+        if (isNull(timestamp, signerCertPath)) {\n@@ -164,1 +164,1 @@\n-        throws IOException, ClassNotFoundException {\n+            throws IOException, ClassNotFoundException {\n@@ -166,0 +166,3 @@\n+        if (isNull(timestamp, signerCertPath)) {\n+            throw new InvalidObjectException(\"Invalid null field(s)\");\n+        }\n@@ -169,0 +172,4 @@\n+\n+    private static boolean isNull(Date d, CertPath c) {\n+        return (d == null || c == null);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/security\/Timestamp.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.io.InvalidObjectException;\n@@ -206,1 +207,0 @@\n-        @SuppressWarnings(\"unchecked\")\n@@ -209,4 +209,9 @@\n-        Hashtable<String, Vector<UnresolvedPermission>> permissions =\n-                (Hashtable<String, Vector<UnresolvedPermission>>)\n-                gfields.get(\"permissions\", null);\n-        perms = new ConcurrentHashMap<>(permissions.size()*2);\n+        try {\n+            @SuppressWarnings(\"unchecked\")\n+            Hashtable<String, Vector<UnresolvedPermission>> permissions =\n+                    (Hashtable<String, Vector<UnresolvedPermission>>)\n+                    gfields.get(\"permissions\", null);\n+\n+            if (permissions == null) {\n+                throw new InvalidObjectException(\"Invalid null permissions\");\n+            }\n@@ -214,6 +219,1 @@\n-        \/\/ Convert each entry (Vector) into a List\n-        Set<Map.Entry<String, Vector<UnresolvedPermission>>> set = permissions.entrySet();\n-        for (Map.Entry<String, Vector<UnresolvedPermission>> e : set) {\n-            \/\/ Convert Vector into ArrayList\n-            Vector<UnresolvedPermission> vec = e.getValue();\n-            List<UnresolvedPermission> list = new CopyOnWriteArrayList<>(vec);\n+            perms = new ConcurrentHashMap<>(permissions.size()*2);\n@@ -221,2 +221,12 @@\n-            \/\/ Add to Hashtable being serialized\n-            perms.put(e.getKey(), list);\n+            \/\/ Convert each entry (Vector) into a List\n+            Set<Map.Entry<String, Vector<UnresolvedPermission>>> set = permissions.entrySet();\n+            for (Map.Entry<String, Vector<UnresolvedPermission>> e : set) {\n+                \/\/ Convert Vector into ArrayList\n+                Vector<UnresolvedPermission> vec = e.getValue();\n+                List<UnresolvedPermission> list = new CopyOnWriteArrayList<>(vec);\n+\n+                \/\/ Add to Hashtable being serialized\n+                perms.put(e.getKey(), list);\n+            }\n+        } catch (ClassCastException cce) {\n+            throw new InvalidObjectException(\"Invalid type for permissions\");\n","filename":"src\/java.base\/share\/classes\/java\/security\/UnresolvedPermissionCollection.java","additions":24,"deletions":14,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.io.InvalidObjectException;\n@@ -73,0 +74,7 @@\n+    private static boolean isNull(Date revocationDate,\n+            CRLReason reason, X500Principal authority,\n+            Map<String, Extension> extensions) {\n+        return (revocationDate == null || reason == null || authority == null\n+                || extensions == null);\n+    }\n+\n@@ -95,2 +103,1 @@\n-        if (revocationDate == null || reason == null || authority == null ||\n-            extensions == null) {\n+        if (isNull(revocationDate, reason, authority, extensions)) {\n@@ -237,3 +244,0 @@\n-        \/\/ Defensively copy the revocation date\n-        revocationDate = new Date(revocationDate.getTime());\n-\n@@ -250,0 +254,7 @@\n+        \/\/ make sure all fields are set before checking\n+        if (isNull(revocationDate, reason, authority, extensions)) {\n+            throw new InvalidObjectException(\"Invalid null field(s)\");\n+        }\n+\n+        \/\/ Defensively copy the revocation date\n+        revocationDate = new Date(revocationDate.getTime());\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/CertificateRevokedException.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,5 +109,3 @@\n-        if (key == null || algorithm == null) {\n-            throw new IllegalArgumentException(\"Missing argument\");\n-        }\n-        if (key.length == 0) {\n-            throw new IllegalArgumentException(\"Empty key\");\n+        String errMsg = doSanityCheck(key, algorithm);\n+        if (errMsg != null) {\n+            throw new IllegalArgumentException(errMsg);\n@@ -277,3 +275,3 @@\n-\n-        if (key == null || algorithm == null) {\n-            throw new InvalidObjectException(\"Missing argument\");\n+        String errMsg = doSanityCheck(key, algorithm);\n+        if (errMsg != null) {\n+            throw new InvalidObjectException(errMsg);\n@@ -281,0 +279,4 @@\n+        byte[] temp = key;\n+        this.key = temp.clone();\n+        Arrays.fill(temp, (byte) 0);\n+    }\n@@ -282,3 +284,6 @@\n-        this.key = key.clone();\n-        if (key.length == 0) {\n-            throw new InvalidObjectException(\"Invalid key length\");\n+    private static String doSanityCheck(byte[] key, String algorithm) {\n+        String errMsg = null;\n+        if (key == null || algorithm == null) {\n+            errMsg = \"Missing argument\";\n+        } else if (key.length == 0) {\n+            errMsg = \"Empty key\";\n@@ -286,0 +291,1 @@\n+        return errMsg;\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/SecretKeySpec.java","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,5 +106,7 @@\n-        if (prompt == null || prompt.isEmpty() ||\n-            choices == null || choices.length == 0 ||\n-            defaultChoice < 0 || defaultChoice >= choices.length)\n-            throw new IllegalArgumentException();\n-\n+        choices = (choices == null || choices.length == 0 ? choices :\n+                choices.clone());\n+        String errMsg = doSanityCheck(prompt, choices, defaultChoice,\n+                multipleSelectionsAllowed);\n+        if (errMsg != null) {\n+            throw new IllegalArgumentException(errMsg);\n+        }\n@@ -115,5 +117,1 @@\n-        this.choices = choices.clone();\n-        for (int i = 0; i < choices.length; i++) {\n-            if (choices[i] == null || choices[i].isEmpty())\n-                throw new IllegalArgumentException();\n-        }\n+        this.choices = choices;\n@@ -187,1 +185,1 @@\n-        if (!multipleSelectionsAllowed)\n+        if (!multipleSelectionsAllowed) {\n@@ -189,1 +187,3 @@\n-        this.selections = selections == null ? null : selections.clone();\n+        }\n+        this.selections = ((selections == null || selections.length == 0) ?\n+                selections : selections.clone());\n@@ -215,0 +215,7 @@\n+        choices = (choices == null || choices.length == 0 ?\n+                choices :  choices.clone());\n+        String errMsg = doSanityCheck(prompt, choices, defaultChoice,\n+                multipleSelectionsAllowed);\n+        if (errMsg != null) {\n+            throw new InvalidObjectException(errMsg);\n+        }\n@@ -216,0 +223,10 @@\n+        selections = (selections == null || selections.length == 0 ?\n+                selections :  selections.clone());\n+        if (selections != null && selections.length > 1 &&\n+                !multipleSelectionsAllowed) {\n+            throw new InvalidObjectException(\"Multiple selections not allowed\");\n+        }\n+    }\n+\n+    private static String doSanityCheck(String prompt, String[] choices,\n+            int defaultChoice, boolean allowMultiple) {\n@@ -219,2 +236,1 @@\n-            throw new InvalidObjectException(\n-                    \"Missing\/invalid prompt\/choices\");\n+            return \"Missing\/invalid prompt\/choices\";\n@@ -223,1 +239,0 @@\n-        choices = choices.clone();\n@@ -225,9 +240,2 @@\n-            if ((choices[i] == null) || choices[i].isEmpty())\n-                throw new InvalidObjectException(\"Null\/empty choices\");\n-        }\n-\n-        if (selections != null) {\n-            selections = selections.clone();\n-            if (!multipleSelectionsAllowed && (selections.length != 1)) {\n-                throw new InvalidObjectException(\n-                        \"Multiple selections not allowed\");\n+            if ((choices[i] == null) || choices[i].isEmpty()) {\n+                return \"Null\/empty choices value\";\n@@ -236,0 +244,1 @@\n+        return null;\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/callback\/ChoiceCallback.java","additions":34,"deletions":25,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.InvalidObjectException;\n@@ -192,19 +193,4 @@\n-\n-        if (messageType < INFORMATION || messageType > ERROR ||\n-            optionType < YES_NO_OPTION || optionType > OK_CANCEL_OPTION)\n-            throw new IllegalArgumentException();\n-\n-        switch (optionType) {\n-        case YES_NO_OPTION:\n-            if (defaultOption != YES && defaultOption != NO)\n-                throw new IllegalArgumentException();\n-            break;\n-        case YES_NO_CANCEL_OPTION:\n-            if (defaultOption != YES && defaultOption != NO &&\n-                defaultOption != CANCEL)\n-                throw new IllegalArgumentException();\n-            break;\n-        case OK_CANCEL_OPTION:\n-            if (defaultOption != OK && defaultOption != CANCEL)\n-                throw new IllegalArgumentException();\n-            break;\n+        String errMsg = doSanityCheck(messageType, optionType, false, null,\n+                defaultOption, null, false);\n+        if (errMsg != null) {\n+            throw new IllegalArgumentException(errMsg);\n@@ -253,4 +239,8 @@\n-        if (messageType < INFORMATION || messageType > ERROR ||\n-            options == null || options.length == 0 ||\n-            defaultOption < 0 || defaultOption >= options.length)\n-            throw new IllegalArgumentException();\n+        if (options != null) {\n+            options = options.clone();\n+        }\n+        String errMsg = doSanityCheck(messageType, UNSPECIFIED_OPTION, true,\n+                options, defaultOption, null, false);\n+        if (errMsg != null) {\n+            throw new IllegalArgumentException(errMsg);\n+        }\n@@ -262,6 +252,1 @@\n-\n-        this.options = options.clone();\n-        for (int i = 0; i < options.length; i++) {\n-            if (options[i] == null || options[i].isEmpty())\n-                throw new IllegalArgumentException();\n-        }\n+        this.options = options;\n@@ -307,19 +292,4 @@\n-        if (prompt == null || prompt.isEmpty() ||\n-            messageType < INFORMATION || messageType > ERROR ||\n-            optionType < YES_NO_OPTION || optionType > OK_CANCEL_OPTION)\n-            throw new IllegalArgumentException();\n-\n-        switch (optionType) {\n-        case YES_NO_OPTION:\n-            if (defaultOption != YES && defaultOption != NO)\n-                throw new IllegalArgumentException();\n-            break;\n-        case YES_NO_CANCEL_OPTION:\n-            if (defaultOption != YES && defaultOption != NO &&\n-                defaultOption != CANCEL)\n-                throw new IllegalArgumentException();\n-            break;\n-        case OK_CANCEL_OPTION:\n-            if (defaultOption != OK && defaultOption != CANCEL)\n-                throw new IllegalArgumentException();\n-            break;\n+        String errMsg = doSanityCheck(messageType, optionType, false, null,\n+                defaultOption, prompt, true);\n+        if (errMsg != null) {\n+            throw new IllegalArgumentException(errMsg);\n@@ -327,1 +297,0 @@\n-\n@@ -372,5 +341,8 @@\n-        if (prompt == null || prompt.isEmpty() ||\n-            messageType < INFORMATION || messageType > ERROR ||\n-            options == null || options.length == 0 ||\n-            defaultOption < 0 || defaultOption >= options.length)\n-            throw new IllegalArgumentException();\n+        if (options != null) {\n+            options = options.clone();\n+        }\n+        String errMsg = doSanityCheck(messageType, UNSPECIFIED_OPTION, true,\n+                options, defaultOption, prompt, true);\n+        if (errMsg != null) {\n+            throw new IllegalArgumentException(errMsg);\n+        }\n@@ -382,6 +354,1 @@\n-\n-        this.options = options.clone();\n-        for (int i = 0; i < options.length; i++) {\n-            if (options[i] == null || options[i].isEmpty())\n-                throw new IllegalArgumentException();\n-        }\n+        this.options = options;\n@@ -494,0 +461,43 @@\n+    private static String doSanityCheck(int msgType, int optionType,\n+            boolean isUnspecifiedOption, String[] options, int defOption,\n+            String prompt, boolean checkPrompt) {\n+        \/\/ validate msgType\n+        if (msgType < INFORMATION || msgType > ERROR) {\n+            return \"Invalid msgType\";\n+        }\n+        \/\/ validate prompt if checkPrompt == true\n+        if (checkPrompt && (prompt == null || prompt.isEmpty())) {\n+            return \"Invalid prompt\";\n+        }\n+        \/\/ validate optionType\n+        if (isUnspecifiedOption) {\n+            if (optionType != UNSPECIFIED_OPTION) {\n+                return \"Invalid optionType\";\n+            }\n+            \/\/ check options\n+            if (options == null || options.length == 0 ||\n+                    defOption < 0 || defOption >= options.length) {\n+                return \"Invalid options and\/or default option\";\n+            }\n+            for (String ov : options) {\n+                if (ov == null || ov.isEmpty()) {\n+                    return \"Invalid option value\";\n+                }\n+            }\n+        } else {\n+            if (optionType < YES_NO_OPTION || optionType > OK_CANCEL_OPTION) {\n+                return \"Invalid optionType\";\n+            }\n+            \/\/ validate defOption based on optionType\n+            if ((optionType == YES_NO_OPTION && (defOption != YES &&\n+                    defOption != NO)) ||\n+                    (optionType == YES_NO_CANCEL_OPTION && (defOption != YES &&\n+                    defOption != NO && defOption != CANCEL)) ||\n+                    (optionType == OK_CANCEL_OPTION && (defOption != OK &&\n+                    defOption != CANCEL))) {\n+                return \"Invalid default option\";\n+            }\n+        }\n+        return null;\n+    }\n+\n@@ -505,0 +515,1 @@\n+\n@@ -508,0 +519,6 @@\n+        String errMsg = doSanityCheck(messageType, optionType,\n+                (optionType == UNSPECIFIED_OPTION), options, defaultOption,\n+                prompt, false);\n+        if (errMsg != null) {\n+            throw new InvalidObjectException(errMsg);\n+        }\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/callback\/ConfirmationCallback.java","additions":78,"deletions":61,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,1 +184,3 @@\n-            inputPassword = inputPassword.clone();\n+            char[] temp = inputPassword;\n+            inputPassword = temp.clone();\n+            Arrays.fill(temp, '0');\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/callback\/PasswordCallback.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.InvalidObjectException;\n@@ -278,0 +279,7 @@\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  s the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n@@ -282,1 +290,1 @@\n-        if (mdp.mech == null) {\n+        if (mdp == null || mdp.mech == null) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DRBG.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,0 +130,7 @@\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  is the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n@@ -136,1 +143,5 @@\n-            int[] comp = (int[])components;\n+            if (components == null) {\n+                throw new InvalidObjectException(\"OID components is null\");\n+            }\n+\n+            int[] comp = ((int[]) components).clone();\n@@ -145,0 +156,1 @@\n+            components = comp;\n@@ -146,0 +158,1 @@\n+            encoding = encoding.clone(); \/\/ defensive copying\n@@ -264,0 +277,1 @@\n+    \/\/ set 'encoding' field based on the specified 'components' and 'length'\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/ObjectIdentifier.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.ObjectInputStream;\n@@ -29,0 +30,1 @@\n+import java.io.InvalidObjectException;\n@@ -32,1 +34,1 @@\n-\n+import java.util.Arrays;\n@@ -75,3 +77,1 @@\n-public final\n-class AlgIdDSA extends AlgorithmId implements DSAParams\n-{\n+public final class AlgIdDSA extends AlgorithmId implements DSAParams {\n@@ -82,0 +82,11 @@\n+    private static class DSAComponents {\n+        private final BigInteger p;\n+        private final BigInteger q;\n+        private final BigInteger g;\n+        DSAComponents(BigInteger p, BigInteger q, BigInteger g) {\n+            this.p = p;\n+            this.q = q;\n+            this.g = g;\n+        }\n+    }\n+\n@@ -85,1 +96,1 @@\n-    private BigInteger  p , q, g;\n+    private BigInteger p, q, g;\n@@ -88,1 +99,1 @@\n-    public BigInteger   getP () { return p; }\n+    public BigInteger   getP() { return p; }\n@@ -91,1 +102,1 @@\n-    public BigInteger   getQ () { return q; }\n+    public BigInteger   getQ() { return q; }\n@@ -94,1 +105,1 @@\n-    public BigInteger   getG () { return g; }\n+    public BigInteger   getG() { return g; }\n@@ -101,1 +112,1 @@\n-    public AlgIdDSA () {}\n+    public AlgIdDSA() {}\n@@ -112,1 +123,1 @@\n-    public AlgIdDSA (BigInteger p, BigInteger q, BigInteger g) {\n+    public AlgIdDSA(BigInteger p, BigInteger q, BigInteger g) {\n@@ -123,2 +134,4 @@\n-                initializeParams ();\n-\n+                \/\/ For algorithm IDs which haven't been created from a DER\n+                \/\/ encoded value, need to create DER encoding and store it\n+                \/\/ into \"encodedParams\"\n+                encodedParams = encode(p, q, g);\n@@ -136,41 +149,2 @@\n-    public String getName ()\n-        { return \"DSA\"; }\n-\n-\n-    \/*\n-     * For algorithm IDs which haven't been created from a DER encoded\n-     * value, \"params\" must be created.\n-     *\/\n-    private void initializeParams () throws IOException {\n-        DerOutputStream out = new DerOutputStream();\n-        out.putInteger(p);\n-        out.putInteger(q);\n-        out.putInteger(g);\n-        DerOutputStream result = new DerOutputStream();\n-        result.write(DerValue.tag_Sequence, out);\n-        encodedParams = result.toByteArray();\n-    }\n-\n-    \/**\n-     * Parses algorithm parameters P, Q, and G.  They're found\n-     * in the \"params\" member, which never needs to be changed.\n-     *\/\n-    protected void decodeParams () throws IOException {\n-        if (encodedParams == null) {\n-            throw new IOException(\"DSA alg params are null\");\n-        }\n-\n-        DerValue params = new DerValue(encodedParams);\n-        if (params.tag != DerValue.tag_Sequence) {\n-            throw new IOException(\"DSA alg parsing error\");\n-        }\n-\n-        params.data.reset ();\n-\n-        this.p = params.data.getBigInteger();\n-        this.q = params.data.getBigInteger();\n-        this.g = params.data.getBigInteger();\n-\n-        if (params.data.available () != 0)\n-            throw new IOException (\"AlgIdDSA params, extra=\"+\n-                                   params.data.available ());\n+    public String getName() {\n+        return \"DSA\";\n@@ -179,1 +153,0 @@\n-\n@@ -200,0 +173,40 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream. Override to check\n+     * on the 'p', 'q', 'g', and 'encodedParams'.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream) throws IOException {\n+        try {\n+            stream.defaultReadObject();\n+            \/\/ if any of the 'p', 'q', 'g', 'encodedParams' is non-null,\n+            \/\/ then they must be all non-null w\/ matching encoding\n+            if ((p != null || q != null || g != null || encodedParams != null)\n+                    && !Arrays.equals(encodedParams, encode(p, q, g))) {\n+                throw new InvalidObjectException(\"Invalid DSA alg params\");\n+            }\n+        } catch (ClassNotFoundException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    \/*\n+     * Create the DER encoding w\/ the specified 'p', 'q', 'g'\n+     *\/\n+    private static byte[] encode(BigInteger p, BigInteger q,\n+            BigInteger g) throws IOException {\n+        if (p == null || q == null || g == null) {\n+            throw new InvalidObjectException(\"invalid null value\");\n+        }\n+        DerOutputStream out = new DerOutputStream();\n+        out.putInteger(p);\n+        out.putInteger(q);\n+        out.putInteger(g);\n+        DerOutputStream result = new DerOutputStream();\n+        result.write(DerValue.tag_Sequence, out);\n+        return result.toByteArray();\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AlgIdDSA.java","additions":68,"deletions":55,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.io.OutputStream;\n+import java.io.InvalidObjectException;\n@@ -38,0 +38,2 @@\n+import java.io.ObjectInputStream;\n+import java.io.OutputStream;\n@@ -1419,0 +1421,14 @@\n+\n+        \/**\n+         * Restores the state of this object from the stream.\n+         *\n+         * @param  stream the {@code ObjectInputStream} from which data is read\n+         * @throws IOException if an I\/O error occurs\n+         * @throws ClassNotFoundException if a serialized class cannot be loaded\n+         *\/\n+        @java.io.Serial\n+        private void readObject(ObjectInputStream stream)\n+                throws IOException, ClassNotFoundException {\n+            throw new InvalidObjectException\n+                    (\"KerberosSessionKey not directly deserializable\");\n+        }\n@@ -1488,1 +1504,0 @@\n-\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/krb5\/Krb5Context.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.io.InvalidObjectException;\n@@ -36,0 +37,1 @@\n+import java.io.ObjectInputStream;\n@@ -408,0 +410,13 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\"Krb5InitCredential not deserializable\");\n+    }\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/krb5\/Krb5InitCredential.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -82,3 +82,1 @@\n-\/\/ The instance fields not statically typed as Serializable are ASN.1\n-\/\/ encoded and written by the writeObject method.\n-@SuppressWarnings(\"serial\")\n+\n@@ -88,13 +86,16 @@\n-    private int pvno;\n-    private int msgType;\n-    private KerberosTime cTime; \/\/optional\n-    private Integer cuSec; \/\/optional\n-    private KerberosTime sTime;\n-    private Integer suSec;\n-    private int errorCode;\n-    private Realm crealm; \/\/optional\n-    private PrincipalName cname; \/\/optional\n-    private PrincipalName sname;\n-    private String eText; \/\/optional\n-    private byte[] eData; \/\/optional\n-    private Checksum eCksum; \/\/optional\n+    private transient int pvno;\n+    private transient int msgType;\n+    private transient KerberosTime cTime; \/\/optional\n+    private transient Integer cuSec; \/\/optional\n+    private transient KerberosTime sTime;\n+    private transient Integer suSec;\n+    private transient int errorCode;\n+    private transient Realm crealm; \/\/optional\n+    private transient PrincipalName cname; \/\/optional\n+    private transient PrincipalName sname;\n+    private transient String eText; \/\/optional\n+    private transient byte[] eData; \/\/optional\n+    private transient Checksum eCksum; \/\/optional\n+\n+    private transient PAData[] pa;    \/\/ PA-DATA in eData\n+\n@@ -102,1 +103,0 @@\n-    private PAData[] pa;    \/\/ PA-DATA in eData\n@@ -106,0 +106,8 @@\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  is the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/internal\/KRBError.java","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -248,0 +248,13 @@\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\"P11Key not directly deserializable\");\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -192,0 +192,8 @@\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  in the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n@@ -195,0 +203,6 @@\n+        if (token == null) {\n+            throw new InvalidObjectException(\"token is null\");\n+        }\n+        if (mixBuffer != null) {\n+            mixBuffer = mixBuffer.clone();\n+        }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11SecureRandom.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1717,0 +1717,13 @@\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\"SunPKCS11 not directly deserializable\");\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"}]}