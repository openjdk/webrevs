{"files":[{"patch":"@@ -790,0 +790,2 @@\n+  else ifeq ($$(call isTargetOs, linux), true)\n+      $1_JTREG_BASIC_OPTIONS += -e:_JVM_DWARF_PATH=$$(SYMBOLS_IMAGE_DIR)\n","filename":"make\/RunTests.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-    CFLAGS_DEBUG_SYMBOLS=\"-g\"\n+    CFLAGS_DEBUG_SYMBOLS=\"-g -gdwarf-4\"\n","filename":"make\/autoconf\/flags-cflags.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -951,1 +951,1 @@\n-                testedProfileTest\n+                testedProfileTest, testedProfile + \".jdk_symbols\",\n@@ -959,1 +959,2 @@\n-                \"TEST_IMAGE_DIR\": input.get(testedProfileTest, \"home_path\")\n+                \"TEST_IMAGE_DIR\": input.get(testedProfileTest, \"home_path\"),\n+                \"SYMBOLS_IMAGE_DIR\": input.get(testedProfile + \".jdk_symbols\", \"home_path\")\n@@ -999,11 +1000,0 @@\n-    \/\/ On windows we want the debug symbols available at test time\n-    if (input.build_os == \"windows\") {\n-        windowsRunTestPrebuiltExtra = {\n-            dependencies: [ testedProfile + \".jdk_symbols\" ],\n-            environment: {\n-                \"SYMBOLS_IMAGE_DIR\": input.get(testedProfile + \".jdk_symbols\", \"home_path\"),\n-            }\n-        };\n-        profiles[\"run-test-prebuilt\"] = concatObjects(profiles[\"run-test-prebuilt\"],\n-            windowsRunTestPrebuiltExtra);\n-    }\n","filename":"make\/conf\/jib-profiles.js","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-bool Decoder::get_source_info(address pc, char* buf, size_t buflen, int* line) {\n+bool Decoder::get_source_info(address pc, char* buf, size_t buflen, int* line, bool is_pc_after_call) {\n","filename":"src\/hotspot\/os\/windows\/decoder_windows.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -517,0 +517,4 @@\n+  develop(intx, TraceDwarfLevel, 0,                                         \\\n+          \"Debug levels for the dwarf parser\")                              \\\n+          range(0, 4)                                                       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,2 +116,7 @@\n-bool Decoder::get_source_info(address pc, char* buf, size_t buflen, int* line) {\n-  return false;\n+bool Decoder::get_source_info(address pc, char* filename, size_t filename_len, int* line, bool is_pc_after_call) {\n+  if (VMError::is_error_reported_in_current_thread()) {\n+    return get_error_handler_instance()->get_source_info(pc, filename, filename_len, line, is_pc_after_call);\n+  } else {\n+    MutexLocker locker(shared_decoder_lock(), Mutex::_no_safepoint_check_flag);\n+    return get_shared_instance()->get_source_info(pc, filename, filename_len, line, is_pc_after_call);\n+  }\n","filename":"src\/hotspot\/share\/utilities\/decoder.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -66,0 +66,5 @@\n+  \/\/ Get filename and line number information.\n+  virtual bool get_source_info(address pc, char* filename, size_t filename_len, int* line, bool is_pc_after_call) {\n+    return false;\n+  }\n+\n@@ -112,1 +117,1 @@\n-  \/\/ If buf != NULL, points to a buffer of size buflen which will receive the\n+  \/\/ If filename != NULL, points to a buffer of size filename_len which will receive the\n@@ -114,1 +119,3 @@\n-  static bool get_source_info(address pc, char* buf, size_t buflen, int* line);\n+  \/\/ If is_pc_after_call is true, then pc is treated as pointing to the next instruction\n+  \/\/ after a call. The source information for the call instruction is fetched in that case.\n+  static bool get_source_info(address pc, char* filename, size_t filename_len, int* line, bool is_pc_after_call = false);\n","filename":"src\/hotspot\/share\/utilities\/decoder.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,2 @@\n-#include \"memory\/allocation.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/os.hpp\"\n@@ -56,0 +57,39 @@\n+bool ElfDecoder::get_source_info(address pc, char* filename, size_t filename_len, int* line, bool is_pc_after_call) {\n+  assert(filename != nullptr && filename_len > 0 && line != nullptr, \"Argument error\");\n+  filename[0] = '\\0';\n+  *line = -1;\n+\n+  char filepath[JVM_MAXPATHLEN];\n+  filepath[JVM_MAXPATHLEN - 1] = '\\0';\n+  int offset_in_library = -1;\n+  if (!os::dll_address_to_library_name(pc, filepath, sizeof(filepath), &offset_in_library)) {\n+    \/\/ Method not found. offset_in_library should not overflow.\n+    DWARF_LOG_ERROR(\"Did not find library for address \" INTPTR_FORMAT, p2i(pc))\n+    return false;\n+  }\n+\n+  if (filepath[JVM_MAXPATHLEN - 1] != '\\0') {\n+    DWARF_LOG_ERROR(\"File path is too large to fit into buffer of size %d\", JVM_MAXPATHLEN);\n+    return false;\n+  }\n+\n+  const uint32_t unsigned_offset_in_library = (uint32_t)offset_in_library;\n+\n+  ElfFile* file = get_elf_file(filepath);\n+  if (file == NULL) {\n+    return false;\n+  }\n+  DWARF_LOG_INFO(\"##### Find filename and line number for offset \" PTR32_FORMAT \" in library %s #####\",\n+                 unsigned_offset_in_library, filepath);\n+\n+  if (!file->get_source_info(unsigned_offset_in_library, filename, filename_len, line, is_pc_after_call)) {\n+    return false;\n+  }\n+\n+  DWARF_LOG_SUMMARY(\"pc: \" INTPTR_FORMAT \", offset: \" PTR32_FORMAT \", filename: %s, line: %u\",\n+                       p2i(pc), offset_in_library, filename, *line);\n+  DWARF_LOG_INFO(\"\") \/\/ To structure the debug output better.\n+  return true;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/utilities\/decoder_elf.cpp","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+  bool get_source_info(address pc, char* buf, size_t buflen, int* line, bool is_pc_after_call);\n","filename":"src\/hotspot\/share\/utilities\/decoder_elf.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"jvm_io.h\"\n@@ -44,0 +45,2 @@\n+const char* ElfFile::USR_LIB_DEBUG_DIRECTORY = \"\/usr\/lib\/debug\";\n+\n@@ -61,1 +64,1 @@\n-    log_debug(decoder)(\"Elf section cache is disabled\");\n+    log_develop_debug(decoder)(\"Elf section cache is disabled\");\n@@ -88,1 +91,1 @@\n-int FileReader::read_buffer(void* buf, size_t size) {\n+size_t FileReader::read_buffer(void* buf, size_t size) {\n@@ -98,2 +101,1 @@\n-MarkedFileReader::MarkedFileReader(FILE* fd) : FileReader(fd) {\n-  _marked_pos = ftell(fd);\n+MarkedFileReader::MarkedFileReader(FILE* fd) : FileReader(fd), _marked_pos(ftell(fd)) {\n@@ -109,1 +111,1 @@\n-  _next(NULL), _filepath(NULL), _file(NULL),\n+  _next(NULL), _filepath(os::strdup(filepath)), _file(NULL),\n@@ -111,1 +113,1 @@\n-  _status(NullDecoder::no_error) {\n+  _status(NullDecoder::no_error), _dwarf_file(nullptr) {\n@@ -113,4 +115,1 @@\n-\n-  int len = strlen(filepath) + 1;\n-  _filepath = (char*)os::malloc(len * sizeof(char), mtInternal);\n-  if (_filepath == NULL) {\n+  if (_filepath == nullptr) {\n@@ -118,10 +117,2 @@\n-    return;\n-  }\n-  strcpy(_filepath, filepath);\n-\n-  _status = parse_elf(filepath);\n-\n-  \/\/ we no longer need section header string table\n-  if (_shdr_string_table != NULL) {\n-    delete _shdr_string_table;\n-    _shdr_string_table = NULL;\n+  } else {\n+    _status = parse_elf(filepath);\n@@ -132,4 +123,0 @@\n-  if (_shdr_string_table != NULL) {\n-    delete _shdr_string_table;\n-  }\n-\n@@ -142,2 +129,8 @@\n-  if (_filepath != NULL) {\n-    os::free((void*)_filepath);\n+  if (_filepath != nullptr) {\n+    os::free((void*) _filepath);\n+    _filepath = nullptr;\n+  }\n+\n+  if (_shdr_string_table != nullptr) {\n+    delete _shdr_string_table;\n+    _shdr_string_table = nullptr;\n@@ -146,1 +139,1 @@\n-  if (_next != NULL) {\n+  if (_next != nullptr) {\n@@ -148,0 +141,6 @@\n+    _next = nullptr;\n+  }\n+\n+  if (_dwarf_file != nullptr) {\n+    delete _dwarf_file;\n+    _dwarf_file = nullptr;\n@@ -152,1 +151,1 @@\n-  if (_string_tables != NULL) {\n+  if (_string_tables != nullptr) {\n@@ -154,1 +153,1 @@\n-    _string_tables = NULL;\n+    _string_tables = nullptr;\n@@ -156,2 +155,1 @@\n-\n-  if (_symbol_tables != NULL) {\n+  if (_symbol_tables != nullptr) {\n@@ -159,1 +157,1 @@\n-    _symbol_tables = NULL;\n+    _symbol_tables = nullptr;\n@@ -161,2 +159,1 @@\n-\n-  if (_funcDesc_table != NULL) {\n+  if (_funcDesc_table != nullptr) {\n@@ -164,1 +161,1 @@\n-    _funcDesc_table = NULL;\n+    _funcDesc_table = nullptr;\n@@ -261,0 +258,1 @@\n+#if defined(PPC64) && !defined(ABI_ELFv2)\n@@ -289,0 +287,1 @@\n+#endif\n@@ -351,1 +350,1469 @@\n-#endif \/\/ !_WINDOWS && !__APPLE__\n+\/\/ Use unified logging to report errors rather than assert() throughout this method as this code is already part of the error reporting\n+\/\/ and the debug symbols might be in an unsupported DWARF version or wrong format.\n+bool ElfFile::get_source_info(const uint32_t offset_in_library, char* filename, const size_t filename_len, int* line, bool is_pc_after_call) {\n+  ResourceMark rm;\n+  if (!load_dwarf_file()) {\n+    \/\/ Some ELF libraries do not provide separate .debuginfo files. Check if the current ELF file has the required\n+    \/\/ DWARF sections. If so, treat the current ELF file as DWARF file.\n+    if (!is_valid_dwarf_file()) {\n+      DWARF_LOG_ERROR(\"Failed to load DWARF file for library %s or find DWARF sections directly inside it.\", _filepath);\n+      return false;\n+    }\n+    DWARF_LOG_INFO(\"No separate .debuginfo file for library %s. It already contains the required DWARF sections.\",\n+                   _filepath);\n+    if (!create_new_dwarf_file(_filepath)) {\n+      return false;\n+    }\n+  }\n+\n+  \/\/ Store result in filename and line pointer.\n+  if (!_dwarf_file->get_filename_and_line_number(offset_in_library, filename, filename_len, line, is_pc_after_call)) {\n+    DWARF_LOG_ERROR(\"Failed to retrieve file and line number information for %s at offset: \" PTR32_FORMAT, _filepath,\n+                    offset_in_library);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+bool ElfFile::is_valid_dwarf_file() const {\n+  Elf_Shdr shdr;\n+  return read_section_header(\".debug_abbrev\", shdr) && read_section_header(\".debug_aranges\", shdr)\n+         && read_section_header(\".debug_info\", shdr) && read_section_header(\".debug_line\", shdr);\n+}\n+\n+\/\/ (1) Load the debuginfo file from the path specified in this ELF file in the .gnu_debuglink section.\n+\/\/ Adapted from Serviceability Agent.\n+bool ElfFile::load_dwarf_file() {\n+  if (_dwarf_file != nullptr) {\n+    return true; \/\/ Already opened.\n+  }\n+\n+  DebugInfo debug_info;\n+  if (!read_debug_info(&debug_info)) {\n+    DWARF_LOG_DEBUG(\"Could not read debug info from .gnu_debuglink section\");\n+    return false;\n+  }\n+\n+  DwarfFilePath dwarf_file_path(debug_info);\n+  return load_dwarf_file_from_same_directory(dwarf_file_path)\n+         || load_dwarf_file_from_env_var_path(dwarf_file_path)\n+         || load_dwarf_file_from_debug_sub_directory(dwarf_file_path)\n+         || load_dwarf_file_from_usr_lib_debug(dwarf_file_path);\n+}\n+\n+\/\/ Read .gnu_debuglink section which contains:\n+\/\/ Filename (null terminated) + 0-3 padding bytes (to 4 byte align) + CRC (4 bytes)\n+bool ElfFile::read_debug_info(DebugInfo* debug_info) const {\n+  Elf_Shdr shdr;\n+  if (!read_section_header(\".gnu_debuglink\", shdr)) {\n+    DWARF_LOG_DEBUG(\"Failed to read the .gnu_debuglink header.\");\n+    return false;\n+  }\n+\n+  if (shdr.sh_size % 4 != 0) {\n+    DWARF_LOG_ERROR(\".gnu_debuglink section is not 4 byte aligned (i.e. file is corrupted)\");\n+    return false;\n+  }\n+\n+  MarkedFileReader mfd(fd());\n+  if (!mfd.has_mark() || !mfd.set_position(_elfHdr.e_shoff)) {\n+    return false;\n+  }\n+\n+  uint64_t filename_max_len = shdr.sh_size - DebugInfo::CRC_LEN;\n+  mfd.set_position(shdr.sh_offset);\n+  if (!mfd.read(&debug_info->_dwarf_filename, filename_max_len)) {\n+    return false;\n+  }\n+\n+  if (debug_info->_dwarf_filename[filename_max_len - 1] != '\\0') {\n+    \/\/ Filename not null-terminated (i.e. overflowed).\n+    DWARF_LOG_ERROR(\"Dwarf filename is not null-terminated\");\n+    return false;\n+  }\n+\n+  return mfd.read(&debug_info->_crc, DebugInfo::CRC_LEN);\n+}\n+\n+bool ElfFile::DwarfFilePath::set(const char* src) {\n+  int bytes_written = jio_snprintf(_path, MAX_DWARF_PATH_LENGTH, \"%s\", src);\n+  if (bytes_written < 0 || bytes_written >= MAX_DWARF_PATH_LENGTH) {\n+    DWARF_LOG_ERROR(\"Dwarf file path buffer is too small\");\n+    return false;\n+  }\n+  update_null_terminator_index();\n+  return check_valid_path(); \/\/ Sanity check\n+}\n+\n+bool ElfFile::DwarfFilePath::set_after_last_slash(const char* src) {\n+  char* last_slash = strrchr(_path, '\/');\n+  if (last_slash == nullptr) {\n+    \/\/ Should always find a slash.\n+    return false;\n+  }\n+\n+  uint16_t index_after_slash = (uint16_t)(last_slash + 1 - _path);\n+  return copy_to_path_index(index_after_slash, src);\n+}\n+\n+bool ElfFile::DwarfFilePath::append(const char* src) {\n+  return copy_to_path_index(_null_terminator_index, src);\n+}\n+\n+bool ElfFile::DwarfFilePath::copy_to_path_index(uint16_t index_in_path, const char* src) {\n+  if (index_in_path >= MAX_DWARF_PATH_LENGTH - 1) {\n+    \/\/ Should not override '\\0' at _path[MAX_DWARF_PATH_LENGTH - 1]\n+    DWARF_LOG_ERROR(\"Dwarf file path buffer is too small\");\n+    return false;\n+  }\n+\n+  uint16_t max_len = MAX_DWARF_PATH_LENGTH - index_in_path;\n+  int bytes_written = jio_snprintf(_path + index_in_path, max_len, \"%s\", src);\n+  if (bytes_written < 0 || bytes_written >= max_len) {\n+    DWARF_LOG_ERROR(\"Dwarf file path buffer is too small\");\n+    return false;\n+  }\n+  update_null_terminator_index();\n+  return check_valid_path(); \/\/ Sanity check\n+}\n+\n+\/\/ Try to load the dwarf file from the same directory as the library file.\n+bool ElfFile::load_dwarf_file_from_same_directory(DwarfFilePath& dwarf_file_path) {\n+  if (!dwarf_file_path.set(_filepath)\n+      || !dwarf_file_path.set_filename_after_last_slash()) {\n+    return false;\n+  }\n+  return open_valid_debuginfo_file(dwarf_file_path);\n+}\n+\n+\/\/ Try to load the dwarf file from a user specified path in environmental variable _JVM_DWARF_PATH.\n+bool ElfFile::load_dwarf_file_from_env_var_path(DwarfFilePath& dwarf_file_path) {\n+  const char* dwarf_path_from_env = ::getenv(\"_JVM_DWARF_PATH\");\n+  if (dwarf_path_from_env != nullptr) {\n+    DWARF_LOG_DEBUG(\"_JVM_DWARF_PATH: %s\", dwarf_path_from_env);\n+    return (load_dwarf_file_from_env_path_folder(dwarf_file_path, dwarf_path_from_env, \"\/lib\/server\/\")\n+            || load_dwarf_file_from_env_path_folder(dwarf_file_path, dwarf_path_from_env, \"\/lib\/\")\n+            || load_dwarf_file_from_env_path_folder(dwarf_file_path, dwarf_path_from_env, \"\/bin\/\")\n+            || load_dwarf_file_from_env_path_folder(dwarf_file_path, dwarf_path_from_env, \"\/\"));\n+  }\n+  return false;\n+}\n+\n+bool ElfFile::load_dwarf_file_from_env_path_folder(DwarfFilePath& dwarf_file_path, const char* dwarf_path_from_env,\n+                                                   const char* folder) {\n+  if (!dwarf_file_path.set(dwarf_path_from_env)\n+      || !dwarf_file_path.append(folder)\n+      || !dwarf_file_path.append(dwarf_file_path.filename())) {\n+    DWARF_LOG_ERROR(\"Dwarf file path buffer is too small\");\n+    return false;\n+  }\n+  return open_valid_debuginfo_file(dwarf_file_path);\n+}\n+\n+\/\/ Try to load the dwarf file from a subdirectory named .debug within the directory of the library file.\n+bool ElfFile::load_dwarf_file_from_debug_sub_directory(DwarfFilePath& dwarf_file_path) {\n+  if (!dwarf_file_path.set(_filepath)\n+      || !dwarf_file_path.set_after_last_slash(\".debug\/\")\n+      || !dwarf_file_path.append(dwarf_file_path.filename())) {\n+    DWARF_LOG_ERROR(\"Dwarf file path buffer is too small\");\n+    return false;\n+  }\n+  return open_valid_debuginfo_file(dwarf_file_path);\n+}\n+\n+\/\/ Try to load the dwarf file from \/usr\/lib\/debug + the full pathname.\n+bool ElfFile::load_dwarf_file_from_usr_lib_debug(DwarfFilePath& dwarf_file_path) {\n+  if (!dwarf_file_path.set(USR_LIB_DEBUG_DIRECTORY)\n+      || !dwarf_file_path.append(_filepath)\n+      || !dwarf_file_path.set_filename_after_last_slash()) {\n+    DWARF_LOG_ERROR(\"Dwarf file path buffer is too small\");\n+    return false;\n+  }\n+  return open_valid_debuginfo_file(dwarf_file_path);\n+}\n+\n+bool ElfFile::read_section_header(const char* name, Elf_Shdr& hdr) const {\n+  if (_shdr_string_table == nullptr) {\n+    assert(false, \"section header string table should be loaded\");\n+    return false;\n+  }\n+  const uint8_t buf_len = 24;\n+  char buf[buf_len];\n+  size_t len = strlen(name) + 1;\n+  if (len > buf_len) {\n+    DWARF_LOG_ERROR(\"Section header name buffer is too small: Required: %zu, Found: %d\", len, buf_len);\n+    return false;\n+  }\n+\n+  MarkedFileReader mfd(fd());\n+  if (!mfd.has_mark() || !mfd.set_position(_elfHdr.e_shoff)) {\n+    return false;\n+  }\n+\n+  for (int index = 0; index < _elfHdr.e_shnum; index++) {\n+    if (!mfd.read((void*)&hdr, sizeof(hdr))) {\n+      return false;\n+    }\n+    if (_shdr_string_table->string_at(hdr.sh_name, buf, buf_len)) {\n+      if (strncmp(buf, name, buf_len) == 0) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+\/\/ Taken from https:\/\/sourceware.org\/gdb\/current\/onlinedocs\/gdb\/Separate-Debug-Files.html#Separate-Debug-Files\n+static const uint32_t crc32_table[256] = {\n+   0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,\n+   0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,\n+   0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,\n+   0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,\n+   0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,\n+   0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n+   0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,\n+   0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n+   0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,\n+   0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,\n+   0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,\n+   0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n+   0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,\n+   0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,\n+   0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,\n+   0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n+   0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,\n+   0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n+   0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,\n+   0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,\n+   0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,\n+   0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,\n+   0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,\n+   0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n+   0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,\n+   0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,\n+   0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,\n+   0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,\n+   0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,\n+   0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n+   0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,\n+   0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n+   0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,\n+   0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,\n+   0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,\n+   0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n+   0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,\n+   0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,\n+   0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,\n+   0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n+   0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,\n+   0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n+   0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,\n+   0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,\n+   0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,\n+   0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,\n+   0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,\n+   0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n+   0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,\n+   0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,\n+   0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,\n+   0x2d02ef8d\n+ };\n+\n+bool ElfFile::open_valid_debuginfo_file(const DwarfFilePath& dwarf_file_path) {\n+  if (_dwarf_file != nullptr) {\n+    \/\/ Already opened.\n+    return true;\n+  }\n+\n+  const char* filepath = dwarf_file_path.path();\n+  FILE* file = fopen(filepath, \"r\");\n+  if (file == nullptr) {\n+    DWARF_LOG_DEBUG(\"Could not open dwarf file %s (%s)\", filepath, os::strerror(errno));\n+    return false;\n+  }\n+\n+  uint32_t file_crc = get_file_crc(file);\n+  fclose(file); \/\/ Close it here to reopen it again when the DwarfFile object is created below.\n+\n+  if (dwarf_file_path.crc() != file_crc) {\n+    \/\/ Must be equal, otherwise the file is corrupted.\n+    DWARF_LOG_ERROR(\"CRC did not match. Expected: \" PTR32_FORMAT \", found: \" PTR32_FORMAT, dwarf_file_path.crc(),\n+                    file_crc);\n+    return false;\n+  }\n+  return create_new_dwarf_file(filepath);\n+}\n+\n+uint32_t ElfFile::get_file_crc(FILE* const file) {\n+  uint32_t file_crc = 0;\n+  uint8_t buffer[8 * 1024];\n+  MarkedFileReader reader(file);\n+  while (true) {\n+    size_t len = reader.read_buffer(buffer, sizeof(buffer));\n+    if (len == 0) {\n+      break;\n+    }\n+    file_crc = gnu_debuglink_crc32(file_crc, buffer, len);\n+  }\n+  return file_crc;\n+}\n+\n+\/\/ The CRC used in gnu_debuglink, retrieved from\n+\/\/ http:\/\/sourceware.org\/gdb\/current\/onlinedocs\/gdb\/Separate-Debug-Files.html#Separate-Debug-Files.\n+uint32_t ElfFile::gnu_debuglink_crc32(uint32_t crc, uint8_t* buf, const size_t len) {\n+  crc = ~crc;\n+  for (uint8_t* end = buf + len; buf < end; buf++) {\n+    crc = crc32_table[(crc ^ *buf) & 0xffu] ^ (crc >> 8u);\n+  }\n+  return ~crc;\n+}\n+\n+bool ElfFile::create_new_dwarf_file(const char* filepath) {\n+  DWARF_LOG_SUMMARY(\"Open DWARF file: %s\", filepath);\n+  _dwarf_file = new (std::nothrow) DwarfFile(filepath);\n+  if (_dwarf_file == nullptr) {\n+    DWARF_LOG_ERROR(\"Failed to create new DwarfFile object for %s.\", _filepath);\n+    return false;\n+  }\n+  if (!_dwarf_file->is_valid_dwarf_file()) {\n+    DWARF_LOG_ERROR(\"Did not find required DWARF sections in %s\", filepath);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+\/\/ Starting point of reading line number and filename information from the DWARF file.\n+bool DwarfFile::get_filename_and_line_number(const uint32_t offset_in_library, char* filename, const size_t filename_len,\n+                                             int* line, const bool is_pc_after_call) {\n+  DebugAranges debug_aranges(this);\n+  uint32_t compilation_unit_offset = 0; \/\/ 4-bytes for 32-bit DWARF\n+  if (!debug_aranges.find_compilation_unit_offset(offset_in_library, &compilation_unit_offset)) {\n+    DWARF_LOG_ERROR(\"Failed to find .debug_info offset for the compilation unit.\");\n+    return false;\n+  }\n+  DWARF_LOG_INFO(\".debug_info offset:    \" PTR32_FORMAT, compilation_unit_offset);\n+\n+  CompilationUnit compilation_unit(this, compilation_unit_offset);\n+  uint32_t debug_line_offset = 0;  \/\/ 4-bytes for 32-bit DWARF\n+  if (!compilation_unit.find_debug_line_offset(&debug_line_offset)) {\n+    DWARF_LOG_ERROR(\"Failed to find .debug_line offset for the line number program.\");\n+    return false;\n+  }\n+  DWARF_LOG_INFO(\".debug_line offset:    \" PTR32_FORMAT, debug_line_offset);\n+\n+  LineNumberProgram line_number_program(this, offset_in_library, debug_line_offset, is_pc_after_call);\n+  if (!line_number_program.find_filename_and_line_number(filename, filename_len, line)) {\n+    DWARF_LOG_ERROR(\"Failed to process the line number program correctly.\");\n+    return false;\n+  }\n+  return true;\n+}\n+\n+\/\/ (2) The .debug_aranges section contains a number of entries\/sets. Each set contains one or multiple address range descriptors of the\n+\/\/ form [beginning_address, beginning_address+length). Start reading these sets and their descriptors until we find one that contains\n+\/\/ 'offset_in_library'. Read the debug_info_offset field from the header of this set which defines the offset for the compilation unit.\n+\/\/ This process is described in section 6.1.2 of the DWARF 4 spec.\n+bool DwarfFile::DebugAranges::find_compilation_unit_offset(const uint32_t offset_in_library, uint32_t* compilation_unit_offset) {\n+  if (!read_section_header()) {\n+    DWARF_LOG_ERROR(\"Failed to read a .debug_aranges header.\");\n+    return false;\n+  }\n+\n+  DebugArangesSetHeader set_header;\n+  bool found_matching_set = false;\n+  while (_reader.has_bytes_left()) {\n+    \/\/ Read multiple sets and therefore multiple headers.\n+    if (!read_set_header(set_header)) {\n+      DWARF_LOG_ERROR(\"Failed to read a .debug_aranges header.\");\n+      return false;\n+    }\n+\n+    if (!read_address_descriptors(set_header, offset_in_library, found_matching_set)) {\n+      return false;\n+    }\n+\n+    if (found_matching_set) {\n+      \/\/ Found the correct set, read the debug_info_offset from the header of this set.\n+      DWARF_LOG_INFO(\".debug_aranges offset: \" PTR32_FORMAT, (uint32_t)_reader.get_position());\n+      *compilation_unit_offset = set_header._debug_info_offset;\n+      return true;\n+    }\n+  }\n+\n+  assert(false, \"No address descriptor found containing offset_in_library.\");\n+  return false;\n+}\n+\n+bool DwarfFile::DebugAranges::read_section_header() {\n+  Elf_Shdr shdr;\n+  if (!_dwarf_file->read_section_header(\".debug_aranges\", shdr)) {\n+    return false;\n+  }\n+\n+  _section_start_address = shdr.sh_offset;\n+  _reader.set_max_pos(shdr.sh_offset + shdr.sh_size);\n+  return _reader.set_position(shdr.sh_offset);\n+}\n+\n+\/\/ Parse set header as specified in section 6.1.2 of the DWARF 4 spec.\n+bool DwarfFile::DebugAranges::read_set_header(DebugArangesSetHeader& header) {\n+  if (!_reader.read_dword(&header._unit_length) || header._unit_length == 0xFFFFFFFF) {\n+    \/\/ For 64-bit DWARF, the first 32-bit value is 0xFFFFFFFF. The current implementation only supports 32-bit DWARF\n+    \/\/ format since GCC only emits 32-bit DWARF.\n+    DWARF_LOG_ERROR(\"64-bit DWARF is not supported for .debug_aranges\")\n+    return false;\n+  }\n+\n+  if (!_reader.read_word(&header._version) || header._version != 2) {\n+    \/\/ DWARF 4 uses version 2 as specified in Appendix F of the DWARF 4 spec.\n+    DWARF_LOG_ERROR(\".debug_aranges in unsupported DWARF version %\" PRIu16, header._version)\n+    return false;\n+  }\n+\n+  if (!_reader.read_dword(&header._debug_info_offset)) {\n+    return false;\n+  }\n+\n+  if (!_reader.read_byte(&header._address_size) || header._address_size != DwarfFile::ADDRESS_SIZE) {\n+    \/\/ Addresses must be either 4 bytes for 32-bit architectures or 8 bytes for 64-bit architectures.\n+    DWARF_LOG_ERROR(\".debug_aranges specifies wrong address size %\" PRIu8, header._address_size);\n+    return false;\n+  }\n+\n+  if (!_reader.read_byte(&header._segment_size) || header._segment_size != 0) {\n+    \/\/ Segment size should be 0.\n+    DWARF_LOG_ERROR(\".debug_aranges segment size is non-zero: %\" PRIu8, header._segment_size);\n+    return false;\n+  }\n+\n+  \/\/ We must align to twice the address size.\n+  uint8_t alignment = DwarfFile::ADDRESS_SIZE * 2;\n+  uint8_t padding = alignment - (_reader.get_position() - _section_start_address) % alignment;\n+  return _reader.move_position(padding);\n+}\n+\n+bool DwarfFile::DebugAranges::read_address_descriptors(const DwarfFile::DebugAranges::DebugArangesSetHeader& header,\n+                                                       const uint32_t offset_in_library, bool& found_matching_set) {\n+  AddressDescriptor descriptor;\n+  do {\n+    if (!read_address_descriptor(descriptor)) {\n+      return false;\n+    }\n+\n+    if (does_match_offset(offset_in_library, descriptor)) {\n+      found_matching_set = true;\n+      return true;\n+    }\n+  } while (!is_terminating_entry(descriptor) && _reader.has_bytes_left());\n+\n+  \/\/ Set does not match offset_in_library. Continue with next.\n+  return true;\n+}\n+\n+bool DwarfFile::DebugAranges::read_address_descriptor(AddressDescriptor& descriptor) {\n+  return _reader.read_address_sized(&descriptor.beginning_address)\n+         && _reader.read_address_sized(&descriptor.range_length);\n+}\n+\n+bool DwarfFile::DebugAranges::does_match_offset(const uint32_t offset_in_library, const AddressDescriptor& descriptor) {\n+  return descriptor.beginning_address <= offset_in_library\n+         && offset_in_library < descriptor.beginning_address + descriptor.range_length;\n+}\n+\n+bool DwarfFile::DebugAranges::is_terminating_entry(const AddressDescriptor& descriptor) {\n+  return descriptor.beginning_address == 0 && descriptor.range_length == 0;\n+}\n+\n+\/\/ Find the .debug_line offset for the line number program by reading from the .debug_abbrev and .debug_info section.\n+bool DwarfFile::CompilationUnit::find_debug_line_offset(uint32_t* debug_line_offset) {\n+  \/\/ (3a,b)\n+  if (!read_header()) {\n+    DWARF_LOG_ERROR(\"Failed to read the compilation unit header.\");\n+    return false;\n+  }\n+\n+  \/\/ (3c) Read the abbreviation code immediately following the compilation unit header which is an offset to the\n+  \/\/ correct abbreviation table in .debug_abbrev for this compilation unit.\n+  uint64_t abbrev_code;\n+  if (!_reader.read_uleb128(&abbrev_code)) {\n+    return false;\n+  }\n+\n+  DebugAbbrev debug_abbrev(_dwarf_file, this);\n+  if (!debug_abbrev.read_section_header(_header._debug_abbrev_offset)) {\n+    DWARF_LOG_ERROR(\"Failed to read the .debug_abbrev header at \" PTR32_FORMAT, _header._debug_abbrev_offset);\n+    return false;\n+  }\n+  if (!debug_abbrev.find_debug_line_offset(abbrev_code)) {\n+    return false;\n+  }\n+  *debug_line_offset = _debug_line_offset; \/\/ Result was stored in _debug_line_offset.\n+  return true;\n+}\n+\n+\/\/ (3a) Parse header as specified in section 7.5.1.1 of the DWARF 4 spec.\n+bool DwarfFile::CompilationUnit::read_header() {\n+  Elf_Shdr shdr;\n+  if (!_dwarf_file->read_section_header(\".debug_info\", shdr)) {\n+    DWARF_LOG_ERROR(\"Failed to read the .debug_info section header.\");\n+    return false;\n+  }\n+\n+  if (!_reader.set_position(shdr.sh_offset + _compilation_unit_offset)) {\n+    return false;\n+  }\n+\n+  if (!_reader.read_dword(&_header._unit_length) || _header._unit_length == 0xFFFFFFFF) {\n+    \/\/ For 64-bit DWARF, the first 32-bit value is 0xFFFFFFFF. The current implementation only supports 32-bit DWARF\n+    \/\/ format since GCC only emits 32-bit DWARF.\n+    DWARF_LOG_ERROR(\"64-bit DWARF is not supported for .debug_info\")\n+    return false;\n+  }\n+\n+  if (!_reader.read_word(&_header._version) || _header._version != 4) {\n+    \/\/ DWARF 4 uses version 4 as specified in Appendix F of the DWARF 4 spec.\n+    DWARF_LOG_ERROR(\".debug_info in unsupported DWARF version %\" PRIu16, _header._version)\n+    return false;\n+  }\n+\n+  \/\/ (3b) Offset into .debug_abbrev section.\n+  if (!_reader.read_dword(&_header._debug_abbrev_offset)) {\n+    return false;\n+  }\n+\n+  if (!_reader.read_byte(&_header._address_size) || _header._address_size != DwarfFile::ADDRESS_SIZE) {\n+    \/\/ Addresses must be either 4 bytes for 32-bit architectures or 8 bytes for 64-bit architectures.\n+    DWARF_LOG_ERROR(\".debug_info specifies wrong address size %\" PRIu8, _header._address_size);\n+    return false;\n+  }\n+\n+  \/\/ Add because _unit_length is not included.\n+  _reader.set_max_pos(_reader.get_position() + _header._unit_length + 4);\n+  return true;\n+}\n+\n+bool DwarfFile::DebugAbbrev::read_section_header(uint32_t debug_abbrev_offset) {\n+  Elf_Shdr shdr;\n+  if (!_dwarf_file->read_section_header(\".debug_abbrev\", shdr)) {\n+    return false;\n+  }\n+\n+  _reader.set_max_pos(shdr.sh_offset + shdr.sh_size);\n+  if (!_reader.set_position(shdr.sh_offset + debug_abbrev_offset)) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+\/\/ (3d) The abbreviations table for a compilation unit consists of a series of abbreviation declarations. Each declaration\n+\/\/ specifies an abbrev code and a tag. Parse all declarations until we find the declaration which matches 'abbrev_code'.\n+\/\/ Read the attribute values from the compilation unit in .debug_info by using the format described in the declaration.\n+\/\/ This process is described in section 7.5 and 7.5.3 of the DWARF 4 spec.\n+bool DwarfFile::DebugAbbrev::find_debug_line_offset(const uint64_t abbrev_code) {\n+  DWARF_LOG_TRACE(\"Series of declarations [code, tag]:\");\n+  AbbreviationDeclaration declaration;\n+  while (_reader.has_bytes_left()) {\n+    if (!read_declaration(declaration)) {\n+      return false;\n+    }\n+\n+    DWARF_LOG_TRACE(\"  Series of attributes [name, form]:\");\n+    if (declaration._abbrev_code == abbrev_code) {\n+      \/\/ Found the correct declaration.\n+      if (is_wrong_or_unsupported_format(declaration)) {\n+        return false;\n+      }\n+      DWARF_LOG_INFO(\".debug_abbrev offset:  \" PTR32_FORMAT, (uint32_t)_reader.get_position());\n+      DWARF_LOG_TRACE(\"  Read the following attribute values from compilation unit:\");\n+      return read_attribute_specifications(true);\n+    } else {\n+      \/\/ Not the correct declaration. Read its attributes and continue with the next declaration.\n+      if (!read_attribute_specifications(false)) {\n+        return false;\n+      }\n+    }\n+  }\n+\n+  assert(false, \".debug_line offset not found\");\n+  return false;\n+}\n+\n+bool DwarfFile::DebugAbbrev::read_declaration(DwarfFile::DebugAbbrev::AbbreviationDeclaration& declaration) {\n+  if (!_reader.read_uleb128(&declaration._abbrev_code)) {\n+    return false;\n+  }\n+\n+  if (declaration._abbrev_code == 0) {\n+    \/\/ Reached the end of the abbreviation declarations for this compilation unit.\n+    DWARF_LOG_ERROR(\"abbrev_code not found in any declaration\");\n+    return false;\n+  }\n+\n+  if (!_reader.read_uleb128(&declaration._tag) || !_reader.read_byte(&declaration._has_children)) {\n+    return false;\n+  }\n+\n+  DWARF_LOG_TRACE(\"Code: 0x\" UINT64_FORMAT_X \", Tag: 0x\" UINT64_FORMAT_X, declaration._abbrev_code, declaration._tag);\n+  return true;\n+}\n+\n+bool DwarfFile::DebugAbbrev::is_wrong_or_unsupported_format(const DwarfFile::DebugAbbrev::AbbreviationDeclaration& declaration) {\n+  if (declaration._tag != DW_TAG_compile_unit) {\n+    \/\/ Is not DW_TAG_compile_unit as specified in Figure 18 in section 7.5 of the DWARF 4 spec. It could also\n+    \/\/ be DW_TAG_partial_unit (0x3c) which is currently not supported by this parser.\n+    DWARF_LOG_ERROR(\"Found unsupported tag in compilation unit: \" UINT64_FORMAT_X, declaration._tag);\n+    return true;\n+  }\n+  if (declaration._has_children != DW_CHILDREN_yes) {\n+    DWARF_LOG_ERROR(\"Must have children but none specified\");\n+    return true;\n+  }\n+  return false;\n+}\n+\n+\/\/ Read the attribute names and forms which define the actual attribute values that follow the abbrev code in the compilation unit. All\n+\/\/ attributes need to be read from the compilation unit until we reach the DW_AT_stmt_list attribute which specifies the offset for the\n+\/\/ line number program into the .debug_line section. The offset is stored in the _debug_line_offset field of the compilation unit.\n+bool DwarfFile::DebugAbbrev::read_attribute_specifications(const bool is_DW_TAG_compile_unit) {\n+  AttributeSpecification attribute_specification;\n+  while (_reader.has_bytes_left()) {\n+    if (!read_attribute_specification(attribute_specification)) {\n+      return false;\n+    }\n+\n+    if (is_terminating_specification(attribute_specification)) {\n+      \/\/ Parsed all attributes of this declaration.\n+      if (is_DW_TAG_compile_unit) {\n+        DWARF_LOG_ERROR(\"Did not find DW_AT_stmt_list in .debug_abbrev\");\n+        return false;\n+      } else {\n+        \/\/ Continue with next declaration if this was not DW_TAG_compile_unit.\n+        return true;\n+      }\n+    }\n+\n+    if (is_DW_TAG_compile_unit) {\n+      \/\/ Read attribute from compilation unit\n+      if (attribute_specification._name == DW_AT_stmt_list) {\n+        \/\/ This attribute represents the .debug_line offset. Read it and then stop parsing.\n+        return _compilation_unit->read_attribute_value(attribute_specification._form, true);\n+      } else {\n+        \/\/ Not DW_AT_stmt_list, read it and continue with the next attribute.\n+        if (!_compilation_unit->read_attribute_value(attribute_specification._form, false)) {\n+          return false;\n+        }\n+      }\n+    }\n+  }\n+\n+  assert(false, \".debug_abbrev section appears to be corrupted\");\n+  return false;\n+}\n+\n+bool DwarfFile::DebugAbbrev::read_attribute_specification(DwarfFile::DebugAbbrev::AttributeSpecification& specification) {\n+  bool result = _reader.read_uleb128(&specification._name) && _reader.read_uleb128(&specification._form);\n+  DWARF_LOG_TRACE(\"  Name: 0x\" UINT64_FORMAT_X \", Form: 0x\" UINT64_FORMAT_X,\n+                   specification._name, specification._form);\n+  return result;\n+}\n+\n+bool DwarfFile::DebugAbbrev::is_terminating_specification(const DwarfFile::DebugAbbrev::AttributeSpecification& specification) {\n+  return specification._name == 0 && specification._form == 0;\n+}\n+\n+\n+\/\/ (3e) Read the actual attribute values from the compilation unit in the .debug_info section. Each attribute has an encoding\n+\/\/ that specifies which values need to be read for it. This is specified in section 7.5.4 of the DWARF 4 spec.\n+\/\/ If is_DW_AT_stmt_list_attribute is:\n+\/\/ - False: Ignore the read attribute value.\n+\/\/ - True:  We are going to read the attribute value of the DW_AT_stmt_list attribute which specifies the offset into the\n+\/\/          .debug_line section for the line number program. Store this offset in the _debug_line_offset field.\n+bool DwarfFile::CompilationUnit::read_attribute_value(const uint64_t attribute_form, const bool is_DW_AT_stmt_list_attribute) {\n+  \/\/ Reset to the stored _cur_pos of the reader since the DebugAbbrev reader changed the index into the file with its reader.\n+  _reader.update_to_stored_position();\n+  uint8_t next_byte = 0;\n+  uint16_t next_word = 0;\n+  uint32_t next_dword = 0;\n+  uint64_t next_qword = 0;\n+\n+  switch (attribute_form) {\n+    case DW_FORM_addr:\n+      \/\/ Move position by the size of an address.\n+      _reader.move_position(DwarfFile::ADDRESS_SIZE);\n+      break;\n+    case DW_FORM_block2:\n+      \/\/ New position: length + data length (next_word)\n+      if (!_reader.read_word(&next_word) || !_reader.move_position(next_word)) {\n+        return false;\n+      }\n+      break;\n+    case DW_FORM_block4:\n+      \/\/ New position: length + data length (next_dword)\n+      if (!_reader.read_dword(&next_dword) || !_reader.move_position(next_dword)) {\n+        return false;\n+      }\n+      break;\n+    case DW_FORM_data2:\n+    case DW_FORM_ref2:\n+      if (!_reader.move_position(2)) {\n+        return false;\n+      }\n+      break;\n+    case DW_FORM_data4:\n+    case DW_FORM_strp: \/\/ 4 bytes in 32-bit DWARF\n+    case DW_FORM_ref_addr: \/\/ second type of reference: 4 bytes in 32-bit DWARF\n+    case DW_FORM_ref4:\n+      if (!_reader.move_position(4)) {\n+        return false;\n+      }\n+      break;\n+    case DW_FORM_data8:\n+    case DW_FORM_ref8:\n+    case DW_FORM_ref_sig8: \/\/ 64-bit type signature\n+      if (!_reader.move_position(8)) {\n+        return false;\n+      }\n+      break;\n+    case DW_FORM_string:\n+      if (!_reader.read_string()) {\n+        return false;\n+      }\n+      break;\n+    case DW_FORM_block:\n+    case DW_FORM_exprloc:\n+      \/\/ New position: length + data length (next_qword).\n+      if (!_reader.read_uleb128(&next_qword) || !_reader.move_position(next_qword)) {\n+        return false;\n+      }\n+      break;\n+    case DW_FORM_block1:\n+      \/\/ New position: length + data length (next_byte).\n+      if (!_reader.read_byte(&next_byte) || !_reader.move_position(next_byte)) {\n+        return false;\n+      }\n+      break;\n+    case DW_FORM_data1:\n+    case DW_FORM_ref1:\n+    case DW_FORM_flag:\n+    case DW_FORM_flag_present:\n+      if (!_reader.move_position(1)) {\n+        return false;\n+      }\n+      break;\n+    case DW_FORM_sdata:\n+    case DW_FORM_udata:\n+    case DW_FORM_ref_udata:\n+      if (!_reader.read_uleb128(&next_qword)) {\n+        return false;\n+      }\n+      break;\n+    case DW_FORM_indirect:\n+      \/\/ Should not be used and therefore is not supported by this parser.\n+      DWARF_LOG_ERROR(\"DW_FORM_indirect is not supported.\");\n+      return false;\n+    case DW_FORM_sec_offset:\n+      if (is_DW_AT_stmt_list_attribute) {\n+        \/\/ DW_AT_stmt_list has the DW_FORM_sec_offset attribute encoding. Store the result in _debug_line_offset.\n+        \/\/ 4 bytes for 32-bit DWARF.\n+        DWARF_LOG_TRACE(\"    Name: DW_AT_stmt_list, Form: DW_FORM_sec_offset\");\n+        DWARF_LOG_TRACE(\"    Reading .debug_line offset from compilation unit at \" PTR32_FORMAT,\n+                        (uint32_t)_reader.get_position());\n+        if (!_reader.read_dword(&_debug_line_offset)) {\n+          return false;\n+        }\n+        break;\n+      } else {\n+        if (!_reader.move_position(DwarfFile::DWARF_SECTION_OFFSET_SIZE)) {\n+          return false;\n+        }\n+        break;\n+      }\n+    default:\n+      assert(false, \"Unknown DW_FORM_* attribute encoding.\");\n+      return false;\n+  }\n+  \/\/ Reset the index into the file to the original position where the DebugAbbrev reader stopped reading before calling this method.\n+  _reader.reset_to_previous_position();\n+  return true;\n+}\n+\n+bool DwarfFile::LineNumberProgram::find_filename_and_line_number(char* filename, const size_t filename_len, int* line) {\n+  if (!read_header()) {\n+    DWARF_LOG_ERROR(\"Failed to parse the line number program header correctly.\");\n+    return false;\n+  }\n+  return run_line_number_program(filename, filename_len, line);\n+}\n+\n+\/\/ Parsing header as specified in section 6.2.4 of DWARF 4 spec. We do not read the file_names field, yet.\n+bool DwarfFile::LineNumberProgram::read_header() {\n+  Elf_Shdr shdr;\n+  if (!_dwarf_file->read_section_header(\".debug_line\", shdr)) {\n+    DWARF_LOG_ERROR(\"Failed to read the .debug_line section header.\");\n+    return false;\n+  }\n+\n+  if (!_reader.set_position(shdr.sh_offset + _debug_line_offset)) {\n+    return false;\n+  }\n+\n+  if (!_reader.read_dword(&_header._unit_length) || _header._unit_length == 0xFFFFFFFF) {\n+    \/\/ For 64-bit DWARF, the first 32-bit value is 0xFFFFFFFF. The current implementation only supports 32-bit DWARF\n+    \/\/ format since GCC only emits 32-bit DWARF.\n+    DWARF_LOG_ERROR(\"64-bit DWARF is not supported for .debug_line\")\n+    return false;\n+  }\n+\n+  if (!_reader.read_word(&_header._version) || _header._version < 2 || _header._version > 4) {\n+    \/\/ DWARF 3 uses version 3 and DWARF 4 uses version 4 as specified in Appendix F of the DWARF 3 and 4 spec, respectively.\n+    \/\/ For some reason, GCC is not following the standard here. While GCC emits DWARF 4 for the other parsed sections,\n+    \/\/ it chooses a different DWARF standard for .debug_line based on the GCC version:\n+    \/\/ - GCC 8 and earlier: .debug_line is in DWARF 2 format (= version 2).\n+    \/\/ - GCC 9 and 10:      .debug_line is in DWARF 3 format (= version 3).\n+    \/\/ - GCC 11:            .debug_line is in DWARF 4 format (= version 4).\n+    DWARF_LOG_ERROR(\".debug_line in unsupported DWARF version %\" PRIu16, _header._version)\n+    return false;\n+  }\n+\n+  if (!_reader.read_dword(&_header._header_length)) {\n+    return false;\n+  }\n+\n+  \/\/ To ensure not to read too many bytes in case of file corruption when reading the path_names field.\n+  _reader.set_max_pos(_reader.get_position() + _header._header_length);\n+\n+  if (!_reader.read_byte(&_header._minimum_instruction_length)) {\n+    return false;\n+  }\n+\n+  if (_header._version == 4) {\n+    if (!_reader.read_byte(&_header._maximum_operations_per_instruction)) {\n+      return false;\n+    }\n+  }\n+\n+  if (!_reader.read_byte(&_header._default_is_stmt)) {\n+    return false;\n+  }\n+\n+  if (!_reader.read_sbyte(&_header._line_base)) {\n+    return false;\n+  }\n+\n+  if (!_reader.read_byte(&_header._line_range)) {\n+    return false;\n+  }\n+\n+  if (!_reader.read_byte(&_header._opcode_base) || _header._opcode_base - 1 != 12) {\n+    \/\/ There are 12 standard opcodes for DWARF 3 and 4.\n+    DWARF_LOG_ERROR(\"Wrong number of opcodes: %\" PRIu8, _header._opcode_base)\n+    return false;\n+  }\n+\n+  for (uint8_t i = 0; i < _header._opcode_base - 1; i++) {\n+    if (!_reader.read_byte(&_header._standard_opcode_lengths[i])) {\n+      return false;\n+    }\n+  }\n+\n+  \/\/ Read field include_directories which is a sequence of path names. These are terminated by a single null byte.\n+  \/\/ We do not care about them, just read the strings and move on.\n+  while (_reader.read_string()) { }\n+\n+  \/\/ Delay reading file_names until we found the correct file index in the line number program. Store the position where\n+  \/\/ the file names start to parse them later. We directly jump to the line number program which starts at offset\n+  \/\/ header_size (=HEADER_DESCRIPTION_BYTES + _header_length) + _debug_line_offset\n+  _header._file_names_offset = _reader.get_position();\n+  uint32_t header_size = LineNumberProgramHeader::HEADER_DESCRIPTION_BYTES + _header._header_length;\n+  if (!_reader.set_position(shdr.sh_offset + header_size + _debug_line_offset)) {\n+    return false;\n+  }\n+\n+  \/\/ Now reset the max position to where the line number information for this compilation unit ends (i.e. where the state\n+  \/\/ machine gets terminated). Add 4 bytes to the offset because the size of the _unit_length field is not included in this\n+  \/\/ value.\n+  _reader.set_max_pos(shdr.sh_offset + _debug_line_offset + _header._unit_length + 4);\n+  return true;\n+}\n+\n+\/\/ Create the line number information matrix as described in section 6.2 of the DWARF 4 spec. Try to find the correct entry\n+\/\/ by comparing the address register belonging to each matrix row with _offset_in_library. Once it is found, we can read\n+\/\/ the line number from the line register and the filename by parsing the file_names list from the header until we reach\n+\/\/ the correct filename as specified by the file register.\n+\/\/\n+\/\/ If space was not a problem, the .debug_line section could provide a large matrix that contains an entry for each\n+\/\/ compiler instruction that contains the line number, the column number, the filename etc. But that's impractical.\n+\/\/ Two techniques optimize such a matrix:\n+\/\/ (1) If two offsets share the same file, line and column (and discriminator) information, the row is dropped.\n+\/\/ (2) We store a stream of bytes that represent opcodes to be executed in a well-defined state machine language\n+\/\/     instead of actually storing the entire matrix row by row.\n+\/\/\n+\/\/ Let's consider a simple example:\n+\/\/ 25: int iFld = 42;\n+\/\/ 26:\n+\/\/ 27: void bar(int i) {\n+\/\/ 28: }\n+\/\/ 29:\n+\/\/ 30: void foo() {\n+\/\/ 31:   bar(*iFld);\n+\/\/ 32: }\n+\/\/\n+\/\/ Disassembly of foo() with source code:\n+\/\/ 30:  void foo() {\n+\/\/           0x55d132:       55                      push   rbp\n+\/\/           0x55d133:       48 89 e5                mov    rbp,rsp\n+\/\/ 31:    bar(*iFld);\n+\/\/           0x55d136:       48 8b 05 b3 ee e8 01    mov    rax,QWORD PTR [rip+0x1e8eeb3]        # 23ebff0 <iFld>\n+\/\/           0x55d13d:       8b 00                   mov    eax,DWORD PTR [rax]\n+\/\/           0x55d13f:       89 c7                   mov    edi,eax\n+\/\/           0x55d141:       e8 e2 ff ff ff          call   55d128 <_Z3bari>\n+\/\/ 32:   }\n+\/\/           0x55d146:       90                      nop\n+\/\/           0x55d147:       5d                      pop    rbp\n+\/\/           0x55d148:       c3                      ret\n+\/\/\n+\/\/ This would produce the following matrix for foo() where duplicated lines (0x55d133, 0x55d13d, 0x55d13f) were removed\n+\/\/ according to (1):\n+\/\/ Address:    Line:    Column:   File:\n+\/\/ 0x55d132    30       12        1\n+\/\/ 0x55d136    31       6         1\n+\/\/ 0x55d146    32       1         1\n+\/\/\n+\/\/ When trying to get the line number for a PC, which is translated into an offset address x into the library file, we can either:\n+\/\/ - Directly find the last entry in the matrix for which address == x (there could be multiple entries with the same address).\n+\/\/ - If there is no matching address for x:\n+\/\/   1. Find two consecutive entries in the matrix for which: address_entry_1 < x < address_entry_2.\n+\/\/   2. Then take the entry of address_entry_1.\n+\/\/      E.g. x = 0x55d13f -> 0x55d136 < 0x55d13f < 0x55d146 -> Take entry 0x55d136.\n+\/\/\n+\/\/ Enable logging with debug level to print the generated line number information matrix.\n+bool DwarfFile::LineNumberProgram::run_line_number_program(char* filename, const size_t filename_len, int* line) {\n+  DWARF_LOG_DEBUG(\"\");\n+  DWARF_LOG_DEBUG(\"Line Number Information Matrix\");\n+  DWARF_LOG_DEBUG(\"------------------------------\");\n+#ifndef _LP64\n+  DWARF_LOG_DEBUG(\"Address:      Line:    Column:   File:\");\n+#else\n+  DWARF_LOG_DEBUG(\"Address:              Line:    Column:   File:\");\n+#endif\n+  _state = new (std::nothrow) LineNumberProgramState(_header);\n+  if (_state == nullptr) {\n+    DWARF_LOG_ERROR(\"Failed to create new LineNumberProgramState object\");\n+    return false;\n+  }\n+  uintptr_t previous_address = 0;\n+  uint32_t previous_file = 0;\n+  uint32_t previous_line = 0;\n+  bool found_entry = false;\n+  bool candidate = false;\n+  bool first_in_sequence = true;\n+  while (_reader.has_bytes_left()) {\n+    if (!apply_opcode()) {\n+      assert(false, \"Could not apply opcode\");\n+      return false;\n+    }\n+\n+    if (_state->_append_row) {\n+      \/\/ Append a new line to the line number information matrix.\n+      if (_state->_first_entry_in_sequence) {\n+        \/\/ First entry in sequence: Check if _offset_in_library >= _state->address. If not, then all following entries\n+        \/\/ belonging to this sequence cannot match our _offset_in_library because the addresses are always increasing\n+        \/\/ in a sequence.\n+        _state->_can_sequence_match_offset = _offset_in_library >= _state->_address;\n+        _state->_first_entry_in_sequence = false;\n+      }\n+      if (does_offset_match_entry(previous_address, previous_file, previous_line)) {\n+        \/\/ We are using an int for the line number which should never be larger than INT_MAX for any files.\n+        *line = (int)_state->_line;\n+        return get_filename_from_header(_state->_file, filename, filename_len);\n+      }\n+\n+      \/\/ We do not actually store the matrix while searching the correct entry. Enable logging to print\/debug it.\n+      DWARF_LOG_DEBUG(INTPTR_FORMAT \"    %-5u    %-3u       %-4u\",\n+                      _state->_address, _state->_line, _state->_column, _state->_file);\n+      previous_file = _state->_file;\n+      previous_line = _state->_line;\n+      previous_address = _state->_address;\n+      _state->_append_row = false;\n+      if (_state->_do_reset) {\n+        \/\/ Current sequence terminated.\n+        _state->reset_fields();\n+      }\n+    }\n+  }\n+\n+  assert(false, \"Did not find an entry in the line number information matrix that matches \" PTR32_FORMAT, _offset_in_library);\n+  return false;\n+}\n+\n+\/\/ Apply next opcode to update the state machine.\n+bool DwarfFile::LineNumberProgram::apply_opcode() {\n+  uint8_t opcode;\n+  if (!_reader.read_byte(&opcode)) {\n+    return false;\n+  }\n+\n+  DWARF_LOG_TRACE(\"  Opcode: 0x%02x \", opcode);\n+  if (opcode == 0) {\n+    \/\/ Extended opcodes start with a zero byte.\n+    if (!apply_extended_opcode()) {\n+      assert(false, \"Could not apply extended opcode\");\n+      return false;\n+    }\n+  } else if (opcode <= 12) {\n+    \/\/ 12 standard opcodes in DWARF 3 and 4.\n+    if (!apply_standard_opcode(opcode)) {\n+      assert(false, \"Could not apply standard opcode\");\n+      return false;\n+    }\n+  } else {\n+    \/\/ Special opcodes range from 13 until 255.\n+    apply_special_opcode(opcode);\n+  }\n+  return true;\n+}\n+\n+\/\/ Specified in section 6.2.5.3 of the DWARF 4 spec.\n+bool DwarfFile::LineNumberProgram::apply_extended_opcode() {\n+  uint64_t extended_opcode_length; \/\/ Does not include the already written zero byte and the length leb128.\n+  uint8_t extended_opcode;\n+  if (!_reader.read_uleb128(&extended_opcode_length) || !_reader.read_byte(&extended_opcode)) {\n+    return false;\n+  }\n+\n+  switch (extended_opcode) {\n+    case DW_LNE_end_sequence: \/\/ No operands\n+      DWARF_LOG_TRACE(\"    DW_LNE_end_sequence\");\n+      _state->_end_sequence = true;\n+      _state->_append_row = true;\n+      _state->_do_reset = true;\n+      break;\n+    case DW_LNE_set_address: \/\/ 1 operand\n+      if (!_reader.read_address_sized(&_state->_address)) {\n+        return false;\n+      }\n+      DWARF_LOG_TRACE(\"    DW_LNE_set_address \" INTPTR_FORMAT, _state->_address);\n+      if (_state->_dwarf_version == 4) {\n+        _state->_op_index = 0;\n+      }\n+      break;\n+    case DW_LNE_define_file: \/\/ 4 operands\n+    DWARF_LOG_TRACE(\"    DW_LNE_define_file\");\n+      if (!_reader.read_string()) {\n+        return false;\n+      }\n+      \/\/ Operand 2-4: uleb128 numbers we do not care about.\n+      if (!_reader.read_uleb128_ignore()\n+          || !_reader.read_uleb128_ignore()\n+          || !_reader.read_uleb128_ignore()) {\n+        return false;\n+      }\n+      break;\n+    case DW_LNE_set_discriminator: \/\/ 1 operand\n+      DWARF_LOG_TRACE(\"    DW_LNE_set_discriminator\");\n+      uint64_t discriminator;\n+      \/\/ For some reason, GCC emits this opcode even for earlier versions than DWARF 4 which introduced this opcode.\n+      \/\/ We need to consume it.\n+      if (!_reader.read_uleb128(&discriminator, 4)) {\n+        \/\/ Must be an unsigned integer as specified in section 6.2.2 of the DWARF 4 spec for the discriminator register.\n+        return false;\n+      }\n+      _state->_discriminator = discriminator;\n+      break;\n+    default:\n+      assert(false, \"Unknown extended opcode\");\n+      return false;\n+  }\n+  return true;\n+}\n+\n+\/\/ Specified in section 6.2.5.2 of the DWARF 4 spec.\n+bool DwarfFile::LineNumberProgram::apply_standard_opcode(const uint8_t opcode) {\n+  switch (opcode) {\n+    case DW_LNS_copy: \/\/ No operands\n+      DWARF_LOG_TRACE(\"    DW_LNS_copy\");\n+      _state->_append_row = true;\n+      _state->_basic_block = false;\n+      _state->_prologue_end = false;\n+      _state->_epilogue_begin = false;\n+      if (_state->_dwarf_version == 4) {\n+        _state->_discriminator = 0;\n+      }\n+      break;\n+    case DW_LNS_advance_pc: { \/\/ 1 operand\n+      uint64_t operation_advance;\n+      if (!_reader.read_uleb128(&operation_advance, 4)) {\n+        \/\/ Must be at most 4 bytes because the index register is only 4 bytes wide.\n+        return false;\n+      }\n+      _state->add_to_address_register(operation_advance, _header);\n+      if (_state->_dwarf_version == 4) {\n+        _state->set_index_register(operation_advance, _header);\n+      }\n+      DWARF_LOG_TRACE(\"    DW_LNS_advance_pc (\" INTPTR_FORMAT \")\", _state->_address);\n+      break;\n+    }\n+    case DW_LNS_advance_line: \/\/ 1 operand\n+      int64_t line;\n+      if (!_reader.read_sleb128(&line, 4)) {\n+        \/\/ line register is 4 bytes wide.\n+        return false;\n+      }\n+      _state->_line += line;\n+      DWARF_LOG_TRACE(\"    DW_LNS_advance_line (%d)\", _state->_line);\n+      break;\n+    case DW_LNS_set_file: \/\/ 1 operand\n+      uint64_t file;\n+      if (!_reader.read_uleb128(&file, 4)) {\n+        \/\/ file register is 4 bytes wide.\n+        return false;\n+      }\n+      _state->_file = file;\n+      DWARF_LOG_TRACE(\"    DW_LNS_set_file (%u)\", _state->_file);\n+      break;\n+    case DW_LNS_set_column: \/\/ 1 operand\n+      uint64_t column;\n+      if (!_reader.read_uleb128(&column, 4)) {\n+        \/\/ column register is 4 bytes wide.\n+        return false;\n+      }\n+      _state->_column = column;\n+      DWARF_LOG_TRACE(\"    DW_LNS_set_column (%u)\", _state->_column);\n+      break;\n+    case DW_LNS_negate_stmt: \/\/ No operands\n+      DWARF_LOG_TRACE(\"    DW_LNS_negate_stmt\");\n+      _state->_is_stmt = !_state->_is_stmt;\n+      break;\n+    case DW_LNS_set_basic_block: \/\/ No operands\n+      DWARF_LOG_TRACE(\"    DW_LNS_set_basic_block\");\n+      _state->_basic_block = true;\n+      break;\n+    case DW_LNS_const_add_pc: { \/\/ No operands\n+      \/\/ Update address and op_index registers by the increments of special opcode 255.\n+      uint8_t adjusted_opcode_255 = 255 - _header._opcode_base;\n+      uint8_t operation_advance = adjusted_opcode_255 \/ _header._line_range;\n+      uintptr_t old_address = _state->_address;\n+      _state->add_to_address_register(operation_advance, _header);\n+      if (_state->_dwarf_version == 4) {\n+        _state->set_index_register(operation_advance, _header);\n+      }\n+      DWARF_LOG_TRACE(\"    DW_LNS_const_add_pc (\" INTPTR_FORMAT \")\", _state->_address - old_address);\n+      break;\n+    }\n+    case DW_LNS_fixed_advance_pc: \/\/ 1 operand\n+      uint16_t operand;\n+      if (!_reader.read_word(&operand)) {\n+        return false;\n+      }\n+      _state->_address += operand;\n+      _state->_op_index = 0;\n+      DWARF_LOG_TRACE(\"    DW_LNS_fixed_advance_pc (\" INTPTR_FORMAT \")\", _state->_address);\n+      break;\n+    case DW_LNS_set_prologue_end: \/\/ No operands\n+      DWARF_LOG_TRACE(\"    DW_LNS_set_basic_block\");\n+      _state->_prologue_end = true;\n+      break;\n+    case DW_LNS_set_epilogue_begin: \/\/ No operands\n+      DWARF_LOG_TRACE(\"    DW_LNS_set_epilogue_begin\");\n+      _state->_epilogue_begin = true;\n+      break;\n+    case DW_LNS_set_isa: \/\/ 1 operand\n+      uint64_t isa;\n+      if (!_reader.read_uleb128(&isa, 4)) {\n+        \/\/ isa register is 4 bytes wide.\n+        return false;\n+      }\n+      _state->_isa = isa;\n+      DWARF_LOG_TRACE(\"    DW_LNS_set_isa (%u)\", _state->_isa);\n+      break;\n+    default:\n+      assert(false, \"Unknown standard opcode\");\n+      return false;\n+  }\n+  return true;\n+}\n+\n+\/\/ Specified in section 6.2.5.1 of the DWARF 4 spec.\n+void DwarfFile::LineNumberProgram::apply_special_opcode(const uint8_t opcode) {\n+  uintptr_t old_address = _state->_address;\n+  uint32_t old_line = _state->_line;\n+  uint8_t adjusted_opcode = opcode - _header._opcode_base;\n+  uint8_t operation_advance = adjusted_opcode \/ _header._line_range;\n+  _state->add_to_address_register(operation_advance, _header);\n+  if (_state->_dwarf_version == 4) {\n+    _state->set_index_register(operation_advance, _header);\n+    _state->_discriminator = 0;\n+  }\n+  _state->_line += _header._line_base + (adjusted_opcode % _header._line_range);\n+  DWARF_LOG_TRACE(\"    address += \" INTPTR_FORMAT \", line += %d\", _state->_address - old_address,\n+                  _state->_line - old_line);\n+  _state->_append_row = true;\n+  _state->_basic_block = false;\n+  _state->_prologue_end = false;\n+  _state->_epilogue_begin = false;\n+}\n+\n+bool DwarfFile::LineNumberProgram::does_offset_match_entry(const uintptr_t previous_address, const uint32_t previous_file,\n+                                                           const uint32_t previous_line) {\n+  if (_state->_can_sequence_match_offset) {\n+    bool matches_entry_directly = _offset_in_library == _state->_address;\n+    if (matches_entry_directly\n+         || (_offset_in_library > previous_address && _offset_in_library < _state->_address)) { \/\/ in between two entries\n+      _state->_found_match = true;\n+      if (!matches_entry_directly || _is_pc_after_call) {\n+        \/\/ We take the previous row in the matrix either when:\n+        \/\/ - We try to match an offset that is between two entries.\n+        \/\/ - We have an offset from a PC that is at a call-site in which case we need to get the line information for\n+        \/\/   the call instruction in the previous entry.\n+        print_and_store_prev_entry(previous_file, previous_line);\n+        return true;\n+      } else if (!_reader.has_bytes_left()) {\n+        \/\/ We take the current entry when this is the very last entry in the matrix (i.e. must be the right one).\n+        DWARF_LOG_DEBUG(\"^^^ Found line for requested offset \" PTR32_FORMAT \" ^^^\", _offset_in_library);\n+        return true;\n+      }\n+      \/\/ Else: Exact match. We cannot take this entry because we do not know if there are more entries following this\n+      \/\/       one with the same offset (we could have multiple entries for the same address in the matrix). Continue\n+      \/\/       to parse entries. When we have the first non-exact match, then we know that the previous entry is the\n+      \/\/       correct one to take (handled in the else-if-case below). If this is the very last entry in a matrix,\n+      \/\/       we will take the current entry (handled in else-if-case above).\n+    } else if (_state->_found_match) {\n+      \/\/ We found an entry before with an exact match. This is now the first entry with a new offset. Pick the previous\n+      \/\/ entry which matches our offset and is guaranteed to be the last entry which matches our offset (if there are\n+      \/\/ multiple entries with the same offset).\n+      print_and_store_prev_entry(previous_file, previous_line);\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+void DwarfFile::LineNumberProgram::print_and_store_prev_entry(const uint32_t previous_file, const uint32_t previous_line) {\n+  _state->_file = previous_file;\n+  _state->_line = previous_line;\n+  DWARF_LOG_DEBUG(\"^^^ Found line for requested offset \" PTR32_FORMAT \" ^^^\", _offset_in_library);\n+  \/\/ Also print the currently parsed entry.\n+  DWARF_LOG_DEBUG(INTPTR_FORMAT \"    %-5u    %-3u       %-4u\",\n+                  _state->_address, _state->_line, _state->_column, _state->_file);\n+}\n+\n+\/\/ Read field file_names from the header as specified in section 6.2.4 of the DWARF 4 spec.\n+bool DwarfFile::LineNumberProgram::get_filename_from_header(const uint32_t file_index, char* filename, const size_t filename_len) {\n+  \/\/ We do not need to restore the position afterwards as this is the last step of parsing from the file for this compilation unit.\n+  _reader.set_position(_header._file_names_offset);\n+  uint32_t current_index = 1; \/\/ file_names start at index 1\n+  while (_reader.has_bytes_left()) {\n+    if (!_reader.read_string(filename, filename_len)) {\n+      \/\/ Either an error while reading or we have reached the end of the file_names. Both should not happen.\n+      return false;\n+    }\n+\n+    if (current_index == file_index) {\n+      \/\/ Found correct file.\n+      return true;\n+    }\n+\n+    \/\/ We don't care about these values.\n+    if (!_reader.read_uleb128_ignore() \/\/ Read directory index\n+        || !_reader.read_uleb128_ignore()  \/\/ Read last modification of file\n+        || !_reader.read_uleb128_ignore()) { \/\/ Read file length\n+      return false;\n+    }\n+    current_index++;\n+  }\n+  DWARF_LOG_DEBUG(\"Did not find filename entry at index \" UINT32_FORMAT \" in .debug_line header\", file_index);\n+  return false;\n+}\n+\n+void DwarfFile::LineNumberProgram::LineNumberProgramState::reset_fields() {\n+  _address = 0;\n+  _op_index = 0;\n+  _file = 1;\n+  _line = 1;\n+  _column = 0;\n+  _is_stmt = _initial_is_stmt;\n+  _basic_block = false;\n+  _end_sequence = false;\n+  _prologue_end = false;\n+  _epilogue_begin = false;\n+  _isa = 0;\n+  _discriminator = 0;\n+  _append_row = false;\n+  _do_reset = false;\n+  _first_entry_in_sequence = true;\n+  _can_sequence_match_offset = false;\n+}\n+\n+\/\/ Defined in section 6.2.5.1 of the DWARF 4 spec.\n+void DwarfFile::LineNumberProgram::LineNumberProgramState::add_to_address_register(const uint32_t operation_advance,\n+                                                                                   const LineNumberProgramHeader& header) {\n+  if (_dwarf_version == 2 || _dwarf_version == 3) {\n+    _address += (uintptr_t)(operation_advance * header._minimum_instruction_length);\n+  } else if (_dwarf_version == 4) {\n+    _address += (uintptr_t)(header._minimum_instruction_length *\n+                ((_op_index + operation_advance) \/ header._maximum_operations_per_instruction));\n+  }\n+}\n+\n+\/\/ Defined in section 6.2.5.1 of the DWARF 4 spec.\n+void DwarfFile::LineNumberProgram::LineNumberProgramState::set_index_register(const uint32_t operation_advance,\n+                                                                              const LineNumberProgramHeader& header) {\n+  _op_index = (_op_index + operation_advance) % header._maximum_operations_per_instruction;\n+}\n+\n+bool DwarfFile::MarkedDwarfFileReader::set_position(const long new_pos) {\n+  if (new_pos < 0) {\n+    return false;\n+  }\n+  _current_pos = new_pos;\n+  return FileReader::set_position(new_pos);\n+}\n+\n+bool DwarfFile::MarkedDwarfFileReader::has_bytes_left() const {\n+  if (_max_pos == -1) {\n+    return false;\n+  }\n+  return _current_pos < _max_pos;\n+}\n+\n+bool DwarfFile::MarkedDwarfFileReader::update_to_stored_position() {\n+  _marked_pos = ftell(_fd);\n+  if (_marked_pos < 0) {\n+    return false;\n+  }\n+  return FileReader::set_position(_current_pos);\n+}\n+\n+bool DwarfFile::MarkedDwarfFileReader::reset_to_previous_position() {\n+  return FileReader::set_position(_marked_pos);\n+}\n+\n+bool DwarfFile::MarkedDwarfFileReader::move_position(const long offset) {\n+  if (offset == 0) {\n+    return true;\n+  }\n+  return set_position(_current_pos + offset);\n+}\n+\n+bool DwarfFile::MarkedDwarfFileReader::read_sbyte(int8_t* result) {\n+  _current_pos++;\n+  return read(result, 1);\n+}\n+\n+bool DwarfFile::MarkedDwarfFileReader::read_byte(uint8_t* result) {\n+  _current_pos++;\n+  return read(result, 1);\n+}\n+\n+bool DwarfFile::MarkedDwarfFileReader::read_word(uint16_t* result) {\n+  _current_pos += 2;\n+  return read(result, 2);\n+}\n+\n+bool DwarfFile::MarkedDwarfFileReader::read_dword(uint32_t* result) {\n+  _current_pos += 4;\n+  return read(result, 4);\n+}\n+\n+bool DwarfFile::MarkedDwarfFileReader::read_qword(uint64_t* result) {\n+  _current_pos += 8;\n+  return read(result, 8);\n+}\n+\n+bool DwarfFile::MarkedDwarfFileReader::read_address_sized(uintptr_t* result) {\n+  _current_pos += DwarfFile::ADDRESS_SIZE;\n+  return read(result, DwarfFile::ADDRESS_SIZE);\n+}\n+\n+\/\/ See Figure 46\/47 in Appendix C of the DWARF 4 spec.\n+bool DwarfFile::MarkedDwarfFileReader::read_leb128(uint64_t* result, const int8_t check_size, bool is_signed) {\n+  *result = 0; \/\/ Ensure a proper result by zeroing it first.\n+  uint8_t buf;\n+  uint8_t shift = 0;\n+  uint8_t bytes_read = 0;\n+  \/\/ leb128 is not larger than 8 bytes.\n+  while (bytes_read < 8) {\n+    if (!read_byte(&buf)) {\n+      return false;\n+    }\n+    bytes_read++;\n+    *result |= (buf & 0x7fu) << shift;\n+    shift += 7;\n+    if ((buf & 0x80u) == 0) {\n+      break;\n+    }\n+  }\n+  if (bytes_read > 8 || (check_size != -1 && bytes_read > check_size)) {\n+    \/\/ Invalid leb128 encoding or the read leb128 was larger than expected.\n+    return false;\n+  }\n+\n+  if (is_signed && (shift < 64) && (buf & 0x40u)) {\n+    *result |= static_cast<uint64_t>(-1L) << shift;\n+  }\n+  return true;\n+}\n+\n+bool DwarfFile::MarkedDwarfFileReader::read_uleb128_ignore(const int8_t check_size) {\n+  uint64_t dont_care;\n+  return read_leb128(&dont_care, check_size, false);\n+}\n+\n+bool DwarfFile::MarkedDwarfFileReader::read_uleb128(uint64_t* result, const int8_t check_size) {\n+  return read_leb128(result, check_size, false);\n+}\n+\n+bool DwarfFile::MarkedDwarfFileReader::read_sleb128(int64_t* result, const int8_t check_size) {\n+  return read_leb128((uint64_t*)result, check_size, true);\n+}\n+\n+\/\/ If result is a nullptr, we do not care about the content of the string being read.\n+bool DwarfFile::MarkedDwarfFileReader::read_string(char* result, const size_t result_len) {\n+  uint8_t next_byte;\n+  if (!read_byte(&next_byte)) {\n+    return false;\n+  }\n+\n+  if (next_byte == 0) {\n+    \/\/ Strings must contain at least one non-null byte.\n+    return false;\n+  }\n+\n+  if (result != nullptr) {\n+    if (result_len < 2) {\n+      \/\/ Strings must contain at least one non-null byte and a null byte terminator.\n+      return false;\n+    }\n+    result[0] = (char)next_byte;\n+  }\n+\n+  size_t char_index = 1;\n+  bool exceeded_buffer = false;\n+  while (has_bytes_left()) {\n+    \/\/ Read until we find a null byte which terminates the string.\n+    if (!read_byte(&next_byte)) {\n+      return false;\n+    }\n+\n+    if (result != nullptr) {\n+      if (char_index >= result_len) {\n+        \/\/ Exceeded buffer size of 'result'.\n+        exceeded_buffer = true;\n+      } else {\n+        result[char_index] = (char)next_byte;\n+      }\n+      char_index++;\n+    }\n+    if (next_byte == 0) {\n+      if (exceeded_buffer) {\n+        result[result_len - 1] = '\\0'; \/\/ Mark end of string.\n+        DWARF_LOG_ERROR(\"Tried to read \" SIZE_FORMAT \" bytes but exceeded buffer size of \" SIZE_FORMAT \". Truncating string.\",\n+                        char_index, result_len);\n+      }\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+#endif \/\/ !_WINDOWS && !__APPLE__\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/utilities\/elfFile.cpp","additions":1503,"deletions":36,"binary":false,"changes":1539,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,1 @@\n+#include \"jvm_md.h\"\n@@ -74,0 +75,21 @@\n+#ifdef ASSERT\n+\/\/ Helper macros to print different log levels during DWARF parsing\n+#define DWARF_LOG_SUMMARY(format, ...) DWARF_LOG_WITH_LEVEL(1, format, ##__VA_ARGS__) \/\/ Same level as error logging\n+#define DWARF_LOG_ERROR(format, ...) DWARF_LOG_WITH_LEVEL(1, format, ##__VA_ARGS__)\n+#define DWARF_LOG_INFO(format, ...) DWARF_LOG_WITH_LEVEL(2, format, ##__VA_ARGS__)\n+#define DWARF_LOG_DEBUG(format, ...) DWARF_LOG_WITH_LEVEL(3, format, ##__VA_ARGS__)\n+#define DWARF_LOG_TRACE(format, ...) DWARF_LOG_WITH_LEVEL(4, format, ##__VA_ARGS__)\n+\n+#define DWARF_LOG_WITH_LEVEL(level, format, ...) \\\n+    if (TraceDwarfLevel >= level) {         \\\n+      tty->print(\"[dwarf] \");               \\\n+      tty->print_cr(format, ##__VA_ARGS__); \\\n+    }\n+#else\n+#define DWARF_LOG_SUMMARY(format, ...)\n+#define DWARF_LOG_ERROR(format, ...)\n+#define DWARF_LOG_INFO(format, ...)\n+#define DWARF_LOG_DEBUG(format, ...)\n+#define DWARF_LOG_TRACE(format, ...)\n+#endif\n+\n@@ -77,0 +99,1 @@\n+class DwarfFile;\n@@ -99,1 +122,1 @@\n-protected:\n+ protected:\n@@ -101,1 +124,1 @@\n-public:\n+ public:\n@@ -104,2 +127,2 @@\n-  int  read_buffer(void* buf, size_t size);\n-  bool set_position(long offset);\n+  size_t read_buffer(void* buf, size_t size);\n+  virtual bool set_position(long offset);\n@@ -111,1 +134,1 @@\n-private:\n+ protected:\n@@ -113,1 +136,1 @@\n-public:\n+ public:\n@@ -128,1 +151,1 @@\n-private:\n+ private:\n@@ -136,3 +159,0 @@\n-  \/\/ Elf header\n-  Elf_Ehdr          _elfHdr;\n-\n@@ -153,1 +173,7 @@\n-public:\n+  DwarfFile* _dwarf_file;\n+  static const char* USR_LIB_DEBUG_DIRECTORY;\n+ protected:\n+  \/\/ Elf header\n+  Elf_Ehdr          _elfHdr;\n+\n+ public:\n@@ -155,1 +181,1 @@\n-  ~ElfFile();\n+  virtual ~ElfFile();\n@@ -159,4 +185,0 @@\n-  const char* filepath() const {\n-    return _filepath;\n-  }\n-\n@@ -178,1 +200,4 @@\n-private:\n+\n+  bool get_source_info(uint32_t offset_in_library, char* filename, size_t filename_len, int* line, bool is_pc_after_call);\n+\n+ private:\n@@ -191,0 +216,1 @@\n+#if defined(PPC64) && !defined(ABI_ELFv2)\n@@ -194,0 +220,1 @@\n+#endif\n@@ -204,0 +231,21 @@\n+  \/\/ Cleanup string, symbol and function descriptor tables\n+  void cleanup_tables();\n+\n+  bool create_new_dwarf_file(const char* filepath);\n+\n+  \/\/ Struct to store the debug info read from the .gnu_debuglink section.\n+  struct DebugInfo {\n+    static const uint8_t CRC_LEN = 4;\n+\n+    char _dwarf_filename[JVM_MAXPATHLEN];\n+    uint32_t _crc;\n+  };\n+\n+  \/\/ Helper class to create DWARF paths when loading a DWARF file.\n+  class DwarfFilePath {\n+   private:\n+    static const uint16_t MAX_DWARF_PATH_LENGTH = JVM_MAXPATHLEN;\n+    const char* _filename;\n+    char _path[MAX_DWARF_PATH_LENGTH];\n+    const uint32_t _crc;\n+    uint16_t _null_terminator_index; \/\/ Index for the current null terminator of the string stored in _path\n@@ -205,0 +253,58 @@\n+    bool check_valid_path() const {\n+      return _path[MAX_DWARF_PATH_LENGTH - 1] == '\\0';\n+    }\n+\n+    void update_null_terminator_index() {\n+      _null_terminator_index = strlen(_path);\n+    }\n+\n+    bool copy_to_path_index(uint16_t index_in_path, const char* src);\n+\n+   public:\n+    DwarfFilePath(DebugInfo& debug_info)\n+      : _filename(debug_info._dwarf_filename), _crc(debug_info._crc), _null_terminator_index(0) {\n+      _path[MAX_DWARF_PATH_LENGTH - 1] = '\\0';  \/\/ Ensures to have a null terminated string and not read beyond the buffer limit.\n+    }\n+\n+    const char* path() const {\n+      return _path;\n+    }\n+\n+    const char* filename() const {\n+      return _filename;\n+    }\n+\n+    uint32_t crc() const {\n+      return _crc;\n+    }\n+\n+    bool set(const char* src);\n+\n+    bool set_filename_after_last_slash() {\n+      return set_after_last_slash(_filename);\n+    }\n+\n+    bool set_after_last_slash(const char* src);\n+    bool append(const char* src);\n+  };\n+\n+  \/\/ Load the DWARF file (.debuginfo) that belongs to this file either from (checked in listed order):\n+  \/\/ - Same directory as the library file.\n+  \/\/ - User defined path in environmental variable _JVM_DWARF_PATH.\n+  \/\/ - Subdirectory .debug in same directory as the library file.\n+  \/\/ - \/usr\/lib\/debug directory\n+  bool load_dwarf_file();\n+\n+\n+  bool read_debug_info(DebugInfo* debug_info) const;\n+\n+  bool load_dwarf_file_from_same_directory(DwarfFilePath& dwarf_file_path);\n+  bool load_dwarf_file_from_env_var_path(DwarfFilePath& dwarf_file_path);\n+  bool load_dwarf_file_from_env_path_folder(DwarfFilePath& dwarf_file_path, const char* dwarf_path_from_env, const char* folder);\n+  bool load_dwarf_file_from_debug_sub_directory(DwarfFilePath& dwarf_file_path);\n+  bool load_dwarf_file_from_usr_lib_debug(DwarfFilePath& dwarf_file_path);\n+  bool open_valid_debuginfo_file(const DwarfFilePath& dwarf_file_path);\n+  static uint32_t get_file_crc(FILE* const file);\n+  static uint gnu_debuglink_crc32(uint32_t crc, uint8_t* buf, size_t len);\n+\n+ protected:\n@@ -207,2 +313,3 @@\n-  \/\/ Cleanup string, symbol and function descriptor tables\n-  void cleanup_tables();\n+  \/\/ Read the section header of section 'name'.\n+  bool read_section_header(const char* name, Elf_Shdr& hdr) const;\n+  bool is_valid_dwarf_file() const;\n@@ -210,1 +317,1 @@\n-public:\n+ public:\n@@ -215,0 +322,567 @@\n+\n+\/*\n+ * This class parses and reads filename and line number information from an associated .debuginfo file that belongs to\n+ * this ELF file or directly from this ELF file if there is no separate .debuginfo file. The debug info is written by GCC\n+ * in DWARF - a standardized debugging data format. There are special sections where the DWARF info is written to. These\n+ * sections can either be put into the same ELF file or a separate .debuginfo file. For simplicity, when referring to the\n+ * \"DWARF file\" or the \".debuginfo file\" we just mean the file that contains the required DWARF sections. The current version\n+ * of GCC uses DWARF version 4 as default which is defined in the official standard: http:\/\/www.dwarfstd.org\/doc\/DWARF4.pdf.\n+ * This class is able to parse 32-bit DWARF version 4 for 32 and 64-bit Linux builds. GCC does not emit 64-bit DWARF and\n+ * therefore is not supported by this parser. For some reason, GCC emits DWARF version 3 for the .debug_line section as a\n+ * default. This parser was therefore adapted to support DWARF version 3 and 4 for the .debug_line section. Apart from that,\n+ * other DWARF versions, especially the newest version 5, are not (yet) supported.\n+ *\n+ * Description of used DWARF file sections:\n+ * - .debug_aranges: A table that consists of sets of variable length entries, each set describing the portion of the\n+ *                   program's address space that is covered by a single compilation unit. In other words, the entries\n+ *                   describe a mapping between addresses and compilation units.\n+ * - .debug_info:    The core DWARF data containing DWARF Information Entries (DIEs). Each DIE consists of a tag and a\n+ *                   series of attributes. Each (normal) compilation unit is represented by a DIE with the tag\n+ *                   DW_TAG_compile_unit and contains children. For our purposes, we are only interested in this DIE to\n+ *                   get to the .debug_line section. We do not care about the children. This parser currently only\n+ *                   supports normal compilation units and no partial compilation or type units.\n+ * - .debug_abbrev:  Represents abbreviation tables for all compilation units. A table for a specific compilation unit\n+ *                   consists of a series of abbreviation declarations. Each declaration specifies a tag and attributes\n+ *                   for a DIE. The DIEs from the compilation units in the .debug_info section need the abbreviation table\n+ *                   to decode their attributes (their meaning and size).\n+ * - .debug_line:    Contains filename and line number information for each compilation unit. To get the information, a\n+ *                   state machine needs to be executed which generates a matrix. Each row of this matrix describes the\n+ *                   filename and line number (among other information) for a specific offset in the associated ELF library\n+ *                   file. The state machine is executed until the row for the requested offset is found. The filename and\n+ *                   line number information can then be fetched with the current register values of the state machine.\n+ *\n+ * Algorithm\n+ * ---------\n+ * Given: Offset into the ELF file library.\n+ * Return: Filename and line number for this offset.\n+ * (1) First, the path to the .debuginfo DWARF file is found by inspecting the .gnu_debuglink section of the library file.\n+ *     The DWARF file is then opened by calling the constructor of this class. Once this is done, the processing of the\n+ *     DWARF file is initiated by calling find_filename_and_line_number().\n+ * (2) Find the compilation unit offset by reading entries from the section .debug_aranges, which contain address range\n+ *     descriptors, until we find the correct descriptor that includes the library offset.\n+ * (3) Find the .debug_line offset for the line number information program from the .debug_info section:\n+ *     (a) Parse the compilation unit header from the .debug_info section at the offset obtained by (2).\n+ *     (b) Read the debug_abbrev_offset into the .debug_abbrev section that belongs to this compilation unit from the\n+ *         header obtained in (3a).\n+ *     (c) Read the abbreviation code that immediately follows the compilation unit header from (3a) which is needed to\n+ *         find the correct entry in the .debug_abbrev section.\n+ *     (d) Find the correct entry in the abbreviation table in the .debug_abbrev section by starting to parse entries at\n+ *         the debug_abbrev_offset from (3b) until we find the correct one matching the abbreviation code from (3c).\n+ *     (e) Read the specified attributes of the abbreviation entry from (3d) from the compilation unit (in the .debug_info\n+ *         section) until we find the attribute DW_AT_stmt_list. This attributes represents an offset into the .debug_line\n+ *         section which contains the line number program information to get the filename and the line number.\n+ *  (4) Find the filename and line number belonging to the given library offset by running the line number program state\n+ *      machine with its registers. This creates a matrix where each row stores information for specific addresses (library\n+ *      offsets). The state machine executes different opcodes which modify the state machine registers. Certain opcodes\n+ *      will add a new row to the matrix by taking the current values of state machine registers. As soon as the correct\n+ *      matrix row matching the library offset is found, we can read the line number from the line register of the state\n+ *      machine and parse the filename from the line number program header with the given file index from the file register\n+ *      of the state machine.\n+ *\n+ *  More details about the different phases can be found at the associated classes and methods. A visualization of the\n+ *  algorithm inside the different sections can be found in the class comments for DebugAranges, DebugAbbrev and\n+ *  LineNumberProgram further down in this file.\n+ *\n+ *  Available (develop) log levels (-XX:TraceDwarfLevel=[1,4]) which are only present in debug builds. Each level prints\n+ *  all the logs of the previous levels and adds some more fine-grained logging:\n+ *  - Level 1 (summary + errors):\n+ *    - Prints the path of parsed DWARF file together with the resulting source information.\n+ *    - Prints all errors.\n+ *  - Level 2 (info):\n+ *    - Prints the found offsets of all DWARF sections\n+ *  - Level 3 (debug):\n+ *    - Prints the results of the steps (1) - (4) together with the generated line information matrix.\n+ *  - Level 4 (trace):\n+ *    - Complete information about intermediate states\/results when parsing the DWARF file.\n+ *\/\n+class DwarfFile : public ElfFile {\n+\n+  static constexpr uint8_t ADDRESS_SIZE = NOT_LP64(4) LP64_ONLY(8);\n+  \/\/ We only support 32-bit DWARF (emitted by GCC) which uses 32-bit values for DWARF section lengths and offsets\n+  \/\/ relative to the beginning of a section.\n+  static constexpr uint8_t DWARF_SECTION_OFFSET_SIZE = 4;\n+\n+  class MarkedDwarfFileReader : public MarkedFileReader {\n+   private:\n+    long _current_pos;\n+    long _max_pos; \/\/ Used to guarantee that we stop reading in case we reached the end of a section.\n+\n+    bool read_leb128(uint64_t* result, int8_t check_size, bool is_signed);\n+   public:\n+    MarkedDwarfFileReader(FILE* const fd) : MarkedFileReader(fd), _current_pos(-1), _max_pos(-1) {}\n+\n+    virtual bool set_position(long new_pos);\n+    long get_position() const { return _current_pos; }\n+    void set_max_pos(long max_pos) { _max_pos = max_pos; }\n+    \/\/ Have we reached the limit of maximally allowable bytes to read? Used to ensure to stop reading when a section ends.\n+    bool has_bytes_left() const;\n+    \/\/ Call this if another file reader has changed the position of the same file handle.\n+    bool update_to_stored_position();\n+    \/\/ Must be called to restore the old position before this file reader changed it with update_to_stored_position().\n+    bool reset_to_previous_position();\n+    bool move_position(long offset);\n+    bool read_sbyte(int8_t* result);\n+    bool read_byte(uint8_t* result);\n+    bool read_word(uint16_t* result);\n+    bool read_dword(uint32_t* result);\n+    bool read_qword(uint64_t* result);\n+    bool read_uleb128_ignore(int8_t check_size = -1);\n+    bool read_uleb128(uint64_t* result, int8_t check_size = -1);\n+    bool read_sleb128(int64_t* result, int8_t check_size = -1);\n+    \/\/ Reads 4 bytes for 32-bit and 8 bytes for 64-bit builds.\n+    bool read_address_sized(uintptr_t* result);\n+    bool read_string(char* result = nullptr, size_t result_len = 0);\n+  };\n+\n+  \/\/ (2) Processing the .debug_aranges section to find the compilation unit which covers offset_in_library.\n+  \/\/ This is specified in section 6.1.2 of the DWARF 4 spec.\n+  \/\/\n+  \/\/ Structure of .debug_aranges:\n+  \/\/   Section Header\n+  \/\/   % Table of variable length sets describing the address space covered by a compilation unit\n+  \/\/     % Set 1\n+  \/\/     ...\n+  \/\/     % Set i:\n+  \/\/       % Set header\n+  \/\/         ...\n+  \/\/         debug_info_offset -> offset to compilation unit\n+  \/\/       % Series of address range descriptors [beginning_address, range_length]:\n+  \/\/         % Descriptor 1\n+  \/\/         ...\n+  \/\/         % Descriptor j:\n+  \/\/           beginning_address <= offset_in_library < beginning_address + range_length?\n+  \/\/           => Found the correct set covering offset_in_library. Take debug_info_offset from the set header to get\n+  \/\/              to the correct compilation unit in .debug_info.\n+  class DebugAranges {\n+\n+    \/\/ The header is defined in section 6.1.2 of the DWARF 4 spec.\n+    struct DebugArangesSetHeader {\n+      \/\/ The total length of all of the entries for that set, not including the length field itself.\n+      uint32_t _unit_length;\n+\n+      \/\/ This number is specific to the address lookup table and is independent of the DWARF version number.\n+      uint16_t _version;\n+\n+      \/\/ The offset from the beginning of the .debug_info or .debug_types section of the compilation unit header referenced\n+      \/\/ by the set. In this parser we only use it as offset into .debug_info. This must be 4 bytes for 32-bit DWARF.\n+      uint32_t _debug_info_offset;\n+\n+      \/\/ The size of an address in bytes on the target architecture, 4 bytes for 32-bit and 8 bytes for 64-bit Linux builds.\n+      uint8_t _address_size;\n+\n+      \/\/ The size of a segment selector in bytes on the target architecture. This should be 0.\n+      uint8_t _segment_size;\n+    };\n+\n+    \/\/ Address descriptor defining a range that is covered by a compilation unit. It is defined in section 6.1.2 after\n+    \/\/ the set header in the DWARF 4 spec.\n+    struct AddressDescriptor {\n+      uintptr_t beginning_address = 0;\n+      uintptr_t range_length = 0;\n+    };\n+\n+    DwarfFile* _dwarf_file;\n+    MarkedDwarfFileReader _reader;\n+    uint32_t _section_start_address;\n+\n+    bool read_section_header();\n+    bool read_set_header(DebugArangesSetHeader& header);\n+    bool read_address_descriptors(const DwarfFile::DebugAranges::DebugArangesSetHeader& header,\n+                                  uint32_t offset_in_library, bool& found_matching_set);\n+    bool read_address_descriptor(AddressDescriptor& descriptor);\n+    static bool does_match_offset(uint32_t offset_in_library, const AddressDescriptor& descriptor) ;\n+    static bool is_terminating_entry(const AddressDescriptor& descriptor);\n+   public:\n+    DebugAranges(DwarfFile* dwarf_file) : _dwarf_file(dwarf_file), _reader(dwarf_file->fd()), _section_start_address(0) {}\n+    bool find_compilation_unit_offset(uint32_t offset_in_library, uint32_t* compilation_unit_offset);\n+\n+  };\n+\n+  \/\/ (3a-c,e) The compilation unit is read from the .debug_info section. The structure of .debug_info is shown in the\n+  \/\/ comments of class DebugAbbrev.\n+  class CompilationUnit {\n+\n+    \/\/ Attribute form encodings from Figure 21 in section 7.5 of the DWARF 4 spec.\n+    static constexpr uint8_t DW_FORM_addr = 0x01; \/\/ address\n+    static constexpr uint8_t DW_FORM_block2 = 0x03; \/\/ block\n+    static constexpr uint8_t DW_FORM_block4 = 0x04; \/\/ block\n+    static constexpr uint8_t DW_FORM_data2 = 0x05; \/\/ constant\n+    static constexpr uint8_t DW_FORM_data4 = 0x06; \/\/ constant\n+    static constexpr uint8_t DW_FORM_data8 = 0x07; \/\/ constant\n+    static constexpr uint8_t DW_FORM_string = 0x08; \/\/ string\n+    static constexpr uint8_t DW_FORM_block = 0x09; \/\/ block\n+    static constexpr uint8_t DW_FORM_block1 = 0x0a; \/\/ block\n+    static constexpr uint8_t DW_FORM_data1 = 0x0b; \/\/ constant\n+    static constexpr uint8_t DW_FORM_flag = 0x0c; \/\/ flag\n+    static constexpr uint8_t DW_FORM_sdata = 0x0d; \/\/ constant\n+    static constexpr uint8_t DW_FORM_strp = 0x0e; \/\/ string\n+    static constexpr uint8_t DW_FORM_udata = 0x0f; \/\/ constant\n+    static constexpr uint8_t DW_FORM_ref_addr = 0x10; \/\/ reference0;\n+    static constexpr uint8_t DW_FORM_ref1 = 0x11; \/\/ reference\n+    static constexpr uint8_t DW_FORM_ref2 = 0x12; \/\/ reference\n+    static constexpr uint8_t DW_FORM_ref4 = 0x13; \/\/ reference\n+    static constexpr uint8_t DW_FORM_ref8 = 0x14; \/\/ reference\n+    static constexpr uint8_t DW_FORM_ref_udata = 0x15; \/\/ reference\n+    static constexpr uint8_t DW_FORM_indirect = 0x16; \/\/ see Section 7.5.3\n+    static constexpr uint8_t DW_FORM_sec_offset = 0x17; \/\/ lineptr, loclistptr, macptr, rangelistptr\n+    static constexpr uint8_t DW_FORM_exprloc = 0x18;\/\/ exprloc\n+    static constexpr uint8_t DW_FORM_flag_present = 0x19; \/\/ flag\n+    static constexpr uint8_t DW_FORM_ref_sig8 = 0x20; \/\/ reference\n+\n+    \/\/ The header is defined in section 7.5.1.1 of the DWARF 4 spec.\n+    struct CompilationUnitHeader {\n+      \/\/ The length of the .debug_info contribution for that compilation unit, not including the length field itself.\n+      uint32_t _unit_length;\n+\n+      \/\/ The version of the DWARF information for the compilation unit. The value in this field is 4 for DWARF 4.\n+      uint16_t _version;\n+\n+      \/\/ The offset into the .debug_abbrev section. This offset associates the compilation unit with a particular set of\n+      \/\/ debugging information entry abbreviations.\n+      uint32_t _debug_abbrev_offset;\n+\n+      \/\/ The size in bytes of an address on the target architecture, 4 bytes for 32-bit and 8 bytes for 64-bit Linux builds.\n+      uint8_t  _address_size;\n+    };\n+\n+    DwarfFile* _dwarf_file;\n+    MarkedDwarfFileReader _reader;\n+    CompilationUnitHeader _header;\n+    const uint32_t _compilation_unit_offset;\n+\n+    \/\/ Result of a request initiated by find_debug_line_offset().\n+    uint32_t _debug_line_offset;\n+\n+    bool read_header();\n+   public:\n+    CompilationUnit(DwarfFile* dwarf_file, uint32_t compilation_unit_offset)\n+      : _dwarf_file(dwarf_file), _reader(dwarf_file->fd()), _compilation_unit_offset(compilation_unit_offset), _debug_line_offset(0) {}\n+\n+    bool find_debug_line_offset(uint32_t* debug_line_offset);\n+    bool read_attribute_value(uint64_t attribute_form, bool is_DW_AT_stmt_list_attribute);\n+  };\n+\n+  \/\/ (3d) Read from the .debug_abbrev section at the debug_abbrev_offset specified by the compilation unit header.\n+  \/\/\n+  \/\/ The interplay between the .debug_info and .debug_abbrev sections is more complex. The following visualization of the structure\n+  \/\/ of both sections support the comments found in the parsing steps of the CompilationUnit and DebugAbbrev class.\n+  \/\/\n+  \/\/ Structure of .debug_abbrev:\n+  \/\/   Section Header\n+  \/\/   % Series of abbreviation tables\n+  \/\/     % Abbreviation table 1\n+  \/\/     ...\n+  \/\/     % Abbreviation table for compilation unit at debug_abbrev_offset:\n+  \/\/       % Series of declarations:\n+  \/\/         % Declaration 1:\n+  \/\/           abbreviation code\n+  \/\/           tag\n+  \/\/           DW_CHILDREN_yes\/no\n+  \/\/           % Series of attribute specifications\n+  \/\/             % Attribute specification 1:\n+  \/\/             attribute name\n+  \/\/             attribute form\n+  \/\/             ...\n+  \/\/             % Last attribute specification:\n+  \/\/             0\n+  \/\/             0\n+  \/\/         ...\n+  \/\/         % Declaration i:\n+  \/\/           Abbrev code read from compilation unit [AC]\n+  \/\/           DW_TAG_compile_unit\n+  \/\/           DW_CHILDREN_yes\n+  \/\/           % Series of attribute specifications\n+  \/\/             % Attribute specification 1 [AS1]\n+  \/\/             ...\n+  \/\/             % Attribute specification j [ASj]:\n+  \/\/             DW_AT_stmt_list\n+  \/\/             DW_FORM_sec_offset\n+  \/\/\n+  \/\/\n+  \/\/ Structure of .debug_info:\n+  \/\/   Section Header\n+  \/\/   % Series of compilation units\n+  \/\/     % Compilation unit 1\n+  \/\/     ...\n+  \/\/     % Compilation unit i for library offset fetched from .debug_aranges:\n+  \/\/       % Compilation unit header:\n+  \/\/         ...\n+  \/\/         debug_abbrev_offset -> offset for abbreviation table in .debug_abbrev for this compilation unit\n+  \/\/         ...\n+  \/\/       Abbrev code -> used in .debug_abbrev to find the correct declaration [AC]\n+  \/\/       % Series of attribute values\n+  \/\/         Attribute value 1 (in the format defined by attribute specification 1 [AS1])\n+  \/\/         ...\n+  \/\/         Attribute value j (in the format defined by attribute specification j [ASj]):\n+  \/\/         => Specifies Offset to line number program for this compilation unit in .debug_line\n+  class DebugAbbrev {\n+\n+    struct AbbreviationDeclaration {\n+      uint64_t _abbrev_code;\n+      uint64_t _tag;\n+      uint8_t _has_children;\n+    };\n+\n+    struct AttributeSpecification {\n+      uint64_t _name;\n+      uint64_t _form;\n+    };\n+\n+    \/\/ Tag encoding from Figure 18 in section 7.5 of the DWARF 4 spec.\n+    static constexpr uint8_t DW_TAG_compile_unit = 0x11;\n+\n+    \/\/ Child determination encoding from Figure 19 in section 7.5 of the DWARF 4 spec.\n+    static constexpr uint8_t DW_CHILDREN_yes = 0x01;\n+\n+    \/\/ Attribute encoding from Figure 20 in section 7.5 of the DWARF 4 spec.\n+    static constexpr uint8_t DW_AT_stmt_list = 0x10;\n+\n+    \/* There is no specific header for this section *\/\n+\n+    DwarfFile* _dwarf_file;\n+    MarkedDwarfFileReader _reader;\n+    CompilationUnit* _compilation_unit; \/\/ Need to read from compilation unit while parsing the entries in .debug_abbrev.\n+\n+    \/\/ Result field of a request\n+    uint32_t* _debug_line_offset;\n+\n+    bool read_declaration(AbbreviationDeclaration& declaration);\n+    static bool is_wrong_or_unsupported_format(const AbbreviationDeclaration& declaration);\n+    bool read_attribute_specifications(bool is_DW_TAG_compile_unit);\n+    bool read_attribute_specification(AttributeSpecification& specification);\n+    static bool is_terminating_specification(const AttributeSpecification& attribute_specification) ;\n+\n+   public:\n+    DebugAbbrev(DwarfFile* dwarf_file, CompilationUnit* compilation_unit) :\n+      _dwarf_file(dwarf_file), _reader(_dwarf_file->fd()), _compilation_unit(compilation_unit),\n+      _debug_line_offset(nullptr) {}\n+\n+    bool read_section_header(uint32_t debug_abbrev_offset);\n+    bool find_debug_line_offset(uint64_t abbrev_code);\n+  };\n+\n+  \/\/ (4) The line number program for the compilation unit at the offset of the .debug_line obtained by (3).\n+  \/\/ For some reason, earlier GCC versions emit the line number program in DWARF 2 or 3 format even though the\n+  \/\/ default is DWARF 4. It also mixes the standards (see comments in the parsing code).\n+  \/\/\n+  \/\/ Therefore, this class supports DWARF 2, 3 and 4 parsing as specified in section 6.2 of the DWARF specs.\n+  \/\/ The parsing of DWARF 2 is already covered by the parsing of DWARF 3 as they use the shared opcodes in the same way.\n+  \/\/ The parsing of DWARF 4, however, needs some adaptation as it consumes more data for some shared opcodes.\n+  \/\/\n+  \/\/ DWARF 2 standard: https:\/\/dwarfstd.org\/doc\/dwarf-2.0.0.pdf\n+  \/\/ DWARF 3 standard: https:\/\/dwarfstd.org\/doc\/Dwarf3.pdf\n+  \/\/\n+  \/\/\n+  \/\/ Structure of .debug_ling:\n+  \/\/   Section Header\n+  \/\/   % Series of line number program entries for each compilation unit\n+  \/\/     % Line number program 1\n+  \/\/     ...\n+  \/\/     % Line number program i for our compilation unit:\n+  \/\/       % Line program header unit header:\n+  \/\/         ...\n+  \/\/         version -> currently emits version 3 by default\n+  \/\/         ...\n+  \/\/         file_name -> sequence of file names\n+  \/\/       % Sequence of opcodes as part of the line number program to build the line number information matrix:\n+  \/\/          % Format of matrix: [offset, line, directory_index, file_index]\n+  \/\/          % Line 1\n+  \/\/          ...\n+  \/\/          % Line j:\n+  \/\/            [offset matching offset_in_library, line, directory_index, file_index]\n+  \/\/            => Get line number + look up file_index in file_name list (pick file_index'th string)\n+  class LineNumberProgram {\n+\n+    \/\/ Standard opcodes for the line number program defined in section 6.2.5.2 of the DWARF 4 spec.\n+    static constexpr uint8_t DW_LNS_copy = 1;\n+    static constexpr uint8_t DW_LNS_advance_pc = 2;\n+    static constexpr uint8_t DW_LNS_advance_line = 3;\n+    static constexpr uint8_t DW_LNS_set_file = 4;\n+    static constexpr uint8_t DW_LNS_set_column = 5;\n+    static constexpr uint8_t DW_LNS_negate_stmt = 6;\n+    static constexpr uint8_t DW_LNS_set_basic_block = 7;\n+    static constexpr uint8_t DW_LNS_const_add_pc = 8;\n+    static constexpr uint8_t DW_LNS_fixed_advance_pc = 9;\n+    static constexpr uint8_t DW_LNS_set_prologue_end = 10; \/\/ Introduced with DWARF 3\n+    static constexpr uint8_t DW_LNS_set_epilogue_begin = 11; \/\/ Introduced with DWARF 3\n+    static constexpr uint8_t DW_LNS_set_isa = 12; \/\/ Introduced with DWARF 3\n+\n+    \/\/ Extended opcodes for the line number program defined in section 6.2.5.2 of the DWARF 4 spec.\n+    static constexpr uint8_t DW_LNE_end_sequence = 1;\n+    static constexpr uint8_t DW_LNE_set_address = 2;\n+    static constexpr uint8_t DW_LNE_define_file = 3;\n+    static constexpr uint8_t DW_LNE_set_discriminator = 4; \/\/ Introduced with DWARF 4\n+\n+    \/\/ The header is defined in section 6.2.4 of the DWARF 4 spec.\n+    struct LineNumberProgramHeader {\n+      \/\/ The size in bytes of the line number information for this compilation unit, not including the unit_length\n+      \/\/ field itself. 32-bit DWARF uses 4 bytes.\n+      uint32_t _unit_length;\n+\n+      \/\/ The version of the DWARF information for the line number program unit. The value in this field should be 4 for\n+      \/\/ DWARF 4 and version 3 as used for DWARF 3.\n+      uint16_t _version;\n+\n+      \/\/ The number of bytes following the header_length field to the beginning of the first byte of the line number\n+      \/\/ program itself. 32-bit DWARF uses 4 bytes.\n+      uint32_t _header_length;\n+\n+      \/\/ The size in bytes of the smallest target machine instruction. Line number program opcodes that alter the address\n+      \/\/ and op_index registers use this and maximum_operations_per_instruction in their calculations.\n+      uint8_t _minimum_instruction_length;\n+\n+      \/\/ The maximum number of individual operations that may be encoded in an instruction. Line number program opcodes\n+      \/\/ that alter the address and op_index registers use this and minimum_instruction_length in their calculations.\n+      \/\/ For non-VLIW architectures, this field is 1, the op_index register is always 0, and the operation pointer is\n+      \/\/ simply the address register. This is only used with DWARF 4.\n+      uint8_t _maximum_operations_per_instruction;\n+\n+      \/\/ The initial value of the is_stmt register.\n+      uint8_t _default_is_stmt;\n+\n+      \/\/ This parameter affects the meaning of the special opcodes.\n+      int8_t _line_base;\n+\n+      \/\/ This parameter affects the meaning of the special opcodes.\n+      uint8_t _line_range;\n+\n+      \/\/ The number assigned to the first special opcode.\n+      uint8_t _opcode_base;\n+\n+      \/\/ This array specifies the number of LEB128 operands for each of the standard opcodes. The first element of the\n+      \/\/ array corresponds to the opcode whose value is 1, and the last element corresponds to the opcode whose value is\n+      \/\/ opcode_base-1. DWARF 2 uses 9 standard opcodes while DWARF 3 and 4 use 12.\n+      uint8_t _standard_opcode_lengths[12];\n+\n+      \/*\n+       * The following fields are not part of the real header and are only used for the implementation.\n+       *\/\n+      \/\/ Offset where the filename strings are starting in header.\n+      long _file_names_offset;\n+\n+      \/\/ _header_length only specifies the number of bytes following the _header_length field. It does not include\n+      \/\/ the size of _unit_length, _version and _header_length itself. This constant represents the number of missing\n+      \/\/ bytes to get the real size of the header:\n+      \/\/ sizeof(_unit_length) + sizeof(_version) + sizeof(_header_length) = 4 + 2 + 4 = 10\n+      static constexpr uint8_t HEADER_DESCRIPTION_BYTES = 10;\n+    };\n+\n+    \/\/ The line number program state consists of several registers that hold the current state of the line number program\n+    \/\/ state machine. The state\/different state registers are defined in section 6.2.2 of the DWARF 4 spec. Most of these\n+    \/\/ fields (state registers) are not used to get the filename and the line number information.\n+    struct LineNumberProgramState : public CHeapObj<mtInternal> {\n+      \/\/ The program-counter value corresponding to a machine instruction generated by the compiler.\n+      \/\/ 4 bytes on 32-bit and 8 bytes on 64-bit.\n+      uintptr_t _address;\n+\n+      \/\/ The index of an operation within a VLIW instruction. The index of the first operation is 0. For non-VLIW\n+      \/\/ architectures, this register will always be 0.\n+      \/\/ The address and op_index registers, taken together, form an operation pointer that can reference any\n+      \/\/ individual operation with the instruction stream. This field was introduced with DWARF 4.\n+      uint32_t _op_index;\n+\n+      \/\/ The identity of the source file corresponding to a machine instruction.\n+      uint32_t _file;\n+\n+      \/\/ A source line number. Lines are numbered beginning at 1. The compiler may emit the value 0 in cases where an\n+      \/\/ instruction cannot be attributed to any source line.\n+      uint32_t _line;\n+\n+      \/\/ A column number within a source line. Columns are numbered beginning at 1. The value 0 is reserved to indicate\n+      \/\/ that a statement begins at the “left edge” of the line.\n+      uint32_t _column;\n+\n+      \/\/ Indicates that the current instruction is a recommended breakpoint location.\n+      bool _is_stmt;\n+\n+      \/\/ Indicates that the current instruction is the beginning of a basic block.\n+      bool _basic_block;\n+\n+      \/\/ Indicates that the current address is that of the first byte after the end of a sequence of target machine\n+      \/\/ instructions. end_sequence terminates a sequence of lines.\n+      bool _end_sequence;\n+\n+      \/\/ Indicates that the current address is one (of possibly many) where execution should be suspended for an entry\n+      \/\/ breakpoint of a function. This field was introduced with DWARF 3.\n+      bool _prologue_end;\n+\n+      \/\/ Indicates that the current address is one (of possibly many) where execution should be suspended for an exit\n+      \/\/ breakpoint of a function. This field was introduced with DWARF 3.\n+      bool _epilogue_begin;\n+\n+      \/\/ Encodes the applicable instruction set architecture for the current instruction.\n+      \/\/ This field was introduced with DWARF 3.\n+      uint32_t _isa;\n+\n+      \/\/ Identifies the block to which the current instruction belongs. This field was introduced with DWARF 4.\n+      uint32_t _discriminator;\n+\n+      \/*\n+       * Additional fields which are not part of the actual state as described in DWARF spec.\n+       *\/\n+      \/\/ Header fields\n+      \/\/ Specifies which DWARF version is used in the .debug_line section. Supported version: DWARF 2, 3, and 4.\n+      const uint16_t _dwarf_version;\n+      const bool _initial_is_stmt;\n+\n+      \/\/ Implementation specific fields\n+      bool _append_row;\n+      bool _do_reset;\n+      bool _first_entry_in_sequence;\n+      bool _can_sequence_match_offset;\n+      bool _found_match;\n+\n+      LineNumberProgramState(const LineNumberProgramHeader& header)\n+        : _is_stmt(header._default_is_stmt != 0), _dwarf_version(header._version),\n+        _initial_is_stmt(header._default_is_stmt != 0), _found_match(false) {\n+        reset_fields();\n+      }\n+\n+      void reset_fields();\n+      \/\/ Defined in section 6.2.5.1 of the DWARF spec 4. add_to_address_register() must always be executed before set_index_register.\n+      void add_to_address_register(uint32_t operation_advance, const LineNumberProgramHeader& header);\n+      void set_index_register(uint32_t operation_advance, const LineNumberProgramHeader& header);\n+    };\n+\n+    DwarfFile* _dwarf_file;\n+    MarkedDwarfFileReader _reader;\n+    LineNumberProgramHeader _header;\n+    LineNumberProgramState* _state;\n+    const uint32_t _offset_in_library;\n+    const uint64_t _debug_line_offset;\n+    bool _is_pc_after_call;\n+\n+    bool read_header();\n+    bool run_line_number_program(char* filename, size_t filename_len, int* line);\n+    bool apply_opcode();\n+    bool apply_extended_opcode();\n+    bool apply_standard_opcode(uint8_t opcode);\n+    void apply_special_opcode(const uint8_t opcode);\n+    bool does_offset_match_entry(uintptr_t previous_address, uint32_t previous_file, uint32_t previous_line);\n+    void print_and_store_prev_entry(uint32_t previous_file, uint32_t previous_line);\n+    bool get_filename_from_header(uint32_t file_index, char* filename, size_t filename_len);\n+\n+   public:\n+    LineNumberProgram(DwarfFile* dwarf_file, uint32_t offset_in_library, uint64_t debug_line_offset, bool is_pc_after_call)\n+      : _dwarf_file(dwarf_file), _reader(dwarf_file->fd()), _offset_in_library(offset_in_library),\n+        _debug_line_offset(debug_line_offset), _is_pc_after_call(is_pc_after_call) {}\n+\n+    bool find_filename_and_line_number(char* filename, size_t filename_len, int* line);\n+  };\n+\n+ public:\n+  DwarfFile(const char* filepath) : ElfFile(filepath) {}\n+\n+  \/*\n+   * Starting point of reading line number and filename information from the DWARF file.\n+   *\n+   * Given:  Offset into the ELF library file, a filename buffer of size filename_size, a line number pointer.\n+   * Return: True:  The filename is set in the 'filename' buffer and the line number at the address pointed to by 'line'.\n+   *         False: Something went wrong either while reading from the file or during parsing due to an unexpected format.\n+   *                This could happen if the DWARF file is in an unsupported or wrong format.\n+   *\n+   *  More details about the different phases can be found at the associated methods.\n+   *\/\n+  bool get_filename_and_line_number(uint32_t offset_in_library, char* filename, size_t filename_len, int* line, bool is_pc_after_call);\n+};\n+\n","filename":"src\/hotspot\/share\/utilities\/elfFile.hpp","additions":695,"deletions":21,"binary":false,"changes":716,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-      if (Decoder::get_source_info(pc, buf, sizeof(buf), &line_no)) {\n+      if (Decoder::get_source_info(pc, buf, sizeof(buf), &line_no, frame != 0)) {\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -187,2 +187,0 @@\n-    char separator = os::file_separator()[0];\n-    const char *p = strrchr(_filename, separator);\n@@ -191,1 +189,1 @@\n-                         p ? p + 1 : _filename, _lineno,\n+                         get_filename_only(), _lineno,\n@@ -380,1 +378,1 @@\n-        char buf[128];\n+        char filename[128];\n@@ -382,2 +380,5 @@\n-        if (Decoder::get_source_info(fr.pc(), buf, sizeof(buf), &line_no)) {\n-          st->print(\"  (%s:%d)\", buf, line_no);\n+        if (count == 1 && _lineno != 0) {\n+          \/\/ We have source information of the first frame for internal errors. There is no need to parse it from the symbols.\n+          st->print(\"  (%s:%d)\", get_filename_only(), _lineno);\n+        } else if (Decoder::get_source_info(fr.pc(), filename, sizeof(filename), &line_no, count != 1)) {\n+          st->print(\"  (%s:%d)\", filename, line_no);\n@@ -685,4 +686,2 @@\n-         \/\/ In product mode chop off pathname?\n-         char separator = os::file_separator()[0];\n-         const char *p = strrchr(_filename, separator);\n-         const char *file = p ? p+1 : _filename;\n+         \/\/ In product mode chop off pathname\n+         const char *file = get_filename_only();\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -106,0 +106,6 @@\n+  static const char* get_filename_only() {\n+    char separator = os::file_separator()[0];\n+    const char* p = strrchr(_filename, separator);\n+    return p ? p+1 : _filename;\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"utilities\/align.hpp\"\n@@ -35,0 +34,2 @@\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/decoder.hpp\"\n@@ -425,1 +426,53 @@\n-#endif\n+\/\/ Check that method JNI_CreateJavaVM is found.\n+TEST(os_linux, addr_to_function_valid) {\n+  char buf[128] = \"\";\n+  int offset = -1;\n+  address valid_function_pointer = (address)JNI_CreateJavaVM;\n+  ASSERT_TRUE(os::dll_address_to_function_name(valid_function_pointer, buf, sizeof(buf), &offset, true));\n+  ASSERT_TRUE(strstr(buf, \"JNI_CreateJavaVM\") != nullptr);\n+  ASSERT_TRUE(offset >= 0);\n+}\n+\n+#ifndef PRODUCT\n+\/\/ Test valid address of method JNI_CreateJavaVM in jni.cpp. We should get \"jni.cpp\" in the buffer and a valid line number.\n+TEST_VM(os_linux, decoder_get_source_info_valid) {\n+  char buf[128] = \"\";\n+  int line = -1;\n+  address valid_function_pointer = (address)JNI_CreateJavaVM;\n+  ASSERT_TRUE(Decoder::get_source_info(valid_function_pointer, buf, sizeof(buf), &line));\n+  ASSERT_TRUE(strcmp(buf, \"jni.cpp\") == 0);\n+  ASSERT_TRUE(line > 0);\n+}\n+\n+\/\/ Same test as \"decoder_get_source_info_valid\" but with a too-small output buffer. Everything should work the same except\n+\/\/ that the output buffer truncates \"jni.cpp\" such that we find \"jni.cp\" instead. The line number must be found as before.\n+TEST_VM(os_linux, decoder_get_source_info_valid_truncated) {\n+  char buf[128] = \"\";\n+  int line = -1;\n+  memset(buf, 'X', sizeof(buf));\n+  address valid_function_pointer = (address)JNI_CreateJavaVM;\n+  ASSERT_TRUE(Decoder::get_source_info(valid_function_pointer, buf, 7, &line));\n+  ASSERT_TRUE(buf[7 - 1] == '\\0');\n+  ASSERT_TRUE(buf[7] == 'X');\n+  ASSERT_TRUE(strcmp(buf, \"jni.cp\") == 0);\n+  ASSERT_TRUE(line > 0);\n+}\n+\n+\/\/ Test invalid addresses. Should not cause harm and output buffer and line must contain \"\" and -1, respectively.\n+TEST_VM(os_linux, decoder_get_source_info_invalid) {\n+  char buf[128] = \"\";\n+  int line = -1;\n+  address invalid_function_pointers[] = { nullptr, (address)1, (address)&line };\n+\n+  for (address addr : invalid_function_pointers) {\n+    strcpy(buf, \"somestring\");\n+    line = 12;\n+    \/\/ We should return false but do not crash or fail in any way.\n+    ASSERT_FALSE(Decoder::get_source_info(addr, buf, sizeof(buf), &line));\n+    \/\/ buffer should contain \"\", offset should contain -1\n+    ASSERT_TRUE(buf[0] == '\\0');\n+    ASSERT_TRUE(line == -1);\n+  }\n+}\n+#endif \/\/ NOT PRODUCT\n+#endif \/\/ LINUX\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux.cpp","additions":55,"deletions":2,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -0,0 +1,274 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8242181\n+ * @library \/ \/test\/lib\n+ * @summary Test DWARF parser with various crashes if debug symbols are available. If the libjvm debug symbols are not\n+ *          in the same directory as the libjvm.so file, in a subdirectory called .debug, or in the path specified\n+ *          by the environment variable _JVM_DWARF_PATH, then no verification of the hs_err_file is done for libjvm.so.\n+ * @requires vm.debug == true & vm.flagless & vm.compMode != \"Xint\" & os.family == \"linux\" & !vm.graal.enabled & vm.gc.G1\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/native\/othervm -Xbootclasspath\/a:. -XX:-CreateCoredumpOnCrash TestDwarf\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import sun.misc.Unsafe;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class TestDwarf {\n+    static {\n+        System.loadLibrary(\"TestDwarf\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 0) {\n+            switch (args[0]) {\n+                case \"unsafeAccess\" -> {\n+                    crashUnsafeAccess();\n+                    Asserts.fail(\"Should crash in crashUnsafeAccess()\");\n+                }\n+                case \"outOfMemory\" -> {\n+                    crashOutOfMemory();\n+                    Asserts.fail(\"Should crash in crashOutOfMemory()\");\n+                }\n+                case \"abortVMOnException\" -> {\n+                    crashAbortVmOnException();\n+                    Asserts.fail(\"Should crash in crashAbortVmOnException()\");\n+                }\n+                case \"nativeDivByZero\" -> {\n+                    crashNativeDivByZero();\n+                    Asserts.fail(\"Should crash in crashNativeDivByZero()\");\n+                }\n+                case \"nativeMultipleMethods\" -> {\n+                    crashNativeMultipleMethods(1);\n+                    crashNativeMultipleMethods(2);\n+                    crashNativeMultipleMethods(3);\n+                    Asserts.fail(\"Should crash in crashNativeMultipleMethods()\");\n+                    crashNativeMultipleMethods(4);\n+                }\n+                case \"nativeDereferenceNull\" -> {\n+                    crashNativeDereferenceNull();\n+                    Asserts.fail(\"Should crash in crashNativeDereferenceNull()\");\n+                }\n+            }\n+        } else {\n+            try {\n+                test();\n+            } catch (UnsupportedDwarfVersionException e) {\n+                System.out.println(\"Skip test due to a DWARF section that is in an unsupported version by the parser.\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Crash the VM in different ways in order to verify that DWARF parsing is able to print the source information\n+    \/\/ in the hs_err_files for each VM and C stack frame.\n+    private static void test() throws Exception {\n+        runAndCheck(new Flags(\"-Xcomp\", \"-XX:CICrashAt=1\", \"--version\"));\n+        runAndCheck(new Flags(\"-Xmx100M\", \"-XX:ErrorHandlerTest=15\", \"-XX:TestCrashInErrorHandler=14\", \"--version\"));\n+        runAndCheck(new Flags(\"-XX:+CrashGCForDumpingJavaThread\", \"--version\"));\n+        runAndCheck(new Flags(\"-Xmx10m\", \"-XX:+CrashOnOutOfMemoryError\", TestDwarf.class.getCanonicalName(), \"outOfMemory\"));\n+        \/\/ Use -XX:-TieredCompilation as C1 is currently not aborting the VM (JDK-8264899).\n+        runAndCheck(new Flags(TestDwarf.class.getCanonicalName(), \"unsafeAccess\"));\n+        runAndCheck(new Flags(\"-XX:-TieredCompilation\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:AbortVMOnException=MyException\",\n+                              TestDwarf.class.getCanonicalName(), \"abortVMOnException\"));\n+        if (Platform.isX64() || Platform.isX86()) {\n+            \/\/ Not all platforms raise SIGFPE but x86_32 and x86_64 do.\n+            runAndCheck(new Flags(TestDwarf.class.getCanonicalName(), \"nativeDivByZero\"),\n+                        new DwarfConstraint(0, \"Java_TestDwarf_crashNativeDivByZero\", \"libTestDwarf.c\", 59));\n+            runAndCheck(new Flags(TestDwarf.class.getCanonicalName(), \"nativeMultipleMethods\"),\n+                        new DwarfConstraint(0, \"foo\", \"libTestDwarf.c\", 42),\n+                        new DwarfConstraint(1, \"Java_TestDwarf_crashNativeMultipleMethods\", \"libTestDwarf.c\", 70));\n+        }\n+        runAndCheck(new Flags(TestDwarf.class.getCanonicalName(), \"nativeDereferenceNull\"),\n+                    new DwarfConstraint(0, \"dereference_null\", \"libTestDwarfHelper.h\", 44));\n+    }\n+\n+    private static void runAndCheck(Flags flags, DwarfConstraint... constraints) throws Exception {\n+        OutputAnalyzer crashOut;\n+        crashOut = ProcessTools.executeProcess(ProcessTools.createTestJvm(flags.getFlags()));\n+        String crashOutputString = crashOut.getOutput();\n+        Asserts.assertNotEquals(crashOut.getExitValue(), 0, \"Crash JVM should not exit gracefully\");\n+        Pattern pattern = Pattern.compile(\"hs_err_pid[0-9]*.log\");\n+        Matcher matcher = pattern.matcher(crashOutputString);\n+        System.out.println(crashOutputString);\n+        if (matcher.find()) {\n+            String hsErrFileName = matcher.group();\n+            System.out.println(\"hs_err_file: \" + hsErrFileName);\n+            File hs_err_file = new File(hsErrFileName);\n+            BufferedReader reader = new BufferedReader(new FileReader(hs_err_file));\n+            String line;\n+            boolean foundNativeFrames = false;\n+            int matches = 0;\n+            int frameIdx = 0;\n+            \/\/ Check all stack entries after the line starting with \"Native frames\" in the hs_err_file until an empty line\n+            \/\/ is found which denotes the end of the stack frames.\n+            while ((line = reader.readLine()) != null) {\n+                if (foundNativeFrames) {\n+                    if (line.isEmpty()) {\n+                        \/\/ Done with the entire stack.\n+                        break;\n+                    } else if ((line.startsWith(\"C\") || line.startsWith(\"V\"))) {\n+                        \/\/ Could be VM or native C frame. There are usually no symbols available for libpthread.so.\n+                        matches++;\n+                        \/\/ File and library names are non-empty and may contain English letters, underscores, dots or numbers ([a-zA-Z0-9_.]+).\n+                        \/\/ Line numbers have at least one digit and start with non-zero ([1-9][0-9]*).\n+                        pattern = Pattern.compile(\"[CV][\\\\s\\\\t]+\\\\[([a-zA-Z0-9_.]+)\\\\+0x.+][\\\\s\\\\t]+.*\\\\+0x.+[\\\\s\\\\t]+\\\\([a-zA-Z0-9_.]+\\\\.[a-z]+:[1-9][0-9]*\\\\)\");\n+                        matcher = pattern.matcher(line);\n+                        if (!matcher.find()) {\n+                            checkNoSourceLine(crashOutputString, line);\n+                        }\n+\n+                        \/\/ Check additional DWARF constraints\n+                        if (constraints != null) {\n+                            int finalFrameIdx = frameIdx;\n+                            String finalLine = line;\n+                            Arrays.stream(constraints).forEach(c -> c.checkConstraint(finalFrameIdx, finalLine));\n+                        }\n+                    }\n+                    frameIdx++;\n+                } else if (line.startsWith(\"Native frames\")) {\n+                    \/\/ Stack starts after this line.\n+                    foundNativeFrames = true;\n+                }\n+            }\n+            Asserts.assertGreaterThan(matches, 0, \"Could not find any stack frames\");\n+        } else {\n+            throw new RuntimeException(\"Could not find an hs_err_file\");\n+        }\n+    }\n+\n+    \/**\n+     * There are some valid cases where we cannot find source information. Check these.\n+     *\/\n+    private static void checkNoSourceLine(String crashOutputString, String line) {\n+        Pattern pattern = Pattern.compile(\"[CV][\\\\s\\\\t]+\\\\[([a-zA-Z0-9_.]+)\\\\+0x.+][\\\\s\\\\t]+.*\\\\+0x\");\n+        Matcher matcher = pattern.matcher(line);\n+        Asserts.assertTrue(matcher.find(), \"Must find library in \\\"\" + line + \"\\\"\");\n+        \/\/ Check if there are symbols available for library. If not, then we cannot find any source information for this library.\n+        \/\/ This can happen if this test is run without any JDK debug symbols at all but also for some libraries like libpthread.so\n+        \/\/ which usually has no symbols available.\n+        String library = matcher.group(1);\n+        pattern = Pattern.compile(\"Failed to load DWARF file for library.*\" + library + \".*or find DWARF sections directly inside it\");\n+        matcher = pattern.matcher(crashOutputString);\n+        if (!matcher.find()) {\n+            bailoutIfUnsupportedDwarfVersion(crashOutputString);\n+            Asserts.fail(\"Could not find filename or line number in \\\"\" + line + \"\\\"\");\n+        }\n+        \/\/ We should always find symbols for libTestDwarf.so.\n+        Asserts.assertFalse(library.equals(\"libTestDwarf.so\"), \"Could not find filename or line number in \\\"\" + line + \"\\\" for libTestDwarf.so\");\n+        System.out.println(\"Did not find symbols for \" + library + \". If they are not in the same directory as \" + library + \" consider setting \" +\n+                           \"the environmental variable _JVM_DWARF_PATH to point to the debug symbols directory.\");\n+    }\n+\n+    \/**\n+     * Some older GCC versions might emit DWARF sections in an old format that is not supported by the DWARF parser.\n+     * If this is the case, skip this entire test by throwing UnsupportedDwarfVersionException.\n+     *\/\n+    private static void bailoutIfUnsupportedDwarfVersion(String crashOutputString) {\n+        Pattern pattern = Pattern.compile(\".debug_\\\\S+ in unsupported DWARF version \\\\d+\");\n+        Matcher matcher = pattern.matcher(crashOutputString);\n+        if (matcher.find()) {\n+            throw new UnsupportedDwarfVersionException();\n+        }\n+    }\n+\n+    \/\/ Crash with SIGSEGV.\n+    private static void crashUnsafeAccess() throws Exception {\n+        Field f = Unsafe.class.getDeclaredField(\"theUnsafe\");\n+        f.setAccessible(true);\n+        Unsafe unsafe = (Unsafe)f.get(null);\n+        unsafe.putAddress(0, 0); \/\/ Crash\n+    }\n+\n+    \/\/ Crash with Internal Error: Java heap space.\n+    private static void crashOutOfMemory() {\n+        Object[] o = null;\n+\n+        \/\/ Loop endlessly and consume memory until we run out. Will crash due to -XX:+CrashOnOutOfMemoryError.\n+        while (true) {\n+            o = new Object[] {o};\n+        }\n+    }\n+\n+    \/\/ Crash with Internal Error: Saw java.lang.RuntimeException, aborting.\n+    \/\/ Crash happens due to an exception raised in combination with -XX:AbortVMOnException.\n+    private static void crashAbortVmOnException() {\n+        throw new MyException();\n+    }\n+\n+    private static native void crashNativeDivByZero();\n+    private static native void crashNativeDereferenceNull();\n+    private static native void crashNativeMultipleMethods(int x);\n+}\n+\n+class UnsupportedDwarfVersionException extends RuntimeException { }\n+\n+class MyException extends RuntimeException { }\n+\n+class Flags {\n+    private final List<String> listOfOptions = new ArrayList<>();\n+\n+    Flags(String... flags) {\n+        listOfOptions.add(\"-XX:TraceDwarfLevel=2\"); \/\/ Always add debug flag\n+        listOfOptions.add(\"-XX:-CreateCoredumpOnCrash\"); \/\/ Never create dumps\n+        listOfOptions.addAll(Arrays.asList(flags));\n+    }\n+\n+    public List<String> getFlags() {\n+        return listOfOptions;\n+    }\n+\n+}\n+class DwarfConstraint {\n+    private final int frameIdx;\n+    private final String methodName;\n+    private final String dwarfInfo;\n+\n+    DwarfConstraint(int frameIdx, String methodName, String fileName, int lineNo) {\n+        this.frameIdx = frameIdx;\n+        this.methodName = methodName;\n+        this.dwarfInfo = \"(\" + fileName + \":\" + lineNo + \")\";\n+    }\n+\n+    public void checkConstraint(int currentFrameIdx, String line) {\n+        if (frameIdx == currentFrameIdx) {\n+            Asserts.assertTrue(line.contains(methodName), \"Could not find method name \" + methodName + \" in \\\"\" + line + \"\\\"\");\n+            Asserts.assertTrue(line.contains(dwarfInfo) , \"Could not find DWARF info \" + dwarfInfo + \" in \\\"\" + line + \"\\\"\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/TestDwarf.java","additions":274,"deletions":0,"binary":false,"changes":274,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include \"jni.h\"\n+#include \"libTestDwarfHelper.h\"\n+#include <stdio.h>\n+\n+int zero = 0;\n+int result = 0;\n+int limit = 20;\n+\n+\/\/ Just big enough by doing some random things such that it is not inlined.\n+void foo(int x) {\n+    printf(\"foo3:\");\n+    printf(\" %d\\n\", x);\n+    for (int i = 0; i < limit; i++) {\n+        result += zero + i;\n+    }\n+    if (x == 3) {\n+        for (int i = 0; i < limit; i++) {\n+            result -= zero + i;\n+        }\n+        result = 3 \/ zero; \/\/ Crash\n+    } else {\n+        for (int i = 0; i < limit; i++) {\n+            result -= zero + i;\n+        }\n+        result = 3 \/ 2; \/\/ No crash\n+    }\n+\n+    for (int i = 0; i < limit; i++) {\n+        for (int j = zero; j < limit; j++) {\n+            result += zero - i;\n+        }\n+    }\n+}\n+\n+JNIEXPORT void JNICALL Java_TestDwarf_crashNativeDivByZero(JNIEnv* env, jclass jclazz) {\n+  limit = 21;\n+  foo(34 \/ zero); \/\/ Crash\n+}\n+\n+JNIEXPORT void JNICALL Java_TestDwarf_crashNativeDereferenceNull(JNIEnv* env, jclass jclazz) {\n+  dereference_null();\n+}\n+\n+JNIEXPORT void JNICALL Java_TestDwarf_crashNativeMultipleMethods(JNIEnv* env, jclass jclazz, jint x) {\n+  \/\/ foo() is not inlined\n+  foo(x - 2);\n+  foo(x - 1);\n+  foo(x);\n+  for (int i = 0; i < limit; i++) {\n+    result += zero + i;\n+  }\n+  for (int i = 0; i < limit; i++) {\n+    result += zero + i;\n+  }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/libTestDwarf.c","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include <stdio.h>\n+\n+void unused1() {\n+}\n+\n+void unused2() {\n+}\n+\n+void unused3() {\n+}\n+\n+void unused4() {\n+}\n+\n+void unused5() {\n+}\n+\n+void dereference_null() {\n+  int* x = (int*)0;\n+  *x = 34; \/\/ Crash\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/libTestDwarfHelper.h","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"}]}