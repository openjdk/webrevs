{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @modules java.base\/java.util.zip:open java.base\/jdk.internal.vm.annotation\n@@ -29,0 +28,7 @@\n+ * @modules java.base\/java.util.zip:open java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib\n+ * @comment The test relies on the Cleaner to invoke the cleaning actions. So\n+ *          we use \"othervm\" to prevent any Cleaner delays that could be contributed by any\n+ *          other tests or code that might have executed on the agentvm prior to this test\n+ *          execution\n+ * @run main\/othervm TestCleaner\n@@ -34,0 +40,1 @@\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -36,0 +43,1 @@\n+import jdk.test.lib.util.ForceGC;\n@@ -62,1 +70,1 @@\n-            throw new RuntimeException(\"'zsRef' is not accesible\");\n+            throw new RuntimeException(\"'zsRef' is not accessible\");\n@@ -66,1 +74,1 @@\n-            throw new RuntimeException(\"'addr' is not accesible\");\n+            throw new RuntimeException(\"'addr' is not accessible\");\n@@ -87,6 +95,10 @@\n-        int n = 10;\n-        long cnt = list.size();\n-        while (n-- > 0 && cnt != 0) {\n-            Thread.sleep(100);\n-            System.gc();\n-            cnt = list.stream().filter(o -> addrOf(o) != 0).count();\n+        final AtomicLong numNotYetCleaned = new AtomicLong();\n+        \/\/ trigger GC\n+        final boolean resourcesCleaned = ForceGC.wait(() -> {\n+            final long remaining = list.stream().filter(o -> addrOf(o) != 0).count();\n+            numNotYetCleaned.set(remaining);\n+            return remaining == 0;\n+        });\n+        if (!resourcesCleaned) {\n+            throw new RuntimeException(numNotYetCleaned.get()\n+                    + \" resources haven't yet been cleaned\");\n@@ -94,3 +106,0 @@\n-        if (cnt != 0)\n-            throw new RuntimeException(\"cleaner failed to clean : \" + cnt);\n-\n@@ -142,8 +151,1 @@\n-                throw new RuntimeException(\"'ZipFile.Source.zfile' is not accesible\");\n-            }\n-            \/\/System.out.println(\"zffile: \" +  zfileField.get(zsrc));\n-            int n = 10;\n-            while (n-- > 0 && zfileField.get(zsrc) != null) {\n-                System.out.println(\"waiting gc ... \" + n);\n-                System.gc();\n-                Thread.sleep(100);\n+                throw new RuntimeException(\"'ZipFile.Source.zfile' is not accessible\");\n@@ -151,2 +153,10 @@\n-            if (zfileField.get(zsrc) != null) {\n-                throw new RuntimeException(\"cleaner failed to clean zipfile.\");\n+            final boolean resourceCleaned = ForceGC.wait(() -> {\n+                try {\n+                    return zfileField.get(zsrc) == null;\n+                } catch (IllegalAccessException e) {\n+                    \/\/ shouldn't happen\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            if (!resourceCleaned) {\n+                throw new RuntimeException(\"cleaner failed to clean zipfile \" + zip);\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/TestCleaner.java","additions":33,"deletions":23,"binary":false,"changes":56,"status":"modified"}]}