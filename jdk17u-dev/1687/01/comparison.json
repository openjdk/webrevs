{"files":[{"patch":"@@ -50,1 +50,1 @@\n-\/\/ stubbed-out trim-native support\n+\/\/ Trim-native support, stubbed out for now, may be enabled later\n","filename":"src\/hotspot\/os\/aix\/os_aix.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-\/\/ stubbed-out trim-native support\n+\/\/ Trim-native support, stubbed out for now, may be enabled later\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"logging\/log.hpp\"\n@@ -45,0 +46,3 @@\n+        \/\/ Also log if native trim log is active\n+        log_info(trimnative)(\"Manual Trim: \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \")\",\n+                             PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta));\n","filename":"src\/hotspot\/os\/linux\/trimCHeapDCmd.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-\/\/ stubbed-out trim-native support\n+\/\/ Trim-native support, stubbed out for now, may be enabled later\n","filename":"src\/hotspot\/os\/windows\/os_windows.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -434,0 +435,1 @@\n+  NativeHeapTrimmer::SuspendMark sm(\"stringtable\");\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -700,0 +701,1 @@\n+  NativeHeapTrimmer::SuspendMark sm(\"symboltable\");\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -190,0 +190,1 @@\n+  LOG_TAG(trimnative) \/* trim native heap *\/ \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -139,0 +140,1 @@\n+    NativeHeapTrimmer::SuspendMark sm(\"chunk pool cleaner\");\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2367,0 +2367,8 @@\n+WB_ENTRY(void, WB_PreTouchMemory(JNIEnv* env, jobject wb, jlong addr, jlong size))\n+  void* const from = (void*)addr;\n+  void* const to = (void*)(addr + size);\n+  if (from > to) {\n+    os::pretouch_memory(from, to, os::vm_page_size());\n+  }\n+WB_END\n+\n@@ -2634,0 +2642,1 @@\n+  {CC\"preTouchMemory\",  CC\"(JJ)V\",                    (void*)&WB_PreTouchMemory},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2096,0 +2096,7 @@\n+                                                                            \\\n+  product(uint, TrimNativeHeapInterval, 0, EXPERIMENTAL,                    \\\n+          \"Interval, in ms, at which the JVM will trim the native heap if \" \\\n+          \"the platform supports that. Lower values will reclaim memory \"   \\\n+          \"more eagerly at the cost of higher overhead. A value of 0 \"      \\\n+          \"(default) disables native heap trimming.\")                       \\\n+          range(0, UINT_MAX)                                                \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -470,0 +471,2 @@\n+  NativeHeapTrimmer::cleanup();\n+\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -1547,0 +1548,2 @@\n+    NativeHeapTrimmer::SuspendMark sm(\"monitor deletion\");\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -3085,0 +3086,4 @@\n+  if (NativeHeapTrimmer::enabled()) {\n+    NativeHeapTrimmer::initialize();\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,275 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023 Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/nonJavaThread.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/trimNativeHeap.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/vmError.hpp\"\n+\n+class NativeHeapTrimmerThread : public NamedThread {\n+\n+  \/\/ Upper limit for the backoff during pending\/in-progress safepoint.\n+  \/\/ Chosen as reasonable value to balance the overheads of waking up\n+  \/\/ during the safepoint, which might have undesired effects on latencies,\n+  \/\/ and the accuracy in tracking the trimming interval.\n+  static constexpr int64_t safepoint_poll_ms = 250;\n+\n+  Monitor* const _lock;\n+  bool _stop;\n+  uint16_t _suspend_count;\n+\n+  \/\/ Statistics\n+  uint64_t _num_trims_performed;\n+\n+  bool is_suspended() const {\n+    assert(_lock->is_locked(), \"Must be\");\n+    return _suspend_count > 0;\n+  }\n+\n+  uint16_t inc_suspend_count() {\n+    assert(_lock->is_locked(), \"Must be\");\n+    assert(_suspend_count < UINT16_MAX, \"Sanity\");\n+    return ++_suspend_count;\n+  }\n+\n+  uint16_t dec_suspend_count() {\n+    assert(_lock->is_locked(), \"Must be\");\n+    assert(_suspend_count != 0, \"Sanity\");\n+    return --_suspend_count;\n+  }\n+\n+  bool is_stopped() const {\n+    assert(_lock->is_locked(), \"Must be\");\n+    return _stop;\n+  }\n+\n+  bool at_or_nearing_safepoint() const {\n+    return SafepointSynchronize::is_at_safepoint() ||\n+           SafepointSynchronize::is_synchronizing();\n+  }\n+\n+  \/\/ in seconds\n+  static double now() { return os::elapsedTime(); }\n+  static double to_ms(double seconds) { return seconds * 1000.0; }\n+\n+  struct LogStartStopMark {\n+    void log(const char* s) { log_info(trimnative)(\"Native heap trimmer %s\", s); }\n+    LogStartStopMark()  { log(\"start\"); }\n+    ~LogStartStopMark() { log(\"stop\"); }\n+  };\n+\n+  void run() override {\n+    assert(NativeHeapTrimmer::enabled(), \"Only call if enabled\");\n+\n+    LogStartStopMark lssm;\n+\n+    const double interval_secs = (double)TrimNativeHeapInterval \/ 1000;\n+\n+    while (true) {\n+      double tnow = now();\n+      double next_trim_time = tnow + interval_secs;\n+\n+      unsigned times_suspended = 0;\n+      unsigned times_waited = 0;\n+      unsigned times_safepoint = 0;\n+\n+      {\n+        MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+        if (_stop) return;\n+\n+        while (at_or_nearing_safepoint() || is_suspended() || next_trim_time > tnow) {\n+          if (is_suspended()) {\n+            times_suspended ++;\n+            ml.wait(0); \/\/ infinite\n+          } else if (next_trim_time > tnow) {\n+            times_waited ++;\n+            const int64_t wait_ms = MAX2(1.0, to_ms(next_trim_time - tnow));\n+            ml.wait(wait_ms);\n+          } else if (at_or_nearing_safepoint()) {\n+            times_safepoint ++;\n+            const int64_t wait_ms = MIN2<int64_t>(TrimNativeHeapInterval, safepoint_poll_ms);\n+            ml.wait(wait_ms);\n+          }\n+\n+          if (_stop) return;\n+\n+          tnow = now();\n+        }\n+      }\n+\n+      log_trace(trimnative)(\"Times: %u suspended, %u timed, %u safepoint\",\n+                            times_suspended, times_waited, times_safepoint);\n+\n+      execute_trim_and_log(tnow);\n+    }\n+  }\n+\n+  \/\/ Execute the native trim, log results.\n+  void execute_trim_and_log(double t1) {\n+    assert(os::can_trim_native_heap(), \"Unexpected\");\n+\n+    os::size_change_t sc = { 0, 0 };\n+    LogTarget(Info, trimnative) lt;\n+    const bool logging_enabled = lt.is_enabled();\n+\n+    \/\/ We only collect size change information if we are logging; save the access to procfs otherwise.\n+    if (os::trim_native_heap(logging_enabled ? &sc : nullptr)) {\n+      _num_trims_performed++;\n+      if (logging_enabled) {\n+        double t2 = now();\n+        if (sc.after != SIZE_MAX) {\n+          const size_t delta = sc.after < sc.before ? (sc.before - sc.after) : (sc.after - sc.before);\n+          const char sign = sc.after < sc.before ? '-' : '+';\n+          log_info(trimnative)(\"Periodic Trim (\" UINT64_FORMAT \"): \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \") %.3fms\",\n+                               _num_trims_performed,\n+                               PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta),\n+                               to_ms(t2 - t1));\n+        } else {\n+          log_info(trimnative)(\"Periodic Trim (\" UINT64_FORMAT \"): complete (no details) %.3fms\",\n+                               _num_trims_performed,\n+                               to_ms(t2 - t1));\n+        }\n+      }\n+    }\n+  }\n+\n+public:\n+\n+  NativeHeapTrimmerThread() :\n+    _lock(new (std::nothrow) PaddedMonitor(Mutex::leaf, \"NativeHeapTrimmer_lock\", true, Mutex::_safepoint_check_never)),\n+    _stop(false),\n+    _suspend_count(0),\n+    _num_trims_performed(0)\n+  {\n+    set_name(\"Native Heap Trimmer\");\n+    if (os::create_thread(this, os::vm_thread)) {\n+      os::start_thread(this);\n+    }\n+  }\n+\n+  void suspend(const char* reason) {\n+    assert(NativeHeapTrimmer::enabled(), \"Only call if enabled\");\n+    uint16_t n = 0;\n+    {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      n = inc_suspend_count();\n+      \/\/ No need to wakeup trimmer\n+    }\n+    log_debug(trimnative)(\"Trim suspended for %s (%u suspend requests)\", reason, n);\n+  }\n+\n+  void resume(const char* reason) {\n+    assert(NativeHeapTrimmer::enabled(), \"Only call if enabled\");\n+    uint16_t n = 0;\n+    {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      n = dec_suspend_count();\n+      if (n == 0) {\n+        ml.notify_all(); \/\/ pause end\n+      }\n+    }\n+    if (n == 0) {\n+      log_debug(trimnative)(\"Trim resumed after %s\", reason);\n+    } else {\n+      log_debug(trimnative)(\"Trim still suspended after %s (%u suspend requests)\", reason, n);\n+    }\n+  }\n+\n+  void stop() {\n+    MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+    _stop = true;\n+    ml.notify_all();\n+  }\n+\n+  void print_state(outputStream* st) const {\n+    \/\/ Don't pull lock during error reporting\n+    Mutex* const lock = VMError::is_error_reported() ? nullptr : _lock;\n+    int64_t num_trims = 0;\n+    bool stopped = false;\n+    uint16_t suspenders = 0;\n+    {\n+      MutexLocker ml(lock, Mutex::_no_safepoint_check_flag);\n+      num_trims = _num_trims_performed;\n+      stopped = _stop;\n+      suspenders = _suspend_count;\n+    }\n+    st->print_cr(\"Trims performed: \" UINT64_FORMAT \", current suspend count: %d, stopped: %d\",\n+                 num_trims, suspenders, stopped);\n+  }\n+\n+}; \/\/ NativeHeapTrimmer\n+\n+static NativeHeapTrimmerThread* g_trimmer_thread = nullptr;\n+\n+void NativeHeapTrimmer::initialize() {\n+  assert(g_trimmer_thread == nullptr, \"Only once\");\n+  if (TrimNativeHeapInterval > 0) {\n+    if (!os::can_trim_native_heap()) {\n+      FLAG_SET_ERGO(TrimNativeHeapInterval, 0);\n+      log_warning(trimnative)(\"Native heap trim is not supported on this platform\");\n+      return;\n+    }\n+    g_trimmer_thread = new NativeHeapTrimmerThread();\n+    log_info(trimnative)(\"Periodic native trim enabled (interval: %u ms)\", TrimNativeHeapInterval);\n+  }\n+}\n+\n+void NativeHeapTrimmer::cleanup() {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->stop();\n+  }\n+}\n+\n+void NativeHeapTrimmer::suspend_periodic_trim(const char* reason) {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->suspend(reason);\n+  }\n+}\n+\n+void NativeHeapTrimmer::resume_periodic_trim(const char* reason) {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->resume(reason);\n+  }\n+}\n+\n+void NativeHeapTrimmer::print_state(outputStream* st) {\n+  if (g_trimmer_thread != nullptr) {\n+    st->print_cr(\"Periodic native trim enabled (interval: %u ms)\", TrimNativeHeapInterval);\n+    g_trimmer_thread->print_state(st);\n+  } else {\n+    st->print_cr(\"Periodic native trim disabled\");\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/trimNativeHeap.cpp","additions":275,"deletions":0,"binary":false,"changes":275,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023 Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_TRIMNATIVEHEAP_HPP\n+#define SHARE_RUNTIME_TRIMNATIVEHEAP_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+class outputStream;\n+\n+class NativeHeapTrimmer : public AllStatic {\n+\n+  \/\/ Pause periodic trim (if enabled).\n+  static void suspend_periodic_trim(const char* reason);\n+\n+  \/\/ Unpause periodic trim (if enabled).\n+  static void resume_periodic_trim(const char* reason);\n+\n+public:\n+\n+  static void initialize();\n+  static void cleanup();\n+\n+  static inline bool enabled() { return TrimNativeHeapInterval > 0; }\n+\n+  static void print_state(outputStream* st);\n+\n+  \/\/ Pause periodic trimming while in scope; when leaving scope,\n+  \/\/ resume periodic trimming.\n+  struct SuspendMark {\n+    const char* const _reason;\n+    SuspendMark(const char* reason = \"unknown\") : _reason(reason) {\n+      if (NativeHeapTrimmer::enabled()) {\n+        suspend_periodic_trim(_reason);\n+      }\n+    }\n+    ~SuspendMark()  {\n+      if (NativeHeapTrimmer::enabled()) {\n+        resume_periodic_trim(_reason);\n+      }\n+    }\n+  };\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_TRIMNATIVEHEAP_HPP\n","filename":"src\/hotspot\/share\/runtime\/trimNativeHeap.hpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -1197,0 +1198,8 @@\n+       st->cr();\n+     }\n+\n+  STEP(\"printing periodic trim state\")\n+\n+     if (_verbose) {\n+       NativeHeapTrimmer::print_state(st);\n+       st->cr();\n@@ -1382,0 +1391,1 @@\n+  st->cr();\n@@ -1383,2 +1393,2 @@\n-  \/\/ STEP(\"printing system\")\n-\n+  \/\/ STEP(\"printing periodic trim state\")\n+  NativeHeapTrimmer::print_state(st);\n@@ -1386,0 +1396,3 @@\n+\n+\n+  \/\/ STEP(\"printing system\")\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2023 Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/trimNativeHeap.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"testutils.hpp\"\n+#include \"unittest.hpp\"\n+\n+using ::testing::HasSubstr;\n+\n+\/\/ Check the state of the trimmer via print_state; returns the suspend count\n+static int check_trim_state() {\n+  char buf [1024];\n+  stringStream ss(buf, sizeof(buf));\n+  NativeHeapTrimmer::print_state(&ss);\n+  if (NativeHeapTrimmer::enabled()) {\n+    assert(TrimNativeHeapInterval > 0, \"Sanity\");\n+    EXPECT_THAT(buf, HasSubstr(\"Periodic native trim enabled\"));\n+\n+    const char* s = ::strstr(buf, \"Trims performed\");\n+    EXPECT_NE(p2i(s), 0);\n+\n+    uint64_t num_trims = 0;\n+    int suspend_count = 0;\n+    int stopped = 0;\n+    EXPECT_EQ(::sscanf(s, \"Trims performed: \" UINT64_FORMAT \", current suspend count: %d, stopped: %d\",\n+                       &num_trims, &suspend_count, &stopped), 3);\n+\n+    \/\/ Number of trims we can reasonably expect should be limited\n+    const double fudge_factor = 1.5;\n+    const uint64_t elapsed_ms = (uint64_t)(os::elapsedTime() * fudge_factor * 1000.0);\n+    const uint64_t max_num_trims = (elapsed_ms \/ TrimNativeHeapInterval) + 1;\n+    EXPECT_LE(num_trims, max_num_trims);\n+\n+    \/\/ We should not be stopped\n+    EXPECT_EQ(stopped, 0);\n+\n+    \/\/ Suspend count must not underflow\n+    EXPECT_GE(suspend_count, 0);\n+    return suspend_count;\n+\n+  } else {\n+    EXPECT_THAT(buf, HasSubstr(\"Periodic native trim disabled\"));\n+    EXPECT_THAT(buf, Not(HasSubstr(\"Trims performed\")));\n+    return 0;\n+  }\n+}\n+\n+TEST_VM(os, TrimNative) {\n+\n+  if (!NativeHeapTrimmer::enabled()) {\n+    return;\n+  }\n+\n+  \/\/ Try recursive pausing. This tests that we are able to pause, that pauses stack,\n+  \/\/ and that stacking works within the same thread.\n+  int c1 = 0, c2 = 0, c3 = 0;\n+  {\n+    NativeHeapTrimmer::SuspendMark sm1(\"Test1\");\n+    c1 = check_trim_state();\n+    {\n+      NativeHeapTrimmer::SuspendMark sm2(\"Test2\");\n+      c2 = check_trim_state();\n+      {\n+        NativeHeapTrimmer::SuspendMark sm3(\"Test3\");\n+        c3 = check_trim_state();\n+      }\n+    }\n+  }\n+  \/\/ We also check the state: the suspend count should go up. But since we don't know\n+  \/\/ whether concurrent code will have increased the suspend count too, this is fuzzy and\n+  \/\/ we must avoid intermittent false positives.\n+  EXPECT_GT(c2, c1);\n+  EXPECT_GT(c3, c2);\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_trim_native.cpp","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023 Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/* @test\n+ * @summary Run a subset of gtests with the native trimmer activated.\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=os.trim* -Xlog:trimnative -XX:+UnlockExperimentalVMOptions -XX:TrimNativeHeapInterval=100\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/NativeHeapTrimmerGtest.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,340 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023 Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=trimNative\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver TestTrimNative trimNative\n+ *\/\n+\n+\/*\n+ * @test id=trimNativeStrict\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/manual TestTrimNative trimNativeStrict\n+ *\/\n+\n+\/*\n+ * @test id=trimNativeHighInterval\n+ * @summary High interval trimming should not even kick in for short program runtimes\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver TestTrimNative trimNativeHighInterval\n+ *\/\n+\n+\/*\n+ * @test id=trimNativeLowInterval\n+ * @summary Very low (sub-second) interval, nothing should explode\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver TestTrimNative trimNativeLowInterval\n+ *\/\n+\n+\/*\n+ * @test id=trimNativeLowIntervalStrict\n+ * @summary Very low (sub-second) interval, nothing should explode (stricter test, manual mode)\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/manual TestTrimNative trimNativeLowIntervalStrict\n+ *\/\n+\n+\/*\n+ * @test id=testOffByDefault\n+ * @summary Test that trimming is disabled by default\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver TestTrimNative testOffByDefault\n+ *\/\n+\n+\/*\n+ * @test id=testOffExplicit\n+ * @summary Test that trimming can be disabled explicitly\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver TestTrimNative testOffExplicit\n+ *\/\n+\n+\/*\n+ * @test id=testOffOnNonCompliantPlatforms\n+ * @summary Test that trimming is correctly reported as unavailable if unavailable\n+ * @requires (os.family!=\"linux\") | vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver TestTrimNative testOffOnNonCompliantPlatforms\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestTrimNative {\n+\n+    \/\/ Actual RSS increase is a lot larger than 4 MB. Depends on glibc overhead, and NMT malloc headers in debug VMs.\n+    \/\/ We need small-grained allocations to make sure they actually increase RSS (all touched) and to see the\n+    \/\/ glibc-retaining-memory effect.\n+    static final int szAllocations = 128;\n+    static final int totalAllocationsSize = 128 * 1024 * 1024; \/\/ 128 MB total\n+    static final int numAllocations = totalAllocationsSize \/ szAllocations;\n+\n+    static long[] ptrs = new long[numAllocations];\n+\n+    enum Unit {\n+        B(1), K(1024), M(1024*1024), G(1024*1024*1024);\n+        public final long size;\n+        Unit(long size) { this.size = size; }\n+    }\n+\n+    private static String[] prepareOptions(String[] extraVMOptions, String[] programOptions) {\n+        List<String> allOptions = new ArrayList<String>();\n+        if (extraVMOptions != null) {\n+            allOptions.addAll(Arrays.asList(extraVMOptions));\n+        }\n+        allOptions.add(\"-Xmx128m\");\n+        allOptions.add(\"-Xms128m\"); \/\/ Stabilize RSS\n+        allOptions.add(\"-XX:+AlwaysPreTouch\"); \/\/ Stabilize RSS\n+        allOptions.add(\"-XX:+UnlockDiagnosticVMOptions\"); \/\/ For whitebox\n+        allOptions.add(\"-XX:+WhiteBoxAPI\");\n+        allOptions.add(\"-Xbootclasspath\/a:.\");\n+        allOptions.add(\"-XX:-ExplicitGCInvokesConcurrent\"); \/\/ Invoke explicit GC on System.gc\n+        allOptions.add(\"-Xlog:trimnative=debug\");\n+        allOptions.add(\"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+        if (programOptions != null) {\n+            allOptions.addAll(Arrays.asList(programOptions));\n+        }\n+        return allOptions.toArray(new String[0]);\n+    }\n+\n+    private static OutputAnalyzer runTestWithOptions(String[] extraOptions, String[] programOptions) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(prepareOptions(extraOptions, programOptions));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        return output;\n+    }\n+\n+    private static void checkExpectedLogMessages(OutputAnalyzer output, boolean expectEnabled,\n+                                                 int expectedInterval) {\n+        if (expectEnabled) {\n+            output.shouldContain(\"Periodic native trim enabled (interval: \" + expectedInterval + \" ms\");\n+            output.shouldContain(\"Native heap trimmer start\");\n+        } else {\n+            output.shouldNotContain(\"Periodic native trim enabled\");\n+        }\n+    }\n+\n+    \/**\n+     * Given JVM output, look for one or more log lines that describes a successful negative trim. The total amount\n+     * of trims should be matching about what the test program allocated.\n+     * @param output\n+     * @param minTrimsExpected min number of periodic trim lines expected in UL log\n+     * @param maxTrimsExpected min number of periodic trim lines expected in UL log\n+     * @param strict: if true, expect RSS to go down; if false, just look for trims without looking at RSS.\n+     *\/\n+    private static void parseOutputAndLookForNegativeTrim(OutputAnalyzer output, int minTrimsExpected,\n+                                                          int maxTrimsExpected, boolean strict) {\n+        output.reportDiagnosticSummary();\n+        List<String> lines = output.asLines();\n+        Pattern pat = Pattern.compile(\".*\\\\[trimnative\\\\] Periodic Trim \\\\(\\\\d+\\\\): (\\\\d+)([BKMG])->(\\\\d+)([BKMG]).*\");\n+        int numTrimsFound = 0;\n+        long rssReductionTotal = 0;\n+        for (String line : lines) {\n+            Matcher mat = pat.matcher(line);\n+            if (mat.matches()) {\n+                long rss1 = Long.parseLong(mat.group(1)) * Unit.valueOf(mat.group(2)).size;\n+                long rss2 = Long.parseLong(mat.group(3)) * Unit.valueOf(mat.group(4)).size;\n+                if (rss1 > rss2) {\n+                    rssReductionTotal += (rss1 - rss2);\n+                }\n+                numTrimsFound ++;\n+            }\n+            if (numTrimsFound > maxTrimsExpected) {\n+                throw new RuntimeException(\"Abnormal high number of periodic trim attempts found (more than \" + maxTrimsExpected +\n+                        \"). Does the interval setting not work?\");\n+            }\n+        }\n+        if (numTrimsFound < minTrimsExpected) {\n+            throw new RuntimeException(\"We found fewer (periodic) trim lines in UL log than expected (expected at least \" + minTrimsExpected +\n+                    \", found \" + numTrimsFound + \").\");\n+        }\n+        System.out.println(\"Found \" + numTrimsFound + \" trims. Ok.\");\n+        if (strict && maxTrimsExpected > 0) {\n+            \/\/ This is very fuzzy. Test program malloced X bytes, then freed them again and trimmed. But the log line prints change in RSS.\n+            \/\/ Which, of course, is influenced by a lot of other factors. But we expect to see *some* reasonable reduction in RSS\n+            \/\/ due to trimming.\n+            float fudge = 0.5f;\n+            \/\/ On ppc, we see a vastly diminished return (~3M reduction instead of ~200), I suspect because of the underlying\n+            \/\/ 64k pages lead to a different geometry. Manual tests with larger reclaim sizes show that autotrim works. For\n+            \/\/ this test, we just reduce the fudge factor.\n+            if (Platform.isPPC()) { \/\/ le and be both\n+                fudge = 0.01f;\n+            }\n+            long expectedMinimalReduction = (long) (totalAllocationsSize * fudge);\n+            if (rssReductionTotal < expectedMinimalReduction) {\n+                throw new RuntimeException(\"We did not see the expected RSS reduction in the UL log. Expected (with fudge)\" +\n+                        \" to see at least a combined reduction of \" + expectedMinimalReduction + \".\");\n+            } else {\n+                System.out.println(\"Found high enough RSS reduction from trims: \" + rssReductionTotal);\n+            }\n+        }\n+    }\n+\n+    static class Tester {\n+        public static void main(String[] args) throws Exception {\n+            long sleeptime = Long.parseLong(args[0]);\n+\n+            System.out.println(\"Will spike now...\");\n+            WhiteBox wb = WhiteBox.getWhiteBox();\n+            for (int i = 0; i < numAllocations; i++) {\n+                ptrs[i] = wb.NMTMalloc(szAllocations);\n+                wb.preTouchMemory(ptrs[i], szAllocations);\n+            }\n+            for (int i = 0; i < numAllocations; i++) {\n+                wb.NMTFree(ptrs[i]);\n+            }\n+            System.out.println(\"Done spiking.\");\n+\n+            System.out.println(\"GC...\");\n+            System.gc();\n+\n+            \/\/ give GC time to react\n+            System.out.println(\"Sleeping for \" + sleeptime + \" ms...\");\n+            Thread.sleep(sleeptime);\n+            System.out.println(\"Done.\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (args.length == 0) {\n+            throw new RuntimeException(\"Argument error\");\n+        }\n+\n+        boolean strictTesting = args[0].endsWith(\"Strict\");\n+\n+        switch (args[0]) {\n+            case \"trimNative\":\n+            case \"trimNativeStrict\": {\n+                long trimInterval = 500; \/\/ twice per second\n+                long ms1 = System.currentTimeMillis();\n+                OutputAnalyzer output = runTestWithOptions(\n+                        new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:TrimNativeHeapInterval=\" + trimInterval },\n+                        new String[] { TestTrimNative.Tester.class.getName(), \"5000\" }\n+                );\n+                long ms2 = System.currentTimeMillis();\n+                long runtime_ms = ms2 - ms1;\n+\n+                checkExpectedLogMessages(output, true, 500);\n+\n+                long maxTrimsExpected = runtime_ms \/ trimInterval;\n+                long minTrimsExpected = maxTrimsExpected \/ 2;\n+                parseOutputAndLookForNegativeTrim(output, (int) minTrimsExpected, (int) maxTrimsExpected, strictTesting);\n+            } break;\n+\n+            case \"trimNativeHighInterval\": {\n+                OutputAnalyzer output = runTestWithOptions(\n+                        new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:TrimNativeHeapInterval=\" + Integer.MAX_VALUE },\n+                        new String[] { TestTrimNative.Tester.class.getName(), \"5000\" }\n+                );\n+                checkExpectedLogMessages(output, true, Integer.MAX_VALUE);\n+                \/\/ We should not see any trims since the interval would prevent them\n+                parseOutputAndLookForNegativeTrim(output, 0, 0, strictTesting);\n+            } break;\n+\n+            case \"trimNativeLowInterval\":\n+            case \"trimNativeLowIntervalStrict\": {\n+                long ms1 = System.currentTimeMillis();\n+                OutputAnalyzer output = runTestWithOptions(\n+                        new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:TrimNativeHeapInterval=1\" },\n+                        new String[] { TestTrimNative.Tester.class.getName(), \"0\" }\n+                );\n+                long ms2 = System.currentTimeMillis();\n+                int maxTrimsExpected = (int)(ms2 - ms1); \/\/ 1ms trim interval\n+                checkExpectedLogMessages(output, true, 1);\n+                parseOutputAndLookForNegativeTrim(output, 1, (int)maxTrimsExpected, strictTesting);\n+            } break;\n+\n+            case \"testOffOnNonCompliantPlatforms\": {\n+                OutputAnalyzer output = runTestWithOptions(\n+                        new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:TrimNativeHeapInterval=1\" },\n+                        new String[] { \"-version\" }\n+                );\n+                checkExpectedLogMessages(output, false, 0);\n+                parseOutputAndLookForNegativeTrim(output, 0, 0, strictTesting);\n+                \/\/ The following output is expected to be printed with warning level, so it should not need -Xlog\n+                output.shouldContain(\"[warning][trimnative] Native heap trim is not supported on this platform\");\n+            } break;\n+\n+            case \"testOffExplicit\": {\n+                OutputAnalyzer output = runTestWithOptions(\n+                        new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:TrimNativeHeapInterval=0\" },\n+                        new String[] { \"-version\" }\n+                );\n+                checkExpectedLogMessages(output, false, 0);\n+                parseOutputAndLookForNegativeTrim(output, 0, 0, strictTesting);\n+            } break;\n+\n+            case \"testOffByDefault\": {\n+                OutputAnalyzer output = runTestWithOptions(null, new String[] { \"-version\" } );\n+                checkExpectedLogMessages(output, false, 0);\n+                parseOutputAndLookForNegativeTrim(output, 0, 0, strictTesting);\n+            } break;\n+\n+            default:\n+                throw new RuntimeException(\"Invalid test \" + args[0]);\n+\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTrimNative.java","additions":340,"deletions":0,"binary":false,"changes":340,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.test.lib.Platform;\n@@ -34,1 +35,1 @@\n- * @requires (os.family==\"linux\") & !vm.musl\n+ * @requires os.family == \"linux\"\n@@ -45,1 +46,5 @@\n-        output.shouldMatch(\".*Trim native heap: RSS\\\\+Swap: \\\\d+[BKM]->\\\\d+[BKM].*\");\n+        if (Platform.isMusl()) {\n+            output.shouldContain(\"Not available\");\n+        } else {\n+            output.shouldMatch(\"Trim native heap: RSS\\\\+Swap: \\\\d+[BKMG]->\\\\d+[BKMG] \\\\(-\\\\d+[BKMG]\\\\)\");\n+        }\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/TrimLibcHeapTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -657,0 +657,2 @@\n+\n+  public native void preTouchMemory(long addr, long size);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}