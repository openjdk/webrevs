{"files":[{"patch":"@@ -3586,0 +3586,6 @@\n+    if (p->is_exiting()) {\n+      \/\/ If we got here via JavaThread::exit(), then we remember that the\n+      \/\/ thread's GC barrier has been detached. We don't do this when we get\n+      \/\/ here from another path, e.g., cleanup_failed_attach_current_thread().\n+      p->set_terminated(JavaThread::_thread_gc_barrier_detached);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -889,1 +889,1 @@\n-    _not_terminated = 0xDEAD - 2,\n+    _not_terminated = 0xDEAD - 3,\n@@ -891,0 +891,1 @@\n+    _thread_gc_barrier_detached,                 \/\/ thread's GC barrier has been detached\n@@ -899,1 +900,1 @@\n-  \/\/   _not_terminated => _thread_exiting => _thread_terminated\n+  \/\/   _not_terminated => _thread_exiting => _thread_gc_barrier_detached => _thread_terminated\n@@ -903,0 +904,4 @@\n+  \/\/\n+  \/\/ A JavaThread that fails to JNI attach has these _terminated field transitions:\n+  \/\/   _not_terminated => _thread_terminated\n+  \/\/\n@@ -1129,1 +1134,2 @@\n-  \/\/ thread has called JavaThread::exit() or is terminated\n+  \/\/ thread has called JavaThread::exit(), thread's GC barrier is detached\n+  \/\/ or thread is terminated\n@@ -1131,0 +1137,2 @@\n+  \/\/ thread's GC barrier is NOT detached and thread is NOT terminated\n+  bool is_oop_safe() const;\n@@ -1132,1 +1140,1 @@\n-  \/\/ against the two non-terminated values so that a freed JavaThread\n+  \/\/ against the three non-terminated values so that a freed JavaThread\n@@ -1135,1 +1143,2 @@\n-    return l_terminated != _not_terminated && l_terminated != _thread_exiting;\n+    return l_terminated != _not_terminated && l_terminated != _thread_exiting &&\n+           l_terminated != _thread_gc_barrier_detached;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -187,2 +187,0 @@\n-  \/\/ Use load-acquire so that setting of _terminated by\n-  \/\/ JavaThread::exit() is seen more quickly.\n@@ -190,1 +188,9 @@\n-  return l_terminated == _thread_exiting || check_is_terminated(l_terminated);\n+  return l_terminated == _thread_exiting ||\n+         l_terminated == _thread_gc_barrier_detached ||\n+         check_is_terminated(l_terminated);\n+}\n+\n+inline bool JavaThread::is_oop_safe() const {\n+  TerminatedTypes l_terminated = Atomic::load_acquire(&_terminated);\n+  return l_terminated != _thread_gc_barrier_detached &&\n+         !check_is_terminated(l_terminated);\n@@ -194,2 +200,0 @@\n-  \/\/ Use load-acquire so that setting of _terminated by\n-  \/\/ JavaThread::exit() is seen more quickly.\n@@ -201,1 +205,0 @@\n-  \/\/ use release-store so the setting of _terminated is seen more quickly\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -165,1 +165,2 @@\n-    \/\/ JavaThread::exit() skipped calling current_thread_exiting()\n+    \/\/ We did not get here via JavaThread::exit() so current_thread_exiting()\n+    \/\/ was not called, e.g., JavaThread::cleanup_failed_attach_current_thread().\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}