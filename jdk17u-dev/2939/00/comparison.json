{"files":[{"patch":"@@ -648,1 +648,1 @@\n-                \"\"\n+        \"\"\n@@ -651,0 +651,54 @@\n+        CA_SHA1_RSA_2048( \/\/ for DHEKeySizing.java\n+                \"RSA\",\n+                \/\/        Signature Algorithm: sha1WithRSAEncryption\n+                \/\/        Issuer: OU = SunJSSE Test Serivce, O = Java, C = US\n+                \/\/        Validity\n+                \/\/            Not Before: Sep 18 04:38:31 2013 GMT\n+                \/\/            Not After : Dec 17 04:38:31 2013 GMT\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIIC8jCCAdqgAwIBAgIEUjkuRzANBgkqhkiG9w0BAQUFADA7MR0wGwYDVQQLExRT\\n\" +\n+                \"dW5KU1NFIFRlc3QgU2VyaXZjZTENMAsGA1UEChMESmF2YTELMAkGA1UEBhMCVVMw\\n\" +\n+                \"HhcNMTMwOTE4MDQzODMxWhcNMTMxMjE3MDQzODMxWjA7MR0wGwYDVQQLExRTdW5K\\n\" +\n+                \"U1NFIFRlc3QgU2VyaXZjZTENMAsGA1UEChMESmF2YTELMAkGA1UEBhMCVVMwggEi\\n\" +\n+                \"MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCO+IGeaskJAvEcYc7pCl9neK3E\\n\" +\n+                \"a28fwWLtChufYNaC9hQfZlUdETWYjV7fZJVJKT\/oLzdDNMWuVA0LKXArpI3thLNK\\n\" +\n+                \"QLXisdF9hKPlZRDazACL9kWUUtJ0FzpEySK4e8wW\/z9FuU6e6iO19FbjxAfInJqk\\n\" +\n+                \"3EDiEhB5g73S2vtvPCxgq2DvWw9TDl\/LIqdKG2JCS93koXCCaHmQ7MrIOqHPd+8r\\n\" +\n+                \"RbGpatXT9qyHKppUv9ATxVygO4rA794mgCFxpT+fkhz+NEB0twTkM65T1hnnOv5n\\n\" +\n+                \"ZIxkcjBggt85UlZtnP3b9P7SYxsWIa46Oc38Od2f3YejfVg6B+PqPgWNl3+\/AgMB\\n\" +\n+                \"AAEwDQYJKoZIhvcNAQEFBQADggEBAAlrP6DFLRPSy0IgQhcI2i56tR\/na8pezSte\\n\" +\n+                \"ZHcCdaCZPDy4UP8mpLJ9QCjEB5VJv8hPm4xdK7ULnKGOGHgYqDpV2ZHvQlhV1woQ\\n\" +\n+                \"TZGb\/LM3c6kAs0j4j9KM2fq3iYUYexjIkS1KzsziflxMM6igS9BRMBR2LQyU+cYq\\n\" +\n+                \"YEsFzkF7Aj2ET4v\/+tgot9mRr2NioJcaJkdsPDpMU3IKB1cczfu+OuLQ\/GCG0Fqu\\n\" +\n+                \"6ijCeCqfnaAbemHbJeVZZ6Qgka3uC2YMntLBmLkhqEo1d9zGYLoh7oWL77y5ibQZ\\n\" +\n+                \"LK5\/H\/zikcu579TWjlDHcqL3arCwBcrtsjSaPrRSWMrWV\/6c0qw=\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+        \"MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCO+IGeaskJAvEc\\n\" +\n+                \"Yc7pCl9neK3Ea28fwWLtChufYNaC9hQfZlUdETWYjV7fZJVJKT\/oLzdDNMWuVA0L\\n\" +\n+                \"KXArpI3thLNKQLXisdF9hKPlZRDazACL9kWUUtJ0FzpEySK4e8wW\/z9FuU6e6iO1\\n\" +\n+                \"9FbjxAfInJqk3EDiEhB5g73S2vtvPCxgq2DvWw9TDl\/LIqdKG2JCS93koXCCaHmQ\\n\" +\n+                \"7MrIOqHPd+8rRbGpatXT9qyHKppUv9ATxVygO4rA794mgCFxpT+fkhz+NEB0twTk\\n\" +\n+                \"M65T1hnnOv5nZIxkcjBggt85UlZtnP3b9P7SYxsWIa46Oc38Od2f3YejfVg6B+Pq\\n\" +\n+                \"PgWNl3+\/AgMBAAECggEAPdb5Ycc4m4A9QBSCRcRpzbyiFLKPh0HDg1n65q4hOtYr\\n\" +\n+                \"kAVYTVFTSF\/lqGS+Ob3w2YIKujQKSUQrvCc5UHdFuHXMgxKIWbymK0+DAMb9SlYw\\n\" +\n+                \"6lkkcWp9gx9E4dnJ\/df2SAAxovvrKMuHlL1SFASHhVtPfH2URvSfUaANLDXxyYOs\\n\" +\n+                \"8BX0Nr6wazhWjLjXo9yIGnKSvFfB8XisYcA78kEgas43zhmIGCDPqaYyyffOfRbx\\n\" +\n+                \"pM1KNwGmlN86iWR1CbwA\/wwhcMySWQueS+s7cHbpRqZIYJF9jEeELiwi0vxjealS\\n\" +\n+                \"EMuHYedIRFMWaDIq9XyjrvXamHb0Z25jlXBNZHaM0QKBgQDE9adl+zAezR\/n79vw\\n\" +\n+                \"0XiX2Fx1UEo3ApZHuoA2Q\/PcBk+rlKqqQ3IwTcy6Wo648wK7v6Nq7w5nEWcsf0dU\\n\" +\n+                \"QA2Ng\/AJEev\/IfF34x7sKGYxtk1gcE0EuSBA3R+ocEZxnNw1Ryd5nUU24s8d4jCP\\n\" +\n+                \"Mkothnyaim+zE2raDlEtVc0CaQKBgQC509av+02Uq5oMjzbQp5PBJfQFjATOQT15\\n\" +\n+                \"eefYnVYurkQ1kcVfixkrO2ORhg4SjmI2Z5hJDgGtXdwgidpzkad+R2epS5qLMyno\\n\" +\n+                \"lQVpY6bMpEZ7Mos0yQygxnm8uNohEcTExOe+nP5fNJVpzBsGmfeyYOhnPQlf6oqf\\n\" +\n+                \"0cHizedb5wKBgQC\/l5LyMil6HOGHlhzmIm3jj7VI7QR0hJC5T6N+phVml8ESUDjA\\n\" +\n+                \"DYHbmSKouISTRtkG14FY+RiSjCxH7bvuKazFV2289PETquogTA\/9e8MFYqfcQwG4\\n\" +\n+                \"sXi9gBxWlnj\/9a2EKiYtOB5nKLR\/BlNkSHA93tAA6N+FXEMZwMmYhxk42QKBgAuY\\n\" +\n+                \"HQgD3PZOsqDf+qKQIhbmAFCsSMx5o5VFtuJ8BpmJA\/Z3ruHkMuDQpsi4nX4o5hXQ\\n\" +\n+                \"5t6AAjjH52kcUMXvK40kdWJJtk3DFnVNfvXxYsHX6hHbuHXFqYUKfSP6QJnZmvZP\\n\" +\n+                \"9smcz\/4usLfWJUWHK740b6upUkFqx9Vq5\/b3s9y3AoGAdM5TW7LkkOFsdMGVAUzR\\n\" +\n+                \"9iXmCWElHTK2Pcp\/3yqDBHSfiQx6Yp5ANyPnE9NBM0yauCfOyBB2oxLO4Rdv3Rqk\\n\" +\n+                \"9V9kyR\/YAGr7dJaPcQ7pZX0OpkzgueAOJYPrx5VUzPYUtklYV1ycFZTfKlpFCxT+\\n\" +\n+                \"Ei6KUo0NXSdUIcB4yib1J10=\"\n+        ),\n+\n+\n@@ -1173,1 +1227,35 @@\n-                \"Q2hO5ZTW6UD9CVA85whf\");\n+                \"Q2hO5ZTW6UD9CVA85whf\"),\n+\n+        DSA_SHA1_1024_EXPIRED( \/\/ for NullCerts test\n+            \"DSA\",\n+                \/\/        Signature Algorithm: dsaWithSHA1\n+                \/\/        Issuer: C = US, ST = CA, L = Cupertino, O = Dummy, OU = Dummy, CN = Example\n+                \/\/        Validity\n+                \/\/            Not Before: Mar 11 06:33:43 2001 GMT\n+                \/\/            Not After : Dec  6 06:33:43 2003 GMT\n+                \"-----BEGIN CERTIFICATE-----\\n\" +\n+                \"MIIC9TCCArMCBDqrHEcwCwYHKoZIzjgEAwUAMGAxCzAJBgNVBAYTAlVTMQswCQYD\\n\" +\n+                \"VQQIEwJDQTESMBAGA1UEBxMJQ3VwZXJ0aW5vMQ4wDAYDVQQKEwVEdW1teTEOMAwG\\n\" +\n+                \"A1UECxMFRHVtbXkxEDAOBgNVBAMTB0V4YW1wbGUwHhcNMDEwMzExMDYzMzQzWhcN\\n\" +\n+                \"MDMxMjA2MDYzMzQzWjBgMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExEjAQBgNV\\n\" +\n+                \"BAcTCUN1cGVydGlubzEOMAwGA1UEChMFRHVtbXkxDjAMBgNVBAsTBUR1bW15MRAw\\n\" +\n+                \"DgYDVQQDEwdFeGFtcGxlMIIBuDCCASwGByqGSM44BAEwggEfAoGBAP1\/U4EddRIp\\n\" +\n+                \"Ut9KnC7s5Of2EbdSPO9EAMMeP4C2USZpRV1AIlH7WT2NWPq\/xfW6MPbLm1Vs14E7\\n\" +\n+                \"gB00b\/JmYLdrmVClpJ+f6AR7ECLCT7up1\/63xhv4O1fnxqimFQ8E+4P208UewwI1\\n\" +\n+                \"VBNaFpEy9nXzrith1yrv8iIDGZ3RSAHHAhUAl2BQjxUjC8yykrmCouuEC\/BYHPUC\\n\" +\n+                \"gYEA9+GghdabPd7LvKtcNrhXuXmUr7v6OuqC+VdMCz0HgmdRWVeOutRZT+ZxBxCB\\n\" +\n+                \"gLRJFnEj6EwoFhO3zwkyjMim4TwWeotUfI0o4KOuHiuzpnWRbqN\/C\/ohNWLx+2J6\\n\" +\n+                \"ASQ7zKTxvqhRkImog9\/hWuWfBpKLZl6Ae1UlZAFMO\/7PSSoDgYUAAoGBAPqO\/boo\\n\" +\n+                \"m+n+tAdqetoQ2ZRoS8BpYIEFOJt4OJ8flb52T3vGNNdapq9pbjN+HKrT62ggNhZs\\n\" +\n+                \"hajxYwFCpaidKZuGQXvvpHkj0UHjhZFry6Dd41cfEG13dfgACf8uooeTzPGFvUPv\\n\" +\n+                \"TCHcPRh820BZMeOqdS4PjWPyf3HEtiTtFWR7MAsGByqGSM44BAMFAAMvADAsAhRH\\n\" +\n+                \"dZQef04MwUTlAALf2J6PIcgmQAIUB2H\/RnW2tVg+mbCl5jQLfudsEhI=\\n\" +\n+                \"-----END CERTIFICATE-----\",\n+                \"MIIBSwIBADCCASwGByqGSM44BAEwggEfAoGBAP1\/U4EddRIpUt9KnC7s5Of2EbdS\\n\" +\n+                \"PO9EAMMeP4C2USZpRV1AIlH7WT2NWPq\/xfW6MPbLm1Vs14E7gB00b\/JmYLdrmVCl\\n\" +\n+                \"pJ+f6AR7ECLCT7up1\/63xhv4O1fnxqimFQ8E+4P208UewwI1VBNaFpEy9nXzrith\\n\" +\n+                \"1yrv8iIDGZ3RSAHHAhUAl2BQjxUjC8yykrmCouuEC\/BYHPUCgYEA9+GghdabPd7L\\n\" +\n+                \"vKtcNrhXuXmUr7v6OuqC+VdMCz0HgmdRWVeOutRZT+ZxBxCBgLRJFnEj6EwoFhO3\\n\" +\n+                \"zwkyjMim4TwWeotUfI0o4KOuHiuzpnWRbqN\/C\/ohNWLx+2J6ASQ7zKTxvqhRkImo\\n\" +\n+                \"g9\/hWuWfBpKLZl6Ae1UlZAFMO\/7PSSoEFgIUZC+jBuwAPm8ejkybfAm2gT49ApY=\"\n+        );\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLContextTemplate.java","additions":90,"deletions":2,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -95,2 +95,6 @@\n-        clientOut = ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n-        serverOut = ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n+        clientOut = createClientOutputBuffer();\n+        serverOut = createServerOutputBuffer();\n+    }\n+\n+    protected ByteBuffer createServerOutputBuffer() {\n+        return ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n@@ -103,0 +107,4 @@\n+    protected ByteBuffer createClientOutputBuffer() {\n+        return ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n+    }\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLEngineTemplate.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/javax\/net\/ssl\/templates\n@@ -73,1 +73,0 @@\n-import java.io.*;\n@@ -82,1 +81,1 @@\n-public class LengthCheckTest {\n+public class LengthCheckTest extends SSLEngineTemplate {\n@@ -101,9 +100,0 @@\n-    private final SSLContext sslc;\n-\n-    private SSLEngine clientEngine;     \/\/ client Engine\n-    private ByteBuffer clientOut;       \/\/ write side of clientEngine\n-    private ByteBuffer clientIn;        \/\/ read side of clientEngine\n-\n-    private SSLEngine serverEngine;     \/\/ server Engine\n-    private ByteBuffer serverOut;       \/\/ write side of serverEngine\n-    private ByteBuffer serverIn;        \/\/ read side of serverEngine\n@@ -113,23 +103,0 @@\n-    \/*\n-     * For data transport, this example uses local ByteBuffers.  This\n-     * isn't really useful, but the purpose of this example is to show\n-     * SSLEngine concepts, not how to do network transport.\n-     *\/\n-    private ByteBuffer cTOs;            \/\/ \"reliable\" transport client->server\n-    private ByteBuffer sTOc;            \/\/ \"reliable\" transport server->client\n-\n-    \/*\n-     * The following is to set up the keystores.\n-     *\/\n-    private static final String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    private static final String keyStoreFile = \"keystore\";\n-    private static final String trustStoreFile = \"truststore\";\n-    private static final String passwd = \"passphrase\";\n-\n-    private static final String keyFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-    private static final String trustFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-\n@@ -179,1 +146,1 @@\n-            runDelegatedTasks(clientResult, clientEngine);\n+            runDelegatedTasks(clientEngine);\n@@ -186,1 +153,1 @@\n-            runDelegatedTasks(serverResult, serverEngine);\n+            runDelegatedTasks(serverEngine);\n@@ -192,1 +159,1 @@\n-            runDelegatedTasks(serverResult, serverEngine);\n+            runDelegatedTasks(serverEngine);\n@@ -223,1 +190,1 @@\n-                    runDelegatedTasks(clientResult, clientEngine);\n+                    runDelegatedTasks(clientEngine);\n@@ -228,1 +195,1 @@\n-                runDelegatedTasks(clientResult, clientEngine);\n+                runDelegatedTasks(clientEngine);\n@@ -235,1 +202,1 @@\n-            runDelegatedTasks(clientResult, clientEngine);\n+            runDelegatedTasks(clientEngine);\n@@ -267,1 +234,1 @@\n-            runDelegatedTasks(serverResult, serverEngine);\n+            runDelegatedTasks(serverEngine);\n@@ -276,1 +243,1 @@\n-                runDelegatedTasks(serverResult, serverEngine);\n+                runDelegatedTasks(serverEngine);\n@@ -285,1 +252,1 @@\n-            runDelegatedTasks(serverResult, serverEngine);\n+            runDelegatedTasks(serverEngine);\n@@ -329,20 +296,1 @@\n-\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        KeyStore ts = KeyStore.getInstance(\"JKS\");\n-\n-        char[] passphrase = \"passphrase\".toCharArray();\n-\n-        ks.load(new FileInputStream(keyFilename), passphrase);\n-        ts.load(new FileInputStream(trustFilename), passphrase);\n-\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-        kmf.init(ks, passphrase);\n-\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-        tmf.init(ts);\n-\n-        SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n-\n-        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-\n-        sslc = sslCtx;\n+        super();\n@@ -381,4 +329,2 @@\n-        boolean dataDone = false;\n-\n-        createSSLEngines();\n-        createBuffers();\n+        configureSSLEngine();\n+\/\/        createBuffers();\n@@ -393,1 +339,1 @@\n-    private void createSSLEngines() throws Exception {\n+    private void configureSSLEngine() throws Exception {\n@@ -398,1 +344,0 @@\n-        serverEngine = sslc.createSSLEngine();\n@@ -405,1 +350,0 @@\n-        clientEngine = sslc.createSSLEngine(\"client\", 80);\n@@ -416,78 +360,0 @@\n-    \/*\n-     * Create and size the buffers appropriately.\n-     *\/\n-    private void createBuffers() {\n-\n-        \/*\n-         * We'll assume the buffer sizes are the same\n-         * between client and server.\n-         *\/\n-        SSLSession session = clientEngine.getSession();\n-        int appBufferMax = session.getApplicationBufferSize();\n-        int netBufferMax = session.getPacketBufferSize();\n-\n-        \/*\n-         * We'll make the input buffers a bit bigger than the max needed\n-         * size, so that unwrap()s following a successful data transfer\n-         * won't generate BUFFER_OVERFLOWS.\n-         *\n-         * We'll use a mix of direct and indirect ByteBuffers for\n-         * tutorial purposes only.  In reality, only use direct\n-         * ByteBuffers when they give a clear performance enhancement.\n-         *\/\n-        clientIn = ByteBuffer.allocate(appBufferMax + 50);\n-        serverIn = ByteBuffer.allocate(appBufferMax + 50);\n-\n-        cTOs = ByteBuffer.allocateDirect(netBufferMax);\n-        sTOc = ByteBuffer.allocateDirect(netBufferMax);\n-\n-        clientOut = ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n-        serverOut = ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n-    }\n-\n-    \/*\n-     * If the result indicates that we have outstanding tasks to do,\n-     * go ahead and run them in this thread.\n-     *\/\n-    private static void runDelegatedTasks(SSLEngineResult result,\n-            SSLEngine engine) throws Exception {\n-\n-        if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n-            Runnable runnable;\n-            while ((runnable = engine.getDelegatedTask()) != null) {\n-                log(\"\\trunning delegated task...\");\n-                runnable.run();\n-            }\n-            HandshakeStatus hsStatus = engine.getHandshakeStatus();\n-            if (hsStatus == HandshakeStatus.NEED_TASK) {\n-                throw new Exception(\n-                    \"handshake shouldn't need additional tasks\");\n-            }\n-            log(\"\\tnew HandshakeStatus: \" + hsStatus);\n-        }\n-    }\n-\n-    private static boolean isEngineClosed(SSLEngine engine) {\n-        return (engine.isOutboundDone() && engine.isInboundDone());\n-    }\n-\n-    \/*\n-     * Simple check to make sure everything came across as expected.\n-     *\/\n-    private static void checkTransfer(ByteBuffer a, ByteBuffer b)\n-            throws Exception {\n-        a.flip();\n-        b.flip();\n-\n-        if (!a.equals(b)) {\n-            throw new Exception(\"Data didn't transfer cleanly\");\n-        } else {\n-            log(\"\\tData transferred cleanly\");\n-        }\n-\n-        a.position(a.limit());\n-        b.position(b.limit());\n-        a.limit(a.capacity());\n-        b.limit(b.capacity());\n-    }\n-\n","filename":"test\/jdk\/sun\/security\/ssl\/ClientHandshaker\/LengthCheckTest.java","additions":16,"deletions":150,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @library \/javax\/net\/ssl\/templates\n@@ -125,1 +126,0 @@\n-import java.io.*;\n@@ -127,2 +127,0 @@\n-import java.security.KeyStore;\n-import java.security.KeyFactory;\n@@ -130,5 +128,0 @@\n-import java.security.cert.Certificate;\n-import java.security.cert.CertificateFactory;\n-import java.security.spec.PKCS8EncodedKeySpec;\n-import java.security.interfaces.*;\n-import java.util.Base64;\n@@ -136,1 +129,1 @@\n-public class DHEKeySizing {\n+public class DHEKeySizing extends SSLEngineTemplate {\n@@ -148,83 +141,0 @@\n-    private SSLContext sslc;\n-    private SSLEngine ssle1;    \/\/ client\n-    private SSLEngine ssle2;    \/\/ server\n-\n-    private ByteBuffer appOut1;         \/\/ write side of ssle1\n-    private ByteBuffer appIn1;          \/\/ read side of ssle1\n-    private ByteBuffer appOut2;         \/\/ write side of ssle2\n-    private ByteBuffer appIn2;          \/\/ read side of ssle2\n-\n-    private ByteBuffer oneToTwo;        \/\/ \"reliable\" transport ssle1->ssle2\n-    private ByteBuffer twoToOne;        \/\/ \"reliable\" transport ssle2->ssle1\n-\n-    \/*\n-     * Where do we find the keystores?\n-     *\/\n-    \/\/ Certificates and key used in the test.\n-    static String trustedCertStr =\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIIC8jCCAdqgAwIBAgIEUjkuRzANBgkqhkiG9w0BAQUFADA7MR0wGwYDVQQLExRT\\n\" +\n-        \"dW5KU1NFIFRlc3QgU2VyaXZjZTENMAsGA1UEChMESmF2YTELMAkGA1UEBhMCVVMw\\n\" +\n-        \"HhcNMTMwOTE4MDQzODMxWhcNMTMxMjE3MDQzODMxWjA7MR0wGwYDVQQLExRTdW5K\\n\" +\n-        \"U1NFIFRlc3QgU2VyaXZjZTENMAsGA1UEChMESmF2YTELMAkGA1UEBhMCVVMwggEi\\n\" +\n-        \"MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCO+IGeaskJAvEcYc7pCl9neK3E\\n\" +\n-        \"a28fwWLtChufYNaC9hQfZlUdETWYjV7fZJVJKT\/oLzdDNMWuVA0LKXArpI3thLNK\\n\" +\n-        \"QLXisdF9hKPlZRDazACL9kWUUtJ0FzpEySK4e8wW\/z9FuU6e6iO19FbjxAfInJqk\\n\" +\n-        \"3EDiEhB5g73S2vtvPCxgq2DvWw9TDl\/LIqdKG2JCS93koXCCaHmQ7MrIOqHPd+8r\\n\" +\n-        \"RbGpatXT9qyHKppUv9ATxVygO4rA794mgCFxpT+fkhz+NEB0twTkM65T1hnnOv5n\\n\" +\n-        \"ZIxkcjBggt85UlZtnP3b9P7SYxsWIa46Oc38Od2f3YejfVg6B+PqPgWNl3+\/AgMB\\n\" +\n-        \"AAEwDQYJKoZIhvcNAQEFBQADggEBAAlrP6DFLRPSy0IgQhcI2i56tR\/na8pezSte\\n\" +\n-        \"ZHcCdaCZPDy4UP8mpLJ9QCjEB5VJv8hPm4xdK7ULnKGOGHgYqDpV2ZHvQlhV1woQ\\n\" +\n-        \"TZGb\/LM3c6kAs0j4j9KM2fq3iYUYexjIkS1KzsziflxMM6igS9BRMBR2LQyU+cYq\\n\" +\n-        \"YEsFzkF7Aj2ET4v\/+tgot9mRr2NioJcaJkdsPDpMU3IKB1cczfu+OuLQ\/GCG0Fqu\\n\" +\n-        \"6ijCeCqfnaAbemHbJeVZZ6Qgka3uC2YMntLBmLkhqEo1d9zGYLoh7oWL77y5ibQZ\\n\" +\n-        \"LK5\/H\/zikcu579TWjlDHcqL3arCwBcrtsjSaPrRSWMrWV\/6c0qw=\\n\" +\n-        \"-----END CERTIFICATE-----\";\n-\n-    \/\/ Private key in the format of PKCS#8\n-    static String targetPrivateKey =\n-        \"MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCO+IGeaskJAvEc\\n\" +\n-        \"Yc7pCl9neK3Ea28fwWLtChufYNaC9hQfZlUdETWYjV7fZJVJKT\/oLzdDNMWuVA0L\\n\" +\n-        \"KXArpI3thLNKQLXisdF9hKPlZRDazACL9kWUUtJ0FzpEySK4e8wW\/z9FuU6e6iO1\\n\" +\n-        \"9FbjxAfInJqk3EDiEhB5g73S2vtvPCxgq2DvWw9TDl\/LIqdKG2JCS93koXCCaHmQ\\n\" +\n-        \"7MrIOqHPd+8rRbGpatXT9qyHKppUv9ATxVygO4rA794mgCFxpT+fkhz+NEB0twTk\\n\" +\n-        \"M65T1hnnOv5nZIxkcjBggt85UlZtnP3b9P7SYxsWIa46Oc38Od2f3YejfVg6B+Pq\\n\" +\n-        \"PgWNl3+\/AgMBAAECggEAPdb5Ycc4m4A9QBSCRcRpzbyiFLKPh0HDg1n65q4hOtYr\\n\" +\n-        \"kAVYTVFTSF\/lqGS+Ob3w2YIKujQKSUQrvCc5UHdFuHXMgxKIWbymK0+DAMb9SlYw\\n\" +\n-        \"6lkkcWp9gx9E4dnJ\/df2SAAxovvrKMuHlL1SFASHhVtPfH2URvSfUaANLDXxyYOs\\n\" +\n-        \"8BX0Nr6wazhWjLjXo9yIGnKSvFfB8XisYcA78kEgas43zhmIGCDPqaYyyffOfRbx\\n\" +\n-        \"pM1KNwGmlN86iWR1CbwA\/wwhcMySWQueS+s7cHbpRqZIYJF9jEeELiwi0vxjealS\\n\" +\n-        \"EMuHYedIRFMWaDIq9XyjrvXamHb0Z25jlXBNZHaM0QKBgQDE9adl+zAezR\/n79vw\\n\" +\n-        \"0XiX2Fx1UEo3ApZHuoA2Q\/PcBk+rlKqqQ3IwTcy6Wo648wK7v6Nq7w5nEWcsf0dU\\n\" +\n-        \"QA2Ng\/AJEev\/IfF34x7sKGYxtk1gcE0EuSBA3R+ocEZxnNw1Ryd5nUU24s8d4jCP\\n\" +\n-        \"Mkothnyaim+zE2raDlEtVc0CaQKBgQC509av+02Uq5oMjzbQp5PBJfQFjATOQT15\\n\" +\n-        \"eefYnVYurkQ1kcVfixkrO2ORhg4SjmI2Z5hJDgGtXdwgidpzkad+R2epS5qLMyno\\n\" +\n-        \"lQVpY6bMpEZ7Mos0yQygxnm8uNohEcTExOe+nP5fNJVpzBsGmfeyYOhnPQlf6oqf\\n\" +\n-        \"0cHizedb5wKBgQC\/l5LyMil6HOGHlhzmIm3jj7VI7QR0hJC5T6N+phVml8ESUDjA\\n\" +\n-        \"DYHbmSKouISTRtkG14FY+RiSjCxH7bvuKazFV2289PETquogTA\/9e8MFYqfcQwG4\\n\" +\n-        \"sXi9gBxWlnj\/9a2EKiYtOB5nKLR\/BlNkSHA93tAA6N+FXEMZwMmYhxk42QKBgAuY\\n\" +\n-        \"HQgD3PZOsqDf+qKQIhbmAFCsSMx5o5VFtuJ8BpmJA\/Z3ruHkMuDQpsi4nX4o5hXQ\\n\" +\n-        \"5t6AAjjH52kcUMXvK40kdWJJtk3DFnVNfvXxYsHX6hHbuHXFqYUKfSP6QJnZmvZP\\n\" +\n-        \"9smcz\/4usLfWJUWHK740b6upUkFqx9Vq5\/b3s9y3AoGAdM5TW7LkkOFsdMGVAUzR\\n\" +\n-        \"9iXmCWElHTK2Pcp\/3yqDBHSfiQx6Yp5ANyPnE9NBM0yauCfOyBB2oxLO4Rdv3Rqk\\n\" +\n-        \"9V9kyR\/YAGr7dJaPcQ7pZX0OpkzgueAOJYPrx5VUzPYUtklYV1ycFZTfKlpFCxT+\\n\" +\n-        \"Ei6KUo0NXSdUIcB4yib1J10=\";\n-\n-    static char passphrase[] = \"passphrase\".toCharArray();\n-\n-    \/*\n-     * Majority of the test case is here, setup is done below.\n-     *\/\n-\n-    private void createSSLEngines() throws Exception {\n-        ssle1 = sslc.createSSLEngine(\"client\", 1);\n-        ssle1.setUseClientMode(true);\n-\n-        ssle2 = sslc.createSSLEngine(\"server\", 2);\n-        ssle2.setUseClientMode(false);\n-    }\n-\n-    private boolean isHandshaking(SSLEngine e) {\n-        return (e.getHandshakeStatus() != HandshakeStatus.NOT_HANDSHAKING);\n-    }\n-\n@@ -271,5 +181,2 @@\n-        createSSLEngines();\n-        createBuffers();\n-\n-        SSLEngineResult result1;        \/\/ ssle1's results from last operation\n-        SSLEngineResult result2;        \/\/ ssle2's results from last operation\n+        SSLEngineResult result1;        \/\/ clientEngine's results from last operation\n+        SSLEngineResult result2;        \/\/ serverEngine's results from last operation\n@@ -279,2 +186,2 @@\n-        ssle1.setEnabledCipherSuites(suites);\n-        ssle2.setEnabledCipherSuites(suites);\n+        clientEngine.setEnabledCipherSuites(suites);\n+        serverEngine.setEnabledCipherSuites(suites);\n@@ -285,2 +192,2 @@\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n+        result1 = clientEngine.wrap(clientOut, cTOs);\n+        checkResult(clientOut, cTOs, result1,\n@@ -288,1 +195,1 @@\n-        oneToTwo.flip();\n+        cTOs.flip();\n@@ -290,2 +197,2 @@\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-        checkResult(oneToTwo, appIn2, result2,\n+        result2 = serverEngine.unwrap(cTOs, serverIn);\n+        checkResult(cTOs, serverIn, result2,\n@@ -293,2 +200,2 @@\n-        runDelegatedTasks(ssle2);\n-        oneToTwo.compact();\n+        runDelegatedTasks(serverEngine);\n+        cTOs.compact();\n@@ -298,2 +205,2 @@\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n+        result2 = serverEngine.wrap(serverOut, sTOc);\n+        checkResult(serverOut, sTOc, result2,\n@@ -301,1 +208,1 @@\n-        twoToOne.flip();\n+        sTOc.flip();\n@@ -303,3 +210,3 @@\n-        log(\"Message length of ServerHello series: \" + twoToOne.remaining());\n-        if (twoToOne.remaining() < (lenServerKeyEx - KEY_LEN_BIAS) ||\n-                twoToOne.remaining() > lenServerKeyEx) {\n+        log(\"Message length of ServerHello series: \" + sTOc.remaining());\n+        if (sTOc.remaining() < (lenServerKeyEx - KEY_LEN_BIAS) ||\n+                sTOc.remaining() > lenServerKeyEx) {\n@@ -308,1 +215,1 @@\n-                lenServerKeyEx + \" bytes, but not \" + twoToOne.remaining());\n+                lenServerKeyEx + \" bytes, but not \" + sTOc.remaining());\n@@ -311,2 +218,2 @@\n-        result1 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result1,\n+        result1 = clientEngine.unwrap(sTOc, clientIn);\n+        checkResult(sTOc, clientIn, result1,\n@@ -314,2 +221,2 @@\n-        runDelegatedTasks(ssle1);\n-        twoToOne.compact();\n+        runDelegatedTasks(clientEngine);\n+        sTOc.compact();\n@@ -319,2 +226,2 @@\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n+        result1 = clientEngine.wrap(clientOut, cTOs);\n+        checkResult(clientOut, cTOs, result1,\n@@ -322,1 +229,1 @@\n-        oneToTwo.flip();\n+        cTOs.flip();\n@@ -324,3 +231,3 @@\n-        log(\"Message length of ClientKeyExchange: \" + oneToTwo.remaining());\n-        if (oneToTwo.remaining() < (lenClientKeyEx - KEY_LEN_BIAS) ||\n-                oneToTwo.remaining() > lenClientKeyEx) {\n+        log(\"Message length of ClientKeyExchange: \" + cTOs.remaining());\n+        if (cTOs.remaining() < (lenClientKeyEx - KEY_LEN_BIAS) ||\n+                cTOs.remaining() > lenClientKeyEx) {\n@@ -329,1 +236,1 @@\n-                lenClientKeyEx + \" bytes, but not \" + oneToTwo.remaining());\n+                lenClientKeyEx + \" bytes, but not \" + cTOs.remaining());\n@@ -331,2 +238,2 @@\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-        checkResult(oneToTwo, appIn2, result2,\n+        result2 = serverEngine.unwrap(cTOs, serverIn);\n+        checkResult(cTOs, serverIn, result2,\n@@ -334,2 +241,2 @@\n-        runDelegatedTasks(ssle2);\n-        oneToTwo.compact();\n+        runDelegatedTasks(serverEngine);\n+        cTOs.compact();\n@@ -339,2 +246,2 @@\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n+        result1 = clientEngine.wrap(clientOut, cTOs);\n+        checkResult(clientOut, cTOs, result1,\n@@ -342,1 +249,1 @@\n-        oneToTwo.flip();\n+        cTOs.flip();\n@@ -344,2 +251,2 @@\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-        checkResult(oneToTwo, appIn2, result2,\n+        result2 = serverEngine.unwrap(cTOs, serverIn);\n+        checkResult(cTOs, serverIn, result2,\n@@ -348,1 +255,1 @@\n-        oneToTwo.compact();\n+        cTOs.compact();\n@@ -352,2 +259,2 @@\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        checkResult(appOut1, oneToTwo, result1,\n+        result1 = clientEngine.wrap(clientOut, cTOs);\n+        checkResult(clientOut, cTOs, result1,\n@@ -355,1 +262,1 @@\n-        oneToTwo.flip();\n+        cTOs.flip();\n@@ -357,2 +264,2 @@\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n-        checkResult(oneToTwo, appIn2, result2,\n+        result2 = serverEngine.unwrap(cTOs, serverIn);\n+        checkResult(cTOs, serverIn, result2,\n@@ -361,1 +268,1 @@\n-        oneToTwo.compact();\n+        cTOs.compact();\n@@ -365,2 +272,2 @@\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n+        result2 = serverEngine.wrap(serverOut, sTOc);\n+        checkResult(serverOut, sTOc, result2,\n@@ -368,1 +275,1 @@\n-        twoToOne.flip();\n+        sTOc.flip();\n@@ -370,2 +277,2 @@\n-        result1 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result1,\n+        result1 = clientEngine.unwrap(sTOc, clientIn);\n+        checkResult(sTOc, clientIn, result1,\n@@ -373,1 +280,1 @@\n-        twoToOne.compact();\n+        sTOc.compact();\n@@ -377,2 +284,2 @@\n-        result2 = ssle2.wrap(appOut2, twoToOne);\n-        checkResult(appOut2, twoToOne, result2,\n+        result2 = serverEngine.wrap(serverOut, sTOc);\n+        checkResult(serverOut, sTOc, result2,\n@@ -380,1 +287,1 @@\n-        twoToOne.flip();\n+        sTOc.flip();\n@@ -382,2 +289,2 @@\n-        result1 = ssle1.unwrap(twoToOne, appIn1);\n-        checkResult(twoToOne, appIn1, result1,\n+        result1 = clientEngine.unwrap(sTOc, clientIn);\n+        checkResult(sTOc, clientIn, result1,\n@@ -385,1 +292,1 @@\n-        twoToOne.compact();\n+        sTOc.compact();\n@@ -389,1 +296,1 @@\n-        String cs = ssle1.getSession().getCipherSuite();\n+        String cs = clientEngine.getSession().getCipherSuite();\n@@ -394,1 +301,1 @@\n-        cs = ssle2.getSession().getCipherSuite();\n+        cs = serverEngine.getSession().getCipherSuite();\n@@ -431,1 +338,1 @@\n-        sslc = getSSLContext();\n+        super();\n@@ -434,45 +341,5 @@\n-    \/*\n-     * Create an initialized SSLContext to use for this test.\n-     *\/\n-    private SSLContext getSSLContext() throws Exception {\n-\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        \/\/ create a key store\n-        KeyStore ts = KeyStore.getInstance(\"JKS\");\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        ts.load(null, null);\n-        ks.load(null, null);\n-\n-        \/\/ import the trused cert\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(trustedCertStr.getBytes());\n-        Certificate trusedCert = cf.generateCertificate(is);\n-        is.close();\n-        ts.setCertificateEntry(\"rsa-trusted-2048\", trusedCert);\n-\n-        \/\/ generate the private key.\n-        String keySpecStr = targetPrivateKey;\n-        PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(\n-                            Base64.getMimeDecoder().decode(keySpecStr));\n-        KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n-        RSAPrivateKey priKey = (RSAPrivateKey)kf.generatePrivate(priKeySpec);\n-\n-        Certificate[] chain = new Certificate[1];\n-        chain[0] = trusedCert;\n-\n-        \/\/ import the key entry.\n-        ks.setKeyEntry(\"rsa-key-2048\", priKey, passphrase, chain);\n-\n-        \/\/ create SSL context\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-        kmf.init(ks, passphrase);\n-\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-        tmf.init(ts);\n-\n-        SSLContext sslCtx = SSLContext.getInstance(\"TLSv1\");\n-        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-\n-        return sslCtx;\n+    @Override\n+    protected SSLEngine configureServerEngine(SSLEngine engine) {\n+        engine.setNeedClientAuth(false);\n+        engine.setUseClientMode(false);\n+        return engine;\n@@ -481,15 +348,5 @@\n-    private void createBuffers() {\n-        \/\/ Size the buffers as appropriate.\n-\n-        SSLSession session = ssle1.getSession();\n-        int appBufferMax = session.getApplicationBufferSize();\n-        int netBufferMax = session.getPacketBufferSize();\n-\n-        appIn1 = ByteBuffer.allocateDirect(appBufferMax + 50);\n-        appIn2 = ByteBuffer.allocateDirect(appBufferMax + 50);\n-\n-        oneToTwo = ByteBuffer.allocateDirect(netBufferMax);\n-        twoToOne = ByteBuffer.allocateDirect(netBufferMax);\n-\n-        appOut1 = ByteBuffer.wrap(\"Hi Engine2, I'm SSLEngine1\".getBytes());\n-        appOut2 = ByteBuffer.wrap(\"Hello Engine1, I'm SSLEngine2\".getBytes());\n+    @Override\n+    protected SSLContext createServerSSLContext() throws Exception {\n+        return createSSLContext(null, new Cert[]{Cert.CA_SHA1_RSA_2048},\n+                getServerContextParameters());\n+    }\n@@ -497,3 +354,4 @@\n-        log(\"AppOut1 = \" + appOut1);\n-        log(\"AppOut2 = \" + appOut2);\n-        log(\"\");\n+    @Override\n+    protected SSLContext createClientSSLContext() throws Exception {\n+        return createSSLContext(new Cert[]{Cert.CA_SHA1_RSA_2048}, null,\n+                getClientContextParameters());\n@@ -502,1 +360,4 @@\n-    private static void runDelegatedTasks(SSLEngine engine) throws Exception {\n+    @Override\n+    protected ContextParameters getClientContextParameters() {\n+        return new ContextParameters(\"TLSv1\", \"PKIX\", \"NewSunX509\");\n+    }\n@@ -504,5 +365,3 @@\n-        Runnable runnable;\n-        while ((runnable = engine.getDelegatedTask()) != null) {\n-            log(\"running delegated task...\");\n-            runnable.run();\n-        }\n+    @Override\n+    protected ContextParameters getServerContextParameters() {\n+        return new ContextParameters(\"TLSv1\", \"PKIX\", \"NewSunX509\");\n","filename":"test\/jdk\/sun\/security\/ssl\/DHKeyExchange\/DHEKeySizing.java","additions":83,"deletions":224,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/javax\/net\/ssl\/templates\n@@ -77,2 +77,0 @@\n-import java.io.*;\n-import java.security.*;\n@@ -85,1 +83,1 @@\n-public class DebugReportsOneExtraByte {\n+public class DebugReportsOneExtraByte extends SSLEngineTemplate {\n@@ -92,33 +90,0 @@\n-    private SSLContext sslc;\n-\n-    private SSLEngine clientEngine;     \/\/ client Engine\n-    private ByteBuffer clientOut;       \/\/ write side of clientEngine\n-    private ByteBuffer clientIn;        \/\/ read side of clientEngine\n-\n-    private SSLEngine serverEngine;     \/\/ server Engine\n-    private ByteBuffer serverOut;       \/\/ write side of serverEngine\n-    private ByteBuffer serverIn;        \/\/ read side of serverEngine\n-\n-    \/*\n-     * For data transport, this example uses local ByteBuffers.  This\n-     * isn't really useful, but the purpose of this example is to show\n-     * SSLEngine concepts, not how to do network transport.\n-     *\/\n-    private ByteBuffer cTOs;            \/\/ \"reliable\" transport client->server\n-    private ByteBuffer sTOc;            \/\/ \"reliable\" transport server->client\n-\n-    \/*\n-     * The following is to set up the keystores.\n-     *\/\n-    private static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    private static String keyStoreFile = \"keystore\";\n-    private static String trustStoreFile = \"truststore\";\n-    private static String passwd = \"passphrase\";\n-\n-    private static String keyFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-    private static String trustFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-\n@@ -150,0 +115,2 @@\n+        super();\n+    }\n@@ -151,10 +118,8 @@\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        KeyStore ts = KeyStore.getInstance(\"JKS\");\n-\n-        char[] passphrase = \"passphrase\".toCharArray();\n-\n-        ks.load(new FileInputStream(keyFilename), passphrase);\n-        ts.load(new FileInputStream(trustFilename), passphrase);\n-\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-        kmf.init(ks, passphrase);\n+    @Override\n+    protected SSLEngine configureServerEngine(SSLEngine serverEngine) {\n+        serverEngine.setUseClientMode(false);\n+        \/\/ Force a block-oriented ciphersuite.\n+        serverEngine.setEnabledCipherSuites(\n+                new String [] {\"TLS_RSA_WITH_AES_128_CBC_SHA\"});\n+        return serverEngine;\n+    }\n@@ -162,2 +127,4 @@\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-        tmf.init(ts);\n+    @Override\n+    protected ContextParameters getClientContextParameters() {\n+        return new ContextParameters(\"TLSv1\", \"PKIX\", \"NewSunX509\");\n+    }\n@@ -165,1 +132,4 @@\n-        SSLContext sslCtx = SSLContext.getInstance(\"TLSv1\");\n+    @Override\n+    protected ContextParameters getServerContextParameters() {\n+        return new ContextParameters(\"TLSv1\", \"PKIX\", \"NewSunX509\");\n+    }\n@@ -167,1 +137,6 @@\n-        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+    @Override\n+    protected ByteBuffer createClientOutputBuffer() {\n+        \/\/ No need to write anything on the client side, it will\n+        \/\/ just confuse the output.\n+        return ByteBuffer.wrap(\"\".getBytes());\n+    }\n@@ -169,1 +144,3 @@\n-        sslc = sslCtx;\n+    @Override\n+    protected ByteBuffer createServerOutputBuffer() {\n+        return ByteBuffer.wrap(\"Hi Client!\".getBytes());\n@@ -192,3 +169,0 @@\n-        createSSLEngines();\n-        createBuffers();\n-\n@@ -220,1 +194,1 @@\n-            runDelegatedTasks(clientResult, clientEngine);\n+            runDelegatedTasks(clientEngine);\n@@ -224,1 +198,1 @@\n-            runDelegatedTasks(serverResult, serverEngine);\n+            runDelegatedTasks(serverEngine);\n@@ -238,1 +212,1 @@\n-            runDelegatedTasks(clientResult, clientEngine);\n+            runDelegatedTasks(clientEngine);\n@@ -242,1 +216,1 @@\n-            runDelegatedTasks(serverResult, serverEngine);\n+            runDelegatedTasks(serverEngine);\n@@ -269,81 +243,0 @@\n-    \/*\n-     * Using the SSLContext created during object creation,\n-     * create\/configure the SSLEngines we'll use for this test.\n-     *\/\n-    private void createSSLEngines() throws Exception {\n-        \/*\n-         * Configure the serverEngine to act as a server in the SSL\/TLS\n-         * handshake.  Also, require SSL client authentication.\n-         *\/\n-        serverEngine = sslc.createSSLEngine();\n-        serverEngine.setUseClientMode(false);\n-        serverEngine.setNeedClientAuth(true);\n-\n-        \/\/ Force a block-oriented ciphersuite.\n-        serverEngine.setEnabledCipherSuites(\n-            new String [] {\"TLS_RSA_WITH_AES_128_CBC_SHA\"});\n-\n-        \/*\n-         * Similar to above, but using client mode instead.\n-         *\/\n-        clientEngine = sslc.createSSLEngine(\"client\", 80);\n-        clientEngine.setUseClientMode(true);\n-    }\n-\n-    \/*\n-     * Create and size the buffers appropriately.\n-     *\/\n-    private void createBuffers() {\n-\n-        \/*\n-         * We'll assume the buffer sizes are the same\n-         * between client and server.\n-         *\/\n-        SSLSession session = clientEngine.getSession();\n-        int appBufferMax = session.getApplicationBufferSize();\n-        int netBufferMax = session.getPacketBufferSize();\n-\n-        \/*\n-         * We'll make the input buffers a bit bigger than the max needed\n-         * size, so that unwrap()s following a successful data transfer\n-         * won't generate BUFFER_OVERFLOWS.\n-         *\n-         * We'll use a mix of direct and indirect ByteBuffers for\n-         * tutorial purposes only.  In reality, only use direct\n-         * ByteBuffers when they give a clear performance enhancement.\n-         *\/\n-        clientIn = ByteBuffer.allocate(appBufferMax + 50);\n-        serverIn = ByteBuffer.allocate(appBufferMax + 50);\n-\n-        cTOs = ByteBuffer.allocateDirect(netBufferMax);\n-        sTOc = ByteBuffer.allocateDirect(netBufferMax);\n-\n-        \/\/ No need to write anything on the client side, it will\n-        \/\/ just confuse the output.\n-        clientOut = ByteBuffer.wrap(\"\".getBytes());\n-        \/\/ 10 bytes long\n-        serverOut = ByteBuffer.wrap(\"Hi Client!\".getBytes());\n-    }\n-\n-    \/*\n-     * If the result indicates that we have outstanding tasks to do,\n-     * go ahead and run them in this thread.\n-     *\/\n-    private static void runDelegatedTasks(SSLEngineResult result,\n-            SSLEngine engine) throws Exception {\n-\n-        if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n-            Runnable runnable;\n-            while ((runnable = engine.getDelegatedTask()) != null) {\n-                log(\"\\trunning delegated task...\");\n-                runnable.run();\n-            }\n-            HandshakeStatus hsStatus = engine.getHandshakeStatus();\n-            if (hsStatus == HandshakeStatus.NEED_TASK) {\n-                throw new Exception(\n-                    \"handshake shouldn't need additional tasks\");\n-            }\n-            log(\"\\tnew HandshakeStatus: \" + hsStatus);\n-        }\n-    }\n-\n@@ -354,20 +247,0 @@\n-    \/*\n-     * Simple check to make sure everything came across as expected.\n-     *\/\n-    private static void checkTransfer(ByteBuffer a, ByteBuffer b)\n-            throws Exception {\n-        a.flip();\n-        b.flip();\n-\n-        if (!a.equals(b)) {\n-            throw new Exception(\"Data didn't transfer cleanly\");\n-        } else {\n-            log(\"\\tData transferred cleanly\");\n-        }\n-\n-        a.position(a.limit());\n-        b.position(b.limit());\n-        a.limit(a.capacity());\n-        b.limit(b.capacity());\n-    }\n-\n","filename":"test\/jdk\/sun\/security\/ssl\/EngineArgs\/DebugReportsOneExtraByte.java","additions":34,"deletions":161,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @library \/javax\/net\/ssl\/templates\n@@ -37,2 +38,0 @@\n-import java.net.*;\n-import java.security.*;\n@@ -41,1 +40,1 @@\n-public class NullCerts {\n+public class NullCerts extends SSLSocketTemplate {\n@@ -43,28 +42,1 @@\n-    \/*\n-     * =============================================================\n-     * Set the various variables needed for the tests, then\n-     * specify what tests to run on each side.\n-     *\/\n-\n-    \/*\n-     * Should we run the client or server in a separate thread?\n-     * Both sides can throw exceptions, but do you have a preference\n-     * as to which side should be the main thread.\n-     *\/\n-    private static boolean separateServerThread = true;\n-\n-    \/*\n-     * Where do we find the keystores?\n-     *\/\n-    private final static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    private final static String keyStoreFile = \"keystore\";\n-    private final static String trustStoreFile = \"truststore\";\n-    private final static String passwd = \"passphrase\";\n-    private final static char[] cpasswd = \"passphrase\".toCharArray();\n-\n-    \/*\n-     * Is the server ready to serve?\n-     *\/\n-    volatile static boolean serverReady = false;\n-\n-    \/*\n+     \/*\n@@ -84,0 +56,6 @@\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket socket) {\n+        socket.setNeedClientAuth(true);\n+        socket.setUseClientMode(false);\n+    }\n+\n@@ -90,17 +68,4 @@\n-    private void doServerSide() throws Exception {\n-        SSLServerSocketFactory sslssf =\n-            (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\n-        SSLServerSocket sslServerSocket =\n-            (SSLServerSocket) sslssf.createServerSocket(serverPort, 3);\n-        sslServerSocket.setNeedClientAuth(true);\n-\n-        serverPort = sslServerSocket.getLocalPort();\n-\n-        \/*\n-         * Signal Client, we're ready for his connect.\n-         *\/\n-        serverReady = true;\n-\n-        SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();\n-        InputStream sslIS = sslSocket.getInputStream();\n-        OutputStream sslOS = sslSocket.getOutputStream();\n+    @Override\n+    protected void runServerApplication(SSLSocket socket) throws Exception {\n+        InputStream sslIS = socket.getInputStream();\n+        OutputStream sslOS = socket.getOutputStream();\n@@ -118,1 +83,0 @@\n-        sslSocket.close();\n@@ -128,8 +92,2 @@\n-    private void doClientSide() throws Exception {\n-\n-        \/*\n-         * Wait for server to get started.\n-         *\/\n-        while (!serverReady) {\n-            Thread.sleep(50);\n-        }\n+    @Override\n+    protected void runClientApplication(SSLSocket sslSocket) throws Exception {\n@@ -139,19 +97,0 @@\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        KeyStore uks = KeyStore.getInstance(\"JKS\");\n-        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-\n-        uks.load(new FileInputStream(unknownFilename), cpasswd);\n-        kmf.init(uks, cpasswd);\n-\n-        ks.load(new FileInputStream(trustFilename), cpasswd);\n-        tmf.init(ks);\n-\n-        ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-\n-        SSLSocketFactory sslsf =\n-            (SSLSocketFactory) ctx.getSocketFactory();\n-        SSLSocket sslSocket = (SSLSocket)\n-            sslsf.createSocket(\"localhost\", serverPort);\n-\n@@ -166,1 +105,0 @@\n-            sslSocket.close();\n@@ -177,20 +115,5 @@\n-    \/*\n-     * =============================================================\n-     * The remainder is just support stuff\n-     *\/\n-\n-    \/\/ use any free port by default\n-    volatile int serverPort = 0;\n-\n-    private volatile Exception serverException = null;\n-    private volatile Exception clientException = null;\n-\n-    private final static String keyFilename =\n-        System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-        \"\/\" + keyStoreFile;\n-    private final static String trustFilename =\n-        System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-        \"\/\" + trustStoreFile;\n-    private final static String unknownFilename =\n-        System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-        \"\/\" + \"unknown_keystore\";\n+    @Override\n+    protected KeyManager createClientKeyManager() throws Exception {\n+        return createKeyManager(new Cert[]{Cert.DSA_SHA1_1024_EXPIRED},\n+                getClientContextParameters());\n+    }\n@@ -201,6 +124,0 @@\n-        String testRoot = System.getProperty(\"test.src\", \".\");\n-        System.setProperty(\"javax.net.ssl.keyStore\", keyFilename);\n-        System.setProperty(\"javax.net.ssl.keyStorePassword\", passwd);\n-        System.setProperty(\"javax.net.ssl.trustStore\", trustFilename);\n-        System.setProperty(\"javax.net.ssl.trustStorePassword\", passwd);\n-\n@@ -213,90 +130,1 @@\n-        new NullCerts();\n-    }\n-\n-    private Thread clientThread = null;\n-    private Thread serverThread = null;\n-\n-    \/*\n-     * Primary constructor, used to drive remainder of the test.\n-     *\n-     * Fork off the other side, then do your work.\n-     *\/\n-    NullCerts() throws Exception {\n-\n-        if (separateServerThread) {\n-            startServer(true);\n-            startClient(false);\n-        } else {\n-            startClient(true);\n-            startServer(false);\n-        }\n-\n-        \/*\n-         * Wait for other side to close down.\n-         *\/\n-        if (separateServerThread) {\n-            serverThread.join();\n-        } else {\n-            clientThread.join();\n-        }\n-\n-        \/*\n-         * When we get here, the test is pretty much over.\n-         *\n-         * If the main thread excepted, that propagates back\n-         * immediately.  If the other thread threw an exception, we\n-         * should report back.\n-         *\/\n-        if (serverException != null) {\n-            System.err.print(\"Server Exception:\");\n-            throw serverException;\n-        }\n-        if (clientException != null) {\n-            System.err.print(\"Client Exception:\");\n-            throw clientException;\n-        }\n-    }\n-\n-    private void startServer(boolean newThread) throws Exception {\n-        if (newThread) {\n-            serverThread = new Thread() {\n-                public void run() {\n-                    try {\n-                        doServerSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our server thread just died.\n-                         *\n-                         * Release the client, if not active already...\n-                         *\/\n-                        System.err.println(\"Server died...\");\n-                        serverReady = true;\n-                        serverException = e;\n-                    }\n-                }\n-            };\n-            serverThread.start();\n-        } else {\n-            doServerSide();\n-        }\n-    }\n-\n-    private void startClient(boolean newThread) throws Exception {\n-        if (newThread) {\n-            clientThread = new Thread() {\n-                public void run() {\n-                    try {\n-                        doClientSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our client thread just died.\n-                         *\/\n-                        System.err.println(\"Client died...\");\n-                        clientException = e;\n-                    }\n-                }\n-            };\n-            clientThread.start();\n-        } else {\n-            doClientSide();\n-        }\n+        new NullCerts().run();\n","filename":"test\/jdk\/sun\/security\/ssl\/HandshakeOutStream\/NullCerts.java","additions":21,"deletions":193,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+ * @library \/javax\/net\/ssl\/templates\n@@ -43,4 +44,0 @@\n-import javax.net.ssl.SSLEngineResult.*;\n-import java.io.*;\n-import java.security.*;\n-import java.nio.*;\n@@ -49,1 +46,1 @@\n-public class CloseEngineException {\n+public class CloseEngineException extends SSLEngineTemplate {\n@@ -53,36 +50,0 @@\n-    private SSLContext sslc;\n-    private SSLEngine ssle1;    \/\/ client\n-    private SSLEngine ssle2;    \/\/ server\n-\n-    private static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    private static String keyStoreFile = \"keystore\";\n-    private static String trustStoreFile = \"truststore\";\n-    private static String passwd = \"passphrase\";\n-\n-    private static String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-    private static String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-\n-    private ByteBuffer appOut1;         \/\/ write side of ssle1\n-    private ByteBuffer appIn1;          \/\/ read side of ssle1\n-    private ByteBuffer appOut2;         \/\/ write side of ssle2\n-    private ByteBuffer appIn2;          \/\/ read side of ssle2\n-\n-    private ByteBuffer oneToTwo;        \/\/ \"reliable\" transport ssle1->ssle2\n-    private ByteBuffer twoToOne;        \/\/ \"reliable\" transport ssle2->ssle1\n-\n-    \/*\n-     * Majority of the test case is here, setup is done below.\n-     *\/\n-    private void createSSLEngines() throws Exception {\n-        ssle1 = sslc.createSSLEngine(\"client\", 1);\n-        ssle1.setUseClientMode(true);\n-\n-        ssle2 = sslc.createSSLEngine();\n-        ssle2.setUseClientMode(false);\n-        ssle2.setNeedClientAuth(true);\n-    }\n-\n@@ -92,4 +53,1 @@\n-        createSSLEngines();\n-        createBuffers();\n-\n-        SSLEngineResult result1;        \/\/ ssle1's results from last operation\n+        SSLEngineResult result1;        \/\/ clientEngine's results from last operation\n@@ -98,1 +56,1 @@\n-        while (!isEngineClosed(ssle1) && !isEngineClosed(ssle2)) {\n+        while (!isEngineClosed(clientEngine) && !isEngineClosed(serverEngine)) {\n@@ -102,3 +60,3 @@\n-            if (!isEngineClosed(ssle1)) {\n-                result1 = ssle1.wrap(appOut1, oneToTwo);\n-                runDelegatedTasks(result1, ssle1);\n+            if (!isEngineClosed(clientEngine)) {\n+                result1 = clientEngine.wrap(clientOut, cTOs);\n+                runDelegatedTasks(clientEngine);\n@@ -107,1 +65,1 @@\n-                log(\"oneToTwo  = \" + oneToTwo);\n+                log(\"oneToTwo  = \" + cTOs);\n@@ -110,1 +68,1 @@\n-                oneToTwo.flip();\n+                cTOs.flip();\n@@ -112,3 +70,3 @@\n-            if (!isEngineClosed(ssle2)) {\n-                result2 = ssle2.wrap(appOut2, twoToOne);\n-                runDelegatedTasks(result2, ssle2);\n+            if (!isEngineClosed(serverEngine)) {\n+                result2 = serverEngine.wrap(serverOut, sTOc);\n+                runDelegatedTasks(serverEngine);\n@@ -117,1 +75,1 @@\n-                log(\"twoToOne  = \" + twoToOne);\n+                log(\"twoToOne  = \" + sTOc);\n@@ -119,1 +77,1 @@\n-                twoToOne.flip();\n+                sTOc.flip();\n@@ -124,1 +82,1 @@\n-            if (!isEngineClosed(ssle1) && !dataDone) {\n+            if (!isEngineClosed(clientEngine) && !dataDone) {\n@@ -126,2 +84,2 @@\n-                result1 = ssle1.unwrap(twoToOne, appIn1);\n-                runDelegatedTasks(result1, ssle1);\n+                result1 = clientEngine.unwrap(sTOc, clientIn);\n+                runDelegatedTasks(clientEngine);\n@@ -130,1 +88,1 @@\n-                log(\"twoToOne  = \" + twoToOne);\n+                log(\"twoToOne  = \" + sTOc);\n@@ -133,1 +91,1 @@\n-                twoToOne.compact();\n+                sTOc.compact();\n@@ -135,1 +93,1 @@\n-            if (!isEngineClosed(ssle2)) {\n+            if (!isEngineClosed(serverEngine)) {\n@@ -137,2 +95,2 @@\n-                result2 = ssle2.unwrap(oneToTwo, appIn2);\n-                runDelegatedTasks(result2, ssle2);\n+                result2 = serverEngine.unwrap(cTOs, serverIn);\n+                runDelegatedTasks(serverEngine);\n@@ -141,1 +99,1 @@\n-                log(\"oneToTwo  = \" + oneToTwo);\n+                log(\"oneToTwo  = \" + cTOs);\n@@ -143,1 +101,1 @@\n-                oneToTwo.compact();\n+                cTOs.compact();\n@@ -150,2 +108,2 @@\n-            if (!dataDone && (appOut1.limit() == appIn2.position()) &&\n-                    (appOut2.limit() == appIn1.position())) {\n+            if (!dataDone && (clientOut.limit() == serverIn.position()) &&\n+                    (serverOut.limit() == clientIn.position())) {\n@@ -153,2 +111,2 @@\n-                checkTransfer(appOut1, appIn2);\n-                checkTransfer(appOut2, appIn1);\n+                checkTransfer(clientOut, serverIn);\n+                checkTransfer(serverOut, clientIn);\n@@ -156,2 +114,2 @@\n-                log(\"Closing ssle1's *OUTBOUND*...\");\n-                ssle1.closeOutbound();\n+                log(\"Closing clientEngine's *OUTBOUND*...\");\n+                clientEngine.closeOutbound();\n@@ -164,1 +122,1 @@\n-                    ssle1.beginHandshake();\n+                    clientEngine.beginHandshake();\n@@ -177,1 +135,1 @@\n-            ssle2.beginHandshake();\n+            serverEngine.beginHandshake();\n@@ -187,6 +145,1 @@\n-        CloseEngineException test;\n-\n-        test = new CloseEngineException();\n-\n-        test.createSSLEngines();\n-\n+        CloseEngineException test = new CloseEngineException();\n@@ -205,1 +158,1 @@\n-        sslc = getSSLContext(keyFilename, trustFilename);\n+        super();\n@@ -208,58 +161,5 @@\n-    \/*\n-     * Create an initialized SSLContext to use for this test.\n-     *\/\n-    private SSLContext getSSLContext(String keyFile, String trustFile)\n-            throws Exception {\n-\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        KeyStore ts = KeyStore.getInstance(\"JKS\");\n-\n-        char[] passphrase = \"passphrase\".toCharArray();\n-\n-        ks.load(new FileInputStream(keyFile), passphrase);\n-        ts.load(new FileInputStream(trustFile), passphrase);\n-\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-        kmf.init(ks, passphrase);\n-\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-        tmf.init(ts);\n-\n-        SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n-\n-        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-\n-        return sslCtx;\n-    }\n-\n-    private void createBuffers() {\n-        \/\/ Size the buffers as appropriate.\n-\n-        SSLSession session = ssle1.getSession();\n-        int appBufferMax = session.getApplicationBufferSize();\n-        int netBufferMax = session.getPacketBufferSize();\n-\n-        appIn1 = ByteBuffer.allocateDirect(appBufferMax + 50);\n-        appIn2 = ByteBuffer.allocateDirect(appBufferMax + 50);\n-\n-        oneToTwo = ByteBuffer.allocateDirect(netBufferMax);\n-        twoToOne = ByteBuffer.allocateDirect(netBufferMax);\n-\n-        appOut1 = ByteBuffer.wrap(\"Hi Engine2, I'm SSLEngine1\".getBytes());\n-        appOut2 = ByteBuffer.wrap(\"Hello Engine1, I'm SSLEngine2\".getBytes());\n-\n-        log(\"AppOut1 = \" + appOut1);\n-        log(\"AppOut2 = \" + appOut2);\n-        log(\"\");\n-    }\n-\n-    private static void runDelegatedTasks(SSLEngineResult result,\n-            SSLEngine engine) throws Exception {\n-\n-        if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n-            Runnable runnable;\n-            while ((runnable = engine.getDelegatedTask()) != null) {\n-                log(\"running delegated task...\");\n-                runnable.run();\n-            }\n-        }\n+    @Override\n+    protected SSLEngine configureServerEngine(SSLEngine engine) {\n+        engine.setUseClientMode(false);\n+        engine.setNeedClientAuth(true);\n+        return engine;\n@@ -272,17 +172,0 @@\n-    private static void checkTransfer(ByteBuffer a, ByteBuffer b)\n-            throws Exception {\n-        a.flip();\n-        b.flip();\n-\n-        if (!a.equals(b)) {\n-            throw new Exception(\"Data didn't transfer cleanly\");\n-        } else {\n-            log(\"Data transferred cleanly\");\n-        }\n-\n-        a.position(a.limit());\n-        b.position(b.limit());\n-        a.limit(a.capacity());\n-        b.limit(b.capacity());\n-    }\n-\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLEngineImpl\/CloseEngineException.java","additions":40,"deletions":157,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @library \/javax\/net\/ssl\/templates\n@@ -41,4 +42,0 @@\n-import javax.net.ssl.SSLEngineResult.*;\n-import java.io.*;\n-import java.security.*;\n-import java.nio.*;\n@@ -46,15 +43,1 @@\n-public class CloseStart {\n-\n-    private static boolean debug = false;\n-\n-    private static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    private static String keyStoreFile = \"keystore\";\n-    private static String trustStoreFile = \"truststore\";\n-    private static String passwd = \"passphrase\";\n-\n-    private static String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-    private static String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n+public class CloseStart extends SSLContextTemplate {\n@@ -77,0 +60,2 @@\n+        new CloseStart().run();\n+    }\n@@ -78,1 +63,2 @@\n-        SSLEngine ssle = createSSLEngine(keyFilename, trustFilename);\n+    private void run() throws Exception {\n+        SSLEngine ssle = createSSLEngine();\n@@ -84,1 +70,1 @@\n-        ssle = createSSLEngine(keyFilename, trustFilename);\n+        ssle = createSSLEngine();\n@@ -96,22 +82,1 @@\n-    static private SSLEngine createSSLEngine(String keyFile, String trustFile)\n-            throws Exception {\n-\n-        SSLEngine ssle;\n-\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        KeyStore ts = KeyStore.getInstance(\"JKS\");\n-\n-        char[] passphrase = \"passphrase\".toCharArray();\n-\n-        ks.load(new FileInputStream(keyFile), passphrase);\n-        ts.load(new FileInputStream(trustFile), passphrase);\n-\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-        kmf.init(ks, passphrase);\n-\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-        tmf.init(ts);\n-\n-        SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n-\n-        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+    private SSLEngine createSSLEngine() throws Exception {\n@@ -119,1 +84,2 @@\n-        ssle = sslCtx.createSSLEngine(\"client\", 1001);\n+        SSLContext sslCtx = createClientSSLContext();\n+        SSLEngine ssle = sslCtx.createSSLEngine(\"client\", 1001);\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLEngineImpl\/CloseStart.java","additions":11,"deletions":45,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @library \/javax\/net\/ssl\/templates\n@@ -37,2 +38,0 @@\n-import javax.net.ssl.SSLEngineResult.*;\n-import java.io.*;\n@@ -40,1 +39,0 @@\n-import java.nio.*;\n@@ -42,1 +40,1 @@\n-public class DelegatedTaskWrongException {\n+public class DelegatedTaskWrongException extends SSLEngineTemplate {\n@@ -46,33 +44,6 @@\n-    private SSLContext sslc;\n-    private SSLEngine ssle1;    \/\/ client\n-    private SSLEngine ssle2;    \/\/ server\n-\n-    private static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    private static String keyStoreFile = \"keystore\";\n-    private static String trustStoreFile = \"truststore\";\n-    private static String passwd = \"passphrase\";\n-\n-    private static String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-    private static String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-\n-    private ByteBuffer appOut1;         \/\/ write side of ssle1\n-    private ByteBuffer appIn1;          \/\/ read side of ssle1\n-    private ByteBuffer appOut2;         \/\/ write side of ssle2\n-    private ByteBuffer appIn2;          \/\/ read side of ssle2\n-\n-    private ByteBuffer oneToTwo;        \/\/ \"reliable\" transport ssle1->ssle2\n-    private ByteBuffer twoToOne;        \/\/ \"reliable\" transport ssle2->ssle1\n-\n-    \/*\n-     * Majority of the test case is here, setup is done below.\n-     *\/\n-    private void createSSLEngines() throws Exception {\n-        ssle1 = sslc.createSSLEngine(\"client\", 1);\n-        ssle1.setUseClientMode(true);\n-\n-        ssle2 = sslc.createSSLEngine();\n-        ssle2.setUseClientMode(false);\n+    @Override\n+    protected SSLEngine configureServerEngine(SSLEngine engine) {\n+        engine.setUseClientMode(false);\n+        engine.setEnabledProtocols(new String [] { \"TLSv1\" });\n+        return engine;\n+    }\n@@ -80,2 +51,5 @@\n-        ssle1.setEnabledProtocols(new String [] { \"SSLv3\" });\n-        ssle2.setEnabledProtocols(new String [] { \"TLSv1\" });\n+    @Override\n+    protected SSLEngine configureClientEngine(SSLEngine engine) {\n+        engine.setUseClientMode(true);\n+        engine.setEnabledProtocols(new String [] { \"SSLv3\" });\n+        return engine;\n@@ -85,10 +59,0 @@\n-        boolean dataDone = false;\n-\n-        createSSLEngines();\n-        createBuffers();\n-\n-        SSLEngineResult result1;        \/\/ ssle1's results from last operation\n-        SSLEngineResult result2;        \/\/ ssle2's results from last operation\n-\n-        result1 = ssle1.wrap(appOut1, oneToTwo);\n-        oneToTwo.flip();\n@@ -96,1 +60,2 @@\n-        result2 = ssle2.unwrap(oneToTwo, appIn2);\n+        clientEngine.wrap(clientOut, cTOs);\n+        cTOs.flip();\n@@ -98,1 +63,2 @@\n-        runDelegatedTasks(result2, ssle2);\n+        serverEngine.unwrap(cTOs, serverIn);\n+        runDelegatedTasks(serverEngine);\n@@ -106,1 +72,1 @@\n-            result2 = ssle2.unwrap(oneToTwo, appIn2);\n+            serverEngine.unwrap(cTOs, serverIn);\n@@ -122,6 +88,1 @@\n-        DelegatedTaskWrongException test;\n-\n-        test = new DelegatedTaskWrongException();\n-\n-        test.createSSLEngines();\n-\n+        DelegatedTaskWrongException test = new DelegatedTaskWrongException();\n@@ -140,82 +101,1 @@\n-        sslc = getSSLContext(keyFilename, trustFilename);\n-    }\n-\n-    \/*\n-     * Create an initialized SSLContext to use for this test.\n-     *\/\n-    private SSLContext getSSLContext(String keyFile, String trustFile)\n-            throws Exception {\n-\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        KeyStore ts = KeyStore.getInstance(\"JKS\");\n-\n-        char[] passphrase = \"passphrase\".toCharArray();\n-\n-        ks.load(new FileInputStream(keyFile), passphrase);\n-        ts.load(new FileInputStream(trustFile), passphrase);\n-\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-        kmf.init(ks, passphrase);\n-\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-        tmf.init(ts);\n-\n-        SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n-\n-        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-\n-        return sslCtx;\n-    }\n-\n-    private void createBuffers() {\n-        \/\/ Size the buffers as appropriate.\n-\n-        SSLSession session = ssle1.getSession();\n-        int appBufferMax = session.getApplicationBufferSize();\n-        int netBufferMax = session.getPacketBufferSize();\n-\n-        appIn1 = ByteBuffer.allocateDirect(appBufferMax + 50);\n-        appIn2 = ByteBuffer.allocateDirect(appBufferMax + 50);\n-\n-        oneToTwo = ByteBuffer.allocateDirect(netBufferMax);\n-        twoToOne = ByteBuffer.allocateDirect(netBufferMax);\n-\n-        appOut1 = ByteBuffer.wrap(\"Hi Engine2, I'm SSLEngine1\".getBytes());\n-        appOut2 = ByteBuffer.wrap(\"Hello Engine1, I'm SSLEngine2\".getBytes());\n-\n-        log(\"AppOut1 = \" + appOut1);\n-        log(\"AppOut2 = \" + appOut2);\n-        log(\"\");\n-    }\n-\n-    private static void runDelegatedTasks(SSLEngineResult result,\n-            SSLEngine engine) throws Exception {\n-\n-        if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n-            Runnable runnable;\n-            while ((runnable = engine.getDelegatedTask()) != null) {\n-                log(\"running delegated task...\");\n-                runnable.run();\n-            }\n-        }\n-    }\n-\n-    private static boolean isEngineClosed(SSLEngine engine) {\n-        return (engine.isOutboundDone() && engine.isInboundDone());\n-    }\n-\n-    private static void checkTransfer(ByteBuffer a, ByteBuffer b)\n-            throws Exception {\n-        a.flip();\n-        b.flip();\n-\n-        if (!a.equals(b)) {\n-            throw new Exception(\"Data didn't transfer cleanly\");\n-        } else {\n-            log(\"Data transferred cleanly\");\n-        }\n-\n-        a.position(a.limit());\n-        b.position(b.limit());\n-        a.limit(a.capacity());\n-        b.limit(b.capacity());\n+        super();\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLEngineImpl\/DelegatedTaskWrongException.java","additions":21,"deletions":141,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/javax\/net\/ssl\/templates\n@@ -39,2 +39,0 @@\n-import java.io.*;\n-import java.security.*;\n@@ -45,1 +43,1 @@\n-public class EmptyExtensionData {\n+public class EmptyExtensionData extends SSLContextTemplate {\n@@ -49,22 +47,1 @@\n-    private static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    private static String keyStoreFile = \"keystore\";\n-    private static String trustStoreFile = \"truststore\";\n-    private static String passwd = \"passphrase\";\n-\n-    private static String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-    private static String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-\n-    private static void checkDone(SSLEngine ssle) throws Exception {\n-        if (!ssle.isInboundDone()) {\n-            throw new Exception(\"isInboundDone isn't done\");\n-        }\n-        if (!ssle.isOutboundDone()) {\n-            throw new Exception(\"isOutboundDone isn't done\");\n-        }\n-    }\n-\n-    private static void runTest(SSLEngine ssle) throws Exception {\n+    private void runTest(SSLEngine ssle) throws Exception {\n@@ -141,1 +118,1 @@\n-    private static void runDelegatedTasks(SSLEngineResult result,\n+    private void runDelegatedTasks(SSLEngineResult result,\n@@ -162,5 +139,1 @@\n-\n-        SSLEngine ssle = createSSLEngine(keyFilename, trustFilename);\n-        runTest(ssle);\n-\n-        System.out.println(\"Test Passed.\");\n+        new EmptyExtensionData().run();\n@@ -169,27 +142,2 @@\n-    \/*\n-     * Create an initialized SSLContext to use for this test.\n-     *\/\n-    static private SSLEngine createSSLEngine(String keyFile, String trustFile)\n-            throws Exception {\n-\n-        SSLEngine ssle;\n-\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        KeyStore ts = KeyStore.getInstance(\"JKS\");\n-\n-        char[] passphrase = \"passphrase\".toCharArray();\n-\n-        ks.load(new FileInputStream(keyFile), passphrase);\n-        ts.load(new FileInputStream(trustFile), passphrase);\n-\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-        kmf.init(ks, passphrase);\n-\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-        tmf.init(ts);\n-\n-        SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n-\n-        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-\n-        ssle = sslCtx.createSSLEngine();\n+    private void run() throws Exception {\n+        SSLEngine ssle = createServerSSLContext().createSSLEngine();\n@@ -197,0 +145,1 @@\n+        runTest(ssle);\n@@ -198,1 +147,1 @@\n-        return ssle;\n+        System.out.println(\"Test Passed.\");\n@@ -201,1 +150,0 @@\n-\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLEngineImpl\/EmptyExtensionData.java","additions":10,"deletions":62,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @library \/javax\/net\/ssl\/templates\n@@ -38,4 +39,0 @@\n-import javax.net.ssl.SSLEngineResult.*;\n-import java.io.*;\n-import java.security.*;\n-import java.nio.*;\n@@ -43,1 +40,1 @@\n-public class EngineEnforceUseClientMode {\n+public class EngineEnforceUseClientMode extends SSLEngineTemplate {\n@@ -47,27 +44,3 @@\n-    private SSLContext sslc;\n-    private SSLEngine ssle1;    \/\/ client\n-    private SSLEngine ssle2;    \/\/ server\n-\n-    private SSLEngine ssle3;    \/\/ server\n-    private SSLEngine ssle4;    \/\/ server\n-    private SSLEngine ssle5;    \/\/ server\n-\n-    private static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    private static String keyStoreFile = \"keystore\";\n-    private static String trustStoreFile = \"truststore\";\n-    private static String passwd = \"passphrase\";\n-\n-    private static String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-    private static String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-\n-    private ByteBuffer appOut1;         \/\/ write side of ssle1\n-    private ByteBuffer appIn1;          \/\/ read side of ssle1\n-    private ByteBuffer appOut2;         \/\/ write side of ssle2\n-    private ByteBuffer appIn2;          \/\/ read side of ssle2\n-\n-    private ByteBuffer oneToTwo;        \/\/ \"reliable\" transport ssle1->ssle2\n-    private ByteBuffer twoToOne;        \/\/ \"reliable\" transport ssle2->ssle1\n+    private SSLEngine serverEngine2;    \/\/ server\n+    private SSLEngine serverEngine3;    \/\/ server\n+    private SSLEngine serverEngine4;    \/\/ server\n@@ -78,8 +51,2 @@\n-    private void createSSLEngines() throws Exception {\n-        ssle1 = sslc.createSSLEngine(\"client\", 1);\n-        ssle1.setUseClientMode(true);\n-\n-        ssle2 = sslc.createSSLEngine();\n-        ssle2.setUseClientMode(false);\n-        ssle2.setNeedClientAuth(true);\n-\n+    private void createAdditionalSSLEngines() throws Exception {\n+        SSLContext sslc = createServerSSLContext();\n@@ -89,3 +56,3 @@\n-        ssle3 = sslc.createSSLEngine();\n-        ssle4 = sslc.createSSLEngine();\n-        ssle5 = sslc.createSSLEngine();\n+        serverEngine2 = sslc.createSSLEngine();\n+        serverEngine3 = sslc.createSSLEngine();\n+        serverEngine4 = sslc.createSSLEngine();\n@@ -93,1 +60,1 @@\n-        if (ssle5.getUseClientMode()) {\n+        if (serverEngine4.getUseClientMode()) {\n@@ -101,2 +68,1 @@\n-        createSSLEngines();\n-        createBuffers();\n+        createAdditionalSSLEngines();\n@@ -110,1 +76,1 @@\n-            ssle3.wrap(appOut1, oneToTwo);\n+            serverEngine2.wrap(clientOut, cTOs);\n@@ -115,2 +81,2 @@\n-            oneToTwo.flip();\n-            if (oneToTwo.hasRemaining()) {\n+            cTOs.flip();\n+            if (cTOs.hasRemaining()) {\n@@ -119,1 +85,1 @@\n-            oneToTwo.clear();\n+            cTOs.clear();\n@@ -124,1 +90,1 @@\n-            ssle4.unwrap(oneToTwo, appIn1);\n+            serverEngine3.unwrap(cTOs, clientIn);\n@@ -129,2 +95,2 @@\n-            appIn1.flip();\n-            if (appIn1.hasRemaining()) {\n+            clientIn.flip();\n+            if (clientIn.hasRemaining()) {\n@@ -133,1 +99,1 @@\n-            appIn1.clear();\n+            clientIn.clear();\n@@ -138,1 +104,1 @@\n-            ssle5.beginHandshake();\n+            serverEngine4.beginHandshake();\n@@ -150,1 +116,1 @@\n-        while (!isEngineClosed(ssle1) || !isEngineClosed(ssle2)) {\n+        while (!isEngineClosed(clientEngine) || !isEngineClosed(serverEngine)) {\n@@ -154,2 +120,2 @@\n-            result1 = ssle1.wrap(appOut1, oneToTwo);\n-            result2 = ssle2.wrap(appOut2, twoToOne);\n+            result1 = clientEngine.wrap(clientOut, cTOs);\n+            result2 = serverEngine.wrap(serverOut, sTOc);\n@@ -158,1 +124,1 @@\n-            log(\"oneToTwo  = \" + oneToTwo);\n+            log(\"oneToTwo  = \" + cTOs);\n@@ -162,1 +128,1 @@\n-            log(\"twoToOne  = \" + twoToOne);\n+            log(\"twoToOne  = \" + sTOc);\n@@ -164,2 +130,2 @@\n-            runDelegatedTasks(result1, ssle1);\n-            runDelegatedTasks(result2, ssle2);\n+            runDelegatedTasks(clientEngine);\n+            runDelegatedTasks(serverEngine);\n@@ -167,2 +133,2 @@\n-            oneToTwo.flip();\n-            twoToOne.flip();\n+            cTOs.flip();\n+            sTOc.flip();\n@@ -172,2 +138,2 @@\n-            result1 = ssle1.unwrap(twoToOne, appIn1);\n-            result2 = ssle2.unwrap(oneToTwo, appIn2);\n+            result1 = clientEngine.unwrap(sTOc, clientIn);\n+            result2 = serverEngine.unwrap(cTOs, serverIn);\n@@ -176,1 +142,1 @@\n-            log(\"twoToOne  = \" + twoToOne);\n+            log(\"twoToOne  = \" + sTOc);\n@@ -180,1 +146,1 @@\n-            log(\"oneToTwo  = \" + oneToTwo);\n+            log(\"oneToTwo  = \" + cTOs);\n@@ -182,2 +148,2 @@\n-            runDelegatedTasks(result1, ssle1);\n-            runDelegatedTasks(result2, ssle2);\n+            runDelegatedTasks(clientEngine);\n+            runDelegatedTasks(serverEngine);\n@@ -185,2 +151,2 @@\n-            oneToTwo.compact();\n-            twoToOne.compact();\n+            cTOs.compact();\n+            sTOc.compact();\n@@ -192,2 +158,2 @@\n-            if (!dataDone && (appOut1.limit() == appIn2.position()) &&\n-                    (appOut2.limit() == appIn1.position())) {\n+            if (!dataDone && (clientOut.limit() == serverIn.position()) &&\n+                    (serverOut.limit() == clientIn.position())) {\n@@ -195,2 +161,2 @@\n-                checkTransfer(appOut1, appIn2);\n-                checkTransfer(appOut2, appIn1);\n+                checkTransfer(clientOut, serverIn);\n+                checkTransfer(serverOut, clientIn);\n@@ -203,1 +169,1 @@\n-                        ssle2.setUseClientMode(b);\n+                        serverEngine.setUseClientMode(b);\n@@ -219,6 +185,2 @@\n-        EngineEnforceUseClientMode test;\n-\n-        test = new EngineEnforceUseClientMode();\n-\n-        test.createSSLEngines();\n-\n+        EngineEnforceUseClientMode test = new EngineEnforceUseClientMode();\n+        test.createAdditionalSSLEngines();\n@@ -237,61 +199,1 @@\n-        sslc = getSSLContext(keyFilename, trustFilename);\n-    }\n-\n-    \/*\n-     * Create an initialized SSLContext to use for this test.\n-     *\/\n-    private SSLContext getSSLContext(String keyFile, String trustFile)\n-            throws Exception {\n-\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        KeyStore ts = KeyStore.getInstance(\"JKS\");\n-\n-        char[] passphrase = \"passphrase\".toCharArray();\n-\n-        ks.load(new FileInputStream(keyFile), passphrase);\n-        ts.load(new FileInputStream(trustFile), passphrase);\n-\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-        kmf.init(ks, passphrase);\n-\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-        tmf.init(ts);\n-\n-        SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n-\n-        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-\n-        return sslCtx;\n-    }\n-\n-    private void createBuffers() {\n-        \/\/ Size the buffers as appropriate.\n-\n-        SSLSession session = ssle1.getSession();\n-        int appBufferMax = session.getApplicationBufferSize();\n-        int netBufferMax = session.getPacketBufferSize();\n-\n-        appIn1 = ByteBuffer.allocateDirect(appBufferMax + 50);\n-        appIn2 = ByteBuffer.allocateDirect(appBufferMax + 50);\n-\n-        oneToTwo = ByteBuffer.allocateDirect(netBufferMax);\n-        twoToOne = ByteBuffer.allocateDirect(netBufferMax);\n-\n-        appOut1 = ByteBuffer.wrap(\"Hi Engine2, I'm SSLEngine1\".getBytes());\n-        appOut2 = ByteBuffer.wrap(\"Hello Engine1, I'm SSLEngine2\".getBytes());\n-\n-        log(\"AppOut1 = \" + appOut1);\n-        log(\"AppOut2 = \" + appOut2);\n-        log(\"\");\n-    }\n-\n-    private static void runDelegatedTasks(SSLEngineResult result,\n-            SSLEngine engine) throws Exception {\n-\n-        if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n-            Runnable runnable;\n-            while ((runnable = engine.getDelegatedTask()) != null) {\n-                log(\"running delegated task...\");\n-                runnable.run();\n-            }\n-        }\n+        super();\n@@ -304,16 +206,0 @@\n-    private static void checkTransfer(ByteBuffer a, ByteBuffer b)\n-            throws Exception {\n-        a.flip();\n-        b.flip();\n-\n-        if (!a.equals(b)) {\n-            throw new Exception(\"Data didn't transfer cleanly\");\n-        } else {\n-            log(\"Data transferred cleanly\");\n-        }\n-\n-        a.position(a.limit());\n-        b.position(b.limit());\n-        a.limit(a.capacity());\n-        b.limit(b.capacity());\n-    }\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLEngineImpl\/EngineEnforceUseClientMode.java","additions":47,"deletions":161,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+ * @library \/javax\/net\/ssl\/templates\n@@ -89,2 +90,0 @@\n-import java.io.*;\n-import java.security.*;\n@@ -93,1 +92,1 @@\n-public class RehandshakeFinished {\n+public class RehandshakeFinished extends SSLContextTemplate {\n@@ -111,1 +110,1 @@\n-    static private SSLContext sslc;\n+    private final SSLContext sslc;\n@@ -129,40 +128,2 @@\n-    \/*\n-     * The following is to set up the keystores.\n-     *\/\n-    private static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    private static String keyStoreFile = \"keystore\";\n-    private static String trustStoreFile = \"truststore\";\n-    private static String passwd = \"passphrase\";\n-\n-    private static String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-    private static String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-\n-    private static Exception loadException = null;\n-\n-    static {\n-        try {\n-            KeyStore ks = KeyStore.getInstance(\"JKS\");\n-            KeyStore ts = KeyStore.getInstance(\"JKS\");\n-\n-            char[] passphrase = \"passphrase\".toCharArray();\n-\n-            ks.load(new FileInputStream(keyFilename), passphrase);\n-            ts.load(new FileInputStream(trustFilename), passphrase);\n-\n-            KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-            kmf.init(ks, passphrase);\n-\n-            TrustManagerFactory tmf =\n-                TrustManagerFactory.getInstance(\"SunX509\");\n-            tmf.init(ts);\n-\n-            SSLContext sslCtx = SSLContext.getInstance(\"TLSv1.2\");\n-            sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-            sslc = sslCtx;\n-        } catch (Exception e) {\n-            loadException = e;\n-        }\n+    public RehandshakeFinished() throws Exception {\n+        sslc = createServerSSLContext();\n@@ -179,4 +140,1 @@\n-        if (loadException != null) {\n-            throw loadException;\n-        }\n-\n+        RehandshakeFinished test = new RehandshakeFinished();\n@@ -185,2 +143,1 @@\n-        if ((new RehandshakeFinished().runTest()) !=\n-                new RehandshakeFinished().runRehandshake()) {\n+        if (test.runTest() != test.runRehandshake()) {\n@@ -415,0 +372,5 @@\n+    @Override\n+    protected ContextParameters getServerContextParameters() {\n+        return new ContextParameters(\"TLSv1.2\", \"PKIX\", \"NewSunX509\");\n+    }\n+\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLEngineImpl\/RehandshakeFinished.java","additions":13,"deletions":51,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @library \/javax\/net\/ssl\/templates\n@@ -73,3 +74,0 @@\n-import java.io.*;\n-import java.security.*;\n-import java.nio.*;\n@@ -78,1 +76,1 @@\n-public class SSLEngineDeadlock {\n+public class SSLEngineDeadlock extends SSLEngineTemplate {\n@@ -96,10 +94,0 @@\n-    private SSLContext sslc;\n-\n-    private SSLEngine clientEngine;     \/\/ client Engine\n-    private ByteBuffer clientOut;       \/\/ write side of clientEngine\n-    private ByteBuffer clientIn;        \/\/ read side of clientEngine\n-\n-    private SSLEngine serverEngine;     \/\/ server Engine\n-    private ByteBuffer serverOut;       \/\/ write side of serverEngine\n-    private ByteBuffer serverIn;        \/\/ read side of serverEngine\n-\n@@ -108,23 +96,0 @@\n-    \/*\n-     * For data transport, this example uses local ByteBuffers.  This\n-     * isn't really useful, but the purpose of this example is to show\n-     * SSLEngine concepts, not how to do network transport.\n-     *\/\n-    private ByteBuffer cTOs;            \/\/ \"reliable\" transport client->server\n-    private ByteBuffer sTOc;            \/\/ \"reliable\" transport server->client\n-\n-    \/*\n-     * The following is to set up the keystores.\n-     *\/\n-    private static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    private static String keyStoreFile = \"keystore\";\n-    private static String trustStoreFile = \"truststore\";\n-    private static String passwd = \"passphrase\";\n-\n-    private static String keyFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-    private static String trustFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-\n@@ -157,20 +122,1 @@\n-\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        KeyStore ts = KeyStore.getInstance(\"JKS\");\n-\n-        char[] passphrase = \"passphrase\".toCharArray();\n-\n-        ks.load(new FileInputStream(keyFilename), passphrase);\n-        ts.load(new FileInputStream(trustFilename), passphrase);\n-\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-        kmf.init(ks, passphrase);\n-\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-        tmf.init(ts);\n-\n-        SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n-\n-        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-\n-        sslc = sslCtx;\n+       super();\n@@ -217,3 +163,0 @@\n-        createSSLEngines();\n-        createBuffers();\n-\n@@ -290,52 +233,0 @@\n-    \/*\n-     * Using the SSLContext created during object creation,\n-     * create\/configure the SSLEngines we'll use for this test.\n-     *\/\n-    private void createSSLEngines() throws Exception {\n-        \/*\n-         * Configure the serverEngine to act as a server in the SSL\/TLS\n-         * handshake.  Also, require SSL client authentication.\n-         *\/\n-        serverEngine = sslc.createSSLEngine();\n-        serverEngine.setUseClientMode(false);\n-        serverEngine.setNeedClientAuth(true);\n-\n-        \/*\n-         * Similar to above, but using client mode instead.\n-         *\/\n-        clientEngine = sslc.createSSLEngine(\"client\", 80);\n-        clientEngine.setUseClientMode(true);\n-    }\n-\n-    \/*\n-     * Create and size the buffers appropriately.\n-     *\/\n-    private void createBuffers() {\n-\n-        \/*\n-         * We'll assume the buffer sizes are the same\n-         * between client and server.\n-         *\/\n-        SSLSession session = clientEngine.getSession();\n-        int appBufferMax = session.getApplicationBufferSize();\n-        int netBufferMax = session.getPacketBufferSize();\n-\n-        \/*\n-         * We'll make the input buffers a bit bigger than the max needed\n-         * size, so that unwrap()s following a successful data transfer\n-         * won't generate BUFFER_OVERFLOWS.\n-         *\n-         * We'll use a mix of direct and indirect ByteBuffers for\n-         * tutorial purposes only.  In reality, only use direct\n-         * ByteBuffers when they give a clear performance enhancement.\n-         *\/\n-        clientIn = ByteBuffer.allocate(appBufferMax + 50);\n-        serverIn = ByteBuffer.allocate(appBufferMax + 50);\n-\n-        cTOs = ByteBuffer.allocateDirect(netBufferMax);\n-        sTOc = ByteBuffer.allocateDirect(netBufferMax);\n-\n-        clientOut = ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n-        serverOut = ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n-    }\n-\n@@ -346,20 +237,0 @@\n-    \/*\n-     * Simple check to make sure everything came across as expected.\n-     *\/\n-    private static void checkTransfer(ByteBuffer a, ByteBuffer b)\n-            throws Exception {\n-        a.flip();\n-        b.flip();\n-\n-        if (!a.equals(b)) {\n-            throw new Exception(\"Data didn't transfer cleanly\");\n-        } else {\n-            log(\"\\tData transferred cleanly\");\n-        }\n-\n-        a.position(a.limit());\n-        b.position(b.limit());\n-        a.limit(a.capacity());\n-        b.limit(b.capacity());\n-    }\n-\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLEngineImpl\/SSLEngineDeadlock.java","additions":4,"deletions":133,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+ * @library \/javax\/net\/ssl\/templates\n@@ -71,3 +72,0 @@\n-import java.io.*;\n-import java.security.*;\n-import java.nio.*;\n@@ -75,1 +73,1 @@\n-public class SSLEngineFailedALPN {\n+public class SSLEngineFailedALPN extends SSLEngineTemplate {\n@@ -93,33 +91,0 @@\n-    private final SSLContext sslc;\n-\n-    private SSLEngine clientEngine;     \/\/ client Engine\n-    private ByteBuffer clientOut;       \/\/ write side of clientEngine\n-    private ByteBuffer clientIn;        \/\/ read side of clientEngine\n-\n-    private SSLEngine serverEngine;     \/\/ server Engine\n-    private ByteBuffer serverOut;       \/\/ write side of serverEngine\n-    private ByteBuffer serverIn;        \/\/ read side of serverEngine\n-\n-    \/*\n-     * For data transport, this example uses local ByteBuffers.  This\n-     * isn't really useful, but the purpose of this example is to show\n-     * SSLEngine concepts, not how to do network transport.\n-     *\/\n-    private ByteBuffer cTOs;            \/\/ \"reliable\" transport client->server\n-    private ByteBuffer sTOc;            \/\/ \"reliable\" transport server->client\n-\n-    \/*\n-     * The following is to set up the keystores.\n-     *\/\n-    private static final String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    private static final String keyStoreFile = \"keystore\";\n-    private static final String trustStoreFile = \"truststore\";\n-    private static final char[] passphrase = \"passphrase\".toCharArray();\n-\n-    private static final String keyFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-    private static final String trustFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-\n@@ -144,18 +109,1 @@\n-\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        KeyStore ts = KeyStore.getInstance(\"JKS\");\n-\n-        ks.load(new FileInputStream(keyFilename), passphrase);\n-        ts.load(new FileInputStream(trustFilename), passphrase);\n-\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-        kmf.init(ks, passphrase);\n-\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-        tmf.init(ts);\n-\n-        SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n-\n-        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-\n-        sslc = sslCtx;\n+        super();\n@@ -184,3 +132,0 @@\n-        createSSLEngines();\n-        createBuffers();\n-\n@@ -312,12 +257,4 @@\n-    \/*\n-     * Using the SSLContext created during object creation,\n-     * create\/configure the SSLEngines we'll use for this test.\n-     *\/\n-    private void createSSLEngines() throws Exception {\n-        \/*\n-         * Configure the serverEngine to act as a server in the SSL\/TLS\n-         * handshake.  Also, require SSL client authentication.\n-         *\/\n-        serverEngine = sslc.createSSLEngine();\n-        serverEngine.setUseClientMode(false);\n-        serverEngine.setNeedClientAuth(true);\n+    @Override\n+    protected SSLEngine configureServerEngine(SSLEngine engine) {\n+        engine.setUseClientMode(false);\n+        engine.setNeedClientAuth(true);\n@@ -326,1 +263,1 @@\n-        SSLParameters paramsServer = serverEngine.getSSLParameters();\n+        SSLParameters paramsServer = engine.getSSLParameters();\n@@ -328,1 +265,3 @@\n-        serverEngine.setSSLParameters(paramsServer);\n+        engine.setSSLParameters(paramsServer);\n+        return engine;\n+    }\n@@ -330,5 +269,3 @@\n-        \/*\n-         * Similar to above, but using client mode instead.\n-         *\/\n-        clientEngine = sslc.createSSLEngine(\"client\", 80);\n-        clientEngine.setUseClientMode(true);\n+    @Override\n+    protected SSLEngine configureClientEngine(SSLEngine engine) {\n+        engine.setUseClientMode(true);\n@@ -337,1 +274,1 @@\n-        SSLParameters paramsClient = clientEngine.getSSLParameters();\n+        SSLParameters paramsClient = engine.getSSLParameters();\n@@ -339,54 +276,2 @@\n-        clientEngine.setSSLParameters(paramsClient);\n-    }\n-\n-    \/*\n-     * Create and size the buffers appropriately.\n-     *\/\n-    private void createBuffers() {\n-\n-        \/*\n-         * We'll assume the buffer sizes are the same\n-         * between client and server.\n-         *\/\n-        SSLSession session = clientEngine.getSession();\n-        int appBufferMax = session.getApplicationBufferSize();\n-        int netBufferMax = session.getPacketBufferSize();\n-\n-        \/*\n-         * We'll make the input buffers a bit bigger than the max needed\n-         * size, so that unwrap()s following a successful data transfer\n-         * won't generate BUFFER_OVERFLOWS.\n-         *\n-         * We'll use a mix of direct and indirect ByteBuffers for\n-         * tutorial purposes only.  In reality, only use direct\n-         * ByteBuffers when they give a clear performance enhancement.\n-         *\/\n-        clientIn = ByteBuffer.allocate(appBufferMax + 50);\n-        serverIn = ByteBuffer.allocate(appBufferMax + 50);\n-\n-        cTOs = ByteBuffer.allocateDirect(netBufferMax);\n-        sTOc = ByteBuffer.allocateDirect(netBufferMax);\n-\n-        clientOut = ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n-        serverOut = ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n-    }\n-\n-    \/*\n-     * If the result indicates that we have outstanding tasks to do,\n-     * go ahead and run them in this thread.\n-     *\/\n-    private static void runDelegatedTasks(SSLEngine engine) throws Exception {\n-\n-        if (engine.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n-            Runnable runnable;\n-            while ((runnable = engine.getDelegatedTask()) != null) {\n-                log(\"    running delegated task...\");\n-                runnable.run();\n-            }\n-            HandshakeStatus hsStatus = engine.getHandshakeStatus();\n-            if (hsStatus == HandshakeStatus.NEED_TASK) {\n-                throw new Exception(\n-                    \"handshake shouldn't need additional tasks\");\n-            }\n-            logEngineStatus(engine);\n-        }\n+        engine.setSSLParameters(paramsClient);\n+        return engine;\n@@ -399,20 +284,0 @@\n-    \/*\n-     * Simple check to make sure everything came across as expected.\n-     *\/\n-    private static void checkTransfer(ByteBuffer a, ByteBuffer b)\n-            throws Exception {\n-        a.flip();\n-        b.flip();\n-\n-        if (!a.equals(b)) {\n-            throw new Exception(\"Data didn't transfer cleanly\");\n-        } else {\n-            log(\"\\tData transferred cleanly\");\n-        }\n-\n-        a.position(a.limit());\n-        b.position(b.limit());\n-        a.limit(a.capacity());\n-        b.limit(b.capacity());\n-    }\n-\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLEngineImpl\/SSLEngineFailedALPN.java","additions":18,"deletions":153,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n- * @library \/test\/lib\n+ *          \/test\/lib\n+ *          \/javax\/net\/ssl\/templates\n@@ -52,1 +53,0 @@\n-import javax.net.ssl.KeyManagerFactory;\n@@ -56,1 +56,0 @@\n-import javax.net.ssl.TrustManagerFactory;\n@@ -60,2 +59,0 @@\n-import java.security.KeyStore;\n-import java.security.SecureRandom;\n@@ -68,1 +65,1 @@\n-public class SSLEngineKeyLimit {\n+public class SSLEngineKeyLimit extends SSLContextTemplate {\n@@ -76,5 +73,0 @@\n-\n-    static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\/\";\n-    static String keyStoreFile = \"keystore\";\n-    static String passwd = \"passphrase\";\n-    static String keyFilename;\n@@ -167,7 +159,0 @@\n-        keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-\n-        System.setProperty(\"javax.net.ssl.keyStore\", keyFilename);\n-        System.setProperty(\"javax.net.ssl.keyStorePassword\", passwd);\n-\n@@ -415,13 +400,6 @@\n-        SSLContext sc = SSLContext.getInstance(\"TLSv1.3\");\n-        KeyStore ks = KeyStore.getInstance(\n-                new File(System.getProperty(\"javax.net.ssl.keyStore\")),\n-                passwd.toCharArray());\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\n-                KeyManagerFactory.getDefaultAlgorithm());\n-        kmf.init(ks, passwd.toCharArray());\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\n-                TrustManagerFactory.getDefaultAlgorithm());\n-        tmf.init(ks);\n-        sc.init(kmf.getKeyManagers(),\n-                tmf.getTrustManagers(), new SecureRandom());\n-        return sc;\n+        return createServerSSLContext();\n+    }\n+\n+    @Override\n+    protected ContextParameters getServerContextParameters() {\n+        return new ContextParameters(\"TLSv1.3\", \"PKIX\", \"NewSunX509\");\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLEngineImpl\/SSLEngineKeyLimit.java","additions":9,"deletions":31,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @library \/javax\/net\/ssl\/templates\n@@ -31,2 +32,0 @@\n-import javax.net.ssl.KeyManagerFactory;\n-import javax.net.ssl.SSLContext;\n@@ -35,15 +34,2 @@\n-import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n-import javax.net.ssl.SSLSession;\n-import javax.net.ssl.TrustManagerFactory;\n-import java.io.File;\n-import java.nio.ByteBuffer;\n-import java.security.KeyStore;\n-import java.security.SecureRandom;\n-\n-public class TLS13BeginHandshake {\n-    static String pathToStores =\n-            System.getProperty(\"test.src\") + \"\/..\/..\/..\/..\/javax\/net\/ssl\/etc\/\";\n-    static String keyStoreFile = \"keystore\";\n-    static String passwd = \"passphrase\";\n-\n-    private SSLEngine serverEngine, clientEngine;\n+\n+public class TLS13BeginHandshake extends SSLEngineTemplate {\n@@ -51,3 +37,0 @@\n-    private ByteBuffer clientOut, clientIn;\n-    private ByteBuffer serverOut, serverIn;\n-    private ByteBuffer cTOs,sTOc;\n@@ -59,0 +42,4 @@\n+    public TLS13BeginHandshake() throws Exception {\n+        super();\n+    }\n+\n@@ -62,3 +49,0 @@\n-        createSSLEngines();\n-        createBuffers();\n-\n@@ -70,1 +54,1 @@\n-            runDelegatedTasks(clientResult, clientEngine);\n+            runDelegatedTasks(clientEngine);\n@@ -73,1 +57,1 @@\n-            runDelegatedTasks(serverResult, serverEngine);\n+            runDelegatedTasks(serverEngine);\n@@ -83,1 +67,2 @@\n-            }            runDelegatedTasks(clientResult, clientEngine);\n+            }\n+            runDelegatedTasks(clientEngine);\n@@ -86,1 +71,1 @@\n-            runDelegatedTasks(serverResult, serverEngine);\n+            runDelegatedTasks(serverEngine);\n@@ -124,37 +109,3 @@\n-    private static void checkTransfer(ByteBuffer a, ByteBuffer b)\n-            throws Exception {\n-        a.flip();\n-        b.flip();\n-\n-        if (!a.equals(b)) {\n-            throw new Exception(\"Data didn't transfer cleanly\");\n-        } else {\n-            System.out.println(\"\\tData transferred cleanly\");\n-        }\n-\n-        a.compact();\n-        b.compact();\n-\n-    }\n-    private void createBuffers() {\n-        SSLSession session = clientEngine.getSession();\n-        int appBufferMax = session.getApplicationBufferSize();\n-        int netBufferMax = session.getPacketBufferSize();\n-\n-        clientIn = ByteBuffer.allocate(appBufferMax + 50);\n-        serverIn = ByteBuffer.allocate(appBufferMax + 50);\n-\n-        cTOs = ByteBuffer.allocateDirect(netBufferMax);\n-        sTOc = ByteBuffer.allocateDirect(netBufferMax);\n-\n-        clientOut = ByteBuffer.wrap(\"client\".getBytes());\n-        serverOut = ByteBuffer.wrap(\"server\".getBytes());\n-    }\n-\n-    private void createSSLEngines() throws Exception {\n-        serverEngine = initContext().createSSLEngine();\n-        serverEngine.setUseClientMode(false);\n-        serverEngine.setNeedClientAuth(true);\n-\n-        clientEngine = initContext().createSSLEngine(\"client\", 80);\n-        clientEngine.setUseClientMode(true);\n+    @Override\n+    protected ContextParameters getServerContextParameters() {\n+        return new ContextParameters(\"TLSv1.3\", \"PKIX\", \"NewSunX509\");\n@@ -163,27 +114,3 @@\n-    private SSLContext initContext() throws Exception {\n-        SSLContext sc = SSLContext.getInstance(\"TLSv1.3\");\n-        KeyStore ks = KeyStore.getInstance(new File(pathToStores + keyStoreFile),\n-                passwd.toCharArray());\n-        KeyManagerFactory kmf =\n-                KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n-        kmf.init(ks, passwd.toCharArray());\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n-        tmf.init(ks);\n-        sc.init(kmf.getKeyManagers(), tmf.getTrustManagers(), new SecureRandom());\n-        return sc;\n-    }\n-\n-    private static void runDelegatedTasks(SSLEngineResult result,\n-            SSLEngine engine) throws Exception {\n-\n-        if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n-            Runnable runnable;\n-            while ((runnable = engine.getDelegatedTask()) != null) {\n-                runnable.run();\n-            }\n-            HandshakeStatus hsStatus = engine.getHandshakeStatus();\n-            if (hsStatus == HandshakeStatus.NEED_TASK) {\n-                throw new Exception(\n-                    \"handshake shouldn't need additional tasks\");\n-            }\n-        }\n+    @Override\n+    protected ContextParameters getClientContextParameters() {\n+        return new ContextParameters(\"TLSv1.3\", \"PKIX\", \"NewSunX509\");\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLEngineImpl\/TLS13BeginHandshake.java","additions":19,"deletions":92,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @library \/javax\/net\/ssl\/templates\n@@ -36,1 +37,0 @@\n-import java.net.*;\n@@ -40,27 +40,1 @@\n-public class HashCodeMissing {\n-\n-    \/*\n-     * =============================================================\n-     * Set the various variables needed for the tests, then\n-     * specify what tests to run on each side.\n-     *\/\n-\n-    \/*\n-     * Should we run the client or server in a separate thread?\n-     * Both sides can throw exceptions, but do you have a preference\n-     * as to which side should be the main thread.\n-     *\/\n-    static boolean separateServerThread = false;\n-\n-    \/*\n-     * Where do we find the keystores?\n-     *\/\n-    static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    static String keyStoreFile = \"keystore\";\n-    static String trustStoreFile = \"truststore\";\n-    static String passwd = \"passphrase\";\n-\n-    \/*\n-     * Is the server ready to serve?\n-     *\/\n-    volatile static boolean serverReady = false;\n+public class HashCodeMissing extends SSLSocketTemplate {\n@@ -73,8 +47,0 @@\n-    \/*\n-     * If the client or server is doing some kind of object creation\n-     * that the other side depends on, and that thread prematurely\n-     * exits, you may experience a hang.  The test harness will\n-     * terminate all hung threads after its timeout has expired,\n-     * currently 3 minutes by default, but you might try to be\n-     * smart about it....\n-     *\/\n@@ -82,20 +48,2 @@\n-    \/*\n-     * Define the server side of the test.\n-     *\n-     * If the server prematurely exits, serverReady will be set to true\n-     * to avoid infinite hangs.\n-     *\/\n-    void doServerSide() throws Exception {\n-        SSLServerSocketFactory sslssf =\n-            (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\n-        SSLServerSocket sslServerSocket =\n-            (SSLServerSocket) sslssf.createServerSocket(serverPort);\n-\n-        serverPort = sslServerSocket.getLocalPort();\n-\n-        \/*\n-         * Signal Client, we're ready for his connect.\n-         *\/\n-        serverReady = true;\n-\n-        SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();\n+    @Override\n+    protected void runServerApplication(SSLSocket sslSocket) throws Exception {\n@@ -109,1 +57,0 @@\n-        sslSocket.close();\n@@ -112,19 +59,2 @@\n-    \/*\n-     * Define the client side of the test.\n-     *\n-     * If the server prematurely exits, serverReady will be set to true\n-     * to avoid infinite hangs.\n-     *\/\n-    void doClientSide() throws Exception {\n-\n-        \/*\n-         * Wait for server to get started.\n-         *\/\n-        while (!serverReady) {\n-            Thread.sleep(50);\n-        }\n-\n-        SSLSocketFactory sslsf =\n-            (SSLSocketFactory) SSLSocketFactory.getDefault();\n-        SSLSocket sslSocket = (SSLSocket)\n-            sslsf.createSocket(\"localhost\", serverPort);\n+    @Override\n+    protected void runClientApplication(SSLSocket sslSocket) throws Exception {\n@@ -153,11 +83,0 @@\n-    \/*\n-     * =============================================================\n-     * The remainder is just support stuff\n-     *\/\n-\n-    \/\/ use any free port by default\n-    volatile int serverPort = 0;\n-\n-    volatile Exception serverException = null;\n-    volatile Exception clientException = null;\n-\n@@ -165,11 +84,0 @@\n-        String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-        String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-\n-        System.setProperty(\"javax.net.ssl.keyStore\", keyFilename);\n-        System.setProperty(\"javax.net.ssl.keyStorePassword\", passwd);\n-        System.setProperty(\"javax.net.ssl.trustStore\", trustFilename);\n-        System.setProperty(\"javax.net.ssl.trustStorePassword\", passwd);\n@@ -183,1 +91,1 @@\n-        new HashCodeMissing();\n+        new HashCodeMissing().run();\n@@ -186,122 +94,0 @@\n-    Thread clientThread = null;\n-    Thread serverThread = null;\n-\n-    \/*\n-     * Primary constructor, used to drive remainder of the test.\n-     *\n-     * Fork off the other side, then do your work.\n-     *\/\n-    HashCodeMissing() throws Exception {\n-        try {\n-            if (separateServerThread) {\n-                startServer(true);\n-                startClient(false);\n-            } else {\n-                startClient(true);\n-                startServer(false);\n-            }\n-        } catch (Exception e) {\n-            \/\/swallow for now.  Show later\n-        }\n-\n-        \/*\n-         * Wait for other side to close down.\n-         *\/\n-        if (separateServerThread) {\n-            serverThread.join();\n-        } else {\n-            clientThread.join();\n-        }\n-\n-        \/*\n-         * When we get here, the test is pretty much over.\n-         * Which side threw the error?\n-         *\/\n-        Exception local;\n-        Exception remote;\n-        String whichRemote;\n-\n-        if (separateServerThread) {\n-            remote = serverException;\n-            local = clientException;\n-            whichRemote = \"server\";\n-        } else {\n-            remote = clientException;\n-            local = serverException;\n-            whichRemote = \"client\";\n-        }\n-\n-        \/*\n-         * If both failed, return the curthread's exception, but also\n-         * print the remote side Exception\n-         *\/\n-        if ((local != null) && (remote != null)) {\n-            System.out.println(whichRemote + \" also threw:\");\n-            remote.printStackTrace();\n-            System.out.println();\n-            throw local;\n-        }\n-\n-        if (remote != null) {\n-            throw remote;\n-        }\n-\n-        if (local != null) {\n-            throw local;\n-        }\n-    }\n-\n-    void startServer(boolean newThread) throws Exception {\n-        if (newThread) {\n-            serverThread = new Thread() {\n-                public void run() {\n-                    try {\n-                        doServerSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our server thread just died.\n-                         *\n-                         * Release the client, if not active already...\n-                         *\/\n-                        System.err.println(\"Server died...\");\n-                        serverReady = true;\n-                        serverException = e;\n-                    }\n-                }\n-            };\n-            serverThread.start();\n-        } else {\n-            try {\n-                doServerSide();\n-            } catch (Exception e) {\n-                serverException = e;\n-            } finally {\n-                serverReady = true;\n-            }\n-        }\n-    }\n-\n-    void startClient(boolean newThread) throws Exception {\n-        if (newThread) {\n-            clientThread = new Thread() {\n-                public void run() {\n-                    try {\n-                        doClientSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our client thread just died.\n-                         *\/\n-                        System.err.println(\"Client died...\");\n-                        clientException = e;\n-                    }\n-                }\n-            };\n-            clientThread.start();\n-        } else {\n-            try {\n-                doClientSide();\n-            } catch (Exception e) {\n-                clientException = e;\n-            }\n-        }\n-    }\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/HashCodeMissing.java","additions":8,"deletions":222,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @library \/javax\/net\/ssl\/templates\n@@ -50,7 +51,1 @@\n-public class ResumeChecksClient {\n-\n-    static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    static String keyStoreFile = \"keystore\";\n-    static String trustStoreFile = \"truststore\";\n-    static String passwd = \"passphrase\";\n-\n+public class ResumeChecksClient extends SSLContextTemplate {\n@@ -66,0 +61,2 @@\n+        new ResumeChecksClient(TestMode.valueOf(args[0])).run();\n+    }\n@@ -67,13 +64,4 @@\n-        TestMode mode = TestMode.valueOf(args[0]);\n-\n-        String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-        String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-\n-        System.setProperty(\"javax.net.ssl.keyStore\", keyFilename);\n-        System.setProperty(\"javax.net.ssl.keyStorePassword\", passwd);\n-        System.setProperty(\"javax.net.ssl.trustStore\", trustFilename);\n-        System.setProperty(\"javax.net.ssl.trustStorePassword\", passwd);\n+    private final TestMode testMode;\n+    public ResumeChecksClient(TestMode mode) {\n+        this.testMode = mode;\n+    }\n@@ -81,0 +69,1 @@\n+    private void run() throws Exception {\n@@ -83,1 +72,1 @@\n-        SSLContext sslContext = SSLContext.getDefault();\n+        SSLContext sslContext = createClientSSLContext();\n@@ -87,1 +76,1 @@\n-        SSLSession firstSession = connect(sslContext, server.port, mode, false);\n+        SSLSession firstSession = connect(sslContext, server.port, testMode, false);\n@@ -92,1 +81,1 @@\n-        SSLSession secondSession = connect(sslContext, server.port, mode, true);\n+        SSLSession secondSession = connect(sslContext, server.port, testMode, true);\n@@ -97,1 +86,1 @@\n-        switch (mode) {\n+        switch (testMode) {\n@@ -112,1 +101,1 @@\n-            throw new RuntimeException(\"unknown mode: \" + mode);\n+            throw new RuntimeException(\"unknown mode: \" + testMode);\n@@ -294,1 +283,1 @@\n-    private static class Server implements Runnable {\n+    private static class Server extends SSLContextTemplate implements Runnable {\n@@ -320,1 +309,1 @@\n-                SSLContext sc = SSLContext.getDefault();\n+                SSLContext sc = createServerSSLContext();\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/ResumeChecksClient.java","additions":17,"deletions":28,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @library \/javax\/net\/ssl\/templates\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/ResumeChecksClientStateless.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @library \/javax\/net\/ssl\/templates\n@@ -51,6 +52,1 @@\n-public class ResumeChecksServer {\n-\n-    static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    static String keyStoreFile = \"keystore\";\n-    static String trustStoreFile = \"truststore\";\n-    static String passwd = \"passphrase\";\n+public class ResumeChecksServer extends SSLContextTemplate {\n@@ -69,8 +65,3 @@\n-        TestMode mode = TestMode.valueOf(args[0]);\n-\n-        String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-        String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n+        new ResumeChecksServer(TestMode.valueOf(args[0])).run();\n+    }\n+    private final TestMode testMode;\n@@ -78,4 +69,3 @@\n-        System.setProperty(\"javax.net.ssl.keyStore\", keyFilename);\n-        System.setProperty(\"javax.net.ssl.keyStorePassword\", passwd);\n-        System.setProperty(\"javax.net.ssl.trustStore\", trustFilename);\n-        System.setProperty(\"javax.net.ssl.trustStorePassword\", passwd);\n+    public ResumeChecksServer(TestMode testMode) {\n+        this.testMode = testMode;\n+    }\n@@ -83,0 +73,1 @@\n+    private void run() throws Exception {\n@@ -85,1 +76,1 @@\n-        SSLContext sslContext = SSLContext.getDefault();\n+        SSLContext sslContext = createServerSSLContext();\n@@ -93,1 +84,1 @@\n-            connect(client, ssock, mode, false);\n+            connect(client, ssock, testMode, false);\n@@ -101,1 +92,1 @@\n-            secondSession = connect(client, ssock, mode, true);\n+            secondSession = connect(client, ssock, testMode, true);\n@@ -111,1 +102,1 @@\n-        switch (mode) {\n+        switch (testMode) {\n@@ -132,1 +123,1 @@\n-            throw new RuntimeException(\"unknown mode: \" + mode);\n+            throw new RuntimeException(\"unknown mode: \" + testMode);\n@@ -247,1 +238,1 @@\n-    private static class Client implements Runnable {\n+    private static class Client extends SSLContextTemplate implements Runnable {\n@@ -281,1 +272,1 @@\n-                SSLContext sc = SSLContext.getDefault();\n+                SSLContext sc = createClientSSLContext();\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/ResumeChecksServer.java","additions":17,"deletions":26,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @library \/javax\/net\/ssl\/templates\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/ResumeChecksServerStateless.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/javax\/net\/ssl\/templates\n@@ -50,1 +50,1 @@\n-public class ResumptionUpdateBoundValues {\n+public class ResumptionUpdateBoundValues extends SSLContextTemplate {\n@@ -79,2 +79,1 @@\n-        SSLServerSocketFactory sslssf =\n-            (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\n+        SSLServerSocketFactory sslssf = createServerSSLContext().getServerSocketFactory();\n@@ -125,2 +124,1 @@\n-        SSLSocketFactory sslsf =\n-            (SSLSocketFactory) SSLSocketFactory.getDefault();\n+        SSLSocketFactory sslsf = createClientSSLContext().getSocketFactory();\n@@ -212,11 +210,0 @@\n-        String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-        String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-        System.setProperty(\"javax.net.ssl.keyStore\", keyFilename);\n-        System.setProperty(\"javax.net.ssl.keyStorePassword\", passwd);\n-        System.setProperty(\"javax.net.ssl.trustStore\", trustFilename);\n-        System.setProperty(\"javax.net.ssl.trustStorePassword\", passwd);\n-\n@@ -230,1 +217,1 @@\n-        new ResumptionUpdateBoundValues();\n+        new ResumptionUpdateBoundValues().run();\n@@ -237,6 +224,1 @@\n-    \/*\n-     * Primary constructor, used to drive remainder of the test.\n-     *\n-     * Fork off the other side, then do your work.\n-     *\/\n-    ResumptionUpdateBoundValues() throws Exception {\n+    private void run() throws Exception {\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/ResumptionUpdateBoundValues.java","additions":6,"deletions":24,"binary":false,"changes":30,"status":"modified"}]}