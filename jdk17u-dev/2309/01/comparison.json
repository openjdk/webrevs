{"files":[{"patch":"@@ -726,0 +726,4 @@\n+  product(intx, MonitorUnlinkBatch, 500, DIAGNOSTIC,                        \\\n+          \"The maximum number of monitors to unlink in one batch. \")        \\\n+          range(1, max_jint)                                                \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,2 +83,2 @@\n-\/\/ Walk the in-use list and unlink (at most MonitorDeflationMax) deflated\n-\/\/ ObjectMonitors. Returns the number of unlinked ObjectMonitors.\n+\/\/ Walk the in-use list and unlink deflated ObjectMonitors.\n+\/\/ Returns the number of unlinked ObjectMonitors.\n@@ -87,0 +87,1 @@\n+                                    size_t deflated_count,\n@@ -89,5 +90,5 @@\n-  ObjectMonitor* prev = NULL;\n-  ObjectMonitor* head = Atomic::load_acquire(&_head);\n-  ObjectMonitor* m = head;\n-  \/\/ The in-use list head can be NULL during the final audit.\n-  while (m != NULL) {\n+  ObjectMonitor* prev = nullptr;\n+  ObjectMonitor* m = Atomic::load_acquire(&_head);\n+\n+  \/\/ The in-use list head can be null during the final audit.\n+  while (m != nullptr) {\n@@ -95,1 +96,3 @@\n-      \/\/ Find next live ObjectMonitor.\n+      \/\/ Find next live ObjectMonitor. Batch up the unlinkable monitors, so we can\n+      \/\/ modify the list once per batch. The batch starts at \"m\".\n+      size_t unlinked_batch = 0;\n@@ -97,0 +100,4 @@\n+      \/\/ Look for at most MonitorUnlinkBatch monitors, or the number of\n+      \/\/ deflated and not unlinked monitors, whatever comes first.\n+      assert(deflated_count >= unlinked_count, \"Sanity: underflow\");\n+      size_t unlinked_batch_limit = MIN2<size_t>(deflated_count - unlinked_count, MonitorUnlinkBatch);\n@@ -99,1 +106,1 @@\n-        unlinked_count++;\n+        unlinked_batch++;\n@@ -102,2 +109,8 @@\n-        if (unlinked_count >= (size_t)MonitorDeflationMax) {\n-          \/\/ Reached the max so bail out on the gathering loop.\n+        if (unlinked_batch >= unlinked_batch_limit) {\n+          \/\/ Reached the max batch, so bail out of the gathering loop.\n+          break;\n+        }\n+        if (prev == nullptr && Atomic::load(&_head) != m) {\n+          \/\/ Current batch used to be at head, but it is not at head anymore.\n+          \/\/ Bail out and figure out where we currently are. This avoids long\n+          \/\/ walks searching for new prev during unlink under heavy list inserts.\n@@ -106,5 +119,9 @@\n-      } while (next != NULL && next->is_being_async_deflated());\n-      if (prev == NULL) {\n-        ObjectMonitor* prev_head = Atomic::cmpxchg(&_head, head, next);\n-        if (prev_head != head) {\n-          \/\/ Find new prev ObjectMonitor that just got inserted.\n+      } while (next != nullptr && next->is_being_async_deflated());\n+\n+      \/\/ Unlink the found batch.\n+      if (prev == nullptr) {\n+        \/\/ The current batch is the first batch, so there is a chance that it starts at head.\n+        \/\/ Optimistically assume no inserts happened, and try to unlink the entire batch from the head.\n+        ObjectMonitor* prev_head = Atomic::cmpxchg(&_head, m, next);\n+        if (prev_head != m) {\n+          \/\/ Something must have updated the head. Figure out the actual prev for this batch.\n@@ -114,0 +131,1 @@\n+          assert(prev != nullptr, \"Should have found the prev for the current batch\");\n@@ -117,0 +135,3 @@\n+        \/\/ The current batch is preceded by another batch. This guarantees the current batch\n+        \/\/ does not start at head. Unlink the entire current batch without updating the head.\n+        assert(Atomic::load(&_head) != m, \"Sanity\");\n@@ -119,2 +140,5 @@\n-      if (unlinked_count >= (size_t)MonitorDeflationMax) {\n-        \/\/ Reached the max so bail out on the searching loop.\n+\n+      unlinked_count += unlinked_batch;\n+      if (unlinked_count >= deflated_count) {\n+        \/\/ Reached the max so bail out of the searching loop.\n+        \/\/ There should be no more deflated monitors left.\n@@ -136,0 +160,14 @@\n+\n+#ifdef ASSERT\n+  \/\/ Invariant: the code above should unlink all deflated monitors.\n+  \/\/ The code that runs after this unlinking does not expect deflated monitors.\n+  \/\/ Notably, attempting to deflate the already deflated monitor would break.\n+  {\n+    ObjectMonitor* m = Atomic::load_acquire(&_head);\n+    while (m != nullptr) {\n+      assert(!m->is_being_async_deflated(), \"All deflated monitors should be unlinked\");\n+      m = m->next_om();\n+    }\n+  }\n+#endif\n+\n@@ -1523,0 +1561,1 @@\n+                                                         deflated_count,\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":57,"deletions":18,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+                         size_t deflated_count,\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\/*\n+ * @test id=defaults\n+ * @bug 8319048\n+ * @summary Test the MonitorUnlinkBatch options\n+ * @library \/test\/lib\n+ * @run driver MonitorUnlinkBatchTest defaults\n+ *\/\n+\n+\/*\n+ * @test id=legal\n+ * @library \/test\/lib\n+ * @run driver MonitorUnlinkBatchTest legal\n+ *\/\n+\n+\/*\n+ * @test id=illegal\n+ * @library \/test\/lib\n+ * @run driver MonitorUnlinkBatchTest illegal\n+ *\/\n+\n+\/*\n+ * @test id=aggressive\n+ * @library \/test\/lib\n+ * @run driver MonitorUnlinkBatchTest aggressive\n+ *\/\n+\n+\/*\n+ * @test id=lazy\n+ * @library \/test\/lib\n+ * @run driver MonitorUnlinkBatchTest lazy\n+ *\/\n+\n+\n+public class MonitorUnlinkBatchTest {\n+\n+    public static class Test {\n+        \/\/ Inflate a lot of monitors, so that threshold heuristics definitely fires\n+        private static final int MONITORS = 10_000;\n+\n+        \/\/ Use a handful of threads to inflate the monitors, to eat the cost of\n+        \/\/ wait(1) calls. This can be larger than available parallelism, since threads\n+        \/\/ would be time-waiting.\n+        private static final int THREADS = 16;\n+\n+        private static Thread[] threads;\n+        private static Object[] monitors;\n+\n+        public static void main(String... args) throws Exception {\n+            monitors = new Object[MONITORS];\n+            threads = new Thread[THREADS];\n+\n+            for (int t = 0; t < THREADS; t++) {\n+                int monStart = t * MONITORS \/ THREADS;\n+                int monEnd = (t + 1) * MONITORS \/ THREADS;\n+                threads[t] = new Thread(() -> {\n+                    for (int m = monStart; m < monEnd; m++) {\n+                        Object o = new Object();\n+                        synchronized (o) {\n+                            try {\n+                                o.wait(1);\n+                            } catch (InterruptedException e) {\n+                            }\n+                        }\n+                        monitors[m] = o;\n+                    }\n+                });\n+                threads[t].start();\n+            }\n+\n+            for (Thread t : threads) {\n+                t.join();\n+            }\n+\n+            try {\n+                Thread.sleep(10_000);\n+            } catch (InterruptedException ie) {\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length < 1) {\n+            throw new IllegalArgumentException(\"Expect the test label\");\n+        }\n+\n+        String test = args[0];\n+        switch (test) {\n+            case \"defaults\":\n+                test(\"\");\n+                break;\n+\n+            case \"legal\":\n+                \/\/ Legal, even if not useful settings\n+                test(\"\",\n+                     \"-XX:MonitorDeflationMax=100000\",\n+                     \"-XX:MonitorUnlinkBatch=100001\"\n+                     );\n+                break;\n+\n+            case \"illegal\":\n+                \/\/ Quick tests that should fail on JVM flags verification.\n+                test(\"outside the allowed range\",\n+                     \"-XX:MonitorUnlinkBatch=-1\"\n+                );\n+                test(\"outside the allowed range\",\n+                     \"-XX:MonitorUnlinkBatch=0\"\n+                );\n+                break;\n+\n+            case \"aggressive\":\n+                \/\/ The smallest batch possible.\n+                test(\"\",\n+                     \"-XX:MonitorUnlinkBatch=1\"\n+                );\n+                break;\n+\n+            case \"lazy\":\n+                \/\/ The largest batch possible.\n+                test(\"\",\n+                     \"-XX:MonitorDeflationMax=1000000\",\n+                     \"-XX:MonitorUnlinkBatch=1000000\"\n+                );\n+                break;\n+\n+            default:\n+                throw new IllegalArgumentException(\"Unknown test: \" + test);\n+        }\n+    }\n+\n+    public static void test(String msg, String... args) throws Exception {\n+        List<String> opts = new ArrayList<>();\n+        opts.add(\"-Xmx128M\");\n+        opts.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        opts.add(\"-XX:GuaranteedAsyncDeflationInterval=100\");\n+        opts.addAll(Arrays.asList(args));\n+        opts.add(\"MonitorUnlinkBatchTest$Test\");\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(opts);\n+        OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n+        if (msg.isEmpty()) {\n+            oa.shouldHaveExitValue(0);\n+        } else {\n+            oa.shouldNotHaveExitValue(0);\n+            oa.shouldContain(msg);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/MonitorUnlinkBatchTest.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"}]}