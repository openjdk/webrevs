{"files":[{"patch":"@@ -147,0 +147,2 @@\n+JVMTI_COMMON_INCLUDES=-I$(TOPDIR)\/test\/lib\/jdk\/test\/lib\/jvmti\n+\n@@ -151,2 +153,2 @@\n-BUILD_HOTSPOT_JTREG_LIBRARIES_CFLAGS := -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS\n-BUILD_HOTSPOT_JTREG_EXECUTABLES_CFLAGS := -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS\n+BUILD_HOTSPOT_JTREG_LIBRARIES_CFLAGS := -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS $(JVMTI_COMMON_INCLUDES)\n+BUILD_HOTSPOT_JTREG_EXECUTABLES_CFLAGS := -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS $(JVMTI_COMMON_INCLUDES)\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3959,0 +3959,17 @@\n+\/\/ This nulls out jmethodIDs for all methods in 'klass'\n+\/\/ It needs to be called explicitly for all previous versions of a class because these may not be cleaned up\n+\/\/ during class unloading.\n+\/\/ We can not use the jmethodID cache associated with klass directly because the 'previous' versions\n+\/\/ do not have the jmethodID cache filled in. Instead, we need to lookup jmethodID for each method and this\n+\/\/ is expensive - O(n) for one jmethodID lookup. For all contained methods it is O(n^2).\n+\/\/ The reason for expensive jmethodID lookup for each method is that there is no direct link between method and jmethodID.\n+void InstanceKlass::clear_jmethod_ids(InstanceKlass* klass) {\n+  Array<Method*>* method_refs = klass->methods();\n+  for (int k = 0; k < method_refs->length(); k++) {\n+    Method* method = method_refs->at(k);\n+    if (method != nullptr && method->is_obsolete()) {\n+      method->clear_jmethod_id();\n+    }\n+  }\n+}\n+\n@@ -4002,0 +4019,1 @@\n+      clear_jmethod_ids(pv_node); \/\/ jmethodID maintenance for the unloaded class\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1182,0 +1182,2 @@\n+  \/\/ This nulls out jmethodIDs for all methods in 'klass'\n+  static void clear_jmethod_ids(InstanceKlass* klass);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2268,0 +2268,14 @@\n+void Method::clear_jmethod_id() {\n+  \/\/ Being at a safepoint prevents racing against other class redefinitions\n+  assert(SafepointSynchronize::is_at_safepoint(), \"should be at safepoint\");\n+  \/\/ The jmethodID is not stored in the Method instance, we need to look it up first\n+  jmethodID methodid = find_jmethod_id_or_null();\n+  \/\/ We need to make sure that jmethodID actually resolves to this method\n+  \/\/ - multiple redefined versions may share jmethodID slots and if a method\n+  \/\/   has already been rewired to a newer version we could be removing reference\n+  \/\/   to a still existing method instance\n+  if (methodid != nullptr && *((Method**)methodid) == this) {\n+    *((Method**)methodid) = nullptr;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -791,0 +791,1 @@\n+  void clear_jmethod_id();\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2372,0 +2372,4 @@\n+WB_ENTRY(void, WB_CleanMetaspaces(JNIEnv* env, jobject target))\n+  ClassLoaderDataGraph::safepoint_and_clean_metaspaces();\n+WB_END\n+\n@@ -2640,0 +2644,1 @@\n+  {CC\"cleanMetaspaces\", CC\"()V\",                      (void*)&WB_CleanMetaspaces},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2023, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8313816\n+ * @summary Test that a sequence of method retransformation and stacktrace capture while the old method\n+ *          version is still on stack does not lead to a crash when that method's jmethodID is used as\n+ *          an argument for JVMTI functions.\n+ * @requires vm.jvmti\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @modules java.instrument\n+ *          java.compiler\n+ * @compile GetStackTraceAndRetransformTest.java\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main RedefineClassHelper\n+ * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -javaagent:redefineagent.jar -agentlib:GetStackTraceAndRetransformTest GetStackTraceAndRetransformTest\n+ *\/\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+class Transformable {\n+  static final String newClass = \"\"\"\n+    class Transformable {\n+      static final String newClass = \"\";\n+      static void redefineAndStacktrace() throws Exception {}\n+      static void stacktrace() throws Exception {\n+        capture(Thread.currentThread());\n+      }\n+      public static native void capture(Thread thread);\n+    }\n+  \"\"\";\n+  static void redefineAndStacktrace() throws Exception {\n+    \/\/ This call will cause the class to be retransformed.\n+    \/\/ However, this method is still on stack so the subsequent attempt to capture the stacktrace\n+    \/\/ will result into this frame being identified by the jmethodID of the previous method version.\n+    RedefineClassHelper.redefineClass(Transformable.class, newClass);\n+    capture(Thread.currentThread());\n+  }\n+\n+  static void stacktrace() throws Exception {\n+  }\n+\n+  public static native void capture(Thread thread);\n+}\n+\n+public class GetStackTraceAndRetransformTest {\n+    public static void main(String args[]) throws Throwable {\n+        initialize(Transformable.class);\n+\n+        Transformable.redefineAndStacktrace();\n+        Transformable.stacktrace();\n+\n+        WhiteBox.getWhiteBox().cleanMetaspaces();\n+        check(2);\n+    }\n+\n+    public static native void initialize(Class<?> target);\n+    public static native void check(int expected);\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/GetStackTraceAndRetransformTest\/GetStackTraceAndRetransformTest.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2023, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+#include \"..\/get_stack_trace.h\"\n+\n+\n+extern \"C\" {\n+\n+static jvmtiEnv *jvmti = NULL;\n+static jmethodID* ids = NULL;\n+static int ids_size = 0;\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  jint res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+  ids = (jmethodID*)malloc(sizeof(jmethodID) * 10);\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_GetStackTraceAndRetransformTest_initialize(JNIEnv *env, jclass cls, jclass tgt) {\n+  \/\/ we need to force jmethodids to be created for the methods we are going to retransform\n+  env->GetStaticMethodID(tgt, \"redefineAndStacktrace\", \"()V\");\n+  env->GetStaticMethodID(tgt, \"stacktrace\", \"()V\");\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_Transformable_capture(JNIEnv *env, jclass cls, jthread thread) {\n+  jint count;\n+  const int MAX_NUMBER_OF_FRAMES = 32;\n+  jvmtiFrameInfo frames[MAX_NUMBER_OF_FRAMES];\n+\n+  jvmtiError err = jvmti->GetStackTrace(thread, 0, MAX_NUMBER_OF_FRAMES, frames, &count);\n+  check_jvmti_status(env, err, \"GetStackTrace failed.\");\n+\n+  ids[ids_size++] = frames[1].method;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_GetStackTraceAndRetransformTest_check(JNIEnv *jni, jclass cls, jint expected) {\n+  if (ids_size != expected) {\n+    fprintf(stderr, \"Unexpected number methods captured: %d (expected %d)\\n\", ids_size, expected);\n+    exit(2);\n+  }\n+  for (int i = 0; i < ids_size; i++) {\n+    jclass rslt = NULL;\n+    char* class_name = NULL;\n+    jvmti->GetMethodDeclaringClass(ids[i], &rslt);\n+    if (rslt != NULL) {\n+        jvmti->GetClassSignature(rslt, &class_name, NULL);\n+    }\n+  }\n+}\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/GetStackTraceAndRetransformTest\/libGetStackTraceAndRetransformTest.cpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef GET_STACK_TRACE_H\n+#define GET_STACK_TRACE_H\n+#include \"jvmti.h\"\n+\n+typedef struct {\n+  const char *cls;\n+  const char *name;\n+  const char *sig;\n+} frame_info;\n+\n+\n+int compare_stack_trace(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread,\n+                        frame_info expected_frames[], int expected_frames_length, int offset = 0) {\n+  int result = JNI_TRUE;\n+  char *class_signature, *name, *sig, *generic;\n+  jint count;\n+  const int MAX_NUMBER_OF_FRAMES = 32;\n+  jvmtiFrameInfo frames[MAX_NUMBER_OF_FRAMES];\n+  jclass caller_class;\n+\n+  printf(\"Calling compare_stack_trace for: \\n\");\n+  print_stack_trace(jvmti, jni, thread);\n+\n+  jvmtiError err = jvmti->GetStackTrace(thread, 0, MAX_NUMBER_OF_FRAMES, frames, &count);\n+  check_jvmti_status(jni, err, \"GetStackTrace failed.\");\n+\n+  printf(\"Number of frames: %d, expected: %d\\n\", count, expected_frames_length - offset);\n+\n+\n+  if (count < expected_frames_length - offset) {\n+    printf(\"Number of expected_frames: %d is less then expected: %d\\n\", count, expected_frames_length);\n+    result = JNI_FALSE;\n+  }\n+  for (int i = 0; i < count - offset; i++) {\n+    int idx = count - 1 - i;\n+    printf(\">>> checking frame#%d ...\\n\", idx);\n+    check_jvmti_status(jni, jvmti->GetMethodDeclaringClass(frames[count - 1 - i].method, &caller_class),\n+                       \"GetMethodDeclaringClass failed.\");\n+    check_jvmti_status(jni, jvmti->GetClassSignature(caller_class, &class_signature, &generic),\n+                       \"GetClassSignature\");\n+    check_jvmti_status(jni, jvmti->GetMethodName(frames[count - 1 - i].method, &name, &sig, &generic),\n+                       \"GetMethodName\");\n+\n+    printf(\">>>   class:  \\\"%s\\\"\\n\", class_signature);\n+    printf(\">>>   method: \\\"%s%s\\\"\\n\", name, sig);\n+    printf(\">>>   %d ... done\\n\", i);\n+\n+    int exp_idx = expected_frames_length - 1 - i;\n+    printf(\"expected idx %d\\n\", exp_idx);\n+    fflush(0);\n+    if (i < expected_frames_length) {\n+\n+      \/\/ for generated classes don't compare lambda indicies\n+      \/\/ Example: {\"Ljava\/lang\/VirtualThread$VThreadContinuation$$Lambda.0x0000000800098340;\"\n+      size_t lambda_idx = strlen(expected_frames[exp_idx].cls);\n+      const char *lambda = strstr(expected_frames[exp_idx].cls, \"$$Lambda\");\n+      if (lambda != nullptr) {\n+        lambda_idx = lambda - expected_frames[exp_idx].cls;\n+        printf(\"Comparing only first %zu chars in classname.\\n\", lambda_idx);\n+      }\n+      if (class_signature == NULL || strncmp(class_signature, expected_frames[exp_idx].cls, lambda_idx) != 0) {\n+        printf(\"(frame#%d) wrong class sig: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n+               exp_idx, class_signature, expected_frames[exp_idx].cls);\n+        result = JNI_FALSE;\n+      }\n+\n+      if (name == NULL || strcmp(name, expected_frames[exp_idx].name) != 0) {\n+        printf(\"(frame#%d) wrong method name: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n+               exp_idx, name, expected_frames[exp_idx].name);\n+        result = JNI_FALSE;\n+      }\n+      if (sig == NULL || strcmp(sig, expected_frames[exp_idx].sig) != 0) {\n+        printf(\"(frame#%d) wrong method sig: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n+               exp_idx, sig, expected_frames[exp_idx].sig);\n+        result = JNI_FALSE;\n+      }\n+    }\n+  }\n+  return result;\n+}\n+\n+\n+#endif \/\/GET_STACK_TRACE_H\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/get_stack_trace.h","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,910 @@\n+\/*\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef JVMTI_COMMON_H\n+#define JVMTI_COMMON_H\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdarg.h>\n+#include <string.h>\n+#include <ctype.h>\n+\n+#ifdef _WIN32\n+#include <windows.h>\n+#else\n+#include <unistd.h>\n+#endif\n+\n+#include \"jvmti.h\"\n+\n+\/**\n+ * Additional Java basic types\n+ *\/\n+\n+#ifdef _WIN32\n+    typedef unsigned __int64 julong;\n+#else\n+    typedef unsigned long long julong;\n+#endif\n+\n+#define LOG(...) \\\n+  { \\\n+    printf(__VA_ARGS__); \\\n+    fflush(stdout); \\\n+  }\n+\n+#define COMPLAIN LOG\n+\n+\n+const char* TranslateState(jint flags);\n+const char* TranslateError(jvmtiError err);\n+\n+static jvmtiExtensionFunction GetVirtualThread_func = NULL;\n+static jvmtiExtensionFunction GetCarrierThread_func = NULL;\n+\n+\/**\n+ * Convert the digits of the given value argument to a null-terminated\n+ * character string and store the result (up to 32 bytes) in string.\n+ * If value is negative, the first character of the stored string is\n+ * the minus sign (-). The function returns a pointer to the begining\n+ * of the result string.\n+ *\/\n+char* jlong_to_string(jlong value, char *string) {\n+  char buffer[32];\n+  char *pbuf, *pstr;\n+\n+  pstr = string;\n+  if (value == 0) {\n+    *pstr++ = '0';\n+  } else {\n+    if (value < 0) {\n+      *pstr++ = '-';\n+      value = -value;\n+    }\n+    pbuf = buffer;\n+    while (value != 0) {\n+      *pbuf++ = '0' + (char)(value % 10);\n+      value = value \/ 10;\n+    }\n+    while (pbuf != buffer) {\n+      *pstr++ = *--pbuf;\n+    }\n+  }\n+  *pstr = '\\0';\n+\n+  return string;\n+}\n+\n+\/**\n+ * Convert the digits of the given value argument to a null-terminated\n+ * character string and store the result (up to 32 bytes) in string.\n+ * The function returns a pointer to the begining of the result string.\n+ *\/\n+char* julong_to_string(julong value, char *string) {\n+    char buffer[32];\n+    char *pbuf, *pstr;\n+\n+    pstr = string;\n+    if (value == 0) {\n+        *pstr++ = '0';\n+    } else {\n+        pbuf = buffer;\n+        while (value != 0) {\n+            *pbuf++ = '0' + (char)(value % 10);\n+            value = value \/ 10;\n+        }\n+        while (pbuf != buffer) {\n+            *pstr++ = *--pbuf;\n+        }\n+    }\n+    *pstr = '\\0';\n+\n+    return string;\n+}\n+\n+static void\n+fatal(JNIEnv* jni, const char* msg) {\n+  jni->FatalError(msg);\n+}\n+\n+\n+static void\n+check_jvmti_status(JNIEnv* jni, jvmtiError err, const char* msg) {\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"check_jvmti_status: JVMTI function returned error: %s (%d)\\n\", TranslateError(err), err);\n+    jni->FatalError(msg);\n+  }\n+}\n+\n+\/* JVMTI helper wrappers. Check errors and fail or return null if jvmti operation failed. *\/\n+\n+\/\/ Monitors often created in Agent_Initialize(..) where JNIEnv* jni doesn't exist.\n+jrawMonitorID\n+create_raw_monitor(jvmtiEnv *jvmti, const char* name) {\n+  jrawMonitorID lock;\n+  jvmtiError err = jvmti->CreateRawMonitor(name, &lock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return nullptr;\n+  }\n+  return lock;\n+}\n+\n+void\n+destroy_raw_monitor(jvmtiEnv *jvmti, JNIEnv *jni, jrawMonitorID lock) {\n+  check_jvmti_status(jni, jvmti->DestroyRawMonitor(lock), \"DestroyRawMonitor failed.\");\n+}\n+\n+class RawMonitorLocker {\n+ private:\n+  jvmtiEnv* _jvmti;\n+  JNIEnv* _jni;\n+  jrawMonitorID _monitor;\n+\n+ public:\n+  RawMonitorLocker(jvmtiEnv *jvmti,JNIEnv* jni, jrawMonitorID monitor):_jvmti(jvmti), _jni(jni), _monitor(monitor) {\n+    check_jvmti_status(_jni, _jvmti->RawMonitorEnter(_monitor), \"Fatal Error in RawMonitorEnter.\");\n+  }\n+\n+  ~RawMonitorLocker() {\n+    check_jvmti_status(_jni, _jvmti->RawMonitorExit(_monitor), \"Fatal Error in RawMonitorEnter.\");\n+  }\n+\n+  void wait(jlong millis) {\n+    check_jvmti_status(_jni, _jvmti->RawMonitorWait(_monitor, millis), \"Fatal Error in RawMonitorWait.\");\n+  }\n+\n+  void wait() {\n+    wait(0);\n+  }\n+\n+  void notify() {\n+    check_jvmti_status(_jni, _jvmti->RawMonitorNotify(_monitor), \"Fatal Error in RawMonitorNotify.\");\n+  }\n+\n+  void notify_all() {\n+    check_jvmti_status(_jni, _jvmti->RawMonitorNotifyAll(_monitor), \"Fatal Error in RawMonitorNotifyAll.\");\n+  }\n+\n+};\n+\n+static void\n+deallocate(jvmtiEnv *jvmti, JNIEnv* jni, void* ptr) {\n+  jvmtiError err = jvmti->Deallocate((unsigned char*)ptr);\n+  check_jvmti_status(jni, err, \"deallocate: error in JVMTI Deallocate call\");\n+}\n+\n+static char*\n+get_method_class_name(jvmtiEnv *jvmti, JNIEnv* jni, jmethodID method) {\n+  jclass klass = NULL;\n+  char*  cname = NULL;\n+  char*  result = NULL;\n+  jvmtiError err;\n+\n+  err = jvmti->GetMethodDeclaringClass(method, &klass);\n+  check_jvmti_status(jni, err, \"get_method_class_name: error in JVMTI GetMethodDeclaringClass\");\n+\n+  err = jvmti->GetClassSignature(klass, &cname, NULL);\n+  check_jvmti_status(jni, err, \"get_method_class_name: error in JVMTI GetClassSignature\");\n+\n+  size_t len = strlen(cname) - 2; \/\/ get rid of leading 'L' and trailing ';'\n+\n+  err = jvmti->Allocate((jlong)(len + 1), (unsigned char**)&result);\n+  check_jvmti_status(jni, err, \"get_method_class_name: error in JVMTI Allocate\");\n+\n+  strncpy(result, cname + 1, len); \/\/ skip leading 'L'\n+  result[len] = '\\0';\n+  deallocate(jvmti, jni, (void*)cname);\n+  return result;\n+}\n+\n+\n+static void\n+print_method(jvmtiEnv *jvmti, JNIEnv* jni, jmethodID method, jint depth) {\n+  char*  cname = NULL;\n+  char*  mname = NULL;\n+  char*  msign = NULL;\n+  jvmtiError err;\n+\n+  cname = get_method_class_name(jvmti, jni, method);\n+\n+  err = jvmti->GetMethodName(method, &mname, &msign, NULL);\n+  check_jvmti_status(jni, err, \"print_method: error in JVMTI GetMethodName\");\n+\n+  LOG(\"%2d: %s: %s%s\\n\", depth, cname, mname, msign);\n+  fflush(0);\n+  deallocate(jvmti, jni, (void*)cname);\n+  deallocate(jvmti, jni, (void*)mname);\n+  deallocate(jvmti, jni, (void*)msign);\n+}\n+\n+void\n+print_thread_info(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread_obj) {\n+  jvmtiThreadInfo thread_info;\n+  jint thread_state;\n+  check_jvmti_status(jni, jvmti->GetThreadInfo(thread_obj, &thread_info), \"Error in GetThreadInfo\");\n+  check_jvmti_status(jni, jvmti->GetThreadState(thread_obj, &thread_state), \"Error in GetThreadInfo\");\n+  const char* state = TranslateState(thread_state);\n+  LOG(\"Thread: %p, name: %s, state(%x): %s, attr: %s\\n\", thread_obj, thread_info.name, thread_state, TranslateState(thread_state),\n+         (thread_info.is_daemon ? \"daemon\": \"\"));\n+}\n+\n+static void\n+print_stack_trace_frames(jvmtiEnv *jvmti, JNIEnv *jni, jint count, jvmtiFrameInfo *frames) {\n+  LOG(\"JVMTI Stack Trace: frame count: %d\\n\", count);\n+  for (int depth = 0; depth < count; depth++) {\n+    print_method(jvmti, jni, frames[depth].method, depth);\n+  }\n+  LOG(\"\\n\");\n+}\n+\n+static jint\n+get_frame_count(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  jint frame_count;\n+  jvmtiError err = jvmti->GetFrameCount(thread, &frame_count);\n+  check_jvmti_status(jni, err, \"get_frame_count: error in JVMTI GetFrameCount call\");\n+  return frame_count;\n+}\n+\n+static jvmtiThreadInfo\n+get_thread_info(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  jvmtiThreadInfo thr_info;\n+  jvmtiError err = jvmti->GetThreadInfo(thread, &thr_info);\n+  check_jvmti_status(jni, err, \"get_thread_info: error in JVMTI GetThreadInfo call\");\n+  return thr_info;\n+}\n+\n+static jint\n+get_thread_state(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  jint thread_state;\n+  jvmtiError err = jvmti->GetThreadState(thread, &thread_state);\n+  check_jvmti_status(jni, err, \"get_thread_state: error in JVMTI GetThreadState call\");\n+  return thread_state;\n+}\n+\n+static char*\n+get_thread_name(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  jvmtiThreadInfo thr_info;\n+  jvmtiError err;\n+\n+  memset(&thr_info, 0, sizeof(thr_info));\n+  err = jvmti->GetThreadInfo(thread, &thr_info);\n+  if (err == JVMTI_ERROR_WRONG_PHASE || err == JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+    return NULL; \/\/ VM or target thread completed its work\n+  }\n+  check_jvmti_status(jni, err, \"get_thread_name: error in JVMTI GetThreadInfo call\");\n+\n+  static const char* UNNAMED_STR = \"<Unnamed thread>\";\n+  static size_t UNNAMED_LEN = strlen(UNNAMED_STR);\n+  char* tname = thr_info.name;\n+  if (tname == NULL) {\n+    err = jvmti->Allocate((jlong)(UNNAMED_LEN + 1), (unsigned char**)&tname);\n+    check_jvmti_status(jni, err, \"get_method_class_name: error in JVMTI Allocate\");\n+    strncpy(tname, UNNAMED_STR, UNNAMED_LEN);\n+    tname[UNNAMED_LEN] = '\\0';\n+  }\n+  return tname;\n+}\n+\n+static char*\n+get_method_name(jvmtiEnv *jvmti, JNIEnv* jni, jmethodID method) {\n+  char*  mname = NULL;\n+  jvmtiError err;\n+\n+  err = jvmti->GetMethodName(method, &mname, NULL, NULL);\n+  check_jvmti_status(jni, err, \"get_method_name: error in JVMTI GetMethodName call\");\n+\n+  return mname;\n+}\n+\n+static jclass\n+find_class(jvmtiEnv *jvmti, JNIEnv *jni, jobject loader, const char* cname) {\n+  jclass *classes = NULL;\n+  jint count = 0;\n+  jvmtiError err;\n+\n+  err = jvmti->GetClassLoaderClasses(loader, &count, &classes);\n+  check_jvmti_status(jni, err, \"find_class: error in JVMTI GetClassLoaderClasses\");\n+\n+  \/\/ Find the jmethodID of the specified method\n+  while (--count >= 0) {\n+    char* name = NULL;\n+    jclass klass = classes[count];\n+\n+    err = jvmti->GetClassSignature(klass, &name, NULL);\n+    check_jvmti_status(jni, err, \"find_class: error in JVMTI GetClassSignature call\");\n+\n+    bool found = (strcmp(name, cname) == 0);\n+    deallocate(jvmti, jni, (void*)name);\n+    if (found) {\n+      return klass;\n+    }\n+  }\n+  return NULL;\n+}\n+\n+static jmethodID\n+find_method(jvmtiEnv *jvmti, JNIEnv *jni, jclass klass, const char* mname) {\n+  jmethodID *methods = NULL;\n+  jmethodID method = NULL;\n+  jint count = 0;\n+  jvmtiError err;\n+\n+  err = jvmti->GetClassMethods(klass, &count, &methods);\n+  check_jvmti_status(jni, err, \"find_method: error in JVMTI GetClassMethods\");\n+\n+  \/\/ Find the jmethodID of the specified method\n+  while (--count >= 0) {\n+    char* name = NULL;\n+\n+    jmethodID meth = methods[count];\n+\n+    err = jvmti->GetMethodName(meth, &name, NULL, NULL);\n+    check_jvmti_status(jni, err, \"find_method: error in JVMTI GetMethodName call\");\n+\n+    bool found = (strcmp(name, mname) == 0);\n+    deallocate(jvmti, jni, (void*)name);\n+    if (found) {\n+      method = meth;\n+      break;\n+    }\n+  }\n+  deallocate(jvmti, jni, (void*)methods);\n+  return method;\n+}\n+\n+#define MAX_FRAME_COUNT_PRINT_STACK_TRACE 200\n+\n+static void\n+print_current_stack_trace(jvmtiEnv *jvmti, JNIEnv* jni) {\n+  jvmtiFrameInfo frames[MAX_FRAME_COUNT_PRINT_STACK_TRACE];\n+  jint count = 0;\n+\n+  jvmtiError err = jvmti->GetStackTrace(NULL, 0, MAX_FRAME_COUNT_PRINT_STACK_TRACE, frames, &count);\n+  check_jvmti_status(jni, err, \"print_stack_trace: error in JVMTI GetStackTrace\");\n+\n+  LOG(\"JVMTI Stack Trace for current thread: frame count: %d\\n\", count);\n+  for (int depth = 0; depth < count; depth++) {\n+    print_method(jvmti, jni, frames[depth].method, depth);\n+  }\n+  LOG(\"\\n\");\n+}\n+\n+static void\n+print_stack_trace(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  jvmtiFrameInfo frames[MAX_FRAME_COUNT_PRINT_STACK_TRACE];\n+  char* tname = get_thread_name(jvmti, jni, thread);\n+  jint count = 0;\n+\n+  jvmtiError err = jvmti->GetStackTrace(thread, 0, MAX_FRAME_COUNT_PRINT_STACK_TRACE, frames, &count);\n+  check_jvmti_status(jni, err, \"print_stack_trace: error in JVMTI GetStackTrace\");\n+\n+  LOG(\"JVMTI Stack Trace for thread %s: frame count: %d\\n\", tname, count);\n+  for (int depth = 0; depth < count; depth++) {\n+    print_method(jvmti, jni, frames[depth].method, depth);\n+  }\n+  deallocate(jvmti, jni, (void*)tname);\n+  LOG(\"\\n\");\n+}\n+\n+\n+static void suspend_thread(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  check_jvmti_status(jni, jvmti->SuspendThread(thread), \"error in JVMTI SuspendThread\");\n+}\n+\n+static void resume_thread(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread) {\n+  check_jvmti_status(jni, jvmti->ResumeThread(thread), \"error in JVMTI ResumeThread\");\n+}\n+\n+static jthread get_current_thread(jvmtiEnv *jvmti, JNIEnv* jni) {\n+  jthread thread;\n+  check_jvmti_status(jni, jvmti->GetCurrentThread(&thread), \"error in JVMTI GetCurrentThread\");\n+  return thread;\n+}\n+\n+\n+\n+\/* Commonly used helper functions *\/\n+const char*\n+TranslateState(jint flags) {\n+  static char str[15 * 20];\n+\n+  if (flags == 0) {\n+    return \"<none>\";\n+  }\n+  str[0] = '\\0';\n+\n+  if (flags & JVMTI_THREAD_STATE_ALIVE) {\n+    strcat(str, \" ALIVE\");\n+  }\n+  if (flags & JVMTI_THREAD_STATE_TERMINATED) {\n+    strcat(str, \" TERMINATED\");\n+  }\n+  if (flags & JVMTI_THREAD_STATE_RUNNABLE) {\n+    strcat(str, \" RUNNABLE\");\n+  }\n+  if (flags & JVMTI_THREAD_STATE_WAITING) {\n+    strcat(str, \" WAITING\");\n+  }\n+  if (flags & JVMTI_THREAD_STATE_WAITING_INDEFINITELY) {\n+    strcat(str, \" WAITING_INDEFINITELY\");\n+  }\n+  if (flags & JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT) {\n+    strcat(str, \" WAITING_WITH_TIMEOUT\");\n+  }\n+  if (flags & JVMTI_THREAD_STATE_SLEEPING) {\n+    strcat(str, \" SLEEPING\");\n+  }\n+  if (flags & JVMTI_THREAD_STATE_IN_OBJECT_WAIT) {\n+    strcat(str, \" IN_OBJECT_WAIT\");\n+  }\n+  if (flags & JVMTI_THREAD_STATE_PARKED) {\n+    strcat(str, \" PARKED\");\n+  }\n+  if (flags & JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER) {\n+    strcat(str, \" BLOCKED_ON_MONITOR_ENTER\");\n+  }\n+  if (flags & JVMTI_THREAD_STATE_SUSPENDED) {\n+    strcat(str, \" SUSPENDED\");\n+  }\n+  if (flags & JVMTI_THREAD_STATE_INTERRUPTED) {\n+    strcat(str, \" INTERRUPTED\");\n+  }\n+  if (flags & JVMTI_THREAD_STATE_IN_NATIVE) {\n+    strcat(str, \" IN_NATIVE\");\n+  }\n+  return str;\n+}\n+\n+const char*\n+TranslateEvent(jvmtiEvent event_type) {\n+    switch (event_type) {\n+    case JVMTI_EVENT_VM_INIT:\n+        return (\"JVMTI_EVENT_VM_INIT\");\n+    case JVMTI_EVENT_VM_DEATH:\n+        return (\"JVMTI_EVENT_VM_DEATH\");\n+    case JVMTI_EVENT_THREAD_START:\n+        return (\"JVMTI_EVENT_THREAD_START\");\n+    case JVMTI_EVENT_THREAD_END:\n+        return (\"JVMTI_EVENT_THREAD_END\");\n+    case JVMTI_EVENT_CLASS_FILE_LOAD_HOOK:\n+        return (\"JVMTI_EVENT_CLASS_FILE_LOAD_HOOK\");\n+    case JVMTI_EVENT_CLASS_LOAD:\n+        return (\"JVMTI_EVENT_CLASS_LOAD\");\n+    case JVMTI_EVENT_CLASS_PREPARE:\n+        return (\"JVMTI_EVENT_CLASS_PREPARE\");\n+    case JVMTI_EVENT_VM_START:\n+        return (\"JVMTI_EVENT_VM_START\");\n+    case JVMTI_EVENT_EXCEPTION:\n+        return (\"JVMTI_EVENT_EXCEPTION\");\n+    case JVMTI_EVENT_EXCEPTION_CATCH:\n+        return (\"JVMTI_EVENT_EXCEPTION_CATCH\");\n+    case JVMTI_EVENT_SINGLE_STEP:\n+        return (\"JVMTI_EVENT_SINGLE_STEP\");\n+    case JVMTI_EVENT_FRAME_POP:\n+        return (\"JVMTI_EVENT_FRAME_POP\");\n+    case JVMTI_EVENT_BREAKPOINT:\n+        return (\"JVMTI_EVENT_BREAKPOINT\");\n+    case JVMTI_EVENT_FIELD_ACCESS:\n+        return (\"JVMTI_EVENT_FIELD_ACCESS\");\n+    case JVMTI_EVENT_FIELD_MODIFICATION:\n+        return (\"JVMTI_EVENT_FIELD_MODIFICATION\");\n+    case JVMTI_EVENT_METHOD_ENTRY:\n+        return (\"JVMTI_EVENT_METHOD_ENTRY\");\n+    case JVMTI_EVENT_METHOD_EXIT:\n+        return (\"JVMTI_EVENT_METHOD_EXIT\");\n+    case JVMTI_EVENT_NATIVE_METHOD_BIND:\n+        return (\"JVMTI_EVENT_NATIVE_METHOD_BIND\");\n+    case JVMTI_EVENT_COMPILED_METHOD_LOAD:\n+        return (\"JVMTI_EVENT_COMPILED_METHOD_LOAD\");\n+    case JVMTI_EVENT_COMPILED_METHOD_UNLOAD:\n+        return (\"JVMTI_EVENT_COMPILED_METHOD_UNLOAD\");\n+    case JVMTI_EVENT_DYNAMIC_CODE_GENERATED:\n+        return (\"JVMTI_EVENT_DYNAMIC_CODE_GENERATED\");\n+    case JVMTI_EVENT_DATA_DUMP_REQUEST:\n+        return (\"JVMTI_EVENT_DATA_DUMP_REQUEST\");\n+    case JVMTI_EVENT_MONITOR_WAIT:\n+        return (\"JVMTI_EVENT_MONITOR_WAIT\");\n+    case JVMTI_EVENT_MONITOR_WAITED:\n+        return (\"JVMTI_EVENT_MONITOR_WAITED\");\n+    case JVMTI_EVENT_MONITOR_CONTENDED_ENTER:\n+        return (\"JVMTI_EVENT_MONITOR_CONTENDED_ENTER\");\n+    case JVMTI_EVENT_MONITOR_CONTENDED_ENTERED:\n+        return (\"JVMTI_EVENT_MONITOR_CONTENDED_ENTERED\");\n+    case JVMTI_EVENT_GARBAGE_COLLECTION_START:\n+        return (\"JVMTI_EVENT_GARBAGE_COLLECTION_START\");\n+    case JVMTI_EVENT_GARBAGE_COLLECTION_FINISH:\n+        return (\"JVMTI_EVENT_GARBAGE_COLLECTION_FINISH\");\n+    case JVMTI_EVENT_OBJECT_FREE:\n+        return (\"JVMTI_EVENT_OBJECT_FREE\");\n+    case JVMTI_EVENT_VM_OBJECT_ALLOC:\n+        return (\"JVMTI_EVENT_VM_OBJECT_ALLOC\");\n+    default:\n+        return (\"<unknown event>\");\n+    }\n+}\n+\n+const char*\n+TranslateError(jvmtiError err) {\n+    switch (err) {\n+    case JVMTI_ERROR_NONE:\n+        return (\"JVMTI_ERROR_NONE\");\n+    case JVMTI_ERROR_INVALID_THREAD:\n+        return (\"JVMTI_ERROR_INVALID_THREAD\");\n+    case JVMTI_ERROR_INVALID_THREAD_GROUP:\n+        return (\"JVMTI_ERROR_INVALID_THREAD_GROUP\");\n+    case JVMTI_ERROR_INVALID_PRIORITY:\n+        return (\"JVMTI_ERROR_INVALID_PRIORITY\");\n+    case JVMTI_ERROR_THREAD_NOT_SUSPENDED:\n+        return (\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\");\n+    case JVMTI_ERROR_THREAD_SUSPENDED:\n+        return (\"JVMTI_ERROR_THREAD_SUSPENDED\");\n+    case JVMTI_ERROR_THREAD_NOT_ALIVE:\n+        return (\"JVMTI_ERROR_THREAD_NOT_ALIVE\");\n+    case JVMTI_ERROR_INVALID_OBJECT:\n+        return (\"JVMTI_ERROR_INVALID_OBJECT\");\n+    case JVMTI_ERROR_INVALID_CLASS:\n+        return (\"JVMTI_ERROR_INVALID_CLASS\");\n+    case JVMTI_ERROR_CLASS_NOT_PREPARED:\n+        return (\"JVMTI_ERROR_CLASS_NOT_PREPARED\");\n+    case JVMTI_ERROR_INVALID_METHODID:\n+        return (\"JVMTI_ERROR_INVALID_METHODID\");\n+    case JVMTI_ERROR_INVALID_LOCATION:\n+        return (\"JVMTI_ERROR_INVALID_LOCATION\");\n+    case JVMTI_ERROR_INVALID_FIELDID:\n+        return (\"JVMTI_ERROR_INVALID_FIELDID\");\n+    case JVMTI_ERROR_NO_MORE_FRAMES:\n+        return (\"JVMTI_ERROR_NO_MORE_FRAMES\");\n+    case JVMTI_ERROR_OPAQUE_FRAME:\n+        return (\"JVMTI_ERROR_OPAQUE_FRAME\");\n+    case JVMTI_ERROR_TYPE_MISMATCH:\n+        return (\"JVMTI_ERROR_TYPE_MISMATCH\");\n+    case JVMTI_ERROR_INVALID_SLOT:\n+        return (\"JVMTI_ERROR_INVALID_SLOT\");\n+    case JVMTI_ERROR_DUPLICATE:\n+        return (\"JVMTI_ERROR_DUPLICATE\");\n+    case JVMTI_ERROR_NOT_FOUND:\n+        return (\"JVMTI_ERROR_NOT_FOUND\");\n+    case JVMTI_ERROR_INVALID_MONITOR:\n+        return (\"JVMTI_ERROR_INVALID_MONITOR\");\n+    case JVMTI_ERROR_NOT_MONITOR_OWNER:\n+        return (\"JVMTI_ERROR_NOT_MONITOR_OWNER\");\n+    case JVMTI_ERROR_INTERRUPT:\n+        return (\"JVMTI_ERROR_INTERRUPT\");\n+    case JVMTI_ERROR_INVALID_CLASS_FORMAT:\n+        return (\"JVMTI_ERROR_INVALID_CLASS_FORMAT\");\n+    case JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION:\n+        return (\"JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION\");\n+    case JVMTI_ERROR_FAILS_VERIFICATION:\n+        return (\"JVMTI_ERROR_FAILS_VERIFICATION\");\n+    case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED:\n+        return (\"JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED\");\n+    case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED:\n+        return (\"JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED\");\n+    case JVMTI_ERROR_INVALID_TYPESTATE:\n+        return (\"JVMTI_ERROR_INVALID_TYPESTATE\");\n+    case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED:\n+        return (\"JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED\");\n+    case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED:\n+        return (\"JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED\");\n+    case JVMTI_ERROR_UNSUPPORTED_VERSION:\n+        return (\"JVMTI_ERROR_UNSUPPORTED_VERSION\");\n+    case JVMTI_ERROR_NAMES_DONT_MATCH:\n+        return (\"JVMTI_ERROR_NAMES_DONT_MATCH\");\n+    case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED:\n+        return (\"JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED\");\n+    case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED:\n+        return (\"JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED\");\n+    case JVMTI_ERROR_UNMODIFIABLE_CLASS:\n+        return (\"JVMTI_ERROR_UNMODIFIABLE_CLASS\");\n+    case JVMTI_ERROR_NOT_AVAILABLE:\n+        return (\"JVMTI_ERROR_NOT_AVAILABLE\");\n+    case JVMTI_ERROR_MUST_POSSESS_CAPABILITY:\n+        return (\"JVMTI_ERROR_MUST_POSSESS_CAPABILITY\");\n+    case JVMTI_ERROR_NULL_POINTER:\n+        return (\"JVMTI_ERROR_NULL_POINTER\");\n+    case JVMTI_ERROR_ABSENT_INFORMATION:\n+        return (\"JVMTI_ERROR_ABSENT_INFORMATION\");\n+    case JVMTI_ERROR_INVALID_EVENT_TYPE:\n+        return (\"JVMTI_ERROR_INVALID_EVENT_TYPE\");\n+    case JVMTI_ERROR_ILLEGAL_ARGUMENT:\n+        return (\"JVMTI_ERROR_ILLEGAL_ARGUMENT\");\n+    case JVMTI_ERROR_NATIVE_METHOD:\n+        return (\"JVMTI_ERROR_NATIVE_METHOD\");\n+    case JVMTI_ERROR_OUT_OF_MEMORY:\n+        return (\"JVMTI_ERROR_OUT_OF_MEMORY\");\n+    case JVMTI_ERROR_ACCESS_DENIED:\n+        return (\"JVMTI_ERROR_ACCESS_DENIED\");\n+    case JVMTI_ERROR_WRONG_PHASE:\n+        return (\"JVMTI_ERROR_WRONG_PHASE\");\n+    case JVMTI_ERROR_INTERNAL:\n+        return (\"JVMTI_ERROR_INTERNAL\");\n+    case JVMTI_ERROR_UNATTACHED_THREAD:\n+        return (\"JVMTI_ERROR_UNATTACHED_THREAD\");\n+    case JVMTI_ERROR_INVALID_ENVIRONMENT:\n+        return (\"JVMTI_ERROR_INVALID_ENVIRONMENT\");\n+    default:\n+        return (\"<unknown error>\");\n+    }\n+}\n+\n+const char*\n+TranslatePhase(jvmtiPhase phase) {\n+    switch (phase) {\n+    case JVMTI_PHASE_ONLOAD:\n+        return (\"JVMTI_PHASE_ONLOAD\");\n+    case JVMTI_PHASE_PRIMORDIAL:\n+        return (\"JVMTI_PHASE_PRIMORDIAL\");\n+    case JVMTI_PHASE_START:\n+        return (\"JVMTI_PHASE_START\");\n+    case JVMTI_PHASE_LIVE:\n+        return (\"JVMTI_PHASE_LIVE\");\n+    case JVMTI_PHASE_DEAD:\n+        return (\"JVMTI_PHASE_DEAD\");\n+    default:\n+        return (\"<unknown phase>\");\n+    }\n+}\n+\n+const char*\n+TranslateRootKind(jvmtiHeapRootKind root) {\n+    switch (root) {\n+    case JVMTI_HEAP_ROOT_JNI_GLOBAL:\n+        return (\"JVMTI_HEAP_ROOT_JNI_GLOBAL\");\n+    case JVMTI_HEAP_ROOT_JNI_LOCAL:\n+        return (\"JVMTI_HEAP_ROOT_JNI_LOCAL\");\n+    case JVMTI_HEAP_ROOT_SYSTEM_CLASS:\n+        return (\"JVMTI_HEAP_ROOT_SYSTEM_CLASS\");\n+    case JVMTI_HEAP_ROOT_MONITOR:\n+        return (\"JVMTI_HEAP_ROOT_MONITOR\");\n+    case JVMTI_HEAP_ROOT_STACK_LOCAL:\n+        return (\"JVMTI_HEAP_ROOT_STACK_LOCAL\");\n+    case JVMTI_HEAP_ROOT_THREAD:\n+        return (\"JVMTI_HEAP_ROOT_THREAD\");\n+    case JVMTI_HEAP_ROOT_OTHER:\n+        return (\"JVMTI_HEAP_ROOT_OTHER\");\n+    default:\n+        return (\"<unknown root kind>\");\n+    }\n+}\n+\n+const char*\n+TranslateObjectRefKind(jvmtiObjectReferenceKind ref) {\n+    switch (ref) {\n+    case JVMTI_REFERENCE_CLASS:\n+        return (\"JVMTI_REFERENCE_CLASS\");\n+    case JVMTI_REFERENCE_FIELD:\n+        return (\"JVMTI_REFERENCE_FIELD\");\n+    case JVMTI_REFERENCE_ARRAY_ELEMENT:\n+        return (\"JVMTI_REFERENCE_ARRAY_ELEMENT\");\n+    case JVMTI_REFERENCE_CLASS_LOADER:\n+        return (\"JVMTI_REFERENCE_CLASS_LOADER\");\n+    case JVMTI_REFERENCE_SIGNERS:\n+        return (\"JVMTI_REFERENCE_SIGNERS\");\n+    case JVMTI_REFERENCE_PROTECTION_DOMAIN:\n+        return (\"JVMTI_REFERENCE_PROTECTION_DOMAIN\");\n+    case JVMTI_REFERENCE_INTERFACE:\n+        return (\"JVMTI_REFERENCE_INTERFACE\");\n+    case JVMTI_REFERENCE_STATIC_FIELD:\n+        return (\"JVMTI_REFERENCE_STATIC_FIELD\");\n+    case JVMTI_REFERENCE_CONSTANT_POOL:\n+        return (\"JVMTI_REFERENCE_CONSTANT_POOL\");\n+    default:\n+        return (\"<unknown reference kind>\");\n+    }\n+}\n+\n+int\n+isThreadExpected(jvmtiEnv *jvmti, jthread thread) {\n+  static const char *vm_jfr_buffer_thread_name = \"VM JFR Buffer Thread\";\n+  static const char *jfr_request_timer_thread_name = \"JFR request timer\";\n+  static const char *graal_management_bean_registration_thread_name =\n+                        \"HotSpotGraalManagement Bean Registration\";\n+  static const char *graal_compiler_thread_name_prefix = \"JVMCI CompilerThread\";\n+  static const size_t graal_prefix_length = strlen(graal_compiler_thread_name_prefix);\n+\n+  static const char *unparker_thread_name_prefix = \"VirtualThread-unparker\";\n+  static const size_t unparker_prefix_length = strlen(unparker_thread_name_prefix);\n+\n+\n+  jvmtiThreadInfo threadinfo;\n+  jvmtiError err = jvmti->GetThreadInfo(thread, &threadinfo);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return 0;\n+  }\n+  if (strcmp(threadinfo.name, vm_jfr_buffer_thread_name) == 0) {\n+    return 0;\n+  }\n+  if (strcmp(threadinfo.name, jfr_request_timer_thread_name) == 0) {\n+    return 0;\n+  }\n+  if (strcmp(threadinfo.name, graal_management_bean_registration_thread_name) == 0)\n+    return 0;\n+\n+  if ((strlen(threadinfo.name) > graal_prefix_length) &&\n+      strncmp(threadinfo.name, graal_compiler_thread_name_prefix, graal_prefix_length) == 0) {\n+    return 0;\n+  }\n+  if (strncmp(threadinfo.name, unparker_thread_name_prefix, unparker_prefix_length) == 0) {\n+    return 0;\n+  }\n+  return 1;\n+}\n+\n+jthread find_thread_by_name(jvmtiEnv* jvmti, JNIEnv* jni, const char name[]) {\n+  jthread* threads = NULL;\n+  jint count = 0;\n+  jthread found_thread = NULL;\n+\n+  if (name == NULL) {\n+    return NULL;\n+  }\n+\n+  check_jvmti_status(jni, jvmti->GetAllThreads(&count, &threads), \"\");\n+\n+  for (int i = 0; i < count; i++) {\n+    jvmtiThreadInfo info = get_thread_info(jvmti, jni, threads[i]);\n+    if (info.name != NULL && strcmp(name, info.name) == 0) {\n+      found_thread = threads[i];\n+      break;\n+    }\n+  }\n+\n+  check_jvmti_status(jni, jvmti->Deallocate((unsigned char*)threads), \"\");\n+\n+  found_thread = (jthread) jni->NewGlobalRef(found_thread);\n+  return found_thread;\n+}\n+\n+\/*\n+ * JVMTI Extension Mechanism\n+ *\/\n+static const jvmtiEvent\n+  EXT_EVENT_VIRTUAL_THREAD_MOUNT   = (jvmtiEvent)((int)JVMTI_MIN_EVENT_TYPE_VAL - 2),\n+  EXT_EVENT_VIRTUAL_THREAD_UNMOUNT = (jvmtiEvent)((int)JVMTI_MIN_EVENT_TYPE_VAL - 3);\n+\n+static jvmtiExtensionFunction\n+find_ext_function(jvmtiEnv* jvmti, JNIEnv* jni, const char* fname) {\n+  jint extCount = 0;\n+  jvmtiExtensionFunctionInfo* extList = NULL;\n+\n+  jvmtiError err = jvmti->GetExtensionFunctions(&extCount, &extList);\n+  check_jvmti_status(jni, err, \"jvmti_common find_ext_function: Error in JVMTI GetExtensionFunctions\");\n+\n+  for (int i = 0; i < extCount; i++) {\n+    if (strstr(extList[i].id, (char*)fname) != NULL) {\n+      return extList[i].func;\n+    }\n+  }\n+  return NULL;\n+}\n+\n+static jvmtiError\n+GetVirtualThread(jvmtiEnv* jvmti, JNIEnv* jni, jthread cthread, jthread* vthread_ptr) {\n+  if (GetVirtualThread_func == NULL) { \/\/ lazily initialize function pointer\n+    GetVirtualThread_func = find_ext_function(jvmti, jni, \"GetVirtualThread\");\n+  }\n+  jvmtiError err = (*GetVirtualThread_func)(jvmti, cthread, vthread_ptr);\n+\n+  return err;\n+}\n+\n+static jvmtiError\n+GetCarrierThread(jvmtiEnv* jvmti, JNIEnv* jni, jthread vthread, jthread* cthread_ptr) {\n+  if (GetCarrierThread_func == NULL) { \/\/ lazily initialize function pointer\n+    GetCarrierThread_func = find_ext_function(jvmti, jni, \"GetCarrierThread\");\n+  }\n+  jvmtiError err = (*GetCarrierThread_func)(jvmti, vthread, cthread_ptr);\n+\n+  return err;\n+}\n+\n+static jthread\n+get_virtual_thread(jvmtiEnv* jvmti, JNIEnv* jni, jthread cthread) {\n+  jthread vthread = NULL;\n+  jvmtiError err = GetVirtualThread(jvmti, jni, cthread, &vthread);\n+  check_jvmti_status(jni, err, \"jvmti_common get_virtual_thread: Error in JVMTI extension GetVirtualThread\");\n+  return vthread;\n+}\n+\n+static jthread\n+get_carrier_thread(jvmtiEnv* jvmti, JNIEnv* jni, jthread vthread) {\n+  jthread cthread = NULL;\n+  jvmtiError err = GetCarrierThread(jvmti, jni, vthread, &cthread);\n+  check_jvmti_status(jni, err, \"jvmti_common get_carrier_thread: Error in JVMTI extension GetCarrierThread\");\n+\n+  return cthread;\n+}\n+\n+static jvmtiExtensionEventInfo*\n+find_ext_event(jvmtiEnv* jvmti, const char* ename) {\n+  jint extCount = 0;\n+  jvmtiExtensionEventInfo* extList = NULL;\n+\n+  jvmtiError err = jvmti->GetExtensionEvents(&extCount, &extList);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"jvmti_common find_ext_event: Error in JVMTI GetExtensionFunctions: %s(%d)\\n\",TranslateError(err), err);\n+    return NULL;\n+  }\n+  for (int i = 0; i < extCount; i++) {\n+    if (strstr(extList[i].id, (char*)ename) != NULL) {\n+      return &extList[i];\n+    }\n+  }\n+  return NULL;\n+}\n+\n+static jvmtiError\n+set_ext_event_callback(jvmtiEnv* jvmti,  const char* ename, jvmtiExtensionEvent callback) {\n+  jvmtiExtensionEventInfo* info = find_ext_event(jvmti, ename);\n+\n+  if (info == NULL) {\n+    LOG(\"jvmti_common set_ext_event_callback: Extension event was not found: %s\\n\", ename);\n+    return JVMTI_ERROR_NOT_AVAILABLE;\n+  }\n+  jvmtiError err = jvmti->SetExtensionEventCallback(info->extension_event_index, callback);\n+  return err;\n+}\n+\n+\/** Enable or disable given events. *\/\n+\n+static jvmtiError\n+set_event_notification_mode(jvmtiEnv* jvmti, jvmtiEventMode mode, jvmtiEvent event_type, jthread event_thread) {\n+  jvmtiError err = jvmti->SetEventNotificationMode(mode, event_type, event_thread);\n+  return err;\n+}\n+\n+static void\n+set_event_notification_mode(jvmtiEnv* jvmti, JNIEnv* jni, jvmtiEventMode mode, jvmtiEvent event_type, jthread event_thread) {\n+  jvmtiError err = jvmti->SetEventNotificationMode(mode, event_type, event_thread);\n+  check_jvmti_status(jni, err, \"jvmti_common set_event_notification_mode: Error in JVMTI SetEventNotificationMode\");\n+}\n+\n+int\n+enable_events_notifications(jvmtiEnv* jvmti, JNIEnv* jni, jvmtiEventMode enable, int size, jvmtiEvent list[], jthread thread) {\n+  for (int i = 0; i < size; i++) {\n+    check_jvmti_status(jni, jvmti->SetEventNotificationMode(enable, list[i], thread), \"\");\n+  }\n+  return JNI_TRUE;\n+}\n+\n+void\n+sleep_ms(int millis) {\n+#ifdef _WIN32\n+  Sleep(millis);\n+#else\n+  usleep(1000 * millis);\n+#endif\n+}\n+\n+void\n+sleep_sec(jlong timeout) {\n+  int seconds = (int)((timeout + 999) \/ 1000);\n+#ifdef _WIN32\n+  Sleep(1000L * seconds);\n+#else\n+  sleep(seconds);\n+#endif\n+}\n+\n+#endif\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/jvmti_common.h","additions":910,"deletions":0,"binary":false,"changes":910,"status":"added"},{"patch":"@@ -402,0 +402,2 @@\n+  public native void cleanMetaspaces();\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}