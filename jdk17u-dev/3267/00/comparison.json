{"files":[{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4184283\n+ * @summary Checks rendering of dithered byte packed image does not crash.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.IndexColorModel;\n+import java.awt.image.MemoryImageSource;\n+import java.awt.image.WritableRaster;\n+\n+public class DitherTest extends Component {\n+\n+    final static int NOOP = 0;\n+    final static int RED = 1;\n+    final static int GREEN = 2;\n+    final static int BLUE = 3;\n+    final static int ALPHA = 4;\n+    final static int SATURATION = 5;\n+\n+    final static byte red[] = {(byte)0, (byte)132, (byte)0, (byte)132, (byte)0, (byte)132,\n+                         (byte)0, (byte)198, (byte)198, (byte)165, (byte)255, (byte)165, (byte)132,\n+                         (byte)255, (byte)0, (byte)255};\n+\n+    final static byte green[] = {(byte)0, (byte)0, (byte)130, (byte)130, (byte)0,\n+                           (byte)0, (byte)130, (byte)195, (byte)223, (byte)203, (byte)251, (byte)162,\n+                           (byte)132, (byte)0, (byte)255, (byte)255};\n+\n+    final static byte blue[] = {(byte)0, (byte)0, (byte)0, (byte)0, (byte)132, (byte)132,\n+                          (byte)132, (byte)198, (byte)198, (byte)247, (byte)247, (byte)165, (byte)132,\n+                          (byte)0, (byte)0, (byte)0};\n+\n+    static IndexColorModel cm16 = new IndexColorModel( 4, 16, red, green, blue);\n+\n+\n+    public static void main(String args[]) {\n+\n+        int imageWidth = 256;\n+        int imageHeight = 256;\n+        WritableRaster raster = cm16.createCompatibleWritableRaster(imageWidth, imageHeight);\n+        BufferedImage intermediateImage = new BufferedImage(cm16, raster, false, null);\n+        Image calculatedImage = calculateImage();\n+\n+        Graphics2D ig = intermediateImage.createGraphics();\n+        \/\/ Clear background and fill a red rectangle just to prove that we can draw on intermediateImage\n+        ig.setColor(Color.white);\n+        ig.fillRect(0,0,imageWidth,imageHeight);\n+        ig.drawImage(calculatedImage, 0, 0, imageWidth, imageHeight, null);\n+        ig.setColor(Color.red);\n+        ig.fillRect(0,0,5,5);\n+\n+        BufferedImage destImage = new BufferedImage(imageWidth, imageWidth, BufferedImage.TYPE_INT_RGB);\n+        Graphics2D dg = destImage.createGraphics();\n+        dg.drawImage(intermediateImage, 0, 0, imageWidth, imageHeight, null);\n+    }\n+\n+    private static void applymethod(int c[], int method, int step, int total, int vals[]) {\n+        if (method == NOOP)\n+            return;\n+        int val = ((total < 2)\n+                   ? vals[0]\n+                   : vals[0] + ((vals[1] - vals[0]) * step \/ (total - 1)));\n+        switch (method) {\n+        case RED:\n+            c[0] = val;\n+            break;\n+        case GREEN:\n+            c[1] = val;\n+            break;\n+        case BLUE:\n+            c[2] = val;\n+            break;\n+        case ALPHA:\n+            c[3] = val;\n+            break;\n+        case SATURATION:\n+            int max = Math.max(Math.max(c[0], c[1]), c[2]);\n+            int min = max * (255 - val) \/ 255;\n+            if (c[0] == 0) c[0] = min;\n+            if (c[1] == 0) c[1] = min;\n+            if (c[2] == 0) c[2] = min;\n+            break;\n+        }\n+    }\n+\n+    private static Image calculateImage() {\n+\n+        int xvals[] = { 0, 255 };\n+        int yvals[] = { 0, 255 };\n+        int xmethod = RED;\n+        int ymethod = BLUE;\n+        int width = 256;\n+        int height = 256;\n+        int pixels[] = new int[width * height];\n+        int c[] = new int[4];\n+        int index = 0;\n+        for (int j = 0; j < height; j++) {\n+            for (int i = 0; i < width; i++) {\n+                c[0] = c[1] = c[2] = 0;\n+                c[3] = 255;\n+                if (xmethod < ymethod) {\n+                    applymethod(c, xmethod, i, width, xvals);\n+                    applymethod(c, ymethod, j, height, yvals);\n+                } else {\n+                    applymethod(c, ymethod, j, height, yvals);\n+                    applymethod(c, xmethod, i, width, xvals);\n+                }\n+                pixels[index++] = ((c[3] << 24) |\n+                                   (c[0] << 16) |\n+                                   (c[1] << 8) |\n+                                   (c[2] << 0));\n+            }\n+        }\n+\n+        DitherTest dt = new DitherTest();\n+        return dt.createImage(new MemoryImageSource(width, height, ColorModel.getRGBdefault(), pixels, 0, width));\n+    }\n+}\n+\n","filename":"test\/jdk\/sun\/awt\/image\/BytePackedRaster\/DitherTest.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4213160\n+ * @summary Should generate a black image\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.DataBufferByte;\n+import java.awt.image.IndexColorModel;\n+import java.awt.image.Raster;\n+import java.awt.image.WritableRaster;\n+import java.awt.geom.AffineTransform;\n+\n+public class MultiOp {\n+\n+    public static void main(String[] argv) {\n+\n+       int width = 256;\n+       int height = 256;\n+\n+       int pixelBits = 2; \/\/ 1, 2, 4, or 8\n+       \/\/ 1 and 8 make the code throw ImagingOpException, 2 and 4\n+       \/\/ make the code SEGV on Sol.\n+\n+       byte[] lut1Arr = new byte[] {0, (byte)255 };\n+       byte[] lut2Arr = new byte[] {0, (byte)85, (byte)170, (byte)255};\n+       byte[] lut4Arr = new byte[] {0, (byte)17, (byte)34, (byte)51,\n+                                  (byte)68, (byte)85,(byte) 102, (byte)119,\n+                                  (byte)136, (byte)153, (byte)170, (byte)187,\n+                                  (byte)204, (byte)221, (byte)238, (byte)255};\n+       byte[] lut8Arr = new byte[256];\n+       for (int i = 0; i < 256; i++) {\n+           lut8Arr[i] = (byte)i;\n+       }\n+\n+       \/\/ Create the binary image\n+       int bytesPerRow = width * pixelBits \/ 8;\n+       byte[] imageData = new byte[height * bytesPerRow];\n+       ColorModel cm = null;\n+\n+       switch (pixelBits) {\n+       case 1:\n+           cm = new IndexColorModel(pixelBits, lut1Arr.length,\n+                                    lut1Arr, lut1Arr, lut1Arr);\n+           break;\n+       case 2:\n+           cm = new IndexColorModel(pixelBits, lut2Arr.length,\n+                                    lut2Arr, lut2Arr, lut2Arr);\n+           break;\n+       case 4:\n+           cm = new IndexColorModel(pixelBits, lut4Arr.length,\n+                                    lut4Arr, lut4Arr, lut4Arr);\n+           break;\n+       case 8:\n+           cm = new IndexColorModel(pixelBits, lut8Arr.length,\n+                                    lut8Arr, lut8Arr, lut8Arr);\n+           break;\n+       default:\n+           {new Exception(\"Invalid # of bit per pixel\").printStackTrace();}\n+       }\n+\n+       DataBuffer db = new DataBufferByte(imageData, imageData.length);\n+       WritableRaster r = Raster.createPackedRaster(db, width, height,\n+                                                    pixelBits, null);\n+       BufferedImage srcImage = new BufferedImage(cm, r, false, null);\n+\n+       BufferedImage destImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n+       Graphics2D g = destImage.createGraphics();\n+       AffineTransform af = AffineTransform.getScaleInstance(.5, .5);\n+       \/\/ This draw image is the problem\n+       g.drawImage(srcImage, af, null);\n+       int blackPixel = Color.black.getRGB();\n+       for (int x = 0; x < width; x++) {\n+           for (int y = 0; y < height; y++) {\n+              if (destImage.getRGB(x, y) != blackPixel) {\n+                  throw new RuntimeException(\"Not black\");\n+              }\n+          }\n+      }\n+   }\n+}\n","filename":"test\/jdk\/sun\/awt\/image\/BytePackedRaster\/MultiOp.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4673490\n+ * @summary This test verifies that Toolkit images with a 1-bit\n+ * IndexColorModel (known as ByteBinary) and a transparent index are rendered properly.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+\n+import java.awt.image.BufferedImage;\n+import java.awt.image.IndexColorModel;\n+\n+public class ByteBinaryBitmask {\n+\n+    public static void main(String argv[]) throws Exception {\n+\n+        \/* Create the image *\/\n+        int w = 16, h = 16;\n+        byte[] bw = { (byte)255, (byte)0, };\n+        IndexColorModel icm = new IndexColorModel(1, 2, bw, bw, bw, 0);\n+        BufferedImage img = new BufferedImage(w, h, BufferedImage.TYPE_BYTE_BINARY, icm);\n+        Graphics2D g2d = img.createGraphics();\n+        g2d.setColor(Color.white);\n+        g2d.fillRect(0, 0, w, h);\n+        g2d.setColor(Color.black);\n+        int xoff = 5;\n+        g2d.fillRect(xoff, 5, 1, 10); \/\/ 1 pixel wide\n+\n+        int dw = 200, dh = 50;\n+        BufferedImage dest = new BufferedImage(dw, dh, BufferedImage.TYPE_INT_RGB);\n+        Graphics2D g = dest.createGraphics();\n+        g.setColor(Color.green);\n+        g.fillRect(0, 0, dw, dh);\n+        int x1 = 10;\n+        int x2 = 50;\n+        int x3 = 90;\n+        int x4 = 130;\n+        g.drawImage(img, x1, 10, null);\n+        g.drawImage(img, x2, 10, null);\n+        g.drawImage(img, x3, 10, null);\n+        g.drawImage(img, x4, 10, null);\n+\n+        int blackPix = Color.black.getRGB();\n+        for (int y = 0; y < dh; y++) {\n+            boolean isBlack = false;\n+            for (int x = 0; x < dw; x++) {\n+               int rgb = dest.getRGB(x, y);\n+               if (rgb == blackPix) {\n+                   \/* Src image has a one pixel wide vertical rect at off \"xoff\" and\n+                    * this is drawn at x1\/x2\/x3\/x4) so the sum of those are the x locations\n+                    * to expect black.\n+                    *\/\n+                   if (x != (x1 + xoff) && x != (x2 + xoff) && x != (x3 + xoff) && x!= (x4 + xoff)) {\n+                       throw new RuntimeException(\"wrong x location: \" +x);\n+                   }\n+                   if (isBlack) {\n+                       throw new RuntimeException(\"black after black\");\n+                   }\n+               }\n+               isBlack = rgb == blackPix;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/awt\/image\/ImageRepresentation\/ByteBinaryBitmask.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 4192756\n+ * @summary Tests that using a non-default colormodel generates correct images under 16\/24 bit mode\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.DirectColorModel;\n+import java.awt.image.ComponentColorModel;\n+import java.awt.image.MemoryImageSource;\n+import java.util.Arrays;\n+\n+\/*\n+ * NOTE: This bug only appears under specific conditions.  If the background of\n+ * the surface is red, then you are not running under the conditions necessary\n+ * to test for the regression so the results of this test will be inconclusive.\n+ *\n+ * The test should be run under any of the following screen depths\/surfaces:\n+ *\n+ * 15-bit, otherwise known as 555 RGB or 32768 (thousands) colors\n+ * 16-bit, otherwise known as 565 RGB or 65536 (thousands) colors\n+ * 24-bit, otherwise known as 16777216 (millions) colors\n+ *\n+ * The test draws 2 rectangles.  Both rectangles should be half black (left)\n+ * and half blue (right).  If the top rectangle is all black, the test fails.\n+ * If the background is red, the results are inconclusive (see above).\n+*\/\n+\n+public class CustomSourceCM extends Component {\n+\n+    public static int IMG_W = 80;\n+    public static int IMG_H = 30;\n+\n+    static void test(int imageType) {\n+\n+        int w = IMG_W + 20;\n+        int h = IMG_H * 2 + 40;\n+        BufferedImage bi = new BufferedImage(w, h, imageType);\n+\n+        DirectColorModel dcm;\n+\n+        \/* the next dozen lines or so are intended to help\n+         * ascertain if the destination surface is of the type\n+         * that exhibited the original bug, making the background\n+         * white in those cases. It is not strictly necessary.\n+         * It is only for a manual tester to be able to tell by looking.\n+         * The real test is the check for black and blue later on.\n+         *\/\n+        Graphics2D g = bi.createGraphics();\n+        g.setColor(Color.red);\n+        g.fillRect(0, 0, w, h);\n+\n+        ColorModel cm = bi.getColorModel();\n+        if (cm instanceof ComponentColorModel) {\n+            g.setColor(Color.white);\n+            g.fillRect(0, 0, w, h);\n+        } else if (cm instanceof DirectColorModel) {\n+            dcm = (DirectColorModel) cm;\n+            if (dcm.getPixelSize() < 24) {\n+                g.setColor(Color.white);\n+                g.fillRect(0, 0, w, h);\n+            }\n+        }\n+\n+        \/\/ Construct a ColorModel and data for a 16-bit 565 image...\n+        dcm = new DirectColorModel(16, 0x1f, 0x7e0, 0xf800);\n+\n+        \/\/ Create an image which is black on the left, blue on the right.\n+        int[] pixels = new int[IMG_W * IMG_H];\n+        int blue = dcm.getBlueMask();\n+        int off = 0;\n+        for (int y = 0; y < IMG_H; y++) {\n+            Arrays.fill(pixels, off, off+IMG_W\/2, 0);\n+            Arrays.fill(pixels, off+IMG_W\/2, off+IMG_W, blue);\n+            off += IMG_W;\n+        }\n+        MemoryImageSource mis = new MemoryImageSource(IMG_W, IMG_H, dcm,\n+                                                      pixels, 0, IMG_W);\n+        CustomSourceCM comp = new CustomSourceCM();\n+        Image img = comp.createImage(mis);\n+\n+        \/\/ Draw the image on to the surface.\n+        g.drawImage(img, 10, 10, null);\n+\n+        \/\/ Create a similar effect with 2 fillrects, below the image.\n+        g.setColor(Color.black);\n+        g.fillRect(10, 60, IMG_W\/2, IMG_H);\n+        g.setColor(Color.blue);\n+        g.fillRect(10+IMG_W\/2, 60, IMG_W\/2, IMG_H);\n+\n+        \/\/ Now sample points in the image to confirm they are the expected color.\n+        int bluePix = Color.blue.getRGB();\n+        int blackPix = Color.black.getRGB();\n+        int black_topLeft = bi.getRGB(10+IMG_W\/4, 10+IMG_H\/2);\n+        int blue_topRight = bi.getRGB(10+IMG_W*3\/4, 10+IMG_H\/2);\n+        int black_bottomLeft = bi.getRGB(10+IMG_W\/4, 60+IMG_H\/2);\n+        int blue_bottomRight = bi.getRGB(10+IMG_W*3\/4, 60+IMG_H\/2);\n+        if ((black_topLeft != blackPix) || (black_bottomLeft != blackPix) ||\n+            (blue_topRight != bluePix) ||  (blue_bottomRight != bluePix)) {\n+\n+            String fileName = \"failed \" + imageType + \".png\";\n+            try {\n+                javax.imageio.ImageIO.write(bi, \"png\", new java.io.File(fileName));\n+            } catch (Exception e) { };\n+            throw new RuntimeException(\"unexpected colors\");\n+        }\n+    }\n+\n+    public static void main(String argv[]) {\n+        test(BufferedImage.TYPE_USHORT_555_RGB);\n+        test(BufferedImage.TYPE_USHORT_565_RGB);\n+        test(BufferedImage.TYPE_3BYTE_BGR);\n+    }\n+}\n","filename":"test\/jdk\/sun\/awt\/image\/ImageRepresentation\/CustomSourceCM.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"}]}