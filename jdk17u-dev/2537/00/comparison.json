{"files":[{"patch":"@@ -104,16 +104,31 @@\n-  int total()                                    { return total_size; }\n-  bool is_empty()                                { return count == 0; }\n-\n-  void print(const char* title) {\n-    tty->print_cr(\" #%d %s = %dK (hdr %d%%,  loc %d%%, code %d%%, stub %d%%, [oops %d%%, metadata %d%%, data %d%%, pcs %d%%])\",\n-                  count,\n-                  title,\n-                  (int)(total() \/ K),\n-                  header_size             * 100 \/ total_size,\n-                  relocation_size         * 100 \/ total_size,\n-                  code_size               * 100 \/ total_size,\n-                  stub_size               * 100 \/ total_size,\n-                  scopes_oop_size         * 100 \/ total_size,\n-                  scopes_metadata_size    * 100 \/ total_size,\n-                  scopes_data_size        * 100 \/ total_size,\n-                  scopes_pcs_size         * 100 \/ total_size);\n+  int total() const                              { return total_size; }\n+  bool is_empty() const                          { return count == 0; }\n+\n+  void print(const char* title) const {\n+    if (is_empty()) {\n+      tty->print_cr(\" #%d %s = %dK\",\n+                    count,\n+                    title,\n+                    total()                 \/ (int)K);\n+    } else {\n+      tty->print_cr(\" #%d %s = %dK (hdr %dK %d%%, loc %dK %d%%, code %dK %d%%, stub %dK %d%%, [oops %dK %d%%, metadata %dK %d%%, data %dK %d%%, pcs %dK %d%%])\",\n+                    count,\n+                    title,\n+                    total()                 \/ (int)K,\n+                    header_size             \/ (int)K,\n+                    header_size             * 100 \/ total_size,\n+                    relocation_size         \/ (int)K,\n+                    relocation_size         * 100 \/ total_size,\n+                    code_size               \/ (int)K,\n+                    code_size               * 100 \/ total_size,\n+                    stub_size               \/ (int)K,\n+                    stub_size               * 100 \/ total_size,\n+                    scopes_oop_size         \/ (int)K,\n+                    scopes_oop_size         * 100 \/ total_size,\n+                    scopes_metadata_size    \/ (int)K,\n+                    scopes_metadata_size    * 100 \/ total_size,\n+                    scopes_data_size        \/ (int)K,\n+                    scopes_data_size        * 100 \/ total_size,\n+                    scopes_pcs_size         \/ (int)K,\n+                    scopes_pcs_size         * 100 \/ total_size);\n+    }\n@@ -1471,2 +1486,8 @@\n-  CodeBlob_sizes live;\n-  CodeBlob_sizes dead;\n+  CodeBlob_sizes live[CompLevel_full_optimization + 1];\n+  CodeBlob_sizes dead[CompLevel_full_optimization + 1];\n+  CodeBlob_sizes runtimeStub;\n+  CodeBlob_sizes uncommonTrapStub;\n+  CodeBlob_sizes deoptimizationStub;\n+  CodeBlob_sizes adapter;\n+  CodeBlob_sizes bufferBlob;\n+  CodeBlob_sizes other;\n@@ -1476,2 +1497,18 @@\n-      if (!cb->is_alive()) {\n-        dead.add(cb);\n+      if (cb->is_nmethod()) {\n+        const int level = cb->as_nmethod()->comp_level();\n+        assert(0 <= level && level <= CompLevel_full_optimization, \"Invalid compilation level\");\n+        if (!cb->is_alive()) {\n+          dead[level].add(cb);\n+        } else {\n+          live[level].add(cb);\n+        }\n+      } else if (cb->is_runtime_stub()) {\n+        runtimeStub.add(cb);\n+      } else if (cb->is_deoptimization_stub()) {\n+        deoptimizationStub.add(cb);\n+      } else if (cb->is_uncommon_trap_stub()) {\n+        uncommonTrapStub.add(cb);\n+      } else if (cb->is_adapter_blob()) {\n+        adapter.add(cb);\n+      } else if (cb->is_buffer_blob()) {\n+        bufferBlob.add(cb);\n@@ -1479,1 +1516,1 @@\n-        live.add(cb);\n+        other.add(cb);\n@@ -1484,1 +1521,0 @@\n-  tty->print_cr(\"CodeCache:\");\n@@ -1487,5 +1523,30 @@\n-  if (!live.is_empty()) {\n-    live.print(\"live\");\n-  }\n-  if (!dead.is_empty()) {\n-    dead.print(\"dead\");\n+  tty->print_cr(\"nmethod blobs per compilation level:\");\n+  for (int i = 0; i <= CompLevel_full_optimization; i++) {\n+    const char *level_name;\n+    switch (i) {\n+    case CompLevel_none:              level_name = \"none\";              break;\n+    case CompLevel_simple:            level_name = \"simple\";            break;\n+    case CompLevel_limited_profile:   level_name = \"limited profile\";   break;\n+    case CompLevel_full_profile:      level_name = \"full profile\";      break;\n+    case CompLevel_full_optimization: level_name = \"full optimization\"; break;\n+    default: assert(false, \"invalid compilation level\");\n+    }\n+    tty->print_cr(\"%s:\", level_name);\n+    live[i].print(\"live\");\n+    dead[i].print(\"dead\");\n+  }\n+\n+  struct {\n+    const char* name;\n+    const CodeBlob_sizes* sizes;\n+  } non_nmethod_blobs[] = {\n+    { \"runtime\",        &runtimeStub },\n+    { \"uncommon trap\",  &uncommonTrapStub },\n+    { \"deoptimization\", &deoptimizationStub },\n+    { \"adapter\",        &adapter },\n+    { \"buffer blob\",    &bufferBlob },\n+    { \"other\",          &other },\n+  };\n+  tty->print_cr(\"Non-nmethod blobs:\");\n+  for (auto& blob: non_nmethod_blobs) {\n+    blob.sizes->print(blob.name);\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":88,"deletions":27,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test CheckCodeCacheInfo\n+ * @bug 8005885\n+ * @summary Checks VM verbose information related to the code cache\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   compiler.codecache.CheckCodeCacheInfo\n+ *\/\n+\n+package compiler.codecache;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class CheckCodeCacheInfo {\n+    private static final String VERBOSE_REGEXP;\n+\n+    static {\n+        String entry = \"\\\\d+K( \\\\(hdr \\\\d+K \\\\d+%, loc \\\\d+K \\\\d+%, code \\\\d+K \\\\d+%, stub \\\\d+K \\\\d+%, \\\\[oops \\\\d+K \\\\d+%, metadata \\\\d+K \\\\d+%, data \\\\d+K \\\\d+%, pcs \\\\d+K \\\\d+%\\\\]\\\\))?\\\\n\";\n+        String pair = \" #\\\\d+ live = \" + entry\n+                    + \" #\\\\d+ dead = \" + entry;\n+\n+        VERBOSE_REGEXP = \"nmethod blobs per compilation level:\\\\n\"\n+                       + \"none:\\\\n\"\n+                       + pair\n+                       + \"simple:\\\\n\"\n+                       + pair\n+                       + \"limited profile:\\\\n\"\n+                       + pair\n+                       + \"full profile:\\\\n\"\n+                       + pair\n+                       + \"full optimization:\\\\n\"\n+                       + pair\n+                       + \"Non-nmethod blobs:\\\\n\"\n+                       + \" #\\\\d+ runtime = \" + entry\n+                       + \" #\\\\d+ uncommon trap = \" + entry\n+                       + \" #\\\\d+ deoptimization = \" + entry\n+                       + \" #\\\\d+ adapter = \" + entry\n+                       + \" #\\\\d+ buffer blob = \" + entry\n+                       + \" #\\\\d+ other = \" + entry;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb;\n+\n+        pb = ProcessTools.createJavaProcessBuilder(\"-XX:+PrintCodeCache\",\n+                                                   \"-XX:+Verbose\",\n+                                                   \"-version\");\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+        out.shouldHaveExitValue(0);\n+        out.stdoutShouldMatch(VERBOSE_REGEXP);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CheckCodeCacheInfo.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"}]}