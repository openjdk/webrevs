{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -76,1 +77,1 @@\n-        Thread thread = new hs201t002Thread();\n+        hs201t002Thread thread = new hs201t002Thread();\n@@ -81,1 +82,0 @@\n-        setThread(thread);\n@@ -84,0 +84,10 @@\n+        \/\/ setThread(thread) enables JVMTI events, and that can only be done on a live thread,\n+        \/\/ so wait until the thread has started.\n+        try {\n+            thread.ready.await();\n+        } catch (InterruptedException e) {\n+        }\n+        setThread(thread);\n+\n+        thread.go.countDown();\n+\n@@ -117,0 +127,4 @@\n+            for (int i = 0; i < stackTrace.length; i++) {\n+                log.display(\"\\t\" + i + \". \" + stackTrace[i]);\n+            }\n+            log.display(\"Retrying...\");\n@@ -139,0 +153,3 @@\n+    CountDownLatch ready = new CountDownLatch(1);\n+    CountDownLatch go = new CountDownLatch(1);\n+\n@@ -145,0 +162,5 @@\n+        ready.countDown();\n+        try {\n+            go.await();\n+        } catch (InterruptedException e) {\n+        }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS201\/hs201t002.java","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,2 +74,2 @@\n- *      -agentlib:hs201t002=pathToNewByteCode=.\/bin,-waittime=5\n- *      nsk.jvmti.scenarios.hotswap.HS201.hs201t002\n+ *      -agentlib:hs201t002=pathToNewByteCode=.\/bin,-waittime=5,-verbose\n+ *      nsk.jvmti.scenarios.hotswap.HS201.hs201t002 -verbose\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS201\/hs201t002\/TestDescription.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,3 +48,0 @@\n-static int redefineNumber;\n-static jint newClassSize;\n-static unsigned char* newClassBytes;\n@@ -53,1 +50,0 @@\n-char chbuffer[255];\n@@ -55,1 +51,7 @@\n-const char* getThreadName(JNIEnv* jni_env, jthread thread);\n+\/\/ callbackException (isCatch == false) and callbackExceptionCatch (isCatch == true) handler\n+void handleException(bool isCatch,\n+    jvmtiEnv* jvmti_env, JNIEnv* jni_env, jthread thread,\n+    jmethodID method, jlocation location,\n+    jobject exception);\n+\n+const char* getThreadName(jvmtiEnv* jvmti_env, JNIEnv* jni_env, jthread thread);\n@@ -57,1 +59,1 @@\n-int readNewBytecode(jvmtiEnv* jvmti);\n+int readNewBytecode(jvmtiEnv* jvmti, jint *newClassSize, unsigned char* *newClassBytes);\n@@ -102,1 +104,0 @@\n-\n@@ -104,0 +105,2 @@\n+    jint newClassSize;\n+    unsigned char* newClassBytes;\n@@ -110,1 +113,1 @@\n-    if (!NSK_VERIFY(readNewBytecode(jvmti_env))) {\n+    if (!NSK_VERIFY(readNewBytecode(jvmti_env, &newClassSize, &newClassBytes))) {\n@@ -113,0 +116,1 @@\n+        jvmti_env->Deallocate((unsigned char*)className);\n@@ -124,1 +128,0 @@\n-        return;\n@@ -130,0 +133,3 @@\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate(newClassBytes))) {\n+        nsk_jvmti_setFailStatus();\n+    }\n@@ -139,1 +145,0 @@\n-    redefineNumber = 1;\n@@ -147,1 +152,1 @@\n-    NSK_DISPLAY0(\"\\n\\n>>>> Debugge started, waiting for class loading \\n\");\n+    NSK_DISPLAY0(\">>>> Debugge started, waiting for class loading \\n\");\n@@ -186,1 +191,0 @@\n-    char *generic;\n@@ -188,1 +192,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, &generic))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, NULL))) {\n@@ -194,2 +198,1 @@\n-        NSK_DISPLAY1(\"\\n\\n>>>> Class loaded: %s\", className);\n-        NSK_DISPLAY0(\", activating breakpoint\\n\");\n+        NSK_DISPLAY1(\">>>> Class loaded: %s, activating breakpoint\\n\", className);\n@@ -202,5 +205,0 @@\n-\n-    if (generic != NULL)\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*)generic))) {\n-            nsk_jvmti_setFailStatus();\n-        }\n@@ -219,1 +217,1 @@\n-    NSK_DISPLAY0(\"\\n\\n>>>>Breakpoint fired, enabling SINGLE_STEP\\n\");\n+    NSK_DISPLAY0(\">>>>Breakpoint fired, enabling SINGLE_STEP\\n\");\n@@ -269,1 +267,1 @@\n-                NSK_DISPLAY1(\"\\n\\n>>>> Checking if redefined method is not obsolete\\n\", testStep);\n+                NSK_DISPLAY1(\">>>> Checking if redefined method is not obsolete\\n\", testStep);\n@@ -286,1 +284,1 @@\n-                NSK_DISPLAY1(\"\\n\\n>>>> Popping the currently executing frame\\n\", testStep);\n+                NSK_DISPLAY1(\">>>> Popping the currently executing frame\\n\", testStep);\n@@ -295,1 +293,1 @@\n-                    NSK_DISPLAY1(\"\\n\\n>>>> Disabling single step\\n\", testStep);\n+                    NSK_DISPLAY1(\">>>> Disabling single step\\n\", testStep);\n@@ -305,1 +303,1 @@\n-            NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to method name\\n\\n\");\n+            NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to declaringClassName\\n\\n\");\n@@ -327,18 +325,1 @@\n-    const char *className;\n-\n-    className = getClassName(jvmti_env, jni_env, exception);\n-\n-    if (strcmp(EXPECTED_CLASS_SIGN, className) == 0) {\n-        jclass klass;\n-\n-        NSK_DISPLAY2(\"\\n\\n>>>> Exception %s in thread - %s\\n\",\n-                        className, getThreadName(jni_env, thread));\n-\n-        testStep++;\n-        if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != NULL)) {\n-            nsk_jvmti_setFailStatus();\n-            return;\n-        }\n-\n-        redefineClass(jvmti_env, klass);\n-    }\n+    handleException(false, jvmti_env, jni_env, thread, method, location, exception);\n@@ -358,1 +339,4 @@\n-    const char *className;\n+    handleException(true, jvmti_env, jni_env, thread, method, location, exception);\n+}\n+\n+\/* ============================================================================= *\/\n@@ -360,1 +344,5 @@\n-    className = getClassName(jvmti_env, jni_env, exception);\n+void handleException(bool isCatch,\n+                     jvmtiEnv* jvmti_env, JNIEnv* jni_env, jthread thread,\n+                     jmethodID method, jlocation location,\n+                     jobject exception) {\n+    const char* className = getClassName(jvmti_env, jni_env, exception);\n@@ -362,1 +350,1 @@\n-    if (strcmp(EXPECTED_CLASS_SIGN, className) == 0) {\n+    if (className != NULL && strcmp(EXPECTED_CLASS_SIGN, className) == 0) {\n@@ -365,2 +353,7 @@\n-        NSK_DISPLAY2(\"\\n\\n>>>> Caught exception %s in thread - %s\\n\",\n-                        className, getThreadName(jni_env, thread));\n+        const char* threadName = getThreadName(jvmti_env, jni_env, thread);\n+        NSK_DISPLAY3(\">>>> %s %s in thread - %s\\n\", isCatch ? \"Caught exception\" : \"Exception\",\n+            className, threadName != NULL ? threadName : \"NULL\");\n+        jvmti->Deallocate((unsigned char*)className);\n+        if (threadName != NULL) {\n+            jvmti->Deallocate((unsigned char*)threadName);\n+        }\n@@ -376,0 +369,1 @@\n+\n@@ -378,1 +372,0 @@\n-\/* ============================================================================= *\/\n@@ -380,1 +373,1 @@\n-int readNewBytecode(jvmtiEnv* jvmti) {\n+int readNewBytecode(jvmtiEnv* jvmti, jint *newClassSize, unsigned char* *newClassBytes) {\n@@ -406,1 +399,1 @@\n-    newClassSize = ftell(bytecode);\n+    *newClassSize = ftell(bytecode);\n@@ -409,1 +402,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->Allocate(newClassSize, &newClassBytes))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti->Allocate(*newClassSize, newClassBytes))) {\n@@ -413,1 +406,1 @@\n-    read_bytes = (jint) fread(newClassBytes, 1, newClassSize, bytecode);\n+    read_bytes = (jint) fread(*newClassBytes, 1, *newClassSize, bytecode);\n@@ -415,1 +408,1 @@\n-    if (read_bytes != newClassSize) {\n+    if (read_bytes != *newClassSize) {\n@@ -417,0 +410,2 @@\n+        jvmti->Deallocate(*newClassBytes);\n+        *newClassBytes = NULL;\n@@ -425,1 +420,1 @@\n-const char* getThreadName(JNIEnv* jni_env, jthread thread) {\n+const char* getThreadName(jvmtiEnv* jvmti_env, JNIEnv* jni_env, jthread thread) {\n@@ -429,0 +424,2 @@\n+    jsize jthreadNameLen;\n+    unsigned char *result = NULL;\n@@ -431,2 +428,0 @@\n-    strcpy(chbuffer, \"\");\n-\n@@ -435,1 +430,1 @@\n-        return chbuffer;\n+        return NULL;\n@@ -441,1 +436,1 @@\n-        return chbuffer;\n+        return NULL;\n@@ -446,0 +441,7 @@\n+    jthreadNameLen = jni_env->GetStringUTFLength(jthreadName);\n+\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->Allocate(jthreadNameLen + 1, &result))) {\n+        NSK_COMPLAIN0(\"buffer couldn't be allocated\\n\");\n+        return NULL;\n+    }\n+\n@@ -448,1 +450,1 @@\n-    strcpy(chbuffer, threadName);\n+    memcpy(result, threadName, jthreadNameLen + 1);\n@@ -452,1 +454,1 @@\n-    return chbuffer;\n+    return (char*)result;\n@@ -460,1 +462,0 @@\n-    char *generic;\n@@ -463,2 +464,0 @@\n-    strcpy(chbuffer, \"\");\n-\n@@ -467,6 +466,1 @@\n-        return chbuffer;\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, &generic))) {\n-        nsk_jvmti_setFailStatus();\n-        return chbuffer;\n+        return NULL;\n@@ -475,3 +469,1 @@\n-    strcpy(chbuffer, className);\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*)className))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, NULL))) {\n@@ -479,0 +471,1 @@\n+        return NULL;\n@@ -481,6 +474,1 @@\n-    if (generic != NULL)\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*)generic))) {\n-            nsk_jvmti_setFailStatus();\n-        }\n-\n-    return chbuffer;\n+    return className;\n@@ -549,0 +537,4 @@\n+    enableEvent(jvmti, JVMTI_EVENT_CLASS_LOAD, testedThread);\n+    enableEvent(jvmti, JVMTI_EVENT_BREAKPOINT, testedThread);\n+    enableEvent(jvmti, JVMTI_EVENT_EXCEPTION, testedThread);\n+    enableEvent(jvmti, JVMTI_EVENT_EXCEPTION_CATCH, testedThread);\n@@ -668,5 +660,0 @@\n-    enableEvent(jvmti, JVMTI_EVENT_CLASS_LOAD, testedThread);\n-    enableEvent(jvmti, JVMTI_EVENT_BREAKPOINT, testedThread);\n-    enableEvent(jvmti, JVMTI_EVENT_EXCEPTION, testedThread);\n-    enableEvent(jvmti, JVMTI_EVENT_EXCEPTION_CATCH, testedThread);\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS201\/hs201t002\/hs201t002.cpp","additions":72,"deletions":85,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+        System.out.println(\"Current step: \" + hs201t002.currentStep); \/\/ Avoid calling classloader to find hs201t002 in doInit()\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS201\/hs201t002\/newclass\/hs201t002a.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}