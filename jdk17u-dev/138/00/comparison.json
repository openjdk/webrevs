{"files":[{"patch":"@@ -1835,13 +1835,0 @@\n-\/\/ Enforces volatile semantics for a non-volatile read.\n-class VolatileRead : public StackObj {\n- public:\n-  VolatileRead() {\n-    \/\/ Ensures a possibly volatile read is not reordered with a prior\n-    \/\/ volatile write.\n-    OrderAccess::storeload();\n-  }\n-  ~VolatileRead() {\n-    OrderAccess::acquire();\n-  }\n-};\n-\n@@ -1888,1 +1875,2 @@\n-  if (displacement < 0 || ((long) displacement + type2aelembytes(basic_type) > HeapWordSize * obj->size())) {\n+  int basic_type_elemsize = type2aelembytes(basic_type);\n+  if (displacement < 0 || ((long) displacement + basic_type_elemsize > HeapWordSize * obj->size())) {\n@@ -1895,0 +1883,4 @@\n+  bool aligned = (displacement % basic_type_elemsize) == 0;\n+  if (!aligned) {\n+    JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"read is unaligned\");\n+  }\n@@ -1935,6 +1927,1 @@\n-  \/\/ folding Unsafe.get* methods with volatile semantics. This is done by\n-  \/\/ performing the volatile barrier operations around a call to an\n-  \/\/ oopDesc::<kind>_field method. The oopDesc::<kind>_field_acquire method\n-  \/\/ cannot be used since it does not support unaligned reads on all platforms\n-  \/\/ (e.g., an unaligned ldar on AArch64 causes a SIGBUS).\n-\n+  \/\/ folding Unsafe.get* methods with volatile semantics.\n@@ -1943,4 +1930,4 @@\n-    case T_BOOLEAN: { VolatileRead vr; value = obj->bool_field(displacement); } break;\n-    case T_BYTE:    { VolatileRead vr; value = obj->byte_field(displacement); } break;\n-    case T_SHORT:   { VolatileRead vr; value = obj->short_field(displacement);} break;\n-    case T_CHAR:    { VolatileRead vr; value = obj->char_field(displacement); } break;\n+    case T_BOOLEAN: value = obj->bool_field_acquire(displacement);  break;\n+    case T_BYTE:    value = obj->byte_field_acquire(displacement);  break;\n+    case T_SHORT:   value = obj->short_field_acquire(displacement); break;\n+    case T_CHAR:    value = obj->char_field_acquire(displacement);  break;\n@@ -1948,1 +1935,1 @@\n-    case T_INT:     { VolatileRead vr; value = obj->int_field(displacement);  } break;\n+    case T_INT:     value = obj->int_field_acquire(displacement);   break;\n@@ -1950,1 +1937,1 @@\n-    case T_LONG:    { VolatileRead vr; value = obj->long_field(displacement); } break;\n+    case T_LONG:    value = obj->long_field_acquire(displacement);  break;\n@@ -1960,2 +1947,1 @@\n-      oop value;\n-      { VolatileRead vr; value = obj->obj_field(displacement); }\n+      oop value = obj->obj_field_acquire(displacement);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":14,"deletions":28,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -786,1 +786,1 @@\n-     * object is exptected to be a subtype of {@code expectedType} and extra sanity checking is\n+     * object is expected to be a subtype of {@code expectedType} and extra sanity checking is\n@@ -788,0 +788,2 @@\n+     *\n+     * @throws IllegalArgumentException if any of the sanity checks fail\n@@ -793,1 +795,1 @@\n-     * object is exptected to be a subtype of {@code expectedType} and extra sanity checking is\n+     * object is expected to be a subtype of {@code expectedType} and extra sanity checking is\n@@ -795,0 +797,2 @@\n+     *\n+     * @throws IllegalArgumentException if any of the sanity checks fail\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-     *             kind or {@code bits} is not 8, 16, 32 or 64\n+     *             kind or {@code bits} is not 8, 16, 32 or 64, or the read is unaligned\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/MemoryAccessProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,0 +80,7 @@\n+        }\n+        return result.toArray(new Object[result.size()][]);\n+    }\n+    @DataProvider(name = \"unalignedPrimitive\")\n+    public static Object[][] getUnalignedPrimitiveJavaKinds() {\n+        List<Object[]> result = new ArrayList<>();\n+        for (KindData k : PRIMITIVE_KIND_DATA) {\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/MemoryAccessProviderData.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -67,0 +67,5 @@\n+    @Test(dataProvider = \"unalignedPrimitive\", dataProviderClass = MemoryAccessProviderData.class, expectedExceptions = {IllegalArgumentException.class})\n+    public void testReadUnalignedConstantConstant(JavaKind kind, Constant base, Long offset, Object expected, int bitsCount) {\n+        PROVIDER.readPrimitiveConstant(kind, null, offset, bitsCount);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/MemoryAccessProviderTest.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}