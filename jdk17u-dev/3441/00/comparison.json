{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,2 @@\n+#define USE_TRAMPOLINE_STUB_FIX_OWNER\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/globalDefinitions_aarch64.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,2 +161,7 @@\n-  address addr = (address)this;\n-  address destination = instruction_address() + displacement();\n+  address addr = instruction_address();\n+  address destination = addr + displacement();\n+\n+  \/\/ Performance optimization: no need to call find_blob() if it is a self-call\n+  if (destination == addr) {\n+    return destination;\n+  }\n@@ -166,2 +171,2 @@\n-  assert(cb && cb->is_nmethod(), \"sanity\");\n-  nmethod *nm = (nmethod *)cb;\n+  assert(cb != nullptr && cb->is_nmethod(), \"nmethod expected\");\n+  nmethod *nm = cb->as_nmethod();\n@@ -182,6 +187,2 @@\n-\/\/\n-\/\/ Add parameter assert_lock to switch off assertion\n-\/\/ during code generation, where no patching lock is needed.\n-void NativeCall::set_destination_mt_safe(address dest, bool assert_lock) {\n-  assert(!assert_lock ||\n-         (Patching_lock->is_locked() || SafepointSynchronize::is_at_safepoint()) ||\n+void NativeCall::set_destination_mt_safe(address dest) {\n+  assert((Patching_lock->is_locked() || SafepointSynchronize::is_at_safepoint()) ||\n@@ -214,1 +215,1 @@\n-  address call_addr = addr_at(0);\n+  address call_addr = instruction_address();\n@@ -217,1 +218,2 @@\n-  assert(code != NULL, \"Could not find the containing code blob\");\n+  assert(code != nullptr && code->is_nmethod(), \"nmethod expected\");\n+  nmethod* nm = code->as_nmethod();\n@@ -219,3 +221,2 @@\n-  address bl_destination\n-    = MacroAssembler::pd_call_destination(call_addr);\n-  if (code->contains(bl_destination) &&\n+  address bl_destination = call_addr + displacement();\n+  if (nm->stub_contains(bl_destination) &&\n@@ -225,5 +226,1 @@\n-  if (code->is_nmethod()) {\n-    return trampoline_stub_Relocation::get_trampoline_for(call_addr, (nmethod*)code);\n-  }\n-\n-  return NULL;\n+  return trampoline_stub_Relocation::get_trampoline_for(call_addr, nm);\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":18,"deletions":21,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,0 +215,1 @@\n+  address raw_destination() const { return instruction_address() + displacement(); }\n@@ -254,3 +255,1 @@\n-\n-  \/\/ The parameter assert_lock disables the assertion during code generation.\n-  void set_destination_mt_safe(address dest, bool assert_lock = true);\n+  void set_destination_mt_safe(address dest);\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -63,4 +63,4 @@\n-  if (NativeCall::is_call_at(addr())) {\n-    address trampoline = nativeCall_at(addr())->get_trampoline();\n-    if (trampoline) {\n-      return nativeCallTrampolineStub_at(trampoline)->destination();\n+  if (orig_addr == nullptr) {\n+    if (NativeCall::is_call_at(addr())) {\n+      NativeCall* call = nativeCall_at(addr());\n+      return call->destination();\n@@ -68,2 +68,1 @@\n-  }\n-  if (orig_addr != NULL) {\n+  } else {\n@@ -85,5 +84,4 @@\n-    address trampoline = nativeCall_at(addr())->get_trampoline();\n-    if (trampoline) {\n-      nativeCall_at(addr())->set_destination_mt_safe(x, \/* assert_lock *\/false);\n-      return;\n-    }\n+    NativeCall* call = nativeCall_at(addr());\n+    call->set_destination(x);\n+  } else {\n+    MacroAssembler::pd_patch_instruction(addr(), x);\n@@ -91,1 +89,0 @@\n-  MacroAssembler::pd_patch_instruction(addr(), x);\n@@ -95,0 +92,12 @@\n+void trampoline_stub_Relocation::pd_fix_owner_after_move() {\n+  NativeCall* call = nativeCall_at(owner());\n+  assert(call->raw_destination() == owner(), \"destination should be empty\");\n+  address trampoline = addr();\n+  address dest = nativeCallTrampolineStub_at(trampoline)->destination();\n+  if (!Assembler::reachable_from_branch_at(owner(), dest)) {\n+    dest = trampoline;\n+  }\n+  call->set_destination(dest);\n+}\n+\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -362,0 +362,8 @@\n+#ifdef USE_TRAMPOLINE_STUB_FIX_OWNER\n+void trampoline_stub_Relocation::fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest) {\n+  \/\/ Finalize owner destination only for nmethods\n+  if (dest->blob() != nullptr) return;\n+  pd_fix_owner_after_move();\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1186,0 +1186,5 @@\n+#ifdef USE_TRAMPOLINE_STUB_FIX_OWNER\n+  void pd_fix_owner_after_move();\n+  void fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest) override;\n+#endif\n+\n@@ -1207,2 +1212,2 @@\n-  void pack_data_to(CodeSection * dest);\n-  void unpack_data();\n+  void pack_data_to(CodeSection * dest) override;\n+  void unpack_data() override;\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"}]}