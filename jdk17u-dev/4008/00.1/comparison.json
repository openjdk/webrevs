{"files":[{"patch":"@@ -28,6 +28,0 @@\n-import sun.awt.AppContext;\n-import sun.awt.SunToolkit;\n-\n-import java.util.Collections;\n-import java.util.Map;\n-import java.util.WeakHashMap;\n@@ -39,0 +33,1 @@\n+import java.awt.Graphics2D;\n@@ -41,0 +36,1 @@\n+import java.awt.Stroke;\n@@ -42,0 +38,5 @@\n+import java.awt.geom.AffineTransform;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.WeakHashMap;\n+\n@@ -47,0 +48,3 @@\n+\n+import sun.awt.AppContext;\n+import sun.awt.SunToolkit;\n@@ -50,0 +54,2 @@\n+import static sun.java2d.pipe.Region.clipRound;\n+\n@@ -123,0 +129,25 @@\n+    \/**\n+     * Returns delegate {@code RepaintManager} for {@code component} hierarchy.\n+     *\/\n+    public static RepaintManager getDelegateRepaintManager(Component\n+                                                            component) {\n+        RepaintManager delegate = null;\n+        if (Boolean.TRUE == SunToolkit.targetToAppContext(component)\n+                                      .get(DELEGATE_REPAINT_MANAGER_KEY)) {\n+            while (delegate == null && component != null) {\n+                while (component != null\n+                         && ! (component instanceof JComponent)) {\n+                    component = component.getParent();\n+                }\n+                if (component != null) {\n+                    delegate = (RepaintManager)\n+                        ((JComponent) component)\n+                          .getClientProperty(DELEGATE_REPAINT_MANAGER_KEY);\n+                    component = component.getParent();\n+                }\n+\n+            }\n+        }\n+        return delegate;\n+    }\n+\n@@ -237,1 +268,5 @@\n-     * Returns delegate {@code RepaintManager} for {@code component} hierarchy.\n+     * A task which paints an <i>unscaled<\/i> border after {@code Graphics}\n+     * transforms are removed. It's used with the\n+     * {@link #paintBorder(Component, Graphics, int, int, int, int, UnscaledBorderPainter)\n+     * SwingUtilities3.paintBorder} which manages changing the transforms and calculating\n+     * the coordinates and size of the border.\n@@ -239,16 +274,55 @@\n-    public static RepaintManager getDelegateRepaintManager(Component\n-                                                            component) {\n-        RepaintManager delegate = null;\n-        if (Boolean.TRUE == SunToolkit.targetToAppContext(component)\n-                                      .get(DELEGATE_REPAINT_MANAGER_KEY)) {\n-            while (delegate == null && component != null) {\n-                while (component != null\n-                         && ! (component instanceof JComponent)) {\n-                    component = component.getParent();\n-                }\n-                if (component != null) {\n-                    delegate = (RepaintManager)\n-                        ((JComponent) component)\n-                          .getClientProperty(DELEGATE_REPAINT_MANAGER_KEY);\n-                    component = component.getParent();\n-                }\n+    @FunctionalInterface\n+    public interface UnscaledBorderPainter {\n+        \/**\n+         * Paints the border for the specified component after the\n+         * {@code Graphics} transforms are removed.\n+         *\n+         * <p>\n+         * The <i>x<\/i> and <i>y<\/i> of the painted border are zero.\n+         *\n+         * @param c the component for which this border is being painted\n+         * @param g the paint graphics\n+         * @param w the width of the painted border, in physical pixels\n+         * @param h the height of the painted border, in physical pixels\n+         * @param scaleFactor the scale that was in the {@code Graphics}\n+         *\n+         * @see #paintBorder(Component, Graphics, int, int, int, int, UnscaledBorderPainter)\n+         * SwingUtilities3.paintBorder\n+         * @see javax.swing.border.Border#paintBorder(Component, Graphics, int, int, int, int)\n+         * Border.paintBorder\n+         *\/\n+        void paintUnscaledBorder(Component c, Graphics g,\n+                                 int w, int h,\n+                                 double scaleFactor);\n+    }\n+\n+    \/**\n+     * Paints the border for a component ensuring its sides have consistent\n+     * thickness at different scales.\n+     * <p>\n+     * It performs the following steps:\n+     * <ol>\n+     *     <li>Reset the scale transform on the {@code Graphics},<\/li>\n+     *     <li>Call {@code painter} to paint the border,<\/li>\n+     *     <li>Restores the transform.<\/li>\n+     * <\/ol>\n+     *\n+     * @param c the component for which this border is being painted\n+     * @param g the paint graphics\n+     * @param x the x position of the painted border\n+     * @param y the y position of the painted border\n+     * @param w the width of the painted border\n+     * @param h the height of the painted border\n+     * @param painter the painter object which paints the border after\n+     *                the transform on the {@code Graphics} is reset\n+     *\/\n+    public static void paintBorder(Component c, Graphics g,\n+                                   int x, int y,\n+                                   int w, int h,\n+                                   UnscaledBorderPainter painter) {\n+\n+        \/\/ Step 1: Reset Transform\n+        AffineTransform at = null;\n+        Stroke oldStroke = null;\n+        boolean resetTransform = false;\n+        double scaleFactor = 1;\n@@ -256,0 +330,43 @@\n+        int xtranslation = x;\n+        int ytranslation = y;\n+        int width = w;\n+        int height = h;\n+\n+        if (g instanceof Graphics2D) {\n+            Graphics2D g2d = (Graphics2D) g;\n+            at = g2d.getTransform();\n+            oldStroke = g2d.getStroke();\n+            scaleFactor = Math.min(at.getScaleX(), at.getScaleY());\n+\n+            \/\/ if m01 or m10 is non-zero, then there is a rotation or shear,\n+            \/\/ or if scale=1, skip resetting the transform in these cases.\n+            resetTransform = ((at.getShearX() == 0) && (at.getShearY() == 0))\n+                    && ((at.getScaleX() > 1) || (at.getScaleY() > 1));\n+\n+            if (resetTransform) {\n+                \/* Deactivate the HiDPI scaling transform,\n+                 * so we can do paint operations in the device\n+                 * pixel coordinate system instead of the logical coordinate system.\n+                 *\/\n+                g2d.setTransform(new AffineTransform());\n+                double xx = at.getScaleX() * x + at.getTranslateX();\n+                double yy = at.getScaleY() * y + at.getTranslateY();\n+                xtranslation = clipRound(xx);\n+                ytranslation = clipRound(yy);\n+                width = clipRound(at.getScaleX() * w + xx) - xtranslation;\n+                height = clipRound(at.getScaleY() * h + yy) - ytranslation;\n+            }\n+        }\n+\n+        g.translate(xtranslation, ytranslation);\n+\n+        \/\/ Step 2: Call respective paintBorder with transformed values\n+        painter.paintUnscaledBorder(c, g, width, height, scaleFactor);\n+\n+        \/\/ Step 3: Restore previous stroke & transform\n+        g.translate(-xtranslation, -ytranslation);\n+        if (g instanceof Graphics2D) {\n+            Graphics2D g2d = (Graphics2D) g;\n+            g2d.setStroke(oldStroke);\n+            if (resetTransform) {\n+                g2d.setTransform(at);\n@@ -258,1 +375,0 @@\n-        return delegate;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/SwingUtilities3.java","additions":140,"deletions":24,"binary":false,"changes":164,"status":"modified"}]}