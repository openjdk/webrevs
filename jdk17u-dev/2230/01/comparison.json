{"files":[{"patch":"@@ -133,0 +133,7 @@\n+  assert(is_aligned(start_addr, CardTable::card_size), \"precondition\");\n+\n+  if (start_addr == end_addr) {\n+    \/\/ No objects in empty range.\n+    return false;\n+  }\n+\n@@ -134,1 +141,1 @@\n-  jbyte* end_block = block_for_addr(end_addr);\n+  jbyte* end_block = block_for_addr(end_addr - 1);\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -150,3 +150,5 @@\n-  \/\/ Return true if an object starts in the range of heap addresses.\n-  \/\/ If an object starts at an address corresponding to\n-  \/\/ \"start\", the method will return true.\n+  \/\/ Return true iff an object starts in\n+  \/\/   [start_addr, end_addr_aligned_up)\n+  \/\/ where\n+  \/\/   end_addr_aligned_up = align_up(end_addr, _card_size)\n+  \/\/ Precondition: start_addr is card-size aligned\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,3 +58,0 @@\n-  develop(uintx, GCWorkerDelayMillis, 0,                                    \\\n-          \"Delay in scheduling GC workers (in milliseconds)\")               \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallel_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/spinYield.hpp\"\n@@ -120,0 +121,186 @@\n+static void prefetch_write(void *p) {\n+  if (PrefetchScanIntervalInBytes >= 0) {\n+    Prefetch::write(p, PrefetchScanIntervalInBytes);\n+  }\n+}\n+\n+void PSCardTable::scan_obj_with_limit(PSPromotionManager* pm,\n+                                      oop obj,\n+                                      HeapWord* start,\n+                                      HeapWord* end) {\n+  if (!obj->is_typeArray()) {\n+    prefetch_write(start);\n+    pm->push_contents_bounded(obj, start, end);\n+  }\n+}\n+\n+void PSCardTable::pre_scavenge(HeapWord* old_gen_bottom, uint active_workers) {\n+  _preprocessing_active_workers = active_workers;\n+}\n+\n+\/\/ The \"shadow\" table is a copy of the card table entries of the current stripe.\n+\/\/ It is used to separate card reading, clearing and redirtying which reduces\n+\/\/ complexity significantly.\n+class PSStripeShadowCardTable {\n+  typedef CardTable::CardValue CardValue;\n+\n+  const uint _card_shift;\n+  const uint _card_size;\n+  CardValue _table[PSCardTable::num_cards_in_stripe];\n+  const CardValue* _table_base;\n+\n+public:\n+  PSStripeShadowCardTable(PSCardTable* pst, HeapWord* const start, HeapWord* const end) :\n+    _card_shift(CardTable::card_shift),\n+    _card_size(CardTable::card_size),\n+    _table_base(_table - (uintptr_t(start) >> _card_shift)) {\n+    size_t stripe_byte_size = pointer_delta(end, start) * HeapWordSize;\n+    size_t copy_length = align_up(stripe_byte_size, _card_size) >> _card_shift;\n+    \/\/ The end of the last stripe may not be card aligned as it is equal to old\n+    \/\/ gen top at scavenge start. We should not clear the card containing old gen\n+    \/\/ top if not card aligned because there can be promoted objects on that\n+    \/\/ same card. If it was marked dirty because of the promoted objects and we\n+    \/\/ cleared it, we would loose a card mark.\n+    size_t clear_length = align_down(stripe_byte_size, _card_size) >> _card_shift;\n+    CardValue* stripe_start_card = pst->byte_for(start);\n+    memcpy(_table, stripe_start_card, copy_length);\n+    memset(stripe_start_card, CardTable::clean_card_val(), clear_length);\n+  }\n+\n+  HeapWord* addr_for(const CardValue* const card) {\n+    assert(card >= _table && card <=  &_table[PSCardTable::num_cards_in_stripe], \"out of bounds\");\n+    return (HeapWord*) ((card - _table_base) << _card_shift);\n+  }\n+\n+  const CardValue* card_for(HeapWord* addr) {\n+    return &_table_base[uintptr_t(addr) >> _card_shift];\n+  }\n+\n+  bool is_dirty(const CardValue* const card) {\n+    return !is_clean(card);\n+  }\n+\n+  bool is_clean(const CardValue* const card) {\n+    assert(card >= _table && card <  &_table[PSCardTable::num_cards_in_stripe], \"out of bounds\");\n+    return *card == PSCardTable::clean_card_val();\n+  }\n+\n+  const CardValue* find_first_dirty_card(const CardValue* const start,\n+                                         const CardValue* const end) {\n+    for (const CardValue* i = start; i < end; ++i) {\n+      if (is_dirty(i)) {\n+        return i;\n+      }\n+    }\n+    return end;\n+  }\n+\n+  const CardValue* find_first_clean_card(const CardValue* const start,\n+                                         const CardValue* const end) {\n+    for (const CardValue* i = start; i < end; ++i) {\n+      if (is_clean(i)) {\n+        return i;\n+      }\n+    }\n+    return end;\n+  }\n+};\n+\n+template <typename Func>\n+void PSCardTable::process_range(Func&& object_start,\n+                                PSPromotionManager* pm,\n+                                HeapWord* const start,\n+                                HeapWord* const end) {\n+  assert(start < end, \"precondition\");\n+  assert(is_card_aligned(start), \"precondition\");\n+\n+  PSStripeShadowCardTable sct(this, start, end);\n+\n+  \/\/ end might not be card-aligned.\n+  const CardValue* end_card = sct.card_for(end - 1) + 1;\n+\n+  for (HeapWord* i_addr = start; i_addr < end; \/* empty *\/) {\n+    const CardValue* dirty_l = sct.find_first_dirty_card(sct.card_for(i_addr), end_card);\n+    const CardValue* dirty_r = sct.find_first_clean_card(dirty_l, end_card);\n+\n+    assert(dirty_l <= dirty_r, \"inv\");\n+\n+    if (dirty_l == dirty_r) {\n+      assert(dirty_r == end_card, \"inv\");\n+      break;\n+    }\n+\n+    \/\/ Located a non-empty dirty chunk [dirty_l, dirty_r).\n+    HeapWord* addr_l = sct.addr_for(dirty_l);\n+    HeapWord* addr_r = MIN2(sct.addr_for(dirty_r), end);\n+\n+    \/\/ Scan objects overlapping [addr_l, addr_r) limited to [start, end).\n+    HeapWord* obj_addr = object_start(addr_l);\n+\n+    while (true) {\n+      assert(obj_addr < addr_r, \"inv\");\n+\n+      oop obj = cast_to_oop(obj_addr);\n+      const bool is_obj_array = obj->is_objArray();\n+      HeapWord* const obj_end_addr = obj_addr + obj->size();\n+\n+      if (is_obj_array) {\n+        \/\/ Always scan obj arrays precisely (they are always marked precisely)\n+        \/\/ to avoid unnecessary work.\n+        scan_obj_with_limit(pm, obj, addr_l, addr_r);\n+      } else {\n+        if (obj_addr < i_addr && i_addr > start) {\n+          \/\/ Already scanned this object. Has been one that spans multiple dirty chunks.\n+          \/\/ The second condition makes sure objects reaching in the stripe are scanned once.\n+        } else {\n+          scan_obj_with_limit(pm, obj, addr_l, end);\n+        }\n+      }\n+\n+      if (obj_end_addr >= addr_r) {\n+        i_addr = is_obj_array ? addr_r : obj_end_addr;\n+        break;\n+      }\n+\n+      \/\/ Move to next obj inside this dirty chunk.\n+      obj_addr = obj_end_addr;\n+    }\n+\n+    \/\/ Finished a dirty chunk.\n+    pm->drain_stacks_cond_depth();\n+  }\n+}\n+\n+template <typename Func>\n+void PSCardTable::preprocess_card_table_parallel(Func&& object_start,\n+                                                 HeapWord* old_gen_bottom,\n+                                                 HeapWord* old_gen_top,\n+                                                 uint stripe_index,\n+                                                 uint n_stripes) {\n+  const size_t num_cards_in_slice = num_cards_in_stripe * n_stripes;\n+  CardValue* cur_card = byte_for(old_gen_bottom) + stripe_index * num_cards_in_stripe;\n+  CardValue* const end_card = byte_for(old_gen_top - 1) + 1;\n+\n+  for (\/* empty *\/; cur_card < end_card; cur_card += num_cards_in_slice) {\n+    HeapWord* stripe_addr = addr_for(cur_card);\n+    if (is_dirty(cur_card)) {\n+      \/\/ The first card of this stripe is already dirty, no need to see if the\n+      \/\/ reaching-in object is a potentially imprecisely marked non-array\n+      \/\/ object.\n+      continue;\n+    }\n+    HeapWord* first_obj_addr = object_start(stripe_addr);\n+    if (first_obj_addr == stripe_addr) {\n+      \/\/ No object reaching into this stripe.\n+      continue;\n+    }\n+    oop first_obj = cast_to_oop(first_obj_addr);\n+    if (!first_obj->is_array() && is_dirty(byte_for(first_obj_addr))) {\n+      \/\/ Found a non-array object reaching into the stripe that has\n+      \/\/ potentially been marked imprecisely. Mark first card of the stripe\n+      \/\/ dirty so it will be processed later.\n+      *cur_card = dirty_card_val();\n+    }\n+  }\n+}\n+\n@@ -125,3 +312,1 @@\n-\/\/ do no work.  If this method needs to be called\n-\/\/ when the space is empty, fix the calculation of\n-\/\/ end_card to allow sp_top == sp->bottom().\n+\/\/ do no work. This method is just a no-op if space_top == sp->bottom().\n@@ -131,1 +316,1 @@\n-\/\/ a stripe is a constant, ssize.\n+\/\/ a stripe is a constant, num_cards_in_stripe.\n@@ -155,5 +340,12 @@\n-\/\/ the next slice is calculated based on the number of stripes.  The next\n-\/\/ stripe is at ssize * number_of_stripes (= slice_stride)..  So after\n-\/\/ finishing stripe 0 in slice 0, the thread finds the stripe 0 in slice1 by\n-\/\/ adding slice_stride to the start of stripe 0 in slice 0 to get to the start\n-\/\/ of stride 0 in slice 1.\n+\/\/ the next slice is calculated based on the number of stripes. After finishing\n+\/\/ stripe 0 in slice 0, the thread finds the stripe 0 in slice 1 by adding\n+\/\/ slice_size_in_words to the start of stripe 0 in slice 0 to get to the start\n+\/\/ of stripe 0 in slice 1.\n+\n+\/\/ Scavenging and accesses to the card table are strictly limited to the stripe.\n+\/\/ In particular scavenging of an object crossing stripe boundaries is shared\n+\/\/ among the threads assigned to the stripes it resides on. This reduces\n+\/\/ complexity and enables shared scanning of large objects.\n+\/\/ It requires preprocessing of the card table though where imprecise card marks of\n+\/\/ objects crossing stripe boundaries are propagated to the first card of\n+\/\/ each stripe covered by the individual object.\n@@ -162,2 +354,2 @@\n-                                             MutableSpace* sp,\n-                                             HeapWord* space_top,\n+                                             HeapWord* old_gen_bottom,\n+                                             HeapWord* old_gen_top,\n@@ -165,40 +357,13 @@\n-                                             uint stripe_number,\n-                                             uint stripe_total) {\n-  int ssize = 128; \/\/ Naked constant!  Work unit = 64k.\n-  int dirty_card_count = 0;\n-\n-  \/\/ It is a waste to get here if empty.\n-  assert(sp->bottom() < sp->top(), \"Should not be called if empty\");\n-  oop* sp_top = (oop*)space_top;\n-  CardValue* start_card = byte_for(sp->bottom());\n-  CardValue* end_card   = byte_for(sp_top - 1) + 1;\n-  oop* last_scanned = NULL; \/\/ Prevent scanning objects more than once\n-  \/\/ The width of the stripe ssize*stripe_total must be\n-  \/\/ consistent with the number of stripes so that the complete slice\n-  \/\/ is covered.\n-  size_t slice_width = ssize * stripe_total;\n-  for (CardValue* slice = start_card; slice < end_card; slice += slice_width) {\n-    CardValue* worker_start_card = slice + stripe_number * ssize;\n-    if (worker_start_card >= end_card)\n-      return; \/\/ We're done.\n-\n-    CardValue* worker_end_card = worker_start_card + ssize;\n-    if (worker_end_card > end_card)\n-      worker_end_card = end_card;\n-\n-    \/\/ We do not want to scan objects more than once. In order to accomplish\n-    \/\/ this, we assert that any object with an object head inside our 'slice'\n-    \/\/ belongs to us. We may need to extend the range of scanned cards if the\n-    \/\/ last object continues into the next 'slice'.\n-    \/\/\n-    \/\/ Note! ending cards are exclusive!\n-    HeapWord* slice_start = addr_for(worker_start_card);\n-    HeapWord* slice_end = MIN2((HeapWord*) sp_top, addr_for(worker_end_card));\n-\n-#ifdef ASSERT\n-    if (GCWorkerDelayMillis > 0) {\n-      \/\/ Delay 1 worker so that it proceeds after all the work\n-      \/\/ has been completed.\n-      if (stripe_number < 2) {\n-        os::naked_sleep(GCWorkerDelayMillis);\n-      }\n+                                             uint stripe_index,\n+                                             uint n_stripes) {\n+  \/\/ ObjectStartArray queries can be expensive for large objects. We cache known objects.\n+  struct {\n+    HeapWord* start_addr;\n+    HeapWord* end_addr;\n+  } cached_obj {nullptr, old_gen_bottom};\n+\n+  \/\/ Queries must be monotonic because we don't check addr >= cached_obj.start_addr.\n+  auto object_start = [&] (HeapWord* addr) {\n+    if (addr < cached_obj.end_addr) {\n+      assert(cached_obj.start_addr != nullptr, \"inv\");\n+      return cached_obj.start_addr;\n@@ -206,1 +371,1 @@\n-#endif\n+    HeapWord* result = start_array->object_start(addr);\n@@ -208,41 +373,2 @@\n-    \/\/ If there are not objects starting within the chunk, skip it.\n-    if (!start_array->object_starts_in_range(slice_start, slice_end)) {\n-      continue;\n-    }\n-    \/\/ Update our beginning addr\n-    HeapWord* first_object = start_array->object_start(slice_start);\n-    debug_only(oop* first_object_within_slice = (oop*) first_object;)\n-    if (first_object < slice_start) {\n-      last_scanned = (oop*)(first_object + cast_to_oop(first_object)->size());\n-      debug_only(first_object_within_slice = last_scanned;)\n-      worker_start_card = byte_for(last_scanned);\n-    }\n-\n-    \/\/ Update the ending addr\n-    if (slice_end < (HeapWord*)sp_top) {\n-      \/\/ The subtraction is important! An object may start precisely at slice_end.\n-      HeapWord* last_object = start_array->object_start(slice_end - 1);\n-      slice_end = last_object + cast_to_oop(last_object)->size();\n-      \/\/ worker_end_card is exclusive, so bump it one past the end of last_object's\n-      \/\/ covered span.\n-      worker_end_card = byte_for(slice_end) + 1;\n-\n-      if (worker_end_card > end_card)\n-        worker_end_card = end_card;\n-    }\n-\n-    assert(slice_end <= (HeapWord*)sp_top, \"Last object in slice crosses space boundary\");\n-    assert(is_valid_card_address(worker_start_card), \"Invalid worker start card\");\n-    assert(is_valid_card_address(worker_end_card), \"Invalid worker end card\");\n-    \/\/ Note that worker_start_card >= worker_end_card is legal, and happens when\n-    \/\/ an object spans an entire slice.\n-    assert(worker_start_card <= end_card, \"worker start card beyond end card\");\n-    assert(worker_end_card <= end_card, \"worker end card beyond end card\");\n-\n-    CardValue* current_card = worker_start_card;\n-    while (current_card < worker_end_card) {\n-      \/\/ Find an unclean card.\n-      while (current_card < worker_end_card && card_is_clean(*current_card)) {\n-        current_card++;\n-      }\n-      CardValue* first_unclean_card = current_card;\n+    cached_obj.start_addr = result;\n+    cached_obj.end_addr = result + cast_to_oop(result)->size();\n@@ -250,5 +376,2 @@\n-      \/\/ Find the end of a run of contiguous unclean cards\n-      while (current_card < worker_end_card && !card_is_clean(*current_card)) {\n-        while (current_card < worker_end_card && !card_is_clean(*current_card)) {\n-          current_card++;\n-        }\n+    return result;\n+  };\n@@ -256,40 +379,2 @@\n-        if (current_card < worker_end_card) {\n-          \/\/ Some objects may be large enough to span several cards. If such\n-          \/\/ an object has more than one dirty card, separated by a clean card,\n-          \/\/ we will attempt to scan it twice. The test against \"last_scanned\"\n-          \/\/ prevents the redundant object scan, but it does not prevent newly\n-          \/\/ marked cards from being cleaned.\n-          HeapWord* last_object_in_dirty_region = start_array->object_start(addr_for(current_card)-1);\n-          size_t size_of_last_object = cast_to_oop(last_object_in_dirty_region)->size();\n-          HeapWord* end_of_last_object = last_object_in_dirty_region + size_of_last_object;\n-          CardValue* ending_card_of_last_object = byte_for(end_of_last_object);\n-          assert(ending_card_of_last_object <= worker_end_card, \"ending_card_of_last_object is greater than worker_end_card\");\n-          if (ending_card_of_last_object > current_card) {\n-            \/\/ This means the object spans the next complete card.\n-            \/\/ We need to bump the current_card to ending_card_of_last_object\n-            current_card = ending_card_of_last_object;\n-          }\n-        }\n-      }\n-      CardValue* following_clean_card = current_card;\n-\n-      if (first_unclean_card < worker_end_card) {\n-        oop* p = (oop*) start_array->object_start(addr_for(first_unclean_card));\n-        assert((HeapWord*)p <= addr_for(first_unclean_card), \"checking\");\n-        \/\/ \"p\" should always be >= \"last_scanned\" because newly GC dirtied\n-        \/\/ cards are no longer scanned again (see comment at end\n-        \/\/ of loop on the increment of \"current_card\").  Test that\n-        \/\/ hypothesis before removing this code.\n-        \/\/ If this code is removed, deal with the first time through\n-        \/\/ the loop when the last_scanned is the object starting in\n-        \/\/ the previous slice.\n-        assert((p >= last_scanned) ||\n-               (last_scanned == first_object_within_slice),\n-               \"Should no longer be possible\");\n-        if (p < last_scanned) {\n-          \/\/ Avoid scanning more than once; this can happen because\n-          \/\/ newgen cards set by GC may a different set than the\n-          \/\/ originally dirty set\n-          p = last_scanned;\n-        }\n-        oop* to = (oop*)addr_for(following_clean_card);\n+  \/\/ Prepare scavenge.\n+  preprocess_card_table_parallel(object_start, old_gen_bottom, old_gen_top, stripe_index, n_stripes);\n@@ -297,16 +382,6 @@\n-        \/\/ Test slice_end first!\n-        if ((HeapWord*)to > slice_end) {\n-          to = (oop*)slice_end;\n-        } else if (to > sp_top) {\n-          to = sp_top;\n-        }\n-\n-        \/\/ we know which cards to scan, now clear them\n-        if (first_unclean_card <= worker_start_card+1)\n-          first_unclean_card = worker_start_card+1;\n-        if (following_clean_card >= worker_end_card-1)\n-          following_clean_card = worker_end_card-1;\n-\n-        while (first_unclean_card < following_clean_card) {\n-          *first_unclean_card++ = clean_card;\n-        }\n+  \/\/ Sync with other workers.\n+  Atomic::dec(&_preprocessing_active_workers);\n+  SpinYield spin_yield;\n+  while (Atomic::load_acquire(&_preprocessing_active_workers) > 0) {\n+    spin_yield.wait();\n+  }\n@@ -314,35 +389,11 @@\n-        const int interval = PrefetchScanIntervalInBytes;\n-        \/\/ scan all objects in the range\n-        if (interval != 0) {\n-          while (p < to) {\n-            Prefetch::write(p, interval);\n-            oop m = cast_to_oop(p);\n-            assert(oopDesc::is_oop_or_null(m), \"Expected an oop or NULL for header field at \" PTR_FORMAT, p2i(m));\n-            pm->push_contents(m);\n-            p += m->size();\n-          }\n-          pm->drain_stacks_cond_depth();\n-        } else {\n-          while (p < to) {\n-            oop m = cast_to_oop(p);\n-            assert(oopDesc::is_oop_or_null(m), \"Expected an oop or NULL for header field at \" PTR_FORMAT, p2i(m));\n-            pm->push_contents(m);\n-            p += m->size();\n-          }\n-          pm->drain_stacks_cond_depth();\n-        }\n-        last_scanned = p;\n-      }\n-      \/\/ \"current_card\" is still the \"following_clean_card\" or\n-      \/\/ the current_card is >= the worker_end_card so the\n-      \/\/ loop will not execute again.\n-      assert((current_card == following_clean_card) ||\n-             (current_card >= worker_end_card),\n-        \"current_card should only be incremented if it still equals \"\n-        \"following_clean_card\");\n-      \/\/ Increment current_card so that it is not processed again.\n-      \/\/ It may now be dirty because a old-to-young pointer was\n-      \/\/ found on it an updated.  If it is now dirty, it cannot be\n-      \/\/ be safely cleaned in the next iteration.\n-      current_card++;\n-    }\n+  \/\/ Scavenge\n+  cached_obj = {nullptr, old_gen_bottom};\n+  const size_t stripe_size_in_words = num_cards_in_stripe * card_size_in_words;\n+  const size_t slice_size_in_words = stripe_size_in_words * n_stripes;\n+  HeapWord* cur_addr = old_gen_bottom + stripe_index * stripe_size_in_words;\n+  for (\/* empty *\/; cur_addr < old_gen_top; cur_addr += slice_size_in_words) {\n+    HeapWord* const stripe_l = cur_addr;\n+    HeapWord* const stripe_r = MIN2(cur_addr + stripe_size_in_words,\n+                                    old_gen_top);\n+\n+    process_range(object_start, pm, stripe_l, stripe_r);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":240,"deletions":189,"binary":false,"changes":429,"status":"modified"},{"patch":"@@ -36,1 +36,30 @@\n- private:\n+  friend class PSStripeShadowCardTable;\n+  static constexpr size_t num_cards_in_stripe = 128;\n+  static_assert(num_cards_in_stripe >= 1, \"progress\");\n+\n+  volatile int _preprocessing_active_workers;\n+\n+  bool is_dirty(CardValue* card) {\n+    return !is_clean(card);\n+  }\n+\n+  bool is_clean(CardValue* card) {\n+    return *card == clean_card_val();\n+  }\n+\n+  \/\/ Iterate the stripes with the given index and copy imprecise card marks of\n+  \/\/ objects reaching into a stripe to its first card.\n+  template <typename Func>\n+  void preprocess_card_table_parallel(Func&& object_start,\n+                                      HeapWord* old_gen_bottom,\n+                                      HeapWord* old_gen_top,\n+                                      uint stripe_index,\n+                                      uint n_stripes);\n+\n+  \/\/ Scavenge contents on dirty cards of the given stripe [start, end).\n+  template <typename Func>\n+  void process_range(Func&& object_start,\n+                     PSPromotionManager* pm,\n+                     HeapWord* const start,\n+                     HeapWord* const end);\n+\n@@ -53,0 +82,5 @@\n+  void scan_obj_with_limit(PSPromotionManager* pm,\n+                           oop obj,\n+                           HeapWord* start,\n+                           HeapWord* end);\n+\n@@ -54,1 +88,2 @@\n-  PSCardTable(MemRegion whole_heap) : CardTable(whole_heap) {}\n+  PSCardTable(MemRegion whole_heap) : CardTable(whole_heap),\n+                                      _preprocessing_active_workers(0) {}\n@@ -60,0 +95,2 @@\n+  void pre_scavenge(HeapWord* old_gen_bottom, uint active_workers);\n+  \/\/ Scavenge contents of stripes with the given index.\n@@ -61,2 +98,2 @@\n-                                  MutableSpace* sp,\n-                                  HeapWord* space_top,\n+                                  HeapWord* old_gen_bottom,\n+                                  HeapWord* old_gen_top,\n@@ -64,2 +101,2 @@\n-                                  uint stripe_number,\n-                                  uint stripe_total);\n+                                  uint stripe_index,\n+                                  uint n_stripes);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.hpp","additions":43,"deletions":6,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+  void push_contents_bounded(oop obj, HeapWord* left, HeapWord* right);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -131,0 +131,5 @@\n+inline void PSPromotionManager::push_contents_bounded(oop obj, HeapWord* left, HeapWord* right) {\n+  PSPushContentsClosure pcc(this);\n+  obj->oop_iterate(&pcc, MemRegion(left, right));\n+}\n+\n@@ -221,7 +226,0 @@\n-#ifdef ASSERT\n-            \/\/ Delay the initialization of the promotion lab (plab).\n-            \/\/ This exposes uninitialized plabs to card table processing.\n-            if (GCWorkerDelayMillis > 0) {\n-              os::naked_sleep(GCWorkerDelayMillis);\n-            }\n-#endif\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -91,1 +91,0 @@\n-  PSScavengeRootsClosure roots_closure(pm);\n@@ -304,0 +303,4 @@\n+    if (!_is_empty) {\n+      PSCardTable* card_table = ParallelScavengeHeap::heap()->card_table();\n+      card_table->pre_scavenge(_old_gen->object_space()->bottom(), active_workers);\n+    }\n@@ -323,0 +326,1 @@\n+        \/\/ The top of the old gen changes during scavenge when objects are promoted.\n@@ -324,1 +328,1 @@\n-                                               _old_gen->object_space(),\n+                                               _old_gen->object_space()->bottom(),\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"}]}