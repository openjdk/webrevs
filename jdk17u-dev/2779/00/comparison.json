{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @build Tests\n@@ -35,0 +36,1 @@\n+import static java.lang.Double.longBitsToDouble;\n@@ -45,1 +47,1 @@\n-    static int testCubeRootCase(double input, double expected) {\n+    private static int testCubeRootCase(double input, double expected) {\n@@ -56,1 +58,1 @@\n-    static int testCubeRoot() {\n+    private static int testCubeRoot() {\n@@ -58,0 +60,5 @@\n+\n+        for(double nan : Tests.NaNs) {\n+            failures += testCubeRootCase(nan, NaNd);\n+        }\n+\n@@ -59,11 +66,0 @@\n-            {NaNd,                      NaNd},\n-            {Double.longBitsToDouble(0x7FF0000000000001L),      NaNd},\n-            {Double.longBitsToDouble(0xFFF0000000000001L),      NaNd},\n-            {Double.longBitsToDouble(0x7FF8555555555555L),      NaNd},\n-            {Double.longBitsToDouble(0xFFF8555555555555L),      NaNd},\n-            {Double.longBitsToDouble(0x7FFFFFFFFFFFFFFFL),      NaNd},\n-            {Double.longBitsToDouble(0xFFFFFFFFFFFFFFFFL),      NaNd},\n-            {Double.longBitsToDouble(0x7FFDeadBeef00000L),      NaNd},\n-            {Double.longBitsToDouble(0xFFFDeadBeef00000L),      NaNd},\n-            {Double.longBitsToDouble(0x7FFCafeBabe00000L),      NaNd},\n-            {Double.longBitsToDouble(0xFFFCafeBabe00000L),      NaNd},\n@@ -72,0 +68,1 @@\n+\n","filename":"test\/jdk\/java\/lang\/Math\/CubeRootTests.java","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+ * @build Tests\n+ * @build Expm1Tests\n+ * @run main Expm1Tests\n@@ -30,0 +33,2 @@\n+import static java.lang.Double.longBitsToDouble;\n+\n@@ -51,1 +56,1 @@\n-    static int testExpm1() {\n+    private static int testExpm1() {\n@@ -54,0 +59,4 @@\n+        for(double nan : Tests.NaNs) {\n+            failures += testExpm1Case(nan, NaNd);\n+        }\n+\n@@ -55,11 +64,0 @@\n-            {Double.NaN,                NaNd},\n-            {Double.longBitsToDouble(0x7FF0000000000001L),      NaNd},\n-            {Double.longBitsToDouble(0xFFF0000000000001L),      NaNd},\n-            {Double.longBitsToDouble(0x7FF8555555555555L),      NaNd},\n-            {Double.longBitsToDouble(0xFFF8555555555555L),      NaNd},\n-            {Double.longBitsToDouble(0x7FFFFFFFFFFFFFFFL),      NaNd},\n-            {Double.longBitsToDouble(0xFFFFFFFFFFFFFFFFL),      NaNd},\n-            {Double.longBitsToDouble(0x7FFDeadBeef00000L),      NaNd},\n-            {Double.longBitsToDouble(0xFFFDeadBeef00000L),      NaNd},\n-            {Double.longBitsToDouble(0x7FFCafeBabe00000L),      NaNd},\n-            {Double.longBitsToDouble(0xFFFCafeBabe00000L),      NaNd},\n","filename":"test\/jdk\/java\/lang\/Math\/Expm1Tests.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+ * @build Tests\n+ * @build HyperbolicTests\n+ * @run main HyperbolicTests\n@@ -30,0 +33,2 @@\n+import static java.lang.Double.longBitsToDouble;\n+\n@@ -251,0 +256,4 @@\n+        for(double nan : Tests.NaNs) {\n+            failures += testSinhCaseWithUlpDiff(nan, NaNd, 0);\n+        }\n+\n@@ -253,11 +262,0 @@\n-            {NaNd,                      NaNd},\n-            {Double.longBitsToDouble(0x7FF0000000000001L),      NaNd},\n-            {Double.longBitsToDouble(0xFFF0000000000001L),      NaNd},\n-            {Double.longBitsToDouble(0x7FF8555555555555L),      NaNd},\n-            {Double.longBitsToDouble(0xFFF8555555555555L),      NaNd},\n-            {Double.longBitsToDouble(0x7FFFFFFFFFFFFFFFL),      NaNd},\n-            {Double.longBitsToDouble(0xFFFFFFFFFFFFFFFFL),      NaNd},\n-            {Double.longBitsToDouble(0x7FFDeadBeef00000L),      NaNd},\n-            {Double.longBitsToDouble(0xFFFDeadBeef00000L),      NaNd},\n-            {Double.longBitsToDouble(0x7FFCafeBabe00000L),      NaNd},\n-            {Double.longBitsToDouble(0xFFFCafeBabe00000L),      NaNd},\n@@ -593,0 +591,4 @@\n+        for(double nan : Tests.NaNs) {\n+            failures += testCoshCaseWithUlpDiff(nan, NaNd, 0);\n+        }\n+\n@@ -595,11 +597,0 @@\n-            {NaNd,                      NaNd},\n-            {Double.longBitsToDouble(0x7FF0000000000001L),      NaNd},\n-            {Double.longBitsToDouble(0xFFF0000000000001L),      NaNd},\n-            {Double.longBitsToDouble(0x7FF8555555555555L),      NaNd},\n-            {Double.longBitsToDouble(0xFFF8555555555555L),      NaNd},\n-            {Double.longBitsToDouble(0x7FFFFFFFFFFFFFFFL),      NaNd},\n-            {Double.longBitsToDouble(0xFFFFFFFFFFFFFFFFL),      NaNd},\n-            {Double.longBitsToDouble(0x7FFDeadBeef00000L),      NaNd},\n-            {Double.longBitsToDouble(0xFFFDeadBeef00000L),      NaNd},\n-            {Double.longBitsToDouble(0x7FFCafeBabe00000L),      NaNd},\n-            {Double.longBitsToDouble(0xFFFCafeBabe00000L),      NaNd},\n@@ -941,0 +932,4 @@\n+        for(double nan : Tests.NaNs) {\n+            failures += testTanhCaseWithUlpDiff(nan, NaNd, 0);\n+        }\n+\n@@ -943,11 +938,0 @@\n-            {NaNd,                      NaNd},\n-            {Double.longBitsToDouble(0x7FF0000000000001L),      NaNd},\n-            {Double.longBitsToDouble(0xFFF0000000000001L),      NaNd},\n-            {Double.longBitsToDouble(0x7FF8555555555555L),      NaNd},\n-            {Double.longBitsToDouble(0xFFF8555555555555L),      NaNd},\n-            {Double.longBitsToDouble(0x7FFFFFFFFFFFFFFFL),      NaNd},\n-            {Double.longBitsToDouble(0xFFFFFFFFFFFFFFFFL),      NaNd},\n-            {Double.longBitsToDouble(0x7FFDeadBeef00000L),      NaNd},\n-            {Double.longBitsToDouble(0xFFFDeadBeef00000L),      NaNd},\n-            {Double.longBitsToDouble(0x7FFCafeBabe00000L),      NaNd},\n-            {Double.longBitsToDouble(0xFFFCafeBabe00000L),      NaNd},\n","filename":"test\/jdk\/java\/lang\/Math\/HyperbolicTests.java","additions":18,"deletions":34,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8302026\n+ * @build Tests\n+ * @build InverseTrigTests\n+ * @run main InverseTrigTests\n+ * @summary Tests for {Math, StrictMath}.{asin, acos, atan}\n+ *\/\n+\n+import static java.lang.Double.longBitsToDouble;\n+\n+public class InverseTrigTests {\n+    private InverseTrigTests(){}\n+\n+    public static void main(String... args) {\n+        int failures = 0;\n+\n+        failures += testAsinSpecialCases();\n+        failures += testAcosSpecialCases();\n+        failures += testAtanSpecialCases();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing inverse trig mthods incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static final double InfinityD = Double.POSITIVE_INFINITY;\n+    private static final double NaNd = Double.NaN;\n+\n+    \/**\n+     * From the spec for Math.asin:\n+     *\n+     * \"Special cases:\n+     *\n+     * If the argument is NaN or its absolute value is greater than 1,\n+     * then the result is NaN.\n+     *\n+     * If the argument is zero, then the result is a zero with the\n+     * same sign as the argument.\"\n+     *\/\n+    private static int testAsinSpecialCases() {\n+        int failures = 0;\n+\n+        for(double nan : Tests.NaNs) {\n+            failures += testAsinCase(nan, NaNd);\n+        }\n+\n+        double [][] testCases = {\n+            {Math.nextUp(1.0),    NaNd},\n+            {Math.nextDown(-1.0), NaNd},\n+            { InfinityD,          NaNd},\n+            {-InfinityD,          NaNd},\n+\n+            {-0.0,                -0.0},\n+            {+0.0,                +0.0},\n+        };\n+\n+        for(int i = 0; i < testCases.length; i++) {\n+            failures += testAsinCase(testCases[i][0],\n+                                     testCases[i][1]);\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int testAsinCase(double input, double expected) {\n+        int failures=0;\n+\n+        failures += Tests.test(\"Math.asin\",       input, Math::asin,       expected);\n+        failures += Tests.test(\"StrictMath.asin\", input, StrictMath::asin, expected);\n+\n+        return failures;\n+    }\n+\n+    \/**\n+     * From the spec for Math.acos:\n+     *\n+     * \"Special case:\n+     *\n+     * If the argument is NaN or its absolute value is greater than 1,\n+     * then the result is NaN.\n+     *\n+     * If the argument is 1.0, the result is positive zero.\"\n+     *\/\n+    private static int testAcosSpecialCases() {\n+        int failures = 0;\n+\n+        for(double nan : Tests.NaNs) {\n+            failures += testAcosCase(nan, NaNd);\n+        }\n+\n+        double [][] testCases = {\n+            {Math.nextUp(1.0),    NaNd},\n+            {Math.nextDown(-1.0), NaNd},\n+            {InfinityD,           NaNd},\n+            {-InfinityD,          NaNd},\n+\n+            {1.0,                 +0.0},\n+        };\n+\n+        for(int i = 0; i < testCases.length; i++) {\n+            failures += testAcosCase(testCases[i][0],\n+                                     testCases[i][1]);\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int testAcosCase(double input, double expected) {\n+        int failures=0;\n+\n+        failures += Tests.test(\"Math.acos\",       input, Math::acos,       expected);\n+        failures += Tests.test(\"StrictMath.acos\", input, StrictMath::acos, expected);\n+\n+        return failures;\n+    }\n+\n+    \/**\n+     * From the spec for Math.atan:\n+     *\n+     * \"Special cases:\n+     *\n+     * If the argument is NaN, then the result is NaN.\n+     *\n+     * If the argument is zero, then the result is a zero with the\n+     * same sign as the argument.\n+     *\n+     * If the argument is infinite, then the result is the closest\n+     * value to pi\/2 with the same sign as the input.\"\n+     *\/\n+    private static int testAtanSpecialCases() {\n+        int failures = 0;\n+\n+        for(double nan : Tests.NaNs) {\n+            failures += testAtanCase(nan, NaNd);\n+        }\n+\n+        double [][] testCases = {\n+            {-0.0,       -0.0},\n+            {+0.0,       +0.0},\n+\n+            { InfinityD, +Math.PI\/2.0},\n+            {-InfinityD, -Math.PI\/2.0},\n+        };\n+\n+        for(int i = 0; i < testCases.length; i++) {\n+            failures += testAtanCase(testCases[i][0],\n+                                     testCases[i][1]);\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int testAtanCase(double input, double expected) {\n+        int failures=0;\n+\n+        failures += Tests.test(\"Math.atan\",       input, Math::atan,       expected);\n+        failures += Tests.test(\"StrictMath.atan\", input, StrictMath::atan, expected);\n+\n+        return failures;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Math\/InverseTrigTests.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+ * @build Tests\n+ * @build Log10Tests\n+ * @run main Log10Tests\n@@ -30,0 +33,2 @@\n+import static java.lang.Double.longBitsToDouble;\n+\n@@ -33,3 +38,3 @@\n-    static final double infinityD = Double.POSITIVE_INFINITY;\n-    static final double NaNd = Double.NaN;\n-    static final double LN_10 = StrictMath.log(10.0);\n+    private static final double infinityD = Double.POSITIVE_INFINITY;\n+    private static final double NaNd = Double.NaN;\n+    private static final double LN_10 = StrictMath.log(10.0);\n@@ -40,1 +45,1 @@\n-    static int testLog10Case(double input, double expected) {\n+    private static int testLog10Case(double input, double expected) {\n@@ -43,2 +48,2 @@\n-        failures+=Tests.test(\"Math.log10\",       input, Math::log10,       expected);\n-        failures+=Tests.test(\"StrictMath.log10\", input, StrictMath::log10, expected);\n+        failures += Tests.test(\"Math.log10\",       input, Math::log10,       expected);\n+        failures += Tests.test(\"StrictMath.log10\", input, StrictMath::log10, expected);\n@@ -49,1 +54,1 @@\n-    static int testLog10() {\n+    private static int testLog10() {\n@@ -52,0 +57,4 @@\n+        for(double nan : Tests.NaNs) {\n+            failures += testLog10Case(nan, NaNd);\n+        }\n+\n@@ -53,11 +62,0 @@\n-            {Double.NaN,                NaNd},\n-            {Double.longBitsToDouble(0x7FF0000000000001L),      NaNd},\n-            {Double.longBitsToDouble(0xFFF0000000000001L),      NaNd},\n-            {Double.longBitsToDouble(0x7FF8555555555555L),      NaNd},\n-            {Double.longBitsToDouble(0xFFF8555555555555L),      NaNd},\n-            {Double.longBitsToDouble(0x7FFFFFFFFFFFFFFFL),      NaNd},\n-            {Double.longBitsToDouble(0xFFFFFFFFFFFFFFFFL),      NaNd},\n-            {Double.longBitsToDouble(0x7FFDeadBeef00000L),      NaNd},\n-            {Double.longBitsToDouble(0xFFFDeadBeef00000L),      NaNd},\n-            {Double.longBitsToDouble(0x7FFCafeBabe00000L),      NaNd},\n-            {Double.longBitsToDouble(0xFFFCafeBabe00000L),      NaNd},\n","filename":"test\/jdk\/java\/lang\/Math\/Log10Tests.java","additions":17,"deletions":19,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+ * @build Tests\n+ * @build Log1pTests\n@@ -62,1 +64,1 @@\n-    static int testLog1p() {\n+    private static int testLog1p() {\n@@ -65,0 +67,4 @@\n+        for(double nan : Tests.NaNs) {\n+            failures += testLog1pCase(nan, NaNd);\n+        }\n+\n@@ -66,11 +72,0 @@\n-            {Double.NaN,                NaNd},\n-            {Double.longBitsToDouble(0x7FF0000000000001L),      NaNd},\n-            {Double.longBitsToDouble(0xFFF0000000000001L),      NaNd},\n-            {Double.longBitsToDouble(0x7FF8555555555555L),      NaNd},\n-            {Double.longBitsToDouble(0xFFF8555555555555L),      NaNd},\n-            {Double.longBitsToDouble(0x7FFFFFFFFFFFFFFFL),      NaNd},\n-            {Double.longBitsToDouble(0xFFFFFFFFFFFFFFFFL),      NaNd},\n-            {Double.longBitsToDouble(0x7FFDeadBeef00000L),      NaNd},\n-            {Double.longBitsToDouble(0xFFFDeadBeef00000L),      NaNd},\n-            {Double.longBitsToDouble(0x7FFCafeBabe00000L),      NaNd},\n-            {Double.longBitsToDouble(0xFFFCafeBabe00000L),      NaNd},\n","filename":"test\/jdk\/java\/lang\/Math\/Log1pTests.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import static java.lang.Double.longBitsToDouble;\n@@ -40,0 +41,32 @@\n+    \/\/ Used to create a NaN value at runtime; mark as volatile to foil\n+    \/\/ compile-time constant folding.\n+    static volatile double zero = 0.0;\n+\n+    private static final double PLATFORM_NAN = zero \/ zero;\n+\n+    public static final double[] NaNs = {\n+            Double.NaN,\n+            PLATFORM_NAN,\n+            bitwiseNegate(PLATFORM_NAN),\n+            \/\/ Exotic NaN bit patterns. Includes values that would\n+            \/\/ *not* be considered a NaN if only the high-order\n+            \/\/ 32-bits were examined.\n+            longBitsToDouble(0x7FF0_0000_0000_0001L),\n+            longBitsToDouble(0xFFF0_0000_0000_0001L),\n+            longBitsToDouble(0x7FF8_5555_5555_5555L),\n+            longBitsToDouble(0xFFF8_5555_5555_5555L),\n+            longBitsToDouble(0x7FFF_FFFF_FFFF_FFFFL),\n+            longBitsToDouble(0xFFFF_FFFF_FFFF_FFFFL),\n+            longBitsToDouble(0x7FF0_0000_7FFF_FFFFL),\n+            longBitsToDouble(0xFFF0_0000_7FFF_FFFFL),\n+            longBitsToDouble(0x7FF0_Dead_Beef_0000L),\n+            longBitsToDouble(0xFFF0_Dead_Beef_0000L),\n+            longBitsToDouble(0x7FF0_Cafe_Babe_0000L),\n+            longBitsToDouble(0xFFF0_Cafe_Babe_0000L),\n+    };\n+\n+    public static double bitwiseNegate(double d) {\n+        long SIGNBIT = 0x8000_0000_0000_0000L;\n+        return longBitsToDouble(Double.doubleToRawLongBits(d) ^ SIGNBIT );\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/Math\/Tests.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"}]}