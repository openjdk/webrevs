{"files":[{"patch":"@@ -744,1 +744,2 @@\n-bool IdealLoopTree::is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, Invariance& invar DEBUG_ONLY(COMMA ProjNode *predicate_proj)) const {\n+bool IdealLoopTree::is_range_check_if(IfProjNode *if_success_proj, PhaseIdealLoop *phase, Invariance& invar DEBUG_ONLY(COMMA ProjNode *predicate_proj)) const {\n+  IfNode* iff = if_success_proj->in(0)->as_If();\n@@ -752,1 +753,37 @@\n-  if (bol->_test._test != BoolTest::lt) {\n+  if (bol->_test._test != BoolTest::lt || if_success_proj->is_IfFalse()) {\n+    \/\/ We don't have the required range check pattern:\n+    \/\/ if (scale*iv + offset <u limit) {\n+    \/\/\n+    \/\/ } else {\n+    \/\/   trap();\n+    \/\/ }\n+    \/\/\n+    \/\/ Having the trap on the true projection:\n+    \/\/ if (scale*iv + offset <u limit) {\n+    \/\/   trap();\n+    \/\/ }\n+    \/\/\n+    \/\/ is not correct. We would need to flip the test to get the expected \"trap on false path\" pattern:\n+    \/\/ if (scale*iv + offset >=u limit) {\n+    \/\/\n+    \/\/ } else {\n+    \/\/   trap();\n+    \/\/ }\n+    \/\/\n+    \/\/ If we create a Hoisted Range Check Predicate for this wrong pattern, it could succeed at runtime (i.e. true\n+    \/\/ for the value of \"scale*iv + offset\" in the first loop iteration and true for the value of \"scale*iv + offset\"\n+    \/\/ in the last loop iteration) while the check to be hoisted could fail in other loop iterations.\n+    \/\/\n+    \/\/ Example:\n+    \/\/ Loop: \"for (int i = -1; i < 1000; i++)\"\n+    \/\/ init = \"scale*iv + offset\" in the first loop iteration = 1*-1 + 0 = -1\n+    \/\/ last = \"scale*iv + offset\" in the last loop iteration = 1*999 + 0 = 999\n+    \/\/ limit = 100\n+    \/\/\n+    \/\/ Hoisted Range Check Predicate is always true:\n+    \/\/ init >=u limit && last >=u limit  <=>\n+    \/\/ -1 >=u 100 && 999 >= u 100\n+    \/\/\n+    \/\/ But for 0 <= x < 100: x >=u 100 is false.\n+    \/\/ We would wrongly skip the branch with the trap() and possibly miss to execute some other statements inside that\n+    \/\/ trap() branch.\n@@ -832,4 +869,2 @@\n-BoolNode* PhaseIdealLoop::rc_predicate(IdealLoopTree *loop, Node* ctrl,\n-                                       int scale, Node* offset,\n-                                       Node* init, Node* limit, jint stride,\n-                                       Node* range, bool upper, bool &overflow, bool negate) {\n+BoolNode* PhaseIdealLoop::rc_predicate(IdealLoopTree* loop, Node* ctrl, int scale, Node* offset, Node* init,\n+                                       Node* limit, jint stride, Node* range, bool upper, bool& overflow) {\n@@ -961,1 +996,1 @@\n-  BoolNode* bol = new BoolNode(cmp, negate ? BoolTest::ge : BoolTest::lt);\n+  BoolNode* bol = new BoolNode(cmp, BoolTest::lt);\n@@ -1252,1 +1287,1 @@\n-bool PhaseIdealLoop::loop_predication_impl_helper(IdealLoopTree *loop, ProjNode* proj, ProjNode *predicate_proj,\n+bool PhaseIdealLoop::loop_predication_impl_helper(IdealLoopTree *loop, ProjNode* success_proj, ProjNode *predicate_proj,\n@@ -1257,1 +1292,3 @@\n-  IfNode*   iff  = proj->in(0)->as_If();\n+  assert(success_proj->is_IfProj(), \"Expectiong IfProj. Else predecessor might not be an iff.\");\n+  IfProjNode* if_success_proj = success_proj->as_IfProj();\n+  IfNode*   iff  = if_success_proj->in(0)->as_If();\n@@ -1273,1 +1310,1 @@\n-    if (proj->_con != predicate_proj->_con) {\n+    if (if_success_proj->_con != predicate_proj->_con) {\n@@ -1290,1 +1327,1 @@\n-  } else if (cl != nullptr && loop->is_range_check_if(iff, this, invar DEBUG_ONLY(COMMA predicate_proj))) {\n+  } else if (cl != nullptr && loop->is_range_check_if(if_success_proj, this, invar DEBUG_ONLY(COMMA predicate_proj))) {\n@@ -1292,0 +1329,1 @@\n+    assert(if_success_proj->is_IfTrue(), \"trap must be on false projection for a range check\");\n@@ -1325,1 +1363,0 @@\n-    bool negate = (proj->_con != predicate_proj->_con);\n@@ -1328,1 +1365,1 @@\n-    BoolNode* lower_bound_bol = rc_predicate(loop, ctrl, scale, offset, init, limit, stride, rng, false, overflow, negate);\n+    BoolNode* lower_bound_bol = rc_predicate(loop, ctrl, scale, offset, init, limit, stride, rng, false, overflow);\n@@ -1334,1 +1371,1 @@\n-    if (TraceLoopPredicate) tty->print_cr(\"lower bound check if: %s %d \", negate ? \" negated\" : \"\", lower_bound_iff->_idx);\n+    if (TraceLoopPredicate) tty->print_cr(\"lower bound check if: %d \", lower_bound_iff->_idx);\n@@ -1337,1 +1374,2 @@\n-    BoolNode* upper_bound_bol = rc_predicate(loop, lower_bound_proj, scale, offset, init, limit, stride, rng, true, overflow, negate);\n+    BoolNode* upper_bound_bol = rc_predicate(loop, lower_bound_proj, scale, offset, init, limit, stride, rng, true,\n+                                             overflow);\n@@ -1344,1 +1382,1 @@\n-    if (TraceLoopPredicate) tty->print_cr(\"upper bound check if: %s %d \", negate ? \" negated\" : \"\", lower_bound_iff->_idx);\n+    if (TraceLoopPredicate) tty->print_cr(\"upper bound check if: %d \", lower_bound_iff->_idx);\n@@ -1351,1 +1389,1 @@\n-      new_predicate_proj = insert_initial_skeleton_predicate(iff, loop, proj, predicate_proj, upper_bound_proj, scale, offset, init, limit, stride, rng, overflow, reason);\n+      new_predicate_proj = insert_initial_skeleton_predicate(iff, loop, if_success_proj, predicate_proj, upper_bound_proj, scale, offset, init, limit, stride, rng, overflow, reason);\n@@ -1367,1 +1405,1 @@\n-  invar.map_ctrl(proj, new_predicate_proj); \/\/ so that invariance test can be appropriate\n+  invar.map_ctrl(if_success_proj, new_predicate_proj); \/\/ so that invariance test can be appropriate\n@@ -1370,1 +1408,1 @@\n-  dominated_by( new_predicate_proj, iff, proj->_con != new_predicate_proj->_con );\n+  dominated_by( new_predicate_proj, iff, if_success_proj->_con != new_predicate_proj->_con );\n@@ -1393,1 +1431,2 @@\n-  BoolNode* bol = rc_predicate(loop, upper_bound_proj, scale, offset, opaque_init, limit, stride, rng, (stride > 0) != (scale > 0), overflow, negate);\n+  BoolNode* bol = rc_predicate(loop, upper_bound_proj, scale, offset, opaque_init, limit, stride, rng,\n+                               (stride > 0) != (scale > 0), overflow);\n@@ -1415,1 +1454,2 @@\n-  bol = rc_predicate(loop, new_proj, scale, offset, max_value, limit, stride, rng, (stride > 0) != (scale > 0), overflow, negate);\n+  bol = rc_predicate(loop, new_proj, scale, offset, max_value, limit, stride, rng, (stride > 0) != (scale > 0),\n+                     overflow);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":61,"deletions":21,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2675,1 +2675,1 @@\n-  BoolNode* bol = rc_predicate(loop, predicate_proj, scale_con, offset, value, nullptr, stride_con, limit, (stride_con > 0) != (scale_con > 0), overflow, false);\n+  BoolNode* bol = rc_predicate(loop, predicate_proj, scale_con, offset, value, nullptr, stride_con, limit, (stride_con > 0) != (scale_con > 0), overflow);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -740,1 +740,3 @@\n-  bool is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, Invariance& invar DEBUG_ONLY(COMMA ProjNode *predicate_proj)) const;\n+  bool is_range_check_if(IfProjNode* if_success_proj, PhaseIdealLoop *phase, Invariance& invar DEBUG_ONLY(COMMA ProjNode *predicate_proj)) const;\n+  \/\/ GLGL bool is_range_check_if(IfProjNode* if_success_proj, PhaseIdealLoop* phase, BasicType bt, Node* iv, Node*& range, Node*& offset,\n+  \/\/ GLGL                        jlong& scale) const;\n@@ -1309,5 +1311,2 @@\n-  BoolNode* rc_predicate(IdealLoopTree *loop, Node* ctrl,\n-                         int scale, Node* offset,\n-                         Node* init, Node* limit, jint stride,\n-                         Node* range, bool upper, bool &overflow,\n-                         bool negate);\n+  BoolNode* rc_predicate(IdealLoopTree *loop, Node* ctrl, int scale, Node* offset,Node* init, Node* limit,\n+                         jint stride, Node* range, bool upper, bool &overflow\/* GLGL, bool negate*\/);\n@@ -1317,1 +1316,1 @@\n-  bool loop_predication_impl_helper(IdealLoopTree *loop, ProjNode* proj, ProjNode *predicate_proj,\n+  bool loop_predication_impl_helper(IdealLoopTree *loop, ProjNode* if_success_proj, ProjNode *predicate_proj,\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8307683\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @summary Tests that IfNode is not wrongly chosen as range check by Loop Predication leading to crashes and wrong executions.\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.predicates.TestHoistedPredicateForNonRangeCheck::test*\n+ *                   compiler.predicates.TestHoistedPredicateForNonRangeCheck\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.predicates.TestHoistedPredicateForNonRangeCheck::test*\n+ *                   -XX:LoopMaxUnroll=0 compiler.predicates.TestHoistedPredicateForNonRangeCheck\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8307683\n+ * @library \/test\/lib \/\n+ * @summary Tests that IfNode is not wrongly chosen as range check by Loop Predication leading to crashes and wrong executions.\n+ * @run main\/othervm -Xbatch compiler.predicates.TestHoistedPredicateForNonRangeCheck calendar\n+ *\/\n+\n+package compiler.predicates;\n+\n+import jdk.test.lib.Asserts;\n+\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+\n+public class TestHoistedPredicateForNonRangeCheck {\n+    static int iFld, iFld2;\n+    static int[] iArr = new int[100];\n+\n+    public static void main(String[] args) {\n+        if (args.length == 0) {\n+            Integer.compareUnsigned(34, 34); \/\/ Ensure Integer class is loaded and we do not emit a trap inside test() for it.\n+\n+            for (int i = 0; i < 2; i++) {\n+                iFld = 0;\n+                iFld2 = 0;\n+                test();\n+                Asserts.assertEQ(iFld, 3604, \"wrong value\");\n+                Asserts.assertEQ(iFld2, 400, \"wrong value\");\n+            }\n+\n+            for (int i = 0; i < 2000; i++) {\n+                iFld = -100;\n+                testRangeCheckNode();\n+            }\n+            iFld = -1;\n+            iFld2 = 0;\n+            testRangeCheckNode();\n+            Asserts.assertEQ(iFld2, 36, \"wrong value\");\n+        } else {\n+            boolean flag = false;\n+            for (int i = 0; i < 10000; i++) {\n+                testCalendar1();\n+                testCalendar2(flag);\n+            }\n+        }\n+    }\n+\n+    public static void test() {\n+        for (int i = -1; i < 1000; i++) {\n+            \/\/ We hoist this check and insert a Hoisted Predicate for the lower and upper bound:\n+            \/\/ -1 >=u 100 && 1000 >= u 100 -> always true and the predicates are removed.\n+            \/\/ Template Assertion Predicates, however, are kept. When splitting this loop further, we insert an Assertion\n+            \/\/ Predicate which fails for i = 0 and we halt.\n+            \/\/ When not splitting this loop (with LoopMaxUnroll=0), we have a wrong execution due to never executing\n+            \/\/ iFld2++ (we remove the check and the branch with the trap when creating the Hoisted Predicates).\n+            if (Integer.compareUnsigned(i, 100) < 0) {\n+                iFld2++;\n+                Float.isNaN(34); \/\/ Float class is unloaded with -Xcomp -> inserts trap\n+            } else {\n+                iFld++;\n+            }\n+\n+            \/\/ Same but flipped condition and moved trap to other branch - result is the same.\n+            if (Integer.compareUnsigned(i, 100) >= 0) { \/\/ Loop Predication creates a Hoisted Range Check Predicate due to trap with Float.isNan().\n+                iFld++;\n+            } else {\n+                iFld2++;\n+                Float.isNaN(34); \/\/ Float class is unloaded with -Xcomp -> inserts trap\n+            }\n+\n+            \/\/ Same but with LoadRangeNode.\n+            if (Integer.compareUnsigned(i, iArr.length) >= 0) { \/\/ Loop Predication creates a Hoisted Range Check Predicate due to trap with Float.isNan().\n+                iFld++;\n+            } else {\n+                iFld2++;\n+                Float.isNaN(34); \/\/ Float class is unloaded with -Xcomp -> inserts trap\n+            }\n+\n+            \/\/ Same but with LoadRangeNode and flipped condition and moved trap to other branch - result is the same.\n+            if (Integer.compareUnsigned(i, iArr.length) >= 0) { \/\/ Loop Predication creates a Hoisted Range Check Predicate due to trap with Float.isNan().\n+                iFld++;\n+            } else {\n+                iFld2++;\n+                Float.isNaN(34); \/\/ Float class is unloaded with -Xcomp -> inserts trap\n+            }\n+        }\n+    }\n+\n+    static void testRangeCheckNode() {\n+        int array[] = new int[34];\n+        \/\/ Hoisted Range Check Predicate with flipped bool because trap is on success proj and no trap on false proj due\n+        \/\/ to catching exception:\n+        \/\/ iFld >=u 34 && iFld+36 >=u 34\n+        \/\/ This is always false for first 2000 iterations where, initially, iFld = -100\n+        \/\/ It is still true in the last iteration where, initially, iFld = -1. But suddenly, in the second iteration,\n+        \/\/ where iFld = 0, we would take the true projection for the first time - but we removed that branch when\n+        \/\/ creating the Hoisted Range Check Predicate. We therefore run into the same problem as with test(): We either\n+        \/\/ halt due to Assertion Predicates catching this case or we have a wrong execution (iFld2 never updated).\n+        for (int i = 0; i < 37; i++) {\n+            try {\n+                array[iFld] = 34; \/\/ Normal RangeCheckNode\n+                iFld2++;\n+                Math.ceil(34); \/\/ Never taken and unloaded -> trap\n+            } catch (Exception e) {\n+                \/\/ False Proj of RangeCheckNode\n+                iFld++;\n+            }\n+        }\n+    }\n+\n+    \/\/ Reported in JDK-8307683\n+    static void testCalendar1() {\n+        Calendar c = Calendar.getInstance();\n+        c.setLenient(false);\n+        c.set(Calendar.HOUR_OF_DAY, 0);\n+        c.set(Calendar.MINUTE, 0);\n+        c.getTime();\n+    }\n+\n+    \/\/ Reported in JDK-8307978\n+    static void testCalendar2(boolean flag) {\n+        flag = !flag;\n+        Calendar timespan = removeTime(new Date(), flag);\n+        timespan.getTime();\n+    }\n+\n+    static Calendar removeTime(Date date, boolean flag) {\n+        Calendar calendar = Calendar.getInstance();\n+        if (flag) {\n+            calendar.setLenient(false);\n+        }\n+        calendar.setTime(date);\n+        calendar = removeTime(calendar);\n+        return calendar;\n+    }\n+\n+    static Calendar removeTime(Calendar calendar) {\n+        calendar.set(Calendar.HOUR_OF_DAY, 0);\n+        calendar.set(Calendar.MINUTE, 0);\n+        calendar.set(Calendar.SECOND, 0);\n+        calendar.set(Calendar.MILLISECOND, 0);\n+        return calendar;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/TestHoistedPredicateForNonRangeCheck.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"}]}