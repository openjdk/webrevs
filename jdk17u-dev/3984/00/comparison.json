{"files":[{"patch":"@@ -28,6 +28,0 @@\n-import sun.awt.AppContext;\n-import sun.awt.SunToolkit;\n-\n-import java.util.Collections;\n-import java.util.Map;\n-import java.util.WeakHashMap;\n@@ -39,0 +33,1 @@\n+import java.awt.Graphics2D;\n@@ -41,0 +36,1 @@\n+import java.awt.Stroke;\n@@ -42,0 +38,5 @@\n+import java.awt.geom.AffineTransform;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.WeakHashMap;\n+\n@@ -47,0 +48,3 @@\n+\n+import sun.awt.AppContext;\n+import sun.awt.SunToolkit;\n@@ -50,0 +54,2 @@\n+import static sun.java2d.pipe.Region.clipRound;\n+\n@@ -127,0 +133,25 @@\n+    \/**\n+     * Returns delegate {@code RepaintManager} for {@code component} hierarchy.\n+     *\/\n+    public static RepaintManager getDelegateRepaintManager(Component\n+                                                            component) {\n+        RepaintManager delegate = null;\n+        if (Boolean.TRUE == SunToolkit.targetToAppContext(component)\n+                                      .get(DELEGATE_REPAINT_MANAGER_KEY)) {\n+            while (delegate == null && component != null) {\n+                while (component != null\n+                         && ! (component instanceof JComponent)) {\n+                    component = component.getParent();\n+                }\n+                if (component != null) {\n+                    delegate = (RepaintManager)\n+                        ((JComponent) component)\n+                          .getClientProperty(DELEGATE_REPAINT_MANAGER_KEY);\n+                    component = component.getParent();\n+                }\n+\n+            }\n+        }\n+        return delegate;\n+    }\n+\n@@ -250,1 +281,5 @@\n-     * Returns delegate {@code RepaintManager} for {@code component} hierarchy.\n+     * A task which paints an <i>unscaled<\/i> border after {@code Graphics}\n+     * transforms are removed. It's used with the\n+     * {@link #paintBorder(Component, Graphics, int, int, int, int, UnscaledBorderPainter)\n+     * SwingUtilities3.paintBorder} which manages changing the transforms and calculating\n+     * the coordinates and size of the border.\n@@ -252,16 +287,55 @@\n-    public static RepaintManager getDelegateRepaintManager(Component\n-                                                            component) {\n-        RepaintManager delegate = null;\n-        if (Boolean.TRUE == SunToolkit.targetToAppContext(component)\n-                                      .get(DELEGATE_REPAINT_MANAGER_KEY)) {\n-            while (delegate == null && component != null) {\n-                while (component != null\n-                         && ! (component instanceof JComponent)) {\n-                    component = component.getParent();\n-                }\n-                if (component != null) {\n-                    delegate = (RepaintManager)\n-                        ((JComponent) component)\n-                          .getClientProperty(DELEGATE_REPAINT_MANAGER_KEY);\n-                    component = component.getParent();\n-                }\n+    @FunctionalInterface\n+    public interface UnscaledBorderPainter {\n+        \/**\n+         * Paints the border for the specified component after the\n+         * {@code Graphics} transforms are removed.\n+         *\n+         * <p>\n+         * The <i>x<\/i> and <i>y<\/i> of the painted border are zero.\n+         *\n+         * @param c the component for which this border is being painted\n+         * @param g the paint graphics\n+         * @param w the width of the painted border, in physical pixels\n+         * @param h the height of the painted border, in physical pixels\n+         * @param scaleFactor the scale that was in the {@code Graphics}\n+         *\n+         * @see #paintBorder(Component, Graphics, int, int, int, int, UnscaledBorderPainter)\n+         * SwingUtilities3.paintBorder\n+         * @see javax.swing.border.Border#paintBorder(Component, Graphics, int, int, int, int)\n+         * Border.paintBorder\n+         *\/\n+        void paintUnscaledBorder(Component c, Graphics g,\n+                                 int w, int h,\n+                                 double scaleFactor);\n+    }\n+\n+    \/**\n+     * Paints the border for a component ensuring its sides have consistent\n+     * thickness at different scales.\n+     * <p>\n+     * It performs the following steps:\n+     * <ol>\n+     *     <li>Reset the scale transform on the {@code Graphics},<\/li>\n+     *     <li>Call {@code painter} to paint the border,<\/li>\n+     *     <li>Restores the transform.<\/li>\n+     * <\/ol>\n+     *\n+     * @param c the component for which this border is being painted\n+     * @param g the paint graphics\n+     * @param x the x position of the painted border\n+     * @param y the y position of the painted border\n+     * @param w the width of the painted border\n+     * @param h the height of the painted border\n+     * @param painter the painter object which paints the border after\n+     *                the transform on the {@code Graphics} is reset\n+     *\/\n+    public static void paintBorder(Component c, Graphics g,\n+                                   int x, int y,\n+                                   int w, int h,\n+                                   UnscaledBorderPainter painter) {\n+\n+        \/\/ Step 1: Reset Transform\n+        AffineTransform at = null;\n+        Stroke oldStroke = null;\n+        boolean resetTransform = false;\n+        double scaleFactor = 1;\n@@ -269,0 +343,43 @@\n+        int xtranslation = x;\n+        int ytranslation = y;\n+        int width = w;\n+        int height = h;\n+\n+        if (g instanceof Graphics2D) {\n+            Graphics2D g2d = (Graphics2D) g;\n+            at = g2d.getTransform();\n+            oldStroke = g2d.getStroke();\n+            scaleFactor = Math.min(at.getScaleX(), at.getScaleY());\n+\n+            \/\/ if m01 or m10 is non-zero, then there is a rotation or shear,\n+            \/\/ or if scale=1, skip resetting the transform in these cases.\n+            resetTransform = ((at.getShearX() == 0) && (at.getShearY() == 0))\n+                    && ((at.getScaleX() > 1) || (at.getScaleY() > 1));\n+\n+            if (resetTransform) {\n+                \/* Deactivate the HiDPI scaling transform,\n+                 * so we can do paint operations in the device\n+                 * pixel coordinate system instead of the logical coordinate system.\n+                 *\/\n+                g2d.setTransform(new AffineTransform());\n+                double xx = at.getScaleX() * x + at.getTranslateX();\n+                double yy = at.getScaleY() * y + at.getTranslateY();\n+                xtranslation = clipRound(xx);\n+                ytranslation = clipRound(yy);\n+                width = clipRound(at.getScaleX() * w + xx) - xtranslation;\n+                height = clipRound(at.getScaleY() * h + yy) - ytranslation;\n+            }\n+        }\n+\n+        g.translate(xtranslation, ytranslation);\n+\n+        \/\/ Step 2: Call respective paintBorder with transformed values\n+        painter.paintUnscaledBorder(c, g, width, height, scaleFactor);\n+\n+        \/\/ Step 3: Restore previous stroke & transform\n+        g.translate(-xtranslation, -ytranslation);\n+        if (g instanceof Graphics2D) {\n+            Graphics2D g2d = (Graphics2D) g;\n+            g2d.setStroke(oldStroke);\n+            if (resetTransform) {\n+                g2d.setTransform(at);\n@@ -271,1 +388,0 @@\n-        return delegate;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/SwingUtilities3.java","additions":140,"deletions":24,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,0 @@\n-import java.awt.Stroke;\n-import java.awt.geom.AffineTransform;\n@@ -37,0 +35,2 @@\n+import com.sun.java.swing.SwingUtilities3;\n+\n@@ -153,19 +153,5 @@\n-        \/\/ We remove any initial transforms to prevent rounding errors\n-        \/\/ when drawing in non-integer scales\n-        AffineTransform at = null;\n-        Stroke oldStk = null;\n-        int stkWidth = 1;\n-        boolean resetTransform = false;\n-        if (g instanceof Graphics2D) {\n-            Graphics2D g2d = (Graphics2D) g;\n-            at = g2d.getTransform();\n-            oldStk = g2d.getStroke();\n-            \/\/ if m01 or m10 is non-zero, then there is a rotation or shear\n-            \/\/ skip resetting the transform\n-            resetTransform = (at.getShearX() == 0) && (at.getShearY() == 0);\n-            if (resetTransform) {\n-                g2d.setTransform(new AffineTransform());\n-                stkWidth = (int) Math.floor(Math.min(at.getScaleX(), at.getScaleY()));\n-                g2d.setStroke(new BasicStroke((float) stkWidth));\n-            }\n-        }\n+        SwingUtilities3.paintBorder(c, g,\n+                                    x, y,\n+                                    width, height,\n+                                    this::paintUnscaledBorder);\n+    }\n@@ -173,14 +159,6 @@\n-        int w;\n-        int h;\n-        int xtranslation;\n-        int ytranslation;\n-        if (resetTransform) {\n-            w = (int) Math.floor(at.getScaleX() * width - 1);\n-            h = (int) Math.floor(at.getScaleY() * height - 1);\n-            xtranslation = (int) Math.ceil(at.getScaleX()*x+at.getTranslateX());\n-            ytranslation = (int) Math.ceil(at.getScaleY()*y+at.getTranslateY());\n-        } else {\n-            w = width;\n-            h = height;\n-            xtranslation = x;\n-            ytranslation = y;\n+    private void paintUnscaledBorder(Component c, Graphics g,\n+                                     int w, int h,\n+                                     double scaleFactor) {\n+        int stkWidth = (int) Math.floor(scaleFactor);\n+        if (g instanceof Graphics2D) {\n+            ((Graphics2D) g).setStroke(new BasicStroke((float) stkWidth));\n@@ -189,2 +167,0 @@\n-        g.translate(xtranslation, ytranslation);\n-\n@@ -197,9 +173,0 @@\n-\n-        g.translate(-xtranslation, -ytranslation);\n-\n-        \/\/ Set the transform we removed earlier\n-        if (resetTransform) {\n-            Graphics2D g2d = (Graphics2D) g;\n-            g2d.setTransform(at);\n-            g2d.setStroke(oldStk);\n-        }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/border\/EtchedBorder.java","additions":14,"deletions":47,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import java.awt.geom.AffineTransform;\n@@ -39,1 +38,1 @@\n-import static sun.java2d.pipe.Region.clipRound;\n+import com.sun.java.swing.SwingUtilities3;\n@@ -147,0 +146,9 @@\n+        SwingUtilities3.paintBorder(c, g,\n+                                    x, y,\n+                                    width, height,\n+                                    this::paintUnscaledBorder);\n+    }\n+\n+    private void paintUnscaledBorder(Component c, Graphics g,\n+                                     int w, int h,\n+                                     double scaleFactor) {\n@@ -150,37 +158,0 @@\n-            AffineTransform at = g2d.getTransform();\n-\n-            \/\/ if m01 or m10 is non-zero, then there is a rotation or shear\n-            \/\/ or if no Scaling enabled,\n-            \/\/ skip resetting the transform\n-            boolean resetTransform = ((at.getShearX() == 0) && (at.getShearY() == 0)) &&\n-                    ((at.getScaleX() > 1) || (at.getScaleY() > 1));\n-\n-            int xtranslation;\n-            int ytranslation;\n-            int w;\n-            int h;\n-            int offs;\n-\n-            if (resetTransform) {\n-                \/* Deactivate the HiDPI scaling transform,\n-                 * so we can do paint operations in the device\n-                 * pixel coordinate system instead of the logical coordinate system.\n-                 *\/\n-                g2d.setTransform(new AffineTransform());\n-                double xx = at.getScaleX() * x + at.getTranslateX();\n-                double yy = at.getScaleY() * y + at.getTranslateY();\n-                xtranslation = clipRound(xx);\n-                ytranslation = clipRound(yy);\n-                w = clipRound(at.getScaleX() * width + xx) - xtranslation;\n-                h = clipRound(at.getScaleY() * height + yy) - ytranslation;\n-                offs = this.thickness * (int) at.getScaleX();\n-            } else {\n-                w = width;\n-                h = height;\n-                xtranslation = x;\n-                ytranslation = y;\n-                offs = this.thickness;\n-            }\n-\n-            g2d.translate(xtranslation, ytranslation);\n-\n@@ -193,0 +164,1 @@\n+            int offs = this.thickness * (int) scaleFactor;\n@@ -198,2 +170,1 @@\n-            }\n-            else {\n+            } else {\n@@ -203,0 +174,1 @@\n+\n@@ -207,1 +179,0 @@\n-            g2d.setColor(oldColor);\n@@ -209,5 +180,1 @@\n-            g2d.translate(-xtranslation, -ytranslation);\n-\n-            if (resetTransform) {\n-                g2d.setTransform(at);\n-            }\n+            g2d.setColor(oldColor);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/border\/LineBorder.java","additions":15,"deletions":48,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.awt.Stroke;\n@@ -38,1 +37,0 @@\n-import java.awt.geom.AffineTransform;\n@@ -65,0 +63,1 @@\n+import com.sun.java.swing.SwingUtilities3;\n@@ -254,0 +253,8 @@\n+            SwingUtilities3.paintBorder(c, g,\n+                                        x, y, w, h,\n+                                        this::paintUnscaledBorder);\n+        }\n+\n+        private void paintUnscaledBorder(Component c, Graphics g,\n+                                         int width, int height,\n+                                         double scaleFactor) {\n@@ -268,42 +275,0 @@\n-            AffineTransform at = null;\n-            Stroke oldStk = null;\n-            boolean resetTransform = false;\n-            int stkWidth = 1;\n-            double scaleFactor = 1;\n-\n-            if (g instanceof Graphics2D g2d) {\n-                at = g2d.getTransform();\n-                scaleFactor = at.getScaleX();\n-                oldStk = g2d.getStroke();\n-\n-                \/\/ if m01 or m10 is non-zero, then there is a rotation or shear\n-                \/\/ skip resetting the transform\n-                resetTransform = ((at.getShearX() == 0) && (at.getShearY() == 0));\n-\n-                if (resetTransform) {\n-                    g2d.setTransform(new AffineTransform());\n-                    stkWidth = clipRound(Math.min(at.getScaleX(), at.getScaleY()));\n-                    g2d.setStroke(new BasicStroke((float) stkWidth));\n-                }\n-            }\n-\n-            int xtranslation;\n-            int ytranslation;\n-            int width;\n-            int height;\n-\n-            if (resetTransform) {\n-                double xx = at.getScaleX() * x + at.getTranslateX();\n-                double yy = at.getScaleY() * y + at.getTranslateY();\n-                xtranslation = clipRound(xx);\n-                ytranslation = clipRound(yy);\n-                width = clipRound(at.getScaleX() * w + xx) - xtranslation;\n-                height = clipRound(at.getScaleY() * h + yy) - ytranslation;\n-            } else {\n-                xtranslation = x;\n-                ytranslation = y;\n-                width = w;\n-                height = h;\n-            }\n-            g.translate(xtranslation, ytranslation);\n-\n@@ -323,0 +288,1 @@\n+                int stkWidth = clipRound(scaleFactor);\n@@ -329,0 +295,4 @@\n+                if (g instanceof Graphics2D) {\n+                    ((Graphics2D) g).setStroke(new BasicStroke((float) stkWidth));\n+                }\n+\n@@ -347,8 +317,0 @@\n-\n-            \/\/ restore previous transform\n-            g.translate(-xtranslation, -ytranslation);\n-            if (resetTransform) {\n-                Graphics2D g2d = (Graphics2D) g;\n-                g2d.setTransform(at);\n-                g2d.setStroke(oldStk);\n-            }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalBorders.java","additions":15,"deletions":53,"binary":false,"changes":68,"status":"modified"}]}