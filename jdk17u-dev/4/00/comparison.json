{"files":[{"patch":"@@ -55,0 +55,4 @@\n+  UNSUPPORTED_OPTION(UseCompiler);\n+#ifdef ASSERT\n+  UNSUPPORTED_OPTION(CountCompiledCalls);\n+#endif\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,8 +71,0 @@\n-\n-  \/\/ Allow c++ interpreter to do one initialization now that switches are set, etc.\n-  BytecodeInterpreter start_msg(BytecodeInterpreter::initialize);\n-  if (JvmtiExport::can_post_interpreter_events()) {\n-    BytecodeInterpreter::run<true>(&start_msg);\n-  } else {\n-    BytecodeInterpreter::run<false>(&start_msg);\n-  }\n","filename":"src\/hotspot\/cpu\/zero\/zeroInterpreter_zero.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -406,14 +406,11 @@\n-\n-  \/\/ In order to simplify some tests based on switches set at runtime\n-  \/\/ we invoke the interpreter a single time after switches are enabled\n-  \/\/ and set simpler to to test variables rather than method calls or complex\n-  \/\/ boolean expressions.\n-\n-  static int initialized = 0;\n-  static int checkit = 0;\n-  static intptr_t* c_addr = NULL;\n-  static intptr_t  c_value;\n-\n-  if (checkit && *c_addr != c_value) {\n-    os::breakpoint();\n-  }\n+  intptr_t*        topOfStack = (intptr_t *)istate->stack(); \/* access with STACK macros *\/\n+  address          pc = istate->bcp();\n+  jubyte opcode;\n+  intptr_t*        locals = istate->locals();\n+  ConstantPoolCache*    cp = istate->constants(); \/\/ method()->constants()->cache()\n+#ifdef LOTS_OF_REGS\n+  JavaThread*      THREAD = istate->thread();\n+#else\n+#undef THREAD\n+#define THREAD istate->thread()\n+#endif\n@@ -422,3 +419,6 @@\n-  if (istate->_msg != initialize) {\n-    assert(labs(istate->_stack_base - istate->_stack_limit) == (istate->_method->max_stack() + 1), \"bad stack limit\");\n-  }\n+  assert(labs(istate->stack_base() - istate->stack_limit()) == (istate->method()->max_stack() + 1),\n+         \"Bad stack limit\");\n+  \/* QQQ this should be a stack method so we don't know actual direction *\/\n+  assert(topOfStack >= istate->stack_limit() && topOfStack < istate->stack_base(),\n+         \"Stack top out of range\");\n+\n@@ -436,12 +436,0 @@\n-  intptr_t*        topOfStack = (intptr_t *)istate->stack(); \/* access with STACK macros *\/\n-  address          pc = istate->bcp();\n-  jubyte opcode;\n-  intptr_t*        locals = istate->locals();\n-  ConstantPoolCache*    cp = istate->constants(); \/\/ method()->constants()->cache()\n-#ifdef LOTS_OF_REGS\n-  JavaThread*      THREAD = istate->thread();\n-#else\n-#undef THREAD\n-#define THREAD istate->thread()\n-#endif\n-\n@@ -534,17 +522,0 @@\n-#ifdef ASSERT\n-  \/\/ this will trigger a VERIFY_OOP on entry\n-  if (istate->msg() != initialize && ! METHOD->is_static()) {\n-    oop rcvr = LOCALS_OBJECT(0);\n-    VERIFY_OOP(rcvr);\n-  }\n-#endif\n-\n-  \/* QQQ this should be a stack method so we don't know actual direction *\/\n-  guarantee(istate->msg() == initialize ||\n-         topOfStack >= istate->stack_limit() &&\n-         topOfStack < istate->stack_base(),\n-         \"Stack top out of range\");\n-\n-  assert(!UseCompiler, \"Zero does not support compilers\");\n-  assert(!CountCompiledCalls, \"Zero does not support counting compiled calls\");\n-\n@@ -553,1 +524,1 @@\n-      if (initialized++) ShouldNotReachHere(); \/\/ Only one initialize call.\n+      ShouldNotCallThis();\n@@ -556,1 +527,0 @@\n-    break;\n@@ -559,7 +529,0 @@\n-      \/\/ count invocations\n-      assert(initialized, \"Interpreter not initialized\");\n-\n-      if ((istate->_stack_base - istate->_stack_limit) != istate->method()->max_stack() + 1) {\n-        \/\/ initialize\n-        os::breakpoint();\n-      }\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":18,"deletions":55,"binary":false,"changes":73,"status":"modified"}]}