{"files":[{"patch":"@@ -37,0 +37,1 @@\n+import jdk.test.lib.cds.CDSArchiveUtils;\n@@ -38,1 +39,0 @@\n-import jdk.test.lib.Utils;\n@@ -40,2 +40,0 @@\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n@@ -43,15 +41,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-import java.nio.channels.FileChannel;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n-import java.nio.file.StandardOpenOption;\n-import static java.nio.file.StandardOpenOption.READ;\n-import static java.nio.file.StandardOpenOption.WRITE;\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Random;\n-import jdk.test.whitebox.WhiteBox;\n@@ -60,13 +43,0 @@\n-    public static WhiteBox wb;\n-    public static int offset_magic;     \/\/ CDSFileMapHeaderBase::_magic\n-    public static int offset_version;   \/\/ CDSFileMapHeaderBase::_version\n-    public static int offset_jvm_ident; \/\/ FileMapHeader::_jvm_ident\n-    public static int sp_offset_crc;    \/\/ CDSFileMapRegion::_crc\n-    public static int file_header_size = -1;\/\/ total size of header, variant, need calculation\n-    public static int CDSFileMapRegion_size; \/\/ size of CDSFileMapRegion\n-    public static int sp_offset;       \/\/ offset of CDSFileMapRegion\n-    public static int sp_used_offset;  \/\/ offset of CDSFileMapRegion::_used\n-    public static int size_t_size;     \/\/ size of size_t\n-    public static int int_size;        \/\/ size of int\n-    public static long alignment;      \/\/ MetaspaceShared::core_region_alignment\n-\n@@ -97,186 +67,0 @@\n-    public static void getFileOffsetInfo() throws Exception {\n-        wb = WhiteBox.getWhiteBox();\n-        offset_magic = wb.getOffsetForName(\"FileMapHeader::_magic\");\n-        offset_version = wb.getOffsetForName(\"FileMapHeader::_version\");\n-        offset_jvm_ident = wb.getOffsetForName(\"FileMapHeader::_jvm_ident\");\n-        sp_offset_crc = wb.getOffsetForName(\"CDSFileMapRegion::_crc\");\n-        try {\n-            int nonExistOffset = wb.getOffsetForName(\"FileMapHeader::_non_exist_offset\");\n-            System.exit(-1); \/\/ should fail\n-        } catch (Exception e) {\n-            \/\/ success\n-        }\n-\n-        sp_offset = wb.getOffsetForName(\"FileMapHeader::_space[0]\") - offset_magic;\n-        sp_used_offset = wb.getOffsetForName(\"CDSFileMapRegion::_used\") - sp_offset_crc;\n-        size_t_size = wb.getOffsetForName(\"size_t_size\");\n-        CDSFileMapRegion_size  = wb.getOffsetForName(\"CDSFileMapRegion_size\");\n-        alignment = wb.metaspaceSharedRegionAlignment();\n-    }\n-\n-    public static int getFileHeaderSize(FileChannel fc) throws Exception {\n-        if (file_header_size != -1) {\n-            return file_header_size;\n-        }\n-        \/\/ this is not real header size, it is struct size\n-        int_size = wb.getOffsetForName(\"int_size\");\n-        file_header_size = wb.getOffsetForName(\"file_header_size\");\n-        System.out.println(\"file_header_size      = \" + file_header_size);\n-        file_header_size = (int)align_up_page(file_header_size);\n-        System.out.println(\"file_header_size (aligned to page) = \" + file_header_size);\n-        return file_header_size;\n-    }\n-\n-    public static long align_up_page(long l) throws Exception {\n-        \/\/ wb is obtained in getFileOffsetInfo() which is called first in main() else we should call\n-        \/\/ WhiteBox.getWhiteBox() here first.\n-        int pageSize = wb.getVMPageSize();\n-        return (l + pageSize -1) & (~ (pageSize - 1));\n-    }\n-\n-    private static long getRandomBetween(long start, long end) throws Exception {\n-        if (start > end) {\n-            throw new IllegalArgumentException(\"start must be less than end\");\n-        }\n-        Random aRandom = Utils.getRandomInstance();\n-        int d = aRandom.nextInt((int)(end - start));\n-        if (d < 1) {\n-            d = 1;\n-        }\n-        return start + d;\n-    }\n-\n-    public static long readInt(FileChannel fc, long offset, int nbytes) throws Exception {\n-        ByteBuffer bb = ByteBuffer.allocate(nbytes);\n-        bb.order(ByteOrder.nativeOrder());\n-        fc.position(offset);\n-        fc.read(bb);\n-        return  (nbytes > 4 ? bb.getLong(0) : bb.getInt(0));\n-    }\n-\n-    public static void writeData(FileChannel fc, long offset, ByteBuffer bb) throws Exception {\n-        fc.position(offset);\n-        fc.write(bb);\n-    }\n-\n-    public static FileChannel getFileChannel(File jsaFile) throws Exception {\n-        List<StandardOpenOption> arry = new ArrayList<StandardOpenOption>();\n-        arry.add(READ);\n-        arry.add(WRITE);\n-        return FileChannel.open(jsaFile.toPath(), new HashSet<StandardOpenOption>(arry));\n-    }\n-\n-    public static void modifyJsaContentRandomly(File jsaFile) throws Exception {\n-        FileChannel fc = getFileChannel(jsaFile);\n-        \/\/ corrupt random area in the data areas\n-        long[] used    = new long[num_regions];       \/\/ record used bytes\n-        long start0, start, end, off;\n-        int used_offset, path_info_size;\n-\n-        int bufSize;\n-        System.out.printf(\"%-24s%12s%12s%16s\\n\", \"Space Name\", \"Used bytes\", \"Reg Start\", \"Random Offset\");\n-        start0 = getFileHeaderSize(fc);\n-        for (int i = 0; i < num_regions; i++) {\n-            used[i] = get_region_used_size_aligned(fc, i);\n-            start = start0;\n-            for (int j = 0; j < i; j++) {\n-                start += align_up_page(used[j]);\n-            }\n-            end = start + used[i];\n-            if (start == end) {\n-                continue; \/\/ Ignore empty regions\n-            }\n-            off = getRandomBetween(start, end);\n-            System.out.printf(\"%-24s%12d%12d%16d\\n\", shared_region_name[i], used[i], start, off);\n-            if (end - off < 1024) {\n-                bufSize = (int)(end - off + 1);\n-            } else {\n-                bufSize = 1024;\n-            }\n-            ByteBuffer bbuf = ByteBuffer.wrap(new byte[bufSize]);\n-            writeData(fc, off, bbuf);\n-        }\n-        if (fc.isOpen()) {\n-            fc.close();\n-        }\n-    }\n-\n-    static long get_region_used_size_aligned(FileChannel fc, int region) throws Exception {\n-        long n = sp_offset + CDSFileMapRegion_size * region + sp_used_offset;\n-        long used = readInt(fc, n, size_t_size);\n-        used = (used + alignment - 1) & ~(alignment - 1);\n-        return used;\n-    }\n-\n-    public static boolean modifyJsaContent(int region, File jsaFile) throws Exception {\n-        FileChannel fc = getFileChannel(jsaFile);\n-        byte[] buf = new byte[4096];\n-        ByteBuffer bbuf = ByteBuffer.wrap(buf);\n-\n-        long total = 0L;\n-        long[] used = new long[num_regions];\n-        System.out.printf(\"%-24s%12s\\n\", \"Space name\", \"Used bytes\");\n-        for (int i = 0; i < num_regions; i++) {\n-            used[i] = get_region_used_size_aligned(fc, i);\n-            System.out.printf(\"%-24s%12d\\n\", shared_region_name[i], used[i]);\n-            total += used[i];\n-        }\n-        System.out.printf(\"%-24s%12d\\n\", \"Total: \", total);\n-        long header_size = getFileHeaderSize(fc);\n-        long region_start_offset = header_size;\n-        for (int i=0; i<region; i++) {\n-            region_start_offset += used[i];\n-        }\n-        if (used[region] == 0) {\n-            System.out.println(\"Region \" + shared_region_name[region] + \" is empty. Nothing to corrupt.\");\n-            return false;\n-        }\n-        System.out.println(\"Corrupt \" + shared_region_name[region] + \" section, start = \" + region_start_offset\n-                           + \" (header_size + 0x\" + Long.toHexString(region_start_offset-header_size) + \")\");\n-        long bytes_written = 0L;\n-        while (bytes_written < used[region]) {\n-            writeData(fc, region_start_offset + bytes_written, bbuf);\n-            bbuf.clear();\n-            bytes_written += 4096;\n-        }\n-        if (fc.isOpen()) {\n-            fc.close();\n-        }\n-        return true;\n-    }\n-\n-    public static void modifyJsaHeader(File jsaFile) throws Exception {\n-        FileChannel fc = getFileChannel(jsaFile);\n-        \/\/ screw up header info\n-        byte[] buf = new byte[getFileHeaderSize(fc)];\n-        ByteBuffer bbuf = ByteBuffer.wrap(buf);\n-        writeData(fc, 0L, bbuf);\n-        if (fc.isOpen()) {\n-            fc.close();\n-        }\n-    }\n-\n-    public static void modifyJvmIdent(File jsaFile) throws Exception {\n-        FileChannel fc = getFileChannel(jsaFile);\n-        int headerSize = getFileHeaderSize(fc);\n-        System.out.println(\"    offset_jvm_ident \" + offset_jvm_ident);\n-        byte[] buf = new byte[256];\n-        ByteBuffer bbuf = ByteBuffer.wrap(buf);\n-        writeData(fc, (long)offset_jvm_ident, bbuf);\n-        if (fc.isOpen()) {\n-            fc.close();\n-        }\n-    }\n-\n-    public static void modifyHeaderIntField(File jsaFile, long offset, int value) throws Exception {\n-        FileChannel fc = getFileChannel(jsaFile);\n-        int headerSize = getFileHeaderSize(fc);\n-        System.out.println(\"    offset \" + offset);\n-        byte[] buf = ByteBuffer.allocate(4).putInt(value).array();\n-        ByteBuffer bbuf = ByteBuffer.wrap(buf);\n-        writeData(fc, offset, bbuf);\n-        if (fc.isOpen()) {\n-            fc.close();\n-        }\n-    }\n-\n@@ -284,1 +68,1 @@\n-    public static String startNewTestArchive(String testName) {\n+    public static String startNewArchive(String testName) {\n@@ -291,56 +75,0 @@\n-    public static File copyFile(File orgJsaFile, String testName) throws Exception {\n-        File newJsaFile = new File(startNewTestArchive(testName));\n-        if (newJsaFile.exists()) {\n-            if (!newJsaFile.delete()) {\n-                throw new IOException(\"Could not delete file \" + newJsaFile);\n-            }\n-        }\n-        Files.copy(orgJsaFile.toPath(), newJsaFile.toPath(), REPLACE_EXISTING);\n-\n-        \/\/ orgJsaFile is read only, and Files.copy passes on this attribute to newJsaFile.\n-        \/\/ Since we need to modify newJsaFile later, let's set it to r\/w\n-        setReadWritePermission(newJsaFile);\n-\n-        return newJsaFile;\n-    }\n-\n-    \/\/ Copy file with bytes deleted or inserted\n-    \/\/ del -- true, deleted, false, inserted\n-    public static File insertOrDeleteBytes(File orgJsaFile, boolean del) throws Exception {\n-        File newJsaFile = new File(startNewTestArchive(del ? \"delete-bytes\" : \"insert-bytes\"));\n-        try (\n-            FileChannel inputChannel = new FileInputStream(orgJsaFile).getChannel();\n-            FileChannel outputChannel = new FileOutputStream(newJsaFile).getChannel()\n-        ) {\n-            long size = inputChannel.size();\n-            int init_size = getFileHeaderSize(inputChannel);\n-            outputChannel.transferFrom(inputChannel, 0, init_size);\n-            int n = (int)getRandomBetween(0, 1024);\n-            if (del) {\n-                System.out.println(\"Delete \" + n + \" bytes at data start section\");\n-                inputChannel.position(init_size + n);\n-                outputChannel.transferFrom(inputChannel, init_size, size - init_size - n);\n-            } else {\n-                System.out.println(\"Insert \" + n + \" bytes at data start section\");\n-                outputChannel.position(init_size);\n-                outputChannel.write(ByteBuffer.wrap(new byte[n]));\n-                outputChannel.transferFrom(inputChannel, init_size + n , size - init_size);\n-            }\n-        }\n-\n-        return newJsaFile;\n-    }\n-\n-    public static void setReadWritePermission(File file) throws Exception {\n-        if (!file.canRead()) {\n-            if (!file.setReadable(true)) {\n-                throw new IOException(\"Cannot modify file \" + file + \" as readable\");\n-            }\n-        }\n-        if (!file.canWrite()) {\n-            if (!file.setWritable(true)) {\n-                throw new IOException(\"Cannot modify file \" + file + \" as writable\");\n-            }\n-        }\n-    }\n-\n@@ -368,1 +96,1 @@\n-    \/\/   7) randomly corrupt data in each region specified by shared_region_name[]\n+    \/\/   7) randomly corrupt data in each region in shared_region_name[]\n@@ -377,7 +105,0 @@\n-\n-        \/\/ must call to get offset info first!!!\n-        getFileOffsetInfo();\n-        Path currentRelativePath = Paths.get(\"\");\n-        String currentDir = currentRelativePath.toAbsolutePath().toString();\n-        System.out.println(\"Current relative path is: \" + currentDir);\n-        \/\/ get jar file\n@@ -412,0 +133,2 @@\n+        String modifyHeader = startNewArchive(\"modify-header\");\n+        File copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, modifyHeader);\n@@ -413,1 +136,1 @@\n-        modifyJsaHeader(copyFile(orgJsaFile, \"corrupt-header\"));\n+        CDSArchiveUtils.modifyFileHeader(copiedJsa);\n@@ -423,1 +146,4 @@\n-        modifyJvmIdent(copyFile(orgJsaFile, \"modify-jvm-ident\"));\n+\n+        String modJvmIdent = startNewArchive(\"modify-jvm-ident\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, modJvmIdent);\n+        CDSArchiveUtils.modifyJvmIdent(copiedJsa, \"My non-exist jdk 1.000001\");\n@@ -433,1 +159,3 @@\n-        modifyHeaderIntField(copyFile(orgJsaFile, \"modify-magic\"), offset_magic, 0x00000000);\n+        String modMagic = startNewArchive(\"modify-magic\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, modMagic);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetMagic, -1);\n@@ -443,1 +171,3 @@\n-        modifyHeaderIntField(copyFile(orgJsaFile, \"modify-version\"), offset_version, 0x00000000);\n+        String modVersion = startNewArchive(\"modify-version\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, modVersion);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion, 0x00000000);\n@@ -454,2 +184,3 @@\n-            File newJsaFile = copyFile(orgJsaFile, (shared_region_name[i]));\n-            if (modifyJsaContent(i, newJsaFile)) {\n+            String newArchiveName = startNewArchive(shared_region_name[i]);\n+            copiedJsa  = CDSArchiveUtils.copyArchiveFile(orgJsaFile, newArchiveName);\n+            if (CDSArchiveUtils.modifyRegionContent(i, copiedJsa)) {\n@@ -462,3 +193,4 @@\n-        File newJsaFile = copyFile(orgJsaFile, \"header-and-content\");\n-        modifyJsaHeader(newJsaFile);\n-        modifyJsaContent(0, newJsaFile);  \/\/ this will not be reached since failed on header change first\n+        String headerAndContent = startNewArchive(\"header-and-content\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, headerAndContent);\n+        CDSArchiveUtils.modifyFileHeader(copiedJsa);\n+        CDSArchiveUtils.modifyRegionContent(0, copiedJsa);  \/\/ this will not be reached since failed on header change first\n@@ -472,3 +204,4 @@\n-        \/\/ delete bytes in data section\n-        System.out.println(\"\\n5. Delete bytes at beginning of data section, should fail\\n\");\n-        insertOrDeleteBytes(orgJsaFile, true);\n+        \/\/ insert  bytes in data section\n+        System.out.println(\"\\n5. Insert bytes at beginning of data section, should fail\\n\");\n+        String insertBytes = startNewArchive(\"insert-bytes\");\n+        CDSArchiveUtils.insertBytesRandomlyAfterHeader(orgJsaFile, insertBytes, new byte[4096]);\n@@ -477,3 +210,4 @@\n-        \/\/ insert bytes in data section forward\n-        System.out.println(\"\\n6. Insert bytes at beginning of data section, should fail\\n\");\n-        insertOrDeleteBytes(orgJsaFile, false);\n+        \/\/ delete bytes in data section forward\n+        System.out.println(\"\\n6. Delete bytes at beginning of data section, should fail\\n\");\n+        String deleteBytes = startNewArchive(\"delete-bytes\");\n+        CDSArchiveUtils.deleteBytesAtRandomPositionAfterHeader(orgJsaFile, deleteBytes, 4096 \/*bytes*\/);\n@@ -483,1 +217,3 @@\n-        modifyJsaContentRandomly(copyFile(orgJsaFile, \"random-areas\"));\n+        String randomAreas = startNewArchive(\"random-areas\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, randomAreas);\n+        CDSArchiveUtils.modifyRegionContentRandomly(copiedJsa);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SharedArchiveConsistency.java","additions":34,"deletions":298,"binary":false,"changes":332,"status":"modified"},{"patch":"@@ -0,0 +1,314 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.test.lib.cds;\n+\n+import java.io.IOException;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Random;\n+\n+import java.nio.file.Files;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+import java.nio.file.StandardOpenOption;\n+import static java.nio.file.StandardOpenOption.READ;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/\/ This class performs operations on shared archive file\n+public class CDSArchiveUtils {\n+    public static int offsetMagic;           \/\/ CDSFileMapHeaderBase::_magic\n+    public static int offsetVersion;         \/\/ CDSFileMapHeaderBase::_version\n+    public static int offsetJvmIdent;        \/\/ FileMapHeader::_jvm_ident\n+    public static int spOffsetCrc;           \/\/ CDSFileMapRegion::_crc\n+    public static int fileHeaderSize;        \/\/ total size of header, aligned with alignment\n+    public static int cdsFileMapRegionSize;  \/\/ size of CDSFileMapRegion\n+    public static int spOffset;              \/\/ offset of CDSFileMapRegion\n+    public static int spUsedOffset;          \/\/ offset of CDSFileMapRegion::_used\n+    public static int sizetSize;             \/\/ size of size_t\n+    public static int intSize;               \/\/ size of int\n+    public static long alignment;            \/\/ MetaspaceShared::core_region_alignment\n+\n+    \/\/ The following should be consistent with the enum in the C++ MetaspaceShared class\n+    public static String[] shared_region_name = {\n+        \"rw\",          \/\/ ReadWrite\n+        \"ro\",          \/\/ ReadOnly\n+        \"bm\",          \/\/ relocation bitmaps\n+        \"first_closed_archive\",\n+        \"last_closed_archive\",\n+        \"first_open_archive\",\n+        \"last_open_archive\"\n+    };\n+    public static int num_regions = shared_region_name.length;\n+\n+    static {\n+        WhiteBox wb;\n+        try {\n+            wb = WhiteBox.getWhiteBox();\n+            offsetMagic = wb.getOffsetForName(\"FileMapHeader::_magic\");\n+            offsetVersion = wb.getOffsetForName(\"FileMapHeader::_version\");\n+            offsetJvmIdent = wb.getOffsetForName(\"FileMapHeader::_jvm_ident\");\n+            spOffsetCrc = wb.getOffsetForName(\"CDSFileMapRegion::_crc\");\n+            spOffset = wb.getOffsetForName(\"FileMapHeader::_space[0]\") - offsetMagic;\n+            spUsedOffset = wb.getOffsetForName(\"CDSFileMapRegion::_used\") - spOffsetCrc;\n+            sizetSize = wb.getOffsetForName(\"size_t_size\");\n+            intSize = wb.getOffsetForName(\"int_size\");\n+            cdsFileMapRegionSize  = wb.getOffsetForName(\"CDSFileMapRegion_size\");\n+            alignment = wb.metaspaceSharedRegionAlignment();\n+            \/\/ file_header_size is structure size, real size aligned with alignment\n+            \/\/ so must be calculated after alignment is available\n+            fileHeaderSize = (int)alignUpWithAlignment(wb.getOffsetForName(\"file_header_size\"));\n+        } catch (Exception e) {\n+            throw new RuntimeException(e.getMessage());\n+        }\n+\n+        try {\n+            int nonExistOffset = wb.getOffsetForName(\"FileMapHeader::_non_exist_offset\");\n+            System.exit(-1); \/\/ should fail\n+        } catch (Exception e) {\n+            \/\/ success\n+        }\n+    }\n+\n+    private static long alignUpWithAlignment(long l) {\n+        return (l + alignment - 1) & (~ (alignment - 1));\n+    }\n+\n+    private static void setReadWritePermission(File file) throws Exception {\n+        if (!file.canRead()) {\n+            if (!file.setReadable(true)) {\n+                throw new IOException(\"Cannot modify file \" + file + \" as readable\");\n+            }\n+        }\n+        if (!file.canWrite()) {\n+            if (!file.setWritable(true)) {\n+                throw new IOException(\"Cannot modify file \" + file + \" as writable\");\n+            }\n+        }\n+    }\n+\n+    public static long getRandomBetween(long start, long end) throws Exception {\n+        if (start > end) {\n+            throw new IllegalArgumentException(\"start must be less than end\");\n+        }\n+        Random aRandom = Utils.getRandomInstance();\n+        int d = aRandom.nextInt((int)(end - start));\n+        if (d < 1) {\n+            d = 1;\n+        }\n+        return start + d;\n+    }\n+\n+    public static void modifyContentRandomly(File jsaFile) throws Exception {\n+        \/\/ corrupt random area in the data areas\n+        long[] used = new long[num_regions]; \/\/ record used bytes\n+        long start0, start, end, offset;\n+        int bufSize;\n+\n+        System.out.printf(\"%-24s%12s%12s%16s\\n\", \"Space Name\", \"Used bytes\", \"Reg Start\", \"Random Offset\");\n+        start0 = fileHeaderSize;\n+        for (int i = 0; i < num_regions; i++) {\n+            used[i] = usedRegionSizeAligned(jsaFile, i);\n+            start = start0;\n+            for (int j = 0; j < i; j++) {\n+                start += alignUpWithAlignment(used[j]);\n+            }\n+            end = start + used[i];\n+            if (start == end) {\n+                continue; \/\/ Ignore empty regions\n+            }\n+            offset = getRandomBetween(start, end);\n+            System.out.printf(\"%-24s%12d%12d%16d\\n\", shared_region_name[i], used[i], start, offset);\n+            if (end - offset < 1024) {\n+                bufSize = (int)(end - offset + 1);\n+            } else {\n+                bufSize = 1024;\n+            }\n+            writeData(jsaFile, offset, new byte[bufSize]);\n+        }\n+    }\n+\n+    public static void modifyRegionContentRandomly(File jsaFile) throws Exception {\n+        \/\/ corrupt random area in the data areas\n+        long[] used = new long[num_regions]; \/\/ record used bytes\n+        long start0, start, end, offset;\n+        int bufSize;\n+\n+        System.out.printf(\"%-24s%12s%12s%16s\\n\", \"Space Name\", \"Used bytes\", \"Reg Start\", \"Random Offset\");\n+        start0 = fileHeaderSize;\n+        for (int i = 0; i < num_regions; i++) {\n+            used[i] = usedRegionSizeAligned(jsaFile, i);\n+            start = start0;\n+            for (int j = 0; j < i; j++) {\n+                start += alignUpWithAlignment(used[j]);\n+            }\n+            end = start + used[i];\n+            if (start == end) {\n+                continue; \/\/ Ignore empty regions\n+            }\n+            offset = getRandomBetween(start, end);\n+            System.out.printf(\"%-24s%12d%12d%16d\\n\", shared_region_name[i], used[i], start, offset);\n+            if (end - offset < 1024) {\n+                bufSize = (int)(end - offset + 1);\n+            } else {\n+                bufSize = 1024;\n+            }\n+            writeData(jsaFile, offset, new byte[bufSize]);\n+        }\n+    }\n+\n+    public static boolean modifyRegionContent(int region, File jsaFile) throws Exception {\n+        long total = 0L;\n+        long[] used = new long[num_regions];\n+        System.out.printf(\"%-24s%12s\\n\", \"Space name\", \"Used bytes\");\n+        for (int i = 0; i < num_regions; i++) {\n+            used[i] = usedRegionSizeAligned(jsaFile, i);\n+            System.out.printf(\"%-24s%12d\\n\", shared_region_name[i], used[i]);\n+            total += used[i];\n+        }\n+        if (used[region] == 0) {\n+            System.out.println(\"Region \" + shared_region_name[region] + \" is empty. Nothing to corrupt.\");\n+            return false;\n+        }\n+        byte[] buf = new byte[4096];\n+        System.out.printf(\"%-24s%12d\\n\", \"Total: \", total);\n+        long regionStartOffset = fileHeaderSize;\n+        for (int i = 0; i < region; i++) {\n+            regionStartOffset += used[i];\n+        }\n+        System.out.println(\"Corrupt \" + shared_region_name[region] + \" section, start = \" + regionStartOffset\n+                           + \" (header_size + 0x\" + Long.toHexString(regionStartOffset - fileHeaderSize) + \")\");\n+        long bytesWritten = 0L;\n+        while (bytesWritten < used[region]) {\n+            bytesWritten += writeData(jsaFile, regionStartOffset + bytesWritten, buf);\n+        }\n+        return true;\n+    }\n+\n+    public static void modifyFileHeader(File jsaFile) throws Exception {\n+        \/\/ screw up header info\n+        byte[] buf = new byte[fileHeaderSize];\n+        writeData(jsaFile, 0, buf);\n+    }\n+\n+    public static void modifyJvmIdent(File jsaFile, String newJvmIdent) throws Exception {\n+        byte[] buf = newJvmIdent.getBytes();\n+        writeData(jsaFile, (long)offsetJvmIdent, buf);\n+    }\n+\n+    public static void modifyHeaderIntField(File jsaFile, long offset, int value) throws Exception {\n+        System.out.println(\"    offset \" + offset);\n+\n+        byte[] bytes = ByteBuffer.allocate(4).putInt(value).array();\n+        writeData(jsaFile, offset, bytes);\n+    }\n+\n+    \/\/ copy archive and set copied read\/write permit\n+    public static File copyArchiveFile(File orgJsaFile, String newName) throws Exception {\n+        File newJsaFile = new File(newName);\n+        if (newJsaFile.exists()) {\n+            if (!newJsaFile.delete()) {\n+                throw new IOException(\"Could not delete file \" + newJsaFile);\n+            }\n+        }\n+        Files.copy(orgJsaFile.toPath(), newJsaFile.toPath(), REPLACE_EXISTING);\n+\n+        \/\/ change permission\n+        setReadWritePermission(newJsaFile);\n+\n+        return newJsaFile;\n+    }\n+\n+    private static FileChannel getFileChannel(File file) throws Exception {\n+        List<StandardOpenOption> arry = new ArrayList<StandardOpenOption>();\n+        arry.add(READ);\n+        arry.add(WRITE);\n+        return FileChannel.open(file.toPath(), new HashSet<StandardOpenOption>(arry));\n+    }\n+\n+    public static long readInt(File file, long offset, int nBytes) throws Exception {\n+        try (FileChannel fc = getFileChannel(file)) {\n+            ByteBuffer bb = ByteBuffer.allocate(nBytes);\n+            bb.order(ByteOrder.nativeOrder());\n+            fc.position(offset);\n+            fc.read(bb);\n+            return  (nBytes > 4 ? bb.getLong(0) : bb.getInt(0));\n+        }\n+    }\n+\n+    private static long writeData(FileChannel fc, long offset, ByteBuffer bb) throws Exception {\n+        fc.position(offset);\n+        return fc.write(bb);\n+    }\n+\n+    public static long writeData(File file, long offset, byte[] array) throws Exception {\n+        try (FileChannel fc = getFileChannel(file)) {\n+            ByteBuffer bbuf = ByteBuffer.wrap(array);\n+            return writeData(fc, offset, bbuf);\n+         }\n+    }\n+\n+    \/\/ dstFile will keep original size so will remove corresponding bytes.length bytes at end of file\n+    public static File insertBytesRandomlyAfterHeader(File orgFile, String newFileName, byte[] bytes) throws Exception {\n+        long offset = fileHeaderSize + getRandomBetween(0L, 4096L);\n+        File dstFile = new File(newFileName);\n+        try (FileChannel inputChannel = new FileInputStream(orgFile).getChannel();\n+             FileChannel outputChannel = new FileOutputStream(dstFile).getChannel()) {\n+            long orgSize = inputChannel.size();\n+            outputChannel.transferFrom(inputChannel, 0, offset);\n+            outputChannel.position(offset);\n+            outputChannel.write(ByteBuffer.wrap(bytes));\n+            outputChannel.transferFrom(inputChannel, offset + bytes.length, orgSize - bytes.length);\n+        }\n+        return dstFile;\n+    }\n+\n+    \/\/ delete nBytes bytes from offset, so new file will be smaller than the original\n+    public static File deleteBytesAtRandomPositionAfterHeader(File orgFile, String newFileName, int nBytes) throws Exception {\n+        long offset = fileHeaderSize + getRandomBetween(0L, 4096L);\n+        File dstFile = new File(newFileName);\n+        try (FileChannel inputChannel = new FileInputStream(orgFile).getChannel();\n+             FileChannel outputChannel = new FileOutputStream(dstFile).getChannel()) {\n+            long orgSize = inputChannel.size();\n+            outputChannel.transferFrom(inputChannel, 0, offset);\n+            inputChannel.position(offset + nBytes);\n+            outputChannel.transferFrom(inputChannel, offset, orgSize - nBytes);\n+        }\n+        return dstFile;\n+    }\n+\n+    \/\/ used region size\n+    public static long usedRegionSizeAligned(File archiveFile, int region) throws Exception {\n+        long offset = spOffset + cdsFileMapRegionSize * region + spUsedOffset;\n+        long used = readInt(archiveFile, offset, sizetSize);\n+        return alignUpWithAlignment(used);\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSArchiveUtils.java","additions":314,"deletions":0,"binary":false,"changes":314,"status":"added"}]}