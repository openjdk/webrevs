{"files":[{"patch":"@@ -1506,4 +1506,1 @@\n-        \/* creates a record component if non is related to the given variable and recreates a brand new one\n-         * in other case\n-         *\/\n-        public RecordComponent createRecordComponent(JCVariableDecl var, List<JCAnnotation> annotations) {\n+        public RecordComponent findRecordComponentToRemove(JCVariableDecl var) {\n@@ -1519,0 +1516,7 @@\n+            return toRemove;\n+        }\n+\n+        \/* creates a record component if non is related to the given variable and recreates a brand new one\n+         * in other case\n+         *\/\n+        public RecordComponent createRecordComponent(RecordComponent existing, JCVariableDecl var, List<JCAnnotation> annotations) {\n@@ -1520,4 +1524,3 @@\n-            if (toRemove != null) {\n-                \/\/ Found a record component with an erroneous type: remove it and create a new one\n-                recordComponents = List.filter(recordComponents, toRemove);\n-                recordComponents = recordComponents.append(rc = new RecordComponent(var.sym, toRemove.originalAnnos, toRemove.isVarargs));\n+            if (existing != null) {\n+                recordComponents = List.filter(recordComponents, existing);\n+                recordComponents = recordComponents.append(rc = new RecordComponent(var.sym, existing.originalAnnos, existing.isVarargs));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -966,1 +966,1 @@\n-                memberEnter.memberEnter(fields, env);\n+\n@@ -968,1 +968,31 @@\n-                    sym.createRecordComponent(field,\n+                    \/** Some notes regarding the code below. Annotations applied to elements of a record header are propagated\n+                     *  to other elements which, when applicable, not explicitly declared by the user: the canonical constructor,\n+                     *  accessors, fields and record components. Of all these the only ones that can't be explicitly declared are\n+                     *  the fields and the record components.\n+                     *\n+                     *  Now given that annotations are propagated to all possible targets  regardless of applicability,\n+                     *  annotations not applicable to a given element should be removed. See Check::validateAnnotation. Once\n+                     *  annotations are removed we could lose the whole picture, that's why original annotations are stored in\n+                     *  the record component, see RecordComponent::originalAnnos, but there is no real AST representing a record\n+                     *  component so if there is an annotation processing round it could be that we need to reenter a record for\n+                     *  which we need to re-attribute its annotations. This is why one of the things the code below is doing is\n+                     *  copying the original annotations from the record component to the corresponding field, again this applies\n+                     *  only if APs are present.\n+                     *\n+                     *  First, we find the record component by comparing its name and position with current field,\n+                     *  if any, and we mark it. Then we copy the annotations to the field so that annotations applicable only to the record component\n+                     *  can be attributed, as if declared in the field, and then stored in the metadata associated to the record\n+                     *  component. The invariance we need to keep here is that record components must be scheduled for\n+                     *  annotation only once during this process.\n+                     *\/\n+                    RecordComponent rc = sym.findRecordComponentToRemove(field);\n+\n+                    if (rc != null && (rc.getOriginalAnnos().length() != field.mods.annotations.length())) {\n+                        TreeCopier<JCTree> tc = new TreeCopier<>(make.at(field.pos));\n+                        List<JCAnnotation> originalAnnos = tc.copy(rc.getOriginalAnnos());\n+                        field.mods.annotations = originalAnnos;\n+                    }\n+\n+                    memberEnter.memberEnter(field, env);\n+\n+                    sym.createRecordComponent(rc, field,\n@@ -1214,18 +1244,1 @@\n-            \/** Some notes regarding the code below. Annotations applied to elements of a record header are propagated\n-             *  to other elements which, when applicable, not explicitly declared by the user: the canonical constructor,\n-             *  accessors, fields and record components. Of all these the only ones that can't be explicitly declared are\n-             *  the fields and the record components.\n-             *\n-             *  Now given that annotations are propagated to all possible targets  regardless of applicability,\n-             *  annotations not applicable to a given element should be removed. See Check::validateAnnotation. Once\n-             *  annotations are removed we could lose the whole picture, that's why original annotations are stored in\n-             *  the record component, see RecordComponent::originalAnnos, but there is no real AST representing a record\n-             *  component so if there is an annotation processing round it could be that we need to reenter a record for\n-             *  which we need to re-attribute its annotations. This is why one of the things the code below is doing is\n-             *  copying the original annotations from the record component to the corresponding field, again this applies\n-             *  only if APs are present.\n-             *\n-             *  We need to copy the annotations to the field so that annotations applicable only to the record component\n-             *  can be attributed as if declared in the field and then stored in the metadata associated to the record\n-             *  component.\n-             *\/\n+            \/\/ fields can't be varargs, lets remove the flag\n@@ -1234,4 +1247,0 @@\n-                RecordComponent rec = tree.sym.getRecordComponent(field.sym);\n-                TreeCopier<JCTree> tc = new TreeCopier<>(make.at(field.pos));\n-                List<JCAnnotation> originalAnnos = tc.copy(rec.getOriginalAnnos());\n-\n@@ -1239,6 +1248,0 @@\n-                if (originalAnnos.length() != field.mods.annotations.length()) {\n-                    field.mods.annotations = originalAnnos;\n-                    annotate.annotateLater(originalAnnos, env, field.sym, field.pos());\n-                }\n-\n-                \/\/ also here\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":33,"deletions":30,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @bug 8250629 8252307 8247352 8241151 8246774 8259025 8288130\n+ * @bug 8250629 8252307 8247352 8241151 8246774 8259025 8288130 8289647\n@@ -1338,0 +1338,41 @@\n+    public void testMultipleAnnosInRecord() throws Exception {\n+        String[] previousOptions = getCompileOptions();\n+\n+        try {\n+            String imports = \"\"\"\n+                    import java.lang.annotation.ElementType;\n+                    import java.lang.annotation.Target;\n+                    \"\"\";\n+\n+            String annotTemplate =\n+                    \"\"\"\n+                    @Target(ElementType.#TARGET)\n+                    @interface anno#TARGET { }\n+                    \"\"\";\n+\n+            String recordTemplate =\n+                    \"\"\"\n+                    record R(#TARGETS String s) {}\n+                    \"\"\";\n+\n+            String[] generalOptions = {\n+                    \"-processor\", Processor.class.getName(),\n+            };\n+\n+            List<String> targets = List.of(\"FIELD\", \"RECORD_COMPONENT\", \"PARAMETER\", \"METHOD\");\n+\n+            var interfaces = targets.stream().map(t -> annotTemplate.replaceAll(\"#TARGET\", t)).collect(Collectors.joining(\"\\n\"));\n+            var recordAnnotations = targets.stream().map(t -> \"@anno\" + t).collect(Collectors.joining(\" \"));\n+            String record = recordTemplate.replaceFirst(\"#TARGETS\", recordAnnotations);\n+            String code = String.format(\"%s\\n%s\\n%s\\n\",imports,interfaces,record);\n+            String[] testOptions = generalOptions.clone();\n+            setCompileOptions(testOptions);\n+\n+            assertOK(true, code);\n+\n+        \/\/ let's reset the default compiler options for other tests\n+        } finally {\n+            setCompileOptions(previousOptions);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":42,"deletions":1,"binary":false,"changes":43,"status":"modified"}]}