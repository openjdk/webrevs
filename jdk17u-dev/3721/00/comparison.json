{"files":[{"patch":"@@ -467,2 +467,2 @@\n-                return exchImpl.readBodyAsync(this::ignoreBody, false, parentExecutor)\n-                        .thenApply(v ->  r1);\n+                exchImpl.expectContinueFailed(rcode);\n+                return MinimalFuture.completedFuture(r1);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Exchange.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -263,0 +263,4 @@\n+\n+    \/\/ Called when server returns non 100 response to\n+    \/\/ an Expect-Continue\n+    void expectContinueFailed(int rcode) { }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ExchangeImpl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -866,0 +866,10 @@\n+\n+    @Override\n+    void expectContinueFailed(int rcode) {\n+        var response = this.response;\n+        if (response != null) {\n+            \/\/ Sets a flag which closes the connection locally when\n+            \/\/ onFinished() is called\n+            response.closeWhenFinished();\n+        }\n+    }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Exchange.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+    private volatile boolean closeWhenFinished;\n@@ -407,1 +408,5 @@\n-        if (return2Cache) {\n+        if (closeWhenFinished) {\n+            if (debug.on())\n+                debug.log(\"Closing Connection when finished\");\n+            connection.close();\n+        } else if (return2Cache) {\n@@ -419,0 +424,4 @@\n+    void closeWhenFinished() {\n+        closeWhenFinished = true;\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Response.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -313,0 +313,7 @@\n+    @Override\n+    void expectContinueFailed(int rcode) {\n+        \/\/ Have to mark request as sent, due to no request body being sent in the\n+        \/\/ event of a 417 Expectation Failed or some other non 100 response code\n+        requestSent();\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,293 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests that when the httpclient sends a 100 Expect Continue header and receives\n+ *          a response code of 417 Expectation Failed, that the client does not hang\n+ *          indefinitely and closes the connection.\n+ * @bug 8286171\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @run testng\/othervm ExpectContinueTest\n+ *\/\n+\n+\n+import com.sun.net.httpserver.HttpServer;\n+\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import javax.net.ServerSocketFactory;\n+import java.io.BufferedReader;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.io.Writer;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.StringTokenizer;\n+import java.util.concurrent.CompletableFuture;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.assertEquals;\n+\n+public class ExpectContinueTest implements HttpServerAdapters {\n+\n+    HttpTestServer http1TestServer; \/\/ HTTP\/1.1\n+    Http1HangServer http1HangServer;\n+    HttpTestServer http2TestServer; \/\/ HTTP\/2\n+\n+    URI getUri;\n+    URI postUri;\n+    URI hangUri;\n+    URI h2getUri;\n+    URI h2postUri;\n+    URI h2hangUri;\n+\n+    static final String EXPECTATION_FAILED_417 = \"417 Expectation Failed\";\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        InetSocketAddress saHang = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+\n+        http1TestServer = HttpTestServer.create(HTTP_1_1);\n+        http1TestServer.addHandler(new GetHandler(), \"\/http1\/get\");\n+        http1TestServer.addHandler(new PostHandler(), \"\/http1\/post\");\n+        getUri = URI.create(\"http:\/\/\" + http1TestServer.serverAuthority() + \"\/http1\/get\");\n+        postUri = URI.create(\"http:\/\/\" + http1TestServer.serverAuthority() + \"\/http1\/post\");\n+\n+        \/\/ Due to limitations of the above Http1 Server, a manual approach is taken to test the hanging with the\n+        \/\/ httpclient using Http1 so that the correct response header can be returned for the test case\n+        http1HangServer = new Http1HangServer(saHang);\n+        hangUri = URI.create(\"http:\/\/\" + http1HangServer.ia.getCanonicalHostName() + \":\" + http1HangServer.port + \"\/http1\/hang\");\n+\n+\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n+        http2TestServer.addHandler(new GetHandler(), \"\/http2\/get\");\n+        http2TestServer.addHandler(new PostHandler(), \"\/http2\/post\");\n+        http2TestServer.addHandler(new PostHandlerCantContinue(), \"\/http2\/hang\");\n+        h2getUri = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/get\");\n+        h2postUri = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/post\");\n+        h2hangUri = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/hang\");\n+\n+        http1TestServer.start();\n+        http1HangServer.start();\n+        http2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws IOException {\n+        http1TestServer.stop();\n+        http1HangServer.close();\n+        http2TestServer.stop();\n+    }\n+\n+    static class GetHandler implements HttpTestHandler {\n+\n+        @Override\n+        public void handle(HttpTestExchange exchange) throws IOException {\n+            try (InputStream is = exchange.getRequestBody();\n+                 OutputStream os = exchange.getResponseBody()) {\n+                is.readAllBytes();\n+                byte[] bytes = \"RESPONSE_BODY\".getBytes(UTF_8);\n+                exchange.sendResponseHeaders(200, bytes.length);\n+                os.write(bytes);\n+            }\n+        }\n+    }\n+\n+    static class PostHandler implements HttpTestHandler {\n+\n+        @Override\n+        public void handle(HttpTestExchange exchange) throws IOException {\n+            \/\/ Http1 server has already sent 100 response at this point but not Http2 server\n+            if (exchange.getExchangeVersion().equals(HttpClient.Version.HTTP_2)) {\n+                \/\/ Send 100 Headers, tell client that we're ready for body\n+                exchange.sendResponseHeaders(100, 0);\n+            }\n+\n+            \/\/ Read body from client and acknowledge with 200\n+            try (InputStream is = exchange.getRequestBody();\n+                OutputStream os = exchange.getResponseBody()) {\n+                is.readAllBytes();\n+                exchange.sendResponseHeaders(200, 0);\n+            }\n+        }\n+    }\n+\n+    static class PostHandlerCantContinue implements HttpTestHandler {\n+\n+        @Override\n+        public void handle(HttpTestExchange exchange) throws IOException {\n+            \/\/Send 417 Headers, tell client to not send body\n+            try (InputStream is = exchange.getRequestBody();\n+                 OutputStream os = exchange.getResponseBody()) {\n+                byte[] bytes = EXPECTATION_FAILED_417.getBytes();\n+                exchange.sendResponseHeaders(417, bytes.length);\n+                os.write(bytes);\n+            }\n+        }\n+    }\n+\n+    static class Http1HangServer extends Thread implements Closeable {\n+\n+        final ServerSocket ss;\n+        final InetAddress ia;\n+        final int port;\n+        volatile boolean closed = false;\n+        volatile Socket client;\n+\n+        Http1HangServer(InetSocketAddress sa) throws IOException {\n+            ss = ServerSocketFactory.getDefault()\n+                    .createServerSocket(sa.getPort(), -1, sa.getAddress());\n+            ia = ss.getInetAddress();\n+            port = ss.getLocalPort();\n+        }\n+\n+        @Override\n+        public void run() {\n+            byte[] bytes = EXPECTATION_FAILED_417.getBytes();\n+\n+            while (!closed) {\n+                try {\n+                    \/\/ Not using try with resources here as we expect the client to close resources when\n+                    \/\/ 417 is received\n+                    client = ss.accept();\n+                    InputStream is = client.getInputStream();\n+                    OutputStream os = client.getOutputStream();\n+\n+                    BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n+                    Writer w = new OutputStreamWriter(os, UTF_8);\n+                    PrintWriter pw = new PrintWriter(w);\n+\n+                    StringBuilder response = new StringBuilder();\n+                    String line = null;\n+                    StringBuilder reqBuilder = new StringBuilder();\n+                    while (!(line = reader.readLine()).isEmpty()) {\n+                        reqBuilder.append(line + \"\\r\\n\");\n+                    }\n+                    String req = reqBuilder.toString();\n+                    System.err.println(\"Http1HangServer received: \" + req);\n+                    StringTokenizer tokenizer = new StringTokenizer(req);\n+                    String method = tokenizer.nextToken();\n+                    String path = tokenizer.nextToken();\n+                    String version = tokenizer.nextToken();\n+\n+                    boolean validRequest = method.equals(\"POST\") && path.equals(\"\/http1\/hang\")\n+                                        && version.equals(\"HTTP\/1.1\");\n+                    \/\/ If correct request, send 417 reply. Otherwise, wait for correct one\n+                    if (validRequest) {\n+                        closed = true;\n+                        response.append(\"HTTP\/1.1 417 Expectation Failed\\r\\n\")\n+                                .append(\"Content-Length: \")\n+                                .append(0)\n+                                .append(\"\\r\\n\\r\\n\");\n+                        pw.print(response);\n+                        pw.flush();\n+\n+                        os.write(bytes);\n+                        os.flush();\n+                    } else {\n+                        client.close();\n+                    }\n+                } catch (IOException e) {\n+                    closed = true;\n+                    e.printStackTrace();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            if (client != null) client.close();\n+            if (ss != null) ss.close();\n+        }\n+    }\n+\n+    @DataProvider(name = \"uris\")\n+    public Object[][] urisData() {\n+        return new Object[][]{\n+                { getUri,   postUri, hangUri, HTTP_1_1 },\n+                { h2getUri,  h2postUri, h2hangUri, HttpClient.Version.HTTP_2 }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"uris\")\n+    public void test(URI getUri, URI postUri, URI hangUri, HttpClient.Version version) throws IOException, InterruptedException {\n+        HttpClient client = HttpClient.newBuilder()\n+                .version(version)\n+                .build();\n+\n+        HttpRequest getRequest = HttpRequest.newBuilder(getUri)\n+                .GET()\n+                .build();\n+\n+        HttpRequest postRequest = HttpRequest.newBuilder(postUri)\n+                .POST(HttpRequest.BodyPublishers.ofString(\"Sample Post\"))\n+                .expectContinue(true)\n+                .build();\n+\n+        HttpRequest hangRequest = HttpRequest.newBuilder(hangUri)\n+                .POST(HttpRequest.BodyPublishers.ofString(\"Sample Post\"))\n+                .expectContinue(true)\n+                .build();\n+\n+        CompletableFuture<HttpResponse<String>> cf = client.sendAsync(getRequest, HttpResponse.BodyHandlers.ofString());\n+        HttpResponse<String> resp = cf.join();\n+        System.err.println(\"Response Headers: \" + resp.headers());\n+        System.err.println(\"Response Status Code: \" + resp.statusCode());\n+        assertEquals(resp.statusCode(), 200);\n+\n+        cf = client.sendAsync(postRequest, HttpResponse.BodyHandlers.ofString());\n+        resp = cf.join();\n+        System.err.println(\"Response Headers: \" + resp.headers());\n+        System.err.println(\"Response Status Code: \" + resp.statusCode());\n+        assertEquals(resp.statusCode(), 200);\n+\n+        cf = client.sendAsync(hangRequest, HttpResponse.BodyHandlers.ofString());\n+        resp = cf.join();\n+        System.err.println(\"Response Headers: \" + resp.headers());\n+        System.err.println(\"Response Status Code: \" + resp.statusCode());\n+        assertEquals(resp.statusCode(), 417);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/ExpectContinueTest.java","additions":293,"deletions":0,"binary":false,"changes":293,"status":"added"}]}