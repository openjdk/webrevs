{"files":[{"patch":"@@ -0,0 +1,218 @@\n+#ifndef OT_VAR_VARC_VARC_HH\n+#define OT_VAR_VARC_VARC_HH\n+\n+#include \"..\/..\/..\/hb-decycler.hh\"\n+#include \"..\/..\/..\/hb-geometry.hh\"\n+#include \"..\/..\/..\/hb-ot-layout-common.hh\"\n+#include \"..\/..\/..\/hb-ot-glyf-table.hh\"\n+#include \"..\/..\/..\/hb-ot-cff2-table.hh\"\n+#include \"..\/..\/..\/hb-ot-cff1-table.hh\"\n+\n+#include \"coord-setter.hh\"\n+\n+namespace OT {\n+\n+\/\/namespace Var {\n+\n+\/*\n+ * VARC -- Variable Composites\n+ * https:\/\/github.com\/harfbuzz\/boring-expansion-spec\/blob\/main\/VARC.md\n+ *\/\n+\n+#ifndef HB_NO_VAR_COMPOSITES\n+\n+struct VarComponent\n+{\n+  enum class flags_t : uint32_t\n+  {\n+    RESET_UNSPECIFIED_AXES      = 1u << 0,\n+    HAVE_AXES                   = 1u << 1,\n+    AXIS_VALUES_HAVE_VARIATION  = 1u << 2,\n+    TRANSFORM_HAS_VARIATION     = 1u << 3,\n+    HAVE_TRANSLATE_X            = 1u << 4,\n+    HAVE_TRANSLATE_Y            = 1u << 5,\n+    HAVE_ROTATION               = 1u << 6,\n+    HAVE_CONDITION              = 1u << 7,\n+    HAVE_SCALE_X                = 1u << 8,\n+    HAVE_SCALE_Y                = 1u << 9,\n+    HAVE_TCENTER_X              = 1u << 10,\n+    HAVE_TCENTER_Y              = 1u << 11,\n+    GID_IS_24BIT                = 1u << 12,\n+    HAVE_SKEW_X                 = 1u << 13,\n+    HAVE_SKEW_Y                 = 1u << 14,\n+    RESERVED_MASK               = ~((1u << 15) - 1),\n+  };\n+\n+  HB_INTERNAL hb_ubytes_t\n+  get_path_at (hb_font_t *font,\n+               hb_codepoint_t parent_gid,\n+               hb_draw_session_t &draw_session,\n+               hb_array_t<const int> coords,\n+               hb_transform_t transform,\n+               hb_ubytes_t record,\n+               hb_decycler_t *decycler,\n+               signed *edges_left,\n+               signed depth_left,\n+               hb_glyf_scratch_t &scratch,\n+               VarRegionList::cache_t *cache = nullptr) const;\n+};\n+\n+struct VarCompositeGlyph\n+{\n+  static void\n+  get_path_at (hb_font_t *font,\n+               hb_codepoint_t glyph,\n+               hb_draw_session_t &draw_session,\n+               hb_array_t<const int> coords,\n+               hb_transform_t transform,\n+               hb_ubytes_t record,\n+               hb_decycler_t *decycler,\n+               signed *edges_left,\n+               signed depth_left,\n+               hb_glyf_scratch_t &scratch,\n+               VarRegionList::cache_t *cache = nullptr)\n+  {\n+    while (record)\n+    {\n+      const VarComponent &comp = * (const VarComponent *) (record.arrayZ);\n+      record = comp.get_path_at (font, glyph,\n+                                 draw_session, coords, transform,\n+                                 record,\n+                                 decycler, edges_left, depth_left, scratch, cache);\n+    }\n+  }\n+};\n+\n+HB_MARK_AS_FLAG_T (VarComponent::flags_t);\n+\n+struct VARC\n+{\n+  friend struct VarComponent;\n+\n+  static constexpr hb_tag_t tableTag = HB_TAG ('V', 'A', 'R', 'C');\n+\n+  HB_INTERNAL bool\n+  get_path_at (hb_font_t *font,\n+               hb_codepoint_t glyph,\n+               hb_draw_session_t &draw_session,\n+               hb_array_t<const int> coords,\n+               hb_transform_t transform,\n+               hb_codepoint_t parent_glyph,\n+               hb_decycler_t *decycler,\n+               signed *edges_left,\n+               signed depth_left,\n+               hb_glyf_scratch_t &scratch) const;\n+\n+  bool\n+  get_path (hb_font_t *font,\n+            hb_codepoint_t gid,\n+            hb_draw_session_t &draw_session,\n+            hb_glyf_scratch_t &scratch) const\n+  {\n+    hb_decycler_t decycler;\n+    signed edges = HB_MAX_GRAPH_EDGE_COUNT;\n+\n+    return get_path_at (font,\n+                        gid,\n+                        draw_session,\n+                        hb_array (font->coords, font->num_coords),\n+                        HB_TRANSFORM_IDENTITY,\n+                        HB_CODEPOINT_INVALID,\n+                        &decycler,\n+                        &edges,\n+                        HB_MAX_NESTING_LEVEL,\n+                        scratch);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (version.sanitize (c) &&\n+                  hb_barrier () &&\n+                  version.major == 1 &&\n+                  coverage.sanitize (c, this) &&\n+                  varStore.sanitize (c, this) &&\n+                  conditionList.sanitize (c, this) &&\n+                  axisIndicesList.sanitize (c, this) &&\n+                  glyphRecords.sanitize (c, this));\n+  }\n+\n+  struct accelerator_t\n+  {\n+    friend struct VarComponent;\n+\n+    accelerator_t (hb_face_t *face)\n+    {\n+      table = hb_sanitize_context_t ().reference_table<VARC> (face);\n+    }\n+    ~accelerator_t ()\n+    {\n+      auto *scratch = cached_scratch.get_relaxed ();\n+      if (scratch)\n+      {\n+        scratch->~hb_glyf_scratch_t ();\n+        hb_free (scratch);\n+      }\n+\n+      table.destroy ();\n+    }\n+\n+    bool\n+    get_path (hb_font_t *font, hb_codepoint_t gid, hb_draw_session_t &draw_session) const\n+    {\n+      if (!table->has_data ()) return false;\n+\n+      hb_glyf_scratch_t *scratch;\n+\n+      \/\/ Borrow the cached strach buffer.\n+      {\n+        scratch = cached_scratch.get_acquire ();\n+        if (!scratch || unlikely (!cached_scratch.cmpexch (scratch, nullptr)))\n+        {\n+          scratch = (hb_glyf_scratch_t *) hb_calloc (1, sizeof (hb_glyf_scratch_t));\n+          if (unlikely (!scratch))\n+            return true;\n+        }\n+      }\n+\n+      bool ret = table->get_path (font, gid, draw_session, *scratch);\n+\n+      \/\/ Put it back.\n+      if (!cached_scratch.cmpexch (nullptr, scratch))\n+      {\n+        scratch->~hb_glyf_scratch_t ();\n+        hb_free (scratch);\n+      }\n+\n+      return ret;\n+    }\n+\n+    private:\n+    hb_blob_ptr_t<VARC> table;\n+    hb_atomic_ptr_t<hb_glyf_scratch_t> cached_scratch;\n+  };\n+\n+  bool has_data () const { return version.major != 0; }\n+\n+  protected:\n+  FixedVersion<> version; \/* Version identifier *\/\n+  Offset32To<Coverage> coverage;\n+  Offset32To<MultiItemVariationStore> varStore;\n+  Offset32To<ConditionList> conditionList;\n+  Offset32To<TupleList> axisIndicesList;\n+  Offset32To<CFF2Index\/*Of<VarCompositeGlyph>*\/> glyphRecords;\n+  public:\n+  DEFINE_SIZE_STATIC (24);\n+};\n+\n+struct VARC_accelerator_t : VARC::accelerator_t {\n+  VARC_accelerator_t (hb_face_t *face) : VARC::accelerator_t (face) {}\n+};\n+\n+#endif\n+\n+\/\/}\n+\n+}\n+\n+#endif  \/* OT_VAR_VARC_VARC_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Var\/VARC\/VARC.hh","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+#ifndef OT_VAR_VARC_COORD_SETTER_HH\n+#define OT_VAR_VARC_COORD_SETTER_HH\n+\n+\n+#include \"..\/..\/..\/hb.hh\"\n+\n+\n+namespace OT {\n+\/\/namespace Var {\n+\n+\n+struct coord_setter_t\n+{\n+  coord_setter_t (hb_array_t<const int> coords_)\n+  {\n+    length = coords_.length;\n+    if (length <= ARRAY_LENGTH (static_coords))\n+      hb_memcpy (static_coords, coords_.arrayZ, length * sizeof (int));\n+    else\n+      dynamic_coords.extend (coords_);\n+  }\n+\n+  int& operator [] (unsigned idx)\n+  {\n+    if (unlikely (idx >= HB_VAR_COMPOSITE_MAX_AXES))\n+      return Crap(int);\n+\n+    if (length <= ARRAY_LENGTH (static_coords))\n+    {\n+      if (idx < ARRAY_LENGTH (static_coords))\n+      {\n+        while (length <= idx)\n+          static_coords[length++] = 0;\n+        return static_coords[idx];\n+      }\n+      else\n+        dynamic_coords.extend (hb_array (static_coords, length));\n+    }\n+\n+    if (dynamic_coords.length <= idx)\n+    {\n+      if (unlikely (!dynamic_coords.resize (idx + 1)))\n+        return Crap(int);\n+      length = idx + 1;\n+    }\n+    return dynamic_coords.arrayZ[idx];\n+  }\n+\n+  hb_array_t<int> get_coords ()\n+  { return length <= ARRAY_LENGTH (static_coords) ? hb_array (static_coords, length) : dynamic_coords.as_array (); }\n+\n+  private:\n+  hb_vector_t<int> dynamic_coords;\n+  unsigned length;\n+  int static_coords[sizeof (void *) * 8];\n+};\n+\n+\n+\/\/} \/\/ namespace Var\n+\n+} \/\/ namespace OT\n+\n+#endif \/* OT_VAR_VARC_COORD_SETTER_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Var\/VARC\/coord-setter.hh","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright © 2025 Behdad Esfahbod\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_DECYCLER_HH\n+#define HB_DECYCLER_HH\n+\n+#include \"hb.hh\"\n+\n+\/*\n+ * hb_decycler_t is an efficient cycle detector for graph traversal.\n+ * It's a simple tortoise-and-hare algorithm with a twist: it's\n+ * designed to detect cycles while traversing a graph in a DFS manner,\n+ * instead of just a linked list.\n+ *\n+ * For Floyd's tortoise and hare algorithm, see:\n+ * https:\/\/en.wikipedia.org\/wiki\/Cycle_detection#Floyd's_tortoise_and_hare\n+ *\n+ * hb_decycler_t is O(n) in the number of nodes in the DFS traversal\n+ * if there are no cycles. Unlike Floyd's algorithm, hb_decycler_t\n+ * can be used in a DFS traversal, where the graph is not a simple\n+ * linked list, but a tree with possible cycles.  Like Floyd's algorithm,\n+ * it is constant-memory (~three  pointers).\n+ *\n+ * The decycler works by creating an implicit linked-list on the stack,\n+ * of the path from the root to the current node, and apply Floyd's\n+ * algorithm on that list as it goes.\n+ *\n+ * The decycler is malloc-free, and as such, much faster to use than a\n+ * hb_set_t or hb_map_t equivalent.\n+ *\n+ * The decycler detects cycles in the graph *eventually*, not *immediately*.\n+ * That is, it may not detect a cycle until the cycle is fully traversed,\n+ * even multiple times. See Floyd's algorithm analysis for details.\n+ *\n+ * The implementation saves a pointer storage on the stack by combining\n+ * this->u.decycler and this->u.next into a union.  This is possible because\n+ * at any point we only need one of those values. The invariant is that\n+ * after construction, and before destruction, of a node, the u.decycler\n+ * field is always valid. The u.next field is only valid when the node is\n+ * in the traversal path, parent to another node.\n+ *\n+ * There are three method's:\n+ *\n+ *   - hb_decycler_node_t() constructor: Creates a new node in the traversal.\n+ *     The constructor takes a reference to the decycler object and inserts\n+ *     itself as the latest node in the traversal path, by advancing the hare\n+ *     pointer, and for every other descent, advancing the tortoise pointer.\n+ *\n+ *   - ~hb_decycler_node_t() destructor: Restores the decycler object to its\n+ *      previous state by removing the node from the traversal path.\n+ *\n+ *   - bool visit(uintptr_t value): Called on every node in the graph.  Returns\n+ *     true if the node is not part of a cycle, and false if it is.  The value\n+ *     parameter is used to detect cycles.  It's the caller's responsibility\n+ *     to ensure that the value is unique for each node in the graph.\n+ *     The cycle detection is as simple as comparing the value to the value\n+ *     held by the tortoise pointer, which is the Floyd's algorithm.\n+ *\n+ * For usage examples see test-decycler.cc.\n+ *\/\n+\n+struct hb_decycler_node_t;\n+\n+struct hb_decycler_t\n+{\n+  friend struct hb_decycler_node_t;\n+\n+  private:\n+  bool tortoise_awake = false;\n+  hb_decycler_node_t *tortoise = nullptr;\n+  hb_decycler_node_t *hare = nullptr;\n+};\n+\n+struct hb_decycler_node_t\n+{\n+  hb_decycler_node_t (hb_decycler_t &decycler)\n+  {\n+    u.decycler = &decycler;\n+\n+    decycler.tortoise_awake = !decycler.tortoise_awake;\n+\n+    if (!decycler.tortoise)\n+    {\n+      \/\/ First node.\n+      assert (decycler.tortoise_awake);\n+      assert (!decycler.hare);\n+      decycler.tortoise = decycler.hare = this;\n+      return;\n+    }\n+\n+    if (decycler.tortoise_awake)\n+      decycler.tortoise = decycler.tortoise->u.next; \/\/ Time to move.\n+\n+    this->prev = decycler.hare;\n+    decycler.hare->u.next = this;\n+    decycler.hare = this;\n+  }\n+\n+  ~hb_decycler_node_t ()\n+  {\n+    hb_decycler_t &decycler = *u.decycler;\n+\n+    \/\/ Inverse of the constructor.\n+\n+    assert (decycler.hare == this);\n+    decycler.hare = prev;\n+    if (prev)\n+      prev->u.decycler = &decycler;\n+\n+    assert (decycler.tortoise);\n+    if (decycler.tortoise_awake)\n+      decycler.tortoise = decycler.tortoise->prev;\n+\n+    decycler.tortoise_awake = !decycler.tortoise_awake;\n+  }\n+\n+  bool visit (uintptr_t value_)\n+  {\n+    value = value_;\n+\n+    hb_decycler_t &decycler = *u.decycler;\n+\n+    if (decycler.tortoise == this)\n+      return true; \/\/ First node; not a cycle.\n+\n+    if (decycler.tortoise->value == value)\n+      return false; \/\/ Cycle detected.\n+\n+    return true;\n+  }\n+\n+  private:\n+  union {\n+    hb_decycler_t *decycler;\n+    hb_decycler_node_t *next;\n+  } u = {nullptr};\n+  hb_decycler_node_t *prev = nullptr;\n+  uintptr_t value = 0;\n+};\n+\n+#endif \/* HB_DECYCLER_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-decycler.hh","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,293 @@\n+\/*\n+ * Copyright © 2022 Behdad Esfahbod\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+#ifndef HB_GEOMETRY_HH\n+#define HB_GEOMETRY_HH\n+\n+#include \"hb.hh\"\n+\n+\n+struct hb_extents_t\n+{\n+  hb_extents_t () {}\n+  hb_extents_t (float xmin, float ymin, float xmax, float ymax) :\n+    xmin (xmin), ymin (ymin), xmax (xmax), ymax (ymax) {}\n+\n+  bool is_empty () const { return xmin >= xmax || ymin >= ymax; }\n+  bool is_void () const { return xmin > xmax; }\n+\n+  void union_ (const hb_extents_t &o)\n+  {\n+    xmin = hb_min (xmin, o.xmin);\n+    ymin = hb_min (ymin, o.ymin);\n+    xmax = hb_max (xmax, o.xmax);\n+    ymax = hb_max (ymax, o.ymax);\n+  }\n+\n+  void intersect (const hb_extents_t &o)\n+  {\n+    xmin = hb_max (xmin, o.xmin);\n+    ymin = hb_max (ymin, o.ymin);\n+    xmax = hb_min (xmax, o.xmax);\n+    ymax = hb_min (ymax, o.ymax);\n+  }\n+\n+  void\n+  add_point (float x, float y)\n+  {\n+    if (unlikely (is_void ()))\n+    {\n+      xmin = xmax = x;\n+      ymin = ymax = y;\n+    }\n+    else\n+    {\n+      xmin = hb_min (xmin, x);\n+      ymin = hb_min (ymin, y);\n+      xmax = hb_max (xmax, x);\n+      ymax = hb_max (ymax, y);\n+    }\n+  }\n+\n+  float xmin = 0.f;\n+  float ymin = 0.f;\n+  float xmax = -1.f;\n+  float ymax = -1.f;\n+};\n+\n+struct hb_transform_t\n+{\n+  hb_transform_t () {}\n+  hb_transform_t (float xx, float yx,\n+                  float xy, float yy,\n+                  float x0, float y0) :\n+    xx (xx), yx (yx), xy (xy), yy (yy), x0 (x0), y0 (y0) {}\n+\n+  bool is_identity () const\n+  {\n+    return xx == 1.f && yx == 0.f &&\n+           xy == 0.f && yy == 1.f &&\n+           x0 == 0.f && y0 == 0.f;\n+  }\n+\n+  void multiply (const hb_transform_t &o)\n+  {\n+    \/* Copied from cairo, with \"o\" being \"a\" there and \"this\" being \"b\" there. *\/\n+    hb_transform_t r;\n+\n+    r.xx = o.xx * xx + o.yx * xy;\n+    r.yx = o.xx * yx + o.yx * yy;\n+\n+    r.xy = o.xy * xx + o.yy * xy;\n+    r.yy = o.xy * yx + o.yy * yy;\n+\n+    r.x0 = o.x0 * xx + o.y0 * xy + x0;\n+    r.y0 = o.x0 * yx + o.y0 * yy + y0;\n+\n+    *this = r;\n+  }\n+\n+  void transform_distance (float &dx, float &dy) const\n+  {\n+    float new_x = xx * dx + xy * dy;\n+    float new_y = yx * dx + yy * dy;\n+    dx = new_x;\n+    dy = new_y;\n+  }\n+\n+  void transform_point (float &x, float &y) const\n+  {\n+    transform_distance (x, y);\n+    x += x0;\n+    y += y0;\n+  }\n+\n+  void transform_extents (hb_extents_t &extents) const\n+  {\n+    float quad_x[4], quad_y[4];\n+\n+    quad_x[0] = extents.xmin;\n+    quad_y[0] = extents.ymin;\n+    quad_x[1] = extents.xmin;\n+    quad_y[1] = extents.ymax;\n+    quad_x[2] = extents.xmax;\n+    quad_y[2] = extents.ymin;\n+    quad_x[3] = extents.xmax;\n+    quad_y[3] = extents.ymax;\n+\n+    extents = hb_extents_t {};\n+    for (unsigned i = 0; i < 4; i++)\n+    {\n+      transform_point (quad_x[i], quad_y[i]);\n+      extents.add_point (quad_x[i], quad_y[i]);\n+    }\n+  }\n+\n+  void transform (const hb_transform_t &o) { multiply (o); }\n+\n+  void translate (float x, float y)\n+  {\n+    if (x == 0.f && y == 0.f)\n+      return;\n+\n+    x0 += xx * x + xy * y;\n+    y0 += yx * x + yy * y;\n+  }\n+\n+  void scale (float scaleX, float scaleY)\n+  {\n+    if (scaleX == 1.f && scaleY == 1.f)\n+      return;\n+\n+    xx *= scaleX;\n+    yx *= scaleX;\n+    xy *= scaleY;\n+    yy *= scaleY;\n+  }\n+\n+  void rotate (float rotation)\n+  {\n+    if (rotation == 0.f)\n+      return;\n+\n+    \/\/ https:\/\/github.com\/fonttools\/fonttools\/blob\/f66ee05f71c8b57b5f519ee975e95edcd1466e14\/Lib\/fontTools\/misc\/transform.py#L240\n+    rotation = rotation * HB_PI;\n+    float c;\n+    float s;\n+#ifdef HAVE_SINCOSF\n+    sincosf (rotation, &s, &c);\n+#else\n+    c = cosf (rotation);\n+    s = sinf (rotation);\n+#endif\n+    auto other = hb_transform_t{c, s, -s, c, 0.f, 0.f};\n+    transform (other);\n+  }\n+\n+  void skew (float skewX, float skewY)\n+  {\n+    if (skewX == 0.f && skewY == 0.f)\n+      return;\n+\n+    \/\/ https:\/\/github.com\/fonttools\/fonttools\/blob\/f66ee05f71c8b57b5f519ee975e95edcd1466e14\/Lib\/fontTools\/misc\/transform.py#L255\n+    skewX = skewX * HB_PI;\n+    skewY = skewY * HB_PI;\n+    auto other = hb_transform_t{1.f,\n+                                skewY ? tanf (skewY) : 0.f,\n+                                skewX ? tanf (skewX) : 0.f,\n+                                1.f,\n+                                0.f, 0.f};\n+    transform (other);\n+  }\n+\n+  float xx = 1.f;\n+  float yx = 0.f;\n+  float xy = 0.f;\n+  float yy = 1.f;\n+  float x0 = 0.f;\n+  float y0 = 0.f;\n+};\n+\n+#define HB_TRANSFORM_IDENTITY hb_transform_t{1.f, 0.f, 0.f, 1.f, 0.f, 0.f}\n+\n+struct hb_bounds_t\n+{\n+  enum status_t {\n+    UNBOUNDED,\n+    BOUNDED,\n+    EMPTY,\n+  };\n+\n+  hb_bounds_t (status_t status) : status (status) {}\n+  hb_bounds_t (const hb_extents_t &extents) :\n+    status (extents.is_empty () ? EMPTY : BOUNDED), extents (extents) {}\n+\n+  void union_ (const hb_bounds_t &o)\n+  {\n+    if (o.status == UNBOUNDED)\n+      status = UNBOUNDED;\n+    else if (o.status == BOUNDED)\n+    {\n+      if (status == EMPTY)\n+        *this = o;\n+      else if (status == BOUNDED)\n+        extents.union_ (o.extents);\n+    }\n+  }\n+\n+  void intersect (const hb_bounds_t &o)\n+  {\n+    if (o.status == EMPTY)\n+      status = EMPTY;\n+    else if (o.status == BOUNDED)\n+    {\n+      if (status == UNBOUNDED)\n+        *this = o;\n+      else if (status == BOUNDED)\n+      {\n+        extents.intersect (o.extents);\n+        if (extents.is_empty ())\n+          status = EMPTY;\n+      }\n+    }\n+  }\n+\n+  status_t status;\n+  hb_extents_t extents;\n+};\n+\n+struct hb_transform_decomposed_t\n+{\n+  float translateX = 0;\n+  float translateY = 0;\n+  float rotation = 0;  \/\/ in degrees, counter-clockwise\n+  float scaleX = 1;\n+  float scaleY = 1;\n+  float skewX = 0;  \/\/ in degrees, counter-clockwise\n+  float skewY = 0;  \/\/ in degrees, counter-clockwise\n+  float tCenterX = 0;\n+  float tCenterY = 0;\n+\n+  operator bool () const\n+  {\n+    return translateX || translateY ||\n+           rotation ||\n+           scaleX != 1 || scaleY != 1 ||\n+           skewX || skewY ||\n+           tCenterX || tCenterY;\n+  }\n+\n+  hb_transform_t to_transform () const\n+  {\n+    hb_transform_t t;\n+    t.translate (translateX + tCenterX, translateY + tCenterY);\n+    t.rotate (rotation);\n+    t.scale (scaleX, scaleY);\n+    t.skew (-skewX, skewY);\n+    t.translate (-tCenterX, -tCenterY);\n+    return t;\n+  }\n+};\n+\n+\n+#endif \/* HB_GEOMETRY_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-geometry.hh","additions":293,"deletions":0,"binary":false,"changes":293,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright © 2024  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_VAR_VARC_TABLE_HH\n+#define HB_OT_VAR_VARC_TABLE_HH\n+\n+#include \"OT\/Var\/VARC\/VARC.hh\"\n+\n+#endif \/* HB_OT_VAR_VARC_TABLE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-varc-table.hh","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright © 2024  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef HB_SUBSET_INSTANCER_IUP_HH\n+#define HB_SUBSET_INSTANCER_IUP_HH\n+\n+#include \"hb-subset-plan.hh\"\n+\/* given contour points and deltas, optimize a set of referenced points within error\n+ * tolerance. Returns optimized referenced point indices *\/\n+HB_INTERNAL bool iup_delta_optimize (const contour_point_vector_t& contour_points,\n+                                     const hb_vector_t<int>& x_deltas,\n+                                     const hb_vector_t<int>& y_deltas,\n+                                     hb_vector_t<bool>& opt_indices, \/* OUT *\/\n+                                     double tolerance = 0.0);\n+\n+#endif \/* HB_SUBSET_INSTANCER_IUP_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-instancer-iup.hh","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright © 2022  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ *\/\n+\n+#ifndef HB_SUBSET_SERIALIZE_H\n+#define HB_SUBSET_SERIALIZE_H\n+\n+#include \"hb.h\"\n+\n+HB_BEGIN_DECLS\n+\n+\/**\n+ * hb_subset_serialize_link_t:\n+ * @width: offsetSize in bytes\n+ * @position: position of the offset field in bytes from\n+ *            beginning of subtable\n+ * @objidx: index of subtable\n+ *\n+ * Represents a link between two objects in the object graph\n+ * to be serialized.\n+ *\n+ * Since: 10.2.0\n+ *\/\n+typedef struct hb_subset_serialize_link_t {\n+  unsigned int width;\n+  unsigned int position;\n+  unsigned int objidx;\n+} hb_subset_serialize_link_t;\n+\n+\/**\n+ * hb_subset_serialize_object_t:\n+ * @head: start of object data\n+ * @tail: end of object data\n+ * @num_real_links: number of offset field in the object\n+ * @real_links: array of offset info\n+ * @num_virtual_links: number of objects that must be packed\n+ *                     after current object in the final\n+ *                     serialized order\n+ * @virtual_links: array of virtual link info\n+ *\n+ * Represents an object in the object graph to be serialized.\n+ *\n+ * Since: 10.2.0\n+ *\/\n+typedef struct hb_subset_serialize_object_t {\n+  char *head;\n+  char *tail;\n+  unsigned int num_real_links;\n+  hb_subset_serialize_link_t *real_links;\n+  unsigned int num_virtual_links;\n+  hb_subset_serialize_link_t *virtual_links;\n+} hb_subset_serialize_object_t;\n+\n+HB_EXTERN hb_blob_t *\n+hb_subset_serialize_or_fail (hb_tag_t                      table_tag,\n+                             hb_subset_serialize_object_t *hb_objects,\n+                             unsigned                      num_hb_objs);\n+\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_SUBSET_SERIALIZE_H *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-serialize.h","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"}]}