{"files":[{"patch":"@@ -28,0 +28,3 @@\n+import java.io.Closeable;\n+import java.io.Externalizable;\n+import java.io.Serializable;\n@@ -32,0 +35,1 @@\n+import java.util.Arrays;\n@@ -35,0 +39,1 @@\n+import java.util.Set;\n@@ -40,0 +45,12 @@\n+\n+    \/\/ These are some common interfaces that we know a priori\n+    \/\/ will not contain any bean property getters or setters.\n+    static final Set<Class<?>> IGNORABLE_INTERFACES = Set.of(\n+        AutoCloseable.class,\n+        Cloneable.class,\n+        Closeable.class,\n+        Comparable.class,\n+        Externalizable.class,\n+        Serializable.class\n+    );\n+\n@@ -69,0 +86,2 @@\n+\n+            \/\/ Add declared methods\n@@ -84,4 +103,13 @@\n-                        if (list == null) {\n-                            list = new ArrayList<>();\n-                        }\n-                        list.add(method);\n+                        (list = createIfNeeded(list)).add(method);\n+                    }\n+                }\n+            }\n+\n+            \/\/ Add default methods inherited from interfaces\n+            for (Class<?> iface : type.getInterfaces()) {\n+                if (IGNORABLE_INTERFACES.contains(iface)) {\n+                    continue;\n+                }\n+                for (Method method : iface.getMethods()) {\n+                    if (!Modifier.isAbstract(method.getModifiers())) {\n+                        (list = createIfNeeded(list)).add(method);\n@@ -99,0 +127,4 @@\n+    private static List<Method> createIfNeeded(List<Method> list) {\n+        return list != null ? list : new ArrayList<>();\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/beans\/introspect\/MethodInfo.java","additions":36,"deletions":4,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8071693\n+ * @summary Verify that the Introspector finds default methods inherited\n+ *          from interfaces\n+ *\/\n+\n+import java.beans.IntrospectionException;\n+import java.beans.Introspector;\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.NavigableSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class DefaultMethodBeanPropertyTest {\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/                                  \/\/\n+\/\/          SCENARIO 1              \/\/\n+\/\/                                  \/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    public interface A1 {\n+        default int getValue() {\n+            return 0;\n+        }\n+        default Object getObj() {\n+            return null;\n+        }\n+\n+        public static int getStaticValue() {\n+            return 0;\n+        }\n+    }\n+\n+    public interface B1 extends A1 {\n+    }\n+\n+    public interface C1 extends A1 {\n+        Number getFoo();\n+    }\n+\n+    public class D1 implements C1 {\n+        @Override\n+        public Integer getFoo() {\n+            return null;\n+        }\n+        @Override\n+        public Float getObj() {\n+            return null;\n+        }\n+    }\n+\n+    public static void testScenario1() {\n+        verifyProperties(D1.class,\n+            \"getClass\",     \/\/ inherited method\n+            \"getValue\",     \/\/ inherited default method\n+            \"getFoo\",       \/\/ overridden interface method\n+            \"getObj\"        \/\/ overridden default method\n+        );\n+    }\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/                                  \/\/\n+\/\/          SCENARIO 2              \/\/\n+\/\/                                  \/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    public interface A2 {\n+        default Object getFoo() {\n+            return null;\n+        }\n+    }\n+\n+    public interface B2 extends A2 {\n+    }\n+\n+    public interface C2 extends A2 {\n+    }\n+\n+    public class D2 implements B2, C2 {\n+    }\n+\n+    public static void testScenario2() {\n+        verifyProperties(D2.class,\n+            \"getClass\",\n+            \"getFoo\"\n+        );\n+    }\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/                                  \/\/\n+\/\/          SCENARIO 3              \/\/\n+\/\/                                  \/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    public interface A3 {\n+        default Object getFoo() {\n+            return null;\n+        }\n+    }\n+\n+    public interface B3 extends A3 {\n+        @Override\n+        Set<?> getFoo();\n+    }\n+\n+    public interface C3 extends A3 {\n+        @Override\n+        Collection<?> getFoo();\n+    }\n+\n+    public class D3 implements B3, C3 {\n+        @Override\n+        public NavigableSet<?> getFoo() {\n+            return null;\n+        }\n+    }\n+\n+    public static void testScenario3() {\n+        verifyProperties(D3.class,\n+            \"getClass\",\n+            \"getFoo\"\n+        );\n+    }\n+\n+\/\/ Helper methods\n+\n+    public static void verifyProperties(Class<?> type, String... getterNames) {\n+\n+        \/\/ Gather expected properties\n+        final HashSet<PropertyDescriptor> expected = new HashSet<>();\n+        for (String methodName : getterNames) {\n+            final String suffix = methodName.substring(3);\n+            final String propName = Introspector.decapitalize(suffix);\n+            final Method getter;\n+            try {\n+                getter = type.getMethod(methodName);\n+            } catch (NoSuchMethodException e) {\n+                throw new Error(\"unexpected error\", e);\n+            }\n+            final PropertyDescriptor propDesc;\n+            try {\n+                propDesc = new PropertyDescriptor(propName, getter, null);\n+            } catch (IntrospectionException e) {\n+                throw new Error(\"unexpected error\", e);\n+            }\n+            expected.add(propDesc);\n+        }\n+\n+        \/\/ Verify properties can be found directly\n+        expected.stream()\n+                .map(PropertyDescriptor::getName)\n+                .filter(name -> BeanUtils.getPropertyDescriptor(type, name) == null)\n+                .findFirst()\n+                .ifPresent(name -> {\n+                    throw new Error(\"property \\\"\" + name + \"\\\" not found in \" + type);\n+                });\n+\n+        \/\/ Gather actual properties\n+        final Set<PropertyDescriptor> actual =\n+                Set.of(BeanUtils.getPropertyDescriptors(type));\n+\n+        \/\/ Verify the two sets are the same\n+        if (!actual.equals(expected)) {\n+            throw new Error(\"mismatch: \" + type\n+              + \"\\nACTUAL:\\n  \"\n+              + actual.stream()\n+                      .map(Object::toString)\n+                      .collect(Collectors.joining(\"\\n  \"))\n+              + \"\\nEXPECTED:\\n  \"\n+              + expected.stream()\n+                        .map(Object::toString)\n+                        .collect(Collectors.joining(\"\\n  \")));\n+        }\n+    }\n+\n+\/\/ Main method\n+\n+    public static void main(String[] args) throws Exception {\n+        testScenario1();\n+        testScenario2();\n+        testScenario3();\n+    }\n+}\n","filename":"test\/jdk\/java\/beans\/Introspector\/DefaultMethodBeanPropertyTest.java","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"}]}