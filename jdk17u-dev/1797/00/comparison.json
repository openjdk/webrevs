{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -388,1 +388,1 @@\n-    int n = ::write(s, buf, len);\n+    ssize_t n = ::write(s, buf, len);\n","filename":"src\/hotspot\/os\/linux\/attachListener_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1444,8 +1444,0 @@\n-static bool file_exists(const char* filename) {\n-  struct stat statbuf;\n-  if (filename == NULL || strlen(filename) == 0) {\n-    return false;\n-  }\n-  return os::stat(filename, &statbuf) == 0;\n-}\n-\n@@ -2515,1 +2507,1 @@\n-      if (file_exists(hbuf_level)) {\n+      if (os::file_exists(hbuf_level)) {\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -742,3 +742,3 @@\n-size_t os::write(int fd, const void *buf, unsigned int nBytes) {\n-  size_t res;\n-  RESTARTABLE((size_t) ::write(fd, buf, (size_t) nBytes), res);\n+ssize_t os::pd_write(int fd, const void *buf, size_t nBytes) {\n+  ssize_t res;\n+  RESTARTABLE(::write(fd, buf, nBytes), res);\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-  int result;\n+  int fd;\n@@ -94,7 +94,4 @@\n-  RESTARTABLE(os::open(destfile, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR|S_IWUSR),\n-              result);\n-  if (result == OS_ERR) {\n-    if (PrintMiscellaneous && Verbose) {\n-      warning(\"Could not create Perfdata save file: %s: %s\\n\",\n-              destfile, os::strerror(errno));\n-    }\n+  RESTARTABLE(os::open(destfile, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR|S_IWUSR), fd);\n+  if (fd == OS_ERR) {\n+    warning(\"Could not create Perfdata save file: %s: %s\\n\",\n+            destfile, os::strerror(errno));\n@@ -102,12 +99,1 @@\n-    int fd = result;\n-\n-    for (size_t remaining = size; remaining > 0;) {\n-\n-      RESTARTABLE(::write(fd, addr, remaining), result);\n-      if (result == OS_ERR) {\n-        if (PrintMiscellaneous && Verbose) {\n-          warning(\"Could not write Perfdata save file: %s: %s\\n\",\n-                  destfile, os::strerror(errno));\n-        }\n-        break;\n-      }\n+    ssize_t result;\n@@ -115,2 +101,4 @@\n-      remaining -= (size_t)result;\n-      addr += result;\n+    bool successful_write = os::write(fd, addr, size);\n+    if (!successful_write) {\n+      warning(\"Could not write Perfdata save file: %s: %s\\n\",\n+              destfile, os::strerror(errno));\n@@ -119,0 +107,1 @@\n+\n@@ -120,4 +109,2 @@\n-    if (PrintMiscellaneous && Verbose) {\n-      if (result == OS_ERR) {\n-        warning(\"Could not close %s: %s\\n\", destfile, os::strerror(errno));\n-      }\n+    if (result == OS_ERR) {\n+      warning(\"Could not close %s: %s\\n\", destfile, os::strerror(errno));\n@@ -883,3 +870,3 @@\n-  int result;\n-  RESTARTABLE(os::open(filename, O_RDWR|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR), result);\n-  if (result == OS_ERR) {\n+  int fd;\n+  RESTARTABLE(os::open(filename, O_RDWR|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR), fd);\n+  if (fd == OS_ERR) {\n@@ -901,3 +888,0 @@\n-  \/\/ save the file descriptor\n-  int fd = result;\n-\n@@ -910,25 +894,1 @@\n-#if defined(LINUX)\n-  \/\/ On Linux, different containerized processes that share the same \/tmp\n-  \/\/ directory (e.g., with \"docker --volume ...\") may have the same pid and\n-  \/\/ try to use the same file. To avoid conflicts among such\n-  \/\/ processes, we allow only one of them (the winner of the flock() call)\n-  \/\/ to write to the file. All the other processes will give up and will\n-  \/\/ have perfdata disabled.\n-  \/\/\n-  \/\/ Note that the flock will be automatically given up when the winner\n-  \/\/ process exits.\n-  \/\/\n-  \/\/ The locking protocol works only with other JVMs that have the JDK-8286030\n-  \/\/ fix. If you are sharing the \/tmp difrectory among different containers,\n-  \/\/ do not use older JVMs that don't have this fix, or the behavior is undefined.\n-  int n;\n-  RESTARTABLE(::flock(fd, LOCK_EX|LOCK_NB), n);\n-  if (n != 0) {\n-    log_warning(perf, memops)(\"Cannot use file %s\/%s because %s (errno = %d)\", dirname, filename,\n-                              (errno == EWOULDBLOCK) ?\n-                              \"it is locked by another process\" :\n-                              \"flock() failed\", errno);\n-    ::close(fd);\n-    return -1;\n-  }\n-#endif\n+  ssize_t result;\n@@ -962,2 +922,1 @@\n-    RESTARTABLE(::write(fd, &zero_int, 1), result);\n-    if (result != 1) {\n+    if (!os::write(fd, &zero_int, 1)) {\n@@ -967,0 +926,1 @@\n+      result = OS_ERR;\n@@ -974,1 +934,1 @@\n-    ::close(fd);\n+    os::close(fd);\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":21,"deletions":61,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -4845,2 +4845,13 @@\n-size_t os::write(int fd, const void *buf, unsigned int nBytes) {\n-  return ::write(fd, buf, nBytes);\n+ssize_t os::pd_write(int fd, const void *buf, size_t nBytes) {\n+  ssize_t original_len = (ssize_t)nBytes;\n+  while (nBytes > 0) {\n+    unsigned int len = nBytes > INT_MAX ? INT_MAX : (unsigned int)nBytes;\n+    \/\/ On Windows, ::write takes 'unsigned int' no of bytes, so nBytes should be split if larger.\n+    ssize_t written_bytes = ::write(fd, buf, len);\n+    if (written_bytes < 0) {\n+      return OS_ERR;\n+    }\n+    nBytes -= written_bytes;\n+    buf = (char *)buf + written_bytes;\n+  }\n+  return original_len;\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1450,2 +1450,1 @@\n-  size_t n = os::write(_fd, buffer, (unsigned int)nbytes);\n-  if (n != nbytes) {\n+  if (!os::write(_fd, buffer, nbytes)) {\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -353,1 +353,1 @@\n-              \"Unable to recover JFR data\");\n+              \"Unable to recover JFR data, read failed.\");\n@@ -358,2 +358,6 @@\n-        bytes_written += (int64_t)os::write(emergency_fd, copy_block, bytes_read - bytes_written);\n-        assert(bytes_read == bytes_written, \"invariant\");\n+        if (!os::write(emergency_fd, copy_block, bytes_read - bytes_written)) {\n+          log_info(jfr)( \/\/ For user, should not be \"jfr, system\"\n+              \"Unable to recover JFR data, write failed.\");\n+          break;\n+        }\n+        bytes_written = bytes_read;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrEmergencyDump.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,2 +79,2 @@\n-    const ssize_t num_written = (ssize_t)os::write(_fd, buf, nBytes);\n-    if (errno == ENOSPC) {\n+    const bool successful_write = os::write(_fd, buf, nBytes);\n+    if (!successful_write && errno == ENOSPC) {\n@@ -83,4 +83,4 @@\n-    guarantee(num_written > 0, \"Nothing got written, or os::write() failed\");\n-    _stream_pos += num_written;\n-    len -= num_written;\n-    buf += num_written;\n+    guarantee(successful_write, \"Not all the bytes got written, or os::write() failed\");\n+    _stream_pos += nBytes;\n+    len -= nBytes;\n+    buf += nBytes;\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrStreamWriterHost.inline.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -95,5 +95,0 @@\n-static bool file_exists(const char* filename) {\n-  struct stat dummy_stat;\n-  return os::stat(filename, &dummy_stat) == 0;\n-}\n-\n@@ -142,1 +137,1 @@\n-    if (file_exists(archive_name) && !is_regular_file(archive_name)) {\n+    if (os::file_exists(archive_name) && !is_regular_file(archive_name)) {\n@@ -153,1 +148,1 @@\n-    if (!file_exists(archive_name)) {\n+    if (!os::file_exists(archive_name)) {\n@@ -236,1 +231,1 @@\n-  bool file_exist = file_exists(_file_name);\n+  bool file_exist = os::file_exists(_file_name);\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2826,1 +2826,1 @@\n-    size_t count = ::write(defaultStream::output_fd(), s, (int)len);\n+    bool dummy = os::write(defaultStream::output_fd(), s, len);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1358,0 +1358,24 @@\n+bool os::file_exists(const char* filename) {\n+  struct stat statbuf;\n+  if (filename == NULL || strlen(filename) == 0) {\n+    return false;\n+  }\n+  return os::stat(filename, &statbuf) == 0;\n+}\n+\n+bool os::write(int fd, const void *buf, size_t nBytes) {\n+  ssize_t res;\n+\n+  while (nBytes > 0) {\n+    res = pd_write(fd, buf, nBytes);\n+    if (res == OS_ERR) {\n+      return false;\n+    }\n+    buf = (void *)((char *)buf + nBytes);\n+    nBytes -= res;\n+  }\n+\n+  return true;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -172,0 +172,2 @@\n+  \/\/ Returns number of bytes written on success, OS_ERR on failure.\n+  static ssize_t pd_write(int fd, const void *buf, size_t nBytes);\n@@ -563,0 +565,1 @@\n+  static bool file_exists(const char* file);\n@@ -582,1 +585,2 @@\n-  static size_t write(int fd, const void *buf, unsigned int nBytes);\n+  \/\/ Writes the bytes completely. Returns true on success, false otherwise.\n+  static bool write(int fd, const void *buf, size_t nBytes);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,8 +58,2 @@\n-  while (size > 0) {\n-    ssize_t n = os::write(_fd, buf, (uint) size);\n-    if (n <= 0) {\n-      return os::strerror(errno);\n-    }\n-\n-    buf += n;\n-    size -= n;\n+  if (!os::write(_fd, buf, (size_t)size)) {\n+    return os::strerror(errno);\n","filename":"src\/hotspot\/share\/services\/heapDumperCompression.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -617,1 +617,1 @@\n-    size_t count = ::write(_fd, s, (int)len);\n+    ssize_t count = ::write(_fd, s, (int)len);\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}