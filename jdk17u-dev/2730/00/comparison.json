{"files":[{"patch":"@@ -198,0 +198,2 @@\n+        this.legacyMap = new ConcurrentHashMap<>();\n+        this.prngAlgos = new LinkedHashSet<String>(6);\n@@ -236,0 +238,2 @@\n+        this.legacyMap = new ConcurrentHashMap<>();\n+        this.prngAlgos = new LinkedHashSet<String>(6);\n@@ -579,1 +583,0 @@\n-\n@@ -605,1 +608,0 @@\n-\n@@ -634,1 +636,0 @@\n-\n@@ -664,1 +665,0 @@\n-\n@@ -691,2 +691,2 @@\n-    public synchronized Object computeIfAbsent(Object key, Function<? super Object,\n-            ? extends Object> mappingFunction) {\n+    public synchronized Object computeIfAbsent(Object key,\n+            Function<? super Object, ? extends Object> mappingFunction) {\n@@ -695,1 +695,0 @@\n-\n@@ -721,2 +720,3 @@\n-    public synchronized Object computeIfPresent(Object key, BiFunction<? super Object,\n-            ? super Object, ? extends Object> remappingFunction) {\n+    public synchronized Object computeIfPresent(Object key,\n+            BiFunction<? super Object, ? super Object, ? extends Object>\n+            remappingFunction) {\n@@ -725,1 +725,0 @@\n-\n@@ -754,2 +753,3 @@\n-    public synchronized Object merge(Object key, Object value,  BiFunction<? super Object,\n-            ? super Object, ? extends Object>  remappingFunction) {\n+    public synchronized Object merge(Object key, Object value,\n+            BiFunction<? super Object, ? super Object, ? extends Object>\n+            remappingFunction) {\n@@ -758,1 +758,0 @@\n-\n@@ -784,1 +783,2 @@\n-    public synchronized void forEach(BiConsumer<? super Object, ? super Object> action) {\n+    public synchronized void forEach(BiConsumer<? super Object, ? super Object>\n+            action) {\n@@ -824,2 +824,2 @@\n-    \/\/ legacy properties changed since last call to any services method?\n-    private transient boolean legacyChanged;\n+    \/\/ legacyMap changed since last call to getServices()\n+    private transient volatile boolean legacyChanged;\n@@ -829,3 +829,0 @@\n-    \/\/ Map<String,String> used to keep track of legacy registration\n-    private transient Map<String,String> legacyStrings;\n-\n@@ -839,0 +836,3 @@\n+    \/\/ NOTE: may need extra mechanism for providers to indicate their\n+    \/\/ preferred ordering of SecureRandom algorithms since registration\n+    \/\/ ordering info is lost once serialized\n@@ -847,1 +847,1 @@\n-    private transient Set<Service> serviceSet;\n+    private transient volatile Set<Service> serviceSet;\n@@ -879,0 +879,1 @@\n+\n@@ -889,0 +890,2 @@\n+        this.legacyMap = new ConcurrentHashMap<>();\n+        this.prngAlgos = new LinkedHashSet<String>(6);\n@@ -894,4 +897,5 @@\n-    \/\/ check whether to update 'legacyString' with the specified key\n-    private boolean checkLegacy(Object key) {\n-        String keyString = (String)key;\n-        if (keyString.startsWith(\"Provider.\")) {\n+    \/\/ returns false if no update necessary, i.e. key isn't String or\n+    \/\/ is String but it's provider-related (name\/version\/info\/className)\n+    private static boolean checkLegacy(Object key) {\n+        if (key instanceof String && ((String)key).startsWith(\"Provider.\")) {\n+            \/\/ ignore provider related updates\n@@ -899,0 +903,2 @@\n+        } else {\n+            return true;\n@@ -900,6 +906,0 @@\n-\n-        legacyChanged = true;\n-        if (legacyStrings == null) {\n-            legacyStrings = new LinkedHashMap<>();\n-        }\n-        return true;\n@@ -920,5 +920,5 @@\n-        if (key instanceof String) {\n-            if (!checkLegacy(key)) {\n-                return null;\n-            }\n-            legacyStrings.remove((String)key);\n+        if (!checkLegacy(key)) return null;\n+\n+        Object o = super.remove(key);\n+        if (o instanceof String so && key instanceof String sk) {\n+            parseLegacy(sk, so, OPType.REMOVE);\n@@ -926,1 +926,1 @@\n-        return super.remove(key);\n+        return o;\n@@ -930,5 +930,5 @@\n-        if (key instanceof String && value instanceof String) {\n-            if (!checkLegacy(key)) {\n-                return false;\n-            }\n-            legacyStrings.remove((String)key, (String)value);\n+        if (!checkLegacy(key)) return false;\n+\n+        boolean result = super.remove(key, value);\n+        if (result && key instanceof String sk && value instanceof String sv) {\n+            parseLegacy(sk, sv, OPType.REMOVE);\n@@ -936,1 +936,1 @@\n-        return super.remove(key, value);\n+        return result;\n@@ -940,4 +940,8 @@\n-        if ((key instanceof String) && (oldValue instanceof String) &&\n-                (newValue instanceof String)) {\n-            if (!checkLegacy(key)) {\n-                return false;\n+        if (!checkLegacy(key)) return false;\n+\n+        boolean result = super.replace(key, oldValue, newValue);\n+        if (result && key instanceof String sk) {\n+            if (newValue instanceof String sv) {\n+                parseLegacy(sk, sv, OPType.ADD);\n+            } else if (oldValue instanceof String sv) {\n+                parseLegacy(sk, sv, OPType.REMOVE);\n@@ -945,2 +949,0 @@\n-            legacyStrings.replace((String)key, (String)oldValue,\n-                    (String)newValue);\n@@ -948,1 +950,1 @@\n-        return super.replace(key, oldValue, newValue);\n+        return result;\n@@ -952,3 +954,10 @@\n-        if ((key instanceof String) && (value instanceof String)) {\n-            if (!checkLegacy(key)) {\n-                return null;\n+        if (!checkLegacy(key)) return null;\n+\n+        Object o = super.replace(key, value);\n+        if (key instanceof String sk) {\n+            if (o instanceof String so) {\n+                if (value instanceof String sv) {\n+                    parseLegacy(sk, sv, OPType.ADD);\n+                } else {\n+                    parseLegacy(sk, so, OPType.REMOVE);\n+                }\n@@ -956,1 +965,0 @@\n-            legacyStrings.replace((String)key, (String)value);\n@@ -958,1 +966,1 @@\n-        return super.replace(key, value);\n+        return o;\n@@ -964,0 +972,4 @@\n+\n+        super.replaceAll(function);\n+        \/\/ clear out all existing mappings and start fresh\n+        legacyMap.clear();\n@@ -965,5 +977,9 @@\n-        if (legacyStrings == null) {\n-            legacyStrings = new LinkedHashMap<>();\n-        } else {\n-            legacyStrings.replaceAll((BiFunction<? super String, ? super String,\n-                    ? extends String>) function);\n+        for (Map.Entry<Object, Object> entry : super.entrySet()) {\n+            Object key = entry.getKey();\n+            Object value = entry.getValue();\n+            if ((key instanceof String sk) && (value instanceof String sv)) {\n+                if (!checkLegacy(sk)) {\n+                    continue;\n+                }\n+                parseLegacy(sk, sv, OPType.ADD);\n+            }\n@@ -971,1 +987,0 @@\n-        super.replaceAll(function);\n@@ -978,3 +993,8 @@\n-        if ((key instanceof String) && (value instanceof String)) {\n-            if (!checkLegacy(key)) {\n-                return null;\n+        if (!checkLegacy(key)) return null;\n+\n+        Object o = super.merge(key, value, remappingFunction);\n+        if (key instanceof String sk) {\n+            if (o == null) {\n+                parseLegacy(sk, null, OPType.REMOVE);\n+            } else if (o instanceof String so) {\n+                parseLegacy(sk, so, OPType.ADD);\n@@ -982,3 +1002,0 @@\n-            legacyStrings.merge((String)key, (String)value,\n-                    (BiFunction<? super String, ? super String,\n-                    ? extends String>) remappingFunction);\n@@ -986,1 +1003,1 @@\n-        return super.merge(key, value, remappingFunction);\n+        return o;\n@@ -992,3 +1009,9 @@\n-        if (key instanceof String) {\n-            if (!checkLegacy(key)) {\n-                return null;\n+\n+        if (!checkLegacy(key)) return null;\n+\n+        Object o = super.compute(key, remappingFunction);\n+        if (key instanceof String sk) {\n+            if (o == null) {\n+                parseLegacy(sk, null, OPType.REMOVE);\n+            } else if (o instanceof String so) {\n+                parseLegacy(sk, so, OPType.ADD);\n@@ -996,3 +1019,0 @@\n-            legacyStrings.compute((String) key,\n-                    (BiFunction<? super String,? super String,\n-                    ? extends String>) remappingFunction);\n@@ -1000,1 +1020,1 @@\n-        return super.compute(key, remappingFunction);\n+        return o;\n@@ -1006,7 +1026,5 @@\n-        if (key instanceof String) {\n-            if (!checkLegacy(key)) {\n-                return null;\n-            }\n-            legacyStrings.computeIfAbsent((String) key,\n-                    (Function<? super String, ? extends String>)\n-                    mappingFunction);\n+        if (!checkLegacy(key)) return null;\n+\n+        Object o = super.computeIfAbsent(key, mappingFunction);\n+        if (o instanceof String so && key instanceof String sk) {\n+            parseLegacy(sk, so, OPType.ADD);\n@@ -1014,1 +1032,1 @@\n-        return super.computeIfAbsent(key, mappingFunction);\n+        return o;\n@@ -1020,7 +1038,5 @@\n-        if (key instanceof String) {\n-            if (!checkLegacy(key)) {\n-                return null;\n-            }\n-            legacyStrings.computeIfPresent((String) key,\n-                    (BiFunction<? super String, ? super String,\n-                    ? extends String>) remappingFunction);\n+        if (!checkLegacy(key)) return null;\n+\n+        Object o = super.computeIfPresent(key, remappingFunction);\n+        if (o instanceof String so && key instanceof String sk) {\n+            parseLegacy(sk, so, OPType.ADD);\n@@ -1028,1 +1044,1 @@\n-        return super.computeIfPresent(key, remappingFunction);\n+        return o;\n@@ -1032,5 +1048,5 @@\n-        if ((key instanceof String) && (value instanceof String)) {\n-            if (!checkLegacy(key)) {\n-                return null;\n-            }\n-            legacyStrings.put((String)key, (String)value);\n+        if (!checkLegacy(key)) return null;\n+\n+        Object o = super.put(key, value);\n+        if (key instanceof String sk && value instanceof String sv) {\n+            parseLegacy(sk, sv, OPType.ADD);\n@@ -1038,1 +1054,1 @@\n-        return super.put(key, value);\n+        return o;\n@@ -1042,5 +1058,6 @@\n-        if ((key instanceof String) && (value instanceof String)) {\n-            if (!checkLegacy(key)) {\n-                return null;\n-            }\n-            legacyStrings.putIfAbsent((String)key, (String)value);\n+        if (!checkLegacy(key)) return null;\n+\n+        Object o = super.putIfAbsent(key, value);\n+        if (o == null && key instanceof String sk &&\n+                value instanceof String sv) {\n+            parseLegacy(sk, sv, OPType.ADD);\n@@ -1048,1 +1065,1 @@\n-        return super.putIfAbsent(key, value);\n+        return o;\n@@ -1052,6 +1069,1 @@\n-        if (legacyStrings != null) {\n-            legacyStrings.clear();\n-        }\n-        if (legacyMap != null) {\n-            legacyMap.clear();\n-        }\n+        legacyMap.clear();\n@@ -1062,1 +1074,1 @@\n-        prngAlgos = null;\n+        prngAlgos.clear();\n@@ -1092,34 +1104,2 @@\n-    }\n-\n-    \/**\n-     * Ensure all the legacy String properties are fully parsed into\n-     * service objects.\n-     *\/\n-    private void ensureLegacyParsed() {\n-        if (legacyChanged == false || (legacyStrings == null)) {\n-            return;\n-        }\n-        serviceSet = null;\n-        if (legacyMap == null) {\n-            legacyMap = new ConcurrentHashMap<>();\n-        } else {\n-            legacyMap.clear();\n-        }\n-        for (Map.Entry<String,String> entry : legacyStrings.entrySet()) {\n-            parseLegacyPut(entry.getKey(), entry.getValue());\n-        }\n-        removeInvalidServices(legacyMap);\n-        legacyChanged = false;\n-    }\n-\n-    \/**\n-     * Remove all invalid services from the Map. Invalid services can only\n-     * occur if the legacy properties are inconsistent or incomplete.\n-     *\/\n-    private void removeInvalidServices(Map<ServiceKey,Service> map) {\n-        for (Iterator<Map.Entry<ServiceKey, Service>> t =\n-                map.entrySet().iterator(); t.hasNext(); ) {\n-            Service s = t.next().getValue();\n-            if (s.isValid() == false) {\n-                t.remove();\n-            }\n+        public String toString() {\n+            return type + \".\" + algorithm;\n@@ -1143,0 +1123,5 @@\n+    \/\/ utility method for getting a String with service type and algorithm\n+    private static String getKey(Service s) {\n+        return s.getType() + \".\" + s.getAlgorithm();\n+    }\n+\n@@ -1147,1 +1132,6 @@\n-    private void parseLegacyPut(String name, String value) {\n+    private static enum OPType {\n+        ADD, REMOVE;\n+    }\n+\n+    private void parseLegacy(String name, String value, OPType opType) {\n+        \/\/ alias\n@@ -1151,3 +1141,2 @@\n-            String stdAlg = value;\n-            String aliasKey = name.substring(ALIAS_LENGTH);\n-            String[] typeAndAlg = getTypeAndAlgorithm(aliasKey);\n+            String aliasKeyStr = name.substring(ALIAS_LENGTH);\n+            String[] typeAndAlg = getTypeAndAlgorithm(aliasKeyStr);\n@@ -1157,0 +1146,2 @@\n+            legacyChanged = true;\n+            Objects.requireNonNull(value, \"alias value should map to an alg\");\n@@ -1159,5 +1150,26 @@\n-            ServiceKey key = new ServiceKey(type, stdAlg, true);\n-            Service s = legacyMap.get(key);\n-            if (s == null) {\n-                s = new Service(this, type, stdAlg);\n-                legacyMap.put(key, s);\n+            ServiceKey stdKey = new ServiceKey(type, value, true);\n+            Service stdService = legacyMap.get(stdKey);\n+            ServiceKey aliasKey = new ServiceKey(type, aliasAlg, true);\n+            switch (opType) {\n+                case ADD:\n+                    \/\/ clean up old alias if present\n+                    Service prevAliasService = legacyMap.get(aliasKey);\n+                    if (prevAliasService != null) {\n+                        prevAliasService.removeAlias(aliasAlg);\n+                    }\n+                    if (stdService == null) {\n+                        \/\/ add standard mapping in order to add alias\n+                        stdService = new Service(this, type, value);\n+                        legacyMap.put(stdKey, stdService);\n+                    }\n+                    stdService.addAlias(aliasAlg);\n+                    legacyMap.put(aliasKey, stdService);\n+                    break;\n+                case REMOVE:\n+                    if (stdService != null) {\n+                        stdService.removeAlias(aliasAlg);\n+                    }\n+                    legacyMap.remove(aliasKey);\n+                    break;\n+                default:\n+                    throw new AssertionError();\n@@ -1165,2 +1177,0 @@\n-            legacyMap.put(new ServiceKey(type, aliasAlg, true), s);\n-            s.addAlias(aliasAlg);\n@@ -1172,0 +1182,1 @@\n+            legacyChanged = true;\n@@ -1173,0 +1184,1 @@\n+            \/\/ regular registration\n@@ -1177,11 +1189,29 @@\n-                String className = value;\n-                ServiceKey key = new ServiceKey(type, stdAlg, true);\n-                Service s = legacyMap.get(key);\n-                if (s == null) {\n-                    s = new Service(this, type, stdAlg);\n-                    legacyMap.put(key, s);\n-                }\n-                s.className = className;\n-\n-                if (type.equals(\"SecureRandom\")) {\n-                    updateSecureRandomEntries(true, s.algorithm);\n+                ServiceKey stdKey = new ServiceKey(type, stdAlg, true);\n+                Service stdService = legacyMap.get(stdKey);\n+                switch (opType) {\n+                    case ADD:\n+                        Objects.requireNonNull(value,\n+                                \"className can't be null\");\n+                        if (stdService == null) {\n+                            stdService = new Service(this, type, stdAlg);\n+                            legacyMap.put(stdKey, stdService);\n+                        }\n+                        stdService.className = value;\n+                        break;\n+                    case REMOVE:\n+                        \/\/ only remove if value also matches when non-null\n+                        if (stdService != null) {\n+                            if (value == null) {\n+                                legacyMap.remove(stdKey);\n+                            } else if (stdService.className.equals(value)) {\n+                                legacyMap.remove(stdKey, stdService);\n+                            }\n+                            \/\/ remove all corresponding alias mappings\n+                            for (String alias : stdService.getAliases()) {\n+                                legacyMap.remove(new ServiceKey(type, alias,\n+                                        true), stdService);\n+                            }\n+                        }\n+                        break;\n+                    default:\n+                        throw new AssertionError();\n@@ -1189,0 +1219,2 @@\n+                checkAndUpdateSecureRandom(type, stdAlg,\n+                        (opType != OPType.REMOVE));\n@@ -1191,1 +1223,0 @@\n-                String attributeValue = value;\n@@ -1193,3 +1224,3 @@\n-                String attributeString = typeAndAlg[1];\n-                String stdAlg = attributeString.substring(0, i).intern();\n-                String attributeName = attributeString.substring(i + 1);\n+                String attrString = typeAndAlg[1];\n+                String stdAlg = attrString.substring(0, i).intern();\n+                String attrName = attrString.substring(i + 1);\n@@ -1197,2 +1228,2 @@\n-                while (attributeName.startsWith(\" \")) {\n-                    attributeName = attributeName.substring(1);\n+                while (attrName.startsWith(\" \")) {\n+                    attrName = attrName.substring(1);\n@@ -1200,6 +1231,21 @@\n-                attributeName = attributeName.intern();\n-                ServiceKey key = new ServiceKey(type, stdAlg, true);\n-                Service s = legacyMap.get(key);\n-                if (s == null) {\n-                    s = new Service(this, type, stdAlg);\n-                    legacyMap.put(key, s);\n+                attrName = attrName.intern();\n+                ServiceKey stdKey = new ServiceKey(type, stdAlg, true);\n+                Service stdService = legacyMap.get(stdKey);\n+                switch (opType) {\n+                    case ADD:\n+                        Objects.requireNonNull(value,\n+                                \"attribute value should not be null\");\n+\n+                        if (stdService == null) {\n+                            stdService = new Service(this, type, stdAlg);\n+                            legacyMap.put(stdKey, stdService);\n+                        }\n+                        stdService.addAttribute(attrName, value);\n+                        break;\n+                    case REMOVE:\n+                        if (stdService != null) {\n+                            stdService.removeAttribute(attrName, value);\n+                        }\n+                        break;\n+                default:\n+                    throw new AssertionError();\n@@ -1207,1 +1253,0 @@\n-                s.addAttribute(attributeName, attributeValue);\n@@ -1234,1 +1279,0 @@\n-\n@@ -1241,4 +1285,2 @@\n-        Service s = null;\n-        if (!serviceMap.isEmpty()) {\n-            s = serviceMap.get(key);\n-        }\n+\n+        Service s = serviceMap.get(key);\n@@ -1246,5 +1288,3 @@\n-            synchronized (this) {\n-                ensureLegacyParsed();\n-                if (legacyMap != null && !legacyMap.isEmpty()) {\n-                    s = legacyMap.get(key);\n-                }\n+            s = legacyMap.get(key);\n+            if (s != null && !s.isValid()) {\n+                legacyMap.remove(key, s);\n@@ -1283,1 +1323,1 @@\n-    public synchronized Set<Service> getServices() {\n+    public Set<Service> getServices() {\n@@ -1285,5 +1325,1 @@\n-        if (legacyChanged || servicesChanged) {\n-            serviceSet = null;\n-        }\n-        if (serviceSet == null) {\n-            ensureLegacyParsed();\n+        if (serviceSet == null || legacyChanged || servicesChanged) {\n@@ -1294,2 +1330,8 @@\n-            if (legacyMap != null && !legacyMap.isEmpty()) {\n-                set.addAll(legacyMap.values());\n+            if (!legacyMap.isEmpty()) {\n+                legacyMap.entrySet().forEach(entry -> {\n+                    if (!entry.getValue().isValid()) {\n+                        legacyMap.remove(entry.getKey(), entry.getValue());\n+                    } else {\n+                        set.add(entry.getValue());\n+                    }\n+                });\n@@ -1299,0 +1341,1 @@\n+            legacyChanged = false;\n@@ -1355,3 +1398,1 @@\n-            if (type.equals(\"SecureRandom\")) {\n-                updateSecureRandomEntries(true, s.algorithm);\n-            }\n+            checkAndUpdateSecureRandom(type, algorithm, true);\n@@ -1361,6 +1402,11 @@\n-    \/\/ keep tracks of the registered secure random algos and store them in order\n-    private void updateSecureRandomEntries(boolean doAdd, String s) {\n-        Objects.requireNonNull(s);\n-        if (doAdd) {\n-            if (prngAlgos == null) {\n-                prngAlgos = new LinkedHashSet<String>();\n+    private void checkAndUpdateSecureRandom(String type, String algo,\n+            boolean doAdd) {\n+        if (type.equalsIgnoreCase(\"SecureRandom\")) {\n+            if (doAdd) {\n+                prngAlgos.add(algo);\n+            } else {\n+                prngAlgos.remove(algo);\n+            }\n+            if (debug != null) {\n+                debug.println((doAdd? \"Add\":\"Remove\") +\n+                        \" SecureRandom algo \" + algo);\n@@ -1368,7 +1414,0 @@\n-            prngAlgos.add(s);\n-        } else {\n-            prngAlgos.remove(s);\n-        }\n-\n-        if (debug != null) {\n-            debug.println((doAdd? \"Add\":\"Remove\") + \" SecureRandom algo \" + s);\n@@ -1380,1 +1419,1 @@\n-    synchronized Service getDefaultSecureRandomService() {\n+    Service getDefaultSecureRandomService() {\n@@ -1383,6 +1422,2 @@\n-        if (legacyChanged) {\n-            prngAlgos = null;\n-            ensureLegacyParsed();\n-        }\n-\n-        if (prngAlgos != null && !prngAlgos.isEmpty()) {\n+        if (!prngAlgos.isEmpty()) {\n+            String algo = prngAlgos.iterator().next();\n@@ -1392,1 +1427,1 @@\n-            return getService(\"SecureRandom\", prngAlgos.iterator().next());\n+            return getService(\"SecureRandom\", algo);\n@@ -1489,6 +1524,3 @@\n-        synchronized (this) {\n-            removePropertyStrings(s);\n-            if (type.equals(\"SecureRandom\")) {\n-                updateSecureRandomEntries(false, s.algorithm);\n-            }\n-        }\n+\n+        removePropertyStrings(s);\n+        checkAndUpdateSecureRandom(type, algorithm, false);\n@@ -1695,0 +1727,7 @@\n+        private void removeAlias(String alias) {\n+            if (aliases.isEmpty()) {\n+                return;\n+            }\n+            aliases.remove(alias);\n+        }\n+\n@@ -1702,0 +1741,11 @@\n+        void removeAttribute(String type, String value) {\n+            if (attributes.isEmpty()) {\n+                return;\n+            }\n+            if (value == null) {\n+                attributes.remove(new UString(type));\n+            } else {\n+                attributes.remove(new UString(type), value);\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/security\/Provider.java","additions":276,"deletions":226,"binary":false,"changes":502,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 5097015 8130181\n+ * @bug 5097015 8130181 8279222 8292739\n@@ -39,1 +39,2 @@\n-        put(\"ALg.aliaS.MESSAGEdigest.Fu\", \"FoO\");\n+        \/\/ first assign the DEF alias to algorithm Foo\n+        put(\"ALg.aliaS.MESSAGEdigest.DEF\", \"FoO\");\n@@ -42,0 +43,5 @@\n+        \/\/ reassign the DEF alias to algorithm Bar\n+        put(\"ALg.aliaS.MESSAGEdigest.DEF\", \"Bar\");\n+        \/\/ invalid entry since it misses the corresponding impl class info\n+        \/\/ e.g. put(\"MessageDigest.Invalid\", \"implClass\");\n+        put(\"MessageDigest.Invalid xYz\", \"aBc\");\n@@ -46,1 +52,3 @@\n-        System.out.println(p.getServices());\n+\n+        System.out.println(\"Services: \" + p.getServices());\n+\n@@ -50,0 +58,4 @@\n+\n+        if (p.getService(\"MessageDigest\", \"Invalid\") != null) {\n+            throw new Exception(\"Invalid service returned\");\n+        }\n@@ -55,1 +67,9 @@\n-        testService(p, \"MessageDigest\", \"fU\");\n+        if (s.toString().indexOf(\"DEF\") != -1) {\n+            throw new Exception(\"Old alias DEF should be removed\");\n+        }\n+\n+        \/\/ test Service alias DEF and its associated impl is Bar\n+        s = testService(p, \"MessageDigest\", \"DeF\");\n+        if (s.getAttribute(\"Xyz\") != null) {\n+            throw new Exception(\"DEF mapped to the wrong impl\");\n+        }\n@@ -61,1 +81,2 @@\n-    private static Service testService(Provider p, String type, String alg) throws Exception {\n+    private static Service testService(Provider p, String type, String alg)\n+            throws Exception {\n","filename":"test\/jdk\/java\/security\/Provider\/CaseSensitiveServices.java","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"}]}