{"files":[{"patch":"@@ -61,0 +61,1 @@\n+import java.util.stream.Stream;\n@@ -267,1 +268,4 @@\n-     * Typically called on a tester object in main()\n+     * The methods are invoked in the order found using getDeclaredMethods.\n+     * The arguments for the invocation are provided {@link #getTestArgs(Method)}.\n+     *\n+     * Typically called on a tester object in main().\n@@ -269,0 +273,1 @@\n+     * @throws IllegalArgumentException if any test method does not have a recognized signature\n@@ -272,1 +277,1 @@\n-        runTests(m -> new Object[0]);\n+        runTests(this::getTestArgs);\n@@ -277,0 +282,3 @@\n+     * The methods are invoked in the order found using getDeclaredMethods.\n+     * The arguments for the invocation are provided by a given function.\n+     *\n@@ -281,1 +289,1 @@\n-     * @throws Exception if any errors occurred\n+     * @throws Exception if any errors occurred while executing a test method\n@@ -284,1 +292,1 @@\n-        for (Method m: getClass().getDeclaredMethods()) {\n+        for (Method m : getClass().getDeclaredMethods()) {\n@@ -287,7 +295,1 @@\n-                try {\n-                    out.println(\"Running test \" + m.getName());\n-                    m.invoke(this, f.apply(m));\n-                } catch (InvocationTargetException e) {\n-                    Throwable cause = e.getCause();\n-                    throw (cause instanceof Exception) ? ((Exception) cause) : e;\n-                }\n+                runTest(m, f);\n@@ -300,0 +302,89 @@\n+    \/**\n+     * Run the specified methods annotated with @Test, or all methods annotated\n+     * with @Test if none are specified, followed by printSummary.\n+     * The methods are invoked in the order given in the methodNames argument,\n+     * or the order returned by getDeclaredMethods if no names are provided.\n+     * The arguments for the invocation are provided {@link #getTestArgs(Method)}.\n+     *\n+     * Typically called on a tester object in main(String[] args), perhaps using\n+     * args as the list of method names.\n+     *\n+     * @throws IllegalStateException if any methods annotated with @Test are overloaded\n+     * @throws IllegalArgumentException if any of the method names does not name a suitable method\n+     * @throws NullPointerException if {@code methodNames} is {@code null}, or if any of the names are {@code null}\n+     * @throws Exception if any errors occurred while executing a test method\n+     *\/\n+    public void runTests(String... methodNames) throws Exception {\n+        runTests(this::getTestArgs, methodNames);\n+    }\n+\n+    \/**\n+     * Run the specified methods annotated with @Test, or all methods annotated\n+     * with @Test if non are specified, followed by printSummary.\n+     * The methods are invoked in the order given in the methodNames argument,\n+     * or the order returned by getDeclaredMethods if no names are provided.\n+     * The arguments for the invocation are provided {@link #getTestArgs(Method)}.\n+     *\n+     * Typically called on a tester object in main(String[] args), perhaps using\n+     * args as the list of method names.\n+     *\n+     * @throws IllegalStateException if any methods annotated with @Test are overloaded\n+     * @throws IllegalArgumentException if any of the method names does not name a suitable method\n+     * @throws NullPointerException if {@code methodNames} is {@code null}, or if any of the names are {@code null}\n+     * @throws Exception if any errors occurred while executing a test method\n+     *\/\n+    public void runTests(Function<Method, Object[]> f, String... methodNames) throws Exception {\n+        if (methodNames.length == 0) {\n+            runTests(f);\n+        } else {\n+            Map<String, Method> testMethods = Stream.of(getClass().getDeclaredMethods())\n+                    .filter(this::isTestMethod)\n+                    .collect(Collectors.toMap(Method::getName, Function.identity(),\n+                            (o, n) -> {\n+                                throw new IllegalStateException(\"test method \" + o.getName() + \" is overloaded\");\n+                            }));\n+\n+            List<Method> list = new ArrayList<>();\n+            for (String mn : methodNames) {\n+                Method m = testMethods.get(mn);\n+                if (m == null) {\n+                    throw new IllegalArgumentException(\"test method \" + mn + \" not found\");\n+                }\n+                list.add(m);\n+            }\n+\n+            for (Method m : list) {\n+                runTest(m, f);\n+            }\n+        }\n+    }\n+\n+    protected boolean isTestMethod(Method m) {\n+        return m.getAnnotation(Test.class) != null;\n+    }\n+\n+    protected Object[] getTestArgs(Method m) throws IllegalArgumentException {\n+        Class<?>[] paramTypes = m.getParameterTypes();\n+        if (paramTypes.length == 0) {\n+            return new Object[] {};\n+        } else if (paramTypes.length == 1 && paramTypes[0] == Path.class) {\n+            return new Object[] { Path.of(m.getName())};\n+        } else {\n+            throw new IllegalArgumentException(\"unknown signature for method \"\n+                    + m + Stream.of(paramTypes)\n+                    .map(Class::toString)\n+                    .collect(Collectors.joining(\", \", \"(\", \")\")))  ;\n+        }\n+    }\n+\n+    protected void runTest(Method m, Function<Method, Object[]> f) throws Exception {\n+        try {\n+            out.println(\"Running test \" + m.getName());\n+            m.invoke(this, f.apply(m));\n+        } catch (InvocationTargetException e) {\n+            Throwable cause = e.getCause();\n+            throw (cause instanceof Exception) ? ((Exception) cause) : e;\n+        }\n+\n+    }\n+\n@@ -1473,1 +1564,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/javadoc\/tester\/JavadocTester.java","additions":103,"deletions":12,"binary":false,"changes":115,"status":"modified"}]}