{"files":[{"patch":"","filename":"make\/data\/charsetmapping\/MS950_HKSCS.map","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/charsetmapping\/HKSCS2008.map","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,5 +23,4 @@\n-\n-\n-\/*\n-  Check the consistency between the regression tests and the currency\n-  data in the JRE. This class is used by other test classes.\n+\/**\n+ *\n+ *\n+ * Check the consistency between the regression tests and the currency data in the JRE\n@@ -30,8 +29,3 @@\n-import java.io.BufferedReader;\n-import java.io.DataInputStream;\n-import java.io.File;\n-import java.io.FileReader;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n+import java.io.*;\n+import java.lang.reflect.*;\n+import java.security.*;\n","filename":"test\/jdk\/java\/util\/Currency\/CheckDataVersion.java","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,0 @@\n-\n@@ -32,1 +31,0 @@\n- * @run junit CurrencyTest\n@@ -43,1 +41,0 @@\n-+import java.util.ArrayList;\n@@ -45,12 +42,1 @@\n-+import java.util.List;\n-import java.util.Locale;;\n-+\n-+import org.junit.jupiter.api.Disabled;\n-+import org.junit.jupiter.api.Nested;\n-+import org.junit.jupiter.api.Test;\n-+import org.junit.jupiter.params.ParameterizedTest;\n-+import org.junit.jupiter.params.provider.Arguments;\n-+import org.junit.jupiter.params.provider.MethodSource;\n-+\n-+import static org.junit.jupiter.api.Assertions.assertEquals;\n-+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import java.util.Locale;\n@@ -61,3 +47,1 @@\n-+    \/\/ 'tablea1.txt' should be up-to-date before testing\n-+    @Test\n-+    public void dataVersionTest() {\n+    public static void main(String[] args) throws Exception {\n@@ -65,0 +49,7 @@\n+        testCurrencyCodeValidation();\n+        testLocaleMapping();\n+        testSymbols();\n+        testFractionDigits();\n+        testSerialization();\n+        testDisplayNames();\n+        testFundsCodes();\n@@ -67,8 +58,14 @@\n-+    @Nested\n-+    class CodeValidationTests {\n-+        \/\/ Calling getInstance() on equal currency codes should return equal currencies\n-+        @ParameterizedTest\n-+        @MethodSource(\"validCurrencies\")\n-+        public void validCurrencyTest(String currencyCode) {\n-+            compareCurrencies(currencyCode);\n-+        }\n+    static void testCurrencyCodeValidation() {\n+        \/\/ test creation of some valid currencies\n+        testValidCurrency(\"USD\");\n+        testValidCurrency(\"EUR\");\n+        testValidCurrency(\"GBP\");\n+        testValidCurrency(\"JPY\");\n+        testValidCurrency(\"CNY\");\n+        testValidCurrency(\"CHF\");\n+\n+        \/\/ test creation of some fictitious currencies\n+        testInvalidCurrency(\"AQD\");\n+        testInvalidCurrency(\"US$\");\n+        testInvalidCurrency(\"\\u20AC\");\n+    }\n@@ -76,10 +73,5 @@\n-+        private static Stream<String> validCurrencies() {\n-+            return Stream.of(\"USD\", \"EUR\", \"GBP\", \"JPY\", \"CNY\", \"CHF\");\n-+        }\n-+\n-+        \/\/ Calling getInstance() with an invalid currency code should throw an IAE\n-+        @ParameterizedTest\n-+        @MethodSource(\"invalidCurrencies\")\n-+        public void invalidCurrencyTest(String currencyCode) {\n-+            assertThrows(IllegalArgumentException.class, () ->\n-+                    Currency.getInstance(currencyCode), \"getInstance() did not throw IAE\");\n+    static void testValidCurrency(String currencyCode) {\n+        Currency currency1 = Currency.getInstance(currencyCode);\n+        Currency currency2 = Currency.getInstance(currencyCode);\n+        if (currency1 != currency2) {\n+            throw new RuntimeException(\"Didn't get same instance for same currency code\");\n@@ -87,3 +79,2 @@\n-+\n-+        private static Stream<String> invalidCurrencies() {\n-+            return Stream.of(\"AQD\", \"US$\", \"\\u20AC\");\n+        if (!currency1.getCurrencyCode().equals(currencyCode)) {\n+            throw new RuntimeException(\"Currency code changed\");\n@@ -93,8 +84,6 @@\n-\n-+    @Nested\n-+    class FundsCodesTests {\n-+        \/\/ Calling getInstance() on equal currency codes should return equal currencies\n-+        @ParameterizedTest\n-+        @MethodSource(\"fundsCodes\")\n-+        public void validCurrencyTest(String currencyCode) {\n-+            compareCurrencies(currencyCode);\n+    static void testInvalidCurrency(String currencyCode) {\n+        boolean gotException = false;\n+        try {\n+            Currency currency = Currency.getInstance(currencyCode);\n+        } catch (IllegalArgumentException e) {\n+            gotException = true;\n@@ -102,25 +91,2 @@\n-+\n-+        \/\/ Verify a currency has the expected fractional digits\n-+        @ParameterizedTest\n-+        @MethodSource(\"fundsCodes\")\n-+        public void fractionDigitTest(String currencyCode, int expectedFractionDigits) {\n-+            compareFractionDigits(currencyCode, expectedFractionDigits);\n-+        }\n-+\n-+        \/\/ Verify a currency has the expected numeric code\n-+        @ParameterizedTest\n-+        @MethodSource(\"fundsCodes\")\n-+        public void numericCodeTest(String currencyCode, int ignored, int expectedNumeric) {\n-+            int numeric = Currency.getInstance(currencyCode).getNumericCode();\n-+            assertEquals(numeric, expectedNumeric, String.format(\n-+                    \"Wrong numeric code for currency %s, expected %s, got %s\",\n-+                    currencyCode, expectedNumeric, numeric));\n-+        }\n-+\n-+        private static Stream<Arguments> fundsCodes() {\n-+            return Stream.of(\n-+                    Arguments.of(\"BOV\", 2, 984), Arguments.of(\"CHE\", 2, 947),\n-+                    Arguments.of(\"CHW\", 2, 948), Arguments.of(\"CLF\", 4, 990),\n-+                    Arguments.of(\"COU\", 2, 970), Arguments.of(\"MXV\", 2, 979),\n-+                    Arguments.of(\"USN\", 2, 997), Arguments.of(\"UYI\", 0, 940)\n-+            );\n+        if (!gotException) {\n+            throw new RuntimeException(\"didn't get specified exception\");\n@@ -130,3 +96,1 @@\n-+    @Nested\n-+    class LocaleMappingTests {\n-+\n+    static void testLocaleMapping() {\n@@ -135,19 +99,25 @@\n-+        @Test\n-+        public void localeMappingTest() {\n-+            Locale[] locales = Locale.getAvailableLocales();\n-+            int goodCountries = 0;\n-+            int ownCurrencies = 0;\n-+            for (Locale locale : locales) {\n-+                String ctryCode = locale.getCountry();\n-+                int ctryLength = ctryCode.length();\n-+                if (ctryLength == 0 ||\n-+                        ctryLength == 3 || \/\/ UN M.49 code\n-+                        ctryCode.matches(\"AA|Q[M-Z]|X[A-JL-Z]|ZZ\" + \/\/ user defined codes, excluding \"XK\" (Kosovo)\n-+                                \"AC|CP|DG|EA|EU|FX|IC|SU|TA|UK\")) { \/\/ exceptional reservation codes\n-+                    assertThrows(IllegalArgumentException.class, () -> Currency.getInstance(locale), \"Did not throw IAE\");\n-+                } else {\n-+                    goodCountries++;\n-+                    Currency currency = Currency.getInstance(locale);\n-+                    if (currency.getCurrencyCode().indexOf(locale.getCountry()) == 0) {\n-+                        ownCurrencies++;\n-+                    }\n+        Locale[] locales = Locale.getAvailableLocales();\n+        int goodCountries = 0;\n+        int ownCurrencies = 0;\n+        for (int i = 0; i < locales.length; i++) {\n+            Locale locale = locales[i];\n+            String ctryCode = locale.getCountry();\n+            int ctryLength = ctryCode.length();\n+            if (ctryLength == 0 ||\n+                ctryLength == 3 || \/\/ UN M.49 code\n+                ctryCode.matches(\"AA|Q[M-Z]|X[A-JL-Z]|ZZ\" + \/\/ user defined codes, excluding \"XK\" (Kosovo)\n+                                 \"AC|CP|DG|EA|EU|FX|IC|SU|TA|UK\")) { \/\/ exceptional reservation codes\n+                boolean gotException = false;\n+                try {\n+                    Currency.getInstance(locale);\n+                } catch (IllegalArgumentException e) {\n+                    gotException = true;\n+                }\n+                if (!gotException) {\n+                    throw new RuntimeException(\"didn't get specified exception\");\n+                }\n+            } else {\n+                goodCountries++;\n+                Currency currency = Currency.getInstance(locale);\n+                if (currency.getCurrencyCode().indexOf(locale.getCountry()) == 0) {\n+                    ownCurrencies++;\n@@ -156,5 +126,0 @@\n-+            System.out.println(\"Countries tested: \" + goodCountries +\n-+                    \", own currencies: \" + ownCurrencies);\n-+            if (ownCurrencies < (goodCountries \/ 2 + 1)) {\n-+                throw new RuntimeException(\"suspicious: not enough countries have their own currency.\");\n-+            }\n@@ -162,6 +127,4 @@\n-+\n-+        \/\/ Check an invalid country code\n-+        @Test\n-+        public void invalidCountryTest() {\n-+            assertThrows(IllegalArgumentException.class, ()->\n-+                    Currency.getInstance(Locale.of(\"\", \"EU\")), \"Did not throw IAE\");\n+        System.out.println(\"Countries tested: \" + goodCountries +\n+                \", own currencies: \" + ownCurrencies);\n+        if (ownCurrencies < (goodCountries \/ 2 + 1)) {\n+            throw new RuntimeException(\"suspicious: not enough countries have their own currency.\");\n@@ -169,9 +132,6 @@\n-+        \/\/ Ensure a selection of countries have the expected currency\n-+        @ParameterizedTest\n-+        @MethodSource({\"countryProvider\", \"switchedOverCountries\"})\n-+        public void countryCurrencyTest(String countryCode, String expected) {\n-+            Locale locale = Locale.of(\"\", countryCode);\n-+            Currency currency = Currency.getInstance(locale);\n-+            String code = (currency != null) ? currency.getCurrencyCode() : null;\n-+            assertEquals(expected, code, generateErrMsg(\n-+                    \"currency for\", locale.getDisplayCountry(), expected, code));\n+\n+        \/\/ check a few countries that don't change their currencies too often\n+        String[] country1 = {\"US\", \"CA\", \"JP\", \"CN\", \"SG\", \"CH\"};\n+        String[] currency1 = {\"USD\", \"CAD\", \"JPY\", \"CNY\", \"SGD\", \"CHF\"};\n+        for (int i = 0; i < country1.length; i++) {\n+            checkCountryCurrency(country1[i], currency1[i]);\n","filename":"test\/jdk\/java\/util\/Currency\/CurrencyTest.java","additions":75,"deletions":115,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,0 @@\n-\n","filename":"test\/jdk\/java\/util\/Currency\/ValidateISO4217.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}