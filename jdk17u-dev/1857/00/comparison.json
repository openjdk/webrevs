{"files":[{"patch":"@@ -492,1 +492,3 @@\n-  ld(ch2, Address(result)); \/\/ load 8 bytes from source string\n+  \/\/ load 8 bytes from source string\n+  \/\/ if isLL is false then read granularity can be 2\n+  load_long_misaligned(ch2, Address(result), ch1, isLL ? 1 : 2); \/\/ can use ch1 as temp register here as it will be trashed by next mv anyway\n@@ -675,0 +677,13 @@\n+    if (AvoidUnalignedAccesses) {\n+      \/\/ preload first value, then we will read by 1 character per loop, instead of four\n+      \/\/ just shifting previous ch2 right by size of character in bits\n+      add(tmp3, haystack, hlen_neg);\n+      (this->*load_4chr)(ch2, Address(tmp3), noreg);\n+      if (isLL) {\n+        \/\/ need to erase 1 most significant byte in 32-bit value of ch2\n+        slli(ch2, ch2, 40);\n+        srli(ch2, ch2, 32);\n+      } else {\n+        slli(ch2, ch2, 16); \/\/ 2 most significant bytes will be erased by this operation\n+      }\n+    }\n@@ -677,2 +692,9 @@\n-    add(ch2, haystack, hlen_neg);\n-    (this->*load_4chr)(ch2, Address(ch2), noreg);\n+    add(tmp3, haystack, hlen_neg);\n+    if (AvoidUnalignedAccesses) {\n+      srli(ch2, ch2, isLL ? 8 : 16);\n+      (this->*haystack_load_1chr)(tmp3, Address(tmp3, isLL ? 3 : 6), noreg);\n+      slli(tmp3, tmp3, isLL ? 24 : 48);\n+      add(ch2, ch2, tmp3);\n+    } else {\n+      (this->*load_4chr)(ch2, Address(tmp3), noreg);\n+    }\n@@ -696,1 +718,7 @@\n-\n+    if (AvoidUnalignedAccesses) {\n+      \/\/ preload first value, then we will read by 1 character per loop, instead of two\n+      \/\/ just shifting previous ch2 right by size of character in bits\n+      add(tmp3, haystack, hlen_neg);\n+      (this->*haystack_load_1chr)(ch2, Address(tmp3), noreg);\n+      slli(ch2, ch2, isLL ? 8 : 16);\n+    }\n@@ -699,1 +727,8 @@\n-    (this->*load_2chr)(ch2, Address(tmp3), noreg);\n+    if (AvoidUnalignedAccesses) {\n+      srli(ch2, ch2, isLL ? 8 : 16);\n+      (this->*haystack_load_1chr)(tmp3, Address(tmp3, isLL ? 1 : 2), noreg);\n+      slli(tmp3, tmp3, isLL ? 8 : 16);\n+      add(ch2, ch2, tmp3);\n+    } else {\n+      (this->*load_2chr)(ch2, Address(tmp3), noreg);\n+    }\n@@ -723,1 +758,8 @@\n-    (this->*load_2chr)(ch2, Address(ch2), noreg);\n+    if (AvoidUnalignedAccesses) {\n+      (this->*haystack_load_1chr)(tmp2, Address(ch2, isLL ? 1 : 2), noreg); \/\/ we need a temp register, we can safely use hlen_tmp here, which is a synonym for tmp2\n+      (this->*haystack_load_1chr)(ch2, Address(ch2), noreg);\n+      slli(tmp2, tmp2, isLL ? 8 : 16);\n+      add(ch2, ch2, tmp2);\n+    } else {\n+      (this->*load_2chr)(ch2, Address(ch2), noreg);\n+    }\n@@ -747,4 +789,1 @@\n-    mv(tmp3, result_tmp);\n-    if (haystack_chr_shift) {\n-      slli(tmp3, result_tmp, haystack_chr_shift);\n-    }\n+    slli(tmp3, result_tmp, haystack_chr_shift);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":49,"deletions":10,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -1619,1 +1619,18 @@\n-\/\/ granularity is 1, 2 bytes per load\n+\/\/ granularity is 1 OR 2 bytes per load. dst and src.base() allowed to be the same register\n+void MacroAssembler::load_short_misaligned(Register dst, Address src, Register tmp, bool is_signed, int granularity) {\n+  if (granularity != 1 && granularity != 2) {\n+    ShouldNotReachHere();\n+  }\n+  if (AvoidUnalignedAccesses && (granularity != 2)) {\n+    assert_different_registers(dst, tmp);\n+    assert_different_registers(tmp, src.base());\n+    is_signed ? lb(tmp, Address(src.base(), src.offset() + 1)) : lbu(tmp, Address(src.base(), src.offset() + 1));\n+    slli(tmp, tmp, 8);\n+    lbu(dst, src);\n+    add(dst, dst, tmp);\n+  } else {\n+    is_signed ? lh(dst, src) : lhu(dst, src);\n+  }\n+}\n+\n+\/\/ granularity is 1, 2 OR 4 bytes per load, if granularity 2 or 4 then dst and src.base() allowed to be the same register\n@@ -1622,1 +1639,0 @@\n-    assert_different_registers(dst, tmp, src.base());\n@@ -1625,0 +1641,1 @@\n+        assert_different_registers(dst, tmp, src.base());\n@@ -1637,1 +1654,2 @@\n-        lhu(dst, src);\n+        assert_different_registers(dst, tmp);\n+        assert_different_registers(tmp, src.base());\n@@ -1640,0 +1658,1 @@\n+        lhu(dst, src);\n@@ -1650,1 +1669,1 @@\n-\/\/ granularity is 1, 2 or 4 bytes per load\n+\/\/ granularity is 1, 2, 4 or 8 bytes per load, if granularity 4 or 8 then dst and src.base() allowed to be same register\n@@ -1653,1 +1672,0 @@\n-    assert_different_registers(dst, tmp, src.base());\n@@ -1656,0 +1674,1 @@\n+        assert_different_registers(dst, tmp, src.base());\n@@ -1680,0 +1699,1 @@\n+        assert_different_registers(dst, tmp, src.base());\n@@ -1692,1 +1712,2 @@\n-        lwu(dst, src);\n+        assert_different_registers(dst, tmp);\n+        assert_different_registers(tmp, src.base());\n@@ -1695,0 +1716,1 @@\n+        lwu(dst, src);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -411,0 +411,1 @@\n+  void load_short_misaligned(Register dst, Address src, Register tmp, bool is_signed, int granularity = 1);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}