{"files":[{"patch":"@@ -136,1 +136,1 @@\n-    entry_frame_after_call_words                     =  34,\n+    entry_frame_after_call_words                     =  35,\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,2 +130,3 @@\n-  \/\/ -34 [ argument word 1      ]\n-  \/\/ -33 [ saved f27            ] <--- sp_after_call\n+  \/\/ -35 [ argument word 1      ]\n+  \/\/ -34 [ saved FRM in Floating-point Control and Status Register ] <--- sp_after_call\n+  \/\/ -33 [ saved f27            ]\n@@ -168,1 +169,1 @@\n-    sp_after_call_off  = -33,\n+    sp_after_call_off  = -34,\n@@ -170,0 +171,1 @@\n+    frm_off            = sp_after_call_off,\n@@ -217,0 +219,1 @@\n+    const Address frm_save      (fp, frm_off            * wordSize);\n@@ -299,0 +302,10 @@\n+    __ frrm(t0);\n+    __ sd(t0, frm_save);\n+    \/\/ Set frm to the state we need. We do want Round to Nearest. We\n+    \/\/ don't want non-IEEE rounding modes.\n+    Label skip_fsrmi;\n+    guarantee(__ RoundingMode::rne == 0, \"must be\");\n+    __ beqz(t0, skip_fsrmi);\n+    __ fsrmi(__ RoundingMode::rne);\n+    __ bind(skip_fsrmi);\n+\n@@ -416,0 +429,8 @@\n+    \/\/ restore frm\n+    Label skip_fsrm;\n+    __ ld(t0, frm_save);\n+    __ frrm(t1);\n+    __ beq(t0, t1, skip_fsrm);\n+    __ fsrm(t0);\n+    __ bind(skip_fsrm);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"}]}