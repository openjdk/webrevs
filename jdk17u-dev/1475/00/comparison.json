{"files":[{"patch":"@@ -656,1 +656,6 @@\n-    nm->print_nmethod(verbose);\n+    if (verbose && st == tty) {\n+      \/\/ verbose is only ever true when called from findpc in debug.cpp\n+      nm->print_nmethod(true);\n+    } else {\n+      nm->print(st);\n+    }\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"utilities\/vmError.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLimit.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1382,0 +1382,4 @@\n+  product(int, ErrorLogPrintCodeLimit, 3, DIAGNOSTIC,                       \\\n+          \"max number of compiled code units to print in error log\")        \\\n+          range(0, VMError::max_error_log_print_code)                       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -247,1 +247,2 @@\n- * is the index of the first nullptr entry.\n+ * is the index of the first nullptr entry or `list_capacity` if there are\n+ * no nullptr entries.\n@@ -912,17 +913,37 @@\n-       if (!_print_native_stack_used) {\n-         \/\/ Only try print code of the crashing frame since\n-         \/\/ we cannot walk the native stack using next_frame.\n-         const int printed_capacity = 1;\n-         address printed_singleton = nullptr;\n-         address* printed = &printed_singleton;\n-         print_code(st, _thread, _pc, true, printed, 1);\n-       } else {\n-         \/\/ Print up to the first 5 unique code units on the stack\n-         const int printed_capacity = 5;\n-         address printed[printed_capacity];\n-         printed[0] = nullptr; \/\/ length(list) == index of first nullptr\n-\n-         frame fr = os::fetch_frame_from_context(_context);\n-         for (int count = 0; count < printed_capacity && fr.pc() != nullptr; ) {\n-           if (print_code(st, _thread, fr.pc(), fr.pc() == _pc, printed, printed_capacity)) {\n-             count++;\n+       const int printed_capacity = max_error_log_print_code;\n+       address printed[printed_capacity];\n+       printed[0] = nullptr;\n+       int printed_len = 0;\n+       \/\/ Even though ErrorLogPrintCodeLimit is ranged checked\n+       \/\/ during argument parsing, there's no way to prevent it\n+       \/\/ subsequently (i.e., after parsing) being set to a\n+       \/\/ value outside the range.\n+       int limit = MIN2(ErrorLogPrintCodeLimit, printed_capacity);\n+       if (limit > 0) {\n+         \/\/ Scan the native stack\n+         if (!_print_native_stack_used) {\n+           \/\/ Only try to print code of the crashing frame since\n+           \/\/ the native stack cannot be walked with next_frame.\n+           if (print_code(st, _thread, _pc, true, printed, printed_capacity)) {\n+             printed_len++;\n+           }\n+         } else {\n+           frame fr = os::fetch_frame_from_context(_context);\n+           while (printed_len < limit && fr.pc() != nullptr) {\n+             if (print_code(st, _thread, fr.pc(), fr.pc() == _pc, printed, printed_capacity)) {\n+               printed_len++;\n+             }\n+             fr = next_frame(fr, _thread);\n+           }\n+         }\n+\n+         \/\/ Scan the Java stack\n+         if (_thread != nullptr && _thread->is_Java_thread()) {\n+           JavaThread* jt = _thread->as_Java_thread();\n+           if (jt->has_last_Java_frame()) {\n+             for (StackFrameStream sfs(jt, true \/* update *\/, true \/* process_frames *\/); printed_len < limit && !sfs.is_done(); sfs.next()) {\n+               address pc = sfs.current()->pc();\n+               if (print_code(st, _thread, pc, pc == _pc, printed, printed_capacity)) {\n+                 printed_len++;\n+               }\n+             }\n@@ -930,1 +951,0 @@\n-           fr = next_frame(fr, _thread);\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":39,"deletions":19,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -188,0 +188,3 @@\n+  \/\/ Max value for the ErrorLogPrintCodeLimit flag.\n+  static const int max_error_log_print_code = 10;\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n@@ -40,1 +42,0 @@\n-import java.util.List;\n@@ -42,1 +43,3 @@\n-import java.util.stream.Stream;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n@@ -44,0 +47,1 @@\n+import java.util.stream.Stream;\n@@ -54,0 +58,1 @@\n+\n@@ -55,2 +60,2 @@\n-        \/\/ Need to make unsafe a compile-time constant so that\n-        \/\/ C2 intrinsifies the call to Unsafe.getLong in method3.\n+        \/\/ Make Crasher.unsafe a compile-time constant so that\n+        \/\/ C2 intrinsifies calls to Unsafe intrinsics.\n@@ -58,2 +63,13 @@\n-        public static void main(String[] args) {\n-            method1(10);\n+\n+        public static void main(String[] args) throws Exception {\n+            if (args[0].equals(\"crashInJava\")) {\n+                \/\/ This test relies on Unsafe.putLong(Object, long, long) being intrinsified\n+                if (!Stream.of(Unsafe.class.getDeclaredMethod(\"putLong\", Object.class, long.class, long.class).getAnnotations()).\n+                    anyMatch(a -> a.annotationType().getName().equals(\"jdk.internal.vm.annotation.IntrinsicCandidate\"))) {\n+                    throw new RuntimeException(\"Unsafe.putLong(Object, long, long) is not an intrinsic\");\n+                }\n+                crashInJava1(10);\n+            } else {\n+                assert args[0].equals(\"crashInVM\");\n+                crashInNative1(10);\n+            }\n@@ -62,3 +78,3 @@\n-        static void method1(long address) {\n-            System.out.println(\"in method1\");\n-            method2(address);\n+        static void crashInJava1(long address) {\n+            System.out.println(\"in crashInJava1\");\n+            crashInJava2(address);\n@@ -66,3 +82,3 @@\n-        static void method2(long address) {\n-            System.out.println(\"in method2\");\n-            method3(address);\n+        static void crashInJava2(long address) {\n+            System.out.println(\"in crashInJava2\");\n+            crashInJava3(address);\n@@ -70,6 +86,12 @@\n-        static void method3(long address) {\n-            System.out.println(\"in method3\");\n-            \/\/ Keep chasing pointers until we crash\n-            while (true) {\n-                address = unsafe.getLong(address);\n-            }\n+        static void crashInJava3(long address) {\n+            unsafe.putLong(null, address, 42);\n+            System.out.println(\"wrote value to 0x\" + Long.toHexString(address));\n+        }\n+\n+        static void crashInNative1(long address) {\n+            System.out.println(\"in crashInNative1\");\n+            crashInNative2(address);\n+        }\n+        static void crashInNative2(long address) {\n+            System.out.println(\"in crashInNative2\");\n+            crashInNative3(address);\n@@ -77,0 +99,8 @@\n+        static void crashInNative3(long address) {\n+            System.out.println(\"read value \" + unsafe.getLong(address) + \" from 0x\" + Long.toHexString(address));\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        run(true);\n+        run(false);\n@@ -80,1 +110,1 @@\n-     * Runs Crasher and tries to force compile the methods in Crasher. The inner\n+     * Runs Crasher in Xcomp mode. The inner\n@@ -84,1 +114,1 @@\n-    public static void main(String[] args) throws Exception {\n+    private static void run(boolean crashInJava) throws Exception {\n@@ -89,4 +119,6 @@\n-            \"-XX:-TieredCompilation\", \/\/ ensure C2 compiles Crasher.method3\n-            \"-XX:CompileCommand=compileonly,MachCodeFramesInErrorFile$Crasher.m*\",\n-            \"-XX:CompileCommand=dontinline,MachCodeFramesInErrorFile$Crasher.m*\",\n-            Crasher.class.getName());\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:CompileCommand=compileonly,MachCodeFramesInErrorFile$Crasher.crashIn*\",\n+            \"-XX:CompileCommand=dontinline,MachCodeFramesInErrorFile$Crasher.crashIn*\",\n+            \"-XX:CompileCommand=dontinline,*\/Unsafe.getLong\", \/\/ ensures VM call when crashInJava == false\n+            Crasher.class.getName(),\n+            crashInJava ? \"crashInJava\" : \"crashInVM\");\n@@ -107,2 +139,9 @@\n-        if (!crashedInCrasherMethod(hsErr)) {\n-            return;\n+        if (System.getenv(\"DEBUG\") != null) {\n+            System.err.println(hsErr);\n+        }\n+        Set<String> frames = new HashSet<>();\n+        extractFrames(hsErr, frames, true);\n+        if (!crashInJava) {\n+            \/\/ A crash in native will have Java frames in the hs-err log\n+            \/\/ as there is a Java frame anchor on the stack.\n+            extractFrames(hsErr, frames, false);\n@@ -110,2 +149,1 @@\n-        List<String> nativeFrames = extractNativeFrames(hsErr);\n-        int compiledJavaFrames = (int) nativeFrames.stream().filter(f -> f.startsWith(\"J \")).count();\n+        int compiledJavaFrames = (int) frames.stream().filter(f -> f.startsWith(\"J \")).count();\n@@ -121,3 +159,0 @@\n-        String message = \"Mach code headers: \" + machCodeHeaders +\n-                         \"\\n\\nExtracted MachCode:\\n\" + extractMachCode(hsErr) +\n-                         \"\\n\\nExtracted native frames:\\n\" + String.join(\"\\n\", nativeFrames);\n@@ -125,21 +160,2 @@\n-        Asserts.assertTrue(machCodeHeaders.size() >= minExpectedMachCodeSections, message);\n-    }\n-\n-    \/**\n-     * Checks whether the crashing frame is in {@code Crasher.method3}.\n-     *\/\n-    private static boolean crashedInCrasherMethod(String hsErr) {\n-        boolean checkProblematicFrame = false;\n-        for (String line : hsErr.split(System.lineSeparator())) {\n-            if (line.startsWith(\"# Problematic frame:\")) {\n-                checkProblematicFrame = true;\n-            } else if (checkProblematicFrame) {\n-                String crasherMethod = Crasher.class.getSimpleName() + \".method3\";\n-                if (!line.contains(crasherMethod)) {\n-                    \/\/ There's any number of things that can subvert the attempt\n-                    \/\/ to crash in the expected method.\n-                    System.out.println(\"Crashed in method other than \" + crasherMethod + \"\\n\\n\" + line + \"\\n\\nSkipping rest of test.\");\n-                    return false;\n-                }\n-                return true;\n-            }\n+        if (machCodeHeaders.size() < minExpectedMachCodeSections) {\n+            Asserts.fail(machCodeHeaders.size() + \" < \" + minExpectedMachCodeSections);\n@@ -147,1 +163,0 @@\n-        throw new RuntimeException(\"\\\"# Problematic frame:\\\" line missing in hs_err_pid file:\\n\" + hsErr);\n@@ -151,1 +166,3 @@\n-     * Gets the lines in {@code hsErr} below the line starting with \"Native frames:\" up to the next blank line.\n+     * Extracts the lines in {@code hsErr} below the line starting with\n+     * \"Native frames:\" or \"Java frames:\" up to the next blank line\n+     * and adds them to {@code frames}.\n@@ -153,3 +170,3 @@\n-    private static List<String> extractNativeFrames(String hsErr) {\n-        List<String> res = new ArrayList<>();\n-        boolean inNativeFrames = false;\n+    private static void extractFrames(String hsErr, Set<String> frames, boolean nativeStack) {\n+        String marker = (nativeStack ? \"Native\" : \"Java\") + \" frames: \";\n+        boolean seenMarker = false;\n@@ -157,3 +174,3 @@\n-            if (line.startsWith(\"Native frames: \")) {\n-                inNativeFrames = true;\n-            } else if (inNativeFrames) {\n+            if (line.startsWith(marker)) {\n+                seenMarker = true;\n+            } else if (seenMarker) {\n@@ -161,1 +178,1 @@\n-                    return res;\n+                    return;\n@@ -163,12 +180,1 @@\n-                res.add(line);\n-            }\n-        }\n-        throw new RuntimeException(\"\\\"Native frames:\\\" line missing in hs_err_pid file:\\n\" + hsErr);\n-    }\n-\n-    private static String extractMachCode(String hsErr) {\n-        int start = hsErr.indexOf(\"[MachCode]\");\n-        if (start != -1) {\n-            int end = hsErr.lastIndexOf(\"[\/MachCode]\");\n-            if (end != -1) {\n-                return hsErr.substring(start, end + \"[\/MachCode]\".length());\n+                frames.add(line);\n@@ -176,1 +182,0 @@\n-            return hsErr.substring(start);\n@@ -178,1 +183,1 @@\n-        return null;\n+        throw new RuntimeException(\"\\\"\" + marker + \"\\\" line missing in hs_err_pid file:\\n\" + hsErr);\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/MachCodeFramesInErrorFile.java","additions":80,"deletions":75,"binary":false,"changes":155,"status":"modified"}]}