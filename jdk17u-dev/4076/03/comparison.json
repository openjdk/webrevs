{"files":[{"patch":"@@ -73,0 +73,3 @@\n+    \/\/ set to true if shut down before close should be enabled on Windows\n+    private static final boolean SHUTDOWN_WRITE_BEFORE_CLOSE;\n+\n@@ -109,0 +112,7 @@\n+    \/**\n+     * Tells whether a TCP connection should be shutdown for writing before closing.\n+     *\/\n+    static boolean shouldShutdownWriteBeforeClose() {\n+        return SHUTDOWN_WRITE_BEFORE_CLOSE;\n+    }\n+\n@@ -509,0 +519,2 @@\n+    private static native boolean shouldShutdownWriteBeforeClose0();\n+\n@@ -835,0 +847,1 @@\n+        SHUTDOWN_WRITE_BEFORE_CLOSE = shouldShutdownWriteBeforeClose0();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Net.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -746,1 +746,1 @@\n-     * @param isa the remote address\n+     * @param sa the remote socket address\n@@ -973,2 +973,2 @@\n-     * Closes the socket if there are no I\/O operations in progress and the\n-     * channel is not registered with a Selector.\n+     * Closes the socket if there are no I\/O operations in progress (or no I\/O\n+     * operations tracked), and the channel is not registered with a Selector.\n@@ -999,1 +999,3 @@\n-     * Closes this channel when configured in blocking mode.\n+     * Closes this channel when configured in blocking mode. If there are no I\/O\n+     * operations in progress (or tracked), then the channel's socket is closed. If\n+     * there are I\/O operations in progress then the behavior is platform specific.\n@@ -1001,3 +1003,6 @@\n-     * If there is an I\/O operation in progress then the socket is pre-closed\n-     * and the I\/O threads signalled, in which case the final close is deferred\n-     * until all I\/O operations complete.\n+     * On Unix systems, the channel's socket is pre-closed. The socket is dup'ed\n+     * and the threads signalled. The final close is deferred until all I\/O\n+     * operations complete.\n+     *\n+     * On Windows, the channel's socket is pre-closed. The channel's\n+     * socket is closed.\n@@ -1012,0 +1017,1 @@\n+            boolean connected = (state == ST_CONNECTED);\n@@ -1013,0 +1019,11 @@\n+\n+            if (connected && Net.shouldShutdownWriteBeforeClose()) {\n+                \/\/ shutdown output when linger interval not set to 0\n+                try {\n+                    var SO_LINGER = StandardSocketOptions.SO_LINGER;\n+                    if ((int) Net.getSocketOption(fd, SO_LINGER) != 0) {\n+                        Net.shutdown(fd, Net.SHUT_WR);\n+                    }\n+                } catch (IOException ignore) { }\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -203,0 +203,5 @@\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_ch_Net_shouldShutdownWriteBeforeClose0(JNIEnv *env, jclass clazz) {\n+    return JNI_FALSE;\n+}\n+\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/Net.c","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,0 +120,5 @@\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_ch_Net_shouldShutdownWriteBeforeClose0(JNIEnv *env, jclass clazz) {\n+    return JNI_TRUE;\n+}\n+\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/Net.c","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8358764\n+ * @summary Test closing a socket while a thread is blocked in read. The connection\n+ *     should be closed gracefuly so that the peer reads EOF.\n+ * @run junit PeerReadsAfterAsyncClose\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.SocketChannel;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class PeerReadsAfterAsyncClose {\n+\n+    \/**\n+     * Close SocketChannel while a thread is blocked reading from the channel's socket.\n+     *\/\n+    void testCloseDuringSocketChannelRead() throws Exception {\n+        var loopback = InetAddress.getLoopbackAddress();\n+        try (var listener = new ServerSocket()) {\n+            listener.bind(new InetSocketAddress(loopback, 0));\n+\n+            try (SocketChannel sc = SocketChannel.open(listener.getLocalSocketAddress());\n+                 Socket peer = listener.accept()) {\n+\n+                \/\/ start thread to read from channel\n+                var cceThrown = new AtomicBoolean();\n+                Thread thread = new Thread(() -> {\n+                    try {\n+                        sc.read(ByteBuffer.allocate(1));\n+                        fail();\n+                    } catch (ClosedChannelException e) {\n+                        cceThrown.set(true);\n+                    } catch (Throwable e) {\n+                        e.printStackTrace();\n+                    }\n+                });\n+                thread.start();\n+                try {\n+                    \/\/ close SocketChannel when thread sampled in read()\n+                    onReach(thread, \"sun.nio.ch.SocketChannelImpl.read\", () -> {\n+                        try {\n+                            sc.close();\n+                        } catch (IOException ignore) { }\n+                    });\n+\n+                    \/\/ peer should read EOF\n+                    int n = peer.getInputStream().read();\n+                    assertEquals(-1, n);\n+                } finally {\n+                    thread.join();\n+                }\n+                assertEquals(true, cceThrown.get(), \"ClosedChannelException not thrown\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Close Socket while a thread is blocked reading from the socket.\n+     *\/\n+    void testCloseDuringSocketUntimedRead() throws Exception {\n+        testCloseDuringSocketRead(0);\n+    }\n+\n+    \/**\n+     * Close Socket while a thread is blocked reading from the socket with a timeout.\n+     *\/\n+    void testCloseDuringSockeTimedRead() throws Exception {\n+        testCloseDuringSocketRead(60_000);\n+    }\n+\n+    private void testCloseDuringSocketRead(int timeout) throws Exception {\n+        var loopback = InetAddress.getLoopbackAddress();\n+        try (var listener = new ServerSocket()) {\n+            listener.bind(new InetSocketAddress(loopback, 0));\n+\n+            try (Socket s = new Socket(loopback, listener.getLocalPort());\n+                 Socket peer = listener.accept()) {\n+\n+                \/\/ start thread to read from socket\n+                var seThrown = new AtomicBoolean();\n+                Thread thread = new Thread(() -> {\n+                    try {\n+                        s.setSoTimeout(timeout);\n+                        s.getInputStream().read();\n+                        fail();\n+                    } catch (SocketException e) {\n+                        seThrown.set(true);\n+                    } catch (Throwable e) {\n+                        e.printStackTrace();\n+                    }\n+                });\n+                thread.start();\n+                try {\n+                    \/\/ close Socket when thread sampled in implRead\n+                    onReach(thread, \"sun.nio.ch.NioSocketImpl.implRead\", () -> {\n+                        try {\n+                            s.close();\n+                        } catch (IOException ignore) { }\n+                    });\n+\n+                    \/\/ peer should read EOF\n+                    int n = peer.getInputStream().read();\n+                    assertEquals(-1, n);\n+                } finally {\n+                    thread.join();\n+                }\n+                assertEquals(true, seThrown.get(), \"SocketException not thrown\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs the given action when the given target thread is sampled at the given\n+     * location. The location takes the form \"{@code c.m}\" where\n+     * {@code c} is the fully qualified class name and {@code m} is the method name.\n+     *\/\n+    private void onReach(Thread target, String location, Runnable action) {\n+        int index = location.lastIndexOf('.');\n+        String className = location.substring(0, index);\n+        String methodName = location.substring(index + 1);\n+        new Thread(() -> {\n+            try {\n+                boolean found = false;\n+                while (!found) {\n+                    found = contains(target.getStackTrace(), className, methodName);\n+                    if (!found) {\n+                        Thread.sleep(20);\n+                    }\n+                }\n+                action.run();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }).start();\n+    }\n+\n+    \/**\n+     * Returns true if the given stack trace contains an element for the given class\n+     * and method name.\n+     *\/\n+    private boolean contains(StackTraceElement[] stack, String className, String methodName) {\n+        return Arrays.stream(stack)\n+                .anyMatch(e -> className.equals(e.getClassName())\n+                        && methodName.equals(e.getMethodName()));\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/SocketChannel\/PeerReadsAfterAsyncClose.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"}]}