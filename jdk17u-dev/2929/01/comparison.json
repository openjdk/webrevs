{"files":[{"patch":"@@ -87,1 +87,1 @@\n-            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n+            debian-repository: https:\/\/snapshot.debian.org\/archive\/debian\/20240228T034848Z\/\n","filename":".github\/workflows\/build-cross-compile.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        default: 'linux-x64, linux-x86, linux-x64-variants, linux-cross-compile, macos-x64, macos-aarch64, windows-x64, windows-aarch64'\n+        default: 'linux-x64, linux-x86-hs, linux-x64-variants, linux-cross-compile, macos-x64, macos-aarch64, windows-x64, windows-aarch64'\n@@ -61,1 +61,1 @@\n-      linux-x86: ${{ steps.include.outputs.linux-x86 }}\n+      linux-x86-hs: ${{ steps.include.outputs.linux-x86-hs }}\n@@ -112,1 +112,1 @@\n-          echo \"linux-x86=$(check_platform linux-x86 linux x86)\" >> $GITHUB_OUTPUT\n+          echo \"linux-x86-hs=$(check_platform linux-x86-hs linux x86)\" >> $GITHUB_OUTPUT\n@@ -135,2 +135,2 @@\n-  build-linux-x86:\n-    name: linux-x86\n+  build-linux-x86-hs:\n+    name: linux-x86-hs\n@@ -141,0 +141,1 @@\n+      make-target: 'hotspot'\n@@ -150,1 +151,1 @@\n-    if: needs.select.outputs.linux-x86 == 'true'\n+    if: needs.select.outputs.linux-x86-hs == 'true'\n@@ -284,10 +285,0 @@\n-  test-linux-x86:\n-    name: linux-x86\n-    needs:\n-      - build-linux-x86\n-    uses: .\/.github\/workflows\/test.yml\n-    with:\n-      platform: linux-x86\n-      bootjdk-platform: linux-x64\n-      runs-on: ubuntu-22.04\n-\n@@ -331,1 +322,1 @@\n-      - build-linux-x86\n+      - build-linux-x86-hs\n@@ -342,1 +333,0 @@\n-      - test-linux-x86\n@@ -355,1 +345,1 @@\n-              '${{ github.api_url }}\/repos\/${{ github.repository }}\/actions\/runs\/${{ github.run_id }}\/artifacts')\"\n+              '${{ github.api_url }}\/repos\/${{ github.repository }}\/actions\/runs\/${{ github.run_id }}\/artifacts?per_page=100')\"\n","filename":".github\/workflows\/main.yml","additions":9,"deletions":19,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-version=17.0.13\n+version=17.0.14\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,3 @@\n+# JDK Vulnerabilities\n+\n+Please follow the process outlined in the [OpenJDK Vulnerability Policy](https:\/\/openjdk.org\/groups\/vulnerability\/report) to disclose vulnerabilities in the JDK.\n","filename":"SECURITY.md","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -73,0 +73,19 @@\n+    if test \"x$ALSA_FOUND\" = xno; then\n+      # If we have sysroot set, and no explicit library location is set,\n+      # look at known locations in sysroot.\n+      if test \"x$SYSROOT\" != \"x\" && test \"x${with_alsa_lib}\" == x; then\n+        if test -f \"$SYSROOT\/usr\/lib64\/libasound.so\" && test \"x$OPENJDK_TARGET_CPU_BITS\" = x64; then\n+          ALSA_LIBS=\"-L$SYSROOT\/usr\/lib64 -lasound\"\n+          ALSA_FOUND=yes\n+        elif test -f \"$SYSROOT\/usr\/lib\/libasound.so\"; then\n+          ALSA_LIBS=\"-L$SYSROOT\/usr\/lib -lasound\"\n+          ALSA_FOUND=yes\n+        elif test -f \"$SYSROOT\/usr\/lib\/$OPENJDK_TARGET_CPU-$OPENJDK_TARGET_OS-$OPENJDK_TARGET_ABI\/libasound.so\"; then\n+          ALSA_LIBS=\"-L$SYSROOT\/usr\/lib\/$OPENJDK_TARGET_CPU-$OPENJDK_TARGET_OS-$OPENJDK_TARGET_ABI -lasound\"\n+          ALSA_FOUND=yes\n+        elif test -f \"$SYSROOT\/usr\/lib\/$OPENJDK_TARGET_CPU_AUTOCONF-$OPENJDK_TARGET_OS-$OPENJDK_TARGET_ABI\/libasound.so\"; then\n+          ALSA_LIBS=\"-L$SYSROOT\/usr\/lib\/$OPENJDK_TARGET_CPU_AUTOCONF-$OPENJDK_TARGET_OS-$OPENJDK_TARGET_ABI -lasound\"\n+          ALSA_FOUND=yes\n+        fi\n+      fi\n+    fi\n","filename":"make\/autoconf\/lib-alsa.m4","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-            x_libraries=\"$SYSROOT\/usr\/lib\/$OPENJDK_TARGET_CPU-$OPENJDK_TARGET_OS-$OPENJDK_TARGET_ABI\/libX11.so\"\n+            x_libraries=\"$SYSROOT\/usr\/lib\/$OPENJDK_TARGET_CPU-$OPENJDK_TARGET_OS-$OPENJDK_TARGET_ABI\"\n@@ -76,1 +76,1 @@\n-            x_libraries=\"$SYSROOT\/usr\/lib\/$OPENJDK_TARGET_CPU_AUTOCONF-$OPENJDK_TARGET_OS-$OPENJDK_TARGET_ABI\/libX11.so\"\n+            x_libraries=\"$SYSROOT\/usr\/lib\/$OPENJDK_TARGET_CPU_AUTOCONF-$OPENJDK_TARGET_OS-$OPENJDK_TARGET_ABI\"\n","filename":"make\/autoconf\/lib-x11.m4","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-DEFAULT_VERSION_UPDATE=13\n+DEFAULT_VERSION_UPDATE=14\n@@ -36,1 +36,1 @@\n-DEFAULT_VERSION_DATE=2024-10-15\n+DEFAULT_VERSION_DATE=2025-01-21\n","filename":"make\/conf\/version-numbers.conf","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-Github: https:\/\/raw.githubusercontent.com\/publicsuffix\/list\/b5bf572c52988dbe9d865b8f090ea819024a9936\/public_suffix_list.dat\n-Date: 2023-11-09\n+Github: https:\/\/raw.githubusercontent.com\/publicsuffix\/list\/1cbd6e71a9b83620b1d0b11e49d3d9ff48c27e22\/public_suffix_list.dat\n+Date: 2024-05-07\n","filename":"make\/data\/publicsuffixlist\/VERSION","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6713,1 +6713,1 @@\n-\/\/ List of new gTLDs imported from https:\/\/www.icann.org\/resources\/registries\/gtlds\/v2\/gtlds.json on 2023-11-03T15:13:18Z\n+\/\/ List of new gTLDs imported from https:\/\/www.icann.org\/resources\/registries\/gtlds\/v2\/gtlds.json on 2024-05-04T15:12:50Z\n@@ -6899,1 +6899,1 @@\n-\/\/ aol : Oath Inc.\n+\/\/ aol : Yahoo Inc.\n@@ -6991,4 +6991,0 @@\n-\/\/ avianca : Avianca Inc.\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/avianca.html\n-avianca\n-\n@@ -7019,4 +7015,0 @@\n-\/\/ bananarepublic : The Gap, Inc.\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/bananarepublic.html\n-bananarepublic\n-\n@@ -7547,4 +7539,0 @@\n-\/\/ comcast : Comcast IP Holdings I, LLC\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/comcast.html\n-comcast\n-\n@@ -7755,0 +7743,4 @@\n+\/\/ desi\n+\/\/ https:\/\/www.iana.org\/domains\/root\/db\/desi.html\n+desi\n+\n@@ -7799,1 +7791,1 @@\n-\/\/ diy : Lifestyle Domain Holdings, Inc.\n+\/\/ diy : Internet Naming Company LLC\n@@ -7931,4 +7923,0 @@\n-\/\/ etisalat : Emirates Telecommunications Corporation (trading as Etisalat)\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/etisalat.html\n-etisalat\n-\n@@ -8107,1 +8095,1 @@\n-\/\/ food : Lifestyle Domain Holdings, Inc.\n+\/\/ food : Internet Naming Company LLC\n@@ -8167,1 +8155,1 @@\n-\/\/ fun : Radix FZC DMCC\n+\/\/ fun : Radix Technologies Inc.\n@@ -8315,1 +8303,1 @@\n-\/\/ goo : NTT Resonant Inc.\n+\/\/ goo : NTT DOCOMO, INC.\n@@ -8367,4 +8355,0 @@\n-\/\/ guardian : The Guardian Life Insurance Company of America\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/guardian.html\n-guardian\n-\n@@ -8503,1 +8487,1 @@\n-\/\/ host : Radix FZC DMCC\n+\/\/ host : Radix Technologies Inc.\n@@ -8723,1 +8707,1 @@\n-\/\/ juegos : Internet Naming Company LLC\n+\/\/ juegos : Dog Beach, LLC\n@@ -8911,1 +8895,1 @@\n-\/\/ lifestyle : Lifestyle Domain Holdings, Inc.\n+\/\/ lifestyle : Internet Naming Company LLC\n@@ -8951,1 +8935,1 @@\n-\/\/ living : Lifestyle Domain Holdings, Inc.\n+\/\/ living : Internet Naming Company LLC\n@@ -9395,4 +9379,0 @@\n-\/\/ oldnavy : The Gap, Inc.\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/oldnavy.html\n-oldnavy\n-\n@@ -9419,1 +9399,1 @@\n-\/\/ online : Radix FZC DMCC\n+\/\/ online : Radix Technologies Inc.\n@@ -9623,1 +9603,1 @@\n-\/\/ press : Radix FZC DMCC\n+\/\/ press : Radix Technologies Inc.\n@@ -9931,4 +9911,0 @@\n-\/\/ sca : SVENSKA CELLULOSA AKTIEBOLAGET SCA (publ)\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/sca.html\n-sca\n-\n@@ -10079,1 +10055,1 @@\n-\/\/ site : Radix FZC DMCC\n+\/\/ site : Radix Technologies Inc.\n@@ -10159,1 +10135,1 @@\n-\/\/ space : Radix FZC DMCC\n+\/\/ space : Radix Technologies Inc.\n@@ -10211,1 +10187,1 @@\n-\/\/ store : Radix FZC DMCC\n+\/\/ store : Radix Technologies Inc.\n@@ -10327,1 +10303,1 @@\n-\/\/ tech : Radix FZC DMCC\n+\/\/ tech : Radix Technologies Inc.\n@@ -10511,1 +10487,1 @@\n-\/\/ uno : Radix FZC DMCC\n+\/\/ uno : Radix Technologies Inc.\n@@ -10527,1 +10503,1 @@\n-\/\/ vana : Lifestyle Domain Holdings, Inc.\n+\/\/ vana : Internet Naming Company LLC\n@@ -10611,4 +10587,0 @@\n-\/\/ volkswagen : Volkswagen Group of America Inc.\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/volkswagen.html\n-volkswagen\n-\n@@ -10679,1 +10651,1 @@\n-\/\/ website : Radix FZC DMCC\n+\/\/ website : Radix Technologies Inc.\n@@ -10683,0 +10655,4 @@\n+\/\/ wed\n+\/\/ https:\/\/www.iana.org\/domains\/root\/db\/wed.html\n+wed\n+\n@@ -10771,4 +10747,0 @@\n-\/\/ xfinity : Comcast IP Holdings I, LLC\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/xfinity.html\n-xfinity\n-\n@@ -11015,4 +10987,0 @@\n-\/\/ xn--mgbaakc7dvf : Emirates Telecommunications Corporation (trading as Etisalat)\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/xn--mgbaakc7dvf.html\n-اتصالات\n-\n@@ -11155,1 +11123,1 @@\n-\/\/ yahoo : Oath Inc.\n+\/\/ yahoo : Yahoo Inc.\n@@ -11220,0 +11188,6 @@\n+\/\/ 12CHARS: https:\/\/12chars.com\n+\/\/ Submitted by Kenny Niehage <psl@12chars.com>\n+12chars.dev\n+12chars.it\n+12chars.pro\n+\n@@ -11229,0 +11203,9 @@\n+\/\/ AAA workspace : https:\/\/aaa.vodka\n+\/\/ Submitted by Kirill Rezraf <admin@aaa.vodka>\n+aaa.vodka\n+\n+\/\/ A2 Hosting\n+\/\/ Submitted by Tyler Hall <sysadmin@a2hosting.com>\n+a2hosted.com\n+cpserver.com\n+\n@@ -11245,0 +11228,4 @@\n+\/\/ Adaptable.io : https:\/\/adaptable.io\n+\/\/ Submitted by Mark Terrel <support@adaptable.io>\n+adaptable.app\n+\n@@ -11249,0 +11236,1 @@\n+aem.live\n@@ -11251,0 +11239,1 @@\n+aem.page\n@@ -11322,1 +11311,1 @@\n-\/\/ Reference: 4d863337-ff98-4501-a6f2-361eba8445d6\n+\/\/ Reference: 9e37648f-a66c-4655-9ab1-5981f8737197\n@@ -11337,0 +11326,1 @@\n+execute-api.ca-west-1.amazonaws.com\n@@ -11363,1 +11353,1 @@\n-\/\/ Reference: 7bee1013-f456-47df-bfe8-03c78d946d61\n+\/\/ Reference: 09588633-91fe-49d8-b4e7-ec36496d11f3\n@@ -11369,0 +11359,1 @@\n+auth.ap-south-2.amazoncognito.com\n@@ -11372,0 +11363,1 @@\n+auth.ap-southeast-4.amazoncognito.com\n@@ -11374,0 +11366,1 @@\n+auth.eu-central-2.amazoncognito.com\n@@ -11376,0 +11369,1 @@\n+auth.eu-south-2.amazoncognito.com\n@@ -11380,0 +11374,1 @@\n+auth.me-central-1.amazoncognito.com\n@@ -11402,1 +11397,1 @@\n-\/\/ Reference: 597f3f8e-9283-4e48-8e32-7ee25a1ff6ab\n+\/\/ Reference: 82f43f9f-bbb8-400e-8349-854f5a62f20d\n@@ -11427,0 +11422,3 @@\n+emrappui-prod.ap-south-2.amazonaws.com\n+emrnotebooks-prod.ap-south-2.amazonaws.com\n+emrstudio-prod.ap-south-2.amazonaws.com\n@@ -11436,0 +11434,3 @@\n+emrappui-prod.ap-southeast-4.amazonaws.com\n+emrnotebooks-prod.ap-southeast-4.amazonaws.com\n+emrstudio-prod.ap-southeast-4.amazonaws.com\n@@ -11439,0 +11440,3 @@\n+emrappui-prod.ca-west-1.amazonaws.com\n+emrnotebooks-prod.ca-west-1.amazonaws.com\n+emrstudio-prod.ca-west-1.amazonaws.com\n@@ -11442,0 +11446,3 @@\n+emrappui-prod.eu-central-2.amazonaws.com\n+emrnotebooks-prod.eu-central-2.amazonaws.com\n+emrstudio-prod.eu-central-2.amazonaws.com\n@@ -11448,0 +11455,3 @@\n+emrappui-prod.eu-south-2.amazonaws.com\n+emrnotebooks-prod.eu-south-2.amazonaws.com\n+emrstudio-prod.eu-south-2.amazonaws.com\n@@ -11457,0 +11467,3 @@\n+emrappui-prod.il-central-1.amazonaws.com\n+emrnotebooks-prod.il-central-1.amazonaws.com\n+emrstudio-prod.il-central-1.amazonaws.com\n@@ -11487,1 +11500,1 @@\n-\/\/ Reference: 4ab55e6f-90c0-4a8d-b6a0-52ca5dbb1c2e\n+\/\/ Reference: 87f24ece-a77e-40e8-bb4a-f6b74fe9f975\n@@ -11490,0 +11503,2 @@\n+*.af-south-1.airflow.amazonaws.com\n+*.ap-east-1.airflow.amazonaws.com\n@@ -11498,0 +11513,1 @@\n+*.eu-south-1.airflow.amazonaws.com\n@@ -11501,0 +11517,1 @@\n+*.me-south-1.airflow.amazonaws.com\n@@ -11504,0 +11521,1 @@\n+*.us-west-1.airflow.amazonaws.com\n@@ -11508,1 +11526,1 @@\n-\/\/ Reference: 0e801048-08f2-4064-9cb8-e7373e0b57f4\n+\/\/ Reference: cd5c8b3a-67b7-4b40-9236-c87ce81a3d10\n@@ -11607,0 +11625,10 @@\n+s3.dualstack.ca-west-1.amazonaws.com\n+s3-accesspoint.dualstack.ca-west-1.amazonaws.com\n+s3-accesspoint-fips.dualstack.ca-west-1.amazonaws.com\n+s3-fips.dualstack.ca-west-1.amazonaws.com\n+s3-website.dualstack.ca-west-1.amazonaws.com\n+s3.ca-west-1.amazonaws.com\n+s3-accesspoint.ca-west-1.amazonaws.com\n+s3-accesspoint-fips.ca-west-1.amazonaws.com\n+s3-fips.ca-west-1.amazonaws.com\n+s3-website.ca-west-1.amazonaws.com\n@@ -11787,0 +11815,16 @@\n+\/\/ Amazon SageMaker Ground Truth\n+\/\/ Submitted by AWS Security <psl-maintainers@amazon.com>\n+\/\/ Reference: 98dbfde4-7802-48c3-8751-b60f204e0d9c\n+labeling.ap-northeast-1.sagemaker.aws\n+labeling.ap-northeast-2.sagemaker.aws\n+labeling.ap-south-1.sagemaker.aws\n+labeling.ap-southeast-1.sagemaker.aws\n+labeling.ap-southeast-2.sagemaker.aws\n+labeling.ca-central-1.sagemaker.aws\n+labeling.eu-central-1.sagemaker.aws\n+labeling.eu-west-1.sagemaker.aws\n+labeling.eu-west-2.sagemaker.aws\n+labeling.us-east-1.sagemaker.aws\n+labeling.us-east-2.sagemaker.aws\n+labeling.us-west-2.sagemaker.aws\n+\n@@ -11789,1 +11833,1 @@\n-\/\/ Reference: fe8c9e94-5a22-486d-8750-991a3a9b13c6\n+\/\/ Reference: b5ea56df-669e-43cc-9537-14aa172f5dfc\n@@ -11802,0 +11846,3 @@\n+notebook-fips.ca-central-1.sagemaker.aws\n+notebook.ca-west-1.sagemaker.aws\n+notebook-fips.ca-west-1.sagemaker.aws\n@@ -11823,0 +11870,1 @@\n+notebook-fips.us-west-1.sagemaker.aws\n@@ -11830,1 +11878,1 @@\n-\/\/ Reference: 057ee397-6bf8-4f20-b807-d7bc145ac980\n+\/\/ Reference: 69c723d9-6e1a-4bff-a203-48eecd203183\n@@ -11844,0 +11892,1 @@\n+studio.eu-south-2.sagemaker.aws\n@@ -11888,1 +11937,1 @@\n-\/\/ Reference: 05c44955-977c-4b57-938a-f2af92733f9f\n+\/\/ Reference: 30717f72-4007-4f0f-8ed4-864c6f2efec9\n@@ -11934,0 +11983,2 @@\n+webview-assets.aws-cloud9.il-central-1.amazonaws.com\n+vfs.cloud9.il-central-1.amazonaws.com\n@@ -11953,0 +12004,5 @@\n+\/\/ AWS Directory Service\n+\/\/ Submitted by AWS Security <psl-maintainers@amazon.com>\n+\/\/ Reference: a13203e8-42dc-4045-a0d2-2ee67bed1068\n+awsapps.com\n+\n@@ -11996,0 +12052,5 @@\n+\/\/ AWS re:Post Private\n+\/\/ Submitted by AWS Security <psl-maintainers@amazon.com>\n+\/\/ Reference: 83385945-225f-416e-9aa0-ad0632bfdcee\n+*.private.repost.aws\n+\n@@ -12013,0 +12074,4 @@\n+\/\/ Apis Networks: https:\/\/apisnetworks.com\n+\/\/ Submitted by Matt Saladna <matt@apisnetworks.com>\n+panel.dev\n+\n@@ -12030,0 +12095,4 @@\n+\/\/ Aquapal : https:\/\/aquapal.net\/\n+\/\/ Submitted by Aki Ueno <admin@aquapal.net>\n+f5.si\n+\n@@ -12065,0 +12134,1 @@\n+myfritz.link\n@@ -12124,0 +12194,4 @@\n+\/\/ Besties : https:\/\/besties.house\n+\/\/ Submitted by Hazel Cora <hazy@besties.house>\n+pages.gay\n+\n@@ -12128,0 +12202,4 @@\n+\/\/ University of Bielsko-Biala regional domain: http:\/\/dns.bielsko.pl\/\n+\/\/ Submitted by Marcin <dns@ath.bielsko.pl>\n+bielsko.pl\n+\n@@ -12169,0 +12247,4 @@\n+\/\/ Brave : https:\/\/brave.com\n+\/\/ Submitted by Andrea Brancaleoni <abrancaleoni@brave.com>\n+*.s.brave.io\n+\n@@ -12170,1 +12252,2 @@\n-\/\/ Submitted by Dusan Radovanovic <dusan.radovanovic@brendly.rs>\n+\/\/ Submitted by Dusan Radovanovic <administracija@brendly.rs>\n+shop.brendly.hr\n@@ -12194,0 +12277,1 @@\n+*.my.canvasite.cn\n@@ -12195,0 +12279,1 @@\n+*.my.canva.site\n@@ -12332,0 +12417,6 @@\n+\/\/ cloudscale.ch AG : https:\/\/www.cloudscale.ch\/\n+\/\/ Submitted by Gaudenz Steinlin <support@cloudscale.ch>\n+cust.cloudscale.ch\n+objects.lpg.cloudscale.ch\n+objects.rma.cloudscale.ch\n+\n@@ -12349,1 +12440,2 @@\n-c.cdn77.org\n+cdn77-storage.com\n+rsc.contentproxy9.cz\n@@ -12352,1 +12444,0 @@\n-rsc.cdn77.org\n@@ -12354,0 +12445,2 @@\n+c.cdn77.org\n+rsc.cdn77.org\n@@ -12356,1 +12449,1 @@\n-\/\/ Submitted by Aleksander Hristov <noc@cloudns.net>\n+\/\/ Submitted by Aleksander Hristov <noc@cloudns.net> & Boyan Peychev <boyan@cloudns.net>\n@@ -12358,0 +12451,1 @@\n+cloudns.be\n@@ -12359,1 +12453,0 @@\n-cloudns.club\n@@ -12361,0 +12454,5 @@\n+cloudns.ch\n+cloudns.cl\n+cloudns.club\n+dnsabr.com\n+cloudns.cx\n@@ -12364,0 +12462,3 @@\n+dns-cloud.net\n+dns-dynamic.net\n+cloudns.nz\n@@ -12365,0 +12466,1 @@\n+cloudns.ph\n@@ -12377,0 +12479,5 @@\n+\/\/ CodeSandbox B.V. : https:\/\/codesandbox.io\n+\/\/ Submitted by Ives van Hoorne <abuse@codesandbox.io>\n+csb.app\n+preview.csb.app\n+\n@@ -12386,0 +12493,4 @@\n+\/\/ Convex : https:\/\/convex.dev\/\n+\/\/ Submitted by James Cowling <security@convex.dev>\n+convex.site\n+\n@@ -12407,0 +12518,4 @@\n+\/\/ cPanel L.L.C. : https:\/\/www.cpanel.net\/\n+\/\/ Submitted by Dustin Scherer <public.suffix@cpanel.net>\n+*.cprapid.com\n+\n@@ -12411,0 +12526,4 @@\n+\/\/ Crisp IM SAS : https:\/\/crisp.chat\/\n+\/\/ Submitted by Baptiste Jamin <hostmaster@crisp.chat>\n+on.crisp.email\n+\n@@ -12431,0 +12550,7 @@\n+\/\/ Cyclic Software : https:\/\/www.cyclic.sh\n+\/\/ Submitted by Kam Lasater <dns-admin@cyclic.sh>\n+cyclic.app\n+cyclic.cloud\n+cyclic-app.com\n+cyclic.co.in\n+\n@@ -12476,0 +12602,1 @@\n+darklang.io\n@@ -12874,0 +13001,4 @@\n+\/\/ DigitalPlat : https:\/\/www.digitalplat.org\/\n+\/\/ Submitted by Edward Hsing <contact@digitalplat.org>\n+us.kg\n+\n@@ -12911,0 +13042,12 @@\n+\/\/ EasyWP : https:\/\/www.easywp.com\n+\/\/ Submitted by <infracloudteam@namecheap.com>\n+*.ewp.live\n+\n+\/\/ Electromagnetic Field : https:\/\/www.emfcamp.org\n+\/\/ Submitted by <noc@emfcamp.org>\n+at.emf.camp\n+\n+\/\/ Elefunc, Inc. : https:\/\/elefunc.com\n+\/\/ Submitted by Cetin Sert <domains@elefunc.com>\n+rt.ht\n+\n@@ -13025,4 +13168,0 @@\n-\/\/ Facebook, Inc.\n-\/\/ Submitted by Peter Ruibal <public-suffix@fb.com>\n-apps.fbsbx.com\n-\n@@ -13186,0 +13325,4 @@\n+\/\/ FlutterFlow : https:\/\/flutterflow.io\n+\/\/ Submitted by Anton Emelyanov <anton@flutterflow.io>\n+flutterflow.app\n+\n@@ -13196,1 +13339,1 @@\n-\/\/ Forgerock : https:\/\/www.forgerock.com\n+\/\/ Forgerock : https:\/\/www.forgerock.com\n@@ -13202,1 +13345,2 @@\n-\/\/ Submitted by Koen Rouwhorst <koenrh@framer.com>\n+\/\/ Submitted by Koen Rouwhorst <security@framer.com>\n+framer.ai\n@@ -13243,0 +13387,18 @@\n+\/\/ Future Versatile Group. ：https:\/\/www.fvg-on.net\/\n+\/\/ T.Kabu <webmaster@fvg-on.net>\n+daemon.asia\n+dix.asia\n+mydns.bz\n+0am.jp\n+0g0.jp\n+0j0.jp\n+0t0.jp\n+mydns.jp\n+pgw.jp\n+wjg.jp\n+keyword-on.net\n+live-on.net\n+server-on.net\n+mydns.tw\n+mydns.vc\n+\n@@ -13254,0 +13416,4 @@\n+\/\/ GCom Internet : https:\/\/www.gcom.net.au\n+\/\/ Submitted by Leo Julius <support@gcom.net.au>\n+aliases121.com\n+\n@@ -13282,3 +13448,5 @@\n-\/\/ Ghost Foundation : https:\/\/ghost.org\n-\/\/ Submitted by Matt Hanley <security@ghost.org>\n-ghost.io\n+\/\/ Getlocalcert: https:\/\/www.getlocalcert.net\n+\/\/ Submitted by Robert Alexander <support@getlocalcert.net>\n+localcert.net\n+localhostcert.net\n+corpnet.work\n@@ -13428,0 +13596,4 @@\n+\/\/ GoDaddy Registry : https:\/\/registry.godaddy\n+\/\/ Submitted by Rohan Durrant <tldns@registry.godaddy>\n+graphic.design\n+\n@@ -13437,4 +13609,0 @@\n-\/\/ UKHomeOffice : https:\/\/www.gov.uk\/government\/organisations\/home-office\n-\/\/ Submitted by Jon Shanks <jon.shanks@digital.homeoffice.gov.uk>\n-homeoffice.gov.uk\n-\n@@ -13451,2 +13619,1 @@\n-run.app\n-a.run.app\n+*.run.app\n@@ -13552,0 +13719,4 @@\n+\/\/ GrayJay Web Solutions Inc. : https:\/\/grayjaysports.ca\n+\/\/ Submitted by Matt Yamkowy <info@grayjaysports.ca>\n+grayjayleagues.com\n+\n@@ -13586,0 +13757,5 @@\n+\/\/ Helio Networks : https:\/\/heliohost.org\n+\/\/ Submitted by Ben Frede <admin@heliohost.org>\n+helioho.st\n+heliohost.us\n+\n@@ -13599,1 +13775,0 @@\n-ravendb.me\n@@ -13607,0 +13782,6 @@\n+\/\/ Homebase : https:\/\/homebase.id\/\n+\/\/ Submitted by Jason Babo <info@homebase.id>\n+*.kin.one\n+*.id.pub\n+*.kin.pub\n+\n@@ -13684,1 +13865,1 @@\n-\/\/ Submitted by Jacob Slater <whois@igloo.to>\n+\/\/ Submitted by June Slater <whois@igloo.to>\n@@ -13733,0 +13914,8 @@\n+\/\/ is-a.dev : https:\/\/www.is-a.dev\n+\/\/ Submitted by William Harrison <admin@maintainers.is-a.dev>\n+is-a.dev\n+\n+\/\/ ir.md : https:\/\/nic.ir.md\n+\/\/ Submitted by Ali Soizi <info@nic.ir.md>\n+ir.md\n+\n@@ -13841,0 +14030,5 @@\n+\/\/ JouwWeb B.V. : https:\/\/www.jouwweb.nl\n+\/\/ Submitted by Camilo Sperberg <tech@webador.com>\n+jouwweb.site\n+webadorsite.com\n+\n@@ -13914,0 +14108,4 @@\n+\/\/ Libre IT Ltd : https:\/\/libre.nz\n+\/\/ Submitted by Tomas Maggio <support@libre.nz>\n+runcontainers.dev\n+\n@@ -13924,4 +14122,0 @@\n-\/\/ Lightmaker Property Manager, Inc. : https:\/\/app.lmpm.com\/\n-\/\/ Submitted by Greg Holland <greg.holland@lmpm.com>\n-app.lmpm.com\n-\n@@ -14060,0 +14254,5 @@\n+\/\/ Meta Platforms, Inc. : https:\/\/meta.com\/\n+\/\/ Submitted by Jacob Cordero <public-suffix@meta.com>\n+atmeta.com\n+apps.fbsbx.com\n+\n@@ -14080,0 +14279,2 @@\n+\/\/ Managed by Corporate Domains\n+\/\/ Microsoft Azure : https:\/\/home.azure\n@@ -14081,0 +14282,3 @@\n+azure-api.net\n+azureedge.net\n+azurefd.net\n@@ -14083,1 +14287,0 @@\n-cloudapp.net\n@@ -14097,0 +14300,4 @@\n+cloudapp.net\n+trafficmanager.net\n+blob.core.windows.net\n+servicebus.windows.net\n@@ -14110,0 +14317,4 @@\n+\/\/ MODX Systems LLC : https:\/\/modx.com\n+\/\/ Submitted by Elizabeth Southwell <elizabeth@modx.com>\n+modx.dev\n+\n@@ -14156,0 +14367,4 @@\n+\/\/ NGO.US Registry : https:\/\/nic.ngo.us\n+\/\/ Submitted by Alstra Solutions Ltd. Networking Team <admin@alstra.org>\n+ngo.us\n+\n@@ -14171,0 +14386,1 @@\n+ngrok.pro\n@@ -14176,1 +14392,1 @@\n-\/\/ Submitted by Nicholas Ford <nick@nimbushosting.co.uk>\n+\/\/ Submitted by Nicholas Ford <dev@nimbushosting.co.uk>\n@@ -14178,0 +14394,1 @@\n+nimsite.uk\n@@ -14183,0 +14400,4 @@\n+\/\/ NFT.Storage : https:\/\/nft.storage\/\n+\/\/ Submitted by Vasco Santos <vasco.santos@protocol.ai> or <support@nft.storage>\n+ipfs.nftstorage.link\n+\n@@ -14333,0 +14554,4 @@\n+\/\/ O3O.Foundation : https:\/\/o3o.foundation\/\n+\/\/ Submitted by the prvcy.page Registry Team <psl@registry.prvcy.page>\n+prvcy.page\n+\n@@ -14362,1 +14587,0 @@\n-123sait.ru\n@@ -14380,0 +14604,7 @@\n+\/\/ Open Domains : https:\/\/open-domains.net\n+\/\/ Submitted by William Harrison <admin@open-domains.net>\n+is-cool.dev\n+is-not-a.dev\n+localplayer.dev\n+is-local.org\n+\n@@ -14400,0 +14631,5 @@\n+\/\/ OsSav Technology Ltd. : https:\/\/ossav.com\/\n+\/\/ TLD Nic: http:\/\/nic.can.re - TLD Whois Server: whois.can.re\n+\/\/ Submitted by OsSav Technology Ltd. <support@ossav.com>\n+can.re\n+\n@@ -14450,4 +14686,5 @@\n-bar0.net\n-bar1.net\n-bar2.net\n-rdv.to\n+*.xmit.co\n+xmit.dev\n+srv.us\n+gh.srv.us\n+gl.srv.us\n@@ -14486,1 +14723,2 @@\n-bc.platform.sh\n+*.upsun.app\n+upsunapp.com\n@@ -14505,0 +14743,4 @@\n+\/\/ Pley AB : https:\/\/www.pley.com\/\n+\/\/ Submitted by Henning Pohl <infra@pley.com>\n+pley.games\n+\n@@ -14536,4 +14778,0 @@\n-\/\/ privacytools.io : https:\/\/www.privacytools.io\/\n-\/\/ Submitted by Jonah Aragon <jonah@privacytools.io>\n-prvcy.page\n-\n@@ -14581,0 +14819,2 @@\n+myradweb.net\n+servername.us\n@@ -14604,2 +14844,2 @@\n-\/\/ Submitted by Nick Chang <nickchang@qnap.com>\n-dev-myqnapcloud.com\n+\/\/ Submitted by Nick Chang <cloudadmin@qnap.com>\n+myqnapcloud.cn\n@@ -14607,0 +14847,3 @@\n+dev-myqnapcloud.com\n+mycloudnas.com\n+mynascloud.com\n@@ -14647,1 +14890,3 @@\n-\/\/ Submitted by Lincoln Bergeson <lincoln@replit.com>\n+\/\/ Submitted by Lincoln Bergeson <psl@repl.it>\n+replit.app\n+id.replit.app\n@@ -14652,0 +14897,27 @@\n+replit.dev\n+archer.replit.dev\n+bones.replit.dev\n+canary.replit.dev\n+global.replit.dev\n+hacker.replit.dev\n+id.replit.dev\n+janeway.replit.dev\n+kim.replit.dev\n+kira.replit.dev\n+kirk.replit.dev\n+odo.replit.dev\n+paris.replit.dev\n+picard.replit.dev\n+pike.replit.dev\n+prerelease.replit.dev\n+reed.replit.dev\n+riker.replit.dev\n+sisko.replit.dev\n+spock.replit.dev\n+staging.replit.dev\n+sulu.replit.dev\n+tarpit.replit.dev\n+teams.replit.dev\n+tucker.replit.dev\n+wesley.replit.dev\n+worf.replit.dev\n@@ -14748,1 +15020,1 @@\n-\/\/ Submitted by Michael Biven <mbiven@salesforce.com>\n+\/\/ Submitted by Michael Biven <mbiven@salesforce.com> and Aaron Romeo <aaron.romeo@salesforce.com>\n@@ -14752,0 +15024,1 @@\n+*.001.test.code-builder-stg.platform.salesforce.com\n@@ -14767,0 +15040,1 @@\n+cockpit.fr-par.scw.cloud\n@@ -14777,0 +15051,1 @@\n+cockpit.nl-ams.scw.cloud\n@@ -14782,0 +15057,1 @@\n+cockpit.pl-waw.scw.cloud\n@@ -14803,0 +15079,4 @@\n+\/\/ Scrypted : https:\/\/scrypted.app\n+\/\/ Submitted by Koushik Dutta <public-suffix-list@scrypted.app>\n+client.scrypted.io\n+\n@@ -14842,0 +15122,4 @@\n+\/\/ Sheezy.Art : https:\/\/sheezy.art\n+\/\/ Submitted by Nyoom <admin@sheezy.art>\n+sheezy.games\n+\n@@ -14890,1 +15174,1 @@\n-\/\/ Former AFNIC's SLDs \n+\/\/ Former AFNIC's SLDs\n@@ -14912,3 +15196,3 @@\n-\/\/ Submitted by Faith Olapade <faith.olapade@snowflake.com>\n-snowflake.app\n-privatelink.snowflake.app\n+\/\/ Submitted by Sam Haar <psl@snowflake.com>\n+*.snowflake.app\n+*.privatelink.snowflake.app\n@@ -14926,0 +15210,6 @@\n+\/\/ StackBlitz : https:\/\/stackblitz.com\n+\/\/ Submitted by Dominic Elm <hello@stackblitz.com>\n+w-corp-staticblitz.com\n+w-credentialless-staticblitz.com\n+w-staticblitz.com\n+\n@@ -14930,0 +15220,8 @@\n+\/\/ STACKIT : https:\/\/www.stackit.de\/en\/\n+\/\/ Submitted by STACKIT-DNS Team (Simon Stier) <stackit-dns@mail.schwarz>\n+runs.onstackit.cloud\n+stackit.gg\n+stackit.rocks\n+stackit.run\n+stackit.zone\n+\n@@ -14996,0 +15294,13 @@\n+\/\/ stereosense GmbH : https:\/\/www.involve.me\n+\/\/ Submitted by Florian Burmann <publicsuffix@involve.me>\n+feedback.ac\n+forms.ac\n+assessments.cx\n+calculators.cx\n+funnels.cx\n+paynow.cx\n+quizzes.cx\n+researched.cx\n+tests.cx\n+surveys.so\n+\n@@ -15004,0 +15315,6 @@\n+\/\/ Streak : https:\/\/streak.com\n+\/\/ Submitted by Blake Kadatz <eng@streak.com>\n+streak-link.com\n+streaklinks.com\n+streakusercontent.com\n+\n@@ -15066,0 +15383,1 @@\n+*.c.ts.net\n@@ -15199,0 +15517,4 @@\n+\/\/ Unison Computing, PBC : https:\/\/unison.cloud\n+\/\/ Submitted by Simon Højberg <security@unison.cloud>\n+unison-services.cloud\n+\n@@ -15248,42 +15570,0 @@\n-\/\/ Voxel.sh DNS : https:\/\/voxel.sh\/dns\/\n-\/\/ Submitted by Mia Rehlinger <dns@voxel.sh>\n-neko.am\n-nyaa.am\n-be.ax\n-cat.ax\n-es.ax\n-eu.ax\n-gg.ax\n-mc.ax\n-us.ax\n-xy.ax\n-nl.ci\n-xx.gl\n-app.gp\n-blog.gt\n-de.gt\n-to.gt\n-be.gy\n-cc.hn\n-blog.kg\n-io.kg\n-jp.kg\n-tv.kg\n-uk.kg\n-us.kg\n-de.ls\n-at.md\n-de.md\n-jp.md\n-to.md\n-indie.porn\n-vxl.sh\n-ch.tc\n-me.tc\n-we.tc\n-nyan.to\n-at.vg\n-blog.vu\n-dev.vu\n-me.vu\n-\n@@ -15302,0 +15582,5 @@\n+\/\/ Webflow, Inc. : https:\/\/www.webflow.com\n+\/\/ Submitted by Webflow Security Team <security@webflow.com>\n+webflow.io\n+webflowtest.io\n+\n@@ -15313,0 +15598,4 @@\n+\/\/ WebWaddle Ltd: https:\/\/webwaddle.com\/\n+\/\/ Submitted by Merlin Glander <hostmaster@webwaddle.com>\n+*.wadl.top\n+\n@@ -15421,0 +15710,4 @@\n+\/\/ ZAP-Hosting GmbH & Co. KG : https:\/\/zap-hosting.com\n+\/\/ Submitted by Julian Alker <security@zap-hosting.com>\n+zap.cloud\n+\n","filename":"make\/data\/publicsuffixlist\/public_suffix_list.dat","additions":449,"deletions":156,"binary":false,"changes":605,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -367,14 +367,15 @@\n-            switch (mon) {\n-            case \"Jan\": return Month.JANUARY;\n-            case \"Feb\": return Month.FEBRUARY;\n-            case \"Mar\": return Month.MARCH;\n-            case \"Apr\": return Month.APRIL;\n-            case \"May\": return Month.MAY;\n-            case \"Jun\": return Month.JUNE;\n-            case \"Jul\": return Month.JULY;\n-            case \"Aug\": return Month.AUGUST;\n-            case \"Sep\": return Month.SEPTEMBER;\n-            case \"Oct\": return Month.OCTOBER;\n-            case \"Nov\": return Month.NOVEMBER;\n-            case \"Dec\": return Month.DECEMBER;\n-            }\n+            int len = mon.length();\n+\n+            if (mon.regionMatches(true, 0, \"January\", 0, len)) return Month.JANUARY;\n+            if (mon.regionMatches(true, 0, \"February\", 0, len)) return Month.FEBRUARY;\n+            if (mon.regionMatches(true, 0, \"March\", 0, len)) return Month.MARCH;\n+            if (mon.regionMatches(true, 0, \"April\", 0, len)) return Month.APRIL;\n+            if (mon.regionMatches(true, 0, \"May\", 0, len)) return Month.MAY;\n+            if (mon.regionMatches(true, 0, \"June\", 0, len)) return Month.JUNE;\n+            if (mon.regionMatches(true, 0, \"July\", 0, len)) return Month.JULY;\n+            if (mon.regionMatches(true, 0, \"August\", 0, len)) return Month.AUGUST;\n+            if (mon.regionMatches(true, 0, \"September\", 0, len)) return Month.SEPTEMBER;\n+            if (mon.regionMatches(true, 0, \"October\", 0, len)) return Month.OCTOBER;\n+            if (mon.regionMatches(true, 0, \"November\", 0, len)) return Month.NOVEMBER;\n+            if (mon.regionMatches(true, 0, \"December\", 0, len)) return Month.DECEMBER;\n+\n@@ -385,9 +386,10 @@\n-            switch (dow) {\n-            case \"Mon\": return DayOfWeek.MONDAY;\n-            case \"Tue\": return DayOfWeek.TUESDAY;\n-            case \"Wed\": return DayOfWeek.WEDNESDAY;\n-            case \"Thu\": return DayOfWeek.THURSDAY;\n-            case \"Fri\": return DayOfWeek.FRIDAY;\n-            case \"Sat\": return DayOfWeek.SATURDAY;\n-            case \"Sun\": return DayOfWeek.SUNDAY;\n-            }\n+            int len = dow.length();\n+\n+            if (dow.regionMatches(true, 0, \"Monday\", 0, len)) return DayOfWeek.MONDAY;\n+            if (dow.regionMatches(true, 0, \"Tuesday\", 0, len)) return DayOfWeek.TUESDAY;\n+            if (dow.regionMatches(true, 0, \"Wednesday\", 0, len)) return DayOfWeek.WEDNESDAY;\n+            if (dow.regionMatches(true, 0, \"Thursday\", 0, len)) return DayOfWeek.THURSDAY;\n+            if (dow.regionMatches(true, 0, \"Friday\", 0, len)) return DayOfWeek.FRIDAY;\n+            if (dow.regionMatches(true, 0, \"Saturday\", 0, len)) return DayOfWeek.SATURDAY;\n+            if (dow.regionMatches(true, 0, \"Sunday\", 0, len)) return DayOfWeek.SUNDAY;\n+\n","filename":"make\/jdk\/src\/classes\/build\/tools\/tzdb\/TzdbZoneRulesProvider.java","additions":26,"deletions":24,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2015 SAP SE. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n@@ -82,1 +82,1 @@\n-  if (is_power_of_2(((jlong) ui16)+1)) {\n+  if (is_power_of_2(((unsigned long) ui16)+1)) {\n@@ -84,1 +84,1 @@\n-    clrldi(a, s, 64 - log2i_exact((((jlong) ui16)+1)));\n+    clrldi(a, s, 64 - log2i_exact((((unsigned long) ui16)+1)));\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -585,1 +585,1 @@\n-      (is_power_of_2(int_or_long_const+1) ||\n+      (is_power_of_2((unsigned long)int_or_long_const+1) ||\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3513,0 +3513,1 @@\n+    call->_arg_escape        = _arg_escape;\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -77,0 +77,10 @@\n+\/\/ The C ABI specifies:\n+\/\/ \"integer scalars narrower than XLEN bits are widened according to the sign\n+\/\/ of their type up to 32 bits, then sign-extended to XLEN bits.\"\n+\/\/ Applies for both passed in register and stack.\n+\/\/\n+\/\/ Java uses 32-bit stack slots; jint, jshort, jchar, jbyte uses one slot.\n+\/\/ Native uses 64-bit stack slots for all integer scalar types.\n+\/\/\n+\/\/ lw loads the Java stack slot, sign-extends and\n+\/\/ sd store this widened integer into a 64 bit native stack slot.\n@@ -85,1 +95,1 @@\n-    __ sw(x10, Address(to(), next_stack_offset()));\n+    __ sd(x10, Address(to(), next_stack_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/interpreterRT_riscv.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -699,1 +699,0 @@\n-  \/\/ use addiw to distinguish li32 to li64\n@@ -703,27 +702,0 @@\n-void MacroAssembler::li64(Register Rd, int64_t imm) {\n-  \/\/ Load upper 32 bits. upper = imm[63:32], but if imm[31] == 1 or\n-  \/\/ (imm[31:20] == 0x7ff && imm[19] == 1), upper = imm[63:32] + 1.\n-  int64_t lower = imm & 0xffffffff;\n-  lower -= ((lower << 44) >> 44);\n-  int64_t tmp_imm = ((uint64_t)(imm & 0xffffffff00000000)) + (uint64_t)lower;\n-  int32_t upper = (tmp_imm - (int32_t)lower) >> 32;\n-\n-  \/\/ Load upper 32 bits\n-  int64_t up = upper, lo = upper;\n-  lo = (lo << 52) >> 52;\n-  up -= lo;\n-  up = (int32_t)up;\n-  lui(Rd, up);\n-  addi(Rd, Rd, lo);\n-\n-  \/\/ Load the rest 32 bits.\n-  slli(Rd, Rd, 12);\n-  addi(Rd, Rd, (int32_t)lower >> 20);\n-  slli(Rd, Rd, 12);\n-  lower = ((int32_t)imm << 12) >> 20;\n-  addi(Rd, Rd, lower);\n-  slli(Rd, Rd, 8);\n-  lower = imm & 0xff;\n-  addi(Rd, Rd, lower);\n-}\n-\n@@ -1318,21 +1290,0 @@\n-static int patch_imm_in_li64(address branch, address target) {\n-  const int LI64_INSTRUCTIONS_NUM = 8;                                          \/\/ lui + addi + slli + addi + slli + addi + slli + addi\n-  int64_t lower = (intptr_t)target & 0xffffffff;\n-  lower = lower - ((lower << 44) >> 44);\n-  int64_t tmp_imm = ((uint64_t)((intptr_t)target & 0xffffffff00000000)) + (uint64_t)lower;\n-  int32_t upper =  (tmp_imm - (int32_t)lower) >> 32;\n-  int64_t tmp_upper = upper, tmp_lower = upper;\n-  tmp_lower = (tmp_lower << 52) >> 52;\n-  tmp_upper -= tmp_lower;\n-  tmp_upper >>= 12;\n-  \/\/ Load upper 32 bits. Upper = target[63:32], but if target[31] = 1 or (target[31:20] == 0x7ff && target[19] == 1),\n-  \/\/ upper = target[63:32] + 1.\n-  Assembler::patch(branch + 0,  31, 12, tmp_upper & 0xfffff);                       \/\/ Lui.\n-  Assembler::patch(branch + 4,  31, 20, tmp_lower & 0xfff);                         \/\/ Addi.\n-  \/\/ Load the rest 32 bits.\n-  Assembler::patch(branch + 12, 31, 20, ((int32_t)lower >> 20) & 0xfff);            \/\/ Addi.\n-  Assembler::patch(branch + 20, 31, 20, (((intptr_t)target << 44) >> 52) & 0xfff);  \/\/ Addi.\n-  Assembler::patch(branch + 28, 31, 20, (intptr_t)target & 0xff);                   \/\/ Addi.\n-  return LI64_INSTRUCTIONS_NUM * NativeInstruction::instruction_size;\n-}\n-\n@@ -1393,10 +1344,0 @@\n-static address get_target_of_li64(address insn_addr) {\n-  assert_cond(insn_addr != NULL);\n-  intptr_t target_address = (((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr), 31, 12)) & 0xfffff) << 44; \/\/ Lui.\n-  target_address += ((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr + 4), 31, 20)) << 32;                 \/\/ Addi.\n-  target_address += ((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr + 12), 31, 20)) << 20;                \/\/ Addi.\n-  target_address += ((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr + 20), 31, 20)) << 8;                 \/\/ Addi.\n-  target_address += ((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr + 28), 31, 20));                      \/\/ Addi.\n-  return (address)target_address;\n-}\n-\n@@ -1423,2 +1364,0 @@\n-  } else if (NativeInstruction::is_li64_at(branch)) {                 \/\/ li64\n-    return patch_imm_in_li64(branch, target);\n@@ -1450,2 +1389,0 @@\n-  } else if (NativeInstruction::is_li64_at(insn_addr)) {             \/\/ li64\n-    return get_target_of_li64(insn_addr);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":0,"deletions":63,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -682,1 +682,0 @@\n-  void li64(Register Rd, int64_t imm);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -106,12 +106,0 @@\n-bool NativeInstruction::is_li64_at(address instr) {\n-  return is_lui_at(instr) && \/\/ lui\n-         is_addi_at(instr + instruction_size) && \/\/ addi\n-         is_slli_shift_at(instr + instruction_size * 2, 12) &&  \/\/ Slli Rd, Rs, 12\n-         is_addi_at(instr + instruction_size * 3) && \/\/ addi\n-         is_slli_shift_at(instr + instruction_size * 4, 12) &&  \/\/ Slli Rd, Rs, 12\n-         is_addi_at(instr + instruction_size * 5) && \/\/ addi\n-         is_slli_shift_at(instr + instruction_size * 6, 8) &&   \/\/ Slli Rd, Rs, 8\n-         is_addi_at(instr + instruction_size * 7) && \/\/ addi\n-         check_li64_data_dependency(instr);\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -117,34 +117,0 @@\n-  \/\/ the instruction sequence of li64 is as below:\n-  \/\/     lui\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  static bool check_li64_data_dependency(address instr) {\n-    address lui = instr;\n-    address addi1 = lui + instruction_size;\n-    address slli1 = addi1 + instruction_size;\n-    address addi2 = slli1 + instruction_size;\n-    address slli2 = addi2 + instruction_size;\n-    address addi3 = slli2 + instruction_size;\n-    address slli3 = addi3 + instruction_size;\n-    address addi4 = slli3 + instruction_size;\n-    return extract_rs1(addi1) == extract_rd(lui) &&\n-           extract_rs1(addi1) == extract_rd(addi1) &&\n-           extract_rs1(slli1) == extract_rd(addi1) &&\n-           extract_rs1(slli1) == extract_rd(slli1) &&\n-           extract_rs1(addi2) == extract_rd(slli1) &&\n-           extract_rs1(addi2) == extract_rd(addi2) &&\n-           extract_rs1(slli2) == extract_rd(addi2) &&\n-           extract_rs1(slli2) == extract_rd(slli2) &&\n-           extract_rs1(addi3) == extract_rd(slli2) &&\n-           extract_rs1(addi3) == extract_rd(addi3) &&\n-           extract_rs1(slli3) == extract_rd(addi3) &&\n-           extract_rs1(slli3) == extract_rd(slli3) &&\n-           extract_rs1(addi4) == extract_rd(slli3) &&\n-           extract_rs1(addi4) == extract_rd(addi4);\n-  }\n-\n@@ -185,1 +151,0 @@\n-  static bool is_li64_at(address instr);\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -87,2 +87,2 @@\n-reg_def R2      ( NS,  SOE, Op_RegI, 2,  x2->as_VMReg()         ); \/\/ sp\n-reg_def R2_H    ( NS,  SOE, Op_RegI, 2,  x2->as_VMReg()->next() );\n+reg_def R2      ( NS,  NS,  Op_RegI, 2,  x2->as_VMReg()         ); \/\/ sp\n+reg_def R2_H    ( NS,  NS,  Op_RegI, 2,  x2->as_VMReg()->next() );\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -761,4 +761,10 @@\n-\/\/ On 64 bit we will store integer like items to the stack as\n-\/\/ 64 bits items (riscv64 abi) even though java would only store\n-\/\/ 32bits for a parameter. On 32bit it will simply be 32 bits\n-\/\/ So this routine will do 32->32 on 32bit and 32->64 on 64bit\n+\/\/ The C ABI specifies:\n+\/\/ \"integer scalars narrower than XLEN bits are widened according to the sign\n+\/\/ of their type up to 32 bits, then sign-extended to XLEN bits.\"\n+\/\/ Applies for both passed in register and stack.\n+\/\/\n+\/\/ Java uses 32-bit stack slots; jint, jshort, jchar, jbyte uses one slot.\n+\/\/ Native uses 64-bit stack slots for all integer scalar types.\n+\/\/\n+\/\/ lw loads the Java stack slot, sign-extends and\n+\/\/ sd store this widened integer into a 64 bit native stack slot.\n@@ -769,1 +775,1 @@\n-      __ ld(t0, Address(fp, reg2offset_in(src.first())));\n+      __ lw(t0, Address(fp, reg2offset_in(src.first())));\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3328,1 +3328,1 @@\n-void Assembler::nop(int i) {\n+void Assembler::nop(uint i) {\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1647,1 +1647,1 @@\n-  void nop(int i = 1);\n+  void nop(uint i = 1);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1178,1 +1178,1 @@\n-  align(64, (unsigned long long) pc());\n+  align(64, (uint)(uintptr_t)pc());\n@@ -1182,1 +1182,1 @@\n-  align(32, (unsigned long long) pc());\n+  align(32, (uint)(uintptr_t)pc());\n@@ -1185,1 +1185,1 @@\n-void MacroAssembler::align(int modulus) {\n+void MacroAssembler::align(uint modulus) {\n@@ -1187,1 +1187,1 @@\n-  assert(modulus <= CodeEntryAlignment, \"Alignment must be <= CodeEntryAlignment\");\n+  assert(modulus <= (uintx)CodeEntryAlignment, \"Alignment must be <= CodeEntryAlignment\");\n@@ -1191,1 +1191,1 @@\n-void MacroAssembler::align(int modulus, int target) {\n+void MacroAssembler::align(uint modulus, uint target) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -199,2 +199,2 @@\n-  void align(int modulus);\n-  void align(int modulus, int target);\n+  void align(uint modulus);\n+  void align(uint modulus, uint target);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3355,1 +3355,2 @@\n-  assert(aligned_base != NULL, \"Did not manage to re-map after %d attempts?\", max_attempts);\n+  assert(aligned_base != nullptr,\n+      \"Did not manage to re-map after %d attempts (size %zu, alignment %zu, file descriptor %d)\", max_attempts, size, alignment, file_desc);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -555,0 +555,15 @@\n+  \/\/ Method::clear_jmethod_ids only sets the jmethod_ids to NULL without\n+  \/\/ releasing the memory for related JNIMethodBlocks and JNIMethodBlockNodes.\n+  \/\/ This is done intentionally because native code (e.g. JVMTI agent) holding\n+  \/\/ jmethod_ids may access them after the associated classes and class loader\n+  \/\/ are unloaded. The Java Native Interface Specification says \"method ID\n+  \/\/ does not prevent the VM from unloading the class from which the ID has\n+  \/\/ been derived. After the class is unloaded, the method or field ID becomes\n+  \/\/ invalid\". In real world usages, the native code may rely on jmethod_ids\n+  \/\/ being NULL after class unloading. Hence, it is unsafe to free the memory\n+  \/\/ from the VM side without knowing when native code is going to stop using\n+  \/\/ them.\n+  if (_jmethod_ids != NULL) {\n+    Method::clear_jmethod_ids(this);\n+  }\n+\n@@ -699,14 +714,1 @@\n-  \/\/ Method::clear_jmethod_ids only sets the jmethod_ids to NULL without\n-  \/\/ releasing the memory for related JNIMethodBlocks and JNIMethodBlockNodes.\n-  \/\/ This is done intentionally because native code (e.g. JVMTI agent) holding\n-  \/\/ jmethod_ids may access them after the associated classes and class loader\n-  \/\/ are unloaded. The Java Native Interface Specification says \"method ID\n-  \/\/ does not prevent the VM from unloading the class from which the ID has\n-  \/\/ been derived. After the class is unloaded, the method or field ID becomes\n-  \/\/ invalid\". In real world usages, the native code may rely on jmethod_ids\n-  \/\/ being NULL after class unloading. Hence, it is unsafe to free the memory\n-  \/\/ from the VM side without knowing when native code is going to stop using\n-  \/\/ them.\n-  if (_jmethod_ids != NULL) {\n-    Method::clear_jmethod_ids(this);\n-  }\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -44,1 +44,5 @@\n-\n+  if (is_full_gc) {\n+    \/\/ Explicit Full GC would do the clearing of soft-refs as well\n+    \/\/ So reset in the beginning\n+    soft_ref_policy->set_should_clear_all_soft_refs(false);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/gcOverheadChecker.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -897,1 +897,5 @@\n-  ShenandoahHeapLocker locker(lock());\n+  \/\/ If we are dealing with mutator allocation, then we may need to block for safepoint.\n+  \/\/ We cannot block for safepoint for GC allocations, because there is a high chance\n+  \/\/ we are already running at safepoint or from stack watermark machinery, and we cannot\n+  \/\/ block again.\n+  ShenandoahHeapLocker locker(lock(), req.is_mutator_alloc());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -34,0 +35,47 @@\n+void ShenandoahLock::contended_lock(bool allow_block_for_safepoint) {\n+  Thread* thread = Thread::current();\n+  if (allow_block_for_safepoint && thread->is_Java_thread()) {\n+    contended_lock_internal<true>(thread->as_Java_thread());\n+  } else {\n+    contended_lock_internal<false>(nullptr);\n+  }\n+}\n+\n+template<bool ALLOW_BLOCK>\n+void ShenandoahLock::contended_lock_internal(JavaThread* java_thread) {\n+  assert(!ALLOW_BLOCK || java_thread != nullptr, \"Must have a Java thread when allowing block.\");\n+  \/\/ Spin this much, but only on multi-processor systems.\n+  int ctr = os::is_MP() ? 0xFF : 0;\n+  \/\/ Apply TTAS to avoid more expensive CAS calls if the lock is still held by other thread.\n+  while (Atomic::load(&_state) == locked ||\n+         Atomic::cmpxchg(&_state, unlocked, locked) != unlocked) {\n+    if (ctr > 0 && !SafepointSynchronize::is_synchronizing()) {\n+      \/\/ Lightly contended, spin a little if no safepoint is pending.\n+      SpinPause();\n+      ctr--;\n+    } else if (ALLOW_BLOCK) {\n+      ThreadBlockInVM block(java_thread);\n+      if (SafepointSynchronize::is_synchronizing()) {\n+        \/\/ If safepoint is pending, we want to block and allow safepoint to proceed.\n+        \/\/ Normally, TBIVM above would block us in its destructor.\n+        \/\/\n+        \/\/ But that blocking only happens when TBIVM knows the thread poll is armed.\n+        \/\/ There is a window between announcing a safepoint and arming the thread poll\n+        \/\/ during which trying to continuously enter TBIVM is counter-productive.\n+        \/\/ Under high contention, we may end up going in circles thousands of times.\n+        \/\/ To avoid it, we wait here until local poll is armed and then proceed\n+        \/\/ to TBVIM exit for blocking. We do not SpinPause, but yield to let\n+        \/\/ VM thread to arm the poll sooner.\n+        while (SafepointSynchronize::is_synchronizing() &&\n+               !SafepointMechanism::local_poll_armed(java_thread)) {\n+          os::naked_yield();\n+        }\n+      } else {\n+        os::naked_yield();\n+      }\n+    } else {\n+      os::naked_yield();\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  volatile int _state;\n+  volatile LockState _state;\n@@ -40,1 +40,1 @@\n-  volatile Thread* _owner;\n+  Thread* volatile _owner;\n@@ -43,0 +43,2 @@\n+  template<bool ALLOW_BLOCK>\n+  void contended_lock_internal(JavaThread* java_thread);\n@@ -46,10 +48,14 @@\n-  void lock() {\n-#ifdef ASSERT\n-    assert(_owner != Thread::current(), \"reentrant locking attempt, would deadlock\");\n-#endif\n-    Thread::SpinAcquire(&_state, \"Shenandoah Heap Lock\");\n-#ifdef ASSERT\n-    assert(_state == locked, \"must be locked\");\n-    assert(_owner == NULL, \"must not be owned\");\n-    _owner = Thread::current();\n-#endif\n+  void lock(bool allow_block_for_safepoint) {\n+    assert(Atomic::load(&_owner) != Thread::current(), \"reentrant locking attempt, would deadlock\");\n+\n+    if ((allow_block_for_safepoint && SafepointSynchronize::is_synchronizing()) ||\n+        (Atomic::cmpxchg(&_state, unlocked, locked) != unlocked)) {\n+      \/\/ 1. Java thread, and there is a pending safepoint. Dive into contended locking\n+      \/\/    immediately without trying anything else, and block.\n+      \/\/ 2. Fast lock fails, dive into contended lock handling.\n+      contended_lock(allow_block_for_safepoint);\n+    }\n+\n+    assert(Atomic::load(&_state) == locked, \"must be locked\");\n+    assert(Atomic::load(&_owner) == NULL, \"must not be owned\");\n+    DEBUG_ONLY(Atomic::store(&_owner, Thread::current());)\n@@ -59,5 +65,4 @@\n-#ifdef ASSERT\n-    assert (_owner == Thread::current(), \"sanity\");\n-    _owner = NULL;\n-#endif\n-    Thread::SpinRelease(&_state);\n+    assert(Atomic::load(&_owner) == Thread::current(), \"sanity\");\n+    DEBUG_ONLY(Atomic::store(&_owner, (Thread*)NULL);)\n+    OrderAccess::fence();\n+    Atomic::store(&_state, unlocked);\n@@ -66,0 +71,2 @@\n+  void contended_lock(bool allow_block_for_safepoint);\n+\n@@ -80,1 +87,1 @@\n-  ShenandoahLocker(ShenandoahLock* lock) : _lock(lock) {\n+  ShenandoahLocker(ShenandoahLock* lock, bool allow_block_for_safepoint = false) : _lock(lock) {\n@@ -82,1 +89,1 @@\n-      _lock->lock();\n+      _lock->lock(allow_block_for_safepoint);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.hpp","additions":26,"deletions":19,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -1054,1 +1054,1 @@\n-  <Event name=\"ZAllocationStall\" category=\"Java Virtual Machine, GC, Detailed\" label=\"ZGC Allocation Stall\" description=\"Time spent waiting for memory to become available\" thread=\"true\">\n+  <Event name=\"ZAllocationStall\" category=\"Java Virtual Machine, GC, Detailed\" label=\"ZGC Allocation Stall\" description=\"Time spent waiting for memory to become available\" thread=\"true\" stackTrace=\"true\">\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,3 @@\n-    memcpy(innerp, ptr, len);\n+    if (ptr != nullptr) {\n+      memcpy(innerp, ptr, len);\n+    }\n","filename":"src\/hotspot\/share\/memory\/guardedMemory.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3430,5 +3430,7 @@\n-  st->print(BULLET\"default_methods:   \"); default_methods()->print_value_on(st);      st->cr();\n-  if (Verbose && default_methods() != NULL) {\n-    Array<Method*>* method_array = default_methods();\n-    for (int i = 0; i < method_array->length(); i++) {\n-      st->print(\"%d : \", i); method_array->at(i)->print_value(); st->cr();\n+  if (default_methods() != nullptr) {\n+    st->print(BULLET\"default_methods:   \"); default_methods()->print_value_on(st);    st->cr();\n+    if (Verbose) {\n+      Array<Method*>* method_array = default_methods();\n+      for (int i = 0; i < method_array->length(); i++) {\n+        st->print(\"%d : \", i); method_array->at(i)->print_value(); st->cr();\n+      }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2245,1 +2245,1 @@\n-  if (o == NULL || o == JNIMethodBlock::_free_method || !((Metadata*)o)->is_method()) {\n+  if (o == NULL || o == JNIMethodBlock::_free_method) {\n@@ -2248,1 +2248,6 @@\n-  return o;\n+  \/\/ Method should otherwise be valid. Assert for testing.\n+  assert(is_valid_method(o), \"should be valid jmethodid\");\n+  \/\/ If the method's class holder object is unreferenced, but not yet marked as\n+  \/\/ unloaded, we need to return NULL here too because after a safepoint, its memory\n+  \/\/ will be reclaimed.\n+  return o->method_holder()->is_loader_alive() ? o : NULL;\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -133,7 +133,3 @@\n-  jlong byte_offset = field_offset_to_byte_offset(field_offset);\n-\n-  if (sizeof(char*) == sizeof(jint)) {   \/\/ (this constant folds!)\n-    return cast_from_oop<address>(p) + (jint) byte_offset;\n-  } else {\n-    return cast_from_oop<address>(p) +        byte_offset;\n-  }\n+  uintptr_t base_address = cast_from_oop<uintptr_t>(p);\n+  uintptr_t byte_offset  = (uintptr_t)field_offset_to_byte_offset(field_offset);\n+  return (void*)(base_address + byte_offset);\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -432,1 +432,1 @@\n-    bool unused;\n+    bool unused = false;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+#include \"utilities\/events.hpp\"\n@@ -413,0 +414,2 @@\n+  Events::log(thread, \"Before exit entered\");\n+\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3402,4 +3402,4 @@\n-\/\/ vm_exit() when the program calls System.exit() to return a value or when\n-\/\/ there is a serious error in VM. The two shutdown paths are not exactly\n-\/\/ the same, but they share Shutdown.shutdown() at Java level and before_exit()\n-\/\/ and VM_Exit op at VM level.\n+\/\/ vm_exit(), when the program calls System.exit() to return a value, or when\n+\/\/ there is a serious error in VM.\n+\/\/ These two separate shutdown paths are not exactly the same, but they share\n+\/\/ Shutdown.shutdown() at Java level and before_exit() and VM_Exit op at VM level.\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -273,0 +273,1 @@\n+    if (_data == nullptr) return;\n@@ -277,0 +278,1 @@\n+    if (_data == nullptr) return;\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import java.util.Objects;\n@@ -639,1 +638,6 @@\n-        String[] as = Objects.requireNonNullElse(aliases, zeroAliases);\n+        String[] as =\n+            aliases == null ?\n+                zeroAliases :\n+                VM.isSystemDomainLoader(getClass().getClassLoader()) ?\n+                    aliases :\n+                    Arrays.copyOf(aliases, aliases.length);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/charset\/Charset.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -809,1 +809,1 @@\n-            if (!isDirectory(dir, LinkOption.NOFOLLOW_LINKS))\n+            if (!isDirectory(dir))\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Files.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1973,4 +1973,4 @@\n-            debug.println(\"X509CertSelector.match(SN: \"\n-                + (xcert.getSerialNumber()).toString(16) + \"\\n  Issuer: \"\n-                + xcert.getIssuerX500Principal() + \"\\n  Subject: \" + xcert.getSubjectX500Principal()\n-                + \")\");\n+            debug.println(\"X509CertSelector.match(Serial number: \"\n+                + Debug.toString(xcert.getSerialNumber())\n+                + \"\\n  Issuer: \" + xcert.getIssuerX500Principal() + \"\\n  Subject: \"\n+                + xcert.getSubjectX500Principal() + \")\");\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/X509CertSelector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1663,0 +1663,3 @@\n+                if (end.cenlen + ENDHDR >= Integer.MAX_VALUE) {\n+                    zerror(\"invalid END header (central directory size too large)\");\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -291,1 +291,2 @@\n-    static final String acceptString = \"*\/*\";\n+    static final String acceptString =\n+        \"text\/html, image\/gif, image\/jpeg, *\/*; q=0.2\";\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpURLConnection.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -189,1 +189,7 @@\n-            return n + implRead(cbuf, off, off + len);\n+            \/\/ Read remaining characters\n+            int nr = implRead(cbuf, off, off + len);\n+\n+            \/\/ At this point, n is either 1 if a leftover character was read,\n+            \/\/ or 0 if no leftover character was read. If n is 1 and nr is -1,\n+            \/\/ indicating EOF, then we don't return their sum as this loses data.\n+            return (nr < 0) ? (n == 1 ? 1 : nr) : (n + nr);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/StreamDecoder.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import sun.security.util.Debug;\n@@ -108,1 +109,1 @@\n-            String serNum = x509.getSerialNumber().toString(16);\n+            String serNum = Debug.toString(x509.getSerialNumber());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/JCAUtil.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -701,2 +701,2 @@\n-                token.getSerialNumber() + \") generated on \" + token.getDate() +\n-                \" is inapplicable\");\n+                Debug.toString(token.getSerialNumber()) +\n+                \") generated on \" + token.getDate() + \" is inapplicable\");\n@@ -708,1 +708,2 @@\n-                token.getSerialNumber() + \") generated on \" + token.getDate());\n+                Debug.toString(token.getSerialNumber()) +\n+                \") generated on \" + token.getDate());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/SignerInfo.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -247,1 +247,1 @@\n-                currCert.getSerialNumber().toString());\n+                Debug.toString(currCert.getSerialNumber()));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/BasicChecker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -438,2 +438,1 @@\n-                        \"\\n  SN: \" + Debug.toHexString(\n-                                            targetCert.getSerialNumber()) +\n+                        \"\\n  SN: \" + Debug.toString(targetCert.getSerialNumber()) +\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/Builder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-            System.out.println(\"SerialNumber is \" + serialNumber.getNumber());\n+            System.out.println(\"SerialNumber is \" + Debug.toString(serialNumber.getNumber()));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/CertId.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -352,1 +352,1 @@\n-                \"\\n  SN: \" + Debug.toHexString(certImpl.getSerialNumber()) +\n+                \"\\n  SN: \" + Debug.toString(certImpl.getSerialNumber()) +\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/DistributionPointFetcher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -283,1 +283,1 @@\n-                            Debug.toHexString(trustedCert.getSerialNumber()) +\n+                            Debug.toString(trustedCert.getSerialNumber()) +\n@@ -706,1 +706,1 @@\n-                + Debug.toHexString(cert.getSerialNumber())\n+                + Debug.toString(cert.getSerialNumber())\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/ForwardBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -407,1 +407,2 @@\n-                    certId.getSerialNumber() + \") is: \" + sr.getCertStatus());\n+                    Debug.toString(certId.getSerialNumber()) +\n+                    \") is: \" + sr.getCertStatus());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/OCSPResponse.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -354,1 +354,1 @@\n-                \"\\n  SN: \" + Debug.toHexString(xcert.getSerialNumber()) +\n+                \"\\n  SN: \" + Debug.toString(xcert.getSerialNumber()) +\n@@ -650,1 +650,1 @@\n-                          \" cert SN: \" + sn.toString());\n+                          \" cert SN: \" + Debug.toString(sn));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/RevocationChecker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,1 +153,1 @@\n-                 (x509Cert.getSerialNumber().toString(16)).append(\"\\n\");\n+                 (Debug.toString(x509Cert.getSerialNumber())).append(\"\\n\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/Vertex.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+import sun.security.util.Debug;\n@@ -474,2 +475,1 @@\n-                        Utilities.toHexString(\n-                                x509.getSerialNumber().toByteArray()),\n+                        Debug.toString(x509.getSerialNumber()),\n@@ -499,2 +499,1 @@\n-                        Utilities.toHexString(\n-                                x509.getSerialNumber().toByteArray()),\n+                        Debug.toString(x509.getSerialNumber()),\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLLogger.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+import sun.security.util.Debug;\n@@ -422,2 +423,2 @@\n-                    \"Check cache for SN\" + cid.getSerialNumber() + \": \" +\n-                    (respEntry != null ? \"HIT\" : \"MISS\"));\n+                    \"Check cache for SN\" + Debug.toString(cid.getSerialNumber())\n+                        + \": \" + (respEntry != null ? \"HIT\" : \"MISS\"));\n@@ -519,1 +520,1 @@\n-            sb.append(\"\\n\\tSerial: \").append(this.cert.getSerialNumber());\n+            sb.append(\"\\n\\tSerial: \").append(Debug.toString(this.cert.getSerialNumber()));\n@@ -566,1 +567,1 @@\n-                            cid.getSerialNumber());\n+                            Debug.toString(cid.getSerialNumber()));\n@@ -617,1 +618,1 @@\n-                    statInfo.cid.getSerialNumber());\n+                    Debug.toString(statInfo.cid.getSerialNumber()));\n@@ -709,1 +710,1 @@\n-                        certId.getSerialNumber() +\n+                        Debug.toString(certId.getSerialNumber()) +\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/StatusResponseManager.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -432,2 +432,11 @@\n-            checkIdentity(peerHost,\n-                    trustedChain[0], algorithm, chainsToPublicCA);\n+            try {\n+                checkIdentity(peerHost,\n+                        trustedChain[0], algorithm, chainsToPublicCA);\n+            } catch(CertificateException ce) {\n+                if (checkClientTrusted && \"HTTPS\".equalsIgnoreCase(algorithm)) {\n+                    throw new CertificateException(\"Endpoint Identification Algorithm \" +\n+                            \"HTTPS is not supported on the server side\");\n+                } else {\n+                    throw ce;\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509TrustManagerImpl.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1128,1 +1128,0 @@\n-        KeyStore cakstore = buildTrustedCerts();\n@@ -1137,0 +1136,1 @@\n+            KeyStore cakstore = buildTrustedCerts();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Main.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -401,0 +401,4 @@\n+    public static String toString(BigInteger b) {\n+        return toString(b.toByteArray());\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Debug.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2002, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.HexFormat;\n@@ -104,1 +105,1 @@\n-        return \"SerialNumber: [\" + Debug.toHexString(serialNum) + ']';\n+        return \"SerialNumber: \" + Debug.toString(serialNum);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/SerialNumber.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -14,1 +14,1 @@\n-https:\/\/raw.githubusercontent.com\/publicsuffix\/list\/b5bf572c52988dbe9d865b8f090ea819024a9936\/public_suffix_list.dat.\n+https:\/\/raw.githubusercontent.com\/publicsuffix\/list\/1cbd6e71a9b83620b1d0b11e49d3d9ff48c27e22\/public_suffix_list.dat.\n","filename":"src\/java.base\/share\/legal\/public_suffix.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -565,2 +565,11 @@\n-    memcpy(buf+offset, c->pdir, sp.dirlen);\n-    offset += sp.dirlen;\n+    if (c->pdir != NULL) {\n+        if (sp.dirlen > 0) {\n+            memcpy(buf+offset, c->pdir, sp.dirlen);\n+            offset += sp.dirlen;\n+        }\n+    } else {\n+        if (sp.dirlen > 0) {\n+            free(buf);\n+            return -1;\n+        }\n+    }\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessImpl_md.c","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -706,0 +706,2 @@\n+        \/\/ statx is not allowed on the old Docker versions and returns EPERM,\n+        \/\/ fallback to stat64 in this case\n@@ -709,1 +711,2 @@\n-        } else {\n+            return;\n+        } else if (errno != EPERM) {\n@@ -711,0 +714,1 @@\n+            return;\n@@ -712,2 +716,0 @@\n-        \/\/ statx was available, so return now\n-        return;\n@@ -737,0 +739,2 @@\n+        \/\/ statx is not allowed on the old Docker versions and returns EPERM,\n+        \/\/ fallback to stat64 in this case\n@@ -740,1 +744,1 @@\n-        } else {\n+        } else if (errno != EPERM) {\n@@ -767,0 +771,2 @@\n+        \/\/ statx is not allowed on the old Docker versions and returns EPERM,\n+        \/\/ fallback to lstat64 in this case\n@@ -770,1 +776,2 @@\n-        } else {\n+            return;\n+        } else if (errno != EPERM) {\n@@ -772,0 +779,1 @@\n+            return;\n@@ -773,2 +781,0 @@\n-        \/\/ statx was available, so return now\n-        return;\n@@ -799,0 +805,2 @@\n+        \/\/ statx is not allowed on the old Docker versions and returns EPERM,\n+        \/\/ fallback to fstat64 in this case\n@@ -802,1 +810,2 @@\n-        } else {\n+            return;\n+        } else if (errno != EPERM) {\n@@ -804,0 +813,1 @@\n+            return;\n@@ -805,2 +815,0 @@\n-        \/\/ statx was available, so return now\n-        return;\n@@ -834,0 +842,2 @@\n+        \/\/ statx is not allowed on the old Docker versions and returns EPERM,\n+        \/\/ fallback to fstatat64 in this case\n@@ -837,1 +847,2 @@\n-        } else {\n+            return;\n+        } else if (errno != EPERM) {\n@@ -839,0 +850,1 @@\n+            return;\n@@ -840,2 +852,0 @@\n-        \/\/ statx was available, so return now\n-        return;\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":23,"deletions":13,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -377,0 +377,11 @@\n+        \/\/ check file exists only\n+        if (!(r || w || x)) {\n+            file.checkRead();\n+            try {\n+                WindowsFileAttributes.get(file, true);\n+                return;\n+            } catch (WindowsException exc) {\n+                exc.rethrowAsIOException(file);\n+            }\n+        }\n+\n@@ -378,1 +389,1 @@\n-        \/\/ access to file; default if modes not specified\n+        \/\/ access to file\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileSystemProvider.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,2 +28,5 @@\n-import java.io.*;\n-import java.util.*;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n@@ -37,0 +40,2 @@\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n@@ -114,5 +119,1 @@\n-            try {\n-                pathBytes = absolutePath.getBytes(\"UTF-8\");\n-            } catch (final UnsupportedEncodingException e) {\n-                pathBytes = new byte[0];\n-            }\n+            pathBytes = absolutePath.getBytes(UTF_8);\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaFileView.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-\n@@ -3,1 +2,1 @@\n- * Copyright (c) 2011, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,5 +28,6 @@\n-import java.awt.*;\n-\n-import java.io.*;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n+import java.awt.Image;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n@@ -38,5 +38,11 @@\n-import java.util.*;\n-import java.util.regex.*;\n-import java.awt.datatransfer.*;\n-import java.nio.charset.StandardCharsets;\n-import sun.awt.datatransfer.*;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import sun.awt.datatransfer.DataTransferer;\n+import sun.awt.datatransfer.ToolkitThreadBlockedHandler;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n@@ -136,1 +142,1 @@\n-                    charset = new String((byte[]) transferable.getTransferData(javaTextEncodingFlavor), StandardCharsets.UTF_8);\n+                    charset = new String((byte[]) transferable.getTransferData(javaTextEncodingFlavor), UTF_8);\n@@ -163,1 +169,2 @@\n-            bytes = Normalizer.normalize(new String(bytes, \"UTF8\"), Form.NFC).getBytes(\"UTF8\");\n+            String src = new String(bytes, UTF_8);\n+            bytes = Normalizer.normalize(src, Form.NFC).getBytes(UTF_8);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CDataTransferer.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.awt.event.WindowStateListener;\n@@ -967,0 +968,27 @@\n+    private void waitForWindowState(int state) {\n+        if (peer.getState() == state) {\n+            return;\n+        }\n+\n+        Object lock = new Object();\n+        WindowStateListener wsl = new WindowStateListener() {\n+            public void windowStateChanged(WindowEvent e) {\n+                synchronized (lock) {\n+                    if (e.getNewState() == state) {\n+                        lock.notifyAll();\n+                    }\n+                }\n+            }\n+        };\n+\n+        target.addWindowStateListener(wsl);\n+        if (peer.getState() != state) {\n+            synchronized (lock) {\n+                try {\n+                    lock.wait();\n+                } catch (InterruptedException ie) {}\n+            }\n+        }\n+        target.removeWindowStateListener(wsl);\n+    }\n+\n@@ -988,0 +1016,1 @@\n+                    waitForWindowState(Frame.NORMAL);\n@@ -995,0 +1024,2 @@\n+                    waitForWindowState(Frame.NORMAL);\n+\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CPlatformWindow.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import java.io.Closeable;\n+import java.io.Externalizable;\n+import java.io.Serializable;\n@@ -32,0 +35,1 @@\n+import java.util.Arrays;\n@@ -35,0 +39,1 @@\n+import java.util.Set;\n@@ -40,0 +45,12 @@\n+\n+    \/\/ These are some common interfaces that we know a priori\n+    \/\/ will not contain any bean property getters or setters.\n+    static final Set<Class<?>> IGNORABLE_INTERFACES = Set.of(\n+        AutoCloseable.class,\n+        Cloneable.class,\n+        Closeable.class,\n+        Comparable.class,\n+        Externalizable.class,\n+        Serializable.class\n+    );\n+\n@@ -69,0 +86,2 @@\n+\n+            \/\/ Add declared methods\n@@ -84,4 +103,13 @@\n-                        if (list == null) {\n-                            list = new ArrayList<>();\n-                        }\n-                        list.add(method);\n+                        (list = createIfNeeded(list)).add(method);\n+                    }\n+                }\n+            }\n+\n+            \/\/ Add default methods inherited from interfaces\n+            for (Class<?> iface : type.getInterfaces()) {\n+                if (IGNORABLE_INTERFACES.contains(iface)) {\n+                    continue;\n+                }\n+                for (Method method : iface.getMethods()) {\n+                    if (!Modifier.isAbstract(method.getModifiers())) {\n+                        (list = createIfNeeded(list)).add(method);\n@@ -99,0 +127,4 @@\n+    private static List<Method> createIfNeeded(List<Method> list) {\n+        return list != null ? list : new ArrayList<>();\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/beans\/introspect\/MethodInfo.java","additions":36,"deletions":4,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,5 +28,0 @@\n-import java.io.UnsupportedEncodingException;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-import javax.imageio.ImageTypeSpecifier;\n@@ -34,2 +29,0 @@\n-import javax.imageio.metadata.IIOMetadataNode;\n-import javax.imageio.metadata.IIOMetadataFormat;\n@@ -37,2 +30,1 @@\n-import org.w3c.dom.Node;\n-import com.sun.imageio.plugins.common.I18N;\n+import javax.imageio.metadata.IIOMetadataNode;\n@@ -40,0 +32,1 @@\n+import com.sun.imageio.plugins.common.I18N;\n@@ -41,0 +34,3 @@\n+import org.w3c.dom.Node;\n+\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n@@ -117,5 +113,1 @@\n-        try {\n-            return new String(data, \"ISO-8859-1\");\n-        } catch (UnsupportedEncodingException e) {\n-            return \"\";\n-        }\n+        return new String(data, ISO_8859_1);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/bmp\/BMPMetadata.java","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.io.UnsupportedEncodingException;\n-import java.util.ArrayList;\n@@ -32,1 +30,1 @@\n-import javax.imageio.ImageTypeSpecifier;\n+\n@@ -34,3 +32,0 @@\n-import javax.imageio.metadata.IIOMetadata;\n-import javax.imageio.metadata.IIOMetadataNode;\n-import javax.imageio.metadata.IIOMetadataFormat;\n@@ -38,0 +33,2 @@\n+import javax.imageio.metadata.IIOMetadataNode;\n+\n@@ -40,0 +37,2 @@\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+\n@@ -135,5 +134,1 @@\n-        try {\n-            return new String(data, \"ISO-8859-1\");\n-        } catch (UnsupportedEncodingException e) {\n-            return \"\";\n-        }\n+        return new String(data, ISO_8859_1);\n@@ -387,6 +382,1 @@\n-            String s = null;\n-            try {\n-                s = new String(comment, \"ISO-8859-1\");\n-            } catch (UnsupportedEncodingException e) {\n-                throw new RuntimeException(\"Encoding ISO-8859-1 unknown!\");\n-            }\n+            String s = new String(comment, ISO_8859_1);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/gif\/GIFImageMetadata.java","additions":8,"deletions":18,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.UnsupportedEncodingException;\n@@ -31,3 +30,1 @@\n-import java.util.Iterator;\n-import java.util.List;\n-import javax.imageio.ImageTypeSpecifier;\n+\n@@ -35,3 +32,0 @@\n-import javax.imageio.metadata.IIOMetadata;\n-import javax.imageio.metadata.IIOMetadataNode;\n-import javax.imageio.metadata.IIOMetadataFormat;\n@@ -39,0 +33,2 @@\n+import javax.imageio.metadata.IIOMetadataNode;\n+\n@@ -41,0 +37,2 @@\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+\n@@ -98,5 +96,1 @@\n-        try {\n-            return data.getBytes(\"ISO-8859-1\");\n-        } catch (UnsupportedEncodingException e) {\n-            return \"\".getBytes();\n-        }\n+        return data.getBytes(ISO_8859_1);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/gif\/GIFWritableImageMetadata.java","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.io.IOException;\n+\n+import javax.imageio.metadata.IIOInvalidTreeException;\n@@ -30,4 +33,0 @@\n-import javax.imageio.metadata.IIOInvalidTreeException;\n-\n-import java.io.IOException;\n-import java.io.UnsupportedEncodingException;\n@@ -37,0 +36,2 @@\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+\n@@ -48,1 +49,0 @@\n-    private static final String ENCODING = \"ISO-8859-1\";\n@@ -99,4 +99,1 @@\n-        try {\n-            return new String (data, ENCODING);\n-        } catch (UnsupportedEncodingException e) {}  \/\/ Won't happen\n-        return null;\n+        return new String(data, ISO_8859_1);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/COMMarkerSegment.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,12 +28,0 @@\n-import javax.imageio.IIOException;\n-import javax.imageio.IIOImage;\n-import javax.imageio.ImageTypeSpecifier;\n-import javax.imageio.ImageReader;\n-import javax.imageio.metadata.IIOInvalidTreeException;\n-import javax.imageio.metadata.IIOMetadataNode;\n-import javax.imageio.metadata.IIOMetadata;\n-import javax.imageio.stream.ImageInputStream;\n-import javax.imageio.stream.ImageOutputStream;\n-import javax.imageio.stream.MemoryCacheImageOutputStream;\n-import javax.imageio.event.IIOReadProgressListener;\n-\n@@ -41,2 +29,0 @@\n-import java.awt.color.ICC_Profile;\n-import java.awt.color.ICC_ColorSpace;\n@@ -44,0 +30,3 @@\n+import java.awt.color.ICC_ColorSpace;\n+import java.awt.color.ICC_Profile;\n+import java.awt.image.BufferedImage;\n@@ -45,2 +34,0 @@\n-import java.awt.image.SampleModel;\n-import java.awt.image.IndexColorModel;\n@@ -48,1 +35,0 @@\n-import java.awt.image.BufferedImage;\n@@ -51,0 +37,1 @@\n+import java.awt.image.IndexColorModel;\n@@ -52,0 +39,1 @@\n+import java.awt.image.SampleModel;\n@@ -53,1 +41,0 @@\n-import java.io.IOException;\n@@ -55,1 +42,1 @@\n-import java.util.List;\n+import java.io.IOException;\n@@ -58,0 +45,1 @@\n+import java.util.List;\n@@ -59,0 +47,12 @@\n+import javax.imageio.IIOException;\n+import javax.imageio.IIOImage;\n+import javax.imageio.ImageReader;\n+import javax.imageio.ImageTypeSpecifier;\n+import javax.imageio.event.IIOReadProgressListener;\n+import javax.imageio.metadata.IIOInvalidTreeException;\n+import javax.imageio.metadata.IIOMetadataNode;\n+import javax.imageio.stream.ImageInputStream;\n+import javax.imageio.stream.ImageOutputStream;\n+import javax.imageio.stream.MemoryCacheImageOutputStream;\n+\n+import org.w3c.dom.NamedNodeMap;\n@@ -61,1 +61,2 @@\n-import org.w3c.dom.NamedNodeMap;\n+\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n@@ -1356,1 +1357,1 @@\n-            byte [] id = ID.getBytes(\"US-ASCII\");\n+            byte[] id = ID.getBytes(US_ASCII);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/JFIFMarkerSegment.java","additions":22,"deletions":21,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.io.ByteArrayOutputStream;\n@@ -41,1 +42,0 @@\n-import java.io.InputStream;\n@@ -43,0 +43,1 @@\n+import java.io.InputStream;\n@@ -50,0 +51,1 @@\n+\n@@ -51,1 +53,0 @@\n-import javax.imageio.ImageReader;\n@@ -53,0 +54,1 @@\n+import javax.imageio.ImageReader;\n@@ -57,0 +59,1 @@\n+\n@@ -60,1 +63,0 @@\n-import java.io.ByteArrayOutputStream;\n@@ -63,0 +65,3 @@\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n@@ -489,1 +494,1 @@\n-            text = new String(inflate(b), \"UTF8\");\n+            text = new String(inflate(b), UTF_8);\n@@ -491,1 +496,1 @@\n-            text = new String(b, \"UTF8\");\n+            text = new String(b, UTF_8);\n@@ -592,1 +597,1 @@\n-        metadata.tEXt_text.add(new String(b, \"ISO-8859-1\"));\n+        metadata.tEXt_text.add(new String(b, ISO_8859_1));\n@@ -693,1 +698,1 @@\n-        metadata.zTXt_text.add(new String(inflate(b), \"ISO-8859-1\"));\n+        metadata.zTXt_text.add(new String(inflate(b), ISO_8859_1));\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/png\/PNGImageReader.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.awt.image.WritableRaster;\n@@ -34,0 +33,1 @@\n+import java.awt.image.WritableRaster;\n@@ -40,0 +40,1 @@\n+\n@@ -50,0 +51,3 @@\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n@@ -804,2 +808,1 @@\n-\n-            cs.write(translatedKeywordIter.next().getBytes(\"UTF8\"));\n+            cs.write(translatedKeywordIter.next().getBytes(UTF_8));\n@@ -810,1 +813,1 @@\n-                cs.write(deflate(text.getBytes(\"UTF8\")));\n+                cs.write(deflate(text.getBytes(UTF_8)));\n@@ -812,1 +815,1 @@\n-                cs.write(text.getBytes(\"UTF8\"));\n+                cs.write(text.getBytes(UTF_8));\n@@ -836,1 +839,1 @@\n-            cs.write(deflate(text.getBytes(\"ISO-8859-1\")));\n+            cs.write(deflate(text.getBytes(ISO_8859_1)));\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/png\/PNGImageWriter.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+\n@@ -29,1 +30,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -35,0 +35,1 @@\n+\n@@ -36,2 +37,0 @@\n-import javax.imageio.stream.ImageInputStream;\n-import javax.imageio.stream.ImageOutputStream;\n@@ -43,0 +42,4 @@\n+import javax.imageio.stream.ImageInputStream;\n+import javax.imageio.stream.ImageOutputStream;\n+\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n@@ -286,2 +289,1 @@\n-                                        index - prevIndex,\n-                                        StandardCharsets.US_ASCII);\n+                                        index - prevIndex, US_ASCII);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/tiff\/TIFFIFD.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -37,1 +38,0 @@\n-import java.awt.image.RenderedImage;\n@@ -39,0 +39,1 @@\n+import java.awt.image.RenderedImage;\n@@ -47,0 +48,1 @@\n+\n@@ -49,0 +51,1 @@\n+import javax.imageio.ImageTypeSpecifier;\n@@ -51,1 +54,0 @@\n-import javax.imageio.ImageTypeSpecifier;\n@@ -55,4 +57,0 @@\n-import javax.imageio.spi.ImageWriterSpi;\n-import javax.imageio.stream.ImageOutputStream;\n-import org.w3c.dom.Node;\n-import com.sun.imageio.plugins.common.ImageUtil;\n@@ -65,0 +63,4 @@\n+import javax.imageio.spi.ImageWriterSpi;\n+import javax.imageio.stream.ImageOutputStream;\n+\n+import com.sun.imageio.plugins.common.ImageUtil;\n@@ -67,1 +69,3 @@\n-import java.nio.charset.StandardCharsets;\n+import org.w3c.dom.Node;\n+\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n@@ -1515,1 +1519,1 @@\n-                         ExifTIFFTagSet.EXIF_VERSION_2_2.getBytes(StandardCharsets.US_ASCII));\n+                         ExifTIFFTagSet.EXIF_VERSION_2_2.getBytes(US_ASCII));\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/tiff\/TIFFImageWriter.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -28,5 +28,0 @@\n-import java.io.UnsupportedEncodingException;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-import javax.imageio.ImageTypeSpecifier;\n@@ -34,2 +29,0 @@\n-import javax.imageio.metadata.IIOMetadataNode;\n-import javax.imageio.metadata.IIOMetadataFormat;\n@@ -37,2 +30,1 @@\n-import org.w3c.dom.Node;\n-import com.sun.imageio.plugins.common.I18N;\n+import javax.imageio.metadata.IIOMetadataNode;\n@@ -40,0 +32,1 @@\n+import com.sun.imageio.plugins.common.I18N;\n@@ -41,0 +34,1 @@\n+import org.w3c.dom.Node;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/wbmp\/WBMPMetadata.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-package com.sun.java.swing.plaf.gtk;\n@@ -27,3 +26,1 @@\n-import sun.swing.SwingUtilities2;\n-import com.sun.java.swing.plaf.gtk.GTKConstants.ArrowType;\n-import com.sun.java.swing.plaf.gtk.GTKConstants.ShadowType;\n+package com.sun.java.swing.plaf.gtk;\n@@ -31,0 +28,48 @@\n+import java.awt.AlphaComposite;\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Composite;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.GradientPaint;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Insets;\n+import java.awt.LayoutManager;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Shape;\n+import java.awt.Stroke;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.PathIterator;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.geom.RectangularShape;\n+import java.awt.image.FilteredImageSource;\n+import java.awt.image.ImageProducer;\n+import java.awt.image.RGBImageFilter;\n+import java.io.BufferedInputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.StringTokenizer;\n+\n+import javax.swing.Icon;\n+import javax.swing.ImageIcon;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JInternalFrame;\n@@ -33,9 +78,6 @@\n-import javax.swing.plaf.synth.*;\n-\n-import java.awt.*;\n-import java.awt.geom.*;\n-import java.awt.image.*;\n-import java.io.*;\n-import java.net.*;\n-import java.security.*;\n-import java.util.*;\n+import javax.swing.plaf.synth.ColorType;\n+import javax.swing.plaf.synth.SynthConstants;\n+import javax.swing.plaf.synth.SynthContext;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n@@ -43,3 +85,6 @@\n-import javax.swing.*;\n-\n-import javax.xml.parsers.*;\n+import com.sun.java.swing.plaf.gtk.GTKConstants.ArrowType;\n+import com.sun.java.swing.plaf.gtk.GTKConstants.ShadowType;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.NamedNodeMap;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n@@ -47,1 +92,3 @@\n-import org.w3c.dom.*;\n+import sun.swing.SwingUtilities2;\n+\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n@@ -539,1 +586,2 @@\n-                    Reader reader = new InputStreamReader(url.openStream(), \"ISO-8859-1\");\n+                    Reader reader = new InputStreamReader(url.openStream(),\n+                                                          ISO_8859_1);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/Metacity.java","additions":66,"deletions":18,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+\n@@ -1150,1 +1152,1 @@\n-        int len = value.getBytes(\"ascii\").length;\n+        int len = value.getBytes(US_ASCII).length;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/DLSSoundbank.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+\n@@ -79,1 +81,1 @@\n-        this.fourcc = new String(fourcc, \"ascii\");\n+        this.fourcc = new String(fourcc, US_ASCII);\n@@ -86,1 +88,1 @@\n-            this.riff_type = new String(format, \"ascii\");\n+            this.riff_type = new String(format, US_ASCII);\n@@ -230,1 +232,1 @@\n-                return new String(buff, 0, i, \"ascii\");\n+                return new String(buff, 0, i, US_ASCII);\n@@ -233,1 +235,1 @@\n-        return new String(buff, \"ascii\");\n+        return new String(buff, US_ASCII);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/RIFFReader.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+\n@@ -211,1 +213,1 @@\n-            raf.write(\"RIFF\".getBytes(\"ascii\"));\n+            raf.write(\"RIFF\".getBytes(US_ASCII));\n@@ -213,1 +215,1 @@\n-            raf.write(\"LIST\".getBytes(\"ascii\"));\n+            raf.write(\"LIST\".getBytes(US_ASCII));\n@@ -215,1 +217,1 @@\n-            raf.write((format + \"    \").substring(0, 4).getBytes(\"ascii\"));\n+            raf.write((format + \"    \").substring(0, 4).getBytes(US_ASCII));\n@@ -223,2 +225,1 @@\n-            raf.write((format + \"    \").substring(0, 4).getBytes(\"ascii\"));\n-\n+            raf.write((format + \"    \").substring(0, 4).getBytes(US_ASCII));\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/RIFFWriter.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,2 @@\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+\n@@ -542,1 +544,1 @@\n-        int len = value.getBytes(\"ascii\").length;\n+        int len = value.getBytes(US_ASCII).length;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/SF2Soundbank.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -127,1 +127,4 @@\n-\n+            if (data.length < 3 || (data[1] & 0xFF) != 0x7E && (data[1] & 0xFF) != 0x7F ) {\n+                \/\/ Not enough data to determine SysEx type or SysEx type is not supported\n+                return;\n+            }\n@@ -132,0 +135,3 @@\n+                    if (data.length < 4) {\n+                        return;\n+                    }\n@@ -135,15 +141,21 @@\n-                    case 0x08:  \/\/ MIDI Tuning Standard\n-                        subid2 = data[4] & 0xFF;\n-                        switch (subid2) {\n-                        case 0x01:  \/\/ BULK TUNING DUMP\n-                        {\n-                            \/\/ http:\/\/www.midi.org\/about-midi\/tuning.shtml\n-                            SoftTuning tuning = synth.getTuning(new Patch(0,\n-                                    data[5] & 0xFF));\n-                            tuning.load(data);\n-                            break;\n-                        }\n-                        case 0x04:  \/\/ KEY-BASED TUNING DUMP\n-                        case 0x05:  \/\/ SCALE\/OCTAVE TUNING DUMP, 1 byte format\n-                        case 0x06:  \/\/ SCALE\/OCTAVE TUNING DUMP, 2 byte format\n-                        case 0x07:  \/\/ SINGLE NOTE TUNING CHANGE (NON REAL-TIME)\n+                        case 0x08:  \/\/ MIDI Tuning Standard\n+                            if (data.length < 5) {\n+                                break;\n+                            }\n+                            subid2 = data[4] & 0xFF;\n+                            switch (subid2) {\n+                                case 0x01:  \/\/ BULK TUNING DUMP\n+                                {\n+                                    if (data.length < 6) {\n+                                        break;\n+                                    }\n+                                    \/\/ http:\/\/www.midi.org\/about-midi\/tuning.shtml\n+                                    SoftTuning tuning = synth.getTuning(new Patch(0,\n+                                            data[5] & 0xFF));\n+                                    tuning.load(data);\n+                                    break;\n+                                }\n+                                case 0x04:  \/\/ KEY-BASED TUNING DUMP\n+                                case 0x05:  \/\/ SCALE\/OCTAVE TUNING DUMP, 1 byte format\n+                                case 0x06:  \/\/ SCALE\/OCTAVE TUNING DUMP, 2 byte format\n+                                case 0x07:  \/\/ SINGLE NOTE TUNING CHANGE (NON REAL-TIME)\n@@ -151,8 +163,11 @@\n-                        {\n-                            \/\/ http:\/\/www.midi.org\/about-midi\/tuning_extens.shtml\n-                            SoftTuning tuning = synth.getTuning(new Patch(\n-                                    data[5] & 0xFF, data[6] & 0xFF));\n-                            tuning.load(data);\n-                            break;\n-                        }\n-                        case 0x08:  \/\/ scale\/octave tuning 1-byte form (Non\n+                                {\n+                                    if (data.length < 7) {\n+                                        break;\n+                                    }\n+                                    \/\/ http:\/\/www.midi.org\/about-midi\/tuning_extens.shtml\n+                                    SoftTuning tuning = synth.getTuning(new Patch(\n+                                            data[5] & 0xFF, data[6] & 0xFF));\n+                                    tuning.load(data); \/\/ Check inside!\n+                                    break;\n+                                }\n+                                case 0x08:  \/\/ scale\/octave tuning 1-byte form (Non\n@@ -160,1 +175,1 @@\n-                        case 0x09:  \/\/ scale\/octave tuning 2-byte form (Non\n+                                case 0x09:  \/\/ scale\/octave tuning 2-byte form (Non\n@@ -162,47 +177,17 @@\n-                        {\n-                            \/\/ http:\/\/www.midi.org\/about-midi\/tuning-scale.shtml\n-                            SoftTuning tuning = new SoftTuning(data);\n-                            int channelmask = (data[5] & 0xFF) * 16384\n-                                    + (data[6] & 0xFF) * 128 + (data[7] & 0xFF);\n-                            SoftChannel[] channels = synth.channels;\n-                            for (int i = 0; i < channels.length; i++)\n-                                if ((channelmask & (1 << i)) != 0)\n-                                    channels[i].tuning = tuning;\n-                            break;\n-                        }\n-                        default:\n-                            break;\n-                        }\n-                        break;\n-                    case 0x09:  \/\/ General Midi Message\n-                        subid2 = data[4] & 0xFF;\n-                        switch (subid2) {\n-                        case 0x01:  \/\/ General Midi 1 On\n-                            synth.setGeneralMidiMode(1);\n-                            reset();\n-                            break;\n-                        case 0x02:  \/\/ General Midi Off\n-                            synth.setGeneralMidiMode(0);\n-                            reset();\n-                            break;\n-                        case 0x03:  \/\/ General MidI Level 2 On\n-                            synth.setGeneralMidiMode(2);\n-                            reset();\n-                            break;\n-                        default:\n-                            break;\n-                        }\n-                        break;\n-                    case 0x0A: \/\/ DLS Message\n-                        subid2 = data[4] & 0xFF;\n-                        switch (subid2) {\n-                        case 0x01:  \/\/ DLS On\n-                            if (synth.getGeneralMidiMode() == 0)\n-                                synth.setGeneralMidiMode(1);\n-                            synth.voice_allocation_mode = 1;\n-                            reset();\n-                            break;\n-                        case 0x02:  \/\/ DLS Off\n-                            synth.setGeneralMidiMode(0);\n-                            synth.voice_allocation_mode = 0;\n-                            reset();\n+                                {\n+                                    if (data.length < 8) {\n+                                        break;\n+                                    }\n+                                    \/\/ http:\/\/www.midi.org\/about-midi\/tuning-scale.shtml\n+                                    SoftTuning tuning = new SoftTuning(data);\n+                                    int channelmask = (data[5] & 0xFF) * 16384\n+                                            + (data[6] & 0xFF) * 128 + (data[7] & 0xFF);\n+                                    SoftChannel[] channels = synth.channels;\n+                                    for (int i = 0; i < channels.length; i++)\n+                                        if ((channelmask & (1 << i)) != 0)\n+                                            channels[i].tuning = tuning;\n+                                    break;\n+                                }\n+                                default:\n+                                    break;\n+                            }\n@@ -210,2 +195,21 @@\n-                        case 0x03:  \/\/ DLS Static Voice Allocation Off\n-                            synth.voice_allocation_mode = 0;\n+                        case 0x09:  \/\/ General Midi Message\n+                            if (data.length < 5) {\n+                                break;\n+                            }\n+                            subid2 = data[4] & 0xFF;\n+                            switch (subid2) {\n+                                case 0x01:  \/\/ General Midi 1 On\n+                                    synth.setGeneralMidiMode(1);\n+                                    reset();\n+                                    break;\n+                                case 0x02:  \/\/ General Midi Off\n+                                    synth.setGeneralMidiMode(0);\n+                                    reset();\n+                                    break;\n+                                case 0x03:  \/\/ General MidI Level 2 On\n+                                    synth.setGeneralMidiMode(2);\n+                                    reset();\n+                                    break;\n+                                default:\n+                                    break;\n+                            }\n@@ -213,2 +217,26 @@\n-                        case 0x04:  \/\/ DLS Static Voice Allocation On\n-                            synth.voice_allocation_mode = 1;\n+                        case 0x0A: \/\/ DLS Message\n+                            if (data.length < 5) {\n+                                break;\n+                            }\n+                            subid2 = data[4] & 0xFF;\n+                            switch (subid2) {\n+                                case 0x01:  \/\/ DLS On\n+                                    if (synth.getGeneralMidiMode() == 0)\n+                                        synth.setGeneralMidiMode(1);\n+                                    synth.voice_allocation_mode = 1;\n+                                    reset();\n+                                    break;\n+                                case 0x02:  \/\/ DLS Off\n+                                    synth.setGeneralMidiMode(0);\n+                                    synth.voice_allocation_mode = 0;\n+                                    reset();\n+                                    break;\n+                                case 0x03:  \/\/ DLS Static Voice Allocation Off\n+                                    synth.voice_allocation_mode = 0;\n+                                    break;\n+                                case 0x04:  \/\/ DLS Static Voice Allocation On\n+                                    synth.voice_allocation_mode = 1;\n+                                    break;\n+                                default:\n+                                    break;\n+                            }\n@@ -216,0 +244,1 @@\n+\n@@ -218,5 +247,0 @@\n-                        }\n-                        break;\n-\n-                    default:\n-                        break;\n@@ -231,0 +255,3 @@\n+                    if (data.length < 4) {\n+                        return;\n+                    }\n@@ -234,29 +261,3 @@\n-                    case 0x04: \/\/ Device Control\n-\n-                        subid2 = data[4] & 0xFF;\n-                        switch (subid2) {\n-                        case 0x01: \/\/ Master Volume\n-                        case 0x02: \/\/ Master Balane\n-                        case 0x03: \/\/ Master fine tuning\n-                        case 0x04: \/\/ Master coarse tuning\n-                            int val = (data[5] & 0x7F)\n-                                    + ((data[6] & 0x7F) * 128);\n-                            if (subid2 == 0x01)\n-                                setVolume(val);\n-                            else if (subid2 == 0x02)\n-                                setBalance(val);\n-                            else if (subid2 == 0x03)\n-                                setFineTuning(val);\n-                            else if (subid2 == 0x04)\n-                                setCoarseTuning(val);\n-                            break;\n-                        case 0x05: \/\/ Global Parameter Control\n-                            int ix = 5;\n-                            int slotPathLen = (data[ix++] & 0xFF);\n-                            int paramWidth = (data[ix++] & 0xFF);\n-                            int valueWidth = (data[ix++] & 0xFF);\n-                            int[] slotPath = new int[slotPathLen];\n-                            for (int i = 0; i < slotPathLen; i++) {\n-                                int msb = (data[ix++] & 0xFF);\n-                                int lsb = (data[ix++] & 0xFF);\n-                                slotPath[i] = msb * 128 + lsb;\n+                        case 0x04: \/\/ Device Control\n+                            if (data.length < 5) {\n+                                break;\n@@ -264,12 +265,52 @@\n-                            int paramCount = (data.length - 1 - ix)\n-                                    \/ (paramWidth + valueWidth);\n-                            long[] params = new long[paramCount];\n-                            long[] values = new long[paramCount];\n-                            for (int i = 0; i < paramCount; i++) {\n-                                values[i] = 0;\n-                                for (int j = 0; j < paramWidth; j++)\n-                                    params[i] = params[i] * 128\n-                                            + (data[ix++] & 0xFF);\n-                                for (int j = 0; j < valueWidth; j++)\n-                                    values[i] = values[i] * 128\n-                                            + (data[ix++] & 0xFF);\n+                            subid2 = data[4] & 0xFF;\n+                            switch (subid2) {\n+                                case 0x01: \/\/ Master Volume\n+                                case 0x02: \/\/ Master Balane\n+                                case 0x03: \/\/ Master fine tuning\n+                                case 0x04: \/\/ Master coarse tuning\n+                                    if (data.length < 7) {\n+                                        break;\n+                                    }\n+                                    int val = (data[5] & 0x7F)\n+                                            + ((data[6] & 0x7F) * 128);\n+                                    if (subid2 == 0x01)\n+                                        setVolume(val);\n+                                    else if (subid2 == 0x02)\n+                                        setBalance(val);\n+                                    else if (subid2 == 0x03)\n+                                        setFineTuning(val);\n+                                    else if (subid2 == 0x04)\n+                                        setCoarseTuning(val);\n+                                    break;\n+                                case 0x05: \/\/ Global Parameter Control\n+                                    if (data.length < 6) {\n+                                        break;\n+                                    }\n+                                    int ix = 5;\n+                                    int slotPathLen = (data[ix++] & 0xFF);\n+                                    if (data.length < slotPathLen * 2 + 8) {\n+                                        break;\n+                                    }\n+                                    int paramWidth = (data[ix++] & 0xFF);\n+                                    int valueWidth = (data[ix++] & 0xFF);\n+                                    int[] slotPath = new int[slotPathLen];\n+                                    for (int i = 0; i < slotPathLen; i++) {\n+                                        int msb = (data[ix++] & 0xFF);\n+                                        int lsb = (data[ix++] & 0xFF);\n+                                        slotPath[i] = msb * 128 + lsb;\n+                                    }\n+                                    int paramCount = (data.length - 1 - ix)\n+                                            \/ (paramWidth + valueWidth);\n+                                    if (paramCount < 1) {\n+                                        break;\n+                                    }\n+                                    long[] params = new long[paramCount];\n+                                    long[] values = new long[paramCount];\n+                                    for (int i = 0; i < paramCount; i++) {\n+                                        values[i] = 0;\n+                                        for (int j = 0; j < paramWidth; j++)\n+                                            params[i] = params[i] * 128\n+                                                    + (data[ix++] & 0xFF);\n+                                        for (int j = 0; j < valueWidth; j++)\n+                                            values[i] = values[i] * 128\n+                                                    + (data[ix++] & 0xFF);\n@@ -277,0 +318,5 @@\n+                                    }\n+                                    globalParameterControlChange(slotPath, params, values);\n+                                    break;\n+                                default:\n+                                    break;\n@@ -278,3 +324,0 @@\n-                            globalParameterControlChange(slotPath, params, values);\n-                            break;\n-                        default:\n@@ -282,2 +325,0 @@\n-                        }\n-                        break;\n@@ -285,17 +326,23 @@\n-                    case 0x08:  \/\/ MIDI Tuning Standard\n-                        subid2 = data[4] & 0xFF;\n-                        switch (subid2) {\n-                        case 0x02:  \/\/ SINGLE NOTE TUNING CHANGE (REAL-TIME)\n-                        {\n-                            \/\/ http:\/\/www.midi.org\/about-midi\/tuning.shtml\n-                            SoftTuning tuning = synth.getTuning(new Patch(0,\n-                                    data[5] & 0xFF));\n-                            tuning.load(data);\n-                            SoftVoice[] voices = synth.getVoices();\n-                            for (int i = 0; i < voices.length; i++)\n-                                if (voices[i].active)\n-                                    if (voices[i].tuning == tuning)\n-                                        voices[i].updateTuning(tuning);\n-                            break;\n-                        }\n-                        case 0x07:  \/\/ SINGLE NOTE TUNING CHANGE (REAL-TIME)\n+                        case 0x08:  \/\/ MIDI Tuning Standard\n+                            if (data.length < 5) {\n+                                break;\n+                            }\n+                            subid2 = data[4] & 0xFF;\n+                            switch (subid2) {\n+                                case 0x02:  \/\/ SINGLE NOTE TUNING CHANGE (REAL-TIME)\n+                                {\n+                                    \/\/ http:\/\/www.midi.org\/about-midi\/tuning.shtml\n+                                    if (data.length < 6) {\n+                                        break;\n+                                    }\n+                                    SoftTuning tuning = synth.getTuning(new Patch(0,\n+                                            data[5] & 0xFF));\n+                                    tuning.load(data);\n+                                    SoftVoice[] voices = synth.getVoices();\n+                                    for (int i = 0; i < voices.length; i++)\n+                                        if (voices[i].active)\n+                                            if (voices[i].tuning == tuning)\n+                                                voices[i].updateTuning(tuning);\n+                                    break;\n+                                }\n+                                case 0x07:  \/\/ SINGLE NOTE TUNING CHANGE (REAL-TIME)\n@@ -303,13 +350,16 @@\n-                        {\n-                            \/\/ http:\/\/www.midi.org\/about-midi\/tuning_extens.shtml\n-                            SoftTuning tuning = synth.getTuning(new Patch(\n-                                    data[5] & 0xFF, data[6] & 0xFF));\n-                            tuning.load(data);\n-                            SoftVoice[] voices = synth.getVoices();\n-                            for (int i = 0; i < voices.length; i++)\n-                                if (voices[i].active)\n-                                    if (voices[i].tuning == tuning)\n-                                        voices[i].updateTuning(tuning);\n-                            break;\n-                        }\n-                        case 0x08:  \/\/ scale\/octave tuning 1-byte form\n+                                {\n+                                    \/\/ http:\/\/www.midi.org\/about-midi\/tuning_extens.shtml\n+                                    if (data.length < 7) {\n+                                        break;\n+                                    }\n+                                    SoftTuning tuning = synth.getTuning(new Patch(\n+                                            data[5] & 0xFF, data[6] & 0xFF));\n+                                    tuning.load(data);\n+                                    SoftVoice[] voices = synth.getVoices();\n+                                    for (int i = 0; i < voices.length; i++)\n+                                        if (voices[i].active)\n+                                            if (voices[i].tuning == tuning)\n+                                                voices[i].updateTuning(tuning);\n+                                    break;\n+                                }\n+                                case 0x08:  \/\/ scale\/octave tuning 1-byte form\n@@ -317,1 +367,1 @@\n-                        case 0x09:  \/\/ scale\/octave tuning 2-byte form\n+                                case 0x09:  \/\/ scale\/octave tuning 2-byte form\n@@ -319,32 +369,21 @@\n-                        {\n-                            \/\/ http:\/\/www.midi.org\/about-midi\/tuning-scale.shtml\n-                            SoftTuning tuning = new SoftTuning(data);\n-                            int channelmask = (data[5] & 0xFF) * 16384\n-                                    + (data[6] & 0xFF) * 128 + (data[7] & 0xFF);\n-                            SoftChannel[] channels = synth.channels;\n-                            for (int i = 0; i < channels.length; i++)\n-                                if ((channelmask & (1 << i)) != 0)\n-                                    channels[i].tuning = tuning;\n-                            SoftVoice[] voices = synth.getVoices();\n-                            for (int i = 0; i < voices.length; i++)\n-                                if (voices[i].active)\n-                                    if ((channelmask & (1 << (voices[i].channel))) != 0)\n-                                        voices[i].updateTuning(tuning);\n-                            break;\n-                        }\n-                        default:\n-                            break;\n-                        }\n-                        break;\n-                    case 0x09:  \/\/ Control Destination Settings\n-                        subid2 = data[4] & 0xFF;\n-                        switch (subid2) {\n-                        case 0x01: \/\/ Channel Pressure\n-                        {\n-                            int[] destinations = new int[(data.length - 7) \/ 2];\n-                            int[] ranges = new int[(data.length - 7) \/ 2];\n-                            int ix = 0;\n-                            for (int j = 6; j < data.length - 1; j += 2) {\n-                                destinations[ix] = data[j] & 0xFF;\n-                                ranges[ix] = data[j + 1] & 0xFF;\n-                                ix++;\n+                                {\n+                                    \/\/ http:\/\/www.midi.org\/about-midi\/tuning-scale.shtml\n+                                    if (data.length < 8) {\n+                                        break;\n+                                    }\n+                                    SoftTuning tuning = new SoftTuning(data);\n+                                    int channelmask = (data[5] & 0xFF) * 16384\n+                                            + (data[6] & 0xFF) * 128 + (data[7] & 0xFF);\n+                                    SoftChannel[] channels = synth.channels;\n+                                    for (int i = 0; i < channels.length; i++)\n+                                        if ((channelmask & (1 << i)) != 0)\n+                                            channels[i].tuning = tuning;\n+                                    SoftVoice[] voices = synth.getVoices();\n+                                    for (int i = 0; i < voices.length; i++)\n+                                        if (voices[i].active)\n+                                            if ((channelmask & (1 << (voices[i].channel))) != 0)\n+                                                voices[i].updateTuning(tuning);\n+                                    break;\n+                                }\n+                                default:\n+                                    break;\n@@ -352,4 +391,0 @@\n-                            int channel = data[5] & 0xFF;\n-                            SoftChannel softchannel = synth.channels[channel];\n-                            softchannel.mapChannelPressureToDestination(\n-                                    destinations, ranges);\n@@ -357,10 +392,3 @@\n-                        }\n-                        case 0x02: \/\/ Poly Pressure\n-                        {\n-                            int[] destinations = new int[(data.length - 7) \/ 2];\n-                            int[] ranges = new int[(data.length - 7) \/ 2];\n-                            int ix = 0;\n-                            for (int j = 6; j < data.length - 1; j += 2) {\n-                                destinations[ix] = data[j] & 0xFF;\n-                                ranges[ix] = data[j + 1] & 0xFF;\n-                                ix++;\n+                        case 0x09:  \/\/ Control Destination Settings\n+                            if (data.length < 5) {\n+                                break;\n@@ -368,15 +396,62 @@\n-                            int channel = data[5] & 0xFF;\n-                            SoftChannel softchannel = synth.channels[channel];\n-                            softchannel.mapPolyPressureToDestination(\n-                                    destinations, ranges);\n-                            break;\n-                        }\n-                        case 0x03: \/\/ Control Change\n-                        {\n-                            int[] destinations = new int[(data.length - 7) \/ 2];\n-                            int[] ranges = new int[(data.length - 7) \/ 2];\n-                            int ix = 0;\n-                            for (int j = 7; j < data.length - 1; j += 2) {\n-                                destinations[ix] = data[j] & 0xFF;\n-                                ranges[ix] = data[j + 1] & 0xFF;\n-                                ix++;\n+                            subid2 = data[4] & 0xFF;\n+                            switch (subid2) {\n+                                case 0x01: \/\/ Channel Pressure\n+                                {\n+                                    if (data.length < 8) {\n+                                        break;\n+                                    }\n+                                    int[] destinations = new int[(data.length - 6) \/ 2];\n+                                    int[] ranges = new int[(data.length - 6) \/ 2];\n+                                    int ix = 0;\n+                                    for (int j = 6; j < data.length - 1; j += 2) {\n+                                        destinations[ix] = data[j] & 0xFF;\n+                                        ranges[ix] = data[j + 1] & 0xFF;\n+                                        ix++;\n+                                    }\n+                                    int channel = data[5] & 0xFF;\n+                                    SoftChannel softchannel = synth.channels[channel];\n+                                    softchannel.mapChannelPressureToDestination(\n+                                            destinations, ranges);\n+                                    break;\n+                                }\n+                                case 0x02: \/\/ Poly Pressure\n+                                {\n+                                    if (data.length < 8) {\n+                                        break;\n+                                    }\n+                                    int[] destinations = new int[(data.length - 6) \/ 2];\n+                                    int[] ranges = new int[(data.length - 6) \/ 2];\n+                                    int ix = 0;\n+                                    for (int j = 6; j < data.length - 1; j += 2) {\n+                                        destinations[ix] = data[j] & 0xFF;\n+                                        ranges[ix] = data[j + 1] & 0xFF;\n+                                        ix++;\n+                                    }\n+                                    int channel = data[5] & 0xFF;\n+                                    SoftChannel softchannel = synth.channels[channel];\n+                                    softchannel.mapPolyPressureToDestination(\n+                                            destinations, ranges);\n+                                    break;\n+                                }\n+                                case 0x03: \/\/ Control Change\n+                                {\n+                                    if (data.length < 8) {\n+                                        break;\n+                                    }\n+                                    int[] destinations = new int[(data.length - 7) \/ 2];\n+                                    int[] ranges = new int[(data.length - 7) \/ 2];\n+                                    int ix = 0;\n+                                    for (int j = 7; j < data.length - 1; j += 2) {\n+                                        destinations[ix] = data[j] & 0xFF;\n+                                        ranges[ix] = data[j + 1] & 0xFF;\n+                                        ix++;\n+                                    }\n+                                    int channel = data[5] & 0xFF;\n+                                    SoftChannel softchannel = synth.channels[channel];\n+                                    int control = data[6] & 0xFF;\n+                                    softchannel.mapControlToDestination(control,\n+                                            destinations, ranges);\n+                                    break;\n+                                }\n+                                default:\n+                                    break;\n@@ -384,8 +459,0 @@\n-                            int channel = data[5] & 0xFF;\n-                            SoftChannel softchannel = synth.channels[channel];\n-                            int control = data[6] & 0xFF;\n-                            softchannel.mapControlToDestination(control,\n-                                    destinations, ranges);\n-                            break;\n-                        }\n-                        default:\n@@ -393,2 +460,0 @@\n-                        }\n-                        break;\n@@ -396,13 +461,20 @@\n-                    case 0x0A:  \/\/ Key Based Instrument Control\n-                    {\n-                        subid2 = data[4] & 0xFF;\n-                        switch (subid2) {\n-                        case 0x01: \/\/ Basic Message\n-                            int channel = data[5] & 0xFF;\n-                            int keynumber = data[6] & 0xFF;\n-                            SoftChannel softchannel = synth.channels[channel];\n-                            for (int j = 7; j < data.length - 1; j += 2) {\n-                                int controlnumber = data[j] & 0xFF;\n-                                int controlvalue = data[j + 1] & 0xFF;\n-                                softchannel.controlChangePerNote(keynumber,\n-                                        controlnumber, controlvalue);\n+                        case 0x0A:  \/\/ Key Based Instrument Control\n+                        {\n+                            if (data.length < 8 || (data[4] & 0xFF) != 0x01) {\n+                                break;\n+                            }\n+                            subid2 = data[4] & 0xFF;\n+                            switch (subid2) {\n+                                case 0x01: \/\/ Basic Message\n+                                    int channel = data[5] & 0xFF;\n+                                    int keynumber = data[6] & 0xFF;\n+                                    SoftChannel softchannel = synth.channels[channel];\n+                                    for (int j = 7; j < data.length - 1; j += 2) {\n+                                        int controlnumber = data[j] & 0xFF;\n+                                        int controlvalue = data[j + 1] & 0xFF;\n+                                        softchannel.controlChangePerNote(keynumber,\n+                                                controlnumber, controlvalue);\n+                                    }\n+                                    break;\n+                                default:\n+                                    break;\n@@ -411,0 +483,1 @@\n+                        }\n@@ -413,5 +486,0 @@\n-                        }\n-                        break;\n-                    }\n-                    default:\n-                        break;\n@@ -421,1 +489,0 @@\n-\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/SoftMainMixer.java","additions":315,"deletions":248,"binary":false,"changes":563,"status":"modified"},{"patch":"@@ -292,1 +292,1 @@\n-            for (Instrument instrument : instruments) {\n+            for (ModelInstrument instrument : instruments) {\n@@ -294,2 +294,1 @@\n-                SoftInstrument softins\n-                        = new SoftInstrument((ModelInstrument) instrument);\n+                SoftInstrument softins = new SoftInstrument(instrument);\n@@ -297,1 +296,1 @@\n-                loadedlist.put(pat, (ModelInstrument) instrument);\n+                loadedlist.put(pat, instrument);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/SoftSynthesizer.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.UnsupportedEncodingException;\n@@ -33,0 +32,2 @@\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+\n@@ -91,0 +92,4 @@\n+        if (data.length < 2) {\n+            return;\n+        }\n+\n@@ -92,0 +97,4 @@\n+            if (data.length < 4) {\n+                return;\n+            }\n+\n@@ -95,0 +104,3 @@\n+                if (data.length < 5) {\n+                    break;\n+                }\n@@ -102,5 +114,0 @@\n-                    try {\n-                        name = new String(data, 6, 16, \"ascii\");\n-                    } catch (UnsupportedEncodingException e) {\n-                        name = null;\n-                    }\n@@ -108,0 +115,4 @@\n+                    if (data.length < 128 * 3 + r) {\n+                        break;\n+                    }\n+                    name = new String(data, 6, 16, US_ASCII);\n@@ -121,0 +132,3 @@\n+                    if (data.length < 7) {\n+                        break;\n+                    }\n@@ -123,0 +137,3 @@\n+                    if (data.length < ll * 4 + r) {\n+                        break;\n+                    }\n@@ -138,4 +155,2 @@\n-                    try {\n-                        name = new String(data, 7, 16, \"ascii\");\n-                    } catch (UnsupportedEncodingException e) {\n-                        name = null;\n+                    if (data.length < 407) {\n+                        break;\n@@ -143,0 +158,1 @@\n+                    name = new String(data, 7, 16, US_ASCII);\n@@ -159,4 +175,2 @@\n-                    try {\n-                        name = new String(data, 7, 16, \"ascii\");\n-                    } catch (UnsupportedEncodingException e) {\n-                        name = null;\n+                    if (data.length < 35) {\n+                        break;\n@@ -164,0 +178,1 @@\n+                    name = new String(data, 7, 16, US_ASCII);\n@@ -177,4 +192,2 @@\n-                    try {\n-                        name = new String(data, 7, 16, \"ascii\");\n-                    } catch (UnsupportedEncodingException e) {\n-                        name = null;\n+                    if (data.length < 47) {\n+                        break;\n@@ -182,0 +195,1 @@\n+                    name = new String(data, 7, 16, US_ASCII);\n@@ -195,0 +209,3 @@\n+                    if (data.length < 8) {\n+                        break;\n+                    }\n@@ -196,0 +213,3 @@\n+                    if (data.length < ll * 4 + 8) {\n+                        break;\n+                    }\n@@ -211,0 +231,3 @@\n+                    if (data.length < 20) {\n+                        break;\n+                    }\n@@ -222,0 +245,3 @@\n+                    if (data.length < 32) {\n+                        break;\n+                    }\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/SoftTuning.java","additions":45,"deletions":19,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -871,3 +871,3 @@\n-            AbstractFormatter displayFormatter = new NumberFormatter();\n-            ((NumberFormatter)displayFormatter).setValueClass(type.getClass());\n-            AbstractFormatter editFormatter = new NumberFormatter(\n+            NumberFormatter displayFormatter = new NumberFormatter();\n+            displayFormatter.setValueClass(type.getClass());\n+            NumberFormatter editFormatter = new NumberFormatter(\n@@ -875,1 +875,1 @@\n-            ((NumberFormatter)editFormatter).setValueClass(type.getClass());\n+            editFormatter.setValueClass(type.getClass());\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JFormattedTextField.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.applet.Applet;\n@@ -29,1 +28,0 @@\n-import java.awt.event.*;\n@@ -34,1 +32,0 @@\n-import java.util.Vector;\n@@ -36,1 +33,0 @@\n-import javax.swing.border.*;\n@@ -38,1 +34,0 @@\n-import sun.awt.AWTAccessor;\n@@ -514,1 +509,1 @@\n-        JComponent c = new JPanel();\n+        JPanel c = new JPanel();\n@@ -517,1 +512,1 @@\n-        ((JPanel)c).setOpaque(false);\n+        c.setOpaque(false);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JRootPane.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2036,1 +2036,1 @@\n-        Object            value;\n+        Boolean           value;\n@@ -2045,2 +2045,1 @@\n-                if(path != parent && value != null &&\n-                   ((Boolean)value).booleanValue() &&\n+                if (path != parent && value != null && value &&\n@@ -2084,1 +2083,1 @@\n-        Object  value;\n+        Boolean value;\n@@ -2088,1 +2087,1 @@\n-            if(value == null || !((Boolean)value).booleanValue())\n+            if (value == null || !value)\n@@ -2112,1 +2111,1 @@\n-                return (value != null && value.booleanValue());\n+                return (value != null && value);\n@@ -3732,1 +3731,1 @@\n-                Object          cValue = expandedState.get(path);\n+                Boolean cValue = expandedState.get(path);\n@@ -3734,1 +3733,1 @@\n-                if(cValue != null && ((Boolean)cValue).booleanValue()) {\n+                if (cValue != null && cValue) {\n@@ -3756,1 +3755,1 @@\n-                Object          cValue = expandedState.get(path);\n+                Boolean cValue = expandedState.get(path);\n@@ -3758,1 +3757,1 @@\n-                if(cValue == null || !((Boolean)cValue).booleanValue()) {\n+                if (cValue == null || !cValue) {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTree.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1027,4 +1027,1 @@\n-        for (Object infoObject: painters) {\n-            ParsedSynthStyle.PainterInfo info;\n-            info = (ParsedSynthStyle.PainterInfo) infoObject;\n-\n+        for (ParsedSynthStyle.PainterInfo info: painters) {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthParser.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -320,1 +320,1 @@\n-            Component comp = getTextComponent();\n+            JTextComponent comp = getTextComponent();\n@@ -325,3 +325,1 @@\n-            if (comp instanceof JTextComponent &&\n-                ((JTextComponent)comp).isEditable()) {\n-\n+            if (comp.isEditable()) {\n@@ -745,5 +743,3 @@\n-            Component comp = getTextComponent();\n-            if (comp instanceof JTextComponent) {\n-                if (((JTextComponent)comp).isEditable()) {\n-                    return true;\n-                }\n+            JTextComponent comp = getTextComponent();\n+            if (comp != null && comp.isEditable()) {\n+                return true;\n@@ -766,2 +762,2 @@\n-            Component comp = getTextComponent();\n-            if (comp instanceof JTextComponent) {\n+            JTextComponent comp = getTextComponent();\n+            if (comp != null) {\n@@ -775,1 +771,1 @@\n-                        ((JTextComponent)comp).setCaretPosition(elem.getStartOffset());\n+                        comp.setCaretPosition(elem.getStartOffset());\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/AccessibleHTML.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -4228,1 +4228,1 @@\n-                        AttributeSet newAttrs = null;\n+                        SimpleAttributeSet newAttrs = null;\n@@ -4262,3 +4262,2 @@\n-                            ((SimpleAttributeSet)newAttrs).addAttribute\n-                                              (StyleConstants.NameAttribute,\n-                                               HTML.Tag.CONTENT);\n+                            newAttrs.addAttribute(StyleConstants.NameAttribute,\n+                                                  HTML.Tag.CONTENT);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/HTMLDocument.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-package javax.swing.text.html;\n@@ -27,1 +26,1 @@\n-import sun.awt.AppContext;\n+package javax.swing.text.html;\n@@ -29,3 +28,26 @@\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.io.*;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Cursor;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Shape;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ComponentEvent;\n+import java.awt.event.ComponentListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseListener;\n+import java.awt.event.MouseMotionListener;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.io.Serializable;\n+import java.io.StringReader;\n+import java.io.Writer;\n+import java.lang.ref.Reference;\n+import java.lang.ref.WeakReference;\n@@ -34,7 +56,0 @@\n-import javax.swing.text.*;\n-import javax.swing.*;\n-import javax.swing.event.*;\n-import javax.swing.plaf.TextUI;\n-import java.util.*;\n-import javax.accessibility.*;\n-import java.lang.ref.*;\n@@ -43,0 +58,36 @@\n+import java.util.Enumeration;\n+\n+import javax.accessibility.Accessible;\n+import javax.accessibility.AccessibleAction;\n+import javax.accessibility.AccessibleContext;\n+import javax.swing.Action;\n+import javax.swing.JEditorPane;\n+import javax.swing.JViewport;\n+import javax.swing.SizeRequirements;\n+import javax.swing.SwingUtilities;\n+import javax.swing.event.CaretEvent;\n+import javax.swing.event.CaretListener;\n+import javax.swing.event.HyperlinkEvent;\n+import javax.swing.plaf.TextUI;\n+import javax.swing.text.AbstractDocument;\n+import javax.swing.text.AttributeSet;\n+import javax.swing.text.BadLocationException;\n+import javax.swing.text.BoxView;\n+import javax.swing.text.ComponentView;\n+import javax.swing.text.DefaultHighlighter;\n+import javax.swing.text.Document;\n+import javax.swing.text.EditorKit;\n+import javax.swing.text.Element;\n+import javax.swing.text.ElementIterator;\n+import javax.swing.text.Highlighter;\n+import javax.swing.text.IconView;\n+import javax.swing.text.JTextComponent;\n+import javax.swing.text.LabelView;\n+import javax.swing.text.MutableAttributeSet;\n+import javax.swing.text.Position;\n+import javax.swing.text.StyleConstants;\n+import javax.swing.text.StyledDocument;\n+import javax.swing.text.StyledEditorKit;\n+import javax.swing.text.TextAction;\n+import javax.swing.text.View;\n+import javax.swing.text.ViewFactory;\n@@ -44,0 +95,2 @@\n+\n+import sun.awt.AppContext;\n@@ -46,0 +99,2 @@\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+\n@@ -407,1 +462,1 @@\n-                        new InputStreamReader(is, \"ISO-8859-1\"));\n+                        new InputStreamReader(is, ISO_8859_1));\n@@ -796,1 +851,1 @@\n-                        Shape lBounds = ui.modelToView(html, offset,\n+                        Rectangle lBounds = ui.modelToView(html, offset,\n@@ -798,1 +853,1 @@\n-                        Shape rBounds = ui.modelToView(html, offset + 1,\n+                        Rectangle rBounds = ui.modelToView(html, offset + 1,\n@@ -800,3 +855,2 @@\n-                        bounds = lBounds.getBounds();\n-                        bounds.add((rBounds instanceof Rectangle) ?\n-                                    (Rectangle)rBounds : rBounds.getBounds());\n+                        bounds = lBounds;\n+                        bounds.add(rBounds);\n@@ -833,3 +887,3 @@\n-                    Shape s1 = ui.modelToView(editor, offset,\n-                                              Position.Bias.Forward);\n-                    if (s1 == null) {\n+                    Rectangle r1 = ui.modelToView(editor, offset,\n+                                                  Position.Bias.Forward);\n+                    if (r1 == null) {\n@@ -838,7 +892,3 @@\n-                    Rectangle r1 = (s1 instanceof Rectangle) ? (Rectangle)s1 :\n-                                    s1.getBounds();\n-                    Shape s2 = ui.modelToView(editor, e.getEndOffset(),\n-                                              Position.Bias.Backward);\n-                    if (s2 != null) {\n-                        Rectangle r2 = (s2 instanceof Rectangle) ? (Rectangle)s2 :\n-                                    s2.getBounds();\n+                    Rectangle r2 = ui.modelToView(editor, e.getEndOffset(),\n+                                                  Position.Bias.Backward);\n+                    if (r2 != null) {\n@@ -1469,1 +1519,1 @@\n-                        Object cachedObject;\n+                        JViewport cachedObject;\n@@ -1471,1 +1521,1 @@\n-                            ((JComponent)cachedObject).removeComponentListener(this);\n+                            cachedObject.removeComponentListener(this);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/HTMLEditorKit.java","additions":80,"deletions":30,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.awt.Font;\n@@ -519,1 +518,1 @@\n-        Object newStyle = findStyleNumber(newAttributes, Constants.STSection);\n+        Integer newStyle = findStyleNumber(newAttributes, Constants.STSection);\n@@ -525,1 +524,1 @@\n-                writeControlWord(\"ds\", ((Integer)newStyle).intValue());\n+                writeControlWord(\"ds\", newStyle);\n@@ -558,2 +557,2 @@\n-    Object parm;\n-    Object oldStyle, newStyle;\n+    Object oldStyle;\n+    Integer newStyle;\n@@ -591,1 +590,1 @@\n-        writeControlWord(\"s\", ((Integer)newStyle).intValue());\n+        writeControlWord(\"s\", newStyle);\n@@ -710,1 +709,1 @@\n-        Object newStyle = findStyleNumber(newAttributes,\n+        Integer newStyle = findStyleNumber(newAttributes,\n@@ -717,1 +716,1 @@\n-                writeControlWord(\"cs\", ((Integer)newStyle).intValue());\n+                writeControlWord(\"cs\", newStyle.intValue());\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/rtf\/RTFGenerator.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+\n@@ -27,3 +28,0 @@\n-import java.lang.*;\n-import java.util.*;\n-import java.io.*;\n@@ -31,0 +29,6 @@\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.StreamTokenizer;\n@@ -38,1 +42,18 @@\n-import javax.swing.text.*;\n+import java.util.Dictionary;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.Vector;\n+\n+import javax.swing.text.AttributeSet;\n+import javax.swing.text.BadLocationException;\n+import javax.swing.text.MutableAttributeSet;\n+import javax.swing.text.SimpleAttributeSet;\n+import javax.swing.text.Style;\n+import javax.swing.text.StyleConstants;\n+import javax.swing.text.StyleContext;\n+import javax.swing.text.StyledDocument;\n+import javax.swing.text.TabStop;\n@@ -651,1 +672,1 @@\n-            new InputStreamReader(strm, \"ISO-8859-1\")));\n+            new InputStreamReader(strm, ISO_8859_1)));\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/rtf\/RTFReader.java","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+\n@@ -28,1 +29,0 @@\n-import java.io.OutputStreamWriter;\n@@ -30,0 +30,1 @@\n+import java.io.OutputStreamWriter;\n@@ -32,1 +33,3 @@\n-import java.nio.charset.StandardCharsets;\n+\n+import static java.nio.charset.StandardCharsets.UTF_16BE;\n+import static java.nio.charset.StandardCharsets.UTF_16LE;\n@@ -112,3 +115,2 @@\n-                this.unicodeEncoder = isLE?\n-                    StandardCharsets.UTF_16LE.newEncoder():\n-                    StandardCharsets.UTF_16BE.newEncoder();\n+                this.unicodeEncoder = isLE ? UTF_16LE.newEncoder():\n+                                             UTF_16BE.newEncoder();\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/FontDescriptor.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1808,2 +1808,2 @@\n-                 Object map = ((SunToolkit)tk).getDesktopAAHints();\n-                 return (RenderingHints)map;\n+                 RenderingHints map = ((SunToolkit)tk).getDesktopAAHints();\n+                 return map;\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/SunToolkit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-\n@@ -38,1 +37,5 @@\n-\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ImageObserver;\n+import java.awt.image.RenderedImage;\n+import java.awt.image.WritableRaster;\n@@ -43,0 +46,2 @@\n+import java.io.FilePermission;\n+import java.io.IOException;\n@@ -45,1 +50,0 @@\n-import java.io.IOException;\n@@ -51,1 +55,2 @@\n-\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Modifier;\n@@ -54,1 +59,0 @@\n-\n@@ -60,1 +64,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -62,4 +65,0 @@\n-\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Modifier;\n-\n@@ -71,14 +70,16 @@\n-\n-import java.util.*;\n-\n-import sun.datatransfer.DataFlavorUtil;\n-\n-import sun.awt.AppContext;\n-import sun.awt.ComponentFactory;\n-import sun.awt.SunToolkit;\n-\n-import java.awt.image.BufferedImage;\n-import java.awt.image.ImageObserver;\n-import java.awt.image.RenderedImage;\n-import java.awt.image.WritableRaster;\n-import java.awt.image.ColorModel;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.Stack;\n+import java.util.TreeMap;\n+import java.util.stream.Stream;\n@@ -87,1 +88,0 @@\n-import javax.imageio.ImageReader;\n@@ -89,1 +89,1 @@\n-import javax.imageio.ImageWriter;\n+import javax.imageio.ImageReader;\n@@ -91,1 +91,1 @@\n-\n+import javax.imageio.ImageWriter;\n@@ -93,1 +93,0 @@\n-\n@@ -97,0 +96,3 @@\n+import sun.awt.AppContext;\n+import sun.awt.ComponentFactory;\n+import sun.awt.SunToolkit;\n@@ -99,0 +101,1 @@\n+import sun.datatransfer.DataFlavorUtil;\n@@ -100,3 +103,1 @@\n-import java.io.FilePermission;\n-import java.util.stream.Stream;\n-\n+import static java.nio.charset.StandardCharsets.UTF_8;\n@@ -553,1 +554,1 @@\n-                charset = new String(charsetNameBytes, StandardCharsets.UTF_8);\n+                charset = new String(charsetNameBytes, UTF_8);\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/datatransfer\/DataTransferer.java","additions":33,"deletions":32,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.ref.WeakReference;\n@@ -33,1 +32,0 @@\n-import java.io.UnsupportedEncodingException;\n@@ -35,0 +33,1 @@\n+import java.nio.BufferUnderflowException;\n@@ -37,1 +36,0 @@\n-import java.nio.BufferUnderflowException;\n@@ -40,0 +38,3 @@\n+import java.util.HashMap;\n+import java.util.HashSet;\n+\n@@ -42,3 +43,2 @@\n-import java.util.HashSet;\n-import java.util.HashMap;\n-import java.awt.Font;\n+\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n@@ -612,5 +612,1 @@\n-        try {\n-            return new String(nameBytes, \"US-ASCII\");\n-        } catch (UnsupportedEncodingException e) {\n-            return new String(nameBytes);\n-        }\n+        return new String(nameBytes, US_ASCII);\n@@ -626,5 +622,1 @@\n-        try {\n-            return new String(nameBytes, \"US-ASCII\");\n-        } catch (UnsupportedEncodingException e) {\n-            return new String(nameBytes);\n-        }\n+        return new String(nameBytes, US_ASCII);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/Type1Font.java","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -145,2 +145,2 @@\n-                Object obj = queue.remove();\n-                ((Reference)obj).clear();\n+                Reference<?> obj = queue.remove();\n+                obj.clear();\n@@ -203,1 +203,1 @@\n-        Object obj;\n+        Reference<?> obj;\n@@ -211,1 +211,1 @@\n-                ((Reference)obj).clear();\n+                obj.clear();\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/Disposer.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.awt.print.Pageable;\n@@ -31,3 +32,0 @@\n-import java.io.UnsupportedEncodingException;\n-\n-import java.awt.print.Pageable;\n@@ -60,3 +58,1 @@\n-   public Reader getReaderForText()\n-      throws UnsupportedEncodingException, IOException {\n-\n+   public Reader getReaderForText() throws IOException {\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/PageableDoc.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -64,0 +63,5 @@\n+import jdk.internal.misc.Unsafe;\n+\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n@@ -311,6 +315,1 @@\n-        byte[] bdata = null;\n-        try {\n-            bdata = str.getBytes(\"UTF-8\");\n-        } catch (java.io.UnsupportedEncodingException uee) {\n-            uee.printStackTrace();\n-        }\n+        byte[] bdata = str.getBytes(UTF_8);\n@@ -330,6 +329,1 @@\n-        byte[] bdata = null;\n-        try {\n-            bdata = str.getBytes(\"ISO-8859-1\");\n-        } catch (java.io.UnsupportedEncodingException uee) {\n-            uee.printStackTrace();\n-        }\n+        byte[] bdata = str.getBytes(ISO_8859_1);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XAtom.java","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-\n@@ -30,0 +29,1 @@\n+import java.nio.charset.Charset;\n@@ -34,0 +34,3 @@\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n@@ -385,1 +388,1 @@\n-        String charSet = \"UTF8\";\n+        Charset charSet = UTF_8;\n@@ -389,1 +392,1 @@\n-            charSet = \"ASCII\";\n+            charSet = US_ASCII;\n@@ -395,6 +398,2 @@\n-        try {\n-            net_wm_name_cache = new String(net_wm_name, charSet);\n-            return net_wm_name_cache;\n-        } catch (java.io.UnsupportedEncodingException uex) {\n-            return null;\n-        }\n+        net_wm_name_cache = new String(net_wm_name, charSet);\n+        return net_wm_name_cache;\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XNETProtocol.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-import java.io.UnsupportedEncodingException;\n@@ -70,0 +69,2 @@\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n@@ -1361,6 +1362,1 @@\n-        final byte[] message;\n-        try {\n-            message = messageBuilder.toString().getBytes(\"UTF-8\");\n-        } catch (UnsupportedEncodingException cannotHappen) {\n-            return;\n-        }\n+        final byte[] message = messageBuilder.toString().getBytes(UTF_8);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XWindowPeer.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,3 +29,0 @@\n-\n-import java.io.UnsupportedEncodingException;\n-\n@@ -35,0 +32,1 @@\n+import static java.nio.charset.StandardCharsets.UTF_8;\n@@ -201,6 +199,1 @@\n-            String str = null;\n-            try {\n-                str = new String(data, idx, len, \"UTF-8\");\n-            } catch (UnsupportedEncodingException e) {\n-                \/\/ XXX: cannot happen, \"UTF-8\" is always supported\n-            }\n+            String str = new String(data, idx, len, UTF_8);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/XSettings.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -69,0 +68,2 @@\n+            \".java\/robot\/screencast-tokens.properties\";\n+    private static final String REL_NAME_SECONDARY =\n@@ -75,0 +76,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -76,6 +78,3 @@\n-        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-            @Override\n-            public Void run() {\n-                runnable.run();\n-                return null;\n-            }\n+        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n+            runnable.run();\n+            return null;\n@@ -86,6 +85,5 @@\n-        PROPS_PATH = AccessController.doPrivileged(new PrivilegedAction<Path>() {\n-            @Override\n-            public Path run() {\n-                return setupPath();\n-            }\n-        });\n+        @SuppressWarnings(\"removal\")\n+        Path propsPath = AccessController\n+                .doPrivileged((PrivilegedAction<Path>) () -> setupPath());\n+\n+        PROPS_PATH = propsPath;\n@@ -113,0 +111,5 @@\n+        Path secondaryPath = Path.of(userHome, REL_NAME_SECONDARY);\n+\n+        boolean copyFromSecondary = !Files.isWritable(path)\n+                && Files.isWritable(secondaryPath);\n+\n@@ -115,7 +118,10 @@\n-        if (!Files.exists(workdir)) {\n-            try {\n-                Files.createDirectories(workdir);\n-            } catch (Exception e) {\n-                if (SCREENCAST_DEBUG) {\n-                    System.err.printf(\"Token storage: cannot create\" +\n-                                    \" directory %s %s\\n\", workdir, e);\n+        if (!Files.isWritable(path)) {\n+            if (!Files.exists(workdir)) {\n+                try {\n+                    Files.createDirectories(workdir);\n+                } catch (Exception e) {\n+                    if (SCREENCAST_DEBUG) {\n+                        System.err.printf(\"Token storage: cannot create\" +\n+                                \" directory %s %s\\n\", workdir, e);\n+                    }\n+                    return null;\n@@ -123,1 +129,0 @@\n-                return null;\n@@ -125,1 +130,0 @@\n-        }\n@@ -127,3 +131,5 @@\n-        if (!Files.isWritable(workdir)) {\n-            if (SCREENCAST_DEBUG) {\n-                System.err.printf(\"Token storage: %s is not writable\\n\", workdir);\n+            if (!Files.isWritable(workdir)) {\n+                if (SCREENCAST_DEBUG) {\n+                    System.err.printf(\"Token storage: %s is not writable\\n\", workdir);\n+                }\n+                return null;\n@@ -131,1 +137,0 @@\n-            return null;\n@@ -148,1 +153,11 @@\n-        if (Files.exists(path)) {\n+        if (copyFromSecondary) {\n+            if (SCREENCAST_DEBUG) {\n+                System.out.println(\"Token storage: copying from the secondary location \"\n+                                        + secondaryPath);\n+            }\n+            synchronized (PROPS) {\n+                if (readTokens(secondaryPath)) {\n+                    store(path, \"copy from the secondary location\");\n+                }\n+            }\n+        } else if (Files.exists(path)) {\n@@ -305,1 +320,1 @@\n-                doPrivilegedRunnable(() -> store(\"save tokens\"));\n+                doPrivilegedRunnable(() -> store(PROPS_PATH, \"save tokens\"));\n@@ -318,1 +333,1 @@\n-        } catch (IOException e) {\n+        } catch (IOException | IllegalArgumentException e) {\n@@ -413,1 +428,1 @@\n-        if (!isWritable()\n+        if (!isWritable(PROPS_PATH)\n@@ -427,1 +442,1 @@\n-            store(\"remove malformed records\");\n+            store(PROPS_PATH, \"remove malformed records\");\n@@ -431,2 +446,2 @@\n-    private static void store(String failMsg) {\n-        if (!isWritable()) {\n+    private static void store(Path path, String failMsg) {\n+        if (!isWritable(path)) {\n@@ -437,1 +452,1 @@\n-            try (BufferedWriter writer = Files.newBufferedWriter(PROPS_PATH)) {\n+            try (BufferedWriter writer = Files.newBufferedWriter(path)) {\n@@ -448,3 +463,3 @@\n-    private static boolean isWritable() {\n-        if (PROPS_PATH == null\n-            || (Files.exists(PROPS_PATH) && !Files.isWritable(PROPS_PATH))) {\n+    private static boolean isWritable(Path path) {\n+        if (path == null\n+            || (Files.exists(path) && !Files.isWritable(path))) {\n@@ -454,1 +469,1 @@\n-                        \"Token storage: %s is not writable\\n\", PROPS_PATH);\n+                        \"Token storage: %s is not writable\\n\", path);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/TokenStorage.java","additions":53,"deletions":38,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -42,0 +41,1 @@\n+\n@@ -46,2 +46,0 @@\n-import sun.font.CompositeFontDescriptor;\n-import sun.font.FontConfigManager.FontConfigInfo;\n@@ -50,0 +48,1 @@\n+import sun.font.FontConfigManager.FontConfigInfo;\n@@ -52,0 +51,2 @@\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+\n@@ -181,1 +182,1 @@\n-            ret[i] = new FontDescriptor(componentFaceNames[i], StandardCharsets.ISO_8859_1.newEncoder(), new int[0]);\n+            ret[i] = new FontDescriptor(componentFaceNames[i], ISO_8859_1.newEncoder(), new int[0]);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/FcFontConfiguration.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,0 @@\n-import java.io.UnsupportedEncodingException;\n-import java.lang.ref.WeakReference;\n@@ -39,0 +37,2 @@\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n@@ -216,7 +216,1 @@\n-        byte[] bytes = null;\n-        try {\n-            bytes = xlfd.getBytes(\"UTF-8\");\n-        } catch (UnsupportedEncodingException e) {\n-            bytes = xlfd.getBytes();\n-        }\n-        return haveBitmapFonts(bytes);\n+        return haveBitmapFonts(xlfd.getBytes(UTF_8));\n@@ -226,7 +220,1 @@\n-        byte[] bytes = null;\n-        try {\n-            bytes = xlfd.getBytes(\"UTF-8\");\n-        } catch (UnsupportedEncodingException e) {\n-            bytes = xlfd.getBytes();\n-        }\n-        return fontExists(bytes);\n+        return fontExists(xlfd.getBytes(UTF_8));\n@@ -383,7 +371,1 @@\n-        byte[] bytes = null;\n-        try {\n-            bytes = xlfd.getBytes(\"UTF-8\");\n-        } catch (UnsupportedEncodingException e) {\n-            bytes = xlfd.getBytes();\n-        }\n-        return bytes;\n+        return xlfd.getBytes(UTF_8);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/NativeFont.java","additions":6,"deletions":24,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -27,1 +28,0 @@\n-import java.util.Objects;\n@@ -29,0 +29,3 @@\n+import java.util.Objects;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n@@ -190,4 +193,1 @@\n-            try {\n-                strVal = new String(strBytes, \"UTF-8\");\n-            } catch (java.io.UnsupportedEncodingException uee) {\n-            }\n+            strVal = new String(strBytes, UTF_8);\n@@ -222,4 +222,1 @@\n-                try {\n-                    valueArray[i] = new String(bufBytes, \"UTF-8\");\n-                } catch (java.io.UnsupportedEncodingException uee) {\n-                }\n+                valueArray[i] = new String(bufBytes, UTF_8);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/AttributeClass.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -30,21 +30,3 @@\n-import javax.print.attribute.*;\n-import javax.print.attribute.standard.*;\n-import javax.print.DocFlavor;\n-import javax.print.DocPrintJob;\n-import javax.print.PrintService;\n-import javax.print.ServiceUIFactory;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Locale;\n-import java.util.Date;\n-import java.util.Arrays;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-import javax.print.event.PrintServiceAttributeListener;\n-\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.net.URL;\n-import java.net.URLConnection;\n-import java.net.HttpURLConnection;\n+import java.io.BufferedReader;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataInputStream;\n@@ -53,0 +35,1 @@\n+import java.io.InputStreamReader;\n@@ -55,8 +38,8 @@\n-import java.io.DataInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.ByteArrayInputStream;\n-import java.io.BufferedReader;\n-import java.io.InputStreamReader;\n-import java.nio.charset.Charset;\n-\n-import java.util.Iterator;\n+import java.net.HttpURLConnection;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n@@ -64,0 +47,1 @@\n+import java.util.Locale;\n@@ -66,0 +50,56 @@\n+import javax.print.DocFlavor;\n+import javax.print.DocPrintJob;\n+import javax.print.PrintService;\n+import javax.print.ServiceUIFactory;\n+import javax.print.attribute.Attribute;\n+import javax.print.attribute.AttributeSet;\n+import javax.print.attribute.AttributeSetUtilities;\n+import javax.print.attribute.EnumSyntax;\n+import javax.print.attribute.HashAttributeSet;\n+import javax.print.attribute.HashPrintServiceAttributeSet;\n+import javax.print.attribute.PrintRequestAttribute;\n+import javax.print.attribute.PrintServiceAttribute;\n+import javax.print.attribute.PrintServiceAttributeSet;\n+import javax.print.attribute.Size2DSyntax;\n+import javax.print.attribute.standard.Chromaticity;\n+import javax.print.attribute.standard.ColorSupported;\n+import javax.print.attribute.standard.Copies;\n+import javax.print.attribute.standard.CopiesSupported;\n+import javax.print.attribute.standard.Destination;\n+import javax.print.attribute.standard.DialogOwner;\n+import javax.print.attribute.standard.DialogTypeSelection;\n+import javax.print.attribute.standard.Fidelity;\n+import javax.print.attribute.standard.Finishings;\n+import javax.print.attribute.standard.JobName;\n+import javax.print.attribute.standard.JobSheets;\n+import javax.print.attribute.standard.Media;\n+import javax.print.attribute.standard.MediaPrintableArea;\n+import javax.print.attribute.standard.MediaSize;\n+import javax.print.attribute.standard.MediaSizeName;\n+import javax.print.attribute.standard.MediaTray;\n+import javax.print.attribute.standard.NumberUp;\n+import javax.print.attribute.standard.OrientationRequested;\n+import javax.print.attribute.standard.PDLOverrideSupported;\n+import javax.print.attribute.standard.PageRanges;\n+import javax.print.attribute.standard.PagesPerMinute;\n+import javax.print.attribute.standard.PagesPerMinuteColor;\n+import javax.print.attribute.standard.PrinterInfo;\n+import javax.print.attribute.standard.PrinterIsAcceptingJobs;\n+import javax.print.attribute.standard.PrinterLocation;\n+import javax.print.attribute.standard.PrinterMakeAndModel;\n+import javax.print.attribute.standard.PrinterMessageFromOperator;\n+import javax.print.attribute.standard.PrinterMoreInfo;\n+import javax.print.attribute.standard.PrinterMoreInfoManufacturer;\n+import javax.print.attribute.standard.PrinterName;\n+import javax.print.attribute.standard.PrinterResolution;\n+import javax.print.attribute.standard.PrinterState;\n+import javax.print.attribute.standard.PrinterStateReasons;\n+import javax.print.attribute.standard.PrinterURI;\n+import javax.print.attribute.standard.QueuedJobCount;\n+import javax.print.attribute.standard.RequestingUserName;\n+import javax.print.attribute.standard.SheetCollate;\n+import javax.print.attribute.standard.Sides;\n+import javax.print.event.PrintServiceAttributeListener;\n+\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n@@ -328,5 +368,1 @@\n-        try {\n-            printer = java.net.URLDecoder.decode(name, \"UTF-8\");\n-        } catch (java.io.UnsupportedEncodingException e) {\n-            printer = name;\n-        }\n+        printer = java.net.URLDecoder.decode(name, UTF_8);\n@@ -362,5 +398,1 @@\n-        try {\n-            printer = java.net.URLDecoder.decode(name, \"UTF-8\");\n-        } catch (java.io.UnsupportedEncodingException e) {\n-            printer = name;\n-        }\n+        printer = java.net.URLDecoder.decode(name, UTF_8);\n@@ -1738,3 +1770,2 @@\n-                       BufferedReader d =\n-                           new BufferedReader(new InputStreamReader(is,\n-                                                          Charset.forName(\"ISO-8859-1\")));\n+                       BufferedReader d = new BufferedReader(\n+                               new InputStreamReader(is, ISO_8859_1));\n@@ -1832,7 +1863,1 @@\n-        OutputStreamWriter osw;\n-        try {\n-            osw = new OutputStreamWriter(os, \"UTF-8\");\n-        } catch (java.io.UnsupportedEncodingException exc) {\n-            debug_println(debugPrefix+\"writeIPPRequest, UTF-8 not supported? Exception: \"+exc);\n-            return false;\n-        }\n+        OutputStreamWriter osw = new OutputStreamWriter(os, UTF_8);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/IPPPrintService.java","additions":74,"deletions":49,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,0 @@\n-typedef void GMainContext;\n@@ -64,1 +63,0 @@\n-typedef void GdkPixbuf;\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk2_interface.h","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,2 +183,0 @@\n-typedef void GdkPixbuf;\n-typedef void GMainContext;\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk3_interface.h","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.awt.Image;\n@@ -30,0 +29,1 @@\n+import java.awt.Image;\n@@ -31,1 +31,0 @@\n-\n@@ -33,1 +32,0 @@\n-\n@@ -38,1 +36,0 @@\n-\n@@ -40,1 +37,0 @@\n-\n@@ -51,1 +47,0 @@\n-\n@@ -54,0 +49,3 @@\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n@@ -56,4 +54,0 @@\n-import java.io.IOException;\n-import java.io.UnsupportedEncodingException;\n-import java.io.File;\n-\n@@ -61,1 +55,0 @@\n-\n@@ -63,0 +56,1 @@\n+import java.util.ArrayList;\n@@ -72,1 +66,0 @@\n-\n@@ -76,3 +69,2 @@\n-import java.util.ArrayList;\n-\n-import java.io.ByteArrayOutputStream;\n+import static java.nio.charset.StandardCharsets.UTF_16LE;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n@@ -252,1 +244,1 @@\n-            String st = new String(bytes, 0, bytes.length, \"UTF-16LE\");\n+            String st = new String(bytes, 0, bytes.length, UTF_16LE);\n@@ -278,1 +270,1 @@\n-                        getTransferData(javaTextEncodingFlavor), \"UTF-8\");\n+                        getTransferData(javaTextEncodingFlavor), UTF_8);\n@@ -551,2 +543,0 @@\n-    \/\/static section\n-    public static final String ENCODING = \"UTF-8\";\n@@ -674,7 +664,2 @@\n-        byte[] headerBytes = null, trailerBytes = null;\n-\n-        try {\n-            headerBytes = header.toString().getBytes(ENCODING);\n-            trailerBytes = htmlSuffix.getBytes(ENCODING);\n-        } catch (UnsupportedEncodingException cannotHappen) {\n-        }\n+        byte[] headerBytes = header.toString().getBytes(UTF_8);\n+        byte[] trailerBytes = htmlSuffix.getBytes(UTF_8);\n@@ -789,1 +774,1 @@\n-                        ENCODING\n+                        UTF_8\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WDataTransferer.java","additions":12,"deletions":27,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,0 +127,2 @@\n+                } else {\n+                    p = Packet.fromByteArray(b);\n@@ -128,1 +130,0 @@\n-                p = Packet.fromByteArray(b);\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/TargetVM.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -780,0 +780,1 @@\n+      <setting name=\"stackTrace\">true<\/setting>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -780,0 +780,1 @@\n+      <setting name=\"stackTrace\">true<\/setting>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+serviceability\/sa\/jmap-hprof\/JMapHProfLargeHeapTest.java      8276539   generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-zgc.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -400,1 +400,2 @@\n- -runtime\/signal\n+ -runtime\/signal \\\n+ -runtime\/stack\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-        revision = \"0.16\", extension = \"jar\", unpack = false)\n+        revision = JcstressRunner.VERSION, extension = \"jar\", unpack = false)\n@@ -48,0 +48,1 @@\n+    public static final String VERSION = \"0.17-SNAPSHOT-20240328\";\n@@ -50,3 +51,2 @@\n-    \/\/ Allow to configure jcstress mode parameter.\n-    \/\/ Test mode preset: sanity, quick, default, tough, stress.\n-    public static final String MODE_PROPERTY = \"jcstress.mode\";\n+    public static final String TIME_BUDGET_PROPERTY = \"jcstress.time_budget\";\n+    public static String timeBudget = \"6m\";\n@@ -62,1 +62,1 @@\n-        return artifacts.get(\"org.openjdk.jcstress.jcstress-tests-all-0.16\")\n+        return artifacts.get(\"org.openjdk.jcstress.jcstress-tests-all-\" + VERSION)\n@@ -112,3 +112,0 @@\n-        \/\/ The \"default\" preset might take days for some tests\n-        \/\/ so use quick testing by default.\n-        String mode = \"quick\";\n@@ -116,4 +113,5 @@\n-            if(jvmArg.startsWith(\"-D\" + MODE_PROPERTY)) {\n-                String[] pair = jvmArg.split(\"=\", 2);\n-                mode = pair[1];\n-                continue;\n+            if (jvmArg.startsWith(\"-D\" + TIME_BUDGET_PROPERTY)) {\n+                timeBudget = jvmArg.split(\"=\", 2)[1];\n+            } else {\n+                extraFlags.add(\"--jvmArgs\");\n+                extraFlags.add(jvmArg);\n@@ -121,2 +119,0 @@\n-            extraFlags.add(\"--jvmArgs\");\n-            extraFlags.add(jvmArg);\n@@ -125,2 +121,2 @@\n-        extraFlags.add(\"-m\");\n-        extraFlags.add(mode);\n+        extraFlags.add(\"-tb\");\n+        extraFlags.add(timeBudget);\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/JcstressRunner.java","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -136,1 +137,0 @@\n-        ProcessBuilder pb = new ProcessBuilder(jar.getCommand());\n@@ -138,1 +138,1 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+            OutputAnalyzer output = ProcessTools.executeProcess(jar.getCommand());\n@@ -140,1 +140,1 @@\n-        } catch (IOException ex) {\n+        } catch (Exception ex) {\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/Test7068051.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Pass values on stack.\n+ * @requires os.arch == \"riscv64\"\n+ * @run main\/native compiler.calls.TestManyArgs\n+ *\/\n+\n+package compiler.calls;\n+\n+public class TestManyArgs {\n+    static {\n+        System.loadLibrary(\"TestManyArgs\");\n+    }\n+\n+    native static void scramblestack();\n+\n+    native static int checkargs(int arg0, short arg1, byte arg2,\n+                                int arg3, short arg4, byte arg5,\n+                                int arg6, short arg7, byte arg8,\n+                                int arg9, short arg10, byte arg11);\n+\n+    static int compiledbridge(int arg0, short arg1, byte arg2,\n+                              int arg3, short arg4, byte arg5,\n+                              int arg6, short arg7, byte arg8,\n+                              int arg9, short arg10, byte arg11) {\n+        return checkargs(arg0, arg1, arg2, arg3, arg4, arg5,\n+                         arg6, arg7, arg8, arg9, arg10, arg11);\n+    }\n+\n+    static public void main(String[] args) {\n+        scramblestack();\n+        for (int i = 0; i < 20000; i++) {\n+            int res = compiledbridge((int)0xf, (short)0xf, (byte)0xf,\n+                                     (int)0xf, (short)0xf, (byte)0xf,\n+                                     (int)0xf, (short)0xf, (byte)0xf,\n+                                     (int)0xf, (short)0xf, (byte)0xf);\n+            if (res != 0) {\n+                throw new RuntimeException(\"Test failed\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/TestManyArgs.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+\n+#ifdef riscv64\n+\/* RV64 ABI pass all integers as 64-bit, in registers or on stack\n+ * As compiler may choose to load smaller width than 64-bit if passed on stack,\n+ * this test may not find any bugs.\n+ * Therefore we trick the compiler todo 64-bit loads,\n+ * by saying these args are jlongs.\n+ *\/\n+JNIEXPORT jint JNICALL Java_compiler_calls_TestManyArgs_checkargs(JNIEnv* env, jclass jclazz,\n+                                                                  jlong arg0, jlong arg1, jlong arg2,\n+                                                                  jlong arg3, jlong arg4, jlong arg5,\n+                                                                  jlong arg6, jlong arg7, jlong arg8,\n+                                                                  jlong arg9, jlong arg10, jlong arg11)\n+#else\n+JNIEXPORT jint JNICALL Java_compiler_calls_TestManyArgs_checkargs(JNIEnv* env, jclass jclazz,\n+                                                                  jint arg0, jshort arg1, jbyte arg2,\n+                                                                  jint arg3, jshort arg4, jbyte arg5,\n+                                                                  jint arg6, jshort arg7, jbyte arg8,\n+                                                                  jint arg9, jshort arg10, jbyte arg11)\n+#endif\n+{\n+    if (arg0 != 0xf) return 1;\n+    if (arg1 != 0xf) return 1;\n+    if (arg2 != 0xf) return 1;\n+    if (arg3 != 0xf) return 1;\n+    if (arg4 != 0xf) return 1;\n+    if (arg5 != 0xf) return 1;\n+    if (arg6 != 0xf) return 1;\n+    if (arg7 != 0xf) return 1;\n+    if (arg8 != 0xf) return 1;\n+    if (arg9 != 0xf) return 1;\n+    if (arg10 != 0xf) return 1;\n+    if (arg11 != 0xf) return 1;\n+    return 0;\n+}\n+\n+JNIEXPORT\n+void JNICALL Java_compiler_calls_TestManyArgs_scramblestack(JNIEnv* env, jclass jclazz)\n+{\n+    volatile char stack[12*8];\n+    for (unsigned int i = 0; i < sizeof(stack); i++) {\n+        stack[i] = (char)0xff;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/libTestManyArgs.c","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -54,2 +55,1 @@\n-        ProcessBuilder pb = new ProcessBuilder(jar.getCommand());\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeProcess(jar.getCommand());\n","filename":"test\/hotspot\/jtreg\/compiler\/jsr292\/NonInlinedCall\/Agent.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -63,1 +64,0 @@\n-        ProcessBuilder pb = new ProcessBuilder(jar.getCommand());\n@@ -65,1 +65,1 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+            OutputAnalyzer output = ProcessTools.executeProcess(jar.getCommand());\n@@ -67,1 +67,1 @@\n-        } catch (IOException ex) {\n+        } catch (Exception ex) {\n","filename":"test\/hotspot\/jtreg\/compiler\/profiling\/spectrapredefineclass\/Launcher.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -66,1 +67,0 @@\n-        ProcessBuilder pb = new ProcessBuilder(jar.getCommand());\n@@ -68,1 +68,1 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+            OutputAnalyzer output = ProcessTools.executeProcess(jar.getCommand());\n@@ -70,1 +70,1 @@\n-        } catch (IOException ex) {\n+        } catch (Exception ex) {\n","filename":"test\/hotspot\/jtreg\/compiler\/profiling\/spectrapredefineclass_classloaders\/Launcher.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-        ProcessBuilder pb = GCArguments.createJavaProcessBuilder(\n+        ProcessBuilder pb = GCArguments.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestAggressiveHeap.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @requires vm.gc.G1\n+ * @requires vm.gc.G1 & vm.opt.G1ConcMarkStepDurationMillis == null\n@@ -81,1 +81,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(vmOpts);\n+    ProcessBuilder pb = GCArguments.createTestJvm(vmOpts);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1ConcMarkStepDurationMillis.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+    ProcessBuilder pb = ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/CommandLineDetail.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/CommandLineEmptyArgument.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/CommandLineInvalidArgument.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+    ProcessBuilder pb = ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/CommandLineSummary.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/CommandLineTurnOffNMT.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/JcmdWithNMTDisabled.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,1 +159,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(vmArgs);\n+        ProcessBuilder pb = ProcessTools.createTestJvm(vmArgs);\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/NMTInitializationTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    pb = ProcessTools.createJavaProcessBuilder(\n+    pb = ProcessTools.createTestJvm(\n@@ -48,1 +48,1 @@\n-      pb = ProcessTools.createJavaProcessBuilder(\n+      pb = ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/NMTWithCDS.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+    ProcessBuilder pb = ProcessTools.createTestJvm(\n@@ -58,1 +58,1 @@\n-    ProcessBuilder pb1 = ProcessTools.createJavaProcessBuilder(\n+    ProcessBuilder pb1 = ProcessTools.createTestJvm(\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/PrintNMTStatistics.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/PrintNMTStatisticsWithNMTDisabled.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires vm.cds\n+ * @requires vm.cds & vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @requires os.arch != \"ppc64le\"\n@@ -54,0 +55,1 @@\n+ * @requires os.arch != \"ppc64le\"\n@@ -66,0 +68,1 @@\n+ * @requires os.arch != \"ppc64le\"\n@@ -78,0 +81,1 @@\n+ * @requires os.arch != \"ppc64le\"\n@@ -90,0 +94,1 @@\n+ * @requires os.arch != \"ppc64le\"\n@@ -251,6 +256,0 @@\n-        \/\/ For similar reasons, we skip the test on ppc platforms, since there the smaps\n-        \/\/  format may follow a different logic.\n-        if (Platform.isPPC()) {\n-            throw new SkippedException(\"PPC - skipping this test.\");\n-        }\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTracePageSizes.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack001.\n+ * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     Provoke StackOverflowError by infinite recursion in Java method,\n+ *     intercept the exception try to make one more invocation.\n+ * COMMENTS\n+ *     Kestrel for Solaris_JDK_1.3-b10 crashes while trying to execute\n+ *     this test with Client HS VM.\n+ *     See lots of bugs concerning similar failures:\n+ *     Evaluated:\n+ *     4217960 [native stack overflow bug] reflection test causes crash\n+ *     Accepted:\n+ *     4285716 native stack overflow causes crash on Solaris\n+ *     4281578 Second stack overflow crashes HotSpot VM\n+ *     Closed (duplicate):\n+ *     4027933     Native stack overflows not detected or handled correctly\n+ *     4134353     (hpi) sysThreadCheckStack is a no-op on win32\n+ *     4185411     Various crashes when using recursive reflection.\n+ *     4167055     infinite recursion in FindClass\n+ *     4222359     Infinite recursion crashes jvm\n+ *     Closed (will not fix):\n+ *     4231968 StackOverflowError in a native method causes Segmentation Fault\n+ *     4254634     println() while catching StackOverflowError causes hotspot VM crash\n+ *     4302288 the second stack overflow causes Classic VM to exit on win32\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack001\n+ *\/\n+\n+public class Stack001 {\n+    public static void main(String[] args) {\n+        Stack001 test = new Stack001();\n+        test.recurse(0);\n+        System.out.println(\"Maximal depth: \" + test.maxdepth);\n+    }\n+\n+    private int maxdepth;\n+\n+    private void recurse(int depth) {\n+        maxdepth = depth;\n+        try {\n+            recurse(depth + 1);\n+        } catch (StackOverflowError | OutOfMemoryError e) {\n+            if (maxdepth == depth) {\n+                recurse(depth + 1);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack001.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack002.\n+ * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     Provoke StackOverflowError by infinite recursion in Java method,\n+ *     intercept the exception and continue to invoke that method until\n+ *     the test exceeds timeout, or until Java VM crashes.\n+ * COMMENTS\n+ *     I believe that the test causes HS crashes due to the following bug:\n+ *     4330318 (P2\/S2) NSK test fails as An irrecoverable stack overflow\n+ *     See also bugs (lots of bugs!):\n+ *     Evaluated:\n+ *     4217960 [native stack overflow bug] reflection test causes crash\n+ *     Accepted:\n+ *     4285716 native stack overflow causes crash on Solaris\n+ *     4281578 Second stack overflow crashes HotSpot VM\n+ *     Closed (duplicate):\n+ *     4027933     Native stack overflows not detected or handled correctly\n+ *     4134353     (hpi) sysThreadCheckStack is a no-op on win32\n+ *     4185411     Various crashes when using recursive reflection.\n+ *     4167055     infinite recursion in FindClass\n+ *     4222359     Infinite recursion crashes jvm\n+ *     Closed (will not fix):\n+ *     4231968 StackOverflowError in a native method causes Segmentation Fault\n+ *     4254634     println() while catching StackOverflowError causes hotspot VM crash\n+ *     4302288 the second stack overflow causes Classic VM to exit on win32\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack002\n+ *\/\n+\n+public class Stack002 {\n+    static final long timeout = 10000; \/\/ 10 seconds\n+\n+    public static void main(String[] args) {\n+        Tester tester = new Tester();\n+        Timer timer = new Timer(tester);\n+        timer.start();\n+        tester.start();\n+        while (timer.isAlive())\n+            try {\n+                timer.join();\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+                throw new RuntimeException(e);\n+            }\n+        \/\/      if (tester.isAlive())\n+\/\/          return 2;\n+        System.out.println(\"Maximal depth: \" + tester.maxdepth);\n+    }\n+\n+    private static class Tester extends Thread {\n+        int maxdepth;\n+\n+        public Tester() {\n+            maxdepth = 0;\n+        }\n+\n+        public void run() {\n+            recurse(0);\n+        }\n+\n+        void recurse(int depth) {\n+            maxdepth = depth;\n+            try {\n+                recurse(depth + 1);\n+\/\/          } catch (StackOverflowError e) {\n+\/\/\n+\/\/ OutOfMemoryError is also eligible to indicate stack overflow:\n+\/\/\n+            } catch (StackOverflowError | OutOfMemoryError e) {\n+\n+\/***\n+ *** Originally, I supposed that VM crashes because of unexpected\n+ *** native stack overflow (println() invokes native method).\n+ *** However, I found that HS 1.3 and HS 2.0 crash even on\n+ *** invocation of Java (not native) method.\n+ ***\n+ out.println(\"StackOverflowError, depth=\" + depth);\n+ ***\/\n+                recurse(depth + 1);\n+            }\n+        }\n+    }\n+\n+    private static class Timer extends Thread {\n+        private Tester tester;\n+\n+        public Timer(Tester tester) {\n+            this.tester = tester;\n+        }\n+\n+        public void run() {\n+            long started;\n+            started = System.currentTimeMillis();\n+            while (System.currentTimeMillis() - started < timeout)\n+                ; \/***\n+             *** The test hangs on JDK 1.2.2 Classic VM if sleep() is invoked.\n+             ***\n+             try {\n+             this.sleep(1000);\n+             } catch (InterruptedException e) {\n+             e.printStackTrace(tester.out);\n+             return;\n+             };\n+             ***\/\n+            tester.stop();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack002.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack003.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the same thread\n+ *     by invoking static recursive method for the given fixed depth\n+ *     of recursion (though, for a large depth).\n+ *     This test makes measures a number of recursive invocations\n+ *     before 1st StackOverflowError, and then tries to reproduce\n+ *     such StackOverflowError 100 times -- each time by trying to\n+ *     invoke the same recursive method for the given fixed depth\n+ *     of invocations (which is twice that depth just measured).\n+ *     The test is deemed passed, if VM have not crashed.\n+ * COMMENTS\n+ *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n+ *     platforms (Win32, Solaris, Linux) in all execution modes\n+ *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n+ *     I had tryied it.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack003\n+ *\/\n+\n+public class Stack003 {\n+    final static int ITERATIONS = 100;\n+    final static int INCREMENT = 100;\n+\n+    public static void main(String[] args) {\n+\n+        int depth;\n+        for (depth = 1; ; depth += INCREMENT) {\n+            try {\n+                recurse(depth);\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + depth);\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            try {\n+                recurse(2 * depth);\n+                System.out.println(\"?\");\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ OK.\n+            }\n+        }\n+    }\n+\n+    static void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack003.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack004.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the same thread\n+ *     by invoking final static recursive method for the given fixed\n+ *     depth of recursion (though, for a large depth).\n+ *     This test makes measures a number of recursive invocations\n+ *     before 1st StackOverflowError, and then tries to reproduce\n+ *     such StackOverflowError 100 times -- each time by trying to\n+ *     invoke the same recursive method for the given fixed depth\n+ *     of invocations (which is twice that depth just measured).\n+ *     The test is deemed passed, if VM have not crashed.\n+ * COMMENTS\n+ *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n+ *     platforms (Win32, Solaris, Linux) in all execution modes\n+ *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n+ *     I had tryied it.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack004\n+ *\/\n+\n+public class Stack004 {\n+    public static void main(String[] args) {\n+        Stack004 test = new Stack004();\n+        test.doRun();\n+    }\n+\n+    public void doRun() {\n+        int depth;\n+        for (depth = 100; ; depth += 100) {\n+            try {\n+                recurse(depth);\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + depth);\n+        for (int i = 0; i < 100; i++) {\n+            try {\n+                recurse(2 * depth);\n+                System.out.println(\"?\");\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ OK.\n+            }\n+        }\n+    }\n+\n+    final static void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack004.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack005.\n+ * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the same thread\n+ *     by invoking final recursive method for the given fixed depth of\n+ *     recursion (though, for a large depth).\n+ *     This test makes measures a number of recursive invocations\n+ *     before 1st StackOverflowError, and then tries to reproduce\n+ *     such StackOverflowError 100 times -- each time by trying to\n+ *     invoke the same recursive method for the given fixed depth\n+ *     of invocations (which is twice that depth just measured).\n+ *     The test is deemed passed, if VM have not crashed.\n+ * COMMENTS\n+ *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n+ *     platforms (Win32, Solaris, Linux) in all execution modes\n+ *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n+ *     I had tryied it.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack005\n+ *\/\n+\n+public class Stack005 {\n+    public static void main(String[] args) {\n+        Stack005 test = new Stack005();\n+        int depth;\n+        for (depth = 100; ; depth += 100) {\n+            try {\n+                test.recurse(depth);\n+            } catch (StackOverflowError | OutOfMemoryError soe) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + depth);\n+        for (int i = 0; i < 100; i++) {\n+            try {\n+                test.recurse(2 * depth);\n+                System.out.println(\"?\");\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ OK.\n+            }\n+        }\n+    }\n+\n+    final void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack005.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack006.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the same thread\n+ *     by invoking virtual recursive method for the given fixed depth\n+ *     of recursion (though, for a large depth).\n+ *     This test makes measures a number of recursive invocations\n+ *     before 1st StackOverflowError, and then tries to reproduce\n+ *     such StackOverflowError 100 times -- each time by trying to\n+ *     invoke the same recursive method for the given fixed depth\n+ *     of invocations (which is twice that depth just measured).\n+ *     The test is deemed passed, if VM have not crashed.\n+ * COMMENTS\n+ *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n+ *     platforms (Win32, Solaris, Linux) in all execution modes\n+ *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n+ *     I had tryied it.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack006\n+ *\/\n+\n+public class Stack006 implements Stack006i {\n+    public static void main(String[] args) {\n+        Stack006i test = new Stack006();\n+        int depth;\n+        for (depth = 100; ; depth += 100) {\n+            try {\n+                test.recurse(depth);\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + depth);\n+        for (int i = 0; i < 100; i++) {\n+            try {\n+                test.recurse(2 * depth);\n+                System.out.println(\"?\");\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ OK.\n+            }\n+        }\n+    }\n+\n+    public void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n+\n+interface Stack006i {\n+    void recurse(int depth);\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack006.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack007.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the same thread\n+ *     by invoking synchronized virtual recursive method for the given\n+ *     fixed depth of recursion (though, for a large depth).\n+ *     This test makes measures a number of recursive invocations\n+ *     before 1st StackOverflowError, and then tries to reproduce\n+ *     such StackOverflowError 10000 times -- each time by trying to\n+ *     invoke the same recursive method for the given fixed depth\n+ *     of invocations (which is 10 times that depth just measured).\n+ *     The test is deemed passed, if VM have not crashed.\n+ * COMMENTS\n+ *     This test crashes HS versions 1.3 and 1.4 on Win32, Solaris,\n+ *     and Linux platforms in all execution modes. However, it passes\n+ *     against HS 2.0 on Win32 platform.\n+ *     See also the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack007\n+ *\/\n+\n+public class Stack007 implements Stack007i {\n+    final static int ITERATIONS = 1000;\n+    final static int INCREMENT = 100;\n+\n+    public static void main(String[] args) {\n+        Stack007i test = new Stack007();\n+        int depth;\n+        for (depth = 100; ; depth += INCREMENT) {\n+            try {\n+                test.recurse(depth);\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + depth);\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            try {\n+                test.recurse(10 * depth);\n+                System.out.println(\"?\");\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ OK.\n+            }\n+        }\n+    }\n+\n+    public synchronized void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n+\n+interface Stack007i {\n+    void recurse(int depth);\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack007.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack008.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the same thread\n+ *     by invocations via reflection. Recursive method is invoked for\n+ *     the given fixed depth of recursion (though, for a large depth).\n+ *     This test makes measures a number of recursive invocations\n+ *     before 1st StackOverflowError, and then tries to reproduce\n+ *     such StackOverflowError 100 times -- each time by trying to\n+ *     invoke the same recursive method for the given fixed depth\n+ *     of invocations (which is twice that depth just measured).\n+ *     The test is deemed passed, if VM have not crashed.\n+ * COMMENTS\n+ *     This test crashes all HS versions (2.0, 1.3, 1.4) on Solaris,\n+ *     and crashes HS 2.0 on win32. However, it passes against HS 1.3\n+ *     and 1.4 on Win32.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *     The stack size is too small to run on systems with > 4K page size.\n+ *     Making it bigger could cause timeouts on other platform.\n+ *\n+ * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n+ * @run main\/othervm\/timeout=900 -Xss200K Stack008\n+ *\/\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+public class Stack008 {\n+    public static void main(String[] args) {\n+        int depth;\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        for (depth = 100; ; depth += 100) {\n+            try {\n+                invokeRecurse(depth);\n+            } catch (Throwable exception) {\n+                Throwable target = getTargetException(exception);\n+                if ((target instanceof StackOverflowError) ||\n+                        (target instanceof OutOfMemoryError))\n+                    break; \/\/ OK.\n+                target.printStackTrace();\n+                throw new RuntimeException(exception);\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + depth);\n+        \/\/\n+        \/\/ Provoke stack overflow multiple times:\n+        \/\/\n+        for (int i = 0; i < 100; i++) {\n+            try {\n+                invokeRecurse(2 * depth);\n+\/\/              System.out.println(\"?\");\n+            } catch (Throwable exception) {\n+                Throwable target = getTargetException(exception);\n+                if ((target instanceof StackOverflowError) ||\n+                        (target instanceof OutOfMemoryError))\n+                    continue; \/\/ OK.\n+                target.printStackTrace();\n+                throw new RuntimeException(exception);\n+            }\n+        }\n+    }\n+\n+    private static Throwable getTargetException(Throwable exception) {\n+        Throwable target;\n+        \/\/\n+        \/\/ Unwrap deep chain of exceptions:\n+        \/\/\n+        for (\n+                target = exception;\n+                target instanceof InvocationTargetException;\n+                target = ((InvocationTargetException) target).getTargetException()\n+                )\n+            ;\n+        return target;\n+    }\n+\n+    static Method method = null;\n+    static Stack008 instance = null;\n+    static Object params[] = null;\n+\n+    private static void invokeRecurse(int depth) throws Exception {\n+        if (method == null) {\n+            \/\/\n+            \/\/ Optimization trick: allocate once, use everywhere.\n+            \/\/\n+            instance = new Stack008();\n+            method = Stack008.class.getMethod(\"recurse\");\n+            params = new Object[]{};\n+        }\n+        \/\/\n+        \/\/ Note, that the same instance.depth is used in all invocations:\n+        \/\/\n+        instance.depth = depth;\n+        method.invoke(instance, params);\n+    }\n+\n+    int depth = 0;\n+\n+    public void recurse() throws Exception {\n+        if (depth > 0) {\n+            \/\/\n+            \/\/ Self-invoke via reflection:\n+            \/\/\n+            invokeRecurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack008.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack009.\n+ * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     The test provokes second stack overflow from within the\n+ *     stack overflow handler.\n+ *     This test measures a number of recursive invocations until\n+ *     StackOverflowError, and then tries to make an invocation\n+ *     for the fixed invocations depth from within the \"catch\"\n+ *     block just caught the 1st stack overflow. The depth of new\n+ *     invocations is 10 times that depth seen at the 1st stack\n+ *     overflow; so that another stack overflow occurs.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if there is no exception thrown other than due to stack\n+ *     overflow.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on Win32\n+ *     and Solaris platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack009\n+ *\/\n+\n+public class Stack009 {\n+    public static void main(String[] args) {\n+        for (int depth = 100; ; depth += 100) {\n+            try {\n+                recurse(depth);\n+            } catch (StackOverflowError | OutOfMemoryError error1) {\n+\n+                System.out.println(\"Max. depth: \" + depth);\n+\n+                try {\n+                    recurse(10 * depth);\n+                    System.out.println(\"?\");\n+                } catch (StackOverflowError | OutOfMemoryError error2) {\n+                    \/\/ ignore\n+                }\n+                break;\n+            }\n+        }\n+    }\n+\n+    static void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack009.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack010.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the multiple\n+ *     threads -- by invoking static recursive method for the given\n+ *     fixed depth of recursion (though, for a large depth).\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, 1.4 on Win32 and Solaris\n+ *     platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack010\n+ *\/\n+\n+public class Stack010 extends Thread {\n+    final static int THREADS = 1;\n+    final static int CYCLES = 1;\n+\n+    public static void main(String[] args) {\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (int depth = 10; ; depth += 10) {\n+            try {\n+                recurse(depth);\n+                maxDepth = depth;\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n+        \/\/\n+        Stack010 threads[] = new Stack010[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack010();\n+            threads[i].depthToTry = 100 * maxDepth;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were not thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    int depthToTry = 0;\n+    Throwable thrown = null;\n+\n+    public void run() {\n+        for (int i = 0; i < CYCLES; i++) {\n+            try {\n+                System.out.println(\"depth = \" +depthToTry);\n+                recurse(depthToTry);\n+                throw new Exception(\n+                        \"TEST_RFE: no stack overflow thrown\" +\n+                                \", need to try deeper recursion?\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+\n+    static void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack010.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack011.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the multiple\n+ *     threads -- by invoking final static recursive method for the\n+ *     given fixed depth of recursion (though, for a large depth).\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, 1.4 on Win32 and Solaris\n+ *     platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack011\n+ *\/\n+\n+public class Stack011 extends Thread {\n+    final static int THREADS = 10;\n+    final static int CYCLES = 10;\n+\n+    public static void main(String[] args) {\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (int depth = 10; ; depth += 10) {\n+            try {\n+                recurse(depth);\n+                maxDepth = depth;\n+            } catch (StackOverflowError | OutOfMemoryError soe) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n+        \/\/\n+        Stack011 threads[] = new Stack011[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack011();\n+            threads[i].depthToTry = 10 * maxDepth;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were not thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    int depthToTry = 0;\n+    Throwable thrown = null;\n+\n+    public void run() {\n+        for (int i = 0; i < CYCLES; i++) {\n+            try {\n+                recurse(depthToTry);\n+                throw new Exception(\n+                        \"TEST_RFE: no stack overflow thrown\" +\n+                                \", need to try deeper recursion?\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+\n+    final static void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack011.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack012.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the multiple\n+ *     threads -- by invoking final recursive method for the given\n+ *     fixed depth of recursion (though, for a large depth).\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 1.3, 1.4 on Win32, and HS versions\n+ *     2.0, 1.3, and 1.4 on Solaris. However, it passes against HS 2.0\n+ *     on Win32.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack012\n+ *\/\n+\n+public class Stack012 extends Thread {\n+    final static int THREADS = 10;\n+    final static int CYCLES = 10;\n+\n+    public static void main(String[] args) {\n+        Stack012 test = new Stack012();\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (int depth = 10; ; depth += 10) {\n+            try {\n+                test.recurse(depth);\n+                maxDepth = depth;\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n+        \/\/\n+        Stack012 threads[] = new Stack012[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack012();\n+            threads[i].depthToTry = 10 * maxDepth;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were not thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    int depthToTry = 0;\n+    Throwable thrown = null;\n+\n+    public void run() {\n+        for (int i = 0; i < CYCLES; i++) {\n+            try {\n+                this.recurse(depthToTry);\n+                throw new Exception(\n+                        \"TEST_RFE: no stack overflow thrown\" +\n+                                \", need to try deeper recursion?\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+\n+    final void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack012.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack013.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the multiple\n+ *     threads -- by invoking virtual recursive method for the given\n+ *     fixed depth of recursion (though, for a large depth).\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on both Win32\n+ *     and Solaris platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack013\n+ *\/\n+\n+public class Stack013 extends Stack013i {\n+    final static int THREADS = 10;\n+    final static int CYCLES = 10;\n+\n+    public static void main(String[] args) {\n+        Stack013i test = new Stack013();\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (int depth = 10; ; depth += 10) {\n+            try {\n+                test.recurse(depth);\n+                maxDepth = depth;\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n+        \/\/\n+        Stack013i threads[] = new Stack013i[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack013();\n+            threads[i].depthToTry = 10 * maxDepth;\n+            threads[i].cycles = CYCLES;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n+\n+abstract class Stack013i extends Thread {\n+    \/\/\n+    \/\/ Pure virtual method:\n+    \/\/\n+    abstract void recurse(int depth);\n+\n+    Throwable thrown = null;\n+    int depthToTry;\n+    int cycles;\n+\n+    public void run() {\n+        \/\/\n+        \/\/ Provoke multiple stack overflows:\n+        \/\/\n+        for (int i = 0; i < cycles; i++) {\n+            try {\n+                recurse(depthToTry);\n+                throw new Exception(\n+                        \"TEST_RFE: no stack overflow thrown\" +\n+                                \", need to try deeper recursion?\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack013.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack014.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the multiple\n+ *     threads -- by invoking synchronized virtual recursive method\n+ *     for the given fixed depth of recursion (though, for a large\n+ *     depth). Note however, that different threads are not actual\n+ *     synchronized, because different instances having the recursive\n+ *     method are used.\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on Solaris.\n+ *     However, it passes against all these HS versions on Win32.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack014\n+ *\/\n+\n+public class Stack014 extends Stack014i {\n+    final static int THREADS = 10;\n+    final static int CYCLES = 10;\n+\n+    public static void main(String[] args) {\n+        Stack014i test = new Stack014();\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (int depth = 10; ; depth += 10) {\n+            try {\n+                test.recurse(depth);\n+                maxDepth = depth;\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n+        \/\/\n+        Stack014i threads[] = new Stack014i[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack014();\n+            threads[i].depthToTry = 10 * maxDepth;\n+            threads[i].cycles = CYCLES;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    synchronized void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n+\n+abstract class Stack014i extends Thread {\n+    \/\/\n+    \/\/ Pure virtual method:\n+    \/\/\n+    abstract void recurse(int depth);\n+\n+    Throwable thrown = null;\n+    int depthToTry;\n+    int cycles;\n+\n+    public void run() {\n+        \/\/\n+        \/\/ Provoke multiple stack overflows:\n+        \/\/\n+        for (int i = 0; i < cycles; i++) {\n+            try {\n+                recurse(depthToTry);\n+                throw new Exception(\n+                        \"TEST_RFE: no stack overflow thrown\" +\n+                                \", need to try deeper recursion?\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack014.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack015.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the multiple\n+ *     threads -- by invoking synchronized virtual recursive method\n+ *     for the given fixed depth of recursion from within another\n+ *     recursive method already deeply invoked.\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     in 10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on Solaris.\n+ *     However, it passes against all these HS versions on Win32.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack015\n+ *\/\n+\n+public class Stack015 extends Stack015i {\n+    final static int THREADS = 10;\n+    final static int CYCLES = 10;\n+    final static int STEP = 10;\n+    final static int RESERVE = 10;\n+\n+    public static void main(String[] args) {\n+        \/\/\n+        \/\/ The test will invoke the particular Stack015.recurse()\n+        \/\/ method via abstract test.recurse() invocations.\n+        \/\/\n+        Stack015i test = new Stack015();\n+        Stack015i.test = test;\n+\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (int depth = 0; ; depth += STEP) {\n+            try {\n+                test.recurse(depth);\n+                maxDepth = depth;\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n+        \/\/\n+        Stack015i threads[] = new Stack015i[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack015();\n+            threads[i].depthToTry = RESERVE * maxDepth;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    synchronized void syncRecurse(int depth) {\n+        if (depth > 0) {\n+            syncRecurse(depth - 1);\n+        }\n+    }\n+}\n+\n+abstract class Stack015i extends Thread {\n+    \/\/\n+    \/\/ Pure virtual method:\n+    \/\/\n+    abstract void syncRecurse(int depth);\n+\n+    void recurse(int depth) {\n+        \/\/\n+        \/\/ Stack overflow must occur here:\n+        \/\/\n+        syncRecurse(Stack015.STEP);\n+        \/\/\n+        \/\/ If no stack overflow occured, try again with deeper stack:\n+        \/\/\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+\n+    Throwable thrown = null;\n+    int depthToTry;\n+\n+    static Stack015i test;\n+\n+    public void run() {\n+        \/\/\n+        \/\/ Provoke multiple stack overflows:\n+        \/\/\n+        for (int i = 0; i < Stack015.CYCLES; i++) {\n+            try {\n+                \/\/\n+                \/\/ All threads invoke the same synchronized method:\n+                \/\/\n+                test.recurse(depthToTry);\n+\n+                throw new Exception(\n+                        \"TEST_RFE: no stack overflow thrown\" +\n+                                \", need to try deeper recursion?\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack015.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack016.\n+ * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     The test provokes second stack overflow from within the\n+ *     stack overflow handler -- repeatedly multiple times, and\n+ *     in multiple threads.\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     in 10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before,\n+ *     and then trying to invoke that recursive method once again\n+ *     from within the catch clause just caught StackOverflowError.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n+ *     Solaris and Win32 platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\")\n+ * @run main\/othervm\/timeout=900 -Xint -Xss448K Stack016\n+ * @run main\/othervm\/timeout=900 -Xcomp -Xss448K Stack016\n+ * @run main\/othervm\/timeout=900 -Xcomp -XX:-TieredCompilation -Xss448K Stack016\n+ *\/\n+\n+public class Stack016 extends Thread {\n+    private final static int THREADS = 10;\n+    private final static int CYCLES = 10;\n+    private final static int STEP = 10;\n+    private final static int RESERVE = 10;\n+    private final static int PROBES = STEP * RESERVE;\n+\n+    public static void main(String[] args) {\n+        Stack016 test = new Stack016();\n+        test.doRun();\n+    }\n+\n+    private void doRun() {\n+        \/\/\n+        \/\/ Measure recursive depth before stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (depthToTry = 0; ; depthToTry += STEP) {\n+            try {\n+                trickyRecurse(depthToTry);\n+                maxDepth = depthToTry;\n+            } catch (StackOverflowError | OutOfMemoryError ex) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Maximal recursion depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Run the tested threads:\n+        \/\/\n+        Stack016 threads[] = new Stack016[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack016();\n+            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n+            threads[i].depthToTry = RESERVE * maxDepth;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+\n+        \/\/\n+        \/\/ Check if unexpected exceptions were thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    private int stackTop = 0;\n+    private int depthToTry = 0;\n+    private Throwable thrown = null;\n+\n+    private void trickyRecurse(int depth) {\n+        stackTop = depthToTry - depth;\n+        if (depth > 0) {\n+            try {\n+                trickyRecurse(depth - 1);\n+            } catch (StackOverflowError | OutOfMemoryError error) {\n+                \/\/\n+                \/\/ Provoke more stack overflow,\n+                \/\/ if current stack is deep enough:\n+                \/\/\n+                if (depthToTry - depth < stackTop - PROBES)\n+                    throw error;\n+                recurse(depthToTry);\n+\n+                throw new Error(\"TEST_RFE: try deeper recursion!\");\n+            }\n+        }\n+    }\n+\n+    private static void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+\n+    public void run() {\n+        String threadName = Thread.currentThread().getName();\n+        for (int i = 1; i <= CYCLES; i++) {\n+            try {\n+                System.out.println(threadName + \", iteration: \" + i + \"\/\" + CYCLES +\n+                        \", depthToTry: \" + depthToTry);\n+                trickyRecurse(depthToTry);\n+                throw new Error(\n+                        \"TEST_BUG: trickyRecursion() must throw an error anyway!\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack016.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack017.\n+ * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     The test invokes infinitely recursive method from within stack\n+ *     overflow handler  -- repeatedly multiple times, and in multiple\n+ *     threads.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n+ *     Solaris and Win32 platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n+ * @run main\/othervm\/timeout=900 -Xss220K Stack017\n+ *\/\n+\n+public class Stack017 extends Thread {\n+    private final static int THREADS = 10;\n+    private final static int CYCLES = 10;\n+    private final static int PROBES = 100;\n+\n+    public static void main(String[] args) {\n+        Stack017 test = new Stack017();\n+        test.doRun();\n+    }\n+\n+    private static int depthToTry;\n+\n+    private void doRun() {\n+        \/\/\n+        \/\/ Measure recursive depth before stack overflow:\n+        \/\/\n+        try {\n+            recurse(0);\n+        } catch (StackOverflowError | OutOfMemoryError err) {\n+        }\n+        System.out.println(\"Maximal recursion depth: \" + maxDepth);\n+        depthToTry = maxDepth;\n+\n+        \/\/\n+        \/\/ Run the tested threads:\n+        \/\/\n+        Stack017 threads[] = new Stack017[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack017();\n+            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    private int maxDepth = 0;\n+\n+    private void recurse(int depth) {\n+        maxDepth = depth;\n+        recurse(depth + 1);\n+    }\n+\n+    private void trickyRecurse(int depth) {\n+        try {\n+            maxDepth = depth;\n+            trickyRecurse(depth + 1);\n+        } catch (StackOverflowError | OutOfMemoryError error) {\n+            \/\/\n+            \/\/ Stack problem caught: provoke it again,\n+            \/\/ if current stack is enough deep:\n+            \/\/\n+            if (depth < depthToTry - PROBES)\n+                throw error;\n+            recurse(depth + 1);\n+        }\n+    }\n+\n+    private Throwable thrown = null;\n+\n+    public void run() {\n+        String threadName = Thread.currentThread().getName();\n+        for (int i = 1; i <= CYCLES; i++)\n+            try {\n+                System.out.println(threadName + \", iteration: \" + i + \"\/\" + CYCLES);\n+                trickyRecurse(0);\n+                throw new Exception(\n+                        \"TEST_BUG: stack overflow was expected!\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack017.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack018.\n+ * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows by invocations via\n+ *     reflection -- repeatedly multiple times, and in multiple threads.\n+ *     Recursive method is invoked for the given fixed depth of recursion\n+ *     (though, for a large depth). The test measures a number of recursive\n+ *     invocations until stack overflow, and then tries to reproduce similar\n+ *     stack overflows 10 times in each of 10 threads -- each time by trying\n+ *     to invoke the same recursive method for the given fixed depth\n+ *     of invocations (which is 10 times that crucial depth just measured).\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n+ *     Solaris and Win32 platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n+ * @run main\/othervm\/timeout=900 -Xss220K Stack018\n+ *\/\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+public class Stack018 extends Thread {\n+    private final static int THREADS = 10;\n+    private final static int CYCLES = 10;\n+    private final static int STEP = 100;\n+    private final static int RESERVE = 100;\n+\n+    public static void main(String[] args) {\n+        Stack018 test = new Stack018();\n+        test.doRun();\n+    }\n+\n+    private void doRun() {\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (depthToTry = 0; ; depthToTry += STEP)\n+            try {\n+                invokeRecurse(depthToTry);\n+                maxDepth = depthToTry;\n+            } catch (Throwable exception) {\n+                Throwable target = getTargetException(exception);\n+                if ((target instanceof StackOverflowError) ||\n+                        (target instanceof OutOfMemoryError))\n+                    break; \/\/ OK.\n+                target.printStackTrace();\n+                throw new RuntimeException(exception);\n+            }\n+        System.out.println(\"Maximal recursion depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Run the tested threads:\n+        \/\/\n+        Stack018 threads[] = new Stack018[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack018();\n+            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n+            threads[i].depthToTry = RESERVE * maxDepth;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were thrown:\n+        \/\/\n+        int exitCode = 0;\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                System.out.println(\"# \" + threads[i].getName()\n+                        + \": \" + threads[i].thrown);\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    private int depthToTry = 0;\n+    private Throwable thrown = null;\n+\n+    public void run() {\n+        String threadName = Thread.currentThread().getName();\n+        for (int i = 1; i <= CYCLES; i++)\n+            try {\n+                System.out.println(threadName + \", iteration: \" + i + \"\/\" + CYCLES);\n+                invokeRecurse(depthToTry);\n+                throw new Error(\"TEST_RFE: try deeper invocations!\");\n+\n+            } catch (Throwable exception) {\n+                Throwable target = getTargetException(exception);\n+                if ((target instanceof StackOverflowError) ||\n+                        (target instanceof OutOfMemoryError))\n+                    continue; \/\/ OK.\n+                thrown = target;\n+                break;\n+            }\n+    }\n+\n+    private static Throwable getTargetException(Throwable exception) {\n+        Throwable target;\n+        \/\/\n+        \/\/ Unwrap deep chain of exceptions to find StackOverflowError:\n+        \/\/\n+        for (\n+                target = exception;\n+                target instanceof InvocationTargetException;\n+                target = ((InvocationTargetException) target).getTargetException()\n+                )\n+            ;\n+        return target;\n+    }\n+\n+    private Method method = null;\n+    private Object params[] = null;\n+\n+    private void invokeRecurse(int depth) throws Exception {\n+        if (method == null) {\n+            \/\/\n+            \/\/ Optimization trick: allocate once, use everywhere.\n+            \/\/\n+            method = Stack018.class.getMethod(\"recurse\");\n+            params = new Object[]{};\n+        }\n+        this.depth = depth; \/\/ actual parameter\n+        method.invoke(this, params);\n+    }\n+\n+    private int depth = 0; \/\/ actual parameter for recurse()\n+\n+    public void recurse() throws Exception {\n+        if (depth > 0) {\n+            \/\/\n+            \/\/ Self-invoke via reflection:\n+            \/\/\n+            invokeRecurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack018.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack019.\n+ * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     The test invokes infinitely recursive method from within stack\n+ *     overflow handler -- repeatedly multiple times in a single thread.\n+ *     The test is deemed passed, if VM have not crashed, and if exception\n+ *     other than due to stack overflow was not thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n+ *     Solaris and Win32 platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *     The stack size is too small to run on systems with > 4K page size.\n+ *     Making it bigger could cause timeouts on other platform.\n+ *\n+ * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n+ * @requires os.family != \"windows\"\n+ * @run main\/othervm\/timeout=900 -Xss200K Stack019\n+ *\/\n+\n+public class Stack019 {\n+    private final static int CYCLES = 50;\n+    private final static int PROBES = 50;\n+\n+    public static void main(String[] args) {\n+        \/\/\n+        \/\/ Measure recursive depth before stack overflow:\n+        \/\/\n+        try {\n+            recurse(0);\n+        } catch (StackOverflowError | OutOfMemoryError err) {\n+        }\n+        System.out.println(\"Maximal recursion depth: \" + maxDepth);\n+        depthToTry = maxDepth;\n+\n+        \/\/\n+        \/\/ Run the tested threads:\n+        \/\/\n+        for (int i = 0; i < CYCLES; i++) {\n+            try {\n+                System.out.println(\"Iteration: \" + i + \"\/\" + CYCLES);\n+                trickyRecurse(0);\n+                throw new RuntimeException(\"# TEST_BUG: stack overflow was expected!\");\n+            } catch (StackOverflowError | OutOfMemoryError error) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                throw new RuntimeException(throwable);\n+            }\n+        }\n+    }\n+\n+    private static int maxDepth;\n+    private static int depthToTry;\n+\n+    private static void recurse(int depth) {\n+        maxDepth = depth;\n+        recurse(depth + 1);\n+    }\n+\n+    private static void trickyRecurse(int depth) {\n+        try {\n+            maxDepth = depth;\n+            trickyRecurse(depth + 1);\n+        } catch (StackOverflowError | OutOfMemoryError error){\n+            \/\/\n+            \/\/ Stack problem caught: provoke it again,\n+            \/\/ if current stack is enough deep:\n+            \/\/\n+            if (depth < depthToTry - PROBES) {\n+                throw error;\n+            }\n+            recurse(depth + 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack019.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,6 +75,0 @@\n-    @Override\n-    public void onDebuggeeError(String message) {\n-        System.err.println(\"Debuggee error: '\" + message + \"'\");\n-        System.exit(1);\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/jdwp\/AllModulesCommandTest.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import jdk.test.lib.JDKToolFinder;\n@@ -28,0 +27,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -48,6 +48,0 @@\n-        \/**\n-         * Callback to handle any debuggee error\n-         *\n-         * @param line line from the debuggee's stderr\n-         *\/\n-        void onDebuggeeError(String line);\n@@ -57,1 +51,0 @@\n-    private static final String CLS_DIR = System.getProperty(\"test.classes\", \"\").trim();\n@@ -59,0 +52,2 @@\n+    private static final String JDWP_OPT = \"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=0\";\n+\n@@ -61,2 +56,0 @@\n-    private StreamHandler inputHandler;\n-    private StreamHandler errorHandler;\n@@ -73,1 +66,1 @@\n-     * debuggee's stdout and stderr outputs\n+     * debuggee's stdout output. stderr might contain jvm output, which is just printed to the log.\n@@ -79,1 +72,1 @@\n-        ProcessBuilder pb = new ProcessBuilder(getCommand());\n+        ProcessBuilder pb = ProcessTools.createTestJvm(JDWP_OPT, DEBUGGEE);\n@@ -81,2 +74,2 @@\n-        inputHandler = new StreamHandler(p.getInputStream(), this);\n-        errorHandler = new StreamHandler(p.getErrorStream(), this);\n+        StreamHandler inputHandler = new StreamHandler(p.getInputStream(), this);\n+        StreamHandler errorHandler = new StreamHandler(p.getErrorStream(), l -> System.out.println(\"[stderr]: \" + l));\n@@ -87,16 +80,0 @@\n-    \/**\n-     * Command to start the debuggee with the JDWP options and using the JDK\n-     * under test\n-     *\n-     * @return the command\n-     *\/\n-    private String[] getCommand() {\n-        return new String[]{\n-            JDKToolFinder.getTestJDKTool(\"java\"),\n-            getJdwpOptions(),\n-            \"-cp\",\n-            CLS_DIR,\n-            DEBUGGEE\n-        };\n-    }\n-\n@@ -112,9 +89,0 @@\n-    \/**\n-     * Debuggee JDWP options\n-     *\n-     * @return the JDWP options to start the debuggee with\n-     *\/\n-    private static String getJdwpOptions() {\n-        return \"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=0\";\n-    }\n-\n@@ -132,10 +100,2 @@\n-    public void onStringRead(StreamHandler handler, String line) {\n-        if (handler.equals(errorHandler)) {\n-            terminateDebuggee();\n-            listener.onDebuggeeError(line);\n-        } else {\n-            processDebuggeeOutput(line);\n-        }\n-    }\n-\n-    private void processDebuggeeOutput(String line) {\n+    public void onStringRead(String line) {\n+        System.out.println(\"[stdout]: \" + line);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jdwp\/DebuggeeLauncher.java","additions":10,"deletions":50,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-         * @param handler this StreamHandler\n@@ -43,1 +42,1 @@\n-        void onStringRead(StreamHandler handler, String s);\n+        void onStringRead(String s);\n@@ -74,1 +73,1 @@\n-                listener.onStringRead(this, line);\n+                listener.onStringRead(line);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jdwp\/StreamHandler.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +60,1 @@\n+import jdk.test.lib.Utils;\n@@ -65,0 +67,1 @@\n+ * @library \/test\/lib\n@@ -74,2 +77,0 @@\n-    public static final String ARGUMENTS = \"\";\n-\n@@ -122,1 +123,1 @@\n-        optionsArg.setValue(ARGUMENTS);\n+        optionsArg.setValue(String.join(\" \", Utils.getTestJavaOpts()));\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/8036666\/GetObjectLockCount.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.InputStreamReader;\n@@ -32,1 +33,0 @@\n-import java.util.Scanner;\n@@ -80,1 +80,1 @@\n-        ProcessBuilder procBuilder = ProcessTools.createJavaProcessBuilder(\n+        ProcessBuilder procBuilder = ProcessTools.createTestJvm(\n@@ -85,2 +85,2 @@\n-        try (Scanner largeHeapScanner = new Scanner(\n-                largeHeapProc.getInputStream());) {\n+        try (BufferedReader r = new BufferedReader(\n+                new InputStreamReader(largeHeapProc.getInputStream()))) {\n@@ -88,2 +88,8 @@\n-            if (!largeHeapScanner.hasNext()) {\n-                throw new RuntimeException (\"Test failed: could not open largeHeapScanner.\");\n+            while ((pidstring = r.readLine()) != null) {\n+                \/\/ The output might contain different VM output, skip it while searching PID line.\n+                if (pidstring.matches(\"PID\\\\[[0-9].*\\\\]\")) {\n+                    System.out.println(\"Found: \" + pidstring);\n+                    break;\n+                } else {\n+                    System.out.println(\"Ignoring: \" + pidstring);\n+                }\n@@ -91,2 +97,2 @@\n-            while ((pidstring = largeHeapScanner.findInLine(\"PID\\\\[[0-9].*\\\\]\")) == null) {\n-                Thread.sleep(500);\n+            if (pidstring == null) {\n+                throw new RuntimeException(\"Not able to find string matching PID.\");\n@@ -94,0 +100,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/jmap-hprof\/JMapHProfLargeHeapTest.java","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -152,2 +152,0 @@\n-\/\/        System.out.println(\"WhiteBox.getWhiteBox().g1GetTotalCollections() = \\t\" + WhiteBox.getWhiteBox().g1GetTotalCollections());\n-\/\/        System.out.println(\"WhiteBox.getWhiteBox().g1GetTotalFullCollections() = \\t\" + WhiteBox.getWhiteBox().g1GetTotalFullCollections());\n@@ -161,1 +159,1 @@\n-\/\/        if (WhiteBox.getWhiteBox().g1GetTotalFullCollections() != 0 || (oldGenBean != null && oldGenBean.getCollectionCount() != 0)) {\n+\n@@ -163,1 +161,1 @@\n-            throw new RuntimeException(\"Full gc happened. Test was useless.\");\n+            throw new SkippedException(\"Full gc happened, skip the test.\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/UnloadingTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,18 +112,2 @@\n-\n-        if (argsHandler.verbose()) {\n-            debugee = binder.bindToDebugee(debugeeName + \" -vbs\");\n-        } else {\n-            debugee = binder.bindToDebugee(debugeeName);\n-        }\n-\n-        IOPipe pipe     = new IOPipe(debugee);\n-\n-\n-        debugee.redirectStderr(out);\n-        debugee.resume();\n-\n-        String line = pipe.readln();\n-        if (!line.equals(\"ready\")) {\n-            logHandler.complain(\"# Cannot recognize debugee's signal: \" + line);\n-            return 2;\n-        };\n+        debugee = Debugee.prepareDebugee(argsHandler, logHandler,\n+                debugeeName + (argsHandler.verbose() ? \" -vbs\" : \"\"));\n@@ -168,4 +152,2 @@\n-        pipe.println(\"quit\");\n-        debugee.waitFor();\n-\n-        int status = debugee.getStatus();\n+        debugee.sendSignal(\"quit\");\n+        int status = debugee.endDebugee();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/Accessible\/isPackagePrivate\/accipp001.java","additions":5,"deletions":23,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-            pipe = SocketIOPipe.createClientIOPipe(log, \"localhost\", portNumber, 0);\n+            pipe = SocketIOPipe.createClientIOPipe(log, portNumber, 0);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/AttachingConnector\/attach\/attach004\/attach004t.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n@@ -71,1 +73,2 @@\n-    static private volatile boolean testFailed, eventsReceived, threadsStarted;\n+    static private volatile boolean testFailed;\n+    static private CountDownLatch eventsReceivedLatch;\n@@ -82,3 +85,1 @@\n-        eventsReceived = false;\n-        threadsStarted = false;\n-\n+        eventsReceivedLatch = new CountDownLatch(1);\n@@ -114,2 +115,4 @@\n-                    \/\/ handle events until all threads started and all expected events received\n-                    while (!(threadsStarted && eventsReceived)) {\n+                    boolean isConnected = true;\n+                    boolean allEventsReceived = false;\n+                    \/\/ handle events until debuggee is disconnected\n+                    while (isConnected) {\n@@ -133,2 +136,4 @@\n-                            \/\/ handle ClassPrepareEvent\n-                            if (event instanceof ClassPrepareEvent) {\n+                            if (event instanceof VMDeathEvent || event instanceof VMDisconnectEvent) {\n+                                log.display(\"eventHandler got \" + event);\n+                                isConnected = false;\n+                            } else  if (event instanceof ClassPrepareEvent) {\n@@ -198,5 +203,14 @@\n-                                              \/\/ Check that all expected ClassPrepareEvent are received\n-                                              eventsReceived = true;\n-                                              for (int i = 0; i < checkedTypes.length; i++) {\n-                                                   if (checkedTypes[i][2] == \"0\")\n-                                                       eventsReceived = false;\n+                                              \/\/ Check that all expected ClassPrepareEvent(s) are received.\n+                                              if (!allEventsReceived) {\n+                                                  allEventsReceived = true;\n+                                                  for (int i = 0; i < checkedTypes.length; i++) {\n+                                                      \/\/ checkedTypes[i][2] is \"0\" initially,\n+                                                      \/\/ \"1\" after corresponding ClassPrepareEvent is received.\n+                                                      if (checkedTypes[i][2] == \"0\") {\n+                                                          allEventsReceived = false;\n+                                                          break;\n+                                                      }\n+                                                  }\n+                                                  if (allEventsReceived) {\n+                                                      eventsReceivedLatch.countDown();\n+                                                  }\n@@ -219,1 +233,3 @@\n-                        eventSet.resume();\n+                        if (isConnected) {\n+                            eventSet.resume();\n+                        }\n@@ -260,3 +276,0 @@\n-            \/\/ notify EventHandler that all threads started\n-            threadsStarted = true;\n-\n@@ -265,6 +278,4 @@\n-                  eventHandler.join(eventTimeout);\n-                  if (eventHandler.isAlive()) {\n-                      log.complain(\"FAILURE 20: Timeout for waiting event was exceeded\");\n-                      eventHandler.interrupt();\n-                      testFailed = true;\n-                  }\n+                if (!eventsReceivedLatch.await(eventTimeout, TimeUnit.MILLISECONDS)) {\n+                    log.complain(\"FAILURE 20: Timeout waiting for all events was exceeded\");\n+                    testFailed = true;\n+                }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ClassPrepareEvent\/referenceType\/refType001.java","additions":34,"deletions":23,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n@@ -75,1 +77,2 @@\n-    static private volatile boolean testFailed, eventsReceived, threadsStarted;\n+    static private volatile boolean testFailed;\n+    static private CountDownLatch eventsReceivedLatch;\n@@ -86,2 +89,1 @@\n-        eventsReceived = false;\n-        threadsStarted = false;\n+        eventsReceivedLatch = new CountDownLatch(1);\n@@ -134,2 +136,4 @@\n-                    \/\/ handle events until all threads started and all expected events received\n-                    while (!(threadsStarted && eventsReceived)) {\n+                    boolean isConnected = true;\n+                    boolean allEventsReceived = false;\n+                    \/\/ handle events until debuggee is disconnected\n+                    while (isConnected) {\n@@ -153,2 +157,4 @@\n-                            \/\/ handle ClassPrepareEvent\n-                            if (event instanceof ClassPrepareEvent) {\n+                            if (event instanceof VMDeathEvent || event instanceof VMDisconnectEvent) {\n+                                log.display(\"eventHandler got \" + event);\n+                                isConnected = false;\n+                            } else  if (event instanceof ClassPrepareEvent) {\n@@ -227,6 +233,14 @@\n-                                          \/\/ Check that all expected ClassPrepareEvent are received\n-                                          eventsReceived = true;\n-                                          for (int i = 0; i < checkedThreads.length; i++) {\n-                                               if (checkedThreads[i][2] == \"0\") {\n-                                                    eventsReceived = false;\n-                                               }\n+                                          \/\/ Check that all expected ClassPrepareEvent(s) are received.\n+                                          if (!allEventsReceived) {\n+                                              allEventsReceived = true;\n+                                              for (int i = 0; i < checkedThreads.length; i++) {\n+                                                  \/\/ checkedTypes[i][2] is \"0\" initially,\n+                                                  \/\/ \"1\" after corresponding ClassPrepareEvent is received.\n+                                                  if (checkedThreads[i][2] == \"0\") {\n+                                                      allEventsReceived = false;\n+                                                      break;\n+                                                   }\n+                                              }\n+                                              if (allEventsReceived) {\n+                                                  eventsReceivedLatch.countDown();\n+                                              }\n@@ -243,1 +257,3 @@\n-                        eventSet.resume();\n+                        if (isConnected) {\n+                            eventSet.resume();\n+                        }\n@@ -283,3 +299,0 @@\n-            \/\/ notify EventHandler that all threads started\n-            threadsStarted = true;\n-\n@@ -288,6 +301,4 @@\n-                  eventHandler.join(eventTimeout);\n-                  if (eventHandler.isAlive()) {\n-                      log.complain(\"FAILURE 20: Timeout for waiting event was exceeded\");\n-                      eventHandler.interrupt();\n-                      testFailed = true;\n-                  }\n+                if (!eventsReceivedLatch.await(eventTimeout, TimeUnit.MILLISECONDS)) {\n+                    log.complain(\"FAILURE 20: Timeout waiting for all events was exceeded\");\n+                    testFailed = true;\n+                }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ClassPrepareEvent\/thread\/thread001.java","additions":34,"deletions":23,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -171,0 +171,1 @@\n+        pipe.println(COMMAND_QUIT);\n@@ -172,1 +173,0 @@\n-            elThread.isConnected = false;\n@@ -183,1 +183,0 @@\n-        pipe.println(COMMAND_QUIT);\n@@ -198,1 +197,0 @@\n-        public volatile boolean isConnected = true;\n@@ -202,0 +200,1 @@\n+                boolean isConnected = true;\n@@ -208,2 +207,2 @@\n-                            if (event instanceof VMDeathEvent) {\n-                                tot_res = FAILED;\n+                            if (event instanceof VMDeathEvent || event instanceof VMDisconnectEvent) {\n+                                log.display(\"EventListener: got \" + event);\n@@ -211,6 +210,1 @@\n-                                log.complain(\"TEST FAILED: unexpected VMDeathEvent\");\n-                            } else if (event instanceof VMDisconnectEvent) {\n-                                tot_res = FAILED;\n-                                isConnected = false;\n-                                log.complain(\"TEST FAILED: unexpected VMDisconnectEvent\");\n-                            } else\n+                            } else {\n@@ -219,3 +213,2 @@\n-                        }\n-                        if (isConnected) {\n-                            eventSet.resume();\n+                                eventSet.resume();\n+                            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequestManager\/threadDeathRequests\/thrdeathreq001.java","additions":7,"deletions":14,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        Terminator.java, TimeoutHandler.java\n+        TimeoutHandler.java\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/README","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,172 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.share;\n-\n-\/**\n- * Terminator is used to terminate a stress test with PASS exit status\n- * before the test is terminated as timed out (and so failed).\n- *\n- * <p>Terminator class holds a thread which sleeps for the given amount\n- * of time, and then wakes up and executes <tt>System.exit()<\/tt>\n- * with the given exit status. That thread is daemon, so it doesn't\n- * prevent application from exiting once all its threads finish\n- * before it's time for termination. Appointing terminator in zero\n- * delay implies immediate <tt>exit()<\/tt>.\n- *\n- * <p>There is a limitation: you may appoint no more than one terminator\n- * per application.\n- *\/\n-public class Terminator {\n-    \/**\n-     * Use specific <tt>appoint()<\/tt> method to appoint terminator.\n-     *\n-     * @see #appoint(int)\n-     * @see #appoint(int,int)\n-     *\/\n-    protected Terminator() {}\n-\n-    \/**\n-     * One terminator per application, or <tt>null<\/tt> (by default).\n-     *\/\n-    private static Thread terminator = null;\n-\n-    \/**\n-     * <p>Return timeout (or waittime) value munus the margin\n-     * value (which is assumed 1 minute by default).\n-     *\n-     * <p>Treat <tt>args[0]<\/tt> as <tt>$TIMEOUT<\/tt> value, or seek for\n-     * <tt>-waittime=$WAITTIME<\/tt> value. If both parameters\n-     * (or either none of them) are assigned, throw an exception to\n-     * report parameters inconsistency.\n-     *\n-     * <p>Also, seek for <tt>-margin=...<\/tt> assignment, or assume margin\n-     * is 1 minute.\n-     *\n-     * @param args Is usually obtained via the application's command-line.\n-     *\n-     * @throws IllegalArgumentException If <tt>args[]<\/tt> is inconsistent.\n-     *\n-     * @see #appoint(int)\n-     * @see #appoint(int,int)\n-     *\/\n-    public static int parseAppointment(String args[]) {\n-        int timeout=-1, margin=1;\n-        int timeouts=0, waittimes=0, margins=0;\n-        for (int i=0; i<args.length; i++) {\n-            if (args[i].startsWith(\"-\")) {\n-                if (args[i].startsWith(\"-waittime=\")) {\n-                    timeout = Integer.parseInt(args[i].substring(10));\n-                    waittimes++;\n-                }\n-                if (args[i].startsWith(\"-margin=\")) {\n-                    margin = Integer.parseInt(args[i].substring(8));\n-                    margins++;\n-                }\n-            } else {\n-                if (i == 0) {\n-                    timeout = Integer.parseInt(args[i]);\n-                    timeouts++;\n-                }\n-            }\n-        };\n-        if (timeouts==0 && waittimes==0)\n-            throw new IllegalArgumentException(\n-                \"no $TIMEOUT, nor -waittime=$WAITTIME is set\");\n-        if (waittimes > 1)\n-            throw new IllegalArgumentException(\n-                \"more than one -waittime=... is set\");\n-        if (margins > 1)\n-            throw new IllegalArgumentException(\n-                \"more than one -margin=... is set\");\n-\n-        int result = timeout - margin;\n-        if (result <= 0)\n-            throw new IllegalArgumentException(\n-                \"delay appointment must be greater than \"+margin+\" minutes\");\n-        return result;\n-    }\n-\n-    \/**\n-     * Appoint terminator after the given amount of <tt>minutes<\/tt>,\n-     * so that exit status would be 95 (to simulate JCK-like PASS\n-     * status).\n-     *\n-     * @throws IllegalStateException If terminator is already appointed.\n-     *\n-     * @see #appoint(int,int)\n-     * @see #parseAppointment(String[])\n-     *\/\n-    public static void appoint(int minutes) {\n-        appoint(minutes,95); \/\/ JCK-like PASS status\n-    }\n-\n-    \/**\n-     * Appoint Terminator for the given amount of <tt>minutes<\/tt>,\n-     * so that the given <tt>status<\/tt> would be exited when time\n-     * is over.\n-     *\n-     * @throws IllegalStateException If terminator is already appointed.\n-     *\n-     * @see #appoint(int)\n-     * @see #parseAppointment(String[])\n-     *\/\n-    public static void appoint(int minutes, int status) {\n-        if (terminator != null)\n-            throw new IllegalStateException(\"Terminator is already appointed.\");\n-\n-        final long timeToExit = System.currentTimeMillis() + 60*1000L*minutes;\n-        final int  exitStatus = status;\n-\n-        terminator = new Thread(Terminator.class.getName()) {\n-            public void run() {\n-                long timeToSleep = timeToExit - System.currentTimeMillis();\n-                if (timeToSleep > 0)\n-                    try {\n-                        \/\/\n-                        \/\/ Use wait() instead of sleep(), because Java 2\n-                        \/\/ specification doesn't guarantee the method\n-                        \/\/ sleep() to yield to other threads.\n-                        \/\/\n-                        Object someDummyObject = new Object();\n-                        synchronized (someDummyObject) {\n-                            someDummyObject.wait(timeToSleep);\n-                        }\n-                    } catch (InterruptedException exception) {\n-                        exception.printStackTrace(System.err);\n-                        return;\n-                    };\n-                \/\/\n-                \/\/ OK, lets do it now:\n-                \/\/\n-                System.err.println(\n-                    \"#\\n# Terminator: prescheduled program termination.\\n#\");\n-                System.exit(exitStatus); \/\/ terminator to all threads\n-            }\n-        };\n-\n-        terminator.setPriority(Thread.MAX_PRIORITY);\n-        terminator.setDaemon(true);\n-        terminator.start();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/Terminator.java","additions":0,"deletions":172,"binary":false,"changes":172,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-        pipe = SocketIOPipe.createClientIOPipe(log, \"localhost\", argParser.getPort(), 0);\n+        pipe = SocketIOPipe.createClientIOPipe(log, argParser.getPort(), 0);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/aod\/DummyTargetApplication.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -344,1 +344,1 @@\n-                pipe = SocketIOPipe.createClientIOPipe(log, \"localhost\", argParser.getPort(), 0);\n+                pipe = SocketIOPipe.createClientIOPipe(log, argParser.getPort(), 0);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/aod\/TargetApplicationWaitingAgents.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-     * \"<i>localhost<\/i>\" string by default.\n+     * empty string (represents an address of the loopback interface) by default.\n@@ -116,1 +116,1 @@\n-        return options.getProperty(\"test.host\", \"localhost\");\n+        return options.getProperty(\"test.host\", \"\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeArgumentHandler.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,1 +183,1 @@\n-                pipeServerSocket.bind(null);\n+                pipeServerSocket.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeBinder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -113,1 +113,5 @@\n-    \/** Created and return new IOPipe channel to the debugee VM. *\/\n+    \/** Create and return new IOPipe channel to the debuggee VM.\n+     * The channel should be created before debuggee starts execution,\n+     * i.e. the method assumes debuggee is started, but suspended before\n+     * its main class is loaded.\n+     *\/\n@@ -118,1 +122,1 @@\n-        pipe = new IOPipe(this);\n+        pipe = IOPipe.startDebuggerPipe(binder);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeProcess.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-    public static IOPipe startDebuggerPipe(Binder binder) {\n+    public static IOPipe startDebuggerPipe(DebugeeBinder binder) {\n@@ -98,1 +98,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/IOPipe.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.net.InetAddress;\n@@ -38,1 +39,1 @@\n- * and 'createClientIOPipe(Log log, String host, int port, long timeout)' for client SocketIOPipe.\n+ * and 'createClientIOPipe(Log log, int port, long timeout)' for client SocketIOPipe.\n@@ -43,2 +44,2 @@\n- * For example, if client process should send string 'OK' to the server process which is run\n- * at the host 'SERVER_HOST' following code can be written:\n+ * For example, if client process should send string 'OK' to the server process,\n+ * the following code can be written:\n@@ -56,2 +57,2 @@\n- *  \/\/ initialize SocketIOPipe with given values of server host name and port\n- *  SocketIOPipe pipe = SocketIOPipe.createClientIOPipe(log, 'SERVER_HOST', port, timeoutValue);\n+ *  \/\/ initialize SocketIOPipe with given port\n+ *  SocketIOPipe pipe = SocketIOPipe.createClientIOPipe(log, port, timeoutValue);\n@@ -123,1 +124,1 @@\n-            ss.bind(new InetSocketAddress(port));\n+            ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), port));\n@@ -143,2 +144,3 @@\n-    public static SocketIOPipe createClientIOPipe(Log log, String host, int port, long timeout) {\n-        return new SocketIOPipe(log, DEFAULT_PIPE_LOG_PREFIX, host, port, timeout, false);\n+    public static SocketIOPipe createClientIOPipe(Log log, int port, long timeout) {\n+        \/\/ use null for host to connect to loopback address\n+        return new SocketIOPipe(log, DEFAULT_PIPE_LOG_PREFIX, null, port, timeout, false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/SocketIOPipe.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import jtreg.SkippedException;\n+\n@@ -85,0 +87,2 @@\n+                        } catch (SkippedException se) {\n+                                throw se;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/test\/Tests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack001.\n- * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     Provoke StackOverflowError by infinite recursion in Java method,\n- *     intercept the exception try to make one more invocation.\n- * COMMENTS\n- *     Kestrel for Solaris_JDK_1.3-b10 crashes while trying to execute\n- *     this test with Client HS VM.\n- *     See lots of bugs concerning similar failures:\n- *     Evaluated:\n- *     4217960 [native stack overflow bug] reflection test causes crash\n- *     Accepted:\n- *     4285716 native stack overflow causes crash on Solaris\n- *     4281578 Second stack overflow crashes HotSpot VM\n- *     Closed (duplicate):\n- *     4027933     Native stack overflows not detected or handled correctly\n- *     4134353     (hpi) sysThreadCheckStack is a no-op on win32\n- *     4185411     Various crashes when using recursive reflection.\n- *     4167055     infinite recursion in FindClass\n- *     4222359     Infinite recursion crashes jvm\n- *     Closed (will not fix):\n- *     4231968 StackOverflowError in a native method causes Segmentation Fault\n- *     4254634     println() while catching StackOverflowError causes hotspot VM crash\n- *     4302288 the second stack overflow causes Classic VM to exit on win32\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack001\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack001 {\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack001 test = new stack001();\n-        test.recurse(0);\n-        out.println(\"Maximal depth: \" + test.maxdepth);\n-        return 0;\n-    }\n-\n-    private int maxdepth;\n-\n-    private void recurse(int depth) {\n-        maxdepth = depth;\n-        try {\n-            recurse(depth + 1);\n-        } catch (Error error) {\n-            if (!(error instanceof StackOverflowError) &&\n-                    !(error instanceof OutOfMemoryError))\n-                throw error;\n-\n-            if (maxdepth == depth)\n-                recurse(depth + 1);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack001.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -1,153 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack002.\n- * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     Provoke StackOverflowError by infinite recursion in Java method,\n- *     intercept the exception and continue to invoke that method until\n- *     the test exceeds timeout, or until Java VM crashes.\n- * COMMENTS\n- *     I believe that the test causes HS crashes due to the following bug:\n- *     4330318 (P2\/S2) NSK test fails as An irrecoverable stack overflow\n- *     See also bugs (lots of bugs!):\n- *     Evaluated:\n- *     4217960 [native stack overflow bug] reflection test causes crash\n- *     Accepted:\n- *     4285716 native stack overflow causes crash on Solaris\n- *     4281578 Second stack overflow crashes HotSpot VM\n- *     Closed (duplicate):\n- *     4027933     Native stack overflows not detected or handled correctly\n- *     4134353     (hpi) sysThreadCheckStack is a no-op on win32\n- *     4185411     Various crashes when using recursive reflection.\n- *     4167055     infinite recursion in FindClass\n- *     4222359     Infinite recursion crashes jvm\n- *     Closed (will not fix):\n- *     4231968 StackOverflowError in a native method causes Segmentation Fault\n- *     4254634     println() while catching StackOverflowError causes hotspot VM crash\n- *     4302288 the second stack overflow causes Classic VM to exit on win32\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack002\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack002 {\n-    static final long timeout = 10000; \/\/ 10 seconds\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        Tester tester = new Tester(out);\n-        Timer timer = new Timer(tester);\n-        timer.start();\n-        tester.start();\n-        while (timer.isAlive())\n-            try {\n-                timer.join();\n-            } catch (InterruptedException e) {\n-                e.printStackTrace(out);\n-                return 2;\n-            }\n-        \/\/      if (tester.isAlive())\n-\/\/          return 2;\n-        out.println(\"Maximal depth: \" + tester.maxdepth);\n-        return 0;\n-    }\n-\n-    private static class Tester extends Thread {\n-        int maxdepth;\n-        PrintStream out;\n-\n-        public Tester(PrintStream out) {\n-            this.out = out;\n-            maxdepth = 0;\n-        }\n-\n-        public void run() {\n-            recurse(0);\n-        }\n-\n-        void recurse(int depth) {\n-            maxdepth = depth;\n-            try {\n-                recurse(depth + 1);\n-\/\/          } catch (StackOverflowError e) {\n-\/\/\n-\/\/ OutOfMemoryError is also eligible to indicate stack overflow:\n-\/\/\n-            } catch (Error error) {\n-                if (!(error instanceof StackOverflowError) &&\n-                        !(error instanceof OutOfMemoryError))\n-                    throw error;\n-\n-\/***\n- *** Originally, I supposed that VM crashes because of unexpected\n- *** native stack overflow (println() invokes native method).\n- *** However, I found that HS 1.3 and HS 2.0 crash even on\n- *** invocation of Java (not native) method.\n- ***\n- out.println(\"StackOverflowError, depth=\" + depth);\n- ***\/\n-                recurse(depth + 1);\n-            }\n-        }\n-    }\n-\n-    private static class Timer extends Thread {\n-        private Tester tester;\n-\n-        public Timer(Tester tester) {\n-            this.tester = tester;\n-        }\n-\n-        public void run() {\n-            long started;\n-            started = System.currentTimeMillis();\n-            while (System.currentTimeMillis() - started < timeout)\n-                ; \/***\n-             *** The test hangs on JDK 1.2.2 Classic VM if sleep() is invoked.\n-             ***\n-             try {\n-             this.sleep(1000);\n-             } catch (InterruptedException e) {\n-             e.printStackTrace(tester.out);\n-             return;\n-             };\n-             ***\/\n-            tester.stop();\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack002.java","additions":0,"deletions":153,"binary":false,"changes":153,"status":"deleted"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack003.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the same thread\n- *     by invoking static recursive method for the given fixed depth\n- *     of recursion (though, for a large depth).\n- *     This test makes measures a number of recursive invocations\n- *     before 1st StackOverflowError, and then tries to reproduce\n- *     such StackOverflowError 100 times -- each time by trying to\n- *     invoke the same recursive method for the given fixed depth\n- *     of invocations (which is twice that depth just measured).\n- *     The test is deemed passed, if VM have not crashed.\n- * COMMENTS\n- *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n- *     platforms (Win32, Solaris, Linux) in all execution modes\n- *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n- *     I had tryied it.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack003\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack003 {\n-    final static int ITERATIONS = 100;\n-    final static int INCREMENT = 100;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        int depth;\n-        for (depth = 1; ; depth += INCREMENT)\n-            try {\n-                recurse(depth);\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + depth);\n-        for (int i = 0; i < ITERATIONS; i++)\n-            try {\n-                recurse(2 * depth);\n-                out.println(\"?\");\n-            } catch (StackOverflowError soe) {\n-                \/\/ OK.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK.\n-            }\n-        return 0;\n-    }\n-\n-    static void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack003.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,97 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack004.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the same thread\n- *     by invoking final static recursive method for the given fixed\n- *     depth of recursion (though, for a large depth).\n- *     This test makes measures a number of recursive invocations\n- *     before 1st StackOverflowError, and then tries to reproduce\n- *     such StackOverflowError 100 times -- each time by trying to\n- *     invoke the same recursive method for the given fixed depth\n- *     of invocations (which is twice that depth just measured).\n- *     The test is deemed passed, if VM have not crashed.\n- * COMMENTS\n- *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n- *     platforms (Win32, Solaris, Linux) in all execution modes\n- *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n- *     I had tryied it.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack004\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack004 {\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack004 test = new stack004();\n-        int exitCode = test.doRun(args, out);\n-        return exitCode;\n-    }\n-\n-    public int doRun(String args[], PrintStream out) {\n-        int depth;\n-        for (depth = 100; ; depth += 100)\n-            try {\n-                recurse(depth);\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + depth);\n-        for (int i = 0; i < 100; i++)\n-            try {\n-                recurse(2 * depth);\n-                out.println(\"?\");\n-            } catch (StackOverflowError soe) {\n-                \/\/ OK.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK.\n-            }\n-        return 0;\n-    }\n-\n-    final static void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack004.java","additions":0,"deletions":97,"binary":false,"changes":97,"status":"deleted"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack005.\n- * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the same thread\n- *     by invoking final recursive method for the given fixed depth of\n- *     recursion (though, for a large depth).\n- *     This test makes measures a number of recursive invocations\n- *     before 1st StackOverflowError, and then tries to reproduce\n- *     such StackOverflowError 100 times -- each time by trying to\n- *     invoke the same recursive method for the given fixed depth\n- *     of invocations (which is twice that depth just measured).\n- *     The test is deemed passed, if VM have not crashed.\n- * COMMENTS\n- *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n- *     platforms (Win32, Solaris, Linux) in all execution modes\n- *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n- *     I had tryied it.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack005\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack005 {\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack005 test = new stack005();\n-        int depth;\n-        for (depth = 100; ; depth += 100)\n-            try {\n-                test.recurse(depth);\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + depth);\n-        for (int i = 0; i < 100; i++)\n-            try {\n-                test.recurse(2 * depth);\n-                out.println(\"?\");\n-            } catch (StackOverflowError soe) {\n-                \/\/ OK.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK.\n-            }\n-        return 0;\n-    }\n-\n-    final void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack005.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack006.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the same thread\n- *     by invoking virtual recursive method for the given fixed depth\n- *     of recursion (though, for a large depth).\n- *     This test makes measures a number of recursive invocations\n- *     before 1st StackOverflowError, and then tries to reproduce\n- *     such StackOverflowError 100 times -- each time by trying to\n- *     invoke the same recursive method for the given fixed depth\n- *     of invocations (which is twice that depth just measured).\n- *     The test is deemed passed, if VM have not crashed.\n- * COMMENTS\n- *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n- *     platforms (Win32, Solaris, Linux) in all execution modes\n- *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n- *     I had tryied it.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack006\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack006 implements stack006i {\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack006i test = new stack006();\n-        int depth;\n-        for (depth = 100; ; depth += 100)\n-            try {\n-                test.recurse(depth);\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + depth);\n-        for (int i = 0; i < 100; i++)\n-            try {\n-                test.recurse(2 * depth);\n-                out.println(\"?\");\n-            } catch (StackOverflowError soe) {\n-                \/\/ OK.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK.\n-            }\n-        return 0;\n-    }\n-\n-    public void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n-\n-interface stack006i {\n-    void recurse(int depth);\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack006.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack007.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the same thread\n- *     by invoking synchronized virtual recursive method for the given\n- *     fixed depth of recursion (though, for a large depth).\n- *     This test makes measures a number of recursive invocations\n- *     before 1st StackOverflowError, and then tries to reproduce\n- *     such StackOverflowError 10000 times -- each time by trying to\n- *     invoke the same recursive method for the given fixed depth\n- *     of invocations (which is 10 times that depth just measured).\n- *     The test is deemed passed, if VM have not crashed.\n- * COMMENTS\n- *     This test crashes HS versions 1.3 and 1.4 on Win32, Solaris,\n- *     and Linux platforms in all execution modes. However, it passes\n- *     against HS 2.0 on Win32 platform.\n- *     See also the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack007\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack007 implements stack007i {\n-    final static int ITERATIONS = 1000;\n-    final static int INCREMENT = 100;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack007i test = new stack007();\n-        int depth;\n-        for (depth = 100; ; depth += INCREMENT)\n-            try {\n-                test.recurse(depth);\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + depth);\n-        for (int i = 0; i < ITERATIONS; i++)\n-            try {\n-                test.recurse(10 * depth);\n-                out.println(\"?\");\n-            } catch (StackOverflowError soe) {\n-                \/\/ OK.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK.\n-            }\n-        return 0;\n-    }\n-\n-    public synchronized void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n-\n-interface stack007i {\n-    void recurse(int depth);\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack007.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -1,149 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack008.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the same thread\n- *     by invocations via reflection. Recursive method is invoked for\n- *     the given fixed depth of recursion (though, for a large depth).\n- *     This test makes measures a number of recursive invocations\n- *     before 1st StackOverflowError, and then tries to reproduce\n- *     such StackOverflowError 100 times -- each time by trying to\n- *     invoke the same recursive method for the given fixed depth\n- *     of invocations (which is twice that depth just measured).\n- *     The test is deemed passed, if VM have not crashed.\n- * COMMENTS\n- *     This test crashes all HS versions (2.0, 1.3, 1.4) on Solaris,\n- *     and crashes HS 2.0 on win32. However, it passes against HS 1.3\n- *     and 1.4 on Win32.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *     The stack size is too small to run on systems with > 4K page size.\n- *     Making it bigger could cause timeouts on other platform.\n- *\n- * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n- * @run main\/othervm\/timeout=900 -Xss200K nsk.stress.stack.stack008\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-\n-public class stack008 {\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        int depth;\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        for (depth = 100; ; depth += 100)\n-            try {\n-                invokeRecurse(depth);\n-            } catch (Throwable exception) {\n-                Throwable target = getTargetException(exception);\n-                if ((target instanceof StackOverflowError) ||\n-                        (target instanceof OutOfMemoryError))\n-                    break; \/\/ OK.\n-                target.printStackTrace(out);\n-                if (target instanceof ThreadDeath)\n-                    throw (ThreadDeath) target;\n-                return 2;\n-            }\n-        out.println(\"Max. depth: \" + depth);\n-        \/\/\n-        \/\/ Provoke stack overflow multiple times:\n-        \/\/\n-        for (int i = 0; i < 100; i++)\n-            try {\n-                invokeRecurse(2 * depth);\n-\/\/              out.println(\"?\");\n-            } catch (Throwable exception) {\n-                Throwable target = getTargetException(exception);\n-                if ((target instanceof StackOverflowError) ||\n-                        (target instanceof OutOfMemoryError))\n-                    continue; \/\/ OK.\n-                target.printStackTrace(out);\n-                if (target instanceof ThreadDeath)\n-                    throw (ThreadDeath) target;\n-                return 2;\n-            }\n-        return 0;\n-    }\n-\n-    private static Throwable getTargetException(Throwable exception) {\n-        Throwable target;\n-        \/\/\n-        \/\/ Unwrap deep chain of exceptions:\n-        \/\/\n-        for (\n-                target = exception;\n-                target instanceof InvocationTargetException;\n-                target = ((InvocationTargetException) target).getTargetException()\n-                )\n-            ;\n-        return target;\n-    }\n-\n-    static Method method = null;\n-    static stack008 instance = null;\n-    static Object params[] = null;\n-\n-    private static void invokeRecurse(int depth) throws Exception {\n-        if (method == null) {\n-            \/\/\n-            \/\/ Optimization trick: allocate once, use everywhere.\n-            \/\/\n-            instance = new stack008();\n-            method = stack008.class.getMethod(\"recurse\");\n-            params = new Object[]{};\n-        }\n-        \/\/\n-        \/\/ Note, that the same instance.depth is used in all invocations:\n-        \/\/\n-        instance.depth = depth;\n-        method.invoke(instance, params);\n-    }\n-\n-    int depth = 0;\n-\n-    public void recurse() throws Exception {\n-        if (depth > 0)\n-            \/\/\n-            \/\/ Self-invoke via reflection:\n-            \/\/\n-            invokeRecurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack008.java","additions":0,"deletions":149,"binary":false,"changes":149,"status":"deleted"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack009.\n- * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     The test provokes second stack overflow from within the\n- *     stack overflow handler.\n- *     This test measures a number of recursive invocations until\n- *     StackOverflowError, and then tries to make an invocation\n- *     for the fixed invocations depth from within the \"catch\"\n- *     block just caught the 1st stack overflow. The depth of new\n- *     invocations is 10 times that depth seen at the 1st stack\n- *     overflow; so that another stack overflow occurs.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if there is no exception thrown other than due to stack\n- *     overflow.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on Win32\n- *     and Solaris platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack009\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack009 {\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        for (int depth = 100; ; depth += 100)\n-            try {\n-                recurse(depth);\n-            } catch (Error error1) {\n-                if (!(error1 instanceof StackOverflowError) &&\n-                        !(error1 instanceof OutOfMemoryError))\n-                    throw error1;\n-\n-                out.println(\"Max. depth: \" + depth);\n-\n-                try {\n-                    recurse(10 * depth);\n-                    out.println(\"?\");\n-                } catch (Error error2) {\n-                    if (!(error2 instanceof StackOverflowError) &&\n-                            !(error2 instanceof OutOfMemoryError))\n-                        throw error2;\n-\n-                    \/\/ Stack overflow is OK here.\n-                }\n-\n-                break;\n-            }\n-        return 0;\n-    }\n-\n-    static void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack009.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -1,145 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack010.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the multiple\n- *     threads -- by invoking static recursive method for the given\n- *     fixed depth of recursion (though, for a large depth).\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, 1.4 on Win32 and Solaris\n- *     platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack010\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack010 extends Thread {\n-    final static int THREADS = 10;\n-    final static int CYCLES = 10;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (int depth = 10; ; depth += 10)\n-            try {\n-                recurse(depth);\n-                maxDepth = depth;\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n-        \/\/\n-        stack010 threads[] = new stack010[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack010();\n-            threads[i].depthToTry = 10 * maxDepth;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were not thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    int depthToTry = 0;\n-    Throwable thrown = null;\n-\n-    public void run() {\n-        for (int i = 0; i < CYCLES; i++)\n-            try {\n-                recurse(depthToTry);\n-                throw new Exception(\n-                        \"TEST_RFE: no stack overflow thrown\" +\n-                                \", need to try deeper recursion?\");\n-\n-            } catch (StackOverflowError soe) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK: out of memory may indacate stack overflow.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-\n-    static void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack010.java","additions":0,"deletions":145,"binary":false,"changes":145,"status":"deleted"},{"patch":"@@ -1,145 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack011.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the multiple\n- *     threads -- by invoking final static recursive method for the\n- *     given fixed depth of recursion (though, for a large depth).\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, 1.4 on Win32 and Solaris\n- *     platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack011\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack011 extends Thread {\n-    final static int THREADS = 10;\n-    final static int CYCLES = 10;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (int depth = 10; ; depth += 10)\n-            try {\n-                recurse(depth);\n-                maxDepth = depth;\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n-        \/\/\n-        stack011 threads[] = new stack011[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack011();\n-            threads[i].depthToTry = 10 * maxDepth;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were not thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    int depthToTry = 0;\n-    Throwable thrown = null;\n-\n-    public void run() {\n-        for (int i = 0; i < CYCLES; i++)\n-            try {\n-                recurse(depthToTry);\n-                throw new Exception(\n-                        \"TEST_RFE: no stack overflow thrown\" +\n-                                \", need to try deeper recursion?\");\n-\n-            } catch (StackOverflowError error) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK: recursion may result in memory lack.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-\n-    final static void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack011.java","additions":0,"deletions":145,"binary":false,"changes":145,"status":"deleted"},{"patch":"@@ -1,147 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack012.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the multiple\n- *     threads -- by invoking final recursive method for the given\n- *     fixed depth of recursion (though, for a large depth).\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 1.3, 1.4 on Win32, and HS versions\n- *     2.0, 1.3, and 1.4 on Solaris. However, it passes against HS 2.0\n- *     on Win32.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack012\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack012 extends Thread {\n-    final static int THREADS = 10;\n-    final static int CYCLES = 10;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack012 test = new stack012();\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (int depth = 10; ; depth += 10)\n-            try {\n-                test.recurse(depth);\n-                maxDepth = depth;\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n-        \/\/\n-        stack012 threads[] = new stack012[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack012();\n-            threads[i].depthToTry = 10 * maxDepth;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were not thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    int depthToTry = 0;\n-    Throwable thrown = null;\n-\n-    public void run() {\n-        for (int i = 0; i < CYCLES; i++)\n-            try {\n-                this.recurse(depthToTry);\n-                throw new Exception(\n-                        \"TEST_RFE: no stack overflow thrown\" +\n-                                \", need to try deeper recursion?\");\n-\n-            } catch (StackOverflowError error) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK: invocation may result in out of memory.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-\n-    final void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack012.java","additions":0,"deletions":147,"binary":false,"changes":147,"status":"deleted"},{"patch":"@@ -1,158 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack013.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the multiple\n- *     threads -- by invoking virtual recursive method for the given\n- *     fixed depth of recursion (though, for a large depth).\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on both Win32\n- *     and Solaris platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack013\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack013 extends stack013i {\n-    final static int THREADS = 10;\n-    final static int CYCLES = 10;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack013i test = new stack013();\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (int depth = 10; ; depth += 10)\n-            try {\n-                test.recurse(depth);\n-                maxDepth = depth;\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n-        \/\/\n-        stack013i threads[] = new stack013i[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack013();\n-            threads[i].depthToTry = 10 * maxDepth;\n-            threads[i].cycles = CYCLES;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n-\n-abstract class stack013i extends Thread {\n-    \/\/\n-    \/\/ Pure virtual method:\n-    \/\/\n-    abstract void recurse(int depth);\n-\n-    Throwable thrown = null;\n-    int depthToTry;\n-    int cycles;\n-\n-    public void run() {\n-        \/\/\n-        \/\/ Provoke multiple stack overflows:\n-        \/\/\n-        for (int i = 0; i < cycles; i++)\n-            try {\n-                recurse(depthToTry);\n-                throw new Exception(\n-                        \"TEST_RFE: no stack overflow thrown\" +\n-                                \", need to try deeper recursion?\");\n-\n-            } catch (StackOverflowError error) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK: out of memory is eligible here.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack013.java","additions":0,"deletions":158,"binary":false,"changes":158,"status":"deleted"},{"patch":"@@ -1,161 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack014.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the multiple\n- *     threads -- by invoking synchronized virtual recursive method\n- *     for the given fixed depth of recursion (though, for a large\n- *     depth). Note however, that different threads are not actual\n- *     synchronized, because different instances having the recursive\n- *     method are used.\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on Solaris.\n- *     However, it passes against all these HS versions on Win32.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack014\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack014 extends stack014i {\n-    final static int THREADS = 10;\n-    final static int CYCLES = 10;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack014i test = new stack014();\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (int depth = 10; ; depth += 10)\n-            try {\n-                test.recurse(depth);\n-                maxDepth = depth;\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n-        \/\/\n-        stack014i threads[] = new stack014i[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack014();\n-            threads[i].depthToTry = 10 * maxDepth;\n-            threads[i].cycles = CYCLES;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    synchronized void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n-\n-abstract class stack014i extends Thread {\n-    \/\/\n-    \/\/ Pure virtual method:\n-    \/\/\n-    abstract void recurse(int depth);\n-\n-    Throwable thrown = null;\n-    int depthToTry;\n-    int cycles;\n-\n-    public void run() {\n-        \/\/\n-        \/\/ Provoke multiple stack overflows:\n-        \/\/\n-        for (int i = 0; i < cycles; i++)\n-            try {\n-                recurse(depthToTry);\n-                throw new Exception(\n-                        \"TEST_RFE: no stack overflow thrown\" +\n-                                \", need to try deeper recursion?\");\n-\n-            } catch (StackOverflowError error) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK: if there is no memory for stack expansion.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack014.java","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"},{"patch":"@@ -1,183 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack015.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the multiple\n- *     threads -- by invoking synchronized virtual recursive method\n- *     for the given fixed depth of recursion from within another\n- *     recursive method already deeply invoked.\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     in 10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on Solaris.\n- *     However, it passes against all these HS versions on Win32.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack015\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack015 extends stack015i {\n-    final static int THREADS = 10;\n-    final static int CYCLES = 10;\n-    final static int STEP = 10;\n-    final static int RESERVE = 10;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        \/\/\n-        \/\/ The test will invoke the particular stack015.recurse()\n-        \/\/ method via abstract test.recurse() invocations.\n-        \/\/\n-        stack015i test = new stack015();\n-        stack015i.test = test;\n-\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (int depth = 0; ; depth += STEP)\n-            try {\n-                test.recurse(depth);\n-                maxDepth = depth;\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n-        \/\/\n-        stack015i threads[] = new stack015i[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack015();\n-            threads[i].depthToTry = RESERVE * maxDepth;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    synchronized void syncRecurse(int depth) {\n-        if (depth > 0)\n-            syncRecurse(depth - 1);\n-    }\n-}\n-\n-abstract class stack015i extends Thread {\n-    \/\/\n-    \/\/ Pure virtual method:\n-    \/\/\n-    abstract void syncRecurse(int depth);\n-\n-    void recurse(int depth) {\n-        \/\/\n-        \/\/ Stack overflow must occur here:\n-        \/\/\n-        syncRecurse(stack015.STEP);\n-        \/\/\n-        \/\/ If no stack overflow occured, try again with deeper stack:\n-        \/\/\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-\n-    Throwable thrown = null;\n-    int depthToTry;\n-\n-    static stack015i test;\n-\n-    public void run() {\n-        \/\/\n-        \/\/ Provoke multiple stack overflows:\n-        \/\/\n-        for (int i = 0; i < stack015.CYCLES; i++)\n-            try {\n-                \/\/\n-                \/\/ All threads invoke the same synchronized method:\n-                \/\/\n-                test.recurse(depthToTry);\n-\n-                throw new Exception(\n-                        \"TEST_RFE: no stack overflow thrown\" +\n-                                \", need to try deeper recursion?\");\n-\n-            } catch (StackOverflowError error) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK: there may be no memory for stack expansion.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack015.java","additions":0,"deletions":183,"binary":false,"changes":183,"status":"deleted"},{"patch":"@@ -1,210 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack016.\n- * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     The test provokes second stack overflow from within the\n- *     stack overflow handler -- repeatedly multiple times, and\n- *     in multiple threads.\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     in 10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before,\n- *     and then trying to invoke that recursive method once again\n- *     from within the catch clause just caught StackOverflowError.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n- *     Solaris and Win32 platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\")\n- * @library \/vmTestbase\n- * @build nsk.share.Terminator\n- * @run main\/othervm\/timeout=900 -Xint -Xss448K nsk.stress.stack.stack016 -eager\n- * @run main\/othervm\/timeout=900 -Xcomp -Xss448K nsk.stress.stack.stack016 -eager\n- * @run main\/othervm\/timeout=900 -Xcomp -XX:-TieredCompilation -Xss448K nsk.stress.stack.stack016 -eager\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import nsk.share.Terminator;\n-\n-import java.io.PrintStream;\n-\n-public class stack016 extends Thread {\n-    private final static int THREADS = 10;\n-    private final static int CYCLES = 10;\n-    private final static int STEP = 10;\n-    private final static int RESERVE = 10;\n-    private final static int PROBES = STEP * RESERVE;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        verbose = false;\n-        boolean eager = false;\n-        for (int i = 0; i < args.length; i++)\n-            if (args[i].toLowerCase().equals(\"-verbose\"))\n-                verbose = true;\n-            else if (args[i].toLowerCase().equals(\"-eager\"))\n-                eager = true;\n-        if (!eager)\n-            Terminator.appoint(Terminator.parseAppointment(args));\n-        stack016.out = out;\n-        stack016 test = new stack016();\n-        return test.doRun();\n-    }\n-\n-    private static boolean verbose;\n-    private static PrintStream out;\n-\n-    private void display(Object message) {\n-        if (!verbose)\n-            return;\n-        synchronized (out) {\n-            out.println(message.toString());\n-        }\n-    }\n-\n-    private int doRun() {\n-        \/\/\n-        \/\/ Measure recursive depth before stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (depthToTry = 0; ; depthToTry += STEP) {\n-            try {\n-                trickyRecurse(depthToTry);\n-                maxDepth = depthToTry;\n-            } catch (StackOverflowError | OutOfMemoryError ex) {\n-                break;\n-            }\n-        }\n-        out.println(\"Maximal recursion depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Run the tested threads:\n-        \/\/\n-        stack016 threads[] = new stack016[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack016();\n-            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n-            threads[i].depthToTry = RESERVE * maxDepth;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++) {\n-            if (threads[i].isAlive()) {\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-            }\n-        }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++) {\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-        }\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    private int stackTop = 0;\n-    private int depthToTry = 0;\n-    private Throwable thrown = null;\n-\n-    private void trickyRecurse(int depth) {\n-        stackTop = depthToTry - depth;\n-        if (depth > 0) {\n-            try {\n-                trickyRecurse(depth - 1);\n-            } catch (Error error) {\n-                if (!(error instanceof StackOverflowError) &&\n-                        !(error instanceof OutOfMemoryError))\n-                    throw error;\n-\n-                \/\/\n-                \/\/ Provoke more stack overflow,\n-                \/\/ if current stack is deep enough:\n-                \/\/\n-                if (depthToTry - depth < stackTop - PROBES)\n-                    throw error;\n-                recurse(depthToTry);\n-\n-                throw new Error(\"TEST_RFE: try deeper recursion!\");\n-            }\n-        }\n-    }\n-\n-    private static void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-\n-    public void run() {\n-        String threadName = Thread.currentThread().getName();\n-        for (int i = 1; i <= CYCLES; i++) {\n-            try {\n-                display(threadName + \", iteration: \" + i + \"\/\" + CYCLES +\n-                        \", depthToTry: \" + depthToTry);\n-                trickyRecurse(depthToTry);\n-                throw new Error(\n-                        \"TEST_BUG: trickyRecursion() must throw an error anyway!\");\n-\n-            } catch (StackOverflowError error) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK, if there is no memory for stack expansion.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                thrown = throwable;\n-                break;\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack016.java","additions":0,"deletions":210,"binary":false,"changes":210,"status":"deleted"},{"patch":"@@ -1,190 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack017.\n- * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     The test invokes infinitely recursive method from within stack\n- *     overflow handler  -- repeatedly multiple times, and in multiple\n- *     threads.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n- *     Solaris and Win32 platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n- * @library \/vmTestbase\n- * @build nsk.share.Terminator\n- * @run main\/othervm\/timeout=900 -Xss220K nsk.stress.stack.stack017 -eager\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import nsk.share.Terminator;\n-\n-import java.io.PrintStream;\n-\n-public class stack017 extends Thread {\n-    private final static int THREADS = 10;\n-    private final static int CYCLES = 10;\n-    private final static int PROBES = 100;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        verbose = false;\n-        boolean eager = false;\n-        for (int i = 0; i < args.length; i++)\n-            if (args[i].toLowerCase().equals(\"-verbose\"))\n-                verbose = true;\n-            else if (args[i].toLowerCase().equals(\"-eager\"))\n-                eager = true;\n-        if (!eager)\n-            Terminator.appoint(Terminator.parseAppointment(args));\n-        stack017.out = out;\n-        stack017 test = new stack017();\n-        return test.doRun();\n-    }\n-\n-    private static boolean verbose;\n-    private static PrintStream out;\n-\n-    private void display(Object message) {\n-        if (!verbose)\n-            return;\n-        synchronized (out) {\n-            out.println(message.toString());\n-        }\n-    }\n-\n-    private static int depthToTry;\n-\n-    private int doRun() {\n-        \/\/\n-        \/\/ Measure recursive depth before stack overflow:\n-        \/\/\n-        try {\n-            recurse(0);\n-        } catch (StackOverflowError soe) {\n-        } catch (OutOfMemoryError oome) {\n-        }\n-        out.println(\"Maximal recursion depth: \" + maxDepth);\n-        depthToTry = maxDepth;\n-\n-        \/\/\n-        \/\/ Run the tested threads:\n-        \/\/\n-        stack017 threads[] = new stack017[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack017();\n-            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    private int maxDepth = 0;\n-\n-    private void recurse(int depth) {\n-        maxDepth = depth;\n-        recurse(depth + 1);\n-    }\n-\n-    private void trickyRecurse(int depth) {\n-        try {\n-            maxDepth = depth;\n-            trickyRecurse(depth + 1);\n-        } catch (Error error) {\n-            if (!(error instanceof StackOverflowError) &&\n-                    !(error instanceof OutOfMemoryError))\n-                throw error;\n-\n-            \/\/\n-            \/\/ Stack problem caught: provoke it again,\n-            \/\/ if current stack is enough deep:\n-            \/\/\n-            if (depth < depthToTry - PROBES)\n-                throw error;\n-            recurse(depth + 1);\n-        }\n-    }\n-\n-    private Throwable thrown = null;\n-\n-    public void run() {\n-        String threadName = Thread.currentThread().getName();\n-        for (int i = 1; i <= CYCLES; i++)\n-            try {\n-                display(threadName + \", iteration: \" + i + \"\/\" + CYCLES);\n-                trickyRecurse(0);\n-                throw new Exception(\n-                        \"TEST_BUG: stack overflow was expected!\");\n-\n-            } catch (StackOverflowError oome) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK, if there is no memory for stack expansion.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack017.java","additions":0,"deletions":190,"binary":false,"changes":190,"status":"deleted"},{"patch":"@@ -1,218 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack018.\n- * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows by invocations via\n- *     reflection -- repeatedly multiple times, and in multiple threads.\n- *     Recursive method is invoked for the given fixed depth of recursion\n- *     (though, for a large depth). The test measures a number of recursive\n- *     invocations until stack overflow, and then tries to reproduce similar\n- *     stack overflows 10 times in each of 10 threads -- each time by trying\n- *     to invoke the same recursive method for the given fixed depth\n- *     of invocations (which is 10 times that crucial depth just measured).\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n- *     Solaris and Win32 platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n- * @library \/vmTestbase\n- * @build nsk.share.Terminator\n- * @run main\/othervm\/timeout=900 -Xss220K nsk.stress.stack.stack018 -eager\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import nsk.share.Terminator;\n-\n-import java.io.PrintStream;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-\n-public class stack018 extends Thread {\n-    private final static int THREADS = 10;\n-    private final static int CYCLES = 10;\n-    private final static int STEP = 100;\n-    private final static int RESERVE = 100;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        verbose = false;\n-        boolean eager = false;\n-        for (int i = 0; i < args.length; i++)\n-            if (args[i].toLowerCase().equals(\"-verbose\"))\n-                verbose = true;\n-            else if (args[i].toLowerCase().equals(\"-eager\"))\n-                eager = true;\n-        if (!eager)\n-            Terminator.appoint(Terminator.parseAppointment(args));\n-        stack018.out = out;\n-        stack018 test = new stack018();\n-        return test.doRun();\n-    }\n-\n-    private static boolean verbose;\n-    private static PrintStream out;\n-\n-    private void display(Object message) {\n-        if (!verbose)\n-            return;\n-        synchronized (out) {\n-            out.println(message.toString());\n-        }\n-    }\n-\n-    private int doRun() {\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (depthToTry = 0; ; depthToTry += STEP)\n-            try {\n-                invokeRecurse(depthToTry);\n-                maxDepth = depthToTry;\n-            } catch (Throwable exception) {\n-                Throwable target = getTargetException(exception);\n-                if ((target instanceof StackOverflowError) ||\n-                        (target instanceof OutOfMemoryError))\n-                    break; \/\/ OK.\n-                target.printStackTrace(out);\n-                if (target instanceof ThreadDeath)\n-                    throw (ThreadDeath) target;\n-                return 2;\n-            }\n-        out.println(\"Maximal recursion depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Run the tested threads:\n-        \/\/\n-        stack018 threads[] = new stack018[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack018();\n-            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n-            threads[i].depthToTry = RESERVE * maxDepth;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                out.println(\"# \" + threads[i].getName()\n-                        + \": \" + threads[i].thrown);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    private int depthToTry = 0;\n-    private Throwable thrown = null;\n-\n-    public void run() {\n-        String threadName = Thread.currentThread().getName();\n-        for (int i = 1; i <= CYCLES; i++)\n-            try {\n-                display(threadName + \", iteration: \" + i + \"\/\" + CYCLES);\n-                invokeRecurse(depthToTry);\n-                throw new Error(\"TEST_RFE: try deeper invocations!\");\n-\n-            } catch (Throwable exception) {\n-                Throwable target = getTargetException(exception);\n-                if ((target instanceof StackOverflowError) ||\n-                        (target instanceof OutOfMemoryError))\n-                    continue; \/\/ OK.\n-                if (target instanceof ThreadDeath)\n-                    throw (ThreadDeath) target;\n-                thrown = target;\n-                break;\n-            }\n-    }\n-\n-    private static Throwable getTargetException(Throwable exception) {\n-        Throwable target;\n-        \/\/\n-        \/\/ Unwrap deep chain of exceptions to find StackOverflowError:\n-        \/\/\n-        for (\n-                target = exception;\n-                target instanceof InvocationTargetException;\n-                target = ((InvocationTargetException) target).getTargetException()\n-                )\n-            ;\n-        return target;\n-    }\n-\n-    private Method method = null;\n-    private Object params[] = null;\n-\n-    private void invokeRecurse(int depth) throws Exception {\n-        if (method == null) {\n-            \/\/\n-            \/\/ Optimization trick: allocate once, use everywhere.\n-            \/\/\n-            method = stack018.class.getMethod(\"recurse\");\n-            params = new Object[]{};\n-        }\n-        this.depth = depth; \/\/ actual parameter\n-        method.invoke(this, params);\n-    }\n-\n-    private int depth = 0; \/\/ actual parameter for recurse()\n-\n-    public void recurse() throws Exception {\n-        if (depth > 0)\n-            \/\/\n-            \/\/ Self-invoke via reflection:\n-            \/\/\n-            invokeRecurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack018.java","additions":0,"deletions":218,"binary":false,"changes":218,"status":"deleted"},{"patch":"@@ -1,137 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack019.\n- * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     The test invokes infinitely recursive method from within stack\n- *     overflow handler -- repeatedly multiple times in a single thread.\n- *     The test is deemed passed, if VM have not crashed, and if exception\n- *     other than due to stack overflow was not thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n- *     Solaris and Win32 platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *     The stack size is too small to run on systems with > 4K page size.\n- *     Making it bigger could cause timeouts on other platform.\n- *\n- * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n- * @requires os.family != \"windows\"\n- * @library \/vmTestbase\n- * @build nsk.share.Terminator\n- * @run main\/othervm\/timeout=900 -Xss200K nsk.stress.stack.stack019 -eager\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import nsk.share.Terminator;\n-\n-import java.io.PrintStream;\n-\n-public class stack019 {\n-    private final static int CYCLES = 50;\n-    private final static int PROBES = 50;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        boolean verbose = false, eager = false;\n-        for (int i = 0; i < args.length; i++)\n-            if (args[i].toLowerCase().equals(\"-verbose\"))\n-                verbose = true;\n-            else if (args[i].toLowerCase().equals(\"-eager\"))\n-                eager = true;\n-        if (!eager)\n-            Terminator.appoint(Terminator.parseAppointment(args));\n-        \/\/\n-        \/\/ Measure recursive depth before stack overflow:\n-        \/\/\n-        try {\n-            recurse(0);\n-        } catch (StackOverflowError soe) {\n-        } catch (OutOfMemoryError oome) {\n-        }\n-        out.println(\"Maximal recursion depth: \" + maxDepth);\n-        depthToTry = maxDepth;\n-\n-        \/\/\n-        \/\/ Run the tested threads:\n-        \/\/\n-        for (int i = 0; i < CYCLES; i++) {\n-            try {\n-                out.println(\"Iteration: \" + i + \"\/\" + CYCLES);\n-                trickyRecurse(0);\n-                out.println(\"# TEST_BUG: stack overflow was expected!\");\n-                return 2;\n-\n-            } catch (StackOverflowError error) {\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ It's OK: stack overflow was expected.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                throwable.printStackTrace(out);\n-                return 2;\n-            }\n-        }\n-        return 0;\n-    }\n-\n-    private static int maxDepth;\n-    private static int depthToTry;\n-\n-    private static void recurse(int depth) {\n-        maxDepth = depth;\n-        recurse(depth + 1);\n-    }\n-\n-    private static void trickyRecurse(int depth) {\n-        try {\n-            maxDepth = depth;\n-            trickyRecurse(depth + 1);\n-        } catch (Error error) {\n-            if (!(error instanceof StackOverflowError) &&\n-                    !(error instanceof OutOfMemoryError))\n-                throw error;\n-\n-            \/\/\n-            \/\/ Stack problem caught: provoke it again,\n-            \/\/ if current stack is enough deep:\n-            \/\/\n-            if (depth < depthToTry - PROBES)\n-                throw error;\n-            recurse(depth + 1);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack019.java","additions":0,"deletions":137,"binary":false,"changes":137,"status":"deleted"},{"patch":"@@ -388,1 +388,1 @@\n-java\/awt\/Mouse\/EnterExitEvents\/ResizingFrameTest.java 8005021 macosx-all\n+java\/awt\/Mouse\/EnterExitEvents\/ResizingFrameTest.java 8005021,8332158 macosx-all,linux-x64\n@@ -515,0 +515,4 @@\n+# Wayland related\n+\n+java\/awt\/FullScreen\/FullscreenWindowProps\/FullscreenWindowProps.java 8280991 linux-x64\n+\n@@ -661,1 +665,0 @@\n-com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Default.java 8039280 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -553,2 +553,3 @@\n-    :jdk_core_manual_no_input_security \\\n-    :jdk_core_manual_requires_human_input\n+    :jdk_security_manual_no_input \\\n+    :jdk_core_manual_interactive \\\n+    :jdk_security_manual_interactive\n@@ -560,2 +561,0 @@\n-    java\/nio\/MappedByteBuffer\/PmemTest.java \\\n-    java\/rmi\/registry\/nonLocalRegistry\/NonLocalRegistryTest.java \\\n@@ -567,1 +566,2 @@\n-    jdk\/nio\/zipfs\/TestLocOffsetFromZip64EF.java\n+    jdk\/nio\/zipfs\/TestLocOffsetFromZip64EF.java \\\n+    jdk\/nio\/zipfs\/LargeCompressedEntrySizeTest.java\n@@ -569,1 +569,1 @@\n-jdk_core_manual_no_input_security = \\\n+jdk_security_manual_no_input = \\\n@@ -572,1 +572,2 @@\n-    com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Default.java \\\n+    com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMIncrementByte4.java \\\n+    com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMIncrementDirect4.java \\\n@@ -594,1 +595,1 @@\n-jdk_core_manual_requires_human_input = \\\n+jdk_core_manual_interactive = \\\n@@ -597,1 +598,3 @@\n-    sun\/security\/tools\/keytool\/i18n.java\n+    java\/nio\/MappedByteBuffer\/PmemTest.java \\\n+    java\/rmi\/registry\/nonLocalRegistry\/NonLocalRegistryTest.java \\\n+    java\/rmi\/registry\/nonLocalRegistry\/NonLocalSkeletonTest.java\n@@ -599,0 +602,4 @@\n+jdk_security_manual_interactive = \\\n+    sun\/security\/tools\/keytool\/i18n.java \\\n+    java\/security\/Policy\/Root\/Root.java \\\n+    sun\/security\/krb5\/config\/native\/TestDynamicStore.java\n@@ -605,0 +612,4 @@\n+\n+jdk_core_no_security = \\\n+   :jdk_core \\\n+   -:jdk_security\n\\ No newline at end of file\n","filename":"test\/jdk\/TEST.groups","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    public static int started = 0;\n+    public static volatile int started = 0;\n","filename":"test\/jdk\/com\/sun\/jdi\/JdbLockTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8251496\n- * @summary Tests for methods in Authenticator\n- * @run testng\/othervm AuthenticatorTest\n- *\/\n-\n-import com.sun.net.httpserver.Authenticator;\n-import com.sun.net.httpserver.BasicAuthenticator;\n-import com.sun.net.httpserver.HttpPrincipal;\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-\n-public class AuthenticatorTest {\n-    @Test\n-    public void testFailure() {\n-        var failureResult = new Authenticator.Failure(666);\n-        assertEquals(failureResult.getResponseCode(), 666);\n-    }\n-\n-    @Test\n-    public void testRetry() {\n-        var retryResult = new Authenticator.Retry(333);\n-        assertEquals(retryResult.getResponseCode(), 333);\n-    }\n-\n-    @Test\n-    public void TestSuccess() {\n-        var principal = new HttpPrincipal(\"test\", \"123\");\n-        var successResult = new Authenticator.Success(principal);\n-        assertEquals(successResult.getPrincipal(), principal);\n-        assertEquals(\"test\", principal.getName());\n-        assertEquals(\"123\", principal.getRealm());\n-    }\n-}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/AuthenticatorTest","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8251496\n+ * @summary Tests for methods in Authenticator\n+ * @run junit AuthenticatorTest\n+ *\/\n+\n+import com.sun.net.httpserver.Authenticator;\n+import com.sun.net.httpserver.HttpPrincipal;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\n+public class AuthenticatorTest {\n+    @Test\n+    public void testFailure() {\n+        var failureResult = new Authenticator.Failure(666);\n+        assertEquals(666, failureResult.getResponseCode());\n+    }\n+\n+    @Test\n+    public void testRetry() {\n+        var retryResult = new Authenticator.Retry(333);\n+        assertEquals(333, retryResult.getResponseCode());\n+    }\n+\n+    @Test\n+    public void testSuccess() {\n+        var principal = new HttpPrincipal(\"test\", \"123\");\n+        var successResult = new Authenticator.Success(principal);\n+        assertEquals(principal, successResult.getPrincipal());\n+        assertEquals(\"test\", principal.getUsername());\n+        assertEquals(\"123\", principal.getRealm());\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/AuthenticatorTest.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib \/java\/security\/testlibrary\n@@ -28,1 +29,1 @@\n- * @run main\/manual Default\n+ * @run main\/othervm Default\n@@ -32,0 +33,2 @@\n+import jdk.test.lib.Asserts;\n+\n@@ -33,0 +36,1 @@\n+import java.io.*;\n@@ -35,16 +39,25 @@\n-   public static void main(String args[]) throws Exception {\n-        TextCallbackHandler h = new TextCallbackHandler();\n-        NameCallback nc = new NameCallback(\"Name: \", \"charlie\");\n-        ConfirmationCallback cc = new ConfirmationCallback\n-                        (\"Correct?\",\n-                        ConfirmationCallback.INFORMATION,\n-                        ConfirmationCallback.YES_NO_OPTION,\n-                        ConfirmationCallback.NO);\n-\n-        Callback[] callbacks = { nc, cc };\n-        h.handle(callbacks);\n-\n-        if (cc.getSelectedIndex() == ConfirmationCallback.YES) {\n-            System.out.println(\"yes\");\n-        } else {\n-            System.out.println(\"no\");\n+    public static void main(String args[]) throws Exception {\n+        InputStream in = System.in;\n+        PrintStream err = System.err;\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        final String defaultName = \"charlie\";\n+        final String simulatedInput = \"-1\\n-1\\n\";\n+        HumanInputStream humanInputStream = new HumanInputStream(simulatedInput);\n+\n+        try (PrintStream prints = new PrintStream(baos)) {\n+            System.setIn(humanInputStream);\n+            System.setErr(prints);\n+            NameCallback nameCallback = new NameCallback(\"Name: \", defaultName);\n+            ConfirmationCallback confirmationCallback = new ConfirmationCallback(\n+                    \"Correct?\",\n+                    ConfirmationCallback.INFORMATION,\n+                    ConfirmationCallback.YES_NO_OPTION,\n+                    ConfirmationCallback.NO);\n+            new TextCallbackHandler().handle(new Callback[]{nameCallback, confirmationCallback});\n+\n+            Asserts.assertEquals(nameCallback.getDefaultName(), defaultName);\n+            Asserts.assertEquals(confirmationCallback.getSelectedIndex(), ConfirmationCallback.NO);\n+\n+        } finally {\n+            System.setIn(in);\n+            System.setErr(err);\n@@ -52,1 +65,5 @@\n-   }\n+\n+        \/\/ check that the default name and confirmation were visible in the output\n+        Asserts.assertTrue(baos.toString().contains(String.format(\"Name:  [%s]\", defaultName)));\n+        Asserts.assertTrue(baos.toString().contains(\"1. No [default]\"));\n+    }\n","filename":"test\/jdk\/com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Default.java","additions":36,"deletions":19,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,0 +116,2 @@\n+        robot.delay(500);\n+\n","filename":"test\/jdk\/java\/awt\/Choice\/ChoicePopupLocation\/ChoicePopupLocation.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,12 @@\n-import java.awt.*;\n-import java.awt.event.*;\n+import java.awt.BorderLayout;\n+import java.awt.Choice;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.event.InputEvent;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+import java.awt.event.KeyEvent;\n@@ -69,0 +79,1 @@\n+            robot.delay(500);\n@@ -111,1 +122,1 @@\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n@@ -113,1 +124,1 @@\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n@@ -124,1 +135,1 @@\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n@@ -126,1 +137,1 @@\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n","filename":"test\/jdk\/java\/awt\/Choice\/PopupPosTest\/PopupPosTest.java","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,0 +82,1 @@\n+        robot.delay(500);\n","filename":"test\/jdk\/java\/awt\/Focus\/NonFocusableBlockedOwnerTest\/NonFocusableBlockedOwnerTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import java.awt.BorderLayout;\n+\n@@ -39,1 +39,0 @@\n-import java.awt.Panel;\n@@ -52,2 +51,0 @@\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.concurrent.atomic.AtomicBoolean;\n@@ -63,1 +60,1 @@\n-    static AtomicBoolean focusGained = new AtomicBoolean(false);\n+    static final AtomicBoolean focusGained = new AtomicBoolean(false);\n@@ -124,0 +121,1 @@\n+            robot.keyRelease(KeyEvent.VK_TAB);\n","filename":"test\/jdk\/java\/awt\/Focus\/RowToleranceTransitivityTest.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,1 @@\n+        robot.delay(500);\n","filename":"test\/jdk\/java\/awt\/Focus\/WrongKeyTypedConsumedTest\/WrongKeyTypedConsumedTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    static volatile int lastFrameState = Frame.NORMAL;\n+    static volatile int lastFrameState;\n@@ -80,0 +80,2 @@\n+        lastFrameState = Frame.NORMAL;\n+\n@@ -117,0 +119,1 @@\n+        System.out.println(\"------\");\n@@ -118,0 +121,4 @@\n+        System.out.println(\"------\");\n+        examineStates(new int[] {Frame.NORMAL, Frame.MAXIMIZED_BOTH, Frame.ICONIFIED});\n+        System.out.println(\"------\");\n+        examineStates(new int[] {Frame.NORMAL, Frame.ICONIFIED, Frame.MAXIMIZED_BOTH});\n","filename":"test\/jdk\/java\/awt\/Frame\/MaximizedToIconified\/MaximizedToIconified.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,5 +43,4 @@\n-    private int eventType, eventType1;\n-    private ExtendedRobot robot;\n-    private Object lock1 = new Object();\n-    private Object lock2 = new Object();\n-    private Object lock3 = new Object();\n+    private volatile int eventType;\n+    private final Object lock1 = new Object();\n+    private final Object lock2 = new Object();\n+    private final Object lock3 = new Object();\n@@ -49,1 +48,1 @@\n-    private int delay = 150;\n+    private final int delay = 150;\n@@ -53,1 +52,12 @@\n-        test.doTest();\n+        try {\n+            test.doTest();\n+        } finally {\n+            EventQueue.invokeLater(() -> {\n+                if (test.frame != null) {\n+                    test.frame.dispose();\n+                }\n+                if (test.frame2 != null) {\n+                    test.frame2.dispose();\n+                }\n+            });\n+        }\n@@ -108,1 +118,1 @@\n-                            lock2.notifyAll();\n+                        lock2.notifyAll();\n@@ -149,0 +159,1 @@\n+        ExtendedRobot robot;\n@@ -156,0 +167,3 @@\n+        robot.setAutoDelay(delay);\n+        robot.setAutoWaitForIdle(true);\n+\n@@ -159,4 +173,2 @@\n-        robot.waitForIdle(delay);\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n-        robot.waitForIdle(delay);\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n@@ -179,1 +191,0 @@\n-        eventType1 = -1;\n@@ -184,4 +195,2 @@\n-        robot.waitForIdle(delay);\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n-        robot.waitForIdle(delay);\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n","filename":"test\/jdk\/java\/awt\/Frame\/MiscUndecorated\/ActiveAWTWindowTest.java","additions":27,"deletions":18,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,2 @@\n- * @library \/lib\/client\n- * @build ExtendedRobot\n+ * @library \/lib\/client \/test\/lib\n+ * @build ExtendedRobot jdk.test.lib.Platform\n@@ -36,0 +36,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -41,0 +43,1 @@\n+import java.awt.EventQueue;\n@@ -46,2 +49,0 @@\n-import java.awt.Toolkit;\n-import java.awt.event.*;\n@@ -52,0 +53,1 @@\n+import java.awt.event.ActionListener;\n@@ -60,1 +62,0 @@\n-    private Container panel1, panel2;\n@@ -65,2 +66,1 @@\n-    private boolean passed = true;\n-    private boolean buttonClicked = false;\n+    private volatile boolean buttonClicked = false;\n@@ -69,1 +69,1 @@\n-    public static void main(String[] args) {\n+    public static void main(String[] args) throws Exception {\n@@ -71,1 +71,0 @@\n-        test.doTest(false);\n@@ -73,8 +72,3 @@\n-            Toolkit.getDefaultToolkit().getSystemEventQueue().invokeAndWait(new Runnable() {\n-                public void run() {\n-                    test.frame.dispose();\n-                }\n-            });\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-            throw new RuntimeException(\"Unexpected Exception occured\");\n+            test.doTest(false);\n+        } finally {\n+            EventQueue.invokeAndWait(test::dispose);\n@@ -82,1 +76,0 @@\n-        test.doTest(true);\n@@ -84,8 +77,3 @@\n-            Toolkit.getDefaultToolkit().getSystemEventQueue().invokeAndWait(new Runnable() {\n-                public void run() {\n-                    test.frame.dispose();\n-                }\n-            });\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-            throw new RuntimeException(\"Unexpected Exception occured\");\n+            test.doTest(true);\n+        } finally {\n+            EventQueue.invokeAndWait(test::dispose);\n@@ -104,2 +92,2 @@\n-        panel1 = swingControl ? new JPanel() : new Panel();\n-        panel2 = swingControl ? new JPanel() : new Panel();\n+        Container panel1 = swingControl ? new JPanel() : new Panel();\n+        Container panel2 = swingControl ? new JPanel() : new Panel();\n@@ -115,0 +103,7 @@\n+\n+    private void dispose() {\n+        if (frame != null) {\n+            frame.dispose();\n+        }\n+    }\n+\n@@ -116,0 +111,12 @@\n+        ActionListener actionListener = e -> {\n+            buttonClicked = true;\n+            System.out.println(\"Clicked!!\");\n+            synchronized (buttonLock) {\n+                try {\n+                    buttonLock.notifyAll();\n+                } catch (Exception ex) {\n+                    ex.printStackTrace();\n+                }\n+            }\n+        };\n+\n@@ -118,12 +125,1 @@\n-            jbtn.addActionListener(new ActionListener() {\n-                public void actionPerformed(ActionEvent e) {\n-                    buttonClicked = true;\n-                    synchronized (buttonLock) {\n-                        try {\n-                            buttonLock.notifyAll();\n-                        } catch (Exception ex) {\n-                            ex.printStackTrace();\n-                        }\n-                    }\n-                }\n-            });\n+            jbtn.addActionListener(actionListener);\n@@ -133,12 +129,1 @@\n-            btn.addActionListener(new ActionListener() {\n-                public void actionPerformed(ActionEvent e) {\n-                    buttonClicked = true;\n-                    synchronized (buttonLock) {\n-                        try {\n-                            buttonLock.notifyAll();\n-                        } catch (Exception ex) {\n-                            ex.printStackTrace();\n-                        }\n-                    }\n-                }\n-            });\n+            btn.addActionListener(actionListener);\n@@ -149,18 +134,7 @@\n-    public void doTest(boolean swingControl) {\n-        try {\n-            Toolkit.getDefaultToolkit().getSystemEventQueue().invokeAndWait(new Runnable() {\n-                public void run() {\n-                    initializeGUI(swingControl);\n-                }\n-            });\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-            throw new RuntimeException(\"Interrupted or unexpected Exception occured\");\n-        }\n-        try {\n-            robot = new ExtendedRobot();\n-            robot.waitForIdle(1000);\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-            throw new RuntimeException(\"Cannot create robot\");\n-        }\n+    public void doTest(boolean swingControl) throws Exception {\n+\n+        robot = new ExtendedRobot();\n+        robot.setAutoDelay(50);\n+\n+        EventQueue.invokeAndWait(() -> initializeGUI(swingControl));\n+        robot.waitForIdle(1000);\n@@ -183,1 +157,0 @@\n-            passed = false;\n@@ -189,1 +162,1 @@\n-        robot.waitForIdle(delay * 5); \/\/ Need to wait until look of the button\n+        robot.waitForIdle(1000); \/\/ Need to wait until look of the button\n@@ -191,5 +164,3 @@\n-        passed = paintAndRepaint(button, (swingControl? \"J\": \"\")+\"Button\");\n-        if( !paintAndRepaint(button, (swingControl? \"J\": \"\")+\"TextField\") ) {\n-            passed = false;\n-        }\n-        if(!passed) {\n+\n+        if (!paintAndRepaint(button, (swingControl ? \"J\" : \"\") + \"Button\")\n+            || !paintAndRepaint(textField, (swingControl ? \"J\" : \"\") + \"TextField\")) {\n@@ -199,1 +170,2 @@\n-    private boolean paintAndRepaint(Component comp, String prefix) {\n+    private boolean paintAndRepaint(Component comp, String prefix) throws Exception {\n+        boolean passed = true;\n@@ -203,1 +175,1 @@\n-        System.out.println(\"paintAndRepaint \"+prefix);\n+        System.out.printf(\"paintAndRepaint %s %s\\n\", prefix, comp);\n@@ -208,10 +180,20 @@\n-\n-        try {\n-            Toolkit.getDefaultToolkit().getSystemEventQueue().invokeAndWait(new Runnable() {\n-                public void run() {\n-                    frame.setExtendedState(Frame.ICONIFIED);\n-                }\n-            });\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-            throw new RuntimeException(\"Exception while setting extended state ICONIFIED\");\n+        BufferedImage frameImage = robot.createScreenCapture(frame.getBounds());\n+\n+        EventQueue.invokeAndWait(() -> frame.setExtendedState(Frame.ICONIFIED));\n+        robot.waitForIdle(1500);\n+        EventQueue.invokeAndWait(() -> frame.setExtendedState(Frame.NORMAL));\n+        robot.waitForIdle(1500);\n+\n+        if (Platform.isOnWayland()) {\n+            \/\/ Robot.mouseMove does not move the actual mouse cursor on the\n+            \/\/ screen in X11 compatibility mode on Wayland, but only within\n+            \/\/ the XWayland server.\n+            \/\/ This can cause the test to fail if the actual mouse cursor on\n+            \/\/ the screen is somewhere over the test window, so that when the\n+            \/\/ test window is restored from the iconified state, it's detected\n+            \/\/ that the mouse cursor has moved to the mouse cursor position on\n+            \/\/ the screen, and is no longer hovering over the button, so the\n+            \/\/ button is painted differently.\n+            robot.mouseMove(button.getLocationOnScreen().x + button.getSize().width \/ 2,\n+                    button.getLocationOnScreen().y + button.getSize().height \/ 2);\n+            robot.waitForIdle();\n@@ -219,12 +201,0 @@\n-        robot.waitForIdle(delay * 5);\n-        try {\n-            Toolkit.getDefaultToolkit().getSystemEventQueue().invokeAndWait(new Runnable() {\n-                public void run() {\n-                    frame.setExtendedState(Frame.NORMAL);\n-                }\n-            });\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-            throw new RuntimeException(\"Exception while setting extended state NORMAL\");\n-        }\n-        robot.waitForIdle(delay * 5);\n@@ -241,0 +211,1 @@\n+        BufferedImage frameImage2 = robot.createScreenCapture(frame.getBounds());\n@@ -242,1 +213,1 @@\n-        if (! compareImages(capturedImage, capturedImage2)) {\n+        if (!compareImages(capturedImage, capturedImage2)) {\n@@ -244,0 +215,1 @@\n+\n@@ -245,4 +217,8 @@\n-                javax.imageio.ImageIO.write(capturedImage, \"jpg\", new File(\n-                                   prefix+\"BeforeMinimize.jpg\"));\n-                javax.imageio.ImageIO.write(capturedImage2, \"jpg\", new File(\n-                                   prefix+\"AfterMinimize.jpg\"));\n+                javax.imageio.ImageIO.write(capturedImage, \"png\",\n+                        new File(prefix + \"BeforeMinimize.png\"));\n+                javax.imageio.ImageIO.write(capturedImage2, \"png\",\n+                        new File(prefix + \"AfterMinimize.png\"));\n+                javax.imageio.ImageIO.write(frameImage, \"png\",\n+                        new File(\"Frame\" + prefix + \"BeforeMinimize.png\"));\n+                javax.imageio.ImageIO.write(frameImage2, \"png\",\n+                        new File(\"Frame\" + prefix + \"AfterMinimize.png\"));\n","filename":"test\/jdk\/java\/awt\/Frame\/MiscUndecorated\/RepaintTest.java","additions":83,"deletions":107,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,3 +36,9 @@\n-import java.awt.*;\n-import javax.swing.*;\n-import java.awt.event.*;\n+import javax.swing.JFrame;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.JTextField;\n+import javax.swing.SwingUtilities;\n+import java.awt.Robot;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.MouseEvent;\n@@ -41,14 +47,10 @@\n-    Robot robot;\n-    JFrame frame = new JFrame(\"Test Frame\");\n-    JTextField text = new JTextField();\n-    JMenuBar bar = new JMenuBar();\n-    JMenu menu = new JMenu(\"Menu\");\n-    JMenuItem item = new JMenuItem(\"item\");\n-\n-    public static void main(String[] args) {\n-        ConsumeNextMnemonicKeyTypedTest app = new ConsumeNextMnemonicKeyTypedTest();\n-        app.init();\n-        app.start();\n-    }\n-\n-    public void init() {\n+    static Robot robot;\n+    static JFrame frame;\n+    static JTextField text;\n+    static JMenuBar bar;\n+    static JMenu menu;\n+    static JMenuItem item;\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+        robot.setAutoDelay(50);\n@@ -56,4 +58,12 @@\n-            robot = new Robot();\n-            robot.setAutoDelay(50);\n-        } catch (AWTException e) {\n-            throw new RuntimeException(\"Error: unable to create robot\", e);\n+            SwingUtilities.invokeAndWait(ConsumeNextMnemonicKeyTypedTest::init);\n+\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            test();\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n@@ -63,1 +73,7 @@\n-    public void start() {\n+    public static void init() {\n+        frame = new JFrame(\"Test Frame\");\n+        text = new JTextField();\n+        bar = new JMenuBar();\n+        menu = new JMenu(\"Menu\");\n+        item = new JMenuItem(\"item\");\n+\n@@ -75,2 +91,0 @@\n-\n-        test();\n@@ -79,1 +93,1 @@\n-    void test() {\n+    static void test() {\n@@ -86,1 +100,1 @@\n-            robot.mousePress(MouseEvent.BUTTON1_MASK);\n+            robot.mousePress(MouseEvent.BUTTON1_DOWN_MASK);\n@@ -88,1 +102,1 @@\n-            robot.mouseRelease(MouseEvent.BUTTON1_MASK);\n+            robot.mouseRelease(MouseEvent.BUTTON1_DOWN_MASK);\n@@ -149,1 +163,1 @@\n-        System.err.println(\"Test: chracter typed with VK_A: \" + text.getText());\n+        System.err.println(\"Test: character typed with VK_A: \" + text.getText());\n","filename":"test\/jdk\/java\/awt\/KeyboardFocusmanager\/ConsumeNextMnemonicKeyTypedTest\/ConsumeNextMnemonicKeyTypedTest.java","additions":43,"deletions":29,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.awt.AWTException;\n+import java.awt.EventQueue;\n@@ -38,1 +38,0 @@\n-import java.awt.event.ActionListener;\n@@ -40,0 +39,2 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n@@ -41,3 +42,0 @@\n-public class ActionEventTest extends Frame {\n-    List list;\n-    Robot robot;\n@@ -45,8 +43,5 @@\n-    public ActionEventTest() {\n-        try {\n-            robot = new Robot();\n-            robot.setAutoDelay(100);\n-            robot.setAutoWaitForIdle(true);\n-        } catch(AWTException e) {\n-            throw new RuntimeException(e.getMessage());\n-        }\n+public class ActionEventTest {\n+\n+    static List list;\n+    static Frame frame;\n+    static Robot robot;\n@@ -54,0 +49,4 @@\n+    static final CountDownLatch countDownLatch = new CountDownLatch(1);\n+    static volatile boolean failed;\n+\n+    static void initAndShowGui() {\n@@ -56,7 +55,0 @@\n-        add(list);\n-        setSize(400,400);\n-        setLayout(new FlowLayout());\n-        setLocationRelativeTo(null);\n-        pack();\n-        setVisible(true);\n-    }\n@@ -64,17 +56,7 @@\n-    void performTest() {\n-        list.addActionListener(new ActionListener() {\n-            @Override\n-            public void actionPerformed(ActionEvent ae) {\n-                int md = ae.getModifiers();\n-                int expectedMask = ActionEvent.ALT_MASK | ActionEvent.CTRL_MASK\n-                        | ActionEvent.SHIFT_MASK;\n-\n-                if ((md & expectedMask) != expectedMask) {\n-\n-                    robot.keyRelease(KeyEvent.VK_CONTROL);\n-                    robot.keyRelease(KeyEvent.VK_SHIFT);\n-                    robot.keyRelease(KeyEvent.VK_ALT);\n-                    dispose();\n-                    throw new RuntimeException(\"Action Event modifiers are not\"\n-                        + \" set correctly.\");\n-                }\n+        list.addActionListener(ae -> {\n+            int md = ae.getModifiers();\n+            int expectedMask = ActionEvent.ALT_MASK | ActionEvent.CTRL_MASK\n+                    | ActionEvent.SHIFT_MASK;\n+\n+            if ((md & expectedMask) != expectedMask) {\n+                failed = true;\n@@ -82,0 +64,1 @@\n+            countDownLatch.countDown();\n@@ -84,0 +67,7 @@\n+        frame = new Frame(\"ActionEventTest\");\n+        frame.add(list);\n+        frame.setSize(400, 400);\n+        frame.setLayout(new FlowLayout());\n+        frame.setLocationRelativeTo(null);\n+        frame.pack();\n+        frame.setVisible(true);\n@@ -85,0 +75,6 @@\n+    }\n+\n+    static void performTest() {\n+        robot.waitForIdle();\n+        robot.delay(500);\n+\n@@ -96,4 +92,24 @@\n-    public static void main(String args[]) {\n-       ActionEventTest test = new ActionEventTest();\n-       test.performTest();\n-       test.dispose();\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+        robot.setAutoDelay(100);\n+        robot.setAutoWaitForIdle(true);\n+\n+        try {\n+            EventQueue.invokeAndWait(ActionEventTest::initAndShowGui);\n+            performTest();\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+\n+        if (!countDownLatch.await(10, TimeUnit.SECONDS)) {\n+            throw new RuntimeException(\"Action Listener is not triggered\");\n+        }\n+\n+        if (failed) {\n+            throw new RuntimeException(\"Action Event modifiers are not\"\n+                    + \" set correctly.\");\n+        }\n","filename":"test\/jdk\/java\/awt\/List\/ActionEventTest\/ActionEventTest.java","additions":57,"deletions":41,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,3 +35,15 @@\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.lang.reflect.*;\n+import java.awt.BorderLayout;\n+import java.awt.EventQueue;\n+import java.awt.KeyboardFocusManager;\n+import java.awt.Frame;\n+import java.awt.List;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.KeyListener;\n@@ -41,2 +53,1 @@\n-public class KeyEventsTest extends Frame implements ItemListener, FocusListener, KeyListener\n-{\n+public class KeyEventsTest {\n@@ -47,2 +58,2 @@\n-    List single = new List(3, false);\n-    List multiple = new List(3, true);\n+    List single;\n+    List multiple;\n@@ -50,2 +61,1 @@\n-    Panel p1 = new Panel ();\n-    Panel p2 = new Panel ();\n+    KeyFrame keyFrame;\n@@ -53,1 +63,4 @@\n-    public static void main(final String[] args) {\n+    static Robot r;\n+\n+    public static void main(final String[] args) throws Exception {\n+        r = new Robot();\n@@ -55,2 +68,40 @@\n-        app.init();\n-        app.start();\n+        try {\n+            EventQueue.invokeAndWait(app::initAndShowGui);\n+            r.waitForIdle();\n+            r.delay(500);\n+            app.doTest();\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (app.keyFrame != null) {\n+                    app.keyFrame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    class KeyFrame extends Frame implements ItemListener, FocusListener, KeyListener {\n+        public void itemStateChanged(ItemEvent ie) {\n+            System.out.println(\"itemStateChanged-\" + ie);\n+            currentState.setAction(true);\n+        }\n+\n+        public void focusGained(FocusEvent e) {\n+            synchronized (LOCK) {\n+                LOCK.notifyAll();\n+            }\n+        }\n+\n+        public void focusLost(FocusEvent e) {\n+        }\n+\n+        public void keyPressed(KeyEvent e) {\n+            System.out.println(\"keyPressed-\" + e);\n+        }\n+\n+        public void keyReleased(KeyEvent e) {\n+            System.out.println(\"keyReleased-\" + e);\n+        }\n+\n+        public void keyTyped(KeyEvent e) {\n+            System.out.println(\"keyTyped-\" + e);\n+        }\n@@ -59,3 +110,6 @@\n-    public void init()\n-    {\n-        setLayout (new BorderLayout ());\n+    public void initAndShowGui() {\n+        keyFrame = new KeyFrame();\n+        keyFrame.setLayout(new BorderLayout ());\n+\n+        single = new List(3, false);\n+        multiple = new List(3, true);\n@@ -83,3 +137,4 @@\n-        single.addKeyListener(this);\n-        single.addItemListener(this);\n-        single.addFocusListener(this);\n+        single.addKeyListener(keyFrame);\n+        single.addItemListener(keyFrame);\n+        single.addFocusListener(keyFrame);\n+        Panel p1 = new Panel();\n@@ -87,1 +142,1 @@\n-        add(\"North\", p1);\n+        keyFrame.add(\"North\", p1);\n@@ -89,3 +144,4 @@\n-        multiple.addKeyListener(this);\n-        multiple.addItemListener(this);\n-        multiple.addFocusListener(this);\n+        multiple.addKeyListener(keyFrame);\n+        multiple.addItemListener(keyFrame);\n+        multiple.addFocusListener(keyFrame);\n+        Panel p2 = new Panel();\n@@ -93,20 +149,1 @@\n-        add(\"South\", p2);\n-\n-    }\/\/End  init()\n-\n-    public void start ()\n-    {\n-\n-        try{\n-            setSize (200,200);\n-            validate();\n-            setUndecorated(true);\n-            setLocationRelativeTo(null);\n-            setVisible(true);\n-\n-            doTest();\n-            System.out.println(\"Test passed.\");\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-            throw new RuntimeException(\"The test failed.\");\n-        }\n+        keyFrame.add(\"South\", p2);\n@@ -114,5 +151,5 @@\n-    }\/\/ start()\n-\n-    public void itemStateChanged (ItemEvent ie) {\n-        System.out.println(\"itemStateChanged-\"+ie);\n-        this.currentState.setAction(true);\n+        keyFrame.setSize(200, 200);\n+        keyFrame.validate();\n+        keyFrame.setUndecorated(true);\n+        keyFrame.setLocationRelativeTo(null);\n+        keyFrame.setVisible(true);\n@@ -121,2 +158,1 @@\n-    public void focusGained(FocusEvent e){\n-\n+    private void test(TestState currentState) throws Exception {\n@@ -124,25 +160,0 @@\n-            LOCK.notifyAll();\n-        }\n-\n-    }\n-\n-    public void focusLost(FocusEvent e){\n-    }\n-\n-    public void keyPressed(KeyEvent e){\n-        System.out.println(\"keyPressed-\"+e);\n-    }\n-\n-    public void keyReleased(KeyEvent e){\n-        System.out.println(\"keyReleased-\"+e);\n-    }\n-\n-    public void keyTyped(KeyEvent e){\n-        System.out.println(\"keyTyped-\"+e);\n-    }\n-\n-    private void test(TestState currentState)\n-      throws InterruptedException, InvocationTargetException {\n-\n-        synchronized (LOCK) {\n-\n@@ -153,1 +164,1 @@\n-            if (currentState.getMultiple()){\n+            if (currentState.getMultiple()) {\n@@ -155,1 +166,1 @@\n-            }else{\n+            } else {\n@@ -159,7 +170,0 @@\n-            Robot r;\n-            try {\n-                r = new Robot();\n-            } catch(AWTException e) {\n-                throw new RuntimeException(e.getMessage());\n-            }\n-\n@@ -167,1 +171,1 @@\n-            Point loc = this.getLocationOnScreen();\n+            Point loc = keyFrame.getLocationOnScreen();\n@@ -169,2 +173,2 @@\n-            r.mouseMove(loc.x+10, loc.y+10);\n-            r.mousePress(InputEvent.BUTTON1_MASK);\n+            r.mouseMove(loc.x + 10, loc.y + 10);\n+            r.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n@@ -172,1 +176,1 @@\n-            r.mouseRelease(InputEvent.BUTTON1_MASK);\n+            r.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n@@ -177,0 +181,2 @@\n+            r.waitForIdle();\n+\n@@ -181,34 +187,21 @@\n-            list.deselect(0);\n-            list.deselect(1);\n-            list.deselect(2);\n-            list.deselect(3);\n-            list.deselect(4);\n-            list.deselect(5);\n-            list.deselect(6);\n-            list.deselect(7);\n-            list.deselect(8);\n-\n-            int selectIndex = 0;\n-            int visibleIndex = 0;\n-\n-            if (currentState.getScrollMoved()){\n-\n-                if (currentState.getKeyID() == KeyEvent.VK_PAGE_UP ||\n-                    currentState.getKeyID() == KeyEvent.VK_HOME){\n-                    selectIndex = 8;\n-                    visibleIndex = 8;\n-                }else if (currentState.getKeyID() == KeyEvent.VK_PAGE_DOWN ||\n-                    currentState.getKeyID() == KeyEvent.VK_END){\n-                    selectIndex = 0;\n-                    visibleIndex = 0;\n-                }\n-\n-            }else{\n-\n-                if (currentState.getKeyID() == KeyEvent.VK_PAGE_UP ||\n-                    currentState.getKeyID() == KeyEvent.VK_HOME){\n-\n-                    if (currentState.getSelectedMoved()){\n-                        selectIndex = 1;\n-                        visibleIndex = 0;\n-                    }else{\n+            EventQueue.invokeAndWait(() -> {\n+                list.deselect(0);\n+                list.deselect(1);\n+                list.deselect(2);\n+                list.deselect(3);\n+                list.deselect(4);\n+                list.deselect(5);\n+                list.deselect(6);\n+                list.deselect(7);\n+                list.deselect(8);\n+\n+                int selectIndex = 0;\n+                int visibleIndex = 0;\n+\n+                if (currentState.getScrollMoved()) {\n+                    if (currentState.getKeyID() == KeyEvent.VK_PAGE_UP ||\n+                            currentState.getKeyID() == KeyEvent.VK_HOME) {\n+                        selectIndex = 8;\n+                        visibleIndex = 8;\n+                    } else if (currentState.getKeyID() == KeyEvent.VK_PAGE_DOWN ||\n+                            currentState.getKeyID() == KeyEvent.VK_END) {\n@@ -218,9 +211,16 @@\n-\n-                }else if (currentState.getKeyID() == KeyEvent.VK_PAGE_DOWN ||\n-                    currentState.getKeyID() == KeyEvent.VK_END){\n-\n-                    if (currentState.getSelectedMoved()){\n-                        selectIndex = 7;\n-                        visibleIndex = 8;\n-                    }else{\n-                        selectIndex = 8;\n+                } else {\n+                    if (currentState.getKeyID() == KeyEvent.VK_PAGE_UP ||\n+                            currentState.getKeyID() == KeyEvent.VK_HOME) {\n+                        if (currentState.getSelectedMoved()) {\n+                            selectIndex = 1;\n+                        } else {\n+                            selectIndex = 0;\n+                        }\n+                        visibleIndex = 0;\n+                    } else if (currentState.getKeyID() == KeyEvent.VK_PAGE_DOWN ||\n+                            currentState.getKeyID() == KeyEvent.VK_END) {\n+                        if (currentState.getSelectedMoved()) {\n+                            selectIndex = 7;\n+                        } else {\n+                            selectIndex = 8;\n+                        }\n@@ -229,1 +229,0 @@\n-\n@@ -231,5 +230,3 @@\n-\n-            }\n-\n-            list.select(selectIndex);\n-            list.makeVisible(visibleIndex);\n+                list.select(selectIndex);\n+                list.makeVisible(visibleIndex);\n+            });\n@@ -238,0 +235,1 @@\n+            r.waitForIdle();\n@@ -262,1 +260,0 @@\n-\n@@ -265,2 +262,1 @@\n-    private void doTest()\n-      throws InterruptedException, InvocationTargetException {\n+    private void doTest() throws Exception {\n@@ -313,1 +309,1 @@\n-class TestState{\n+class TestState {\n@@ -315,1 +311,1 @@\n-    private boolean multiple;\n+    private final boolean multiple;\n","filename":"test\/jdk\/java\/awt\/List\/KeyEventsTest\/KeyEventsTest.java","additions":138,"deletions":142,"binary":false,"changes":280,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n@@ -54,0 +56,1 @@\n+            latch.countDown();\n@@ -64,1 +67,2 @@\n-    static boolean pressed = false;\n+    static volatile boolean pressed = false;\n+    static final CountDownLatch latch = new CountDownLatch(1);\n@@ -86,0 +90,1 @@\n+            r.setAutoDelay(20);\n@@ -88,1 +93,0 @@\n-            r.delay(10);\n@@ -92,1 +96,0 @@\n-            r.delay(10);\n@@ -96,1 +99,0 @@\n-            r.delay(10);\n@@ -100,1 +102,0 @@\n-            r.delay(10);\n@@ -104,1 +105,0 @@\n-            r.delay(10);\n@@ -106,1 +106,1 @@\n-            r.delay(10000);\n+            latch.await(5, TimeUnit.SECONDS);\n","filename":"test\/jdk\/java\/awt\/MenuBar\/SeparatorsNavigation\/SeparatorsNavigation.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,4 @@\n-    public static void main(final String[] args) {\n+    static ListRepaint listRepaint;\n+    static Frame frame;\n+\n+    public static void main(final String[] args) throws Exception {\n@@ -39,14 +42,12 @@\n-            final Frame frame = new Frame();\n-            frame.setSize(300, 300);\n-            frame.setLocationRelativeTo(null);\n-            ListRepaint list = new ListRepaint();\n-            list.add(\"1\");\n-            list.add(\"2\");\n-            list.add(\"3\");\n-            list.add(\"4\");\n-            list.select(0);\n-            frame.add(list);\n-            frame.setVisible(true);\n-            sleep();\n-            list.test();\n-            frame.dispose();\n+            try {\n+                EventQueue.invokeLater(ListRepaint::createAndShowGUI);\n+                sleep();\n+                EventQueue.invokeAndWait(listRepaint::test);\n+            } finally {\n+                EventQueue.invokeAndWait(() -> {\n+                    if (frame != null) {\n+                        frame.dispose();\n+                        frame = null;\n+                    }\n+                });\n+            }\n@@ -63,0 +64,16 @@\n+    static void createAndShowGUI() {\n+        frame = new Frame();\n+        frame.setSize(300, 300);\n+        frame.setLocationRelativeTo(null);\n+\n+        listRepaint = new ListRepaint();\n+        listRepaint.add(\"1\");\n+        listRepaint.add(\"2\");\n+        listRepaint.add(\"3\");\n+        listRepaint.add(\"4\");\n+        listRepaint.select(0);\n+\n+        frame.add(listRepaint);\n+        frame.setVisible(true);\n+    }\n+\n","filename":"test\/jdk\/java\/awt\/Paint\/ListRepaint.java","additions":33,"deletions":16,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-        if (os.contains(\"os x\"))\n+        if (os.contains(\"os x\") || os.contains(\"linux\"))\n","filename":"test\/jdk\/java\/awt\/Robot\/ModifierRobotKey\/ModifierRobotKeyTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,0 +101,1 @@\n+        robot.delay(500);\n","filename":"test\/jdk\/java\/awt\/TextArea\/TextAreaCaretVisibilityTest\/bug7129742.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,14 +31,0 @@\n-        GNOMESID=`pgrep gnome-session | head -n1`\n-\n-        printf \"\\n\/* gnome-session environ\\n\"\n-        cat \"\/proc\/$GNOMESID\/environ\" | tr '\\0' '\\n'\n-        printf \"\\n*\/\\n\\n\"\n-\n-        DBUS_SESSION_BUS_ADDRESS=`grep -z DBUS_SESSION_BUS_ADDRESS \/proc\/$GNOMESID\/environ | cut -d= -f2-`\n-        export DBUS_SESSION_BUS_ADDRESS\n-\n-        DISPLAY=`grep -z DISPLAY \/proc\/$GNOMESID\/environ | cut -d= -f2-`\n-        export DISPLAY\n-\n-        XDG_CURRENT_DESKTOP=`grep -z XDG_CURRENT_DESKTOP \/proc\/$GNOMESID\/environ | cut -d= -f2-`\n-        export XDG_CURRENT_DESKTOP\n","filename":"test\/jdk\/java\/awt\/Toolkit\/DesktopProperties\/rfe4758438.sh","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+        robot.setAutoDelay(25);\n@@ -83,0 +84,2 @@\n+        robot.waitForIdle();\n+        robot.delay(500);\n@@ -120,4 +123,0 @@\n-        robot.keyPress(KeyEvent.VK_ALT);\n-        robot.keyPress(KeyEvent.VK_SHIFT);\n-        robot.keyPress(KeyEvent.VK_CONTROL);\n-\n@@ -132,0 +131,4 @@\n+        robot.keyPress(KeyEvent.VK_ALT);\n+        robot.keyPress(KeyEvent.VK_SHIFT);\n+        robot.keyPress(KeyEvent.VK_CONTROL);\n+\n","filename":"test\/jdk\/java\/awt\/TrayIcon\/ActionEventTest\/ActionEventTest.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    static final int ATTEMPTS = 50;\n+    static final int ATTEMPTS = 10;\n","filename":"test\/jdk\/java\/awt\/TrayIcon\/TrayIconPopup\/TrayIconPopupTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+        r.delay(500);\n","filename":"test\/jdk\/java\/awt\/Window\/SetWindowLocationByPlatformTest\/SetWindowLocationByPlatformTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,12 +24,0 @@\n-\/**\n- * @test\n- * @bug 4956397\n- * @key printer\n- * @run main\/manual PageDlgPrnButton\n- *\/\n-\n-import java.awt.print.PrinterJob;\n-import java.awt.print.PageFormat;\n-import java.awt.print.Printable;\n-import java.awt.print.PrinterException;\n-\n@@ -39,5 +27,4 @@\n-import java.awt.* ;\n-\n-public class PageDlgPrnButton implements Printable\n-{\n-    public static void main ( String args[] ) {\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n@@ -45,7 +32,1 @@\n-        String[] instructions =\n-           {\"For non-windows OS, this test PASSes.\",\n-            \"You must have at least 2 printers available to perform this test.\",\n-            \"This test brings up a native Windows page dialog.\",\n-            \"Click on the Printer... button and change the selected printer. \",\n-            \"Test passes if the printout comes from the new selected printer.\",\n-         };\n+import jtreg.SkippedException;\n@@ -53,2 +34,23 @@\n-         Sysout.createDialog( );\n-         Sysout.printInstructions( instructions );\n+\/*\n+ * @test\n+ * @bug 4956397\n+ * @key printer\n+ * @requires os.family==\"windows\"\n+ * @library \/test\/lib \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame jtreg.SkippedException\n+ * @run main\/manual PageDlgPrnButton\n+ *\/\n+public class PageDlgPrnButton implements Printable {\n+    private static final String INSTRUCTIONS =\n+            \"This test brings up a native Windows page dialog.\\n\" +\n+            \"Click on the Printer... button and change the selected printer. \\n\" +\n+            \"Test passes if the printout comes from the new selected printer.\";\n+\n+    public static void main(String[] args) throws Exception {\n+        final int serviceCount = PrinterJob.lookupPrintServices().length;\n+        if (serviceCount == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+        if (serviceCount < 2) {\n+            throw new SkippedException(\"The test requires at least 2 printers.\");\n+        }\n@@ -56,2 +58,5 @@\n-        PageDlgPrnButton pdpb = new PageDlgPrnButton() ;\n-    }\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build();\n@@ -59,8 +64,2 @@\n-    public PageDlgPrnButton()\n-    {\n-        try\n-        {\n-            pageDialogExample();\n-        }\n-        catch(Exception e)\n-        {e.printStackTrace(System.err);}\n+        pageDialogExample();\n+        passFailJFrame.awaitAndCheck();\n@@ -69,1 +68,0 @@\n-\n@@ -72,2 +70,1 @@\n-    public void pageDialogExample() throws PrinterException\n-    {\n+    public static void pageDialogExample() throws PrinterException {\n@@ -78,4 +75,4 @@\n-        if(originalPageFormat == pageFormat) return;\n-\n-        job.setPrintable(this,pageFormat);\n-        job.print();\n+        job.setPrintable(new PageDlgPrnButton(), pageFormat);\n+        if (job.printDialog()) {\n+            job.print();\n+        }\n@@ -84,4 +81,2 @@\n-\n-\n-    public int print(Graphics g, PageFormat pageFormat, int pageIndex)\n-    {\n+    @Override\n+    public int print(Graphics g, PageFormat pageFormat, int pageIndex) {\n@@ -90,1 +85,1 @@\n-        final Rectangle rect = new Rectangle(0,0,boxWidth,boxHeight);\n+        final Rectangle rect = new Rectangle(0, 0, boxWidth, boxHeight);\n@@ -93,0 +88,1 @@\n+        final Graphics2D g2d = (Graphics2D) g;\n@@ -94,3 +90,3 @@\n-        if (pageIndex > 0) return (NO_SUCH_PAGE);\n-\n-        final Graphics2D g2d = (Graphics2D)g;\n+        if (pageIndex > 0) {\n+            return NO_SUCH_PAGE;\n+        }\n@@ -102,1 +98,1 @@\n-        g2d.drawRect(0,0,(int)pageW,(int)pageH);\n+        g2d.drawRect(0, 0, (int) pageW, (int) pageH);\n@@ -106,1 +102,1 @@\n-        final double scale = Math.min( (pageW\/boxWidth), (pageH\/boxHeight) );\n+        final double scale = Math.min((pageW \/ boxWidth), (pageH \/ boxHeight));\n@@ -108,1 +104,3 @@\n-        if(scale < 1.0) g2d.scale(scale, scale);\n+        if (scale < 1.0) {\n+            g2d.scale(scale, scale);\n+        }\n@@ -113,1 +111,1 @@\n-        return(PAGE_EXISTS);\n+        return PAGE_EXISTS;\n@@ -116,114 +114,0 @@\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PageDlgPrnButton.java","additions":54,"deletions":170,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,14 @@\n-\/**\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+import javax.swing.BorderFactory;\n+import javax.swing.Box;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JOptionPane;\n+\n+\/*\n@@ -29,0 +42,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,0 +46,22 @@\n+public class PrintCompoundString implements Printable {\n+    private static final String STR = \"Test string compound printing \\u2203\\u2200\\u2211\";\n+\n+    private static final String INSTRUCTIONS =\n+            \"This test should print following text\\n\\n\" +\n+            STR +\"\\n\\n\" +\n+            \"If an exception is thrown, or the page doesn't print properly\\n\" +\n+            \"then the test fails\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .splitUI(PrintCompoundString::createTestUI)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n+    }\n@@ -32,42 +69,15 @@\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.print.*;\n-import java.text.*;\n-\n-public class PrintCompoundString extends Frame implements ActionListener {\n-\n- private TextCanvas c;\n-\n- public static void main(String args[]) {\n-\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test should print a page which contains the same\",\n-         \"text message as in the test window on the screen\",\n-         \"You should also monitor the command line to see if any exceptions\",\n-         \"were thrown\",\n-         \"If an exception is thrown, or the page doesn't print properly\",\n-         \"then the test fails\",\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-    PrintCompoundString f = new PrintCompoundString();\n-    f.show();\n- }\n-\n- public PrintCompoundString() {\n-    super(\"JDK 1.2 drawString Printing\");\n-\n-    c = new TextCanvas();\n-    add(\"Center\", c);\n-\n-    Button printButton = new Button(\"Print\");\n-    printButton.addActionListener(this);\n-    add(\"South\", printButton);\n-\n-    addWindowListener(new WindowAdapter() {\n-       public void windowClosing(WindowEvent e) {\n-             System.exit(0);\n+    private static JComponent createTestUI() {\n+        JButton b = new JButton(\"Print\");\n+        b.addActionListener((ae) -> {\n+            try {\n+                PrinterJob job = PrinterJob.getPrinterJob();\n+                job.setPrintable(new PrintCompoundString());\n+                if (job.printDialog()) {\n+                    job.print();\n+                }\n+            } catch (PrinterException ex) {\n+                ex.printStackTrace();\n+                String msg = \"PrinterException: \" + ex.getMessage();\n+                JOptionPane.showMessageDialog(b, msg, \"Error occurred\",\n+                        JOptionPane.ERROR_MESSAGE);\n+                PassFailJFrame.forceFail(msg);\n@@ -75,41 +85,8 @@\n-    });\n-\n-    pack();\n- }\n-\n- public void actionPerformed(ActionEvent e) {\n-\n-   PrinterJob pj = PrinterJob.getPrinterJob();\n-\n-   if (pj != null && pj.printDialog()) {\n-\n-       pj.setPrintable(c);\n-       try {\n-            pj.print();\n-      } catch (PrinterException pe) {\n-      } finally {\n-         System.err.println(\"PRINT RETURNED\");\n-      }\n-   }\n- }\n-\n- class TextCanvas extends Panel implements Printable {\n-\n-    String nullStr = null;\n-    String emptyStr = new String();\n-    AttributedString nullAttStr = null;\n-    AttributedString emptyAttStr = new AttributedString(emptyStr);\n-    AttributedCharacterIterator nullIterator = null;\n-    AttributedCharacterIterator emptyIterator = emptyAttStr.getIterator();\n-\n-    public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n-\n-      if (pgIndex > 0)\n-         return Printable.NO_SUCH_PAGE;\n-\n-      Graphics2D g2d = (Graphics2D)g;\n-      g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n-\n-      paint(g);\n-\n-      return Printable.PAGE_EXISTS;\n+        });\n+\n+        Box main = Box.createHorizontalBox();\n+        main.setBorder(BorderFactory.createEmptyBorder(8, 8, 8, 8));\n+        main.add(Box.createHorizontalGlue());\n+        main.add(b);\n+        main.add(Box.createHorizontalGlue());\n+        return main;\n@@ -118,5 +95,5 @@\n-    public void paint(Graphics g1) {\n-        Graphics2D g = (Graphics2D)g1;\n-\n-          String str = \"Test string compound printing \\u2203\\u2200\\u2211\";\n-          g.drawString(str, 20, 40);\n+    @Override\n+    public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n+        if (pgIndex > 0) {\n+            return Printable.NO_SUCH_PAGE;\n+        }\n@@ -124,1 +101,3 @@\n-    }\n+        Graphics2D g2d = (Graphics2D) g;\n+        g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n+        g2d.drawString(STR, 20, 40);\n@@ -126,2 +105,1 @@\n-     public Dimension getPreferredSize() {\n-        return new Dimension(450, 250);\n+        return Printable.PAGE_EXISTS;\n@@ -129,2 +107,0 @@\n- }\n-\n@@ -132,115 +108,0 @@\n-\n-class Sysout\n- {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n- }\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrintCompoundString.java","additions":71,"deletions":210,"binary":false,"changes":281,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,18 @@\n-\/**\n- * @test %I %W\n+import java.awt.BorderLayout;\n+import java.awt.Canvas;\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+\/*\n+ * @test\n@@ -29,0 +45,3 @@\n+ * @requires os.family==\"windows\"\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,4 +50,0 @@\n-import java.awt.*;\n-import java.awt.print.*;\n-import java.awt.event.*;\n-\n@@ -36,48 +51,21 @@\n-\n-        private PrintImageCanvas                printImageCanvas;\n-\n-        private MenuItem        print1Menu = new MenuItem(\"PrintTest1\");\n-        private MenuItem        print2Menu = new MenuItem(\"PrintTest2\");\n-        private MenuItem        exitMenu = new MenuItem(\"Exit\");\n-\n-        public static void main(String[] argv) {\n-        String[] instructions =\n-           { \"You must have a printer available to perform this test,\",\n-             \"prefererably Canon LaserShot A309GII.\",\n-             \"Printing must be done in Win 98 Japanese 2nd Edition.\",\n-             \"\",\n-             \"Passing test : Output of text image for PrintTest1 and PrintTest2 should be same as that on the screen.\",\n-           };\n-\n-        Sysout.createDialog( );\n-         Sysout.printInstructions( instructions );\n-\n-                new PrintImage();\n-        }\n-\n-        public PrintImage() {\n-                super(\"PrintImage\");\n-                initPrintImage();\n-        }\n-\n-        public void initPrintImage() {\n-\n-                printImageCanvas = new PrintImageCanvas(this);\n-\n-                initMenu();\n-\n-                addWindowListener(new WindowAdapter() {\n-                        public void windowClosing(WindowEvent ev) {\n-                                dispose();\n-                        }\n-                        public void windowClosed(WindowEvent ev) {\n-                                System.exit(0);\n-                        }\n-                });\n-\n-                setLayout(new BorderLayout());\n-                add(printImageCanvas, BorderLayout.CENTER);\n-                pack();\n-\n-                setSize(500,500);\n-                setVisible(true);\n+    private final PrintImageCanvas printImageCanvas = new PrintImageCanvas();\n+    private final MenuItem print1Menu = new MenuItem(\"PrintTest1\");\n+    private final MenuItem print2Menu = new MenuItem(\"PrintTest2\");\n+    private static final String INSTRUCTIONS =\n+            \"Select PrintTest1 in the File menu.\\n\" +\n+            \"Print Dialog will appear.\\n\" +\n+            \"Click OK to start the first print job.\\n\" +\n+            \"\\n\" +\n+            \"Select PrintTest2 in the File menu.\\n\" +\n+            \"Page Setup Dialog will appear.\\n\" +\n+            \"Click OK.\\n\" +\n+            \"Print Dialog will appear.\\n\" +\n+            \"Click OK to start the second print job.\\n\" +\n+            \"\\n\" +\n+            \"The text in the printouts for PrintTest1 and PrintTest2 should be\\n\" +\n+            \"same as that on the screen.\\n\" +\n+            \"Press Pass if they are, otherwise press Fail.\";\n+\n+    public static void main(String[] argv) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n@@ -86,14 +74,8 @@\n-        private void initMenu() {\n-                MenuBar         mb = new MenuBar();\n-                Menu            me = new Menu(\"File\");\n-                me.add(print1Menu);\n-                me.add(print2Menu);\n-                me.add(\"-\");\n-                me.add(exitMenu);\n-                mb.add(me);\n-                this.setMenuBar(mb);\n-\n-                print1Menu.addActionListener(this);\n-                print2Menu.addActionListener(this);\n-                exitMenu.addActionListener(this);\n-        }\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .testUI(PrintImage::new)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n+    }\n@@ -101,12 +83,4 @@\n-        public void actionPerformed(ActionEvent e) {\n-                Object target = e.getSource();\n-                if( target.equals(print1Menu) ) {\n-                        printMain1();\n-                }\n-                else if( target.equals(print2Menu) ) {\n-                        printMain2();\n-                }\n-                else if( target.equals(exitMenu) ) {\n-                        dispose();\n-                }\n-        }\n+    public PrintImage() {\n+        super(\"PrintImage\");\n+        initPrintImage();\n+    }\n@@ -114,1 +88,6 @@\n-        private void printMain1(){\n+    public void initPrintImage() {\n+        initMenu();\n+        setLayout(new BorderLayout());\n+        add(printImageCanvas, BorderLayout.CENTER);\n+        setSize(500, 300);\n+    }\n@@ -116,2 +95,7 @@\n-                PrinterJob printerJob = PrinterJob.getPrinterJob();\n-                PageFormat pageFormat = printerJob.defaultPage();\n+    private void initMenu() {\n+        MenuBar mb = new MenuBar();\n+        Menu me = new Menu(\"File\");\n+        me.add(print1Menu);\n+        me.add(print2Menu);\n+        mb.add(me);\n+        setMenuBar(mb);\n@@ -119,1 +103,3 @@\n-                printerJob.setPrintable((Printable)printImageCanvas, pageFormat);\n+        print1Menu.addActionListener(this);\n+        print2Menu.addActionListener(this);\n+    }\n@@ -121,9 +107,6 @@\n-                if(printerJob.printDialog()){\n-                        try {\n-                                printerJob.print();\n-                        }\n-                        catch(PrinterException p){\n-                        }\n-                }\n-                else\n-                        printerJob.cancel();\n+    public void actionPerformed(ActionEvent e) {\n+        Object target = e.getSource();\n+        if (target.equals(print1Menu)) {\n+            printMain1();\n+        } else if (target.equals(print2Menu)) {\n+            printMain2();\n@@ -131,0 +114,1 @@\n+    }\n@@ -132,16 +116,15 @@\n-        private void printMain2(){\n-\n-                PrinterJob printerJob = PrinterJob.getPrinterJob();\n-                PageFormat pageFormat = printerJob.pageDialog(printerJob.defaultPage());\n-\n-                printerJob.setPrintable((Printable)printImageCanvas, pageFormat);\n-\n-                if(printerJob.printDialog()){\n-                        try {\n-                                printerJob.print();\n-                        }\n-                        catch(PrinterException p){\n-                        }\n-                }\n-                else\n-                        printerJob.cancel();\n+    private void printMain1() {\n+        PrinterJob printerJob = PrinterJob.getPrinterJob();\n+        PageFormat pageFormat = printerJob.defaultPage();\n+\n+        printerJob.setPrintable(printImageCanvas, pageFormat);\n+\n+        if (printerJob.printDialog()) {\n+            try {\n+                printerJob.print();\n+            } catch (PrinterException e) {\n+                PassFailJFrame.forceFail(\"Print Failed\");\n+                e.printStackTrace();\n+            }\n+        } else {\n+            printerJob.cancel();\n@@ -149,0 +132,1 @@\n+    }\n@@ -150,8 +134,15 @@\n-}\n-\n-class PrintImageCanvas extends Canvas implements Printable {\n-\n-        private PrintImage pdsFrame;\n-\n-        public PrintImageCanvas(PrintImage pds) {\n-                pdsFrame = pds;\n+    private void printMain2() {\n+        PrinterJob printerJob = PrinterJob.getPrinterJob();\n+        PageFormat pageFormat = printerJob.pageDialog(printerJob.defaultPage());\n+\n+        printerJob.setPrintable(printImageCanvas, pageFormat);\n+\n+        if (printerJob.printDialog()) {\n+            try {\n+                printerJob.print();\n+            } catch (PrinterException e) {\n+                PassFailJFrame.forceFail(\"Print Failed\");\n+                e.printStackTrace();\n+            }\n+        } else {\n+            printerJob.cancel();\n@@ -159,0 +150,1 @@\n+    }\n@@ -160,0 +152,2 @@\n+    private static class PrintImageCanvas extends Canvas implements Printable {\n+        @Override\n@@ -161,3 +155,4 @@\n-                Font drawFont = new Font(\"MS Mincho\",Font.ITALIC,50);\n-                g.setFont(drawFont);\n-                g.drawString(\"PrintSample!\",100,150);\n+            Font drawFont = new Font(\"MS Mincho\", Font.ITALIC, 50);\n+            g.setFont(drawFont);\n+            g.setColor(new Color(0, 0, 0, 200));\n+            g.drawString(\"PrintSample!\", 100, 150);\n@@ -166,0 +161,1 @@\n+        @Override\n@@ -168,12 +164,5 @@\n-\n-                if(pi>=1)\n-                        return NO_SUCH_PAGE;\n-                else{\n-                        Graphics2D g2 = (Graphics2D)g;\n-                        g.setColor(new Color(0,0,0,200));\n-\n-                        Font drawFont = new Font(\"MS Mincho\",Font.ITALIC,50);\n-                        g.setFont(drawFont);\n-                        g.drawString(\"PrintSample!\",100,150);\n-                        return PAGE_EXISTS;\n-                }\n+            if (pi > 0) {\n+                return NO_SUCH_PAGE;\n+            }\n+            paint(g);\n+            return PAGE_EXISTS;\n@@ -181,113 +170,0 @@\n-}\n-\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n@@ -295,0 +171,1 @@\n+}\n@@ -296,1 +173,0 @@\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrintImage.java","additions":123,"deletions":247,"binary":false,"changes":370,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,16 @@\n-\/**\n+import java.awt.Button;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import java.text.AttributedCharacterIterator;\n+import java.text.AttributedString;\n+\n+import javax.swing.JOptionPane;\n+\n+\/*\n@@ -29,0 +44,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,209 +48,23 @@\n-\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.print.*;\n-import java.text.*;\n-\n-public class PrintNullString extends Frame implements ActionListener {\n-\n- private TextCanvas c;\n-\n- public static void main(String args[]) {\n-\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test should print a page which contains the same\",\n-         \"text messages as in the test window on the screen\",\n-         \"The messages should contain only 'OK' and 'expected' messages\",\n-         \"There should be no FAILURE messages.\",\n-         \"You should also monitor the command line to see if any exceptions\",\n-         \"were thrown\",\n-         \"If the page fails to print, but there were no exceptions\",\n-         \"then the problem is likely elsewhere (ie your printer)\"\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-    PrintNullString f = new PrintNullString();\n-    f.show();\n- }\n-\n- public PrintNullString() {\n-    super(\"JDK 1.2 drawString Printing\");\n-\n-    c = new TextCanvas();\n-    add(\"Center\", c);\n-\n-    Button printButton = new Button(\"Print\");\n-    printButton.addActionListener(this);\n-    add(\"South\", printButton);\n-\n-    addWindowListener(new WindowAdapter() {\n-       public void windowClosing(WindowEvent e) {\n-             System.exit(0);\n-            }\n-    });\n-\n-    pack();\n- }\n-\n- public void actionPerformed(ActionEvent e) {\n-\n-   PrinterJob pj = PrinterJob.getPrinterJob();\n-\n-   if (pj != null && pj.printDialog()) {\n-\n-       pj.setPrintable(c);\n-       try {\n-            pj.print();\n-      } catch (PrinterException pe) {\n-      } finally {\n-         System.err.println(\"PRINT RETURNED\");\n-      }\n-   }\n- }\n-\n- class TextCanvas extends Panel implements Printable {\n-\n-    String nullStr = null;\n-    String emptyStr = new String();\n-    AttributedString nullAttStr = null;\n-    AttributedString emptyAttStr = new AttributedString(emptyStr);\n-    AttributedCharacterIterator nullIterator = null;\n-    AttributedCharacterIterator emptyIterator = emptyAttStr.getIterator();\n-\n-    public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n-\n-      if (pgIndex > 0)\n-         return Printable.NO_SUCH_PAGE;\n-\n-      Graphics2D g2d = (Graphics2D)g;\n-      g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n-\n-      paint(g);\n-\n-      return Printable.PAGE_EXISTS;\n-    }\n-\n-    public void paint(Graphics g1) {\n-        Graphics2D g = (Graphics2D)g1;\n-\n-        \/\/ API 1: null & empty drawString(String, int, int);\n-        try {\n-             g.drawString(nullStr, 20, 40);\n-             g.drawString(\"FAILURE: No NPE for null String, int\", 20, 40);\n-        } catch (NullPointerException e) {\n-          g.drawString(\"caught expected NPE for null String, int\", 20, 40);\n-        }\/* catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for null String, int\",\n-                        20, 40);\n-        }*\/\n-\n-        \/\/try {\n-             g.drawString(emptyStr, 20, 60);\n-             g.drawString(\"OK for empty String, int\", 20, 60);\n-        \/*} catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for empty String, int\",\n-                        20, 60);\n-        }*\/\n-\n-\n-        \/\/ API 2: null & empty drawString(String, float, float);\n-        try {\n-             g.drawString(nullStr, 20.0f, 80.0f);\n-             g.drawString(\"FAILURE: No NPE for null String, float\", 20, 80);\n-        } catch (NullPointerException e) {\n-          g.drawString(\"caught expected NPE for null String, float\", 20, 80);\n-        } \/*catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for null String, float\",\n-                        20, 80);\n-        }*\/\n-        \/\/try {\n-             g.drawString(emptyStr, 20.0f, 100.0f);\n-             g.drawString(\"OK for empty String, float\", 20.0f, 100.f);\n-        \/* } catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for empty String, float\",\n-                        20, 100);\n-        }*\/\n-\n-        \/\/ API 3: null & empty drawString(Iterator, int, int);\n-        try {\n-             g.drawString(nullIterator, 20, 120);\n-             g.drawString(\"FAILURE: No NPE for null iterator, float\", 20, 120);\n-        } catch (NullPointerException e) {\n-          g.drawString(\"caught expected NPE for null iterator, int\", 20, 120);\n-        } \/*catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for null iterator, int\",\n-                       20, 120);\n-        } *\/\n-        try {\n-             g.drawString(emptyIterator, 20, 140);\n-             g.drawString(\"FAILURE: No IAE for empty iterator, int\",\n-                           20, 140);\n-        } catch (IllegalArgumentException e) {\n-          g.drawString(\"caught expected IAE for empty iterator, int\",\n-                        20, 140);\n-        } \/*catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for empty iterator, int\",\n-                       20, 140);\n-        } *\/\n-\n-\n-        \/\/ API 4: null & empty drawString(Iterator, float, int);\n-        try {\n-             g.drawString(nullIterator, 20.0f, 160.0f);\n-             g.drawString(\"FAILURE: No NPE for null iterator, float\", 20, 160);\n-        } catch (NullPointerException e) {\n-          g.drawString(\"caught expected NPE for null iterator, float\", 20, 160);\n-        } \/*catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for null iterator, float\",\n-                        20, 160);\n-        } *\/\n-\n-        try {\n-             g.drawString(emptyIterator, 20, 180);\n-             g.drawString(\"FAILURE: No IAE for empty iterator, float\",\n-                           20, 180);\n-        } catch (IllegalArgumentException e) {\n-          g.drawString(\"caught expected IAE for empty iterator, float\",\n-                        20, 180);\n-        } \/*catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for empty iterator, float\",\n-                       20, 180);\n-        } *\/\n-    }\n-\n-     public Dimension getPreferredSize() {\n-        return new Dimension(450, 250);\n-    }\n- }\n-\n-}\n-\n-class Sysout\n- {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n+public class PrintNullString extends Frame {\n+    private static final String INSTRUCTIONS =\n+            \"This test should print a page which contains the same\\n\" +\n+            \"text messages as in the test window on the screen.\\n\" +\n+            \"\\n\" +\n+            \"The messages should contain only 'OK' and 'expected' messages.\\n\" +\n+            \"Press Pass if it's the case; otherwise press Fail.\\n\" +\n+            \"\\n\" +\n+            \"If the page fails to print, but there were no exceptions\\n\" +\n+            \"then the problem is likely elsewhere (i.e. your printer)\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .testUI(PrintNullString::new)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n@@ -242,4 +73,24 @@\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n+    public PrintNullString() {\n+        super(\"PrintNullString\");\n+\n+        TextCanvas c = new TextCanvas();\n+        add(\"Center\", c);\n+\n+        Button b = new Button(\"Print\");\n+        add(\"South\", b);\n+        b.addActionListener(e -> {\n+            PrinterJob pj = PrinterJob.getPrinterJob();\n+            if (pj.printDialog()) {\n+                pj.setPrintable(c);\n+                try {\n+                    pj.print();\n+                } catch (PrinterException ex) {\n+                    ex.printStackTrace();\n+                    String msg = \"PrinterException: \" + ex.getMessage();\n+                    JOptionPane.showMessageDialog(b, msg, \"Error occurred\",\n+                            JOptionPane.ERROR_MESSAGE);\n+                    PassFailJFrame.forceFail(msg);\n+                }\n+            }\n+        });\n+        pack();\n@@ -248,28 +99,18 @@\n- }\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n+    private static class TextCanvas extends Panel implements Printable {\n+        private final String nullStr = null;\n+        private final String emptyStr = \"\";\n+        private final AttributedString emptyAttStr = new AttributedString(emptyStr);\n+        private final AttributedCharacterIterator nullIterator = null;\n+        private final AttributedCharacterIterator emptyIterator = emptyAttStr.getIterator();\n+\n+        @Override\n+        public void paint(Graphics g) {\n+            Graphics2D g2d = (Graphics2D) g;\n+            paint(g2d);\n+        }\n+\n+        @Override\n+        public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n+            if (pgIndex > 0) {\n+                return NO_SUCH_PAGE;\n+            }\n@@ -277,2 +118,3 @@\n-      show();\n-    }\/\/ TestDialog()\n+            Graphics2D g2d = (Graphics2D) g;\n+            g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n+            paint(g2d);\n@@ -280,5 +122,2 @@\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n+            return PAGE_EXISTS;\n+        }\n@@ -286,1 +125,8 @@\n-      \/\/Go down array of instruction strings\n+        private void paint(Graphics2D g2d) {\n+            \/\/ API 1: null & empty drawString(String, int, int);\n+            try {\n+                g2d.drawString(nullStr, 20, 40);\n+                g2d.drawString(\"FAILURE: No NPE for null String, int\", 20, 40);\n+            } catch (NullPointerException e) {\n+                g2d.drawString(\"caught expected NPE for null String, int\", 20, 40);\n+            }\n@@ -288,13 +134,2 @@\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n+            g2d.drawString(emptyStr, 20, 60);\n+            g2d.drawString(\"OK for empty String, int\", 20, 60);\n@@ -302,1 +137,7 @@\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n+            \/\/ API 2: null & empty drawString(String, float, float);\n+            try {\n+                g2d.drawString(nullStr, 20.0f, 80.0f);\n+                g2d.drawString(\"FAILURE: No NPE for null String, float\", 20, 80);\n+            } catch (NullPointerException e) {\n+                g2d.drawString(\"caught expected NPE for null String, float\", 20, 80);\n+            }\n@@ -304,9 +145,2 @@\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n+            g2d.drawString(emptyStr, 20.0f, 100.0f);\n+            g2d.drawString(\"OK for empty String, float\", 20.0f, 100.f);\n@@ -314,1 +148,7 @@\n-            instructionsText.append( printStr + \"\\n\" );\n+            \/\/ API 3: null & empty drawString(Iterator, int, int);\n+            try {\n+                g2d.drawString(nullIterator, 20, 120);\n+                g2d.drawString(\"FAILURE: No NPE for null iterator, float\", 20, 120);\n+            } catch (NullPointerException e) {\n+                g2d.drawString(\"caught expected NPE for null iterator, int\", 20, 120);\n+            }\n@@ -316,1 +156,6 @@\n-          }\/\/ while\n+            try {\n+                g2d.drawString(emptyIterator, 20, 140);\n+                g2d.drawString(\"FAILURE: No IAE for empty iterator, int\", 20, 140);\n+            } catch (IllegalArgumentException e) {\n+                g2d.drawString(\"caught expected IAE for empty iterator, int\", 20, 140);\n+            }\n@@ -318,1 +163,7 @@\n-       }\/\/ for\n+            \/\/ API 4: null & empty drawString(Iterator, float, int);\n+            try {\n+                g2d.drawString(nullIterator, 20.0f, 160.0f);\n+                g2d.drawString(\"FAILURE: No NPE for null iterator, float\", 20, 160);\n+            } catch (NullPointerException e) {\n+                g2d.drawString(\"caught expected NPE for null iterator, float\", 20, 160);\n+            }\n@@ -320,1 +171,7 @@\n-    }\/\/printInstructions()\n+            try {\n+                g2d.drawString(emptyIterator, 20, 180);\n+                g2d.drawString(\"FAILURE: No IAE for empty iterator, float\", 20, 180);\n+            } catch (IllegalArgumentException e) {\n+                g2d.drawString(\"caught expected IAE for empty iterator, float\", 20, 180);\n+            }\n+        }\n@@ -322,4 +179,4 @@\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n+        @Override\n+        public Dimension getPreferredSize() {\n+            return new Dimension(450, 250);\n+        }\n@@ -327,2 +184,1 @@\n-\n- }\/\/ TestDialog  class\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrintNullString.java","additions":140,"deletions":284,"binary":false,"changes":424,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,14 @@\n-\/**\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+import javax.swing.BorderFactory;\n+import javax.swing.Box;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JOptionPane;\n+\n+\/*\n@@ -29,0 +42,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,0 +46,22 @@\n+public class PrintParenString implements Printable {\n+    private static final String STR = \"String containing unclosed parenthesis (.\";\n+\n+    private static final String INSTRUCTIONS =\n+            \"This test should print a page with following text\\n\\n\" +\n+            STR + \"\\n\\n\" +\n+            \"If an exception is thrown, or the page doesn't print properly\\n\" +\n+            \"then the test fails\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .splitUI(PrintParenString::createTestUI)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n+    }\n@@ -32,42 +69,15 @@\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.print.*;\n-import java.text.*;\n-\n-public class PrintParenString extends Frame implements ActionListener {\n-\n- private TextCanvas c;\n-\n- public static void main(String args[]) {\n-\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test should print a page which contains the same\",\n-         \"text message as in the test window on the screen\",\n-         \"You should also monitor the command line to see if any exceptions\",\n-         \"were thrown\",\n-         \"If an exception is thrown, or the page doesn't print properly\",\n-         \"then the test fails\",\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-    PrintParenString f = new PrintParenString();\n-    f.show();\n- }\n-\n- public PrintParenString() {\n-    super(\"JDK 1.2 drawString Printing\");\n-\n-    c = new TextCanvas();\n-    add(\"Center\", c);\n-\n-    Button printButton = new Button(\"Print\");\n-    printButton.addActionListener(this);\n-    add(\"South\", printButton);\n-\n-    addWindowListener(new WindowAdapter() {\n-       public void windowClosing(WindowEvent e) {\n-             System.exit(0);\n+    private static JComponent createTestUI() {\n+        JButton b = new JButton(\"Print\");\n+        b.addActionListener((ae) -> {\n+            try {\n+                PrinterJob job = PrinterJob.getPrinterJob();\n+                job.setPrintable(new PrintParenString());\n+                if (job.printDialog()) {\n+                    job.print();\n+                }\n+            } catch (PrinterException ex) {\n+                ex.printStackTrace();\n+                String msg = \"PrinterException: \" + ex.getMessage();\n+                JOptionPane.showMessageDialog(b, msg, \"Error occurred\",\n+                        JOptionPane.ERROR_MESSAGE);\n+                PassFailJFrame.forceFail(msg);\n@@ -75,41 +85,8 @@\n-    });\n-\n-    pack();\n- }\n-\n- public void actionPerformed(ActionEvent e) {\n-\n-   PrinterJob pj = PrinterJob.getPrinterJob();\n-\n-   if (pj != null && pj.printDialog()) {\n-\n-       pj.setPrintable(c);\n-       try {\n-            pj.print();\n-      } catch (PrinterException pe) {\n-      } finally {\n-         System.err.println(\"PRINT RETURNED\");\n-      }\n-   }\n- }\n-\n- class TextCanvas extends Panel implements Printable {\n-\n-    String nullStr = null;\n-    String emptyStr = new String();\n-    AttributedString nullAttStr = null;\n-    AttributedString emptyAttStr = new AttributedString(emptyStr);\n-    AttributedCharacterIterator nullIterator = null;\n-    AttributedCharacterIterator emptyIterator = emptyAttStr.getIterator();\n-\n-    public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n-\n-      if (pgIndex > 0)\n-         return Printable.NO_SUCH_PAGE;\n-\n-      Graphics2D g2d = (Graphics2D)g;\n-      g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n-\n-      paint(g);\n-\n-      return Printable.PAGE_EXISTS;\n+        });\n+\n+        Box main = Box.createHorizontalBox();\n+        main.setBorder(BorderFactory.createEmptyBorder(8, 8, 8, 8));\n+        main.add(Box.createHorizontalGlue());\n+        main.add(b);\n+        main.add(Box.createHorizontalGlue());\n+        return main;\n@@ -118,5 +95,5 @@\n-    public void paint(Graphics g1) {\n-        Graphics2D g = (Graphics2D)g1;\n-\n-          String str = \"String containing unclosed parenthesis (.\";\n-          g.drawString(str, 20, 40);\n+    @Override\n+    public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n+        if (pgIndex > 0) {\n+            return Printable.NO_SUCH_PAGE;\n+        }\n@@ -124,1 +101,3 @@\n-    }\n+        Graphics2D g2d = (Graphics2D) g;\n+        g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n+        g2d.drawString(STR, 20, 40);\n@@ -126,2 +105,1 @@\n-     public Dimension getPreferredSize() {\n-        return new Dimension(450, 250);\n+        return Printable.PAGE_EXISTS;\n@@ -129,2 +107,0 @@\n- }\n-\n@@ -132,115 +108,0 @@\n-\n-class Sysout\n- {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n- }\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrintParenString.java","additions":71,"deletions":210,"binary":false,"changes":281,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,17 @@\n-\/**\n+import java.awt.Button;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n+import java.awt.geom.AffineTransform;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+import javax.swing.JOptionPane;\n+\n+\/*\n@@ -28,0 +44,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,0 +49,21 @@\n+public class PrintTranslatedFont extends Frame {\n+    private static final String INSTRUCTIONS =\n+            \"This test should print a page which contains the same\\n\" +\n+            \"content as the test window on the screen, in particular the lines\\n\" +\n+            \"should be immediately under the text\\n\\n\" +\n+            \"If an exception is thrown, or the page doesn't print properly\\n\" +\n+            \"then the test fails\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .testUI(PrintTranslatedFont::new)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n+    }\n@@ -32,44 +71,21 @@\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.geom.*;\n-import java.awt.print.*;\n-import java.text.*;\n-\n-public class PrintTranslatedFont extends Frame implements ActionListener {\n-\n- private TextCanvas c;\n-\n- public static void main(String args[]) {\n-\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test should print a page which contains the same\",\n-         \"content as the test window on the screen, in particular the lines\",\n-         \"should be immediately under the text\",\n-         \"You should also monitor the command line to see if any exceptions\",\n-         \"were thrown\",\n-         \"If an exception is thrown, or the page doesn't print properly\",\n-         \"then the test fails\",\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-    PrintTranslatedFont f = new PrintTranslatedFont();\n-    f.show();\n- }\n-\n- public PrintTranslatedFont() {\n-    super(\"JDK 1.2 drawString Printing\");\n-\n-    c = new TextCanvas();\n-    add(\"Center\", c);\n-\n-    Button printButton = new Button(\"Print\");\n-    printButton.addActionListener(this);\n-    add(\"South\", printButton);\n-\n-    addWindowListener(new WindowAdapter() {\n-       public void windowClosing(WindowEvent e) {\n-             System.exit(0);\n+    public PrintTranslatedFont() {\n+        super(\"PrintTranslatedFont\");\n+\n+        TextCanvas c = new TextCanvas();\n+        add(\"Center\", c);\n+\n+        Button b = new Button(\"Print\");\n+        add(\"South\", b);\n+        b.addActionListener(e -> {\n+            PrinterJob pj = PrinterJob.getPrinterJob();\n+            if (pj.printDialog()) {\n+                pj.setPrintable(c);\n+                try {\n+                    pj.print();\n+                } catch (PrinterException ex) {\n+                    ex.printStackTrace();\n+                    String msg = \"PrinterException: \" + ex.getMessage();\n+                    JOptionPane.showMessageDialog(b, msg, \"Error occurred\",\n+                            JOptionPane.ERROR_MESSAGE);\n+                    PassFailJFrame.forceFail(msg);\n+                }\n@@ -77,6 +93,1 @@\n-    });\n-\n-    pack();\n- }\n-\n- public void actionPerformed(ActionEvent e) {\n+        });\n@@ -84,27 +95,1 @@\n-   PrinterJob pj = PrinterJob.getPrinterJob();\n-\n-   if (pj != null && pj.printDialog()) {\n-\n-       pj.setPrintable(c);\n-       try {\n-            pj.print();\n-      } catch (PrinterException pe) {\n-      } finally {\n-         System.err.println(\"PRINT RETURNED\");\n-      }\n-   }\n- }\n-\n- class TextCanvas extends Panel implements Printable {\n-\n-    public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n-\n-      if (pgIndex > 0)\n-         return Printable.NO_SUCH_PAGE;\n-\n-      Graphics2D g2d = (Graphics2D)g;\n-      g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n-\n-      paint(g);\n-\n-      return Printable.PAGE_EXISTS;\n+        pack();\n@@ -113,23 +98,12 @@\n-    public void paint(Graphics g1) {\n-        Graphics2D g = (Graphics2D)g1;\n-\n-          Font f = new Font(\"Dialog\", Font.PLAIN, 20);\n-          int tx = 20;\n-          int ty = 20;\n-          AffineTransform at = AffineTransform.getTranslateInstance(tx, ty);\n-          f = f.deriveFont(at);\n-          g.setFont(f);\n-\n-          FontMetrics fm = g.getFontMetrics();\n-          String str = \"Basic ascii string\";\n-          int sw = fm.stringWidth(str);\n-          int posx = 20, posy = 40;\n-          g.drawString(str, posx, posy);\n-          g.drawLine(posx+tx, posy+ty+2, posx+tx+sw, posy+ty+2);\n-\n-          posx = 20; posy = 70;\n-          str = \"Test string compound printing \\u2203\\u2200\";\n-          sw = fm.stringWidth(str);\n-          g.drawString(str, posx, posy);\n-          g.drawLine(posx+tx, posy+ty+2, posx+tx+sw, posy+ty+2);\n-    }\n+    private static class TextCanvas extends Panel implements Printable {\n+        @Override\n+        public void paint(Graphics g) {\n+            Graphics2D g2d = (Graphics2D) g;\n+            paint(g2d);\n+        }\n+\n+        @Override\n+        public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n+            if (pgIndex > 0) {\n+                return Printable.NO_SUCH_PAGE;\n+            }\n@@ -137,2 +111,34 @@\n-     public Dimension getPreferredSize() {\n-        return new Dimension(450, 250);\n+            Graphics2D g2d = (Graphics2D) g;\n+            g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n+            paint(g2d);\n+            return Printable.PAGE_EXISTS;\n+        }\n+\n+        private void paint(Graphics2D g2d) {\n+            Font f = new Font(\"Dialog\", Font.PLAIN, 20);\n+            int tx = 20;\n+            int ty = 20;\n+            AffineTransform at = AffineTransform.getTranslateInstance(tx, ty);\n+            f = f.deriveFont(at);\n+            g2d.setFont(f);\n+\n+            FontMetrics fm = g2d.getFontMetrics();\n+            String str = \"Basic ascii string\";\n+            int sw = fm.stringWidth(str);\n+            int posx = 20;\n+            int posy = 40;\n+            g2d.drawString(str, posx, posy);\n+            g2d.drawLine(posx + tx, posy + ty + 2, posx + tx + sw, posy + ty + 2);\n+\n+            posx = 20;\n+            posy = 70;\n+            str = \"Test string compound printing \\u2203\\u2200\";\n+            sw = fm.stringWidth(str);\n+            g2d.drawString(str, posx, posy);\n+            g2d.drawLine(posx + tx, posy + ty + 2, posx + tx + sw, posy + ty + 2);\n+        }\n+\n+        @Override\n+        public Dimension getPreferredSize() {\n+            return new Dimension(450, 250);\n+        }\n@@ -140,2 +146,0 @@\n- }\n-\n@@ -143,115 +147,0 @@\n-\n-class Sysout\n- {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n- }\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrintTranslatedFont.java","additions":110,"deletions":221,"binary":false,"changes":331,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,15 @@\n-\/**\n+import java.awt.Frame;\n+import java.awt.print.PageFormat;\n+import java.awt.print.PrinterJob;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import javax.print.PrintService;\n+import javax.print.attribute.HashPrintRequestAttributeSet;\n+import javax.print.attribute.PrintRequestAttributeSet;\n+import javax.swing.BorderFactory;\n+import javax.swing.Box;\n+import javax.swing.JComponent;\n+import javax.swing.JLabel;\n+import javax.swing.SwingUtilities;\n+\n+\/*\n@@ -28,1 +42,5 @@\n- * @run main\/othervm\/manual -Djava.security.manager=allow SecurityDialogTest\n+ * @summary Verifies \"Print to file\" option is disable if reading\/writing files\n+ *          is not allowed by Security Manager.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual\/othervm -Djava.security.manager=allow SecurityDialogTest\n@@ -30,8 +48,0 @@\n-\n-import java.awt.* ;\n-import java.awt.print.* ;\n-import java.io.*;\n-import java.security.*;\n-import javax.print.*;\n-import javax.print.attribute.*;\n-\n@@ -39,0 +49,19 @@\n+    private static final String INSTRUCTIONS =\n+            \"This test brings up a native and cross-platform page and print dialogs.\\n\" +\n+            \"\\n\" +\n+            \"If the dialog has an option to save to file, the option ought \" +\n+            \"to be disabled.\\n\" +\n+            \"\\n\" +\n+            \"Press the Pass button if the \\\"Print to file\\\" option was disabled in\\n\" +\n+            \"all the dialogs where it was present.\\n\" +\n+            \"Otherwise, press the Fail button.\\n\" +\n+            \"\\n\" +\n+            \"The dialogs should be displayed even when \\n\" +\n+            \"there is no queuePrintJob permission.\";\n+\n+    private static JLabel dialogType;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n@@ -40,0 +69,6 @@\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .splitUIBottom(SecurityDialogTest::createTestUI)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build();\n@@ -41,16 +76,1 @@\n-    public static void main ( String args[] ) {\n-\n-        String[] instructions =\n-           {\n-            \"You must have a printer available to perform this test.\",\n-            \"This test brings up a native and cross-platform page and\",\n-            \"print dialogs.\",\n-            \"The dialogs should be displayed even when \",\n-            \"there is no queuePrintJob permission.\",\n-            \"If the dialog has an option to save to file, the option ought\",\n-            \"to be disabled if there is no read\/write file permission.\",\n-            \"You should test this by trying different policy files.\"\n-          };\n-\n-         Sysout.createDialog( );\n-         Sysout.printInstructions( instructions );\n+        displayDialogs();\n@@ -58,1 +78,1 @@\n-        SecurityDialogTest pjc = new SecurityDialogTest() ;\n+        passFailJFrame.awaitAndCheck();\n@@ -61,0 +81,2 @@\n+    private static JComponent createTestUI() {\n+        dialogType = new JLabel(\" \");\n@@ -62,41 +84,7 @@\n-  public SecurityDialogTest() {\n-\n-      PrinterJob pj = PrinterJob.getPrinterJob() ;\n-\n-      \/\/ Install a security manager which does not allow reading and\n-      \/\/ writing of files.\n-      \/\/PrintTestSecurityManager ptsm = new PrintTestSecurityManager();\n-      SecurityManager ptsm = new SecurityManager();\n-\n-      try {\n-          System.setSecurityManager(ptsm);\n-      } catch (SecurityException e) {\n-          System.out.println(\"Could not run test - security exception\");\n-      }\n-\n-      try {\n-          PrintJob pjob = Toolkit.getDefaultToolkit().getPrintJob(new Frame(), \"Printing\", null, null);\n-          Sysout.println(\"If the value of pjob is null, the test fails.\\n\");\n-          Sysout.println(\"        pjob = \"+pjob);\n-      } catch (SecurityException e) {\n-      }\n-\n-      PrintService[] services = PrinterJob.lookupPrintServices();\n-      for (int i=0; i<services.length; i++) {\n-          System.out.println(\"SecurityDialogTest service \"+i+\" : \"+services[i]);\n-      }\n-\n-      PrintService defservice = pj.getPrintService();\n-      System.out.println(\"SecurityDialogTest default service : \"+defservice);\n-\n-      System.out.println(\"SecurityDialogTest native PageDialog \");\n-      PageFormat pf1 = pj.pageDialog(new PageFormat());\n-\n-      System.out.println(\"SecurityDialogTest swing PageDialog \");\n-      PrintRequestAttributeSet attributes = new HashPrintRequestAttributeSet();\n-      PageFormat pf2 = pj.pageDialog(attributes);\n-\n-      \/\/ With the security manager installed, save to file should now\n-      \/\/ be denied.\n-      System.out.println(\"SecurityDialogTest native printDialog \");\n-      pj.printDialog();\n+        Box main = Box.createVerticalBox();\n+        main.setBorder(BorderFactory.createEmptyBorder(8, 8, 8, 8));\n+        main.add(new JLabel(\"Current Dialog:\"));\n+        main.add(Box.createVerticalStrut(4));\n+        main.add(dialogType);\n+        return main;\n+    }\n@@ -104,3 +92,3 @@\n-      System.out.println(\"SecurityDialogTest swing printDialog \");\n-      pj.printDialog(attributes);\n-  }\n+    private static void displayDialogs()\n+            throws InterruptedException, InvocationTargetException {\n+        final PrinterJob pj = PrinterJob.getPrinterJob();\n@@ -108,0 +96,4 @@\n+        \/\/ Install a security manager which does not allow reading and\n+        \/\/ writing of files.\n+        SecurityManager ptsm = new SecurityManager();\n+        System.setSecurityManager(ptsm);\n@@ -109,4 +101,3 @@\n-    class PrintTestSecurityManager extends SecurityManager {\n-        public void checkPackageAccess(String pkg) {\n-        }\n-        public void checkPropertyAccess(String key) {\n+        PrintService[] services = PrinterJob.lookupPrintServices();\n+        for (int i = 0; i < services.length; i++) {\n+            System.out.println(\"SecurityDialogTest service \" + i + \" : \" + services[i]);\n@@ -115,1 +106,1 @@\n-    }\n+        System.out.println(\"SecurityDialogTest default service : \" + pj.getPrintService());\n@@ -117,3 +108,2 @@\n-}\n-class Sysout {\n-   private static TestDialog dialog;\n+        setDialogType(\"Native Page Dialog\");\n+        pj.pageDialog(new PageFormat());\n@@ -121,16 +111,3 @@\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n+        setDialogType(\"Swing Page Dialog\");\n+        PrintRequestAttributeSet attributes = new HashPrintRequestAttributeSet();\n+        pj.pageDialog(attributes);\n@@ -138,0 +115,4 @@\n+        \/\/ With the security manager installed, save to file should now\n+        \/\/ be denied.\n+        setDialogType(\"Native Print Dialog\");\n+        pj.printDialog();\n@@ -139,5 +120,2 @@\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n+        setDialogType(\"Swing Print Dialog\");\n+        pj.printDialog(attributes);\n@@ -145,3 +123,1 @@\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n+        setDialogType(\"Test completed\");\n@@ -150,78 +126,3 @@\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n+    private static void setDialogType(String type)\n+            throws InterruptedException, InvocationTargetException {\n+        SwingUtilities.invokeAndWait(() -> dialogType.setText(type));\n@@ -229,2 +130,1 @@\n-\n- }\/\/ TestDialog  class\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/SecurityDialogTest.java","additions":84,"deletions":184,"binary":false,"changes":268,"status":"modified"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8071693\n+ * @summary Verify that the Introspector finds default methods inherited\n+ *          from interfaces\n+ *\/\n+\n+import java.beans.IntrospectionException;\n+import java.beans.Introspector;\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.NavigableSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class DefaultMethodBeanPropertyTest {\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/                                  \/\/\n+\/\/          SCENARIO 1              \/\/\n+\/\/                                  \/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    public interface A1 {\n+        default int getValue() {\n+            return 0;\n+        }\n+        default Object getObj() {\n+            return null;\n+        }\n+\n+        public static int getStaticValue() {\n+            return 0;\n+        }\n+    }\n+\n+    public interface B1 extends A1 {\n+    }\n+\n+    public interface C1 extends A1 {\n+        Number getFoo();\n+    }\n+\n+    public class D1 implements C1 {\n+        @Override\n+        public Integer getFoo() {\n+            return null;\n+        }\n+        @Override\n+        public Float getObj() {\n+            return null;\n+        }\n+    }\n+\n+    public static void testScenario1() {\n+        verifyProperties(D1.class,\n+            \"getClass\",     \/\/ inherited method\n+            \"getValue\",     \/\/ inherited default method\n+            \"getFoo\",       \/\/ overridden interface method\n+            \"getObj\"        \/\/ overridden default method\n+        );\n+    }\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/                                  \/\/\n+\/\/          SCENARIO 2              \/\/\n+\/\/                                  \/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    public interface A2 {\n+        default Object getFoo() {\n+            return null;\n+        }\n+    }\n+\n+    public interface B2 extends A2 {\n+    }\n+\n+    public interface C2 extends A2 {\n+    }\n+\n+    public class D2 implements B2, C2 {\n+    }\n+\n+    public static void testScenario2() {\n+        verifyProperties(D2.class,\n+            \"getClass\",\n+            \"getFoo\"\n+        );\n+    }\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/                                  \/\/\n+\/\/          SCENARIO 3              \/\/\n+\/\/                                  \/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    public interface A3 {\n+        default Object getFoo() {\n+            return null;\n+        }\n+    }\n+\n+    public interface B3 extends A3 {\n+        @Override\n+        Set<?> getFoo();\n+    }\n+\n+    public interface C3 extends A3 {\n+        @Override\n+        Collection<?> getFoo();\n+    }\n+\n+    public class D3 implements B3, C3 {\n+        @Override\n+        public NavigableSet<?> getFoo() {\n+            return null;\n+        }\n+    }\n+\n+    public static void testScenario3() {\n+        verifyProperties(D3.class,\n+            \"getClass\",\n+            \"getFoo\"\n+        );\n+    }\n+\n+\/\/ Helper methods\n+\n+    public static void verifyProperties(Class<?> type, String... getterNames) {\n+\n+        \/\/ Gather expected properties\n+        final HashSet<PropertyDescriptor> expected = new HashSet<>();\n+        for (String methodName : getterNames) {\n+            final String suffix = methodName.substring(3);\n+            final String propName = Introspector.decapitalize(suffix);\n+            final Method getter;\n+            try {\n+                getter = type.getMethod(methodName);\n+            } catch (NoSuchMethodException e) {\n+                throw new Error(\"unexpected error\", e);\n+            }\n+            final PropertyDescriptor propDesc;\n+            try {\n+                propDesc = new PropertyDescriptor(propName, getter, null);\n+            } catch (IntrospectionException e) {\n+                throw new Error(\"unexpected error\", e);\n+            }\n+            expected.add(propDesc);\n+        }\n+\n+        \/\/ Verify properties can be found directly\n+        expected.stream()\n+                .map(PropertyDescriptor::getName)\n+                .filter(name -> BeanUtils.getPropertyDescriptor(type, name) == null)\n+                .findFirst()\n+                .ifPresent(name -> {\n+                    throw new Error(\"property \\\"\" + name + \"\\\" not found in \" + type);\n+                });\n+\n+        \/\/ Gather actual properties\n+        final Set<PropertyDescriptor> actual =\n+                Set.of(BeanUtils.getPropertyDescriptors(type));\n+\n+        \/\/ Verify the two sets are the same\n+        if (!actual.equals(expected)) {\n+            throw new Error(\"mismatch: \" + type\n+              + \"\\nACTUAL:\\n  \"\n+              + actual.stream()\n+                      .map(Object::toString)\n+                      .collect(Collectors.joining(\"\\n  \"))\n+              + \"\\nEXPECTED:\\n  \"\n+              + expected.stream()\n+                        .map(Object::toString)\n+                        .collect(Collectors.joining(\"\\n  \")));\n+        }\n+    }\n+\n+\/\/ Main method\n+\n+    public static void main(String[] args) throws Exception {\n+        testScenario1();\n+        testScenario2();\n+        testScenario3();\n+    }\n+}\n","filename":"test\/jdk\/java\/beans\/Introspector\/DefaultMethodBeanPropertyTest.java","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4926314\n+ * @bug 4926314 8287003\n@@ -41,0 +41,1 @@\n+import java.nio.charset.CodingErrorAction;\n@@ -44,0 +45,1 @@\n+import static java.nio.charset.StandardCharsets.UTF_8;\n@@ -59,0 +61,7 @@\n+    private void fillBuffer(CharBuffer buffer) {\n+        char[] filler = new char[BUFFER_SIZE];\n+        Arrays.fill(filler, 'x');\n+        buffer.put(filler);\n+        buffer.clear();\n+    }\n+\n@@ -81,5 +90,14 @@\n-    private void fillBuffer(CharBuffer buffer) {\n-        char[] filler = new char[BUFFER_SIZE];\n-        Arrays.fill(filler, 'x');\n-        buffer.put(filler);\n-        buffer.clear();\n+    @Test\n+    public void readLeftover() throws IOException {\n+        byte[] b = new byte[] {'a', 'b', (byte) 0xC2};\n+        ByteArrayInputStream bais = new ByteArrayInputStream(b);\n+        InputStreamReader r = new InputStreamReader(bais,\n+            UTF_8.newDecoder().onMalformedInput(CodingErrorAction.IGNORE));\n+        int n = r.read();\n+        assertEquals((char)n, 'a');\n+        char[] c = new char[3];\n+        n = r.read(c, 0, 3);\n+        assertEquals(n, 1);\n+        assertEquals((char)c[0], 'b');\n+        n = r.read();\n+        assertEquals(n, -1);\n@@ -87,1 +105,0 @@\n-\n","filename":"test\/jdk\/java\/io\/InputStreamReader\/ReadCharBuffer.java","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/Basic.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/InheritIOTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/JspawnhelperProtocol.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/ReaderWriterTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/SkipTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+ * @requires vm.flagless\n@@ -98,0 +99,18 @@\n+\n+        \/\/ Please note (JDK-8284282):\n+        \/\/\n+        \/\/ On Unix, this test relies on the ability of the system to adopt orphaned processes and\n+        \/\/ reap them in a timely fashion. In other words, the ability to prevent orphans from becoming\n+        \/\/ zombies.\n+        \/\/\n+        \/\/ Therefore, on misconfigured or broken systems, this test may fail. These failures will manifest\n+        \/\/ as timeouts. The failures depend on timing: they may not happen at all, be intermittent or\n+        \/\/ constant.\n+        \/\/\n+        \/\/ That will rarely be a problem on bare-metal systems but may be more common when running in\n+        \/\/ Docker. Misconfigured Docker instances may run with an initial process unable to reap. One\n+        \/\/ infamous example would be running jtreg tests inside a Docker via Jenkins CI.\n+        \/\/\n+        \/\/ This is quite difficult - and inefficient - to fix inside this test, and rather easy to\n+        \/\/ avoid. For a detailed analysis, as well as proposed workarounds, please see JDK-8284282.\n+        \/\/\n","filename":"test\/jdk\/java\/lang\/ProcessHandle\/OnExitTest.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/ProcessHandle\/TreeTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/exec\/ArgWithSpaceAndFinalBackslash.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+   @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/exec\/Duped.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+   @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/exec\/ExecWithLotsOfArgs.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/exec\/ExitValue.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- *\n+ * @requires vm.flagless\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/exec\/SetCwd.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -54,0 +53,1 @@\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -76,0 +76,1 @@\n+ *        jdk.httpclient.test.lib.common.TestServerConfigurator\n@@ -302,1 +303,1 @@\n-        httpsTestServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        httpsTestServer.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), sslContext));\n","filename":"test\/jdk\/java\/net\/httpclient\/AsFileDownloadTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -56,1 +57,1 @@\n- *        DigestEchoServer\n+ *        DigestEchoServer jdk.httpclient.test.lib.common.TestServerConfigurator\n@@ -134,1 +135,1 @@\n-            sserver1.setHttpsConfigurator(new HttpsConfigurator(context));\n+            sserver1.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), context));\n","filename":"test\/jdk\/java\/net\/httpclient\/AuthFilterCacheTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ *        jdk.httpclient.test.lib.common.TestServerConfigurator\n@@ -54,1 +55,0 @@\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -63,0 +63,2 @@\n+\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -270,1 +272,1 @@\n-        httpsTestServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        httpsTestServer.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), sslContext));\n","filename":"test\/jdk\/java\/net\/httpclient\/ConcurrentResponses.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *        jdk.httpclient.test.lib.common.TestServerConfigurator\n@@ -46,1 +47,0 @@\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -55,0 +55,2 @@\n+\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -203,1 +205,1 @@\n-        httpsTestServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        httpsTestServer.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), sslContext));\n","filename":"test\/jdk\/java\/net\/httpclient\/CustomResponseSubscriber.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,3 @@\n- * @modules java.net.http\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext jdk.httpclient.test.lib.common.TestServerConfigurator\n+ * @modules java.net.http\/jdk.internal.net.http.common\n@@ -29,2 +31,0 @@\n- * @library \/test\/lib\n- * @build jdk.test.lib.net.SimpleSSLContext\n@@ -37,1 +37,0 @@\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -52,0 +51,2 @@\n+\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -151,1 +152,1 @@\n-        httpsTestServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        httpsTestServer.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), sslContext));\n","filename":"test\/jdk\/java\/net\/httpclient\/ExpectContinue.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -23,2 +23,0 @@\n-import com.sun.net.httpserver.HttpServer;\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -26,0 +24,1 @@\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -63,1 +62,0 @@\n-import jdk.httpclient.test.lib.http2.Http2TestServer;\n@@ -72,0 +70,1 @@\n+ *        jdk.httpclient.test.lib.common.TestServerConfigurator\n@@ -178,1 +177,1 @@\n-            sserver1.setHttpsConfigurator(new HttpsConfigurator(context));\n+            sserver1.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), context));\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRedirectTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -23,2 +23,0 @@\n-import com.sun.net.httpserver.HttpServer;\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -26,0 +24,1 @@\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -54,1 +53,0 @@\n-import jdk.httpclient.test.lib.http2.Http2TestServer;\n@@ -65,0 +63,1 @@\n+ *        jdk.httpclient.test.lib.common.TestServerConfigurator\n@@ -141,1 +140,1 @@\n-            sserver1.setHttpsConfigurator(new HttpsConfigurator(context));\n+            sserver1.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), context));\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpSlowServerTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ *        jdk.httpclient.test.lib.common.TestServerConfigurator\n@@ -46,1 +47,0 @@\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -56,0 +56,2 @@\n+\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -192,1 +194,1 @@\n-        httpsTestServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        httpsTestServer.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), sslContext));\n","filename":"test\/jdk\/java\/net\/httpclient\/ImmutableFlowItems.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -23,2 +23,0 @@\n-import com.sun.net.httpserver.HttpServer;\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -64,1 +62,1 @@\n-import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -85,0 +83,1 @@\n+ *        jdk.httpclient.test.lib.common.TestServerConfigurator\n@@ -1014,1 +1013,1 @@\n-            sserver1.setHttpsConfigurator(new HttpsConfigurator(context));\n+            sserver1.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), context));\n","filename":"test\/jdk\/java\/net\/httpclient\/LargeHandshakeTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -23,2 +23,0 @@\n-import com.sun.net.httpserver.HttpServer;\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -26,0 +24,1 @@\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -41,1 +40,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -54,1 +52,0 @@\n-import jdk.httpclient.test.lib.http2.Http2TestServer;\n@@ -67,0 +64,1 @@\n+ *        jdk.httpclient.test.lib.common.TestServerConfigurator\n@@ -139,1 +137,1 @@\n-            sserver1.setHttpsConfigurator(new HttpsConfigurator(context));\n+            sserver1.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), context));\n","filename":"test\/jdk\/java\/net\/httpclient\/LargeResponseTest.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -53,0 +52,2 @@\n+\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -114,1 +115,1 @@\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(ctx));\n+        httpsServer.setHttpsConfigurator(new TestServerConfigurator(addr.getAddress(), ctx));\n","filename":"test\/jdk\/java\/net\/httpclient\/LightWeightHttpServer.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *        jdk.httpclient.test.lib.common.TestServerConfigurator\n@@ -49,1 +50,0 @@\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -61,0 +61,2 @@\n+\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -210,1 +212,1 @@\n-        httpsTestServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        httpsTestServer.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), sslContext));\n","filename":"test\/jdk\/java\/net\/httpclient\/MappingResponseSubscriber.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n- * @modules java.net.http\n+ * @modules java.net.http\/jdk.internal.net.http.common\n@@ -65,1 +65,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n@@ -69,1 +69,1 @@\n- * @build jdk.test.lib.net.SimpleSSLContext\n+ * @build jdk.test.lib.net.SimpleSSLContext jdk.httpclient.test.lib.common.TestServerConfigurator\n","filename":"test\/jdk\/java\/net\/httpclient\/RequestBodyTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,5 @@\n+\/\/ for jdk\/httpclient\/test\/lib\/* classes\n+grant codeBase \"file:${test.classes}\/..\/..\/..\/..\/test\/jdk\/java\/net\/httpclient\/lib\/-\" {\n+    permission java.lang.RuntimePermission \"accessClassInPackage.jdk.internal.net.http.common\";\n+};\n+\n@@ -55,0 +60,2 @@\n+\n+    permission java.lang.RuntimePermission \"accessClassInPackage.jdk.internal.net.http.common\";\n","filename":"test\/jdk\/java\/net\/httpclient\/RequestBodyTest.policy","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -801,2 +800,2 @@\n-                    InetSocketAddress sa = new InetSocketAddress(\n-                            InetAddress.getLoopbackAddress(), 0);\n+                    InetAddress loopback = InetAddress.getLoopbackAddress();\n+                    InetSocketAddress sa = new InetSocketAddress(loopback, 0);\n@@ -808,1 +807,1 @@\n-                        https.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+                        https.setHttpsConfigurator(new TestServerConfigurator(loopback, sslContext));\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/common\/HttpServerAdapters.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.httpclient.test.lib.common;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import javax.net.ssl.SNIHostName;\n+import javax.net.ssl.SNIMatcher;\n+import javax.net.ssl.SNIServerName;\n+import javax.net.ssl.StandardConstants;\n+\n+import jdk.internal.net.http.common.Logger;\n+import jdk.internal.net.http.common.Utils;\n+\n+\/**\n+ * A (server side) SNI host name matcher. Implementation is based on the expectations set in\n+ * section 3 of RFC-6066.\n+ * A server can be configured with an instance of this class.\n+ * <p>\n+ * The RFC states:\n+ * {@code\n+ * Currently, the only server names supported are DNS hostnames; however, this does not imply\n+ * any dependency of TLS on DNS,\n+ * ....\n+ * TLS MAY treat provided server names as opaque data and pass the names and types to the application.\n+ * }\n+ * <p>\n+ * The implementation in this class doesn't mandate the configured\/recognized SNI host name as DNS\n+ * resolvable. However, the {@code ServerNameMatcher} can be configured to treat the SNI host name\n+ * as DNS resolvable by passing {@code true} to the {@code attemptDNSResolution} parameter of\n+ * the {@link #ServerNameMatcher(boolean, String) constructor}\n+ *\/\n+public class ServerNameMatcher extends SNIMatcher {\n+\n+    private final Logger debug;\n+    private final boolean attemptDNSResolution;\n+    private final Set<String> recognizedSNINames;\n+\n+    \/**\n+     * Creates a ServerNameMatcher which recognizes the passed {@code recognizedSNIName}\n+     *\n+     * @param recognizedSNIName The SNI host name\n+     *\/\n+    public ServerNameMatcher(final String recognizedSNIName) {\n+        this(false, recognizedSNIName);\n+    }\n+\n+    \/**\n+     * Creates a ServerNameMatcher which recognizes the passed SNI host name\n+     * If {@code attemptDNSResolution} is {@code true}, then when\n+     * {@link #matches(SNIServerName) matching} a client requested SNI name against the server\n+     * recognized SNI name, the implementation will, as a last resort do a DNS resolution of the\n+     * client requested SNI name and the server recognized SNI name and compare them to\n+     * try and find a match. If {@code attemptDNSResolution} is false, then no DNS resolution is\n+     * attempted and instead the SNI names are literally compared.\n+     *\n+     * @param attemptDNSResolution If true then a DNS resolution will be attempted during\n+     *                             {@link #matches(SNIServerName) SNI matching}\n+     * @param recognizedSNIName    SNI host name\n+     *\/\n+    public ServerNameMatcher(final boolean attemptDNSResolution,\n+                             final String recognizedSNIName) {\n+        super(StandardConstants.SNI_HOST_NAME);\n+        Objects.requireNonNull(recognizedSNIName);\n+        this.debug = Utils.getDebugLogger(() -> \"SNIMatcher\");\n+        this.recognizedSNINames = Set.of(recognizedSNIName);\n+        this.attemptDNSResolution = attemptDNSResolution;\n+    }\n+\n+    \/**\n+     * @param clientRequestedSNI the SNI name requested by the client\n+     *                           {@return true if the {@code clientRequestedSNI} is recognized by\n+     *                           the server. false otherwise}\n+     *\/\n+    @Override\n+    public boolean matches(final SNIServerName clientRequestedSNI) {\n+        Objects.requireNonNull(clientRequestedSNI);\n+        if (!SNIHostName.class.isInstance(clientRequestedSNI)) {\n+            if (debug.on()) {\n+                debug.log(\"SNI match (against \" + recognizedSNINames + \")\" +\n+                        \" failed - not a SNIHostName: \" + clientRequestedSNI);\n+            }\n+            \/\/ we only support SNIHostName type\n+            return false;\n+        }\n+        final String requestedName = ((SNIHostName) clientRequestedSNI).getAsciiName();\n+        if (recognizedSNINames.contains(requestedName)) {\n+            if (debug.on()) {\n+                debug.log(\"SNI match (against \" + recognizedSNINames + \") passed: \"\n+                        + clientRequestedSNI);\n+            }\n+            return true;\n+        }\n+        if (attemptDNSResolution) {\n+            final boolean res = matchesAfterDNSResolution(requestedName);\n+            if (debug.on()) {\n+                debug.log(\"SNI match (against \" + recognizedSNINames + \") \"\n+                        + (res ? \"passed\" : \"failed\") + \": \" + clientRequestedSNI);\n+            }\n+            return res;\n+        }\n+        if (debug.on()) {\n+            debug.log(\"SNI match (against \" + recognizedSNINames + \") failed: \" + clientRequestedSNI);\n+        }\n+        return false;\n+    }\n+\n+    private boolean matchesAfterDNSResolution(final String clientRequestedSNI) {\n+        final InetAddress clientRequestedAddr;\n+        try {\n+            clientRequestedAddr = InetAddress.getByName(clientRequestedSNI);\n+        } catch (IOException e) {\n+            return false;\n+        }\n+        for (final String recognizedSNIName : recognizedSNINames) {\n+            final InetAddress serverRecognizedAddr;\n+            try {\n+                serverRecognizedAddr = InetAddress.getByName(recognizedSNIName);\n+            } catch (IOException e) {\n+                \/\/ try next\n+                continue;\n+            }\n+            if (serverRecognizedAddr.equals(clientRequestedAddr)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/common\/ServerNameMatcher.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.httpclient.test.lib.common;\n+\n+import java.net.InetAddress;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.List;\n+\n+import javax.net.ssl.SNIMatcher;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsParameters;\n+\n+\/**\n+ * A {@link HttpsConfigurator} that can be used with the HTTP1 test server over HTTPS.\n+ * This configurator {@link #configure(HttpsParameters) configures} the server's\n+ * {@link HttpsParameters} with the necessary {@link SSLParameters} including a\n+ * {@link SNIMatcher}\n+ *\/\n+public final class TestServerConfigurator extends HttpsConfigurator {\n+\n+    private final InetAddress serverAddr;\n+\n+    \/**\n+     * Creates a Https configuration, with the given {@link SSLContext}.\n+     *\n+     * @param serverAddr the address to which the server is bound\n+     * @param context    the {@code SSLContext} to use for this configurator\n+     * @throws NullPointerException if no {@code SSLContext} supplied\n+     *\/\n+    public TestServerConfigurator(final InetAddress serverAddr, final SSLContext context) {\n+        super(context);\n+        this.serverAddr = serverAddr;\n+    }\n+\n+    @Override\n+    public void configure(final HttpsParameters params) {\n+        final SSLParameters sslParams = getSSLContext().getDefaultSSLParameters();\n+        @SuppressWarnings(\"removal\") final SecurityManager sm = System.getSecurityManager();\n+        final String hostname;\n+        if (sm == null) {\n+            hostname = serverAddr.getHostName();\n+        } else {\n+            final PrivilegedAction<String> action = () -> serverAddr.getHostName();\n+            hostname = AccessController.doPrivileged(action);\n+        }\n+        final List<SNIMatcher> sniMatchers = List.of(new ServerNameMatcher(hostname));\n+        sslParams.setSNIMatchers(sniMatchers);\n+        \/\/ configure the server with these custom SSLParameters\n+        params.setSSLParameters(sslParams);\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/common\/TestServerConfigurator.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -28,3 +28,3 @@\n- * @library \/test\/lib\n- * @build jdk.test.lib.net.SimpleSSLContext\n- * @modules java.net.http\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext jdk.httpclient.test.lib.common.TestServerConfigurator\n+ * @modules java.net.http\/jdk.internal.net.http.common\n@@ -37,1 +37,0 @@\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -40,0 +39,1 @@\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -157,1 +157,1 @@\n-        httpsTestServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        httpsTestServer.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), sslContext));\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/HandshakeUrlEncodingTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,3 +28,3 @@\n- * @library \/test\/lib\n- * @build jdk.test.lib.net.SimpleSSLContext\n- * @modules java.net.http\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext jdk.httpclient.test.lib.common.TestServerConfigurator\n+ * @modules java.net.http\/jdk.internal.net.http.common\n@@ -37,1 +37,0 @@\n-import com.sun.net.httpserver.HttpsConfigurator;\n@@ -50,0 +49,2 @@\n+\n+import jdk.httpclient.test.lib.common.TestServerConfigurator;\n@@ -175,1 +176,1 @@\n-        httpsTestServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        httpsTestServer.setHttpsConfigurator(new TestServerConfigurator(sa.getAddress(), sslContext));\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/WSHandshakeExceptionTest.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-                InetAddress lo4 = InetAddress.ofLiteral(\"127.0.0.1\");\n+                InetAddress lo4 = InetAddress.getByName(\"127.0.0.1\");\n@@ -65,1 +65,1 @@\n-                InetAddress lo6 = InetAddress.ofLiteral(\"::1\");\n+                InetAddress lo6 = InetAddress.getByName(\"::1\");\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Disconnect.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -311,1 +311,1 @@\n-            long start = System.currentTimeMillis();\n+            long start = millisTime();\n@@ -313,1 +313,1 @@\n-            long duration = System.currentTimeMillis() - start;\n+            expectDuration(start, 500, Long.MAX_VALUE);\n@@ -315,1 +315,0 @@\n-            assertTrue(duration > 500, \"select took \" + duration + \" ms\");\n@@ -335,1 +334,1 @@\n-            long start = System.currentTimeMillis();\n+            long start = millisTime();\n@@ -337,1 +336,1 @@\n-            long duration = System.currentTimeMillis() - start;\n+            expectDuration(start, 0, 20_000);\n@@ -339,1 +338,0 @@\n-            assertTrue(duration < 5000, \"select took \" + duration + \" ms\");\n@@ -357,1 +355,1 @@\n-            long start = System.currentTimeMillis();\n+            long start = millisTime();\n@@ -359,1 +357,1 @@\n-            long duration = System.currentTimeMillis() - start;\n+            expectDuration(start, 0, 20_000);\n@@ -361,2 +359,0 @@\n-            assertTrue(duration > 500 && duration < 10*1000,\n-                    \"select took \" + duration + \" ms\");\n@@ -384,1 +380,1 @@\n-            long start = System.currentTimeMillis();\n+            long start = millisTime();\n@@ -386,1 +382,1 @@\n-            long duration = System.currentTimeMillis() - start;\n+            expectDuration(start, 0, 20_000);\n@@ -388,1 +384,0 @@\n-            assertTrue(duration < 5000, \"select took \" + duration + \" ms\");\n@@ -767,0 +762,28 @@\n+\n+    \/**\n+     * Returns the current time in milliseconds.\n+     *\/\n+    private static long millisTime() {\n+        long now = System.nanoTime();\n+        return TimeUnit.MILLISECONDS.convert(now, TimeUnit.NANOSECONDS);\n+    }\n+\n+    \/**\n+     * Check the duration of a task. The method will fail with an\n+     * AssertionError if the millisecond duration does not satisfy:\n+     *\n+     *     duration >= min && duration <= max\n+     *\n+     * Note that the inequalities are not strict, i.e., are inclusive.\n+     *\n+     * @param start start time, in milliseconds\n+     * @param min minimum expected duration, in milliseconds\n+     * @param max maximum expected duration, in milliseconds\n+     *\/\n+    private static void expectDuration(long start, long min, long max) {\n+        long duration = millisTime() - start;\n+        assertTrue(duration >= min,\n+                \"Duration \" + duration + \"ms, expected >= \" + min + \"ms\");\n+        assertTrue(duration <= max,\n+                \"Duration \" + duration + \"ms, expected <= \" + max + \"ms\");\n+    }\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/SelectWithConsumer.java","additions":37,"deletions":14,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,1 +161,1 @@\n-            s.setSoTimeout(1000);\n+            s.setSoTimeout(60_000);\n@@ -174,1 +174,1 @@\n-            s.setSoTimeout(5000);\n+            s.setSoTimeout(60_000);\n@@ -186,1 +186,1 @@\n-            s.setSoTimeout(1000);\n+            s.setSoTimeout(500);\n@@ -199,1 +199,1 @@\n-            s.setSoTimeout(60*1000);\n+            s.setSoTimeout(60_000);\n@@ -213,1 +213,1 @@\n-                s.setSoTimeout(60*1000);\n+                s.setSoTimeout(60_000);\n@@ -231,1 +231,1 @@\n-                s.setSoTimeout(60*1000);\n+                s.setSoTimeout(60_000);\n@@ -399,1 +399,1 @@\n-            s.setSoTimeout(60*1000);\n+            s.setSoTimeout(60_000);\n@@ -424,1 +424,1 @@\n-            s.setSoTimeout(60*1000);\n+            s.setSoTimeout(60_000);\n@@ -439,1 +439,1 @@\n-                s.setSoTimeout(60*1000);\n+                s.setSoTimeout(60_000);\n","filename":"test\/jdk\/java\/nio\/channels\/SocketChannel\/AdaptorStreams.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8319817\n+ * @summary Check that aliases cannot be mutated\n+ * @run junit AliasesCopy\n+ *\/\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetDecoder;\n+import java.nio.charset.CharsetEncoder;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.assertIterableEquals;\n+\n+public class AliasesCopy {\n+    private static final Set<String> ALIASES_SET = Set.of(\"foo-alias\");\n+    private static final String[] ALIASES_ARRAY = ALIASES_SET.toArray(String[]::new);\n+\n+    @Test\n+    public void aliasesCopy() {\n+        final FooCharset cs = new FooCharset(ALIASES_ARRAY);\n+        ALIASES_ARRAY[0] = \"bar-alias\";\n+        assertIterableEquals(ALIASES_SET, cs.aliases());\n+    }\n+\n+    private static final class FooCharset extends Charset {\n+        private FooCharset(String[] aliases) {\n+            super(\"foo\", aliases);\n+        }\n+\n+        @Override\n+        public CharsetEncoder newEncoder() {\n+            throw new RuntimeException(\"not implemented\");\n+        }\n+\n+        @Override\n+        public CharsetDecoder newDecoder() {\n+            throw new RuntimeException(\"not implemented\");\n+        }\n+\n+        @Override\n+        public boolean contains(Charset cs) {\n+            throw new RuntimeException(\"not implemented\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/charset\/Charset\/AliasesCopy.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static org.testng.Assert.*;\n+import org.testng.SkipException;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @bug 8032220 8293792\n+ * @summary Test java.nio.file.Files.createDirectories method\n+ * @library ..\n+ * @run testng CreateDirectories\n+ *\/\n+public class CreateDirectories {\n+\n+    \/**\n+     * Test Files.createDirectories symbolic file with an existing directory.\n+     *\/\n+    @Test\n+    public void testSymlinkDir() throws Exception {\n+        \/\/ create a temp dir as the \"root\" in which we will run our tests.\n+        final Path top = TestUtil.createTemporaryDirectory();\n+        if (!TestUtil.supportsLinks(top)) {\n+            System.out.println(\"Skipping tests since symbolic links isn't \" +\n+                    \"supported under directory \"+ top);\n+            throw new SkipException(\"Symbolic links not supported\");\n+        }\n+        System.out.println(\"Running tests under directory \" + top.toAbsolutePath());\n+        final Path fooDir = Files.createDirectory(top.resolve(\"foo\"));\n+        assertTrue(Files.isDirectory(fooDir),\n+                fooDir + \" was expected to be a directory but wasn't\");\n+\n+        \/\/ now create a symlink to the \"foo\" dir\n+        final Path symlink = Files.createSymbolicLink(top.resolve(\"symlinkToFoo\"),\n+                fooDir.toAbsolutePath());\n+        assertTrue(Files.isSymbolicLink(symlink),\n+                symlink + \" was expected to be a symlink but wasn't\");\n+        assertTrue(Files.isDirectory(symlink),\n+                symlink + \" was expected to be a directory but wasn't\");\n+\n+        \/\/ now create a directory under the symlink (which effectively creates a directory under\n+        \/\/ \"foo\")\n+        final Path barDir = Files.createDirectory(symlink.resolve(\"bar\"));\n+        assertTrue(Files.isDirectory(barDir),\n+                barDir + \" was expected to be a directory but wasn't\");\n+        \/\/ ultimately, we now have this directory structure:\n+        \/\/ <root-dir>\n+        \/\/   |--- foo\n+        \/\/   |     |--- bar\n+        \/\/   |\n+        \/\/   |--- symlinkToFoo -> (links to) <absolute-path-to-root-dir>\/foo\n+\n+\n+        \/\/ now call Files.createDirectories on each of these existing directory\/symlink paths\n+        \/\/ and expect each one to succeed\n+        Files.createDirectories(fooDir); \/\/ .\/<root-dir>\/foo\n+        Files.createDirectories(symlink); \/\/ .\/<root-dir>\/symlinkToFoo\n+        Files.createDirectories(barDir); \/\/ .\/<root-dir>\/symlinkToFoo\/bar\n+    }\n+\n+    \/**\n+     * Tests Files.createDirectories\n+     *\/\n+    @Test\n+    public void testCreateDirectories() throws IOException {\n+        final Path tmpdir = TestUtil.createTemporaryDirectory();\n+        \/\/ a no-op\n+        Files.createDirectories(tmpdir);\n+\n+        \/\/ create one directory\n+        Path subdir = tmpdir.resolve(\"a\");\n+        Files.createDirectories(subdir);\n+        assertTrue(Files.isDirectory(subdir), subdir + \" was expected to be a directory,\" +\n+                \" but wasn't\");\n+\n+        \/\/ create parents\n+        subdir = subdir.resolve(\"b\/c\/d\");\n+        Files.createDirectories(subdir);\n+        assertTrue(Files.isDirectory(subdir), subdir + \" was expected to be a directory,\" +\n+                \" but wasn't\");\n+\n+        \/\/ existing file is not a directory\n+        Path file = Files.createFile(tmpdir.resolve(\"x\"));\n+        try {\n+            Files.createDirectories(file);\n+            throw new RuntimeException(\"failure expected\");\n+        } catch (FileAlreadyExistsException x) { }\n+        try {\n+            Files.createDirectories(file.resolve(\"y\"));\n+            throw new RuntimeException(\"failure expected\");\n+        } catch (IOException x) { }\n+\n+        \/\/ the root directory always exists\n+        Path root = Path.of(\"\/\");\n+        Files.createDirectories(root);\n+        Files.createDirectories(root.toAbsolutePath());\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/Files\/CreateDirectories.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,3 +25,5 @@\n- * @bug 4313887 6838333 8005566 8032220 8215467 8255576\n- * @summary Unit test for miscellenous methods in java.nio.file.Files\n- * @library ..\n+ * @bug 4313887 6838333 8005566 8215467 8255576 8286160\n+ * @summary Unit test for miscellaneous methods in java.nio.file.Files\n+ * @library .. \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @run main Misc\n@@ -30,1 +32,14 @@\n-import java.nio.file.*;\n+import java.io.IOException;\n+import java.io.File;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.AclEntry;\n+import java.nio.file.attribute.AclEntryPermission;\n+import java.nio.file.attribute.AclEntryType;\n+import java.nio.file.attribute.AclFileAttributeView;\n+import java.nio.file.attribute.DosFileAttributeView;\n+import java.nio.file.attribute.UserPrincipal;\n+import java.util.List;\n+import jdk.test.lib.Platform;\n+\n@@ -33,3 +48,0 @@\n-import java.nio.file.attribute.*;\n-import java.io.IOException;\n-import java.util.*;\n@@ -42,1 +54,0 @@\n-            testCreateDirectories(dir);\n@@ -52,33 +63,0 @@\n-    \/**\n-     * Tests createDirectories\n-     *\/\n-    static void testCreateDirectories(Path tmpdir) throws IOException {\n-        \/\/ a no-op\n-        createDirectories(tmpdir);\n-\n-        \/\/ create one directory\n-        Path subdir = tmpdir.resolve(\"a\");\n-        createDirectories(subdir);\n-        assertTrue(exists(subdir));\n-\n-        \/\/ create parents\n-        subdir = subdir.resolve(\"b\/c\/d\");\n-        createDirectories(subdir);\n-        assertTrue(exists(subdir));\n-\n-        \/\/ existing file is not a directory\n-        Path file = createFile(tmpdir.resolve(\"x\"));\n-        try {\n-            createDirectories(file);\n-            throw new RuntimeException(\"failure expected\");\n-        } catch (FileAlreadyExistsException x) { }\n-        try {\n-            createDirectories(file.resolve(\"y\"));\n-            throw new RuntimeException(\"failure expected\");\n-        } catch (IOException x) { }\n-\n-        \/\/ the root directory always exists\n-        Path root = Paths.get(\"\/\");\n-        Files.createDirectories(root);\n-        Files.createDirectories(root.toAbsolutePath());\n-    }\n@@ -96,1 +74,1 @@\n-        if (System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n+        if (Platform.isWindows()) {\n@@ -289,0 +267,7 @@\n+            if (Platform.isWindows()) {\n+                Path pageFile = Path.of(\"C:\\\\pagefile.sys\");\n+                if (pageFile.toFile().exists()) {\n+                    System.out.printf(\"Check page file %s%n\", pageFile);\n+                    assertTrue(exists(pageFile));\n+                }\n+            }\n@@ -354,1 +339,1 @@\n-            if (System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n+            if (Platform.isWindows()) {\n@@ -384,1 +369,1 @@\n-        if (System.getProperty(\"os.name\").startsWith(\"Windows\"))\n+        if (Platform.isWindows())\n@@ -387,1 +372,1 @@\n-        Path passwd = Paths.get(\"\/etc\/passwd\");\n+        Path passwd = Path.of(\"\/etc\/passwd\");\n","filename":"test\/jdk\/java\/nio\/file\/Files\/Misc.java","additions":31,"deletions":46,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n- * @bug 4162583 7054918 8130181\n- * @library ..\/testlibrary\n+ * @bug 4162583 7054918 8130181 8028127\n+ * @library \/test\/lib ..\/testlibrary\n@@ -33,0 +33,2 @@\n+import jdk.test.lib.Asserts;\n+\n@@ -45,0 +47,1 @@\n+        var providersCountBefore = Security.getProviders().length;\n@@ -46,3 +49,4 @@\n-        for (int i=0; i < acc.length; i++)\n-            acc[i] = new AccessorThread(\"thread\"+i);\n-        for (int i=0; i < acc.length; i++)\n+        for (int i = 0; i < acc.length; i++) {\n+            acc[i] = new AccessorThread(\"thread\" + i);\n+        }\n+        for (int i = 0; i < acc.length; i++) {\n@@ -50,1 +54,2 @@\n-        for (int i=0; i < acc.length; i++)\n+        }\n+        for (int i = 0; i < acc.length; i++) {\n@@ -52,0 +57,3 @@\n+        }\n+        var providersCountAfter = Security.getProviders().length;\n+        Asserts.assertEquals(providersCountBefore, providersCountAfter);\n@@ -53,1 +61,0 @@\n-}\n@@ -55,1 +62,1 @@\n-class AccessorThread extends Thread {\n+    static class AccessorThread extends Thread {\n@@ -57,3 +64,3 @@\n-    public AccessorThread(String str) {\n-        super(str);\n-    }\n+        public AccessorThread(String str) {\n+            super(str);\n+        }\n@@ -61,4 +68,5 @@\n-    public void run() {\n-        Provider[] provs = new Provider[10];\n-        for (int i=0; i < provs.length; i++)\n-            provs[i] = new MyProvider(\"name\"+i, \"1\", \"test\");\n+        public void run() {\n+            Provider[] provs = new Provider[10];\n+            for (int i = 0; i < provs.length; i++) {\n+                provs[i] = new MyProvider(\"name\" + i, \"1\", \"test\");\n+            }\n@@ -66,4 +74,4 @@\n-        int rounds = 20;\n-        while (rounds-- > 0) {\n-            try {\n-                for (int i=0; i<provs.length; i++) {\n+            int rounds = 20;\n+            while (rounds-- > 0) {\n+                for (int i = 0; i < provs.length; i++) {\n+                    \/\/ Might install (>=0) or not (-1) if already installed\n@@ -71,0 +79,8 @@\n+                    Thread.yield();\n+                }\n+\n+                try {\n+                    Signature.getInstance(\"sigalg\");\n+                    Thread.yield();\n+                } catch (NoSuchAlgorithmException nsae) {\n+                    \/\/ All providers may have been deregistered.  Ok.\n@@ -72,3 +88,5 @@\n-                Signature sig = Signature.getInstance(\"sigalg\");\n-                for (int i=0; i<provs.length; i++) {\n-                    Security.removeProvider(\"name\"+i);\n+\n+                for (int i = 0; i < provs.length; i++) {\n+                    \/\/ Might or might not remove (silent return)\n+                    Security.removeProvider(\"name\" + i);\n+                    Thread.yield();\n@@ -76,2 +94,7 @@\n-                provs = Security.getProviders();\n-            } catch (NoSuchAlgorithmException nsae) {\n+            } \/\/ while\n+        }\n+\n+        public static final class MyProvider extends Provider {\n+            public MyProvider(String name, String version, String info) {\n+                super(name, version, info);\n+                put(\"Signature.sigalg\", SigImpl.class.getName());\n@@ -79,0 +102,3 @@\n+        }\n+\n+        public static final class SigImpl extends Signature {\n@@ -80,3 +106,2 @@\n-            try {\n-                Thread.sleep(5);\n-            } catch (InterruptedException ie) {\n+            public SigImpl() {\n+                super(null);\n@@ -84,3 +109,0 @@\n-        } \/\/ while\n-    }\n-}\n@@ -88,4 +110,37 @@\n-class MyProvider extends Provider {\n-    public MyProvider(String name, String version, String info) {\n-        super(name, version, info);\n-        put(\"Signature.sigalg\", \"sigimpl\");\n+            @Override\n+            protected void engineInitVerify(PublicKey publicKey) {\n+            }\n+\n+            @Override\n+            protected void engineInitSign(PrivateKey privateKey) {\n+            }\n+\n+            @Override\n+            protected void engineUpdate(byte b) {\n+            }\n+\n+            @Override\n+            protected void engineUpdate(byte[] b, int off, int len) {\n+            }\n+\n+            @Override\n+            protected byte[] engineSign() {\n+                return new byte[0];\n+            }\n+\n+            @Override\n+            protected boolean engineVerify(byte[] sigBytes) {\n+                return false;\n+            }\n+\n+            @Override\n+            protected void engineSetParameter(String param, Object value)\n+                    throws InvalidParameterException {\n+            }\n+\n+            @Override\n+            protected Object engineGetParameter(String param)\n+                    throws InvalidParameterException {\n+                return null;\n+            }\n+        }\n@@ -93,1 +148,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/security\/Security\/SynchronizedAccess.java","additions":91,"deletions":36,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,1 @@\n+import sun.security.util.Debug;\n@@ -70,1 +71,1 @@\n- * @bug 8074931\n+ * @bug 8074931 8296787\n@@ -198,0 +199,8 @@\n+\n+        \/\/ check serial number format\n+        String serialNum = Debug.toString(selector.getSerialNumber());\n+        String expected = \"38:df:82:b8\";\n+        if (!serialNum.equals(expected)) {\n+            throw new RuntimeException(\"Serial number toString format is incorrect. Got: \"\n+                + serialNum + \" Expected: \" + expected);\n+        }\n","filename":"test\/jdk\/java\/security\/cert\/X509CertSelectorTest.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+\n+\/**\n+ * HumanInputStream tries to act like a human sitting in front of a computer\n+ * terminal typing on the keyboard while a program is running.\n+ * <p>\n+ * The program may call InputStream.read() and BufferedReader.readLine() in\n+ * various places. a call to B.readLine() will try to buffer as much input as\n+ * possible. Thus, a trivial InputStream will find it impossible to feed\n+ * anything to I.read() after a B.readLine() call.\n+ * <p>\n+ * This is why HumanInputStream was created, which will only send a single line\n+ * to B.readLine(), no more, no less, and the next I.read() can have a chance\n+ * to read the exact character right after \"\\n\".\n+ *\n+ *\/\n+\n+public class HumanInputStream extends InputStream {\n+    byte[] src;\n+    int pos;\n+    int length;\n+    boolean inLine;\n+    int stopIt;\n+\n+    public HumanInputStream(String input) {\n+        src = input.getBytes();\n+        pos = 0;\n+        length = src.length;\n+        stopIt = 0;\n+        inLine = false;\n+    }\n+\n+    \/\/ the trick: when called through read(byte[], int, int),\n+    \/\/ return -1 twice after \"\\n\"\n+\n+    @Override public int read() throws IOException {\n+        int re;\n+        if(pos < length) {\n+            re = src[pos];\n+            if(inLine) {\n+                if(stopIt > 0) {\n+                    stopIt--;\n+                    re = -1;\n+                } else {\n+                    if(re == '\\n') {\n+                        stopIt = 2;\n+                    }\n+                    pos++;\n+                }\n+            } else {\n+                pos++;\n+            }\n+        } else {\n+            re = -1; \/\/throws new IOException(\"NO MORE TO READ\");\n+        }\n+        return re;\n+    }\n+    @Override public int read(byte[] buffer, int offset, int len) {\n+        inLine = true;\n+        try {\n+            return super.read(buffer, offset, len);\n+        } catch(Exception e) {\n+            throw new RuntimeException(\"HumanInputStream error\");\n+        } finally {\n+            inLine = false;\n+        }\n+    }\n+    @Override public int available() {\n+        if (pos < length) return 1;\n+        return 0;\n+    }\n+\n+    \/\/ test part\n+    static void assertTrue(boolean bool) {\n+        if (!bool)\n+            throw new RuntimeException();\n+    }\n+\n+    public static void test() throws Exception {\n+        class Tester {\n+            HumanInputStream is;\n+            BufferedReader reader;\n+            Tester(String s) {\n+                is = new HumanInputStream(s);\n+                reader = new BufferedReader(new InputStreamReader(is));\n+            }\n+\n+            \/\/ three kinds of test method\n+            \/\/ 1. read byte by byte from InputStream\n+            void testStreamReadOnce(int expection) throws Exception {\n+                assertTrue(is.read() == expection);\n+            }\n+            void testStreamReadMany(String expectation) throws Exception {\n+                char[] keys = expectation.toCharArray();\n+                for (char key : keys) {\n+                    assertTrue(is.read() == key);\n+                }\n+            }\n+            \/\/ 2. read a line with a newly created Reader\n+            void testReaderReadline(String expectation) throws Exception {\n+                String s = new BufferedReader(new InputStreamReader(is)).readLine();\n+                if(s == null) assertTrue(expectation == null);\n+                else assertTrue(s.equals(expectation));\n+            }\n+            \/\/ 3. read a line with the old Reader\n+            void testReaderReadline2(String expectation) throws Exception  {\n+                String s = reader.readLine();\n+                if(s == null) assertTrue(expectation == null);\n+                else assertTrue(s.equals(expectation));\n+            }\n+        }\n+\n+        Tester test;\n+\n+        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n+        test.testReaderReadline(\"111\");\n+        test.testReaderReadline(\"222\");\n+        test.testReaderReadline(\"\");\n+        test.testReaderReadline(\"444\");\n+        test.testReaderReadline(\"\");\n+        test.testReaderReadline(null);\n+\n+        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n+        test.testReaderReadline2(\"111\");\n+        test.testReaderReadline2(\"222\");\n+        test.testReaderReadline2(\"\");\n+        test.testReaderReadline2(\"444\");\n+        test.testReaderReadline2(\"\");\n+        test.testReaderReadline2(null);\n+\n+        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n+        test.testReaderReadline2(\"111\");\n+        test.testReaderReadline(\"222\");\n+        test.testReaderReadline2(\"\");\n+        test.testReaderReadline2(\"444\");\n+        test.testReaderReadline(\"\");\n+        test.testReaderReadline2(null);\n+\n+        test = new Tester(\"1\\n2\");\n+        test.testStreamReadMany(\"1\\n2\");\n+        test.testStreamReadOnce(-1);\n+\n+        test = new Tester(\"12\\n234\");\n+        test.testStreamReadOnce('1');\n+        test.testReaderReadline(\"2\");\n+        test.testStreamReadOnce('2');\n+        test.testReaderReadline2(\"34\");\n+        test.testReaderReadline2(null);\n+\n+        test = new Tester(\"changeit\\n\");\n+        test.testStreamReadMany(\"changeit\\n\");\n+        test.testReaderReadline(null);\n+\n+        test = new Tester(\"changeit\\nName\\nCountry\\nYes\\n\");\n+        test.testStreamReadMany(\"changeit\\n\");\n+        test.testReaderReadline(\"Name\");\n+        test.testReaderReadline(\"Country\");\n+        test.testReaderReadline(\"Yes\");\n+        test.testReaderReadline(null);\n+\n+        test = new Tester(\"Me\\nHere\\n\");\n+        test.testReaderReadline2(\"Me\");\n+        test.testReaderReadline2(\"Here\");\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/testlibrary\/HumanInputStream.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -595,1 +595,0 @@\n-            SystemTest.suite(),\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/JSR166TestCase.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * This file is available under and governed by the GNU General Public\n- * License version 2 only, as published by the Free Software Foundation.\n- * However, the following notice accompanied the original version of this\n- * file:\n- *\n- * Written by Doug Lea with assistance from members of JCP JSR-166\n- * Expert Group and released to the public domain, as explained at\n- * http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/\n- * Other contributors include Andrew Wright, Jeffrey Hayes,\n- * Pat Fisher, Mike Judd.\n- *\/\n-\n-import junit.framework.Test;\n-import junit.framework.TestSuite;\n-\n-public class SystemTest extends JSR166TestCase {\n-    public static void main(String[] args) {\n-        main(suite(), args);\n-    }\n-\n-    public static Test suite() {\n-        return new TestSuite(SystemTest.class);\n-    }\n-\n-    \/**\n-     * Worst case rounding for millisecs; set for 60 cycle millis clock.\n-     * This value might need to be changed on JVMs with coarser\n-     * System.currentTimeMillis clocks.\n-     *\/\n-    static final long MILLIS_ROUND = 17;\n-\n-    \/**\n-     * Nanos between readings of millis is no longer than millis (plus\n-     * possible rounding), and vice versa.\n-     * This shows only that nano timing not (much) worse than milli.\n-     *\/\n-    public void testNanoTime() throws InterruptedException {\n-        long m0 = System.currentTimeMillis();\n-        long n0 = System.nanoTime();\n-        Thread.sleep(1);\n-        long m1 = System.currentTimeMillis();\n-        long n1 = System.nanoTime();\n-        Thread.sleep(50);       \/\/ avoid possibly scaled SHORT_DELAY_MS\n-        long m2 = System.currentTimeMillis();\n-        long n2 = System.nanoTime();\n-        Thread.sleep(1);\n-        long m3 = System.currentTimeMillis();\n-        long n3 = System.nanoTime();\n-        assertTrue((n2 - n1) \/ 1_000_000 <= m3 - m0 + MILLIS_ROUND);\n-        assertTrue(m2 - m1 <= (n3 - n0) \/ 1_000_000 + MILLIS_ROUND);\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/SystemTest.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8253952\n@@ -27,1 +28,1 @@\n- * @run main\/othervm CopyZipFile\n+ * @run junit CopyZipFile\n@@ -30,5 +31,5 @@\n-import java.io.File;\n-import java.io.ByteArrayOutputStream;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n@@ -37,0 +38,3 @@\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -40,7 +44,3 @@\n-import java.util.zip.CRC32;\n-import java.util.zip.Deflater;\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipException;\n-import java.util.zip.ZipFile;\n-import java.util.zip.ZipInputStream;\n-import java.util.zip.ZipOutputStream;\n+import java.util.zip.*;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -49,2 +49,4 @@\n-    private static final String ZIP_FILE = \"first.zip\";\n-    private static final String TEST_STRING = \"TestTestTest\";\n+    \/\/ ZIP file created in this test\n+    private Path zip = Path.of(\"first.zip\");\n+    \/\/ The content to put in each entry\n+    private static final byte[] TEST_STRING = \"TestTestTest\".getBytes(StandardCharsets.UTF_8);\n@@ -52,4 +54,14 @@\n-    private static void createZip(String zipFile) throws Exception {\n-        File f = new File(zipFile);\n-        f.deleteOnExit();\n-        try (OutputStream os = new FileOutputStream(f);\n+    \/**\n+     * Create the sample ZIP file used in this test, including a STORED entry\n+     * and DEFLATE entries with various compression levels.\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @BeforeEach\n+    public void createZip() throws IOException {\n+        \/\/ By default, ZipOutputStream creates zip files with Local File Headers\n+        \/\/ without size, compressed size and crc values and an extra Data\n+        \/\/ Descriptor (see https:\/\/en.wikipedia.org\/wiki\/Zip_(file_format)\n+        \/\/ after the data belonging to that entry with these values if in the\n+        \/\/ corresponding ZipEntry one of the size, compressedSize or crc fields is\n+        \/\/ equal to '-1' (which is the default for newly created ZipEntries).\n+        try (OutputStream os = Files.newOutputStream(zip) ;\n@@ -58,3 +70,4 @@\n-            zos.putNextEntry(new ZipEntry(\"test1.txt\"));\n-            zos.write(TEST_STRING.getBytes());\n-            zos.closeEntry();\n+            zos.setLevel(Deflater.DEFAULT_COMPRESSION);\n+            zos.putNextEntry(new ZipEntry(\"DEFAULT_COMPRESSION.txt\"));\n+            zos.write(TEST_STRING);\n+\n@@ -63,4 +76,3 @@\n-            ZipEntry ze = new ZipEntry(\"test2.txt\");\n-            int length = TEST_STRING.length();\n-            ze.setSize(length);\n-            ze.setCompressedSize(length);\n+            ZipEntry ze = new ZipEntry(\"STORED.txt\");\n+            ze.setSize(TEST_STRING.length);\n+            ze.setCompressedSize(TEST_STRING.length);\n@@ -68,1 +80,1 @@\n-            crc.update(TEST_STRING.getBytes(\"utf8\"), 0, length);\n+            crc.update(TEST_STRING);\n@@ -71,1 +83,2 @@\n-            zos.write(TEST_STRING.getBytes());\n+            zos.write(TEST_STRING);\n+\n@@ -75,2 +88,3 @@\n-            zos.putNextEntry(new ZipEntry(\"test3.txt\"));\n-            zos.write(TEST_STRING.getBytes());\n+            zos.putNextEntry(new ZipEntry(\"NO_COMPRESSION.txt\"));\n+            zos.write(TEST_STRING);\n+\n@@ -79,2 +93,3 @@\n-            zos.putNextEntry(new ZipEntry(\"test4.txt\"));\n-            zos.write(TEST_STRING.getBytes());\n+            zos.putNextEntry(new ZipEntry(\"BEST_SPEED.txt\"));\n+            zos.write(TEST_STRING);\n+\n@@ -83,2 +98,2 @@\n-            zos.putNextEntry(new ZipEntry(\"test5.txt\"));\n-            zos.write(TEST_STRING.getBytes());\n+            zos.putNextEntry(new ZipEntry(\"BEST_COMPRESSION.txt\"));\n+            zos.write(TEST_STRING);\n@@ -88,22 +103,26 @@\n-    public static void main(String args[]) throws Exception {\n-        \/\/ By default, ZipOutputStream creates zip files with Local File Headers\n-        \/\/ without size, compressedSize and crc values and an extra Data\n-        \/\/ Descriptor (see https:\/\/en.wikipedia.org\/wiki\/Zip_(file_format)\n-        \/\/ after the data belonging to that entry with these values if in the\n-        \/\/ corresponding ZipEntry one of the size, compressedSize or crc fields is\n-        \/\/ equal to '-1' (which is the default for newly created ZipEntries).\n-        createZip(ZIP_FILE);\n-\n-        \/\/ Now read all the entries of the newly generated zip file with a ZipInputStream\n-        \/\/ and copy them to a new zip file with the help of a ZipOutputStream.\n-        \/\/ This only works reliably because the generated zip file has no values for the\n-        \/\/ size, compressedSize and crc values of a zip entry in the local file header and\n-        \/\/ therefore the ZipEntry objects created by ZipOutputStream.getNextEntry() will have\n-        \/\/ all these fields set to '-1'.\n-        ZipEntry entry;\n-        byte[] buf = new byte[512];\n-        try (InputStream is = new FileInputStream(ZIP_FILE);\n-             ZipInputStream zis = new ZipInputStream(is);\n-             OutputStream os = new ByteArrayOutputStream();\n-             ZipOutputStream zos = new ZipOutputStream(os)) {\n-            while((entry = zis.getNextEntry())!=null) {\n+    \/**\n+     * Delete the ZIP file produced by this test\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * Read all entries using ZipInputStream.getNextEntry and copy them\n+     * to a new zip file using ZipOutputStream.putNextEntry. This only works\n+     * reliably because the input zip file has no values for the size, compressedSize\n+     * and crc values of streamed zip entries in the local file header and\n+     * therefore the ZipEntry objects created by ZipOutputStream.getNextEntry\n+     * will have all these fields set to '-1'.\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void copyFromZipInputStreamToZipOutputStream() throws IOException {\n+\n+        try (ZipInputStream zis = new ZipInputStream(Files.newInputStream(zip));\n+             ZipOutputStream zos = new ZipOutputStream(OutputStream.nullOutputStream())) {\n+            ZipEntry entry;\n+            while ((entry = zis.getNextEntry()) != null) {\n@@ -114,5 +133,7 @@\n-                    String.format(\"name=%s, clen=%d, len=%d, crc=%d\",\n-                                  entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n-                if (entry.getMethod() == ZipEntry.DEFLATED &&\n-                    (entry.getCompressedSize() != -1 || entry.getSize() != -1 || entry.getCrc() != -1)) {\n-                    throw new Exception(\"'size', 'compressedSize' and 'crc' shouldn't be initialized at this point.\");\n+                        String.format(\"name=%s, clen=%d, len=%d, crc=%d\",\n+                                entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n+                if (entry.getMethod() == ZipEntry.DEFLATED) {\n+                    \/\/ Expect size, compressed size and crc to not be initialized at this point\n+                    assertEquals(-1, entry.getCompressedSize());\n+                    assertEquals(-1, entry.getSize());\n+                    assertEquals(-1, entry.getCrc());\n@@ -127,5 +148,6 @@\n-                    String.format(\"name=%s, clen=%d, len=%d, crc=%d\\n\",\n-                                  entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n-                if (entry.getCompressedSize() == -1 || entry.getSize() == -1) {\n-                    throw new Exception(\"'size' and 'compressedSize' must be initialized at this point.\");\n-                }\n+                        String.format(\"name=%s, clen=%d, len=%d, crc=%d\\n\",\n+                                entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n+                \/\/ Expect size, compressed size and crc to be initialized at this point\n+                assertNotEquals(-1, entry.getCompressedSize());\n+                assertNotEquals(-1, entry.getSize());\n+                assertNotEquals(-1, entry.getCrc());\n@@ -134,0 +156,1 @@\n+    }\n@@ -135,15 +158,21 @@\n-        \/\/ Now we read all the entries of the initially generated zip file with the help\n-        \/\/ of the ZipFile class. The ZipFile class reads all the zip entries from the Central\n-        \/\/ Directory which must have accurate information for size, compressedSize and crc.\n-        \/\/ This means that all ZipEntry objects returned from ZipFile will have correct\n-        \/\/ settings for these fields.\n-        \/\/ If the compression level was different in the initial zip file (which we can't find\n-        \/\/ out any more now because the zip file format doesn't record this information) the\n-        \/\/ size of the re-compressed entry we are writing to the ZipOutputStream might differ\n-        \/\/ from the original compressed size recorded in the ZipEntry. This would result in an\n-        \/\/ \"invalid entry compressed size\" ZipException if ZipOutputStream wouldn't ignore\n-        \/\/ the implicitely set compressed size attribute of ZipEntries read from a ZipFile\n-        \/\/ or ZipInputStream.\n-        try (OutputStream os = new ByteArrayOutputStream();\n-             ZipOutputStream zos = new ZipOutputStream(os);\n-             ZipFile zf = new ZipFile(ZIP_FILE)) {\n+    \/**\n+     * Read all entries using the ZipFile class and copy them to a new zip file\n+     * using ZipOutputStream.putNextEntry.\n+     * The ZipFile class reads all the zip entries from the Central\n+     * Directory, which has accurate information for size, compressedSize and crc.\n+     * This means that all ZipEntry objects returned from ZipFile will have correct\n+     * settings for these fields.\n+     * If the compression level was different in the input zip file (which we can't know\n+     * because the zip file format doesn't record this information), the\n+     * size of the re-compressed entry we are writing to the ZipOutputStream might differ\n+     * from the original compressed size recorded in the ZipEntry. This would result in an\n+     * \"invalid entry compressed size\" ZipException if ZipOutputStream wouldn't ignore\n+     * the implicitely set compressed size attribute of ZipEntries read from a ZipFile\n+     * or ZipInputStream.\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void copyFromZipFileToZipOutputStream() throws IOException {\n+        try (ZipOutputStream zos = new ZipOutputStream(OutputStream.nullOutputStream());\n+             ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry entry;\n@@ -157,4 +186,5 @@\n-                if (entry.getCompressedSize() == -1 || entry.getSize() == -1) {\n-                    throw new Exception(\"'size' and 'compressedSize' must be initialized at this point.\");\n-                }\n-                InputStream is = zf.getInputStream(entry);\n+                \/\/ Expect size, compressed size and crc to be initialized at this point\n+                assertNotEquals(-1, entry.getCompressedSize());\n+                assertNotEquals(-1, entry.getSize());\n+                assertNotEquals(-1, entry.getCrc());\n+\n@@ -162,1 +192,3 @@\n-                is.transferTo(zos);\n+                try (InputStream is = zf.getInputStream(entry)) {\n+                    is.transferTo(zos);\n+                }\n@@ -166,0 +198,17 @@\n+    }\n+\n+    \/**\n+     * If the compressed size is set explicitly using ZipEntry.setCompressedSize(),\n+     * then the entry will be restreamed with a data descriptor and the compressed size\n+     * recomputed. If the source compression level was different from the target compression\n+     * level, the compressed sizes may differ and a ZipException will be thrown\n+     * when the entry is closed in ZipOutputStream.closeEntry\n+     *\n+     * @throws IOException if an unexpected IOException is thrown\n+     *\/\n+    @Test\n+    public void explicitCompressedSizeWithDifferentCompressionLevels() throws IOException {\n+        try (ZipOutputStream zos = new ZipOutputStream(OutputStream.nullOutputStream());\n+             ZipFile zf = new ZipFile(zip.toFile())) {\n+            \/\/ Be explicit about the default compression level\n+            zos.setLevel(Deflater.DEFAULT_COMPRESSION);\n@@ -167,5 +216,0 @@\n-        \/\/ The compressed size attribute of a ZipEntry shouldn't be ignored if it was set\n-        \/\/ explicitely by calling ZipEntry.setCpompressedSize()\n-        try (OutputStream os = new ByteArrayOutputStream();\n-             ZipOutputStream zos = new ZipOutputStream(os);\n-             ZipFile zf = new ZipFile(ZIP_FILE)) {\n@@ -174,4 +218,8 @@\n-                try {\n-                    entry = entries.nextElement();\n-                    entry.setCompressedSize(entry.getCompressedSize());\n-                    InputStream is = zf.getInputStream(entry);\n+                ZipEntry entry = entries.nextElement();\n+\n+                \/\/ Explicitly setting the compressed size will disable data descriptors\n+                \/\/ and enable validation that the compressed size in the ZipEntry matches the\n+                \/\/ actual compressed size written by ZipOutputStream\n+                entry.setCompressedSize(entry.getCompressedSize());\n+\n+                try (InputStream is = zf.getInputStream(entry)) {\n@@ -180,9 +228,35 @@\n-                    zos.closeEntry();\n-                    if (\"test3.txt\".equals(entry.getName())) {\n-                        throw new Exception(\n-                            \"Should throw a ZipException if ZipEntry.setCpompressedSize() was called.\");\n-                    }\n-                } catch (ZipException ze) {\n-                    if (\"test1.txt\".equals(entry.getName()) || \"test2.txt\".equals(entry.getName())) {\n-                        throw new Exception(\n-                            \"Shouldn't throw a ZipExcpetion for STORED files or files compressed with DEFAULT_COMPRESSION\");\n+                    \/\/ Some compression levels lead to unexpected recompressed sizes when closing the entry\n+                    switch (entry.getName()) {\n+                        case \"DEFAULT_COMPRESSION.txt\" -> {\n+                            \/\/ DEFAULT_COMPRESSION matches expected size\n+                            zos.closeEntry();\n+                        }\n+                        case \"STORED.txt\" -> {\n+                            \/\/ STORED should not throw\n+                            zos.closeEntry();\n+                        }\n+                        case \"NO_COMPRESSION.txt\", \"BEST_SPEED.txt\" -> {\n+                            \/\/ NO_COMPRESSION and BEST_SPEED should lead to an unexpected recompressed size\n+                            ZipException ze = assertThrows(ZipException.class, () -> {\n+                                zos.closeEntry();\n+                            });\n+\n+                            \/\/ Hack to fix and close the offending zip entry with the correct recompressed size.\n+                            \/\/ The exception message is something like:\n+                            \/\/   \"invalid entry compressed size (expected 12 but got 7 bytes)\"\n+                            \/\/ and we need to extract the second integer.\n+                            Pattern cSize = Pattern.compile(\"\\\\d+\");\n+                            Matcher m = cSize.matcher(ze.getMessage());\n+                            m.find();\n+                            m.find();\n+                            entry.setCompressedSize(Integer.parseInt(m.group()));\n+                            zos.closeEntry();\n+                        }\n+                        case \"BEST_COMPRESSION.txt\" -> {\n+                            \/\/ BEST_COMPRESSION produces the same compressed\n+                            \/\/ size as DEFAULT_COMPRESSION for sample content\n+                            zos.closeEntry();\n+                        }\n+                        default -> {\n+                            throw new IllegalArgumentException(\"Unexpected entry \" + entry.getName());\n+                        }\n@@ -190,9 +264,0 @@\n-                    \/\/ Hack to fix and close the offending zip entry with the correct compressed size.\n-                    \/\/ The exception message is something like:\n-                    \/\/   \"invalid entry compressed size (expected 12 but got 7 bytes)\"\n-                    \/\/ and we need to extract the second integer.\n-                    Pattern cSize = Pattern.compile(\"\\\\d+\");\n-                    Matcher m = cSize.matcher(ze.getMessage());\n-                    m.find();\n-                    m.find();\n-                    entry.setCompressedSize(Integer.parseInt(m.group()));\n","filename":"test\/jdk\/java\/util\/zip\/CopyZipFile.java","additions":178,"deletions":113,"binary":false,"changes":291,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -98,3 +98,3 @@\n-            System.out.printf(\"Deflater::getTotalOut:%s, Deflater::getAdler: %s,\" +\n-                            \" compressed length: %s%n\", deflater.getTotalOut(),\n-                    deflater.getTotalOut(), compressedDataLength);\n+            System.out.printf(\"Deflater::getBytesWritten:%d, Deflater::getAdler: %d,\" +\n+                            \" compressed length: %d%n\", deflater.getBytesWritten(),\n+                    deflater.getAdler(), compressedDataLength);\n@@ -115,1 +115,1 @@\n-            System.out.printf(\"Inflater::getAdler:%s, length: %s%n\",\n+            System.out.printf(\"Inflater::getAdler:%d, length: %d%n\",\n@@ -146,3 +146,3 @@\n-            System.out.printf(\"Deflater::getTotalOut:%s, Deflater::getAdler: %s,\" +\n-                            \" compressed length: %s%n\", deflater.getTotalOut(),\n-                    deflater.getTotalOut(), compressedDataLength);\n+            System.out.printf(\"Deflater::getBytesWritten:%d, Deflater::getAdler: %d,\" +\n+                            \" compressed length: %d%n\", deflater.getBytesWritten(),\n+                    deflater.getAdler(), compressedDataLength);\n@@ -163,1 +163,1 @@\n-            System.out.printf(\"Inflater::getAdler:%s, length: %s%n\",\n+            System.out.printf(\"Inflater::getAdler:%d, length: %d%n\",\n@@ -200,3 +200,3 @@\n-            System.out.printf(\"Deflater::getTotalOut:%s, Deflater::getAdler: %s,\" +\n-                            \" compressed length: %s%n\", deflater.getTotalOut(),\n-                    deflater.getTotalOut(), compressedDataLength);\n+            System.out.printf(\"Deflater::getBytesWritten:%d, Deflater::getAdler: %d,\" +\n+                            \" compressed length: %d%n\", deflater.getBytesWritten(),\n+                    deflater.getAdler(), compressedDataLength);\n@@ -217,1 +217,1 @@\n-            System.out.printf(\"Inflater::getAdler:%s, length: %s%n\",\n+            System.out.printf(\"Inflater::getAdler:%d, length: %d%n\",\n","filename":"test\/jdk\/java\/util\/zip\/DeflaterDictionaryTests.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.zip.*;\n-import java.io.File;\n-\n-public class Available\n-{\n-    public static void main (String argv[]) throws Exception {\n-        ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\"),\n-                                          \"input.jar\"));\n-        ZipEntry e = zf.getEntry(\"ReleaseInflater.java\");\n-        if (e.getSize() != zf.getInputStream(e).available()) {\n-            throw new Exception(\"wrong return value of available\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/Available.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8272746\n+ * @summary Verify that ZipFile rejects a ZIP with a CEN size which does not fit in a Java byte array\n+ * @run junit CenSizeTooLarge\n+ *\/\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class CenSizeTooLarge {\n+    \/\/ Maximum allowed CEN size allowed by the ZipFile implementation\n+    static final int MAX_CEN_SIZE = Integer.MAX_VALUE - ZipFile.ENDHDR - 1;\n+\n+    \/**\n+     * From the APPNOTE.txt specification:\n+     *    4.4.10 file name length: (2 bytes)\n+     *    4.4.11 extra field length: (2 bytes)\n+     *    4.4.12 file comment length: (2 bytes)\n+     *\n+     *        The length of the file name, extra field, and comment\n+     *        fields respectively.  The combined length of any\n+     *        directory record and these three fields SHOULD NOT\n+     *        generally exceed 65,535 bytes.\n+     *\n+     *  Since ZipOutputStream does not enforce the 'combined length' clause,\n+     *  we simply use 65,535 (0xFFFF) for the purpose of this test.\n+     *\/\n+    static final int MAX_EXTRA_FIELD_SIZE = 65_535;\n+\n+    \/\/ Data size (unsigned short)\n+    \/\/ Field size minus the leading header 'tag' and 'data size' fields (2 bytes each)\n+    static final short MAX_DATA_SIZE = (short) (MAX_EXTRA_FIELD_SIZE - 2 * Short.BYTES);\n+\n+    \/\/ Tag for the 'unknown' field type, specified in APPNOTE.txt 'Third party mappings'\n+    static final short UNKNOWN_ZIP_TAG = (short) 0x9902;\n+\n+    \/\/ Entry names produced in this test are fixed-length\n+    public static final int NAME_LENGTH = 10;\n+\n+    \/\/ Use a shared LocalDateTime on all entries to save processing time\n+    static final LocalDateTime TIME_LOCAL = LocalDateTime.now();\n+\n+    \/\/ The size of one CEN header, including the name and the extra field\n+    static final int CEN_HEADER_SIZE = ZipFile.CENHDR + NAME_LENGTH + MAX_EXTRA_FIELD_SIZE;\n+\n+    \/\/ The number of entries needed to exceed the MAX_CEN_SIZE\n+    static final int NUM_ENTRIES = (MAX_CEN_SIZE \/ CEN_HEADER_SIZE) + 1;\n+\n+    \/\/ Helps SparseOutputStream detect write of the last CEN entry\n+    private static final String LAST_CEN_COMMENT = \"LastCEN\";\n+    private static final byte[] LAST_CEN_COMMENT_BYTES = LAST_CEN_COMMENT.getBytes(StandardCharsets.UTF_8);\n+\n+    \/\/ Expected ZipException message when the CEN does not fit in a Java byte array\n+    private static final String CEN_TOO_LARGE_MESSAGE = \"invalid END header (central directory size too large)\";\n+\n+    \/\/ Zip file to create for testing\n+    private File hugeZipFile;\n+\n+    \/**\n+     * Create a zip file with a CEN size which does not fit within a Java byte array\n+     *\/\n+    @Before\n+    public void setup() throws IOException {\n+        hugeZipFile = new File(\"cen-too-large.zip\");\n+        hugeZipFile.deleteOnExit();\n+\n+        try (OutputStream out = new SparseOutputStream(new FileOutputStream(hugeZipFile));\n+             ZipOutputStream zip = new ZipOutputStream(out)) {\n+\n+            \/\/ Keep track of entries so we can update extra data before the CEN is written\n+            ZipEntry[] entries = new ZipEntry[NUM_ENTRIES];\n+\n+            \/\/ Add entries until MAX_CEN_SIZE is reached\n+            for (int i = 0; i < NUM_ENTRIES; i++) {\n+                \/\/ Create a fixed-length name for the entry\n+                String name = Integer.toString(i);\n+                name = \"0\".repeat(NAME_LENGTH - name.length()) + name;\n+\n+                \/\/ Create and track the entry\n+                ZipEntry entry = entries[i] = new ZipEntry(name);\n+\n+                \/\/ Use STORED for faster processing\n+                entry.setMethod(ZipEntry.STORED);\n+                entry.setSize(0);\n+                entry.setCrc(0);\n+\n+                \/\/ Set the time\/date field for faster processing\n+                entry.setTimeLocal(TIME_LOCAL);\n+\n+                if (i == NUM_ENTRIES -1) {\n+                    \/\/ Help SparseOutputStream detect the last CEN entry write\n+                    entry.setComment(LAST_CEN_COMMENT);\n+                }\n+                \/\/ Add the entry\n+                zip.putNextEntry(entry);\n+\n+\n+            }\n+            \/\/ Finish writing the last entry\n+            zip.closeEntry();\n+\n+            \/\/ Before the CEN headers are written, set the extra data on each entry\n+            byte[] extra = makeLargeExtraField();\n+            for (ZipEntry entry : entries) {\n+                entry.setExtra(extra);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Validates that a ZipException is thrown with the expected message when\n+     * the ZipFile is initialized with a ZIP whose CEN exeeds {@link #MAX_CEN_SIZE}\n+     *\/\n+    @Test\n+    public void centralDirectoryTooLargeToFitInByteArray() {\n+        ZipException ex = assertThrows(ZipException.class, () -> new ZipFile(hugeZipFile));\n+        assertEquals(CEN_TOO_LARGE_MESSAGE, ex.getMessage());\n+    }\n+\n+    \/**\n+     * We can reduce the number of written CEN headers by making each CEN header maximally large.\n+     * We do this by adding the extra field produced by this method to each CEN header.\n+     * <p>\n+     * The structure of an extra field is as follows:\n+     * <p>\n+     * Header ID  (Two bytes, describes the type of the field, also called 'tag')\n+     * Data Size  (Two byte short)\n+     * Data Block (Contents depend on field type)\n+     *\/\n+    private byte[] makeLargeExtraField() {\n+        \/\/ Make a maximally sized extra field\n+        byte[] extra = new byte[MAX_EXTRA_FIELD_SIZE];\n+        \/\/ Little-endian ByteBuffer for updating the header fields\n+        ByteBuffer buffer = ByteBuffer.wrap(extra).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        \/\/ We use the 'unknown' tag, specified in APPNOTE.TXT, 4.6.1 Third party mappings'\n+        buffer.putShort(UNKNOWN_ZIP_TAG);\n+\n+        \/\/ Size of the actual (empty) data\n+        buffer.putShort(MAX_DATA_SIZE);\n+        return extra;\n+    }\n+\n+    \/**\n+     * By writing sparse 'holes' until the last CEN is detected, we can save disk space\n+     * used by this test from ~2GB to ~4K. Instances of this class should be passed\n+     * directly to the ZipOutputStream constructor, without any buffering. Otherwise,\n+     * writes from ZipOutputStream may not be detected correctly.\n+     *\/\n+    private static class SparseOutputStream extends FilterOutputStream {\n+        private final FileChannel channel;\n+        private boolean sparse = true; \/\/ True until the last CEN is written\n+        private long position = 0;\n+\n+        public SparseOutputStream(FileOutputStream fos) {\n+            super(fos);\n+            this.channel = fos.getChannel();\n+        }\n+\n+        @Override\n+        public void write(byte[] b, int off, int len) throws IOException {\n+            position += len;\n+            if (sparse) {\n+                \/\/ Until finding the last CEN, we don't actually write anything,\n+                \/\/ but instead simply advance the position, creating a sparse file\n+                channel.position(position);\n+                \/\/ Check for last CEN record\n+                if (Arrays.equals(LAST_CEN_COMMENT_BYTES, 0, LAST_CEN_COMMENT_BYTES.length, b, off, len)) {\n+                    \/\/ From here on, write actual bytes\n+                    sparse = false;\n+                }\n+            } else {\n+                \/\/ Regular write\n+                out.write(b, off, len);\n+            }\n+        }\n+\n+        @Override\n+        public void write(int b) throws IOException {\n+            position++;\n+            if (sparse) {\n+                channel.position(position);\n+            } else {\n+                out.write(b);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/CenSizeTooLarge.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test 1.1 99\/06\/01\n-   @bug 4239446\n-   @summary Make sure the ZipEntry fields are correct.\n- *\/\n-\n-import java.io.*;\n-import java.util.zip.*;\n-\n-public class CopyJar {\n-    public static void main(String args[]) throws Exception {\n-        try (ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\", \".\"),\n-                                               \"input.jar\"))) {\n-            ZipEntry ze = zf.getEntry(\"ReleaseInflater.java\");\n-            ZipOutputStream zos = new ZipOutputStream(new ByteArrayOutputStream());\n-            InputStream in = zf.getInputStream(ze);\n-            byte[] b = new byte[128];\n-            int n;\n-            zos.putNextEntry(ze);\n-            while((n = in.read(b)) != -1) {\n-                zos.write(b, 0, n);\n-            }\n-            zos.close();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/CopyJar.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n-   @bug 4290060\n-   @summary Check if the zip file is closed before access any\n-            elements in the Enumeration.\n- *\/\n-\n-import java.io.*;\n-import java.util.zip.*;\n-import java.util.Enumeration;\n-\n-public class EnumAfterClose {\n-    public static void main(String args[]) throws Exception {\n-        Enumeration e;\n-        try (ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\", \".\"),\n-                                               \"input.zip\"))) {\n-            e = zf.entries();\n-        }\n-        \/\/ ensure that the ZipFile is closed before checking the Enumeration\n-        try {\n-            if (e.hasMoreElements()) {\n-                ZipEntry ze = (ZipEntry)e.nextElement();\n-            }\n-        } catch (IllegalStateException ie) {\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/EnumAfterClose.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+   @bug 4290060\n+   @summary Check if the zip file is closed before access any\n+            elements in the Enumeration.\n+   @run junit EnumerateAfterClose\n+ *\/\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Enumeration;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class EnumerateAfterClose {\n+\n+    \/\/ ZIP file used in this test\n+    private Path zip = Path.of(\"enum-after-close.zip\");\n+\n+    \/**\n+     * Create a sample ZIP file for use by this test\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @BeforeEach\n+    public void setUp() throws IOException {\n+        try (OutputStream out = Files.newOutputStream(zip);\n+             ZipOutputStream zo = new ZipOutputStream(out)) {\n+            zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+            zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+        }\n+    }\n+\n+    \/**\n+     * Delete the ZIP file produced by this test\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * Attempting to using a ZipEntry Enumeration after its backing\n+     * ZipFile is closed should throw IllegalStateException.\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void enumeratingAfterCloseShouldThrowISE() throws IOException {\n+        \/\/ Retain a reference to an enumeration backed by a closed ZipFile\n+        Enumeration e;\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            e = zf.entries();\n+        }\n+        \/\/ Using the enumeration after the ZipFile is closed should throw ISE\n+        assertThrows(IllegalStateException.class, () -> {\n+            if (e.hasMoreElements()) {\n+                ZipEntry ze = (ZipEntry)e.nextElement();\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/EnumerateAfterClose.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+   @run junit FinalizeInflater\n@@ -29,2 +30,4 @@\n-import java.io.File;\n-import java.io.InputStream;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n@@ -32,0 +35,5 @@\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -34,0 +42,1 @@\n+import java.util.zip.ZipOutputStream;\n@@ -37,4 +46,39 @@\n-    public static void main(String[] args) throws Throwable {\n-        try (ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\", \".\"), \"input.zip\")))\n-        {\n-            ZipEntry ze = zf.getEntry(\"ReadZip.java\");\n+    \/\/ ZIP file produced by this test\n+    private Path zip = Path.of(\"finalize-inflater.zip\");\n+\n+    \/**\n+     * Create the sample ZIP used in this test\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @BeforeEach\n+    public void setUp() throws IOException {\n+        try (OutputStream out = Files.newOutputStream(zip);\n+             ZipOutputStream zo = new ZipOutputStream(out)) {\n+            zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+            byte[] hello = \"hello\".getBytes(StandardCharsets.UTF_8);\n+            for (int i = 0; i < 100; i++) {\n+                zo.write(hello);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Delete the ZIP file produced by this test\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * A cached Inflater should not be made invalid by finalization\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void shouldNotFinalizeInflaterInPool() throws IOException {\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry ze = zf.getEntry(\"file.txt\");\n@@ -54,6 +98,1 @@\n-        byte[] buffer = new byte[32];\n-        try {\n-            while(is.read(buffer)>0){}\n-        } catch (IOException ioe) {\n-            ioe.printStackTrace();\n-        }\n+        is.readAllBytes();\n@@ -62,1 +101,1 @@\n-    static class Wrapper{\n+    static class Wrapper {\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/FinalizeInflater.java","additions":53,"deletions":14,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n-   @bug 4206838\n-   @summary getEntry() will search for a directory\n-            even without an ending '\/'.\n- *\/\n-\n-import java.io.*;\n-import java.util.zip.*;\n-\n-public class GetDirEntry {\n-    public static void main(String args[]) throws Exception {\n-        try (ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\", \".\"),\n-                                               \"input.jar\"))) {\n-            ZipEntry ze = zf.getEntry(\"META-INF\");\n-            if (ze == null) {\n-                throw new Exception(\"failed to find a directory entry\");\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/GetDirEntry.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n-   @bug 4528128 6846616\n-   @summary Test if reading InputStream of a closed ZipFile crashes VM\n-   @author kladko\n-   *\/\n-\n-\n-import java.util.zip.*;\n-import java.io.*;\n-import java.util.*;\n-\n-public class ReadAfterClose {\n-    public static void main(String[] argv) throws Exception {\n-        InputStream in;\n-        try (ZipFile zf = new ZipFile(\n-                 new File(System.getProperty(\"test.src\",\".\"),\"crash.jar\"))) {\n-            ZipEntry zent = zf.getEntry(\"Test.java\");\n-            in = zf.getInputStream(zent);\n-        }\n-        \/\/ ensure zf is closed at this point\n-        try {\n-            in.read();\n-        } catch (IOException e) {\n-            return;\n-        }\n-        throw new Exception(\"Test failed.\");\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ReadAfterClose.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-   @bug 4241361 4842702 4985614 6646605 5032358 6923692 6233323 8144977 8186464\n+   @bug 4241361 4842702 4985614 6646605 5032358 6923692 6233323 8144977 8186464 4401122 8322830\n@@ -27,1 +27,0 @@\n-   @key randomness\n@@ -29,0 +28,1 @@\n+   @run junit ReadZip\n@@ -31,1 +31,7 @@\n-import java.io.*;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n@@ -33,9 +39,4 @@\n-import java.nio.file.Files;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.NoSuchFileException;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n-import java.util.List;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.*;\n+import java.util.Collections;\n+import java.util.HexFormat;\n@@ -43,1 +44,4 @@\n-import java.util.zip.*;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n@@ -46,0 +50,1 @@\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -48,5 +53,20 @@\n-    private static void unreached (Object o)\n-        throws Exception\n-    {\n-        \/\/ Should never get here\n-        throw new Exception (\"Expected exception was not thrown\");\n+\n+    \/\/ ZIP file produced during tests\n+    private Path zip = Path.of(\"read-zip.zip\");\n+\n+    \/**\n+     * Create a sample ZIP file for use by tests\n+     * @param name name of the ZIP file to create\n+     * @return a sample ZIP file\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    private Path createZip(String name) throws IOException {\n+        Path zip = Path.of(name);\n+\n+        try (OutputStream out = Files.newOutputStream(zip);\n+             ZipOutputStream zo = new ZipOutputStream(out)) {\n+            zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+            zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+        }\n+\n+        return zip;\n@@ -55,6 +75,8 @@\n-    public static void main(String args[]) throws Exception {\n-        try (ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\", \".\"),\n-                                               \"input.zip\"))) {\n-            \/\/ Make sure we throw NPE on null objects\n-            try { unreached (zf.getEntry(null)); }\n-            catch (NullPointerException e) {}\n+    \/**\n+     * Delete the ZIP file produced after each test method\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n@@ -62,2 +84,9 @@\n-            try { unreached (zf.getInputStream(null)); }\n-            catch (NullPointerException e) {}\n+    \/**\n+     * Make sure we throw NPE when calling getEntry or getInputStream with null params\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void nullPointerExceptionOnNullParams() throws IOException {\n+        zip = createZip(\"null-params.zip\");\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n@@ -65,4 +94,6 @@\n-            ZipEntry ze = zf.getEntry(\"ReadZip.java\");\n-            if (ze == null) {\n-                throw new Exception(\"cannot read from zip file\");\n-            }\n+            assertThrows(NullPointerException.class, () -> zf.getEntry(null));\n+            assertThrows(NullPointerException.class, () -> zf.getInputStream(null));\n+\n+            \/\/ Sanity check that we can still read an entry\n+            ZipEntry ze = zf.getEntry(\"file.txt\");\n+            assertNotNull(ze, \"cannot read from zip file\");\n@@ -70,0 +101,1 @@\n+    }\n@@ -71,5 +103,6 @@\n-        \/\/ Make sure we can read the zip file that has some garbage\n-        \/\/ bytes padded at the end.\n-        File newZip = new File(System.getProperty(\"test.dir\", \".\"), \"input2.zip\");\n-        Files.copy(Paths.get(System.getProperty(\"test.src\", \"\"), \"input.zip\"),\n-                   newZip.toPath(), StandardCopyOption.REPLACE_EXISTING);\n+    \/**\n+     * Read the zip file that has some garbage bytes padded at the end\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void bytesPaddedAtEnd() throws IOException {\n@@ -77,1 +110,1 @@\n-        newZip.setWritable(true);\n+        zip = createZip(\"bytes-padded.zip\");\n@@ -80,3 +113,6 @@\n-        try (OutputStream os = Files.newOutputStream(newZip.toPath(),\n-                                                     StandardOpenOption.APPEND)) {\n-            os.write(1); os.write(3); os.write(5); os.write(7);\n+        try (OutputStream os = Files.newOutputStream(zip,\n+                StandardOpenOption.APPEND)) {\n+            os.write(1);\n+            os.write(3);\n+            os.write(5);\n+            os.write(7);\n@@ -85,7 +121,25 @@\n-        try (ZipFile zf = new ZipFile(newZip)) {\n-            ZipEntry ze = zf.getEntry(\"ReadZip.java\");\n-            if (ze == null) {\n-                throw new Exception(\"cannot read from zip file\");\n-            }\n-        } finally {\n-            newZip.delete();\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry ze = zf.getEntry(\"file.txt\");\n+            assertNotNull(ze, \"cannot read from zip file\");\n+        }\n+    }\n+\n+    \/**\n+     * Verify that we can read a comment from the ZIP\n+     * file's 'End of Central Directory' header\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void readZipFileComment() throws IOException {\n+\n+        \/\/ Create a zip file with a comment in the 'End of Central Directory' header\n+        try (OutputStream out = Files.newOutputStream(zip);\n+             ZipOutputStream zos = new ZipOutputStream(out)) {\n+            ZipEntry ze = new ZipEntry(\"ZipEntry\");\n+            zos.putNextEntry(ze);\n+            zos.write(1);\n+            zos.write(2);\n+            zos.write(3);\n+            zos.write(4);\n+            zos.closeEntry();\n+            zos.setComment(\"This is the comment for testing\");\n@@ -95,10 +149,6 @@\n-        try {\n-            try (FileOutputStream fos = new FileOutputStream(newZip);\n-                 ZipOutputStream zos = new ZipOutputStream(fos))\n-            {\n-                ZipEntry ze = new ZipEntry(\"ZipEntry\");\n-                zos.putNextEntry(ze);\n-                zos.write(1); zos.write(2); zos.write(3); zos.write(4);\n-                zos.closeEntry();\n-                zos.setComment(\"This is the comment for testing\");\n-            }\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry ze = zf.getEntry(\"ZipEntry\");\n+            assertNotNull(ze, \"cannot read entry from zip file\");\n+            assertEquals(\"This is the comment for testing\", zf.getComment());\n+        }\n+    }\n@@ -106,38 +156,37 @@\n-            try (ZipFile zf = new ZipFile(newZip)) {\n-                ZipEntry ze = zf.getEntry(\"ZipEntry\");\n-                if (ze == null)\n-                    throw new Exception(\"cannot read entry from zip file\");\n-                if (!\"This is the comment for testing\".equals(zf.getComment()))\n-                    throw new Exception(\"cannot read comment from zip file\");\n-            }\n-        } finally {\n-            newZip.delete();\n-        }\n-\n-        \/\/ Read directory entry\n-        try {\n-            try (FileOutputStream fos = new FileOutputStream(newZip);\n-                 ZipOutputStream zos = new ZipOutputStream(fos))\n-            {\n-                ZipEntry ze = new ZipEntry(\"directory\/\");\n-                zos.putNextEntry(ze);\n-                zos.closeEntry();\n-            }\n-            try (ZipFile zf = new ZipFile(newZip)) {\n-                ZipEntry ze = zf.getEntry(\"directory\/\");\n-                if (ze == null || !ze.isDirectory())\n-                    throw new RuntimeException(\"read entry \\\"directory\/\\\" failed\");\n-                try (InputStream is = zf.getInputStream(ze)) {\n-                    is.available();\n-                } catch (Exception x) {\n-                    x.printStackTrace();\n-                }\n-\n-                ze = zf.getEntry(\"directory\");\n-                if (ze == null || !ze.isDirectory())\n-                    throw new RuntimeException(\"read entry \\\"directory\\\" failed\");\n-                try (InputStream is = zf.getInputStream(ze)) {\n-                    is.available();\n-                } catch (Exception x) {\n-                    x.printStackTrace();\n-                }\n+    \/**\n+     * Verify that a directory entry can be found using the\n+     * name 'directory\/' as well as 'directory\/'\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void readDirectoryEntries() throws IOException {\n+\n+        \/\/ Create a ZIP containing some directory entries\n+        try (OutputStream fos = Files.newOutputStream(zip);\n+             ZipOutputStream zos = new ZipOutputStream(fos)) {\n+            \/\/ Add a META-INF directory with STORED compression type\n+            ZipEntry metaInf = new ZipEntry(\"META-INF\/\");\n+            metaInf.setMethod(ZipEntry.STORED);\n+            metaInf.setSize(0);\n+            metaInf.setCrc(0);\n+            zos.putNextEntry(metaInf);\n+\n+            \/\/ Add a regular directory\n+            ZipEntry dir = new ZipEntry(\"directory\/\");\n+            zos.putNextEntry(dir);\n+            zos.closeEntry();\n+        }\n+\n+        \/\/ Verify directory lookups\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            \/\/ Look up 'directory\/' using the full name\n+            ZipEntry ze = zf.getEntry(\"directory\/\");\n+            assertNotNull(ze, \"read entry \\\"directory\/\\\" failed\");\n+            assertTrue(ze.isDirectory(), \"read entry \\\"directory\/\\\" failed\");\n+            assertEquals(\"directory\/\", ze.getName());\n+\n+            try (InputStream is = zf.getInputStream(ze)) {\n+                is.available();\n+            } catch (Exception x) {\n+                x.printStackTrace();\n@@ -145,19 +194,11 @@\n-        } finally {\n-            newZip.delete();\n-        }\n-\n-        \/\/ Throw a FNF exception when read a non-existing zip file\n-        try { unreached (new ZipFile(\n-                             new File(System.getProperty(\"test.src\", \".\"),\n-                                     \"input\"\n-                                      + String.valueOf(new java.util.Random().nextInt())\n-                                      + \".zip\")));\n-        } catch (NoSuchFileException nsfe) {}\n-\n-        \/\/ read a zip file with ZIP64 end\n-        Path path = Paths.get(System.getProperty(\"test.dir\", \"\"), \"end64.zip\");\n-        try {\n-            URI uri = URI.create(\"jar:\" + path.toUri());\n-            Map<String, Object> env = Map.of(\"create\", \"true\", \"forceZIP64End\", \"true\");\n-            try (FileSystem fs = FileSystems.newFileSystem(uri, env)) {\n-                Files.write(fs.getPath(\"hello\"), \"hello\".getBytes());\n+\n+            \/\/ Look up 'directory\/' without the trailing slash\n+            ze = zf.getEntry(\"directory\");\n+            assertNotNull(ze, \"read entry \\\"directory\\\" failed\");\n+            assertTrue(ze.isDirectory(), \"read entry \\\"directory\\\" failed\");\n+            assertEquals(\"directory\/\", ze.getName());\n+\n+            try (InputStream is = zf.getInputStream(ze)) {\n+                is.available();\n+            } catch (Exception x) {\n+                x.printStackTrace();\n@@ -165,7 +206,35 @@\n-            try (ZipFile zf = new ZipFile(path.toFile())) {\n-                if (!\"hello\".equals(new String(zf.getInputStream(new ZipEntry(\"hello\"))\n-                                               .readAllBytes(),\n-                                               US_ASCII)))\n-                    throw new RuntimeException(\"zipfile: read entry failed\");\n-            } catch (IOException x) {\n-                throw new RuntimeException(\"zipfile: zip64 end failed\");\n+            \/\/ Sanity check that also META-INF\/ can be looked up with or without the trailing slash\n+            assertNotNull(zf.getEntry(\"META-INF\"));\n+            assertNotNull(zf.getEntry(\"META-INF\/\"));\n+            assertEquals(zf.getEntry(\"META-INF\").getName(),\n+                    zf.getEntry(\"META-INF\/\").getName());\n+        }\n+    }\n+\n+    \/**\n+     * Throw a NoSuchFileException exception when reading a non-existing zip file\n+     *\/\n+    @Test\n+    public void nonExistingFile() {\n+        File nonExistingFile = new File(\"non-existing-file-f6804460f.zip\");\n+        assertThrows(NoSuchFileException.class, () ->\n+                new ZipFile(nonExistingFile));\n+    }\n+\n+    \/**\n+     * Read a Zip file with a 'Zip64 End of Central Directory header' which was created\n+     * using ZipFileSystem with the 'forceZIP64End' option.\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void readZip64EndZipFs() throws IOException {\n+\n+        \/\/ Create zip file with Zip64 end\n+        Map<String, Object> env = Map.of(\"create\", \"true\", \"forceZIP64End\", \"true\");\n+        try (FileSystem fs = FileSystems.newFileSystem(zip, env)) {\n+            Files.write(fs.getPath(\"hello\"), \"hello\".getBytes());\n+        }\n+        \/\/ Read using ZipFile\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            try (InputStream in = zf.getInputStream(zf.getEntry(\"hello\"))) {\n+                assertEquals(\"hello\", new String(in.readAllBytes(), StandardCharsets.US_ASCII));\n@@ -173,5 +242,35 @@\n-            try (FileSystem fs = FileSystems.newFileSystem(uri, Map.of())) {\n-                if (!\"hello\".equals(new String(Files.readAllBytes(fs.getPath(\"hello\")))))\n-                    throw new RuntimeException(\"zipfs: read entry failed\");\n-            } catch (IOException x) {\n-                throw new RuntimeException(\"zipfile: zip64 end failed\");\n+        }\n+        \/\/ Read using ZipFileSystem\n+        try (FileSystem fs = FileSystems.newFileSystem(zip, Map.of())) {\n+            assertEquals(\"hello\", new String(Files.readAllBytes(fs.getPath(\"hello\"))));\n+        }\n+    }\n+\n+    \/**\n+     * Read a zip file created via Info-ZIP in streaming mode,\n+     * which includes a 'Zip64 End of Central Directory header'.\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     * @throws InterruptedException if an unexpected InterruptedException occurs\n+     *\/\n+    @Test\n+    public void readZip64EndInfoZIPStreaming() throws IOException, InterruptedException {\n+        \/\/ ZIP created using: \"echo -n hello | zip zip64.zip -\"\n+        \/\/ Hex encoded using: \"cat zip64.zip | xxd -ps\"\n+        byte[] zipBytes = HexFormat.of().parseHex(\"\"\"\n+                  504b03042d0000000000c441295886a61036ffffffffffffffff01001400\n+                  2d010010000500000000000000050000000000000068656c6c6f504b0102\n+                  1e032d0000000000c441295886a610360500000005000000010000000000\n+                  000001000000b011000000002d504b06062c000000000000001e032d0000\n+                  00000000000000010000000000000001000000000000002f000000000000\n+                  003800000000000000504b06070000000067000000000000000100000050\n+                  4b050600000000010001002f000000380000000000\n+                  \"\"\".replaceAll(\"\\n\",\"\")\n+        );\n+\n+        Files.write(zip, zipBytes);\n+\n+        try (ZipFile zf = new ZipFile(this.zip.toFile())) {\n+            try (InputStream in = zf.getInputStream(zf.getEntry(\"-\"))) {\n+                String contents = new String(in.readAllBytes(), StandardCharsets.US_ASCII);\n+                assertEquals(\"hello\", contents);\n@@ -179,22 +278,40 @@\n-        } finally {\n-            Files.deleteIfExists(path);\n-        }\n-\n-        \/\/ read a zip file created via \"echo hello | zip dst.zip -\", which uses\n-        \/\/ ZIP64 end record\n-        if (Files.notExists(Paths.get(\"\/usr\/bin\/zip\")))\n-            return;\n-        try {\n-            Process zip = new ProcessBuilder(\"zip\", path.toString().toString(), \"-\").start();\n-            OutputStream os = zip.getOutputStream();\n-            os.write(\"hello\".getBytes(US_ASCII));\n-            os.close();\n-            zip.waitFor();\n-            if (zip.exitValue() == 0 && Files.exists(path)) {\n-                try (ZipFile zf = new ZipFile(path.toFile())) {\n-                    if (!\"hello\".equals(new String(zf.getInputStream(new ZipEntry(\"-\"))\n-                                                       .readAllBytes())))\n-                        throw new RuntimeException(\"zipfile: read entry failed\");\n-                } catch (IOException x) {\n-                    throw new RuntimeException(\"zipfile: zip64 end failed\");\n-                }\n+        }\n+    }\n+\n+    \/**\n+     * Check that the available() method overriden by the input stream returned by\n+     * ZipFile.getInputStream correctly returns the number of remaining uncompressed bytes\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void availableShouldReturnRemainingUncompressedBytes() throws IOException {\n+        \/\/ The number of uncompressed bytes to write to the sample ZIP entry\n+        final int expectedBytes = 512;\n+\n+        \/\/ Create a sample ZIP with deflated entry of a known uncompressed size\n+        try (ZipOutputStream zo = new ZipOutputStream(Files.newOutputStream(zip))) {\n+            zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+            zo.write(new byte[expectedBytes]);\n+        }\n+\n+        \/\/ Verify the behavior of ZipFileInflaterInputStream.available()\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry e = zf.getEntry(\"file.txt\");\n+            try (InputStream in = zf.getInputStream(e)) {\n+                \/\/ Initially, available() should return the full uncompressed size of the entry\n+                assertEquals(expectedBytes, in.available(),\n+                        \"wrong initial return value of available\");\n+\n+                \/\/ Reading a few bytes should reduce the number of available bytes accordingly\n+                int bytesToRead = 10;\n+                in.read(new byte[bytesToRead]);\n+                assertEquals(expectedBytes - bytesToRead, in.available());\n+\n+                \/\/ Reading all remaining bytes should reduce the number of available bytes to zero\n+                in.transferTo(OutputStream.nullOutputStream());\n+                assertEquals(0, in.available());\n+\n+                \/\/ available on a closed input stream should return zero\n+                in.close();\n+                assertEquals(0, in.available());\n@@ -202,2 +319,0 @@\n-        } finally {\n-            Files.deleteIfExists(path);\n@@ -206,1 +321,60 @@\n-}\n+\n+    \/**\n+     * Verify that reading an InputStream from a closed ZipFile\n+     * throws IOException as expected and does not crash the VM.\n+     * See bugs: 4528128 6846616\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void readAfterClose() throws IOException {\n+        zip = createZip(\"read-after-close.zip\");\n+        InputStream in;\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry zent = zf.getEntry(\"file.txt\");\n+            in = zf.getInputStream(zent);\n+        }\n+\n+        \/\/ zf is closed at this point\n+        assertThrows(IOException.class,  () -> {\n+            in.read();\n+        });\n+        assertThrows(IOException.class,  () -> {\n+            in.read(new byte[10]);\n+        });\n+        assertThrows(IOException.class,  () -> {\n+            byte[] buf = new byte[10];\n+            in.read(buf, 0, buf.length);\n+        });\n+        assertThrows(IOException.class,  () -> {\n+            in.readAllBytes();\n+        });\n+    }\n+\n+    \/**\n+     * Verify that ZipFile can open a ZIP file with zero entries\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void noEntries() throws IOException {\n+        \/\/ Create a ZIP file with no entries\n+        try (ZipOutputStream zo = new ZipOutputStream(Files.newOutputStream(zip))) {\n+        }\n+\n+        \/\/ Open the \"empty\" ZIP file\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            \/\/ Verify size\n+            assertEquals(0, zf.size());\n+\n+            \/\/ Verify entry lookup using ZipFile.getEntry()\n+            assertNull(zf.getEntry(\"file.txt\"));\n+\n+            \/\/ Verify iteration using ZipFile.entries()\n+            assertEquals(Collections.emptyList(), Collections.list(zf.entries()));\n+\n+            \/\/ Verify iteration using ZipFile.stream()\n+            assertEquals(Collections.emptyList(), zf.stream().toList());\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ReadZip.java","additions":325,"deletions":151,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @run junit ReleaseInflater\n@@ -30,2 +31,14 @@\n-import java.io.*;\n-import java.util.zip.*;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -35,4 +48,35 @@\n-    public static void main(String[] args) throws Exception {\n-        ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\"),\n-                                          \"input.jar\"));\n-        ZipEntry e = zf.getEntry(\"ReleaseInflater.java\");\n+    \/\/ ZIP file produced in this test\n+    private Path zip = Path.of(\"release-inflater.zip\");\n+\n+    \/**\n+     * Create a sample ZIP file for use by tests\n+     * @param name name of the ZIP file to create\n+     * @return a sample ZIP file\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @BeforeEach\n+    public void setUp() throws IOException {\n+        try (ZipOutputStream zo = new ZipOutputStream(Files.newOutputStream(zip))) {\n+            zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+            zo.write(\"helloworld\".getBytes(StandardCharsets.UTF_8));\n+        }\n+    }\n+\n+    \/**\n+     * Delete the ZIP and JAR files produced after each test method\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * Verify that the same Inflater is not recycled across input streams\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void recycleInflaterOnlyOnce() throws IOException {\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry e = zf.getEntry(\"file.txt\");\n@@ -40,5 +84,5 @@\n-        InputStream in1 = zf.getInputStream(e);\n-        \/\/ close the stream, the inflater will be released\n-        in1.close();\n-        \/\/ close the stream again, should be no-op\n-        in1.close();\n+            InputStream in1 = zf.getInputStream(e);\n+            \/\/ close the stream, the inflater will be released\n+            in1.close();\n+            \/\/ close the stream again, should be no-op\n+            in1.close();\n@@ -46,3 +90,3 @@\n-        \/\/ create two new streams, allocating inflaters\n-        InputStream in2 = zf.getInputStream(e);\n-        InputStream in3 = zf.getInputStream(e);\n+            \/\/ create two new streams, allocating inflaters\n+            InputStream in2 = zf.getInputStream(e);\n+            InputStream in3 = zf.getInputStream(e);\n@@ -50,3 +94,2 @@\n-        \/\/ check to see if they influence each other\n-        if (in2.read() != in3.read()) {\n-            throw new Exception(\"Stream is corrupted!\");\n+            \/\/ check to see if they influence each other\n+            assertEquals(in2.read(), in3.read(), \"Stream is corrupted!\");\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ReleaseInflater.java","additions":61,"deletions":18,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @run testng StreamZipEntriesTest\n+ * @run junit StreamZipEntriesTest\n@@ -30,1 +30,4 @@\n-import java.io.File;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n@@ -32,3 +35,6 @@\n-import java.lang.Object;\n-import java.lang.System;\n-import java.util.jar.JarFile;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Set;\n@@ -36,0 +42,3 @@\n+import java.util.jar.JarFile;\n+import java.util.jar.JarOutputStream;\n+import java.util.jar.Manifest;\n@@ -39,0 +48,1 @@\n+import java.util.zip.ZipOutputStream;\n@@ -40,1 +50,1 @@\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -42,3 +52,0 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n@@ -48,0 +55,50 @@\n+    \/\/ ZIP file produced in this test\n+    private Path zip = Path.of(\"stream.zip\");\n+    \/\/ JAR file produced in this test\n+    private Path jar = Path.of(\"stream.jar\");\n+\n+    \/**\n+     * Create sample ZIP and JAR files used in in this test\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @BeforeEach\n+    public void setUp() throws IOException {\n+\n+        try (OutputStream out = Files.newOutputStream(zip);\n+             ZipOutputStream zo = new ZipOutputStream(out)) {\n+            zo.putNextEntry(new ZipEntry(\"entry1.txt\"));\n+            zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+            zo.putNextEntry(new ZipEntry(\"entry2.txt\"));\n+            zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+        }\n+\n+        try (OutputStream out = Files.newOutputStream(jar);\n+             ZipOutputStream zo = new ZipOutputStream(out)) {\n+            \/\/ A JAR file may start with a META-INF\/ directory before the manifest\n+            zo.putNextEntry(new ZipEntry(\"META-INF\/\"));\n+            \/\/ Write the manifest\n+            zo.putNextEntry(new ZipEntry(\"META-INF\/MANIFEST.MF\"));\n+            new Manifest().write(zo);\n+\n+            \/\/ Write two regular entries\n+            zo.putNextEntry(new ZipEntry(\"entry1.txt\"));\n+            zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+            zo.putNextEntry(new ZipEntry(\"entry2.txt\"));\n+            zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+        }\n+    }\n+\n+    \/**\n+     * Delete the ZIP file produced after each test method\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+        Files.deleteIfExists(jar);\n+    }\n+\n+    \/**\n+     * Verify that ZipFile.stream() produces the expected entries\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n@@ -50,3 +107,13 @@\n-        try (ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\", \".\"), \"input.zip\"))) {\n-            zf.stream().forEach(e -> assertTrue(e instanceof ZipEntry));\n-            zf.stream().forEach(e -> assertEquals(e.toString(), \"ReadZip.java\"));\n+        Set<String> names = new HashSet<>(Set.of(\"entry1.txt\", \"entry2.txt\"));\n+\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            zf.stream().forEach(e -> {\n+                assertTrue(e instanceof ZipEntry);\n+                String name = e.getName();\n+                assertNotNull(names.remove(name));\n+                String toString = e.toString();\n+                assertEquals(name, toString);\n+            });\n+\n+            \/\/ Check that all expected names were processed\n+            assertTrue(names.isEmpty());\n@@ -54,0 +121,1 @@\n+            \/\/ Check that Stream.toArray produces the expected result\n@@ -55,2 +123,3 @@\n-            assertEquals(1, elements.length);\n-            assertEquals(elements[0].toString(), \"ReadZip.java\");\n+            assertEquals(2, elements.length);\n+            assertEquals(elements[0].toString(), \"entry1.txt\");\n+            assertEquals(elements[1].toString(), \"entry2.txt\");\n@@ -60,0 +129,4 @@\n+    \/**\n+     * Verify that JarFile.stream() produces the expected entries\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n@@ -62,2 +135,7 @@\n-        try (JarFile jf = new JarFile(new File(System.getProperty(\"test.src\", \".\"), \"input.jar\"))) {\n-            jf.stream().forEach(e -> assertTrue(e instanceof JarEntry));\n+        try (JarFile jf = new JarFile(jar.toFile())) {\n+            Set<String> names = new HashSet<>(Set.of(\n+                    \"META-INF\/\",\n+                    \"META-INF\/MANIFEST.MF\",\n+                    \"entry1.txt\",\n+                    \"entry2.txt\"\n+            ));\n@@ -65,0 +143,14 @@\n+            jf.stream().forEach(e -> {\n+                        assertTrue(e instanceof JarEntry);\n+                        String name = e.getName();\n+                        assertNotNull(names.remove(name));\n+                        String toString = e.toString();\n+                        assertEquals(name, toString);\n+                    }\n+            );\n+\n+            \/\/ Check that all expected names were processed\n+            assertTrue(names.isEmpty(), \"Unprocessed entries: \" + names);\n+\n+\n+            \/\/ Check that Stream.toArray produces the expected result\n@@ -66,1 +158,1 @@\n-            assertEquals(3, elements.length);\n+            assertEquals(4, elements.length);\n@@ -69,1 +161,2 @@\n-            assertEquals(elements[2].toString(), \"ReleaseInflater.java\");\n+            assertEquals(elements[2].toString(), \"entry1.txt\");\n+            assertEquals(elements[3].toString(), \"entry2.txt\");\n@@ -73,0 +166,4 @@\n+    \/**\n+     * Calling ZipFile.stream() on a closed ZipFile should throw ISE\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n@@ -75,1 +172,1 @@\n-        ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\", \".\"), \"input.zip\"));\n+        ZipFile zf = new ZipFile(zip.toFile());\n@@ -77,1 +174,1 @@\n-        try {\n+        assertThrows(IllegalStateException.class, () -> {\n@@ -79,4 +176,1 @@\n-            fail(\"Should have thrown IllegalStateException\");\n-        } catch (IllegalStateException e) {\n-            \/\/ expected;\n-        }\n+        });\n@@ -85,0 +179,4 @@\n+    \/**\n+     * Calling JarFile.stream() on a closed JarFile should throw ISE\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n@@ -87,1 +185,1 @@\n-        JarFile jf = new JarFile(new File(System.getProperty(\"test.src\", \".\"), \"input.jar\"));\n+        JarFile jf = new JarFile(jar.toFile());\n@@ -89,1 +187,1 @@\n-        try {\n+        assertThrows(IllegalStateException.class, () -> {\n@@ -91,4 +189,1 @@\n-            fail(\"Should have thrown IllegalStateException\");\n-        } catch (IllegalStateException e) {\n-            \/\/ expected;\n-        }\n+        });\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/StreamZipEntriesTest.java","additions":126,"deletions":31,"binary":false,"changes":157,"status":"modified"},{"filename":"test\/jdk\/java\/util\/zip\/ZipFile\/crash.jar","binary":true,"status":"deleted"},{"filename":"test\/jdk\/java\/util\/zip\/ZipFile\/input.jar","binary":true,"status":"deleted"},{"filename":"test\/jdk\/java\/util\/zip\/ZipFile\/input.zip","binary":true,"status":"deleted"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.sound.sampled.AudioInputStream;\n+import javax.sound.sampled.AudioSystem;\n+import javax.sound.sampled.Clip;\n+import javax.sound.sampled.LineUnavailableException;\n+import javax.sound.sampled.UnsupportedAudioFileException;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+\/*\n+ * @test\n+ * @key sound\n+ * @bug 8282578\n+ * @summary AIOOBE in javax.sound.sampled.Clip\n+ * @run main EmptySysExMessageTest\n+ *\/\n+\n+public class EmptySysExMessageTest {\n+    public static void main(String[] args) {\n+        String sep = System.getProperty(\"file.separator\");\n+        String dir = System.getProperty(\"test.src\", \".\");\n+        String name = \"zerosysex.mid\";\n+        try {\n+            readAudioFile(dir + sep + name);\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"Invalid file \" + name\n+                    + \" caused unexpected exception during read: \"\n+                    + t + System.lineSeparator());\n+        }\n+    }\n+\n+    static void readAudioFile(String name) throws IOException {\n+        File soundFile = new File(name);\n+        Path path = Paths.get(soundFile.getAbsolutePath());\n+        byte[] samples = Files.readAllBytes(path);\n+\n+        try {\n+            AudioInputStream audioInputStream =\n+                    AudioSystem.getAudioInputStream(new ByteArrayInputStream(samples));\n+            try (Clip clip = AudioSystem.getClip()) {\n+                clip.open(audioInputStream);\n+                clip.start();\n+                Thread.sleep(1000);\n+                clip.stop();\n+            }\n+        } catch (UnsupportedAudioFileException\n+                 | LineUnavailableException\n+                 | IOException\n+                 | InterruptedException\n+                 | IllegalArgumentException\n+                 | IllegalStateException\n+                 | SecurityException expected) {\n+            \/\/ Do nothing, these types of exception are expected on invalid file\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/sound\/midi\/SysexMessage\/EmptySysExMessageTest.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"filename":"test\/jdk\/javax\/sound\/midi\/SysexMessage\/zerosysex.mid","binary":true,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.awt.EventQueue;\n@@ -30,0 +31,2 @@\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n@@ -49,7 +52,1 @@\n-        SwingUtilities.invokeAndWait(new Runnable() {\n-\n-            @Override\n-            public void run() {\n-                constructTestUI();\n-            }\n-        });\n+        SwingUtilities.invokeAndWait(PressedButtonRightClickTest::constructTestUI);\n@@ -64,0 +61,1 @@\n+        testRobot.delay(500);\n@@ -66,3 +64,5 @@\n-        test();\n-\n-        disposeTestUI();\n+        try {\n+            test();\n+        } finally {\n+            EventQueue.invokeAndWait(PressedButtonRightClickTest::disposeTestUI);\n+        }\n@@ -77,0 +77,1 @@\n+        System.out.println(\"press BUTTON1_DOWN_MASK\");\n@@ -79,1 +80,1 @@\n-        testRobot.delay(1000);\n+        testRobot.delay(500);\n@@ -82,0 +83,1 @@\n+        System.out.println(\"press BUTTON3_DOWN_MASK\");\n@@ -84,1 +86,1 @@\n-        testRobot.delay(1000);\n+        testRobot.delay(500);\n@@ -87,0 +89,1 @@\n+        System.out.println(\"release BUTTON3_DOWN_MASK\");\n@@ -89,1 +92,2 @@\n-        testRobot.delay(1000);\n+        testRobot.waitForIdle();\n+        testRobot.delay(500);\n@@ -93,0 +97,1 @@\n+        System.out.println(\"release BUTTON1_DOWN_MASK\");\n@@ -109,0 +114,26 @@\n+        myButton.addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseClicked(MouseEvent e) {\n+                System.out.println(e);\n+            }\n+\n+            @Override\n+            public void mousePressed(MouseEvent e) {\n+                System.out.println(e);\n+            }\n+\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                System.out.println(e);\n+            }\n+\n+            @Override\n+            public void mouseEntered(MouseEvent e) {\n+                System.out.println(e);\n+            }\n+\n+            @Override\n+            public void mouseExited(MouseEvent e) {\n+                System.out.println(e);\n+            }\n+        });\n","filename":"test\/jdk\/javax\/swing\/JButton\/PressedButtonRightClickTest.java","additions":45,"deletions":14,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,0 @@\n-import java.awt.event.ActionEvent;\n-import java.awt.event.ActionListener;\n@@ -52,0 +50,1 @@\n+        robot.setAutoWaitForIdle(true);\n@@ -57,2 +56,4 @@\n-                button.addActionListener(new ActionListener() {\n-                    public void actionPerformed(ActionEvent e) {\n+                button.addActionListener(e -> {\n+                    if ((e.getModifiers() & InputEvent.BUTTON1_MASK)\n+                            != InputEvent.BUTTON1_MASK) {\n+                        System.out.println(\"Status: Failed\");\n@@ -83,0 +84,2 @@\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.delay(500);\n","filename":"test\/jdk\/javax\/swing\/JButton\/bug4490179.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,0 +93,1 @@\n+                robot.delay(500);\n","filename":"test\/jdk\/javax\/swing\/JLabel\/4138746\/JLabelMnemonicsTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,0 +93,1 @@\n+                        robot.delay(500);\n@@ -113,0 +114,1 @@\n+                robot.delay(500);\n","filename":"test\/jdk\/javax\/swing\/plaf\/basic\/BasicComboPopup\/JComboBoxPopupLocation\/JComboBoxPopupLocation.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+    static JFrame frame;\n@@ -58,1 +59,1 @@\n-        JFrame frame = new JFrame();\n+        frame = new JFrame();\n@@ -60,0 +61,1 @@\n+        frame.setLocationRelativeTo(null);\n@@ -83,0 +85,2 @@\n+        robot.delay(500);\n+\n@@ -85,1 +89,3 @@\n-        robot.delay(200);\n+        robot.delay(500);\n+\n+        SwingUtilities.invokeAndWait(() -> frame.dispose());\n","filename":"test\/jdk\/javax\/swing\/plaf\/basic\/BasicMenuUI\/4983388\/bug4983388.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @summary tests delte-next-word and delete-prev-word actions for all text compnents and all look&feels\n+ * @summary tests delete-next-word and delete-prev-word actions for all text components and all look&feels\n@@ -52,0 +52,2 @@\n+    private static JFrame frame;\n+    private static Robot robot;\n@@ -59,0 +61,4 @@\n+        robot = new Robot();\n+        robot.setAutoWaitForIdle(true);\n+        robot.setAutoDelay(50);\n+\n@@ -63,3 +69,12 @@\n-                boolean res = test(clazz);\n-                if (!res && clazz != JPasswordField.class) {\n-                    throw new RuntimeException(\"failed\");\n+                try {\n+                    boolean res = test(clazz);\n+                    if (!res && clazz != JPasswordField.class) {\n+                        throw new RuntimeException(\"failed\");\n+                    }\n+                } finally {\n+                    SwingUtilities.invokeAndWait(() -> {\n+                        if (frame != null) {\n+                            frame.dispose();\n+                            frame = null;\n+                        }\n+                    });\n@@ -72,5 +87,0 @@\n-        Robot robot = new Robot();\n-        robot.setAutoWaitForIdle(true);\n-        robot.setAutoDelay(50);\n-\n-\n@@ -86,0 +96,1 @@\n+        robot.delay(500);\n@@ -123,0 +134,1 @@\n+        robot.delay(250);\n@@ -155,1 +167,1 @@\n-            JFrame frame = new JFrame();\n+            frame = new JFrame();\n","filename":"test\/jdk\/javax\/swing\/text\/JTextComponent\/5074573\/bug5074573.java","additions":23,"deletions":11,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * Before this test set to manual, the original timeout\n+ * value if 180\n@@ -32,1 +34,1 @@\n- * @run main\/othervm\/manual\/timeout=180 -Djava.security.debug=certpath,ocsp\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp\n@@ -35,1 +37,1 @@\n- * @run main\/othervm\/manual\/timeout=180 -Djava.security.debug=certpath,ocsp\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/CAInterop.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(options);\n+        ProcessBuilder pb = ProcessTools.createTestJvm(options);\n","filename":"test\/jdk\/sun\/management\/jdp\/DynamicLauncher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8185898 8163921\n+ * @bug 8185898 8163921 8339470\n@@ -146,1 +146,1 @@\n-                        + \"Accept: *\/*\\r\\n\"\n+                        + \"Accept: text\/html, image\/gif, image\/jpeg, *\/*; q=0.2\\r\\n\"\n@@ -151,1 +151,1 @@\n-                        + \"{Accept: *\/*}\"\n+                        + \"{Accept: text\/html, image\/gif, image\/jpeg, *\/*; q=0.2}\"\n@@ -155,1 +155,1 @@\n-                \"Accept: *\/*\\r\\n\"\n+                \"Accept: text\/html, image\/gif, image\/jpeg, *\/*; q=0.2\\r\\n\"\n@@ -160,1 +160,1 @@\n-                        + \"Accept: *\/*\\r\\n\"\n+                        + \"Accept: text\/html, image\/gif, image\/jpeg, *\/*; q=0.2\\r\\n\"\n@@ -166,1 +166,1 @@\n-                        + \"{Accept: *\/*}\"\n+                        + \"{Accept: text\/html, image\/gif, image\/jpeg, *\/*; q=0.2}\"\n@@ -171,1 +171,1 @@\n-                \"Accept: *\/*\\r\\n\"\n+                \"Accept: text\/html, image\/gif, image\/jpeg, *\/*; q=0.2\\r\\n\"\n","filename":"test\/jdk\/sun\/net\/www\/B8185898.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @summary Http keep-alive implementation is not efficient\n@@ -29,1 +30,0 @@\n- * @summary Http keep-alive implementation is not efficient\n@@ -45,0 +45,1 @@\n+import java.util.concurrent.ExecutorService;\n@@ -51,0 +52,2 @@\n+import jdk.test.lib.net.URIBuilder;\n+\n@@ -52,1 +55,1 @@\n- * The http client makes a connection to a URL whos content contains a lot of\n+ * The http client makes a connection to a URL whose content contains a lot of\n@@ -66,5 +69,1 @@\n-\n-    public static void main(String[] args) {\n-        startHttpServer();\n-        clientHttpCalls();\n-    }\n+    static ExecutorService executor = Executors.newSingleThreadExecutor();\n@@ -74,1 +73,1 @@\n-            server = HttpServer.create(new InetSocketAddress(InetAddress.getLocalHost(), 0), 10);\n+            server = HttpServer.create(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 10);\n@@ -76,2 +75,0 @@\n-            server.setExecutor(Executors.newSingleThreadExecutor());\n-            server.start();\n@@ -79,1 +76,1 @@\n-            e.printStackTrace();\n+            throw new RuntimeException(e);\n@@ -81,0 +78,3 @@\n+        server.setExecutor(executor);\n+        server.start();\n+        System.out.println(\"http server listens on: \" + server.getAddress());\n@@ -83,1 +83,6 @@\n-    public static void clientHttpCalls() {\n+    public static void stopHttpServer() {\n+        server.stop(1);\n+        executor.shutdown();\n+    }\n+\n+    public static void clientHttpCalls() throws Exception {\n@@ -88,5 +93,0 @@\n-        try {\n-            System.out.println(\"http server listen on: \" + server.getAddress().getPort());\n-            String hostAddr =  InetAddress.getLocalHost().getHostAddress();\n-            if (hostAddr.indexOf(':') > -1) hostAddr = \"[\" + hostAddr + \"]\";\n-            String baseURLStr = \"http:\/\/\" + hostAddr + \":\" + server.getAddress().getPort() + \"\/\";\n@@ -94,2 +94,13 @@\n-            URL bigDataURL = new URL (baseURLStr + \"firstCall\");\n-            URL smallDataURL = new URL (baseURLStr + \"secondCall\");\n+        URL bigDataURL = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .loopback()\n+                .port(server.getAddress().getPort())\n+                .path(\"\/firstCall\")\n+                .toURL();\n+\n+        URL smallDataURL = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .loopback()\n+                .port(server.getAddress().getPort())\n+                .path(\"\/secondCall\")\n+                .toURL();\n@@ -97,1 +108,1 @@\n-            HttpURLConnection uc = (HttpURLConnection)bigDataURL.openConnection(Proxy.NO_PROXY);\n+        HttpURLConnection uc = (HttpURLConnection)bigDataURL.openConnection(Proxy.NO_PROXY);\n@@ -99,2 +110,2 @@\n-            \/\/Only read 1 byte of response data and close the stream\n-            InputStream is = uc.getInputStream();\n+        \/\/ Only read 1 byte of response data and close the stream\n+        try (InputStream is = uc.getInputStream()) {\n@@ -103,41 +114,45 @@\n-            is.close();\n-\n-            \/\/ Allow the KeepAliveStreamCleaner thread to read the data left behind and cache the connection.\n-            try { Thread.sleep(2000); } catch (Exception e) {}\n-\n-            uc = (HttpURLConnection)smallDataURL.openConnection(Proxy.NO_PROXY);\n-            uc.getResponseCode();\n-\n-            if (SimpleHttpTransactionHandler.failed)\n-                throw new RuntimeException(\"Failed: Initial Keep Alive Connection is not being reused\");\n-\n-            \/\/ Part 2\n-            URL part2Url = new URL (baseURLStr + \"part2\");\n-            uc = (HttpURLConnection)part2Url.openConnection(Proxy.NO_PROXY);\n-            is = uc.getInputStream();\n-            is.close();\n-\n-            \/\/ Allow the KeepAliveStreamCleaner thread to try and read the data left behind and cache the connection.\n-            try { Thread.sleep(2000); } catch (Exception e) {}\n-\n-            ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n-            if (threadMXBean.isThreadCpuTimeSupported()) {\n-                long[] threads = threadMXBean.getAllThreadIds();\n-                ThreadInfo[] threadInfo = threadMXBean.getThreadInfo(threads);\n-                for (int i=0; i<threadInfo.length; i++) {\n-                    if (threadInfo[i].getThreadName().equals(\"Keep-Alive-SocketCleaner\"))  {\n-                        System.out.println(\"Found Keep-Alive-SocketCleaner thread\");\n-                        long threadID = threadInfo[i].getThreadId();\n-                        long before = threadMXBean.getThreadCpuTime(threadID);\n-                        try { Thread.sleep(2000); } catch (Exception e) {}\n-                        long after = threadMXBean.getThreadCpuTime(threadID);\n-\n-                        if (before ==-1 || after == -1)\n-                            break;  \/\/ thread has died, OK\n-\n-                        \/\/ if Keep-Alive-SocketCleaner consumes more than 50% of cpu then we\n-                        \/\/ can assume a recursive loop.\n-                        long total = after - before;\n-                        if (total >= 1000000000)  \/\/ 1 second, or 1 billion nanoseconds\n-                            throw new RuntimeException(\"Failed: possible recursive loop in Keep-Alive-SocketCleaner\");\n-                    }\n+        }\n+\n+        \/\/ Allow the KeepAliveStreamCleaner thread to read the data left behind and cache the connection.\n+        try { Thread.sleep(2000); } catch (Exception e) {}\n+\n+        uc = (HttpURLConnection)smallDataURL.openConnection(Proxy.NO_PROXY);\n+        uc.getResponseCode();\n+\n+        if (SimpleHttpTransactionHandler.failed)\n+            throw new RuntimeException(\"Failed: Initial Keep Alive Connection is not being reused\");\n+\n+        \/\/ Part 2\n+        URL part2Url = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .loopback()\n+                .port(server.getAddress().getPort())\n+                .path(\"\/part2\")\n+                .toURL();\n+\n+        uc = (HttpURLConnection)part2Url.openConnection(Proxy.NO_PROXY);\n+        try (InputStream is = uc.getInputStream()) {}\n+\n+        \/\/ Allow the KeepAliveStreamCleaner thread to try and read the data left behind and cache the connection.\n+        try { Thread.sleep(2000); } catch (Exception e) {}\n+\n+        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n+        if (threadMXBean.isThreadCpuTimeSupported()) {\n+            long[] threads = threadMXBean.getAllThreadIds();\n+            ThreadInfo[] threadInfo = threadMXBean.getThreadInfo(threads);\n+            for (int i = 0; i < threadInfo.length; i++) {\n+                if (threadInfo[i].getThreadName().equals(\"Keep-Alive-SocketCleaner\")) {\n+                    System.out.println(\"Found Keep-Alive-SocketCleaner thread\");\n+                    long threadID = threadInfo[i].getThreadId();\n+                    long before = threadMXBean.getThreadCpuTime(threadID);\n+                    try { Thread.sleep(2000); } catch (Exception e) {}\n+                    long after = threadMXBean.getThreadCpuTime(threadID);\n+\n+                    if (before ==-1 || after == -1)\n+                        break;  \/\/ thread has died, OK\n+\n+                    \/\/ if Keep-Alive-SocketCleaner consumes more than 50% of cpu then we\n+                    \/\/ can assume a recursive loop.\n+                    long total = after - before;\n+                    if (total >= 1000000000)  \/\/ 1 second, or 1 billion nanoseconds\n+                        throw new RuntimeException(\"Failed: possible recursive loop in Keep-Alive-SocketCleaner\");\n@@ -146,5 +161,0 @@\n-\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        } finally {\n-            server.stop(1);\n@@ -156,1 +166,0 @@\n-}\n@@ -158,3 +167,2 @@\n-class SimpleHttpTransactionHandler implements HttpHandler\n-{\n-    static volatile boolean failed = false;\n+    static class SimpleHttpTransactionHandler implements HttpHandler {\n+        static volatile boolean failed = false;\n@@ -162,3 +170,3 @@\n-    \/\/ Need to have enough data here that is too large for the socket buffer to hold.\n-    \/\/ Also http.KeepAlive.remainingData must be greater than this value, default is 256K.\n-    static final int RESPONSE_DATA_LENGTH = 128 * 1024;\n+        \/\/ Need to have enough data here that is too large for the socket buffer to hold.\n+        \/\/ Also http.KeepAlive.remainingData must be greater than this value, default is 256K.\n+        static final int RESPONSE_DATA_LENGTH = 128 * 1024;\n@@ -166,1 +174,1 @@\n-    int port1;\n+        int port1;\n@@ -168,12 +176,36 @@\n-    public void handle(HttpExchange trans) {\n-        try {\n-            String path = trans.getRequestURI().getPath();\n-            if (path.equals(\"\/firstCall\")) {\n-                port1 = trans.getRemoteAddress().getPort();\n-                System.out.println(\"First connection on client port = \" + port1);\n-\n-                byte[] responseBody = new byte[RESPONSE_DATA_LENGTH];\n-                for (int i=0; i<responseBody.length; i++)\n-                    responseBody[i] = 0x41;\n-                trans.sendResponseHeaders(200, responseBody.length);\n-                try (OutputStream os = trans.getResponseBody()) {\n+        public void handle(HttpExchange trans) {\n+            try {\n+                String path = trans.getRequestURI().getPath();\n+                if (path.equals(\"\/firstCall\")) {\n+                    port1 = trans.getRemoteAddress().getPort();\n+                    System.out.println(\"First connection on client port = \" + port1);\n+\n+                    byte[] responseBody = new byte[RESPONSE_DATA_LENGTH];\n+                    for (int i=0; i<responseBody.length; i++)\n+                        responseBody[i] = 0x41;\n+                    trans.sendResponseHeaders(200, responseBody.length);\n+                    try (OutputStream os = trans.getResponseBody()) {\n+                        os.write(responseBody);\n+                    }\n+                } else if (path.equals(\"\/secondCall\")) {\n+                    int port2 = trans.getRemoteAddress().getPort();\n+                    System.out.println(\"Second connection on client port = \" + port2);\n+\n+                    if (port1 != port2)\n+                        failed = true;\n+\n+                     \/* Force the server to not respond for more that the timeout\n+                      * set by the keepalive cleaner (5000 millis). This ensures the\n+                      * timeout is correctly resets the default read timeout,\n+                      * infinity. See 6993490. *\/\n+                    System.out.println(\"server sleeping...\");\n+                    try {Thread.sleep(6000); } catch (InterruptedException e) {}\n+                    trans.sendResponseHeaders(200, -1);\n+                } else if (path.equals(\"\/part2\")) {\n+                    System.out.println(\"Call to \/part2\");\n+                    byte[] responseBody = new byte[RESPONSE_DATA_LENGTH];\n+                    for (int i=0; i<responseBody.length; i++)\n+                        responseBody[i] = 0x41;\n+                    \/\/ override the Content-length header to be greater than the actual response body\n+                    trans.sendResponseHeaders(200, responseBody.length+1);\n+                    OutputStream os = trans.getResponseBody();\n@@ -181,0 +213,3 @@\n+                    \/\/ now close the socket\n+                    \/\/ closing the stream here would throw; close the exchange instead\n+                    trans.close();\n@@ -182,26 +217,3 @@\n-            } else if (path.equals(\"\/secondCall\")) {\n-                int port2 = trans.getRemoteAddress().getPort();\n-                System.out.println(\"Second connection on client port = \" + port2);\n-\n-                if (port1 != port2)\n-                    failed = true;\n-\n-                 \/* Force the server to not respond for more that the timeout\n-                  * set by the keepalive cleaner (5000 millis). This ensures the\n-                  * timeout is correctly resets the default read timeout,\n-                  * infinity. See 6993490. *\/\n-                System.out.println(\"server sleeping...\");\n-                try {Thread.sleep(6000); } catch (InterruptedException e) {}\n-                trans.sendResponseHeaders(200, -1);\n-            } else if(path.equals(\"\/part2\")) {\n-                System.out.println(\"Call to \/part2\");\n-                byte[] responseBody = new byte[RESPONSE_DATA_LENGTH];\n-                for (int i=0; i<responseBody.length; i++)\n-                    responseBody[i] = 0x41;\n-                \/\/ override the Content-length header to be greater than the actual response body\n-                trans.sendResponseHeaders(200, responseBody.length+1);\n-                OutputStream os = trans.getResponseBody();\n-                os.write(responseBody);\n-                \/\/ now close the socket\n-                \/\/ closing the stream here would throw; close the exchange instead\n-                trans.close();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+                failed = true;\n@@ -209,2 +221,9 @@\n-        } catch (Exception e) {\n-            e.printStackTrace();\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        startHttpServer();\n+        try {\n+            clientHttpCalls();\n+        } finally {\n+            stopHttpServer();\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/B5045306.java","additions":136,"deletions":117,"binary":false,"changes":253,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,2 @@\n- * @run main\/othervm -Dhttp.keepAlive.time.server=20 -esa -ea B8291637 timeout\n- * @run main\/othervm -Dhttp.keepAlive.time.server=20 -esa -ea B8291637 max\n+ * @library \/test\/lib\n+ * @run main\/othervm -Dhttp.keepAlive.time.server=20 -esa -ea B8291637\n@@ -34,1 +34,4 @@\n-import java.net.*;\n+import java.net.HttpURLConnection;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n@@ -38,0 +41,2 @@\n+import jdk.test.lib.net.URIBuilder;\n+\n@@ -41,3 +46,1 @@\n-    static class Server extends Thread {\n-        final ServerSocket serverSocket;\n-        final int port;\n+    static class Server extends Thread implements AutoCloseable {\n@@ -45,0 +48,2 @@\n+        final ServerSocket serverSocket = new ServerSocket(0);\n+        final int port;\n@@ -48,1 +53,1 @@\n-            serverSocket = new ServerSocket(0);\n+            this.param = param;\n@@ -51,1 +56,0 @@\n-            this.param = param;\n@@ -58,6 +62,4 @@\n-        public void close() {\n-            try {\n-                serverSocket.close();\n-                if (s != null)\n-                    s.close();\n-            } catch (IOException e) {}\n+        public void close() throws IOException {\n+            serverSocket.close();\n+            if (s != null)\n+                s.close();\n@@ -115,15 +117,13 @@\n-    public static void main(String[] args) throws Exception {\n-        Server server = new Server(args[0]);\n-        int port = server.getPort();\n-        server.start();\n-        URL url = new URL(\"http:\/\/127.0.0.1:\" + Integer.toString(port) + \"\/\");\n-        HttpURLConnection urlc = (HttpURLConnection) url.openConnection();\n-        InputStream i = urlc.getInputStream();\n-        int c,count=0;\n-        byte[] buf = new byte[256];\n-        while ((c=i.read(buf)) != -1) {\n-            count+=c;\n-        }\n-        i.close();\n-        System.out.println(\"Read \" + count );\n-        try {\n+    public static void runTest(String param) throws Exception {\n+        try (Server server = new Server(param)) {\n+            server.start();\n+            URL url = URIBuilder.newBuilder()\n+                    .scheme(\"http\")\n+                    .loopback()\n+                    .port(server.getPort())\n+                    .path(\"\/\")\n+                    .toURL();\n+            HttpURLConnection urlc = (HttpURLConnection) url.openConnection();\n+            try (InputStream i = urlc.getInputStream()) {\n+                System.out.println(\"Read \" + i.readAllBytes().length);\n+            }\n@@ -135,2 +135,0 @@\n-        } finally {\n-            server.close();\n@@ -139,0 +137,5 @@\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest(\"timeout\");\n+        runTest(\"max\");\n+    }\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/B8291637.java","additions":35,"deletions":32,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @summary Http keep-alive thread should close sockets without holding a lock\n@@ -29,1 +30,0 @@\n- * @summary Http keep-alive thread should close sockets without holding a lock\n@@ -32,9 +32,0 @@\n-import com.sun.net.httpserver.HttpExchange;\n-import com.sun.net.httpserver.HttpHandler;\n-import com.sun.net.httpserver.HttpServer;\n-\n-import javax.net.ssl.HandshakeCompletedListener;\n-import javax.net.ssl.HttpsURLConnection;\n-import javax.net.ssl.SSLSession;\n-import javax.net.ssl.SSLSocket;\n-import javax.net.ssl.SSLSocketFactory;\n@@ -56,0 +47,12 @@\n+import javax.net.ssl.HandshakeCompletedListener;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+\n+import jdk.test.lib.net.URIBuilder;\n+\n@@ -76,4 +79,1 @@\n-            System.out.println(\"http server listen on: \" + server.getAddress().getPort());\n-            String hostAddr = InetAddress.getLoopbackAddress().getHostAddress();\n-            if (hostAddr.indexOf(':') > -1) hostAddr = \"[\" + hostAddr + \"]\";\n-            String baseURLStr = \"https:\/\/\" + hostAddr + \":\" + server.getAddress().getPort() + \"\/\";\n+            System.out.println(\"http server listens on: \" + server.getAddress().getPort());\n@@ -81,1 +81,5 @@\n-            URL testUrl = new URL (baseURLStr);\n+            URL testUrl = URIBuilder.newBuilder()\n+                    .scheme(\"https\")\n+                    .loopback()\n+                    .port(server.getAddress().getPort())\n+                    .toURL();\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/B8293562.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @library \/test\/lib\n@@ -28,0 +27,1 @@\n+ * @library \/test\/lib\n@@ -33,4 +33,14 @@\n-import java.net.*;\n-import java.io.*;\n-import java.nio.charset.*;\n-import java.util.logging.*;\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.logging.ConsoleHandler;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n@@ -38,0 +48,1 @@\n+\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/KeepAliveProperty.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n- * @library \/test\/lib\n@@ -29,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -33,2 +33,11 @@\n-import java.net.*;\n-import java.io.*;\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+import java.net.URL;\n+\n@@ -36,0 +45,1 @@\n+\n@@ -134,2 +144,0 @@\n-\n-        grp.destroy();\n@@ -137,1 +145,0 @@\n-\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/KeepAliveTimerThread.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,3 +56,1 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -259,2 +257,3 @@\n-        String nssLibDir = fetchNssLib(osid);\n-        if (nssLibDir == null) {\n+        Path libraryName = Path.of(System.mapLibraryName(library));\n+        Path nssLibPath = fetchNssLib(osid, libraryName);\n+        if (nssLibPath == null) {\n@@ -264,8 +263,1 @@\n-\n-        String libraryName = System.mapLibraryName(library);\n-        Path libPath = Paths.get(nssLibDir).resolve(libraryName);\n-        if (!Files.exists(libPath)) {\n-            throw new SkippedException(\"NSS library \\\"\" + libraryName + \"\\\" was not found in \" + nssLibDir);\n-        }\n-\n-        return libPath;\n+        return nssLibPath;\n@@ -677,1 +669,1 @@\n-    private static String fetchNssLib(String osId) {\n+    private static Path fetchNssLib(String osId, Path libraryName) {\n@@ -680,1 +672,1 @@\n-                return fetchNssLib(WINDOWS_X64.class);\n+                return fetchNssLib(WINDOWS_X64.class, libraryName);\n@@ -683,1 +675,1 @@\n-                return fetchNssLib(MACOSX_X64.class);\n+                return fetchNssLib(MACOSX_X64.class, libraryName);\n@@ -686,1 +678,1 @@\n-                return fetchNssLib(MACOSX_AARCH64.class);\n+                return fetchNssLib(MACOSX_AARCH64.class, libraryName);\n@@ -692,1 +684,1 @@\n-                    return fetchNssLib(LINUX_X64.class);\n+                    return fetchNssLib(LINUX_X64.class, libraryName);\n@@ -699,1 +691,1 @@\n-                    return fetchNssLib(LINUX_AARCH64.class);\n+                    return fetchNssLib(LINUX_AARCH64.class, libraryName);\n@@ -706,2 +698,2 @@\n-    private static String fetchNssLib(Class<?> clazz) {\n-        String path = null;\n+    private static Path fetchNssLib(Class<?> clazz, Path libraryName) {\n+        Path path = null;\n@@ -709,4 +701,4 @@\n-            path = ArtifactResolver.resolve(clazz).entrySet().stream()\n-                    .findAny().get().getValue() + File.separator + \"nss\"\n-                    + File.separator + \"lib\" + File.separator;\n-        } catch (ArtifactResolverException e) {\n+            Path p = ArtifactResolver.resolve(clazz).entrySet().stream()\n+                    .findAny().get().getValue();\n+            path = findNSSLibrary(p, libraryName);\n+        } catch (ArtifactResolverException | IOException e) {\n@@ -726,0 +718,10 @@\n+    private static Path findNSSLibrary(Path path, Path libraryName) throws IOException {\n+        try(Stream<Path> files = Files.find(path, 10,\n+                (tp, attr) -> tp.getFileName().equals(libraryName))) {\n+\n+            return files.findAny()\n+                        .orElseThrow(() ->\n+                            new RuntimeException(\"NSS library \\\"\" + libraryName + \"\\\" was not found in \" + path));\n+        }\n+    }\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":28,"deletions":26,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/java\/security\/testlibrary\n@@ -1868,169 +1869,1 @@\n-}\n-\n-\/**\n- * HumanInputStream tries to act like a human sitting in front of a computer\n- * terminal typing on the keyboard while the keytool program is running.\n- *\n- * keytool has called InputStream.read() and BufferedReader.readLine() in\n- * various places. a call to B.readLine() will try to buffer as much input as\n- * possible. Thus, a trivial InputStream will find it impossible to feed\n- * anything to I.read() after a B.readLine() call.\n- *\n- * This is why i create HumanInputStream, which will only send a single line\n- * to B.readLine(), no more, no less, and the next I.read() can have a chance\n- * to read the exact character right after \"\\n\".\n- *\n- * I don't know why HumanInputStream works.\n- *\/\n-class HumanInputStream extends InputStream {\n-    byte[] src;\n-    int pos;\n-    int length;\n-    boolean inLine;\n-    int stopIt;\n-\n-    public HumanInputStream(String input) {\n-        src = input.getBytes();\n-        pos = 0;\n-        length = src.length;\n-        stopIt = 0;\n-        inLine = false;\n-    }\n-\n-    \/\/ the trick: when called through read(byte[], int, int),\n-    \/\/ return -1 twice after \"\\n\"\n-\n-    @Override public int read() throws IOException {\n-        int re;\n-        if(pos < length) {\n-            re = src[pos];\n-            if(inLine) {\n-                if(stopIt > 0) {\n-                    stopIt--;\n-                    re = -1;\n-                } else {\n-                    if(re == '\\n') {\n-                        stopIt = 2;\n-                    }\n-                    pos++;\n-                }\n-            } else {\n-                pos++;\n-            }\n-        } else {\n-            re = -1;\/\/throw new IOException(\"NO MORE TO READ\");\n-        }\n-        \/\/if (re < 32) System.err.printf(\"[%02d]\", re);\n-        \/\/else System.err.printf(\"[%c]\", (char)re);\n-        return re;\n-    }\n-    @Override public int read(byte[] buffer, int offset, int len) {\n-        inLine = true;\n-        try {\n-            int re = super.read(buffer, offset, len);\n-            return re;\n-        } catch(Exception e) {\n-            throw new RuntimeException(\"HumanInputStream error\");\n-        } finally {\n-            inLine = false;\n-        }\n-    }\n-    @Override public int available() {\n-        if(pos < length) return 1;\n-        return 0;\n-    }\n-\n-    \/\/ test part\n-    static void assertTrue(boolean bool) {\n-        if(!bool)\n-            throw new RuntimeException();\n-    }\n-\n-    public static void test() throws Exception {\n-\n-        class Tester {\n-            HumanInputStream is;\n-            BufferedReader reader;\n-            Tester(String s) {\n-                is = new HumanInputStream(s);\n-                reader = new BufferedReader(new InputStreamReader(is));\n-            }\n-\n-            \/\/ three kinds of test method\n-            \/\/ 1. read byte by byte from InputStream\n-            void testStreamReadOnce(int expection) throws Exception {\n-                assertTrue(is.read() == expection);\n-            }\n-            void testStreamReadMany(String expection) throws Exception {\n-                char[] keys = expection.toCharArray();\n-                for(int i=0; i<keys.length; i++) {\n-                    assertTrue(is.read() == keys[i]);\n-                }\n-            }\n-            \/\/ 2. read a line with a newly created Reader\n-            void testReaderReadline(String expection) throws Exception {\n-                String s = new BufferedReader(new InputStreamReader(is)).readLine();\n-                if(s == null) assertTrue(expection == null);\n-                else assertTrue(s.equals(expection));\n-            }\n-            \/\/ 3. read a line with the old Reader\n-            void testReaderReadline2(String expection) throws Exception  {\n-                String s = reader.readLine();\n-                if(s == null) assertTrue(expection == null);\n-                else assertTrue(s.equals(expection));\n-            }\n-        }\n-\n-        Tester test;\n-\n-        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n-        test.testReaderReadline(\"111\");\n-        test.testReaderReadline(\"222\");\n-        test.testReaderReadline(\"\");\n-        test.testReaderReadline(\"444\");\n-        test.testReaderReadline(\"\");\n-        test.testReaderReadline(null);\n-\n-        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n-        test.testReaderReadline2(\"111\");\n-        test.testReaderReadline2(\"222\");\n-        test.testReaderReadline2(\"\");\n-        test.testReaderReadline2(\"444\");\n-        test.testReaderReadline2(\"\");\n-        test.testReaderReadline2(null);\n-\n-        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n-        test.testReaderReadline2(\"111\");\n-        test.testReaderReadline(\"222\");\n-        test.testReaderReadline2(\"\");\n-        test.testReaderReadline2(\"444\");\n-        test.testReaderReadline(\"\");\n-        test.testReaderReadline2(null);\n-\n-        test = new Tester(\"1\\n2\");\n-        test.testStreamReadMany(\"1\\n2\");\n-        test.testStreamReadOnce(-1);\n-\n-        test = new Tester(\"12\\n234\");\n-        test.testStreamReadOnce('1');\n-        test.testReaderReadline(\"2\");\n-        test.testStreamReadOnce('2');\n-        test.testReaderReadline2(\"34\");\n-        test.testReaderReadline2(null);\n-\n-        test = new Tester(\"changeit\\n\");\n-        test.testStreamReadMany(\"changeit\\n\");\n-        test.testReaderReadline(null);\n-\n-        test = new Tester(\"changeit\\nName\\nCountry\\nYes\\n\");\n-        test.testStreamReadMany(\"changeit\\n\");\n-        test.testReaderReadline(\"Name\");\n-        test.testReaderReadline(\"Country\");\n-        test.testReaderReadline(\"Yes\");\n-        test.testReaderReadline(null);\n-\n-        test = new Tester(\"Me\\nHere\\n\");\n-        test.testReaderReadline2(\"Me\");\n-        test.testReaderReadline2(\"Here\");\n-    }\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/KeyToolTest.java","additions":3,"deletions":170,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @library \/test\/lib \/test\/jdk\/sun\/security\/pkcs11\n+ * @library \/test\/lib \/test\/jdk\/sun\/security\/pkcs11 \/java\/security\/testlibrary\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/NssTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8228969 8244087 8255266 8302182\n+ * @bug 8228969 8244087 8255266 8302182 8331864\n","filename":"test\/jdk\/sun\/security\/util\/RegisteredDomain\/ParseNames.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,0 +164,11 @@\n+# newGTLDs\n+\n+# This is not a GTLD\n+www.site.unknown        www.site.unknown    null\n+\n+# GTLD added in 1cbd6e7\n+www.site.wed            wed                 site.wed\n+\n+# GTLD removed in 1cbd6e7\n+www.site.oldnavy        www.site.oldnavy    null\n+\n","filename":"test\/jdk\/sun\/security\/util\/RegisteredDomain\/tests.dat","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,5 +24,0 @@\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n@@ -50,9 +45,0 @@\n-    private static final Map<String,Month> abbreviations\n-                                = new HashMap<String,Month>(12);\n-\n-    static {\n-        for (Month m : Month.values()) {\n-            abbreviations.put(m.abbr, m);\n-        }\n-    }\n-\n@@ -73,5 +59,16 @@\n-        Month m = abbreviations.get(name);\n-        if (m != null) {\n-            return m;\n-        }\n-        return null;\n+        int len = name.length();\n+\n+        if (name.regionMatches(true, 0, \"January\", 0, len)) return Month.JANUARY;\n+        if (name.regionMatches(true, 0, \"February\", 0, len)) return Month.FEBRUARY;\n+        if (name.regionMatches(true, 0, \"March\", 0, len)) return Month.MARCH;\n+        if (name.regionMatches(true, 0, \"April\", 0, len)) return Month.APRIL;\n+        if (name.regionMatches(true, 0, \"May\", 0, len)) return Month.MAY;\n+        if (name.regionMatches(true, 0, \"June\", 0, len)) return Month.JUNE;\n+        if (name.regionMatches(true, 0, \"July\", 0, len)) return Month.JULY;\n+        if (name.regionMatches(true, 0, \"August\", 0, len)) return Month.AUGUST;\n+        if (name.regionMatches(true, 0, \"September\", 0, len)) return Month.SEPTEMBER;\n+        if (name.regionMatches(true, 0, \"October\", 0, len)) return Month.OCTOBER;\n+        if (name.regionMatches(true, 0, \"November\", 0, len)) return Month.NOVEMBER;\n+        if (name.regionMatches(true, 0, \"December\", 0, len)) return Month.DECEMBER;\n+\n+        throw new IllegalArgumentException(\"Unknown month: \" + name);\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Month.java","additions":17,"deletions":20,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,5 +24,0 @@\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n@@ -37,7 +32,0 @@\n-    private static final Map<String,DayOfWeek> abbreviations = new HashMap<String,DayOfWeek>(7);\n-    static {\n-        for (DayOfWeek day : DayOfWeek.values()) {\n-            abbreviations.put(day.getAbbr(), day);\n-        }\n-    }\n-\n@@ -169,2 +157,12 @@\n-    private static DayOfWeek getDOW(String abbr) {\n-        return abbreviations.get(abbr);\n+    private static DayOfWeek getDOW(String name) {\n+        int len = name.length();\n+\n+        if (name.regionMatches(true, 0, \"Monday\", 0, len)) return DayOfWeek.MONDAY;\n+        if (name.regionMatches(true, 0, \"Tuesday\", 0, len)) return DayOfWeek.TUESDAY;\n+        if (name.regionMatches(true, 0, \"Wednesday\", 0, len)) return DayOfWeek.WEDNESDAY;\n+        if (name.regionMatches(true, 0, \"Thursday\", 0, len)) return DayOfWeek.THURSDAY;\n+        if (name.regionMatches(true, 0, \"Friday\", 0, len)) return DayOfWeek.FRIDAY;\n+        if (name.regionMatches(true, 0, \"Saturday\", 0, len)) return DayOfWeek.SATURDAY;\n+        if (name.regionMatches(true, 0, \"Sunday\", 0, len)) return DayOfWeek.SUNDAY;\n+\n+        throw new IllegalArgumentException(\"Unknown day-of-week: \" + name);\n@@ -175,1 +173,1 @@\n-     * name defined in {@link java.util.Calenda}.\n+     * name defined in {@link java.util.Calendar}.\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/RuleDay.java","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1,198 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-\n-# @test\n-# @bug 4212732\n-# @summary Test handling of the Class-Path attribute in jar file manifests\n-# @author Martin Buchholz\n-#\n-# @run shell Class-Path.sh\n-\n-# To run this test manually, simply do .\/Class-Path.sh\n-\n-. ${TESTSRC-.}\/Util.sh\n-\n-set -u\n-\n-Cleanup() {\n-    Sys rm -rf pkg Main.java Main.class Main.jar jars\n-    Sys rm -rf MANIFEST.MF A.jar B.zip\n-}\n-\n-Cleanup\n-Sys mkdir pkg\n-\n-#----------------------------------------------------------------\n-# Create mutually referential jar files\n-#----------------------------------------------------------------\n-cat >pkg\/A.java <<EOF\n-package pkg;\n-import pkg.B;\n-public class A {\n-    public static int f() { return B.g(); }\n-    public static int g() { return 0; }\n-}\n-EOF\n-\n-cat >pkg\/B.java <<EOF\n-package pkg;\n-import pkg.A;\n-public class B {\n-    public static int f() { return A.g(); }\n-    public static int g() { return 0; }\n-}\n-EOF\n-\n-Sys \"$javac\" ${TESTTOOLVMOPTS} pkg\/A.java pkg\/B.java\n-\n-MkManifestWithClassPath \"B.zip\"\n-Sys \"$jar\" cmf MANIFEST.MF A.jar pkg\/A.class\n-\n-MkManifestWithClassPath \"A.jar\"\n-Sys \"$jar\" cmf MANIFEST.MF B.zip pkg\/B.class\n-\n-cat >Main.java <<EOF\n-import pkg.*;\n-public class Main {\n-    public static void main(String []a) { System.exit(A.f() + B.f()); }\n-}\n-EOF\n-\n-Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"A.jar\" Main.java\n-Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"B.zip\" Main.java\n-Success \"$java\" ${TESTVMOPTS}  -cp \"A.jar${PS}.\" Main\n-Success \"$java\" ${TESTVMOPTS}  -cp \"B.zip${PS}.\" Main\n-\n-#----------------------------------------------------------------\n-# Jar file Class-Path expanded only for jars found on user class path\n-#----------------------------------------------------------------\n-Sys mkdir jars\n-Sys mv A.jar B.zip jars\/.\n-Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"jars\/A.jar\"       Main.java\n-Success \"$java\" ${TESTVMOPTS}  -cp \"jars\/A.jar${PS}.\" Main\n-\n-Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"jars\/B.zip\"       Main.java\n-Success \"$java\" ${TESTVMOPTS}  -cp \"jars\/B.zip${PS}.\" Main\n-\n-# Success \"$javac\" ${TESTTOOLVMOPTS} -extdirs \"jars\"        -cp None Main.java\n-# Success \"$javac\" ${TESTTOOLVMOPTS} -Djava.ext.dirs=\"jars\" -cp None Main.java\n-# Success \"$java\" ${TESTVMOPTS}  -Djava.ext.dirs=\"jars\" -cp .    Main\n-\n-# Success \"$javac\" ${TESTTOOLVMOPTS} -endorseddirs \"jars\"        -cp None Main.java\n-# Success \"$javac\" ${TESTTOOLVMOPTS} -Djava.endorsed.dirs=\"jars\" -cp None Main.java\n-# Success \"$java\" ${TESTVMOPTS}  -Djava.endorsed.dirs=\"jars\" -cp .    Main\n-\n-Failure \"$java\" ${TESTVMOPTS}  -Xbootclasspath\/p:\"jars\/A.jar\" -cp .    Main\n-Failure \"$java\" ${TESTVMOPTS}  -Xbootclasspath\/a:\"jars\/B.zip\" -cp .    Main\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -Xbootclasspath\/p:\"jars\/A.jar\" -cp None Main.java\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -Xbootclasspath\/a:\"jars\/B.zip\" -cp None Main.java\n-Sys mv jars\/A.jar jars\/B.zip .\n-\n-MkManifestWithClassPath \"A.jar\"\n-echo \"Main-Class: Main\" >> MANIFEST.MF\n-Sys \"$jar\" cmf MANIFEST.MF Main.jar Main.class\n-\n-Success \"$java\" ${TESTVMOPTS} -jar Main.jar\n-\n-MkManifestWithClassPath \".\"\n-Sys \"$jar\" cmf MANIFEST.MF A.jar pkg\/A.class\n-\n-Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"A.jar\" Main.java\n-Success \"$java\" ${TESTVMOPTS} -jar Main.jar\n-\n-MkManifestWithClassPath \"\"\n-Sys \"$jar\" cmf MANIFEST.MF A.jar pkg\/A.class\n-\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -cp \"A.jar\" Main.java\n-Failure \"$java\" ${TESTVMOPTS} -jar Main.jar\n-\n-#----------------------------------------------------------------\n-# Test new flag -e (application entry point)\n-#----------------------------------------------------------------\n-\n-cat > Hello.java <<EOF\n-import pkg.*;\n-public class Hello {\n-    public static void main(String []a) { System.out.println(\"Hello World!\"); }\n-}\n-EOF\n-\n-cat > Bye.java <<EOF\n-import pkg.*;\n-public class Bye {\n-    public static void main(String []a) { System.out.println(\"Good Bye!\"); }\n-}\n-EOF\n-\n-Success \"$javac\" ${TESTTOOLVMOPTS} Hello.java Bye.java\n-\n-# test jar creation without manifest\n-#\n-Success \"$jar\" cfe \"Hello.jar\" \"Hello\" Hello.class\n-Success \"$java\" ${TESTVMOPTS} -jar Hello.jar\n-\n-# test for overriding the manifest during jar creation\n-#\n-echo \"Main-Class: Hello\" >> MANIFEST.MF\n-\n-# test for error: \" 'e' flag and manifest with the 'Main-Class' \n-# attribute cannot be specified together, during creation\n-Failure \"$jar\" cmfe  MANIFEST.MF \"Bye.jar\" \"Bye\" Bye.class\n-\n-# test for overriding the manifest when updating the jar\n-#\n-Success \"$jar\" cfe \"greetings.jar\" \"Hello\" Hello.class\n-Success \"$jar\" ufe \"greetings.jar\" \"Bye\" Bye.class\n-Success \"$java\" ${TESTVMOPTS} -jar greetings.jar\n-\n-# test for error: \" 'e' flag and manifest with the 'Main-Class'\n-# attribute cannot be specified together, during update\n-Failure \"$jar\" umfe  MANIFEST.MF \"greetings.jar\" \"Hello\"\n-\n-# test jar updation when there are no inputfiles \n-#\n-Success \"$jar\" ufe \"Hello.jar\" \"Bye\"\n-Failure \"$java\" ${TESTVMOPTS} -jar Hello.jar\n-Success \"$jar\" umf  MANIFEST.MF \"Hello.jar\"\n-\n-# test creating jar when the to-be-archived files\n-# do not contain the specified main class, there is no check done\n-# for the presence of the main class, so the test will pass\n-#\n-Success \"$jar\" cfe \"Hello.jar\" \"Hello\" Bye.class\n-\n-# Jar creation and update when there is no manifest and inputfiles \n-# specified\n-Failure \"$jar\" cvf \"A.jar\"\n-Failure \"$jar\" uvf \"A.jar\"\n-\n-# error: no such file or directory\n-Failure \"$jar\" cvf \"A.jar\" non-existing.file\n-Failure \"$jar\" uvf \"A.jar\" non-existing.file\n-\n-Cleanup\n-\n-Bottom Line\n","filename":"test\/langtools\/tools\/javac\/Paths\/Class-Path.sh","additions":0,"deletions":198,"binary":false,"changes":198,"status":"deleted"},{"patch":"@@ -1,111 +0,0 @@\n-#!\/bin\/sh\n-#\n-# Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# @test \n-# @bug 4212732 6485027\n-# @summary Test handling of the Class-Path attribute in jar file manifests\n-# @author Martin Buchholz\n-#\n-# @run shell Class-Path2.sh\n-\n-# To run this test manually, simply do .\/Class-Path2.sh\n-\n-. ${TESTSRC-.}\/Util.sh\n-\n-set -u\n-\n-Cleanup() {\n-    Sys rm -rf pkg Main.java Main.class Main.jar jars\n-    Sys rm -rf MANIFEST.MF A.jar B.zip\n-}\n-\n-Cleanup\n-Sys mkdir pkg\n-\n-#----------------------------------------------------------------\n-# Create mutually referential jar files\n-#----------------------------------------------------------------\n-cat >pkg\/A.java <<EOF\n-package pkg;\n-import pkg.B;\n-public class A {\n-    public static int f() { return B.g(); }\n-    public static int g() { return 0; }\n-}\n-EOF\n-\n-cat >pkg\/B.java <<EOF\n-package pkg;\n-import pkg.A;\n-public class B {\n-    public static int f() { return A.g(); }\n-    public static int g() { return 0; }\n-}\n-EOF\n-\n-Sys \"$javac\" pkg\/A.java pkg\/B.java\n-\n-MkManifestWithClassPath \".\/sub\/B.zip\"\n-Sys \"$jar\" cmf MANIFEST.MF A.jar pkg\/A.class\n-\n-MkManifestWithClassPath \"..\/A.jar\"\n-Sys \"$jar\" cmf MANIFEST.MF B.zip pkg\/B.class\n-\n-cat >Main.java <<EOF\n-import pkg.*;\n-public class Main {\n-    public static void main(String []a) { System.exit(A.f() + B.f()); }\n-}\n-EOF\n-\n-Sys rm -rf pkg\n-\n-Sys mkdir jars\n-Sys mkdir jars\/sub\/\n-Sys mv A.jar jars\/.\n-Sys mv B.zip jars\/sub\/.\n-\n-#\n-# Test 1: Compiling \n-#\n-\n-Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"jars\/A.jar\" Main.java\n-Success \"$java\"  ${TESTVMOPTS}     -cp \"jars\/A.jar${PS}.\" Main\n-\n-Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"jars\/sub\/B.zip\"       Main.java\n-Success \"$java\"  ${TESTVMOPTS}     -cp \"jars\/sub\/B.zip${PS}.\" Main\n-\n-#\n-# Test 2: Use of extension directories is incorrect\n-#\n-\n-# Success \"$javac\" ${TESTTOOLVMOPTS} -extdirs jars          -cp None Main.java\n-# Success \"$java\"  ${TESTVMOPTS}     -Djava.ext.dirs=\"jars\" -cp .    Main\n-\n-# Success \"$javac\" ${TESTTOOLVMOPTS} -extdirs jars\/sub          -cp None Main.java\n-# Success \"$java\"  ${TESTVMOPTS}     -Djava.ext.dirs=\"jars\/sub\" -cp .    Main\n-\n-Cleanup\n-\n-Bottom Line\n","filename":"test\/langtools\/tools\/javac\/Paths\/Class-Path2.sh","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 4212732 8293877\n+ * @summary Test handling of the Class-Path attribute in jar file manifests\n+ * @library \/tools\/lib\n+ * @build toolbox.ToolBox Util ClassPath\n+ * @run main ClassPath\n+*\/\n+\n+\n+\/*\n+ * Converted from Class-Path.sh, originally written by Martin Buchholz.\n+ *\n+ * For the last version of the original, Class-Path.sh, see\n+ * https:\/\/git.openjdk.org\/jdk\/blob\/jdk-19%2B36\/test\/langtools\/tools\/javac\/Paths\/Class-Path.sh\n+ *\n+ * This class primarily tests that the Class-Path attribute in jar files\n+ * is handled the same way by javac and java. It also has various tests\n+ * of the jar tool itself.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+\n+public class ClassPath extends Util {\n+    public static void main(String... args) throws Exception {\n+        new ClassPath().run(args);\n+    }\n+\n+    void run(String... args) throws Exception {\n+        setup();\n+        tests();\n+        cleanup();\n+        bottomLine();\n+    }\n+\n+    void setup() throws Exception {\n+        cleanup();\n+        tb.createDirectories(\"pkg\");\n+\n+        \/*----------------------------------------------------------------\n+         * Create mutually referential jar files\n+         *----------------------------------------------------------------*\/\n+\n+        Files.writeString(Path.of(\"pkg\/A.java\"), \"\"\"\n+                package pkg;\n+                import pkg.B;\n+                public class A {\n+                    public static int f() { return B.g(); }\n+                    public static int g() { return 0; }\n+                }\n+                \"\"\");\n+        Files.writeString(Path.of(\"pkg\/B.java\"), \"\"\"\n+                package pkg;\n+                import pkg.A;\n+                public class B {\n+                    public static int f() { return A.g(); }\n+                    public static int g() { return 0; }\n+                }\n+                \"\"\");\n+\n+        javac(\"pkg\/A.java\", \"pkg\/B.java\");\n+\n+        makeManifestWithClassPath(\"B.zip\");\n+        jar(\"cmf\", \"MANIFEST.MF\", \"A.jar\", \"pkg\/A.class\");\n+\n+        makeManifestWithClassPath(\"A.jar\");\n+        jar(\"cmf\", \"MANIFEST.MF\", \"B.zip\", \"pkg\/B.class\");\n+\n+        Files.writeString(Path.of(\"Main.java\"), \"\"\"\n+                import pkg.*;\n+                public class Main {\n+                    public static void main(String[] a) { System.exit(A.f() + B.f()); }\n+                }\n+                \"\"\");\n+    }\n+\n+    void cleanup() throws IOException {\n+        deleteFiles(\"pkg\", \"Main.java\", \"Main.class\", \"Main.jar\", \"jars\");\n+        deleteFiles(\"MANIFEST.MF\", \"A.jar\", \"B.zip\");\n+    }\n+\n+    void tests() throws Exception {\n+        expectPass(JAVAC, \"-cp A.jar Main.java\");\n+        expectPass(JAVAC, \"-cp B.zip Main.java\");\n+        expectPass(JAVA, \"-cp A.jar${PS}. Main\");\n+        expectPass(JAVA, \"-cp B.zip${PS}. Main\");\n+\n+        \/*----------------------------------------------------------------\n+         * Jar file Class-Path expanded only for jars found on user class path\n+         *----------------------------------------------------------------*\/\n+\n+        tb.createDirectories(\"jars\");\n+        moveFiles(List.of(\"A.jar\", \"B.zip\"), \"jars\/.\");\n+\n+        expectPass(JAVAC, \"-cp jars\/A.jar Main.java\");\n+        expectPass(JAVA, \"-cp jars\/A.jar${PS}. Main\");\n+\n+        expectPass(JAVAC, \"-cp jars\/B.zip Main.java\");\n+        expectPass(JAVA, \"-cp jars\/B.zip${PS}. Main\");\n+\n+        expectFail(JAVA, \"-Xbootclasspath\/p:jars\/A.jar -cp .    Main\");\n+        expectFail(JAVA, \"-Xbootclasspath\/a:jars\/B.zip -cp .    Main\");\n+        expectFail(JAVAC, \"-Xbootclasspath\/p:jars\/A.jar -cp None Main.java\");\n+        expectFail(JAVAC, \"-Xbootclasspath\/a:jars\/B.zip -cp None Main.java\");\n+        moveFiles(List.of(\"jars\/A.jar\", \"jars\/B.zip\"), \".\");\n+\n+        makeManifestWithClassPath(\"A.jar\");\n+        Files.writeString(Path.of(\"MANIFEST.MF\"), \"Main-Class: Main\\n\", StandardOpenOption.APPEND);\n+        jar(\"cmf\", \"MANIFEST.MF\", \"Main.jar\", \"Main.class\");\n+\n+        expectPass(JAVA, \"-jar Main.jar\");\n+\n+        makeManifestWithClassPath(\".\");\n+        jar(\"cmf\", \"MANIFEST.MF\", \"A.jar\", \"pkg\/A.class\");\n+\n+        expectPass(JAVAC, \"-cp A.jar Main.java\");\n+        expectPass(JAVA, \"-jar Main.jar\");\n+\n+        makeManifestWithClassPath(\"\");\n+        jar(\"cmf\", \"MANIFEST.MF\", \"A.jar\", \"pkg\/A.class\");\n+\n+        expectFail(JAVAC, \"-cp A.jar Main.java\");\n+        expectFail(JAVA, \"-jar Main.jar\");\n+\n+        \/*----------------------------------------------------------------\n+         * Test new flag -e (application entry point)\n+         *----------------------------------------------------------------*\/\n+\n+        Files.writeString(Path.of(\"Hello.java\"), \"\"\"\n+                import pkg.*;\n+                public class Hello {\n+                    public static void main(String[] a) { System.out.println(\"Hello World!\"); }\n+                }\n+                \"\"\");\n+\n+        Files.writeString(Path.of(\"Bye.java\"), \"\"\"\n+                import pkg.*;\n+                public class Bye {\n+                    public static void main(String[] a) { System.out.println(\"Good Bye!\"); }\n+                }\n+                \"\"\");\n+\n+        \/\/ Set an empty classpath to override any inherited setting of CLASSPATH\n+        expectPass(classpath(\"\"), JAVAC, \"Hello.java Bye.java\");\n+\n+        \/\/ test jar creation without manifest\n+        \/\/\n+        expectPass(JAR, \"cfe Hello.jar Hello Hello.class\");\n+        expectPass(JAVA, \"-jar Hello.jar\");\n+\n+        \/\/ test for overriding the manifest during jar creation\n+        \/\/\n+        Files.writeString(Path.of(\"MANIFEST.MF\"), \"Main-Class: Hello\\n\", StandardOpenOption.APPEND);\n+\n+        \/\/ test for error: \" 'e' flag and manifest with the 'Main-Class'\n+        \/\/ attribute cannot be specified together, during creation\n+        expectFail(JAR, \"cmfe MANIFEST.MF Bye.jar Bye Bye.class\");\n+\n+        \/\/ test for overriding the manifest when updating the jar\n+        \/\/\n+        expectPass(JAR, \"cfe greetings.jar Hello Hello.class\");\n+        expectPass(JAR, \"ufe greetings.jar Bye Bye.class\");\n+        expectPass(JAVA, \"-jar greetings.jar\");\n+\n+        \/\/ test for error: \" 'e' flag and manifest with the 'Main-Class'\n+        \/\/ attribute cannot be specified together, during update\n+        expectFail(JAR, \"umfe MANIFEST.MF greetings.jar Hello\");\n+\n+        \/\/ test jar update when there are no input files\n+        expectPass(JAR, \"ufe Hello.jar Bye\");\n+        expectFail(JAVA, \"-jar Hello.jar\");\n+        expectPass(JAR, \"umf MANIFEST.MF Hello.jar\");\n+\n+        \/\/ test creating jar when the to-be-archived files\n+        \/\/ do not contain the specified main class, there is no check done\n+        \/\/ for the presence of the main class, so the test will pass\n+        \/\/\n+        expectPass(JAR, \"cfe Hello.jar Hello Bye.class\");\n+\n+        \/\/ Jar creation and update when there is no manifest and inputfiles\n+        \/\/ specified\n+        expectFail(JAR, \"cvf A.jar\");\n+        expectFail(JAR, \"uvf A.jar\");\n+\n+        \/\/ error: no such file or directory\n+        expectFail(JAR, \"cvf A.jar non-existing.file\");\n+        expectFail(JAR, \"uvf A.jar non-existing.file\");\n+\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/Paths\/ClassPath.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4212732 6485027 8293877\n+ * @summary Test handling of the Class-Path attribute in jar file manifests\n+ * @library \/tools\/lib\n+ * @build toolbox.ToolBox Util ClassPath\n+ * @run main ClassPath2\n+ *\/\n+\n+\/*\n+ * Converted from Class-Path2.sh, originally written by Martin Buchholz.\n+ *\n+ * For the last version of the original, Class-Path2.sh, see\n+ * https:\/\/git.openjdk.org\/jdk\/blob\/jdk-19%2B36\/test\/langtools\/tools\/javac\/Paths\/Class-Path2.sh\n+ *\n+ * This class provides additional tests for the Class-Path attribute in jar\n+ * files, when the entries are not in the same directory.\n+ *\/\n+\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class ClassPath2 extends Util {\n+    public static void main(String... args) throws Exception {\n+        new ClassPath2().run(args);\n+    }\n+\n+    void run(String... args) throws Exception {\n+        setup();\n+        tests();\n+        cleanup();\n+        bottomLine();\n+    }\n+\n+    void setup() throws Exception {\n+        cleanup();\n+\n+        tb.createDirectories(\"pkg\");\n+\n+        \/*----------------------------------------------------------------\n+         * Create mutually referential jar files\n+         *----------------------------------------------------------------*\/\n+\n+        Files.writeString(Path.of(\"pkg\/A.java\"), \"\"\"\n+                package pkg;\n+                import pkg.B;\n+                public class A {\n+                    public static int f() { return B.g(); }\n+                    public static int g() { return 0; }\n+                }\n+                \"\"\");\n+        Files.writeString(Path.of(\"pkg\/B.java\"), \"\"\"\n+                package pkg;\n+                import pkg.A;\n+                public class B {\n+                    public static int f() { return A.g(); }\n+                    public static int g() { return 0; }\n+                }\n+                \"\"\");\n+\n+        javac(\"pkg\/A.java\", \"pkg\/B.java\");\n+\n+        makeManifestWithClassPath(\".\/sub\/B.zip\");\n+        jar(\"cmf\", \"MANIFEST.MF\", \"A.jar\", \"pkg\/A.class\");\n+\n+        makeManifestWithClassPath(\"..\/A.jar\");\n+        jar(\"cmf\", \"MANIFEST.MF\", \"B.zip\", \"pkg\/B.class\");\n+\n+        Files.writeString(Path.of(\"Main.java\"), \"\"\"\n+                import pkg.*;\n+                public class Main {\n+                    public static void main(String[] a) { System.exit(A.f() + B.f()); }\n+                }\n+                \"\"\");\n+\n+        deleteFiles(\"pkg\");\n+        tb.createDirectories(\"jars\");\n+        tb.createDirectories(\"jars\/sub\");\n+        tb.moveFile(\"A.jar\", \"jars\/.\");\n+        tb.moveFile(\"B.zip\", \"jars\/sub\/.\");\n+    }\n+\n+    void cleanup() throws IOException {\n+        deleteFiles(\"pkg\", \"Main.java\", \"Main.class\", \"Main.jar\", \"jars\");\n+        deleteFiles(\"MANIFEST.MF\", \"A.jar\", \"B.zip\");\n+    }\n+\n+    void tests() throws Exception {\n+\n+        \/*\n+         * Test 1: Compiling\n+         *\/\n+\n+        expectPass(JAVAC, \"-cp jars\/A.jar Main.java\");\n+        expectPass(JAVA, \"-cp jars\/A.jar${PS}. Main\");\n+\n+        expectPass(JAVAC, \"-cp jars\/sub\/B.zip Main.java\");\n+        expectPass(JAVA, \"-cp jars\/sub\/B.zip${PS}. Main\");\n+\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/Paths\/ClassPath2.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4884487 6295519 6236704 6429613 8293877\n+ * @summary Test for proper diagnostics during path manipulation operations\n+ * @library \/tools\/lib\n+ * @build toolbox.ToolBox Util Diagnostics\n+ * @run main Diagnostics\n+ *\/\n+\n+\n+\/*\n+ * Converted from Diagnostics.sh, originally written by Martin Buchholz.\n+ *\n+ * For the last version of the original, Diagnostics.sh, see\n+ * https:\/\/git.openjdk.org\/jdk\/blob\/jdk-19%2B36\/test\/langtools\/tools\/javac\/Paths\/Diagnostics.sh\n+ *\n+ * This class primarily tests that javac generates warnings or errors\n+ * as appropriate for various input conditions.\n+ *\n+ * Note: only the {@code warning:} or {@code error:} prefixes are checked,\n+ * and not the subsequent text of the diagnostic.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Locale;\n+\n+public class Diagnostics extends Util {\n+    public static void main(String... args) throws Exception {\n+        new Diagnostics().run(args);\n+    }\n+\n+    void run(String... args) throws Exception{\n+        setup();\n+\n+        Locale prev = Locale.getDefault();\n+        Locale.setDefault(Locale.US); \/\/ diagnostics in English, please!\n+        try {\n+            tests();\n+        } finally {\n+            Locale.setDefault(prev);\n+        }\n+\n+        cleanup();\n+        bottomLine();\n+    }\n+\n+    void setup() throws IOException {\n+        cleanup();\n+        Files.writeString(Path.of(\"Main.java\"), \"public class Main{public static void main(String[]a){}}\");\n+    }\n+\n+    void cleanup() throws IOException {\n+        deleteFiles(\"Main.java\", \"Main.class\");\n+        deleteFiles(\"classes\", \"classes.foo\", \"classes.jar\", \"classes.war\", \"classes.zip\");\n+        deleteFiles(\"MANIFEST.MF\", \"classesRef.jar\", \"classesRefRef.jar\", \"jars\");\n+    }\n+\n+    void tests() throws Exception {\n+        \/*----------------------------------------------------------------\n+         * No warnings unless -Xlint:path is used\n+         *----------------------------------------------------------------*\/\n+        checkWarning(false, \"Main.java\");\n+        checkWarning(false, \"-cp .${PS}classes Main.java\");\n+\n+        \/*----------------------------------------------------------------\n+         * Warn for missing elts in user-specified paths\n+         *----------------------------------------------------------------*\/\n+\n+        \/\/ use --source 8 -target 8 with bootclasspath-related options\n+        String JDK8 = \"-source 8 -target 8 -Xlint:-options \";\n+        checkWarning(true, \"-Xlint:path -cp .${PS}classes         Main.java\");\n+        checkWarning(true, JDK8 + \"-Xlint:path -Xbootclasspath\/p:classes Main.java\");\n+        checkWarning(true, JDK8 + \"-Xlint      -Xbootclasspath\/a:classes Main.java\");\n+\n+        checkWarning(true, JDK8 + \"-Xlint:-options -Xlint:path -endorseddirs classes   Main.java\");\n+        checkWarning(true, JDK8 + \"-Xlint:-options -Xlint      -extdirs      classes   Main.java\");\n+\n+        \/*----------------------------------------------------------------\n+         * No warning for missing elts in \"system\" paths\n+         *----------------------------------------------------------------*\/\n+        \/\/ TODO? there are system paths we could check, such as --module-path\n+\n+        \/*----------------------------------------------------------------\n+         * No warning if class path element exists\n+         *----------------------------------------------------------------*\/\n+        tb.createDirectories(\"classes\");\n+\n+        checkWarning(false, \"-Xlint:path -cp .${PS}classes         Main.java\");\n+        checkWarning(false, JDK8 + \"-Xlint:path -endorseddirs  classes Main.java\");\n+        checkWarning(false, JDK8 + \"-Xlint:path -extdirs       classes Main.java\");\n+        checkWarning(false, JDK8 + \"-Xlint:path -Xbootclasspath\/p:classes Main.java\");\n+        checkWarning(false, JDK8 + \"-Xlint:path -Xbootclasspath\/a:classes Main.java\");\n+\n+        jar(\"cf\", \"classes.jar\", \"Main.class\");\n+        tb.copyFile(\"classes.jar\", \"classes.war\");\n+        tb.copyFile(\"classes.war\", \"classes.zip\");\n+        checkWarning(false, \"-Xlint:path -cp .${PS}classes.jar     Main.java\");\n+        checkWarning(true,  \"-Xlint:path -cp .${PS}classes.war     Main.java\");\n+        checkWarning(false, \"-Xlint:path -cp .${PS}classes.zip     Main.java\");\n+\n+        \/*----------------------------------------------------------------\n+         * Warn if -Xlint is used and if class path element refers to\n+         * regular file which doesn't look like a zip file, but is\n+         *----------------------------------------------------------------*\/\n+        tb.copyFile(\"classes.war\", \"classes.foo\");\n+        checkWarning(true, \"-Xlint:path -cp .${PS}classes.foo     Main.java\");\n+\n+        \/*----------------------------------------------------------------\n+         * No error if class path element refers to regular file which is\n+         * not a zip file\n+         *----------------------------------------------------------------*\/\n+        checkError(false, \"-cp Main.java Main.java\"); \/\/ Main.java is NOT a jar file\n+        checkError(false, \"Main.java\");\n+\n+        \/*----------------------------------------------------------------\n+         * Warn if -Xlint is used and if class path element refers to\n+         * regular file which is not a zip file\n+         *----------------------------------------------------------------*\/\n+        checkWarning(true, \"-Xlint -cp Main.java Main.java\"); \/\/ Main.java is NOT a jar file\n+\n+        \/*----------------------------------------------------------------\n+         * Test jar file class path reference recursion\n+         *----------------------------------------------------------------*\/\n+        makeManifestWithClassPath(\"classesRef.jar\");\n+        jar(\"cmf\", \"MANIFEST.MF\", \"classesRefRef.jar\", \"Main.class\");\n+\n+        \/*----------------------------------------------------------------\n+         * Non-existent recursive Class-Path reference gives warning\n+         *----------------------------------------------------------------*\/\n+        checkWarning(false, \"                   -classpath   classesRefRef.jar Main.java\");\n+        checkWarning(true, \"        -Xlint      -classpath   classesRefRef.jar Main.java\");\n+        checkWarning(false, JDK8 + \"-Xlint -Xbootclasspath\/p:classesRefRef.jar Main.java\");\n+\n+        createBadJarFiles(\"classesRef.jar\");\n+\n+        \/*----------------------------------------------------------------\n+         * Non-jar file recursive Class-Path reference gives error\n+         *----------------------------------------------------------------*\/\n+\n+        checkError(true, \"        -classpath        classesRefRef.jar Main.java\");\n+        checkError(false, JDK8 + \"-Xbootclasspath\/a:classesRefRef.jar Main.java\");\n+\n+        makeManifestWithClassPath(\"classes\");\n+        jar(\"cmf\", \"MANIFEST.MF\", \"classesRef.jar\", \"Main.class\");\n+\n+        \/*----------------------------------------------------------------\n+         * Jar file recursive Class-Path reference is OK\n+         *----------------------------------------------------------------*\/\n+        checkWarning(false, \"       -Xlint      -classpath   classesRefRef.jar Main.java\");\n+        checkWarning(false, JDK8 + \"-Xlint -Xbootclasspath\/p:classesRefRef.jar Main.java\");\n+\n+\n+        \/*----------------------------------------------------------------\n+         * Class-Path attribute followed in extdirs or endorseddirs\n+         *----------------------------------------------------------------*\/\n+        tb.createDirectories(\"jars\");\n+        tb.copyFile(\"classesRefRef.jar\", \"jars\/.\");\n+        checkWarning(true, JDK8 + \"-Xlint -extdirs      jars Main.java\");\n+        checkWarning(true, JDK8 + \"-Xlint -endorseddirs jars Main.java\");\n+\n+        \/*----------------------------------------------------------------\n+         * Bad Jar file in extdirs and endorseddirs should not be ignored\n+         *----------------------------------------------------------------*\/\n+        createBadJarFiles(\"jars\/classesRef.jar\");\n+        checkError(true, JDK8 + \"-Xlint -extdirs      jars Main.java\");\n+        checkError(true, JDK8 + \"-Xlint -endorseddirs jars Main.java\");\n+    }\n+\n+    void checkWarning(boolean expect, String args) throws Exception {\n+        Result result = javac(splitArgs(args));\n+        int exitCode = result.exitCode();\n+        if (exitCode != 0) {\n+            throw new Exception(\"javac failed: exit code \" + exitCode);\n+        }\n+        String output = result.out();\n+        if (output.contains(\"warning:\")) {\n+            if (!expect) {\n+                out.println(\"FAIL: Command 'javac \" + args + \"' printed an unexpected warning\");\n+                failCount++;\n+            } else {\n+                passCount++;\n+            }\n+        } else {\n+            if (expect) {\n+                out.println(\"FAIL: Command 'javac \" + args + \"' did not generate the expected warning\");\n+                failCount++;\n+            } else {\n+                passCount++;\n+            }\n+        }\n+    }\n+\n+    void checkError(boolean expect, String args) throws Exception {\n+        Result result = javac(splitArgs(args));\n+        int exitCode = result.exitCode();\n+        boolean ok = true;\n+        if (expect) {\n+            if (exitCode == 0) {\n+                out.println(\"FAIL: Command 'javac \" + args + \" was supposed to exit with non-zero return code\");\n+                ok = false;\n+            }\n+            if (!result.out().contains(\"error:\")) {\n+                out.println(\"FAIL: Command 'javac \" + args + \" did not generate any error message\");\n+                ok = false;\n+            }\n+        } else {\n+            if (exitCode != 0) {\n+                out.println(\"FAIL: Command 'javac \" + args + \" failed with a non-zero return code\");\n+                ok = false;\n+            }\n+            if (result.out().contains(\"error:\")) {\n+                out.println(\"FAIL: Command 'javac \" + args + \" printed an unexpected error message\");\n+                ok = false;\n+            }\n+        }\n+        if (ok) {\n+            passCount++;\n+        } else {\n+            failCount++;\n+        }\n+    }\n+\n+    void createBadJarFiles(String... paths) throws IOException {\n+        for (String p : paths) {\n+            Files.writeString(Path.of(p), \"not a jar file\\n\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/Paths\/Diagnostics.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -1,210 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-# @test\n-# @bug 4884487 6295519 6236704 6429613\n-# @summary Test for proper diagnostics during path manipulation operations\n-# @author Martin Buchholz\n-#\n-# @run shell\/timeout=180 Diagnostics.sh\n-\n-# To run this test manually, simply do .\/Diagnostics.sh\n-\n-. ${TESTSRC-.}\/Util.sh\n-\n-set -u\n-\n-# BCP=`DefaultBootClassPath`\n-\n-DiagnosticsInEnglishPlease\n-\n-No() { NO=\"no\"; \"$@\"; NO=\"\"; }  # No means NO!\n-\n-Warning() {\n-    HorizontalRule\n-    echo \"$@\"\n-    output=`\"$@\" 2>&1`; rc=\"$?\"\n-    output2=`echo \"$output\" | grep -v \"bootstrap class path not set in conjunction with -source\"`\n-    test -n \"$output2\" && echo \"$output\"\n-    test $rc -eq 0 || Fail \"Command \\\"$*\\\" failed with exitValue $rc\";\n-    case \"$output2\" in *warning:*) gotwarning=\"yes\";; *) gotwarning=\"no\";; esac\n-\n-    if test \"$gotwarning\" = \"yes\" -a \"$NO\" = \"no\"; then\n-        Fail \"Command \\\"$*\\\" printed an unexpected warning\"\n-    elif test \"$gotwarning\" = \"no\" -a \"$NO\" != \"no\"; then\n-        Fail \"Command \\\"$*\\\" did not generate the expected warning\"\n-    fi\n-}\n-\n-Error() {\n-    HorizontalRule\n-    echo \"$@\"\n-    output=`\"$@\" 2>&1`; rc=\"$?\"\n-    test -n \"$output\" && echo \"$output\"\n-    case \"$output\" in *error:*) goterror=\"yes\";; *) goterror=\"no\";; esac\n-\n-    if test \"$NO\" = \"no\"; then\n-        test \"$rc\" -ne 0 && \\\n-            Fail \"Command \\\"$*\\\" failed with return code $rc\"\n-        test \"$goterror\" = \"yes\" && \\\n-            Fail \"Command \\\"$*\\\" did not generate any error message\"\n-    else\n-        test \"$rc\" -eq 0 && \\\n-            Fail \"Command \\\"$*\\\" was supposed to Die with fatal error\";\n-        test \"$goterror\" = \"no\" && \\\n-            Fail \"Command \\\"$*\\\" printed an unexpected error message\"\n-    fi\n-}\n-\n-Cleanup() {\n-    Sys rm -rf Main.java Main.class\n-    Sys rm -rf classes classes.foo classes.jar classes.war classes.zip\n-    Sys rm -rf MANIFEST.MF classesRef.jar classesRefRef.jar jars\n-}\n-\n-Cleanup\n-echo \"public class Main{public static void main(String[]a){}}\" > Main.java\n-\n-# We need to set -source 8 -target 8 for those cases where the option is\n-# not legal in 9 and later. However, that triggers an additional warning\n-# about not setting bootclasspath, which is filtered out in Warning.\n-# The alternative would be to extract a minimal rt.jar from JDK and\n-# specify that with -bootclasspath.\n-SRCTRG8=\"-source 8 -target 8\"\n-\n-#----------------------------------------------------------------\n-# No warnings unless -Xlint:path is used\n-#----------------------------------------------------------------\n-No Warning \"$javac\" ${TESTTOOLVMOPTS} Main.java\n-No Warning \"$javac\" ${TESTTOOLVMOPTS} -cp \".${PS}classes\" Main.java\n-\n-#----------------------------------------------------------------\n-# Warn for missing elts in user-specified paths\n-#----------------------------------------------------------------\n-Warning \"$javac\" ${TESTTOOLVMOPTS}           -Xlint:path -cp \".${PS}classes\"         Main.java\n-Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint:path \"-Xbootclasspath\/p:classes\" Main.java\n-Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint      \"-Xbootclasspath\/a:classes\" Main.java\n-\n-Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint:path \"-endorseddirs\" \"classes\"   Main.java\n-Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint      \"-extdirs\"      \"classes\"   Main.java\n-#Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint:path \"-Xbootclasspath:classes${PS}${BCP}\" Main.java\n-\n-#----------------------------------------------------------------\n-# No warning for missing elts in \"system\" paths\n-#----------------------------------------------------------------\n-# No Warning \"$javac\" ${TESTTOOLVMOPTS} -Xlint:path \"-J-Djava.endorsed.dirs=classes\" Main.java\n-# No Warning \"$javac\" ${TESTTOOLVMOPTS} -Xlint:path \"-J-Djava.ext.dirs=classes\"      Main.java\n-# No Warning \"$javac\" ${TESTTOOLVMOPTS} -Xlint:path \"-J-Xbootclasspath\/p:classes\"    Main.java\n-# No Warning \"$javac\" ${TESTTOOLVMOPTS} -Xlint:path \"-J-Xbootclasspath\/a:classes\"    Main.java\n-# No Warning \"$javac\" ${TESTTOOLVMOPTS} -Xlint:path \"-J-Xbootclasspath:classes${PS}${BCP}\" Main.java\n-\n-#----------------------------------------------------------------\n-# No warning if class path element exists\n-#----------------------------------------------------------------\n-Sys mkdir classes\n-No Warning \"$javac\" ${TESTTOOLVMOPTS}           -Xlint:path -cp \".${PS}classes\"         Main.java\n-No Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint:path \"-endorseddirs\"   \"classes\" Main.java\n-No Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint:path \"-extdirs\"        \"classes\" Main.java\n-No Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint:path \"-Xbootclasspath\/p:classes\" Main.java\n-No Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint:path \"-Xbootclasspath\/a:classes\" Main.java\n-#No Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint:path \"-Xbootclasspath:classes${PS}${BCP}\" Main.java\n-\n-Sys \"$jar\" cf classes.jar Main.class\n-Sys cp classes.jar classes.war\n-Sys cp classes.war classes.zip\n-No Warning \"$javac\" ${TESTTOOLVMOPTS} -Xlint:path -cp \".${PS}classes.jar\"     Main.java\n-   Warning \"$javac\" ${TESTTOOLVMOPTS} -Xlint:path -cp \".${PS}classes.war\"     Main.java\n-No Warning \"$javac\" ${TESTTOOLVMOPTS} -Xlint:path -cp \".${PS}classes.zip\"     Main.java\n-\n-#----------------------------------------------------------------\n-# Warn if -Xlint is used and if class path element refers to\n-# regular file which doesn't look like a zip file, but is\n-#----------------------------------------------------------------\n-Sys cp classes.war classes.foo\n-   Warning \"$javac\" ${TESTTOOLVMOPTS} -Xlint:path -cp \".${PS}classes.foo\"     Main.java\n-\n-\n-#----------------------------------------------------------------\n-# No error if class path element refers to regular file which is\n-# not a zip file\n-#----------------------------------------------------------------\n-No Error \"$javac\" ${TESTTOOLVMOPTS} -cp Main.java Main.java # Main.java is NOT a jar file\n-No Error \"$javac\" ${TESTTOOLVMOPTS} Main.java\n-\n-#----------------------------------------------------------------\n-# Warn if -Xlint is used and if class path element refers to\n-# regular file which is not a zip file\n-#----------------------------------------------------------------\n-Warning \"$javac\" ${TESTTOOLVMOPTS} -Xlint -cp Main.java Main.java # Main.java is NOT a jar file\n-\n-#----------------------------------------------------------------\n-# Test jar file class path reference recursion\n-#----------------------------------------------------------------\n-MkManifestWithClassPath classesRef.jar\n-Sys \"$jar\" cmf MANIFEST.MF classesRefRef.jar Main.class\n-\n-#----------------------------------------------------------------\n-# Non-existent recursive Class-Path reference gives warning\n-#----------------------------------------------------------------\n-No Warning \"$javac\" ${TESTTOOLVMOPTS}                        -classpath   classesRefRef.jar Main.java\n-   Warning \"$javac\" ${TESTTOOLVMOPTS}            -Xlint      -classpath   classesRefRef.jar Main.java\n-No Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint -Xbootclasspath\/p:classesRefRef.jar Main.java\n-\n-BadJarFile classesRef.jar\n-\n-#----------------------------------------------------------------\n-# Non-jar file recursive Class-Path reference gives error\n-#----------------------------------------------------------------\n-   Error \"$javac\" ${TESTTOOLVMOPTS}            -classpath        classesRefRef.jar Main.java\n-No Error \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xbootclasspath\/a:classesRefRef.jar Main.java\n-\n-MkManifestWithClassPath classes\n-Sys \"$jar\" cmf MANIFEST.MF classesRef.jar Main.class\n-\n-#----------------------------------------------------------------\n-# Jar file recursive Class-Path reference is OK\n-#----------------------------------------------------------------\n-No Warning \"$javac\" ${TESTTOOLVMOPTS}            -Xlint      -classpath   classesRefRef.jar Main.java\n-No Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint -Xbootclasspath\/p:classesRefRef.jar Main.java\n-\n-#----------------------------------------------------------------\n-# Class-Path attribute followed in extdirs or endorseddirs\n-#----------------------------------------------------------------\n-Sys mkdir jars\n-Sys cp classesRefRef.jar jars\/.\n-   Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint -extdirs      jars Main.java\n-   Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint -endorseddirs jars Main.java\n-\n-#----------------------------------------------------------------\n-# Bad Jar file in extdirs and endorseddirs should not be ignored\n-#----------------------------------------------------------------\n-BadJarFile jars\/classesRef.jar\n-   Error \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint -extdirs      jars Main.java\n-   Error \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint -endorseddirs jars Main.java\n-\n-Cleanup\n-\n-Bottom Line\n","filename":"test\/langtools\/tools\/javac\/Paths\/Diagnostics.sh","additions":0,"deletions":210,"binary":false,"changes":210,"status":"deleted"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 4940642 8293877\n+ * @summary Check for -help and -X flags\n+ *\/\n+\n+\/*\n+ * Converted from Help.sh, originally written by Martin Buchholz\n+ *\n+ * For the last version of the original, Help.sh, see\n+ * https:\/\/git.openjdk.org\/jdk\/blob\/jdk-19%2B36\/test\/langtools\/tools\/javac\/Paths\/Help.sh\n+ *\n+ * This class provides rudimentary tests of the javac command-line help.\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.spi.ToolProvider;\n+\n+public class Help {\n+    public static void main(String... args) throws Exception {\n+        new Help().run(args);\n+    }\n+\n+    void run(String... args) throws Exception {\n+        String helpText = javac(\"-help\");\n+        check(helpText,\n+                \"-X \", \"-J\", \"-classpath \", \"-cp \", \"-bootclasspath \", \"-sourcepath \");\n+\n+        String xText = javac(\"-X\");\n+        check(xText, \"-Xbootclasspath\/p:\");\n+    }\n+\n+    void check(String text, String... options) throws Exception {\n+        for (String opt : options) {\n+            System.err.println(\"Checking '\" + opt + \"'\");\n+            if (!text.contains(opt)) {\n+                text.lines().forEach(System.err::println);\n+                throw new Exception(\"Bad help output\");\n+            }\n+        }\n+    }\n+\n+    String javac(String... args) throws Exception {\n+        var javac = ToolProvider.findFirst(\"javac\")\n+                .orElseThrow(() -> new Exception(\"cannot find javac\"));\n+        try (StringWriter sw = new StringWriter();\n+             PrintWriter pw = new PrintWriter(sw)) {\n+             int rc = javac.run(pw, pw, args);\n+             if (rc != 0) {\n+                 throw new Error(\"unexpected exit from javac: \" + rc);\n+             }\n+             pw.flush();\n+             return sw.toString();\n+        }\n+    }\n+}\n+\n","filename":"test\/langtools\/tools\/javac\/Paths\/Help.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -1,69 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-# @test\n-# @bug 4940642\n-# @summary Check for -help and -X flags\n-# @author Martin Buchholz\n-#\n-# @run shell Help.sh\n-\n-# To run this test manually, simply do .\/MineField.sh\n-\n-\n-. ${TESTSRC-.}\/Util.sh\n-\n-set -u\n-\n-DiagnosticsInEnglishPlease\n-\n-HELP=\"`\\\"$javac\\\" ${TESTTOOLVMOPTS} -help 2>&1`\"\n-XHELP=\"`\\\"$javac\\\" ${TESTTOOLVMOPTS} -X 2>&1`\"\n-\n-#----------------------------------------------------------------\n-# Standard options\n-#----------------------------------------------------------------\n-for opt in \\\n-    \"-X \" \\\n-    \"-J\" \\\n-    \"-classpath \" \\\n-    \"-cp \" \\\n-    \"-bootclasspath \" \\\n-    \"-sourcepath \"; \n-do\n-    case \"$HELP\" in *\"$opt\"*) ;; *) Fail \"Bad help output\" ;; esac\n-done\n-\n-#----------------------------------------------------------------\n-# Non-standard options\n-#----------------------------------------------------------------\n-for opt in \\\n-    \"-Xbootclasspath\/p:\"; \n-do\n-    case \"$XHELP\" in *\"$opt\"*) ;; *) Fail \"Bad help output\" ;; esac\n-done\n-\n-Bottom Line\n","filename":"test\/langtools\/tools\/javac\/Paths\/Help.sh","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -0,0 +1,352 @@\n+\/*\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 4758537 4809833 8149599 8293877\n+ * @summary Test that javac and java find files in similar ways\n+ * @library \/tools\/lib\n+ * @build toolbox.ToolBox Util MineField\n+ * @run main MineField\n+ *\/\n+\n+\/*\n+ * Converted from MineField.sh, originally written by Martin Buchholz.\n+ *\n+ * For the last version of the original, MineField.sh, see\n+ * https:\/\/git.openjdk.org\/jdk\/blob\/jdk-19%2B36\/test\/langtools\/tools\/javac\/Paths\/MineField.sh\n+ *\n+ * This class primarily tests that javac and the java launcher provide\n+ * equivalent handling of all path-related options, like {@code -classpath}.\n+ *\/\n+\n+\/*\n+#----------------------------------------------------------------\n+# The search order for classes used by both java and javac is:\n+#\n+# -Xbootclasspath\/p:<path>\n+# -endorseddirs <dirs> or -Djava.endorsed.dirs=<dirs> (search for jar\/zip only)\n+# -bootclasspath <path> or -Xbootclasspath:<path>\n+# -Xbootclasspath\/a:<path>\n+# -extdirs <dirs> or -Djava.ext.dirs=<dirs> (search for jar\/zip only)\n+# -classpath <path>, -cp <path>, env CLASSPATH=<path>\n+#\n+# Peculiarities of the class file search:\n+# - Empty elements of the (user) classpath default to \".\",\n+#   while empty elements of other paths are ignored.\n+# - Only for the user classpath is an empty string value equivalent to \".\"\n+# - Specifying a bootclasspath on the command line obliterates any\n+#   previous -Xbootclasspath\/p: or -Xbootclasspath\/a: command line flags.\n+#\n+# JDK 9 update:\n+#   java: The java launcher does not support any of the following:\n+#       * -Xbootclasspath\/p: -Xbootclasspath:\n+#       * -endorseddirs -Djava.endorsed.dirs\n+#       * -extdirs -Djava.ext.dirs\n+#       All test cases exercising these features have been removed.\n+#   javac: The following features are only supported when compiling\n+#       for older releases:\n+#       * -Xbootclasspath\/p: -Xbootclasspath: -bootclasspath -Xbootclasspath\/a:\n+#       * -endorseddirs -Djava.endorsed.dirs\n+#       * -extdirs -Djava.ext.dirs\n+#       All test cases exercising these features have been modified to\n+#       use -source 8 -target 8.  In addition, javac test cases involving\n+#       use of the runtime properties java.endorsed.dirs and java.extdirs\n+#       (by means of -J-Dname=value) have been removed.\n+#       Although the primary purpose of the test cases in this file is to\n+#       compare javac and java behavior, some tests remain for javac for\n+#       which there is no java equivalent. However, the cases remain as useful\n+#       test cases for javac handling of the paths involved.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class MineField extends Util {\n+    public static void main(String... args) throws Exception {\n+        new MineField().run(args);\n+    }\n+\n+    void run(String... args) throws Exception{\n+        setup();\n+        tests();\n+        cleanup();\n+        bottomLine();\n+    }\n+\n+    void cleanup() throws IOException {\n+        deleteFiles(\"GooSrc\", \"GooJar\", \"GooZip\", \"GooClass\");\n+        deleteFiles(\"BadSrc\", \"BadJar\", \"BadZip\", \"BadClass\");\n+        deleteFiles(\"OneDir\", \"Main.java\", \"MANIFEST.MF\");\n+        deleteFiles(listFiles(Path.of(\".\"), \"*.class\"));\n+        deleteFiles(\"java-lang.jar\");\n+    }\n+\n+    \/**\n+     * \"Prepare the minefield\".\n+     *\/\n+    void setup() throws Exception {\n+        cleanup();\n+\n+        tb.createDirectories(\"GooSrc\", \"GooJar\", \"GooZip\", \"GooClass\");\n+        tb.createDirectories(\"BadSrc\", \"BadJar\", \"BadZip\", \"BadClass\");\n+\n+        Files.writeString(Path.of(\"Lib.java\"),\n+                \"public class Lib {public static void f(){}}\");\n+        javac(\"Lib.java\");\n+        jar(\"cf\", \"GooJar\/Lib.jar\", \"Lib.class\");\n+        jar(\"cf\", \"GooZip\/Lib.zip\", \"Lib.class\");\n+        tb.moveFile(\"Lib.class\", \"GooClass\/.\");\n+        tb.moveFile(\"Lib.java\", \"GooSrc\/.\");\n+        checkFiles(\"GooZip\/Lib.zip\", \"GooJar\/Lib.jar\", \"GooSrc\/Lib.java\");\n+\n+        Files.writeString(Path.of(\"Lib.java\"),\n+                \"public class Lib {\/* Bad *\/}\");\n+        javac(\"Lib.java\");\n+        jar(\"cf\", \"BadJar\/Lib.jar\", \"Lib.class\");\n+        jar(\"cf\", \"BadZip\/Lib.zip\", \"Lib.class\");\n+        tb.moveFile(\"Lib.class\", \"BadClass\/.\");\n+        tb.moveFile(\"Lib.java\", \"BadSrc\/.\");\n+        checkFiles(\"BadZip\/Lib.zip\", \"BadJar\/Lib.jar\", \"BadSrc\/Lib.java\");\n+\n+        Files.writeString(Path.of(\"Main.java\"),\n+                \"public class Main {public static void main(String[] a) {Lib.f();}}\");\n+        Path libModules = javaHome.resolve(\"lib\").resolve(\"modules\");\n+        if (Files.isReadable(libModules)) {\n+            jimage(\"extract\", \"--dir\", \"modules\", libModules.toString());\n+            jar(\"cf\", \"java-lang.jar\", \"-C\", \"modules\/java.base\", \"java\/lang\");\n+            deleteFiles(\"modules\");\n+        } else {\n+            Path modules = javaHome.resolve(\"modules\");\n+            if (Files.isDirectory(modules)) {\n+                jar(\"cf\", \"java-lang.jar\", \"-C\", modules.resolve(\"java.base\").toString(), \"java\/lang\");\n+            } else {\n+                throw new Exception(\"Cannot create java-lang.jar\");\n+            }\n+        }\n+    }\n+\n+    void tests() throws Exception {\n+\n+        \/\/----------------------------------------------------------------\n+        \/\/ Verify that javac class search order is the same as java's\n+        \/\/----------------------------------------------------------------\n+\n+        expectFail(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Xbootclasspath\/p:GooClass\n+                -bootclasspath java-lang.jar${PS}BadZip\/Lib.zip\n+                Main.java\"\"\");\n+\n+        expectPass(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Xbootclasspath\/p:BadClass${PS}GooClass\n+                -bootclasspath java-lang.jar${PS}GooZip\/Lib.zip${PS}BadClass\n+                Main.java\"\"\");\n+\n+        expectPass(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Xbootclasspath\/p:BadJar\/Lib.jar\n+                -Xbootclasspath:java-lang.jar${PS}GooClass\n+                Main.java\"\"\");\n+\n+        \/\/----------------------------------------------------------------\n+\n+        expectFail(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -bootclasspath java-lang.jar${PS}GooZip\/Lib.zip\n+                -Xbootclasspath\/p:BadClass\n+                Main.java\"\"\");\n+\n+        expectPass(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -bootclasspath java-lang.jar${PS}BadZip\/Lib.zip\n+                -Xbootclasspath\/p:GooClass${PS}BadJar\/Lib.jar\n+                Main.java\"\"\");\n+\n+        \/\/----------------------------------------------------------------\n+\n+        expectFail(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Xbootclasspath\/p:BadClass\n+                -Xbootclasspath\/a:GooClass\n+                Main.java\"\"\");\n+\n+        expectPass(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Xbootclasspath\/p:GooClass${PS}BadClass\n+                -Xbootclasspath\/a:BadClass\n+                Main.java\"\"\");\n+\n+        expectPass(JAVA, \"\"\"\n+                -Xbootclasspath\/a:GooClass\n+                Main\"\"\");\n+\n+        \/\/----------------------------------------------------------------\n+\n+        expectFail(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Xbootclasspath\/p:GooClass\n+                -Xbootclasspath:BadClass${PS}java-lang.jar\n+                -Xbootclasspath\/a:GooClass\n+                Main.java\"\"\");\n+\n+        expectPass(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Xbootclasspath\/p:BadClass\n+                -Xbootclasspath:GooClass${PS}BadClass${PS}java-lang.jar\n+                -Xbootclasspath\/a:BadClass\n+                Main.java\"\"\");\n+\n+        \/\/----------------------------------------------------------------\n+\n+        expectPass(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -endorseddirs BadClass${PS}GooZip${PS}BadJar\n+                -Xbootclasspath:\"BadClass${PS}java-lang.jar\n+                Main.java\"\"\");\n+\n+        expectPass(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Djava.endorsed.dirs=BadClass${PS}GooZip${PS}BadJar\n+                -Xbootclasspath:BadClass${PS}java-lang.jar\n+                Main.java\"\"\");\n+\n+        \/\/----------------------------------------------------------------\n+\n+        expectFail(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Xbootclasspath\/a:BadClass\n+                -extdirs GooZip\n+                Main.java\"\"\");\n+\n+        expectPass(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Xbootclasspath\/a:GooClass${PS}BadClass\n+                -extdirs BadZip\n+                Main.java\"\"\");\n+\n+        \/\/----------------------------------------------------------------\n+\n+        expectFail(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -extdirs GooClass${PS}BadZip\n+                -cp GooZip\/Lib.zip\n+                Main.java\"\"\");\n+\n+        expectPass(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -extdirs BadClass${PS}GooZip${PS}BadJar\n+                -cp BadZip\/Lib.zip\n+                Main.java\"\"\");\n+\n+        expectPass(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Djava.ext.dirs=GooZip${PS}BadJar\n+                -classpath BadZip\/Lib.zip\n+                Main.java\"\"\");\n+\n+        \/\/----------------------------------------------------------------\n+\n+        expectFail(JAVAC, \"-classpath BadClass${PS}GooClass Main.java\");\n+        expectPass(JAVAC, \"-classpath GooClass${PS}BadClass Main.java\");\n+        expectFail(JAVA,  \"-classpath BadClass${PS}GooClass${PS}. Main\");\n+        expectPass(JAVA,  \"-classpath GooClass${PS}BadClass${PS}. Main\");\n+\n+        expectFail(JAVAC, \"-cp BadJar\/Lib.jar${PS}GooZip\/Lib.zip Main.java\");\n+        expectPass(JAVAC, \"-cp GooJar\/Lib.jar${PS}BadZip\/Lib.zip Main.java\");\n+        expectFail(JAVA,  \"-cp BadJar\/Lib.jar${PS}${PS}GooZip\/Lib.zip Main\");\n+        expectPass(JAVA,  \"-cp GooJar\/Lib.jar${PS}${PS}BadZip\/Lib.zip Main\");\n+\n+        \/\/----------------------------------------------------------------\n+\n+        expectFail(classpath(\"BadZip\/Lib.zip${PS}GooJar\/Lib.jar\"), JAVAC,\"Main.java\");\n+        expectPass(classpath(\"GooZip\/Lib.zip${PS}BadJar\/Lib.jar\"), JAVAC, \"Main.java\");\n+        expectFail(classpath(\"${PS}BadZip\/Lib.zip${PS}GooJar\/Lib.jar\"), JAVA, \"Main\");\n+        expectPass(classpath(\"${PS}GooZip\/Lib.zip${PS}BadJar\/Lib.jar\"), JAVA, \"Main\");\n+\n+        \/\/----------------------------------------------------------------\n+        \/\/ Check behavior of empty paths and empty path elements\n+        \/\/----------------------------------------------------------------\n+\n+        Path GooClass = Path.of(\"GooClass\");\n+        Path GooJar = Path.of(\"GooJar\");\n+\n+        expectFail(GooClass,  JAVAC, \"-cp .. ..\/Main.java\");\n+        expectFail(GooClass,  JAVA, \"-cp .. Main\");\n+\n+        \/\/ Unspecified classpath defaults to \".\"\n+        Path OneDir = Path.of(\"OneDir\");\n+        tb.createDirectories(OneDir);\n+        tb.copyFile(Path.of(\"Main.java\"), OneDir);\n+        tb.copyFile(GooClass.resolve(\"Lib.class\"), OneDir);\n+        expectPass(OneDir,  JAVAC, \"Main.java\");\n+        expectPass(OneDir,  JAVA, \"Main\");\n+\n+        \/\/ Empty classpath elements mean \".\"\n+        expectPass(GooClass,  JAVAC, \"-cp ${PS}.. ..\/Main.java\");\n+        expectPass(GooClass,  JAVA,  \"-cp ${PS}.. Main\");\n+\n+        expectPass(GooClass,  JAVAC, \"-cp ..${PS} ..\/Main.java\");\n+        expectPass(GooClass,  JAVA,  \"-cp ..${PS} Main\");\n+\n+        expectPass(GooClass,  JAVAC, \"-cp ..${PS}${PS}\/xyzzy ..\/Main.java\");\n+        expectPass(GooClass,  JAVA,  \"-cp ..${PS}${PS}\/xyzzy Main\");\n+\n+        \/\/ All other empty path elements are ignored.\n+\n+        \/\/ note presence of empty arg in this invocation\n+        expectFail(GooJar,  null, JAVAC, \"-source\", \"8\", \"-target\", \"8\", \"-extdirs\", \"\", \"-cp\", \"..\", \"..\/Main.java\");\n+\n+        expectFail(GooJar,  JAVAC, \"-source 8 -target 8 -extdirs        ${PS} -cp .. ..\/Main.java\");\n+        expectFail(GooJar,  JAVAC, \"-source 8 -target 8 -Djava.ext.dirs=${PS} -cp .. ..\/Main.java\");\n+\n+        expectPass(GooJar,  JAVAC, \"-source 8 -target 8 -extdirs        . -cp .. ..\/Main.java\");\n+        expectPass(GooJar,  JAVAC, \"-source 8 -target 8 -Djava.ext.dirs=. -cp .. ..\/Main.java\");\n+\n+        expectFail(GooJar,  JAVAC, \"-source 8 -target 8 -Djava.endorsed.dirs= -cp .. ..\/Main.java\");\n+\n+        expectFail(GooJar,  JAVAC, \"-source 8 -target 8 -endorseddirs        ${PS} -cp .. ..\/Main.java\");\n+\n+        expectPass(GooJar,  JAVAC, \"-source 8 -target 8 -Djava.endorsed.dirs=. -cp .. ..\/Main.java\");\n+\n+        expectFail(GooClass,  JAVAC, \"-source 8 -target 8 -Xbootclasspath\/p: -cp .. ..\/Main.java\");\n+\n+        expectPass(GooClass,  JAVAC, \"-source 8 -target 8 -Xbootclasspath\/p:. -cp .. ..\/Main.java\");\n+\n+        expectFail(GooClass,  JAVAC, \"-source 8 -target 8 -Xbootclasspath:..\/java-lang.jar -cp .. ..\/Main.java\");\n+\n+        expectPass(GooClass,  JAVAC, \"-source 8 -target 8 -Xbootclasspath:..\/java-lang.jar${PS}. -cp .. ..\/Main.java\");\n+\n+        expectFail(GooClass,  JAVAC, \"-source 8 -target 8 -Xbootclasspath\/a: -cp .. ..\/Main.java\");\n+        expectFail(GooClass,  JAVA, \"-Xbootclasspath\/a: -cp .. Main\");\n+\n+        expectPass(GooClass,  JAVAC, \"-source 8 -target 8 -Xbootclasspath\/a:. -cp .. ..\/Main.java\");\n+        expectPass(GooClass,  JAVA, \"-Xbootclasspath\/a:. -cp .. Main\");\n+\n+    }\n+\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/Paths\/MineField.java","additions":352,"deletions":0,"binary":false,"changes":352,"status":"added"},{"patch":"@@ -1,277 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-# @test\n-# @bug 4758537 4809833 8149599\n-# @summary Test that javac and java find files in similar ways\n-# @author Martin Buchholz\n-#\n-# @run shell\/timeout=600 MineField.sh\n-\n-# To run this test manually, simply do .\/MineField.sh\n-\n-#----------------------------------------------------------------\n-# The search order for classes used by both java and javac is:\n-#\n-# -Xbootclasspath\/p:<path>\n-# -endorseddirs <dirs> or -Djava.endorsed.dirs=<dirs> (search for jar\/zip only)\n-# -bootclasspath <path> or -Xbootclasspath:<path>\n-# -Xbootclasspath\/a:<path>\n-# -extdirs <dirs> or -Djava.ext.dirs=<dirs> (search for jar\/zip only)\n-# -classpath <path>, -cp <path>, env CLASSPATH=<path>\n-#\n-# Peculiarities of the class file search:\n-# - Empty elements of the (user) classpath default to \".\",\n-#   while empty elements of other paths are ignored.\n-# - Only for the user classpath is an empty string value equivalent to \".\"\n-# - Specifying a bootclasspath on the command line obliterates any\n-#   previous -Xbootclasspath\/p: or -Xbootclasspath\/a: command line flags.\n-#\n-# JDK 9 update:\n-#   java: The java launcher does not support any of the following:\n-#       * -Xbootclasspath\/p: -Xbootclasspath:\n-#       * -endorseddirs -Djava.endorsed.dirs\n-#       * -extdirs -Djava.ext.dirs\n-#       All test cases exercising these features have been removed.\n-#   javac: The following features are only supported when compiling\n-#       for older releases:\n-#       * -Xbootclasspath\/p: -Xbootclasspath: -bootclasspath -Xbootclasspath\/a:\n-#       * -endorseddirs -Djava.endorsed.dirs\n-#       * -extdirs -Djava.ext.dirs\n-#       All test cases exercising these features have been modified to\n-#       use -source 8 -target 8.  In addition, javac test cases involving\n-#       use of the runtime properties java.endorsed.dirs and java.extdirs\n-#       (by means of -J-Dname=value) have been removed.\n-#       Although the primary purpose of the test cases in this file is to\n-#       compare javac and java behavior, some tests remain for javac for\n-#       which there is no java equivalent. However, the cases remain as useful\n-#       test cases for javac handling of the paths involved.\n-\n-#----------------------------------------------------------------\n-\n-. ${TESTSRC-.}\/Util.sh\n-\n-set -u\n-\n-#----------------------------------------------------------------\n-# Prepare the \"Minefield\"\n-#----------------------------------------------------------------\n-Cleanup() {\n-    Sys rm -rf GooSrc GooJar GooZip GooClass\n-    Sys rm -rf BadSrc BadJar BadZip BadClass\n-    Sys rm -rf OneDir *.class Main.java MANIFEST.MF\n-    Sys rm -f java-lang.jar\n-}\n-\n-Cleanup\n-Sys mkdir  GooSrc GooJar GooZip GooClass\n-Sys mkdir  BadSrc BadJar BadZip BadClass\n-\n-echo 'public class Lib {public static void f(){}}' > Lib.java\n-Sys \"$javac\" ${TESTTOOLVMOPTS} Lib.java\n-Sys \"$jar\" cf GooJar\/Lib.jar Lib.class\n-Sys \"$jar\" cf GooZip\/Lib.zip Lib.class\n-Sys mv Lib.class GooClass\/.\n-Sys mv Lib.java GooSrc\/.\n-CheckFiles GooZip\/Lib.zip GooJar\/Lib.jar GooSrc\/Lib.java\n-\n-echo 'public class Lib {\/* Bad *\/}' > Lib.java\n-Sys \"$javac\" ${TESTTOOLVMOPTS} Lib.java\n-Sys \"$jar\" cf BadJar\/Lib.jar Lib.class\n-Sys \"$jar\" cf BadZip\/Lib.zip Lib.class\n-Sys mv Lib.class BadClass\/.\n-Sys mv Lib.java BadSrc\/.\n-CheckFiles BadZip\/Lib.zip BadJar\/Lib.jar BadSrc\/Lib.java\n-\n-echo 'public class Main {public static void main(String[] a) {Lib.f();}}' > Main.java\n-\n-# Create a jar file that is good enough to put on the javac boot class path (i.e. contains java.lang.**)\n-if [ -r ${TESTJAVA}\/lib\/modules ]; then\n-  Sys \"$jimage\" extract --dir modules ${TESTJAVA}\/lib\/modules\n-  Sys \"$jar\" cf java-lang.jar -C modules\/java.base java\/lang\n-  Sys rm -rf modules\n-elif [ -d ${TESTJAVA}\/modules ]; then\n-  Sys \"$jar\" cf java-lang.jar -C ${TESTJAVA}\/modules\/java.base java\/lang\n-else\n-  echo 'cannot create java-lang.jar' ; exit 1\n-fi\n-\n-#----------------------------------------------------------------\n-# Verify that javac class search order is the same as java's\n-#----------------------------------------------------------------\n-Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Xbootclasspath\/p:\"GooClass\" \\\n-    -bootclasspath \"java-lang.jar${PS}BadZip\/Lib.zip\" \\\n-    Main.java\n-Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Xbootclasspath\/p:\"BadClass${PS}GooClass\" \\\n-    -bootclasspath \"java-lang.jar${PS}GooZip\/Lib.zip${PS}BadClass\" \\\n-    Main.java\n-Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Xbootclasspath\/p:\"BadJar\/Lib.jar\" \\\n-    -Xbootclasspath:\"java-lang.jar${PS}GooClass\" \\\n-    Main.java\n-\n-#----------------------------------------------------------------\n-Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -bootclasspath \"java-lang.jar${PS}GooZip\/Lib.zip\" \\\n-    -Xbootclasspath\/p:\"BadClass\" \\\n-    Main.java\n-Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -bootclasspath \"java-lang.jar${PS}BadZip\/Lib.zip\" \\\n-    -Xbootclasspath\/p:\"GooClass${PS}BadJar\/Lib.jar\" \\\n-    Main.java\n-\n-#----------------------------------------------------------------\n-Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Xbootclasspath\/p:\"BadClass\" \\\n-    -Xbootclasspath\/a:\"GooClass\" \\\n-    Main.java\n-Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Xbootclasspath\/p:\"GooClass${PS}BadClass\" \\\n-    -Xbootclasspath\/a:\"BadClass\" \\\n-    Main.java\n-Success \"$java\" ${TESTVMOPTS} \\\n-    -Xbootclasspath\/a:\"GooClass\" \\\n-    Main\n-\n-#----------------------------------------------------------------\n-Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Xbootclasspath\/p:\"GooClass\" \\\n-    -Xbootclasspath:\"BadClass${PS}java-lang.jar\" \\\n-    -Xbootclasspath\/a:\"GooClass\" \\\n-    Main.java\n-Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Xbootclasspath\/p:\"BadClass\" \\\n-    -Xbootclasspath:\"GooClass${PS}BadClass${PS}java-lang.jar\" \\\n-    -Xbootclasspath\/a:\"BadClass\" \\\n-    Main.java\n-\n-#----------------------------------------------------------------\n-Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -endorseddirs \"BadClass${PS}GooZip${PS}BadJar\" \\\n-    -Xbootclasspath:\"BadClass${PS}java-lang.jar\" \\\n-    Main.java\n-Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Djava.endorsed.dirs=\"BadClass${PS}GooZip${PS}BadJar\" \\\n-    -Xbootclasspath:\"BadClass${PS}java-lang.jar\" \\\n-    Main.java\n-\n-#----------------------------------------------------------------\n-Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Xbootclasspath\/a:\"BadClass\" \\\n-    -extdirs \"GooZip\" \\\n-    Main.java\n-Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Xbootclasspath\/a:\"GooClass${PS}BadClass\" \\\n-    -extdirs \"BadZip\" \\\n-    Main.java\n-\n-#----------------------------------------------------------------\n-Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -extdirs \"GooClass${PS}BadZip\" \\\n-    -cp \"GooZip\/Lib.zip\" \\\n-    Main.java\n-Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -extdirs \"BadClass${PS}GooZip${PS}BadJar\" \\\n-    -cp \"BadZip\/Lib.zip\" \\\n-    Main.java\n-Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Djava.ext.dirs=\"GooZip${PS}BadJar\" \\\n-    -classpath \"BadZip\/Lib.zip\" \\\n-    Main.java\n-\n-#----------------------------------------------------------------\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \"BadClass${PS}GooClass\" Main.java\n-Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"GooClass${PS}BadClass\" Main.java\n-Failure \"$java\" ${TESTVMOPTS}  -classpath \"BadClass${PS}GooClass${PS}.\" Main\n-Success \"$java\" ${TESTVMOPTS}  -classpath \"GooClass${PS}BadClass${PS}.\" Main\n-\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -cp \"BadJar\/Lib.jar${PS}GooZip\/Lib.zip\" Main.java\n-Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"GooJar\/Lib.jar${PS}BadZip\/Lib.zip\" Main.java\n-Failure \"$java\" ${TESTVMOPTS}  -cp \"BadJar\/Lib.jar${PS}${PS}GooZip\/Lib.zip\" Main\n-Success \"$java\" ${TESTVMOPTS}  -cp \"GooJar\/Lib.jar${PS}${PS}BadZip\/Lib.zip\" Main\n-\n-Failure env CLASSPATH=\"BadZip\/Lib.zip${PS}GooJar\/Lib.jar\" \"$javac\" ${TESTTOOLVMOPTS} Main.java\n-Success env CLASSPATH=\"GooZip\/Lib.zip${PS}BadJar\/Lib.jar\" \"$javac\" ${TESTTOOLVMOPTS} Main.java\n-Failure env CLASSPATH=\"${PS}BadZip\/Lib.zip${PS}GooJar\/Lib.jar\" \"$java\" ${TESTVMOPTS} Main\n-Success env CLASSPATH=\"${PS}GooZip\/Lib.zip${PS}BadJar\/Lib.jar\" \"$java\" ${TESTVMOPTS} Main\n-\n-#----------------------------------------------------------------\n-# Check behavior of empty paths and empty path elements\n-#----------------------------------------------------------------\n-In() { cd \"$1\"; shift; \"$@\"; cd ..; }\n-\n-In GooClass Failure \"$javac\" ${TESTTOOLVMOPTS} -cp \"..\" ..\/Main.java\n-In GooClass Failure \"$java\" ${TESTVMOPTS}  -cp \"..\" Main\n-\n-# Unspecified classpath defaults to \".\"\n-Sys mkdir OneDir; Sys cp Main.java GooClass\/Lib.class OneDir\/.\n-In OneDir Success \"$javac\" ${TESTTOOLVMOPTS} Main.java\n-In OneDir Success \"$java\" ${TESTVMOPTS}  Main\n-\n-# Empty classpath elements mean \".\"\n-In GooClass Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"${PS}..\" ..\/Main.java\n-In GooClass Success \"$java\" ${TESTVMOPTS}  -cp \"${PS}..\" Main\n-\n-In GooClass Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"..${PS}\" ..\/Main.java\n-In GooClass Success \"$java\" ${TESTVMOPTS}  -cp \"..${PS}\" Main\n-\n-In GooClass Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"..${PS}${PS}\/xyzzy\" ..\/Main.java\n-In GooClass Success \"$java\" ${TESTVMOPTS}  -cp \"..${PS}${PS}\/xyzzy\" Main\n-\n-# All other empty path elements are ignored.\n-In GooJar Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} -extdirs \"\" -cp \"..\" ..\/Main.java\n-\n-In GooJar Failure \"$javac\" -source 8 -targt 8 ${TESTTOOLVMOPTS} -extdirs        \"${PS}\" -cp \"..\" ..\/Main.java\n-In GooJar Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} -Djava.ext.dirs=\"${PS}\" -cp \"..\" ..\/Main.java\n-\n-In GooJar Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} -extdirs        \".\" -cp \"..\" ..\/Main.java\n-In GooJar Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} -Djava.ext.dirs=\".\" -cp \"..\" ..\/Main.java\n-\n-In GooJar Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS}   -Djava.endorsed.dirs=\"\" -cp \"..\" ..\/Main.java\n-\n-In GooJar Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS}   -endorseddirs        \"${PS}\" -cp \"..\" ..\/Main.java\n-\n-In GooJar Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS}   -Djava.endorsed.dirs=\".\" -cp \"..\" ..\/Main.java\n-\n-In GooClass Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} -Xbootclasspath\/p: -cp \"..\" ..\/Main.java\n-\n-In GooClass Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} -Xbootclasspath\/p:. -cp \"..\" ..\/Main.java\n-\n-In GooClass Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} -Xbootclasspath:\"..\/java-lang.jar\" -cp \"..\" ..\/Main.java\n-\n-In GooClass Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} -Xbootclasspath:\"..\/java-lang.jar${PS}.\" -cp \"..\" ..\/Main.java\n-\n-In GooClass Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} -Xbootclasspath\/a: -cp \"..\" ..\/Main.java\n-In GooClass Failure \"$java\" ${TESTVMOPTS}  -Xbootclasspath\/a: -cp \"..\" Main\n-\n-In GooClass Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} -Xbootclasspath\/a:. -cp \"..\" ..\/Main.java\n-In GooClass Success \"$java\" ${TESTVMOPTS}  -Xbootclasspath\/a:. -cp \"..\" Main\n-\n-Cleanup\n-\n-Bottom Line\n","filename":"test\/langtools\/tools\/javac\/Paths\/MineField.sh","additions":0,"deletions":277,"binary":false,"changes":277,"status":"deleted"},{"patch":"@@ -0,0 +1,560 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.spi.ToolProvider;\n+\n+import toolbox.ToolBox;\n+\n+\/**\n+ * Utility methods for use by tests in the `Paths` directory.\n+ *\/\n+class Util {\n+\n+    ToolBox tb = new ToolBox();\n+    PrintStream out = tb.out;\n+\n+    Path javaHome = Path.of(System.getProperty(\"java.home\"));\n+    String PS = File.pathSeparator;\n+    Path curDir = Path.of(\".\");\n+\n+    static final String JAR = \"jar\";\n+    static final String JAVA = \"java\";\n+    static final String JAVAC = \"javac\";\n+    static final String JIMAGE = \"jimage\";\n+\n+    \/** The number of test-case failures. *\/\n+    int failCount = 0;\n+    \/** The number of test-case passes. *\/\n+    int passCount = 0;\n+    \/** A map recording how often each tool is executed in a separate process. *\/\n+    Map<String, Integer> execCounts = new TreeMap<>();\n+    \/** A map recording how often each tool is invoked via its ToolProvider API. *\/\n+    Map<String, Integer> toolCounts = new TreeMap<>();\n+\n+    \/**\n+     * Reports a summary of the overall test statistics, and throws an exception\n+     * if any test cases failed.\n+     *\n+     * @throws Exception if any test cases failed\n+     *\/\n+    void bottomLine() throws Exception {\n+        out.println();\n+        out.println(\"-- Summary --\");\n+        out.println(\"Passed: \" + passCount);\n+        out.println(\"Failed: \" + failCount);\n+        out.println(\"exec: \" + execCounts);\n+        out.println(\"tool: \" + toolCounts);\n+\n+        if (failCount > 0) {\n+            throw new Exception(failCount + \" tests failed\");\n+        }\n+    }\n+\n+    \/**\n+     * The result of executing a tool, either in a separate process, or via its ToolProvider API.\n+     *\n+     * @param exitCode the exit code from the tool: 0 for success\n+     * @param out the output from the tool\n+     *\/\n+    record Result(int exitCode, String out) { }\n+\n+    \/**\n+     * Executes a tool with given arguments and verifies that it passes.\n+     *\n+     * @param command the name of a JDK tool: java, javac or jar\n+     * @param args a string containing whitespace separated arguments\n+     * @throws Exception if there was an issue trying to execute the tool\n+     * @see #passCount\n+     * @see #failCount\n+     * @see #splitArgs(String)\n+     *\/\n+    void expectPass(String command, String args) throws Exception {\n+        expectPass(null, null, command, splitArgs(args));\n+    }\n+\n+    \/**\n+     * Executes a tool in a specific directory with given arguments and verifies that it passes.\n+     * In order to set the directory, the tool will be executed in a separate process.\n+     *\n+     * @param dir the directory\n+     * @param command the name of a JDK tool: java, javac or jar\n+     * @param args a string containing whitespace separated arguments\n+     * @throws Exception if there was an issue trying to execute the tool\n+     * @see #passCount\n+     * @see #failCount\n+     * @see #splitArgs(String)\n+     *\/\n+    void expectPass(Path dir, String command, String args) throws Exception {\n+        expectPass(dir, null, command, splitArgs(args));\n+    }\n+\n+    \/**\n+     * Executes a tool with additional env variables with given arguments and verifies that it passes.\n+     * In order to set the env variables, the tool will be executed in a separate process.\n+     * Note that any value of {@code CLASSPATH} inherited from this process will always be removed.\n+     *\n+     * @param env the additional env variables\n+     * @param command the name of a JDK tool: java, javac or jar\n+     * @param args a string containing whitespace separated arguments\n+     * @throws Exception if there was an issue trying to execute the tool\n+     * @see #passCount\n+     * @see #failCount\n+     * @see #splitArgs(String)\n+     *\/\n+    void expectPass(Map<String, String> env, String command, String args) throws Exception {\n+        expectPass(null, env, command, splitArgs(args));\n+    }\n+\n+    \/**\n+     * Executes a tool in a given directory with additional env variables with given arguments\n+     * and verifies that it passes.\n+     * In order to set any directory and env variables, the tool will be executed in a separate process.\n+     * Note that any value of {@code CLASSPATH} inherited from this process will always be removed.\n+     *\n+     * @param dir the directory, or {@code null}\n+     * @param env the additional env variables, or {@code null}\n+     * @param command the name of a JDK tool: java, javac or jar\n+     * @param args the arguments\n+     * @throws Exception if there was an issue trying to execute the tool\n+     * @see #passCount\n+     * @see #failCount\n+     *\/\n+    void expectPass(Path dir, Map<String, String> env, String command, String... args) throws Exception {\n+        Result result = switch (command) {\n+            case JAR -> jar(args);\n+            case JAVAC -> javac(dir, env, args);\n+            case JAVA -> java(dir, env, args);\n+            default -> throw new Exception(\"unknown command: \" + command);\n+        };\n+\n+        if (result.exitCode == 0) {\n+            out.println(\"PASS: test passed as expected\");\n+            passCount++;\n+        } else {\n+            out.println(\"FAIL: test failed unexpectedly\");\n+            failCount++;\n+        }\n+    }\n+\n+    \/**\n+     * Executes a tool with given arguments and verifies that it fails.\n+     *\n+     * @param command the name of a JDK tool: java, javac or jar\n+     * @param args a string containing whitespace separated arguments\n+     * @throws Exception if there was an issue trying to execute the tool\n+     * @see #passCount\n+     * @see #failCount\n+     * @see #splitArgs(String)\n+     *\/\n+    void expectFail(String command, String args) throws Exception {\n+        expectFail(null, null, command, splitArgs(args));\n+    }\n+\n+    \/**\n+     * Executes a tool in a specific directory with given arguments and verifies that it fails.\n+     * In order to set the directory, the tool will be executed in a separate process.\n+     *\n+     * @param dir the directory\n+     * @param command the name of a JDK tool: java, javac or jar\n+     * @param args a string containing whitespace separated arguments\n+     * @throws Exception if there was an issue trying to execute the tool\n+     * @see #passCount\n+     * @see #failCount\n+     * @see #splitArgs(String)\n+     *\/\n+    void expectFail(Path dir, String command, String args) throws Exception {\n+        expectFail(dir, null, command, splitArgs(args));\n+    }\n+\n+    \/**\n+     * Executes a tool with additional env variables with given arguments and verifies that it passes.\n+     * In order to set the env variables, the tool will be executed in a separate process.\n+     * Note that any value of {@code CLASSPATH} inherited from this process will always be removed.\n+     *\n+     * @param env the additional env variables\n+     * @param command the name of a JDK tool: java, javac or jar\n+     * @param args a string containing whitespace separated arguments\n+     * @throws Exception if there was an issue trying to execute the tool\n+     * @see #passCount\n+     * @see #failCount\n+     * @see #splitArgs(String)\n+     *\/\n+    void expectFail(Map<String, String> env, String command, String args) throws Exception {\n+        expectFail(null, env, command, splitArgs(args));\n+    }\n+\n+    \/**\n+     * Executes a tool in a given directory with additional env variables with given arguments\n+     * and verifies that it passes.\n+     * In order to set any directory and env variables, the tool will be executed in a separate process.\n+     * Note that any value of {@code CLASSPATH} inherited from this process will always be removed.\n+     *\n+     * @param dir the directory, or {@code null}\n+     * @param env the additional env variables, or {@code null}\n+     * @param command the name of a JDK tool: java, javac or jar\n+     * @param args the arguments\n+     * @throws Exception if there was an issue trying to execute the tool\n+     * @see #passCount\n+     * @see #failCount\n+     *\/\n+    void expectFail(Path dir, Map<String, String> env, String command, String... args) throws Exception {\n+        Result result = switch (command) {\n+            case JAR -> jar(args);\n+            case JAVAC -> javac(dir, env, args);\n+            case JAVA -> java(dir, env, args);\n+            default -> throw new Exception(\"unknown command: \" + command);\n+        };\n+\n+        if (result.exitCode == 0) {\n+            out.println(\"FAIL: test passed unexpectedly\");\n+            failCount++;\n+        } else {\n+            out.println(\"PASS: failed as expected\");\n+            passCount++;\n+        }\n+    }\n+\n+    \/**\n+     * Splits a string into a list of strings that were separated by whitespace.\n+     * Leading and trailing whitespace is removed.\n+     * The character sequence {@code ${PS}} is replaced by the platform path separator.\n+     * Note, quotes are not supported, and so there is no support for embedded whitespace\n+     * or empty strings in the output.\n+     *\n+     * @param args a string of tokens separated by whitespace\n+     * @return an array of the tokens that were separated by whitespace\n+     *\/\n+    String[] splitArgs(String args) {\n+        return args.trim()\n+                .replace(\"${PS}\", PS)\n+                .split(\"\\\\s+\");\n+    }\n+\n+    \/**\n+     * Executes {@code javac} using its ToolProvider API.\n+     *\n+     * @param args the arguments\n+     * @return an object containing the output and exit code from the tool\n+     * @throws Exception if there is an issue executing the tool\n+     *\/\n+    Result javac(String... args) throws Exception {\n+        return runTool(JAVAC, args);\n+    }\n+\n+    \/**\n+     * Executes {@code javac} in either a separate process or using its ToolProvider API.\n+     * The ToolProvider API is used if the directory and env parameters are {@code null},\n+     * and if the arguments definitely do not use \"classpath wildcards\", which are\n+     * only supported when the tool is invoked by the launcher.\n+     *\n+     * @param dir the directory, or {@code null}\n+     * @param env any additional environment variables, or {@code null}\n+     * @param args the arguments\n+     * @return an object containing the output and exit code from the tool\n+     * @throws Exception if there is an issue executing the tool\n+     *\/\n+    Result javac(Path dir, Map<String, String> env, String... args) throws Exception {\n+        return (env != null || dir != null || hasWildcardClassPath(args))\n+                ? execTool(dir, env, JAVAC, args)\n+                : runTool(JAVAC, args);\n+    }\n+\n+    \/**\n+     * {@return true if the arguments may contain a classpath option using a \"classpath wildcard\"}\n+     *\n+     * The result is {@code true} if there is any form of a classpath option whose value contains {@code *}.\n+     * Note: this may include \"false positives\", where the {@code *} is not at the end of\n+     * any element in the path, such as when the character is part of the filename.\n+     * However, in context, the approximation is safe, and just means that we may sometimes\n+     * execute javac in a separate process when it would be sufficient to use its ToolProvider API.\n+     *\n+     * A more refined implementation could split apart the path elements and looking for\n+     * an element that is {@code *} or which ends in {@code *}.\n+     *\n+     * @param args the arguments to be checked\n+     *\/\n+    private boolean hasWildcardClassPath(String... args) {\n+        for (int i = 0; i < args.length; i++) {\n+            String arg = args[i];\n+            switch (arg) {\n+                case \"-classpath\", \"--class-path\", \"-cp\" -> {\n+                    if (i + 1 < args.length && args[i + 1].contains(\"*\")) {\n+                        return true;\n+                    }\n+                }\n+                default -> {\n+                    if (arg.startsWith(\"--class-path=\") && arg.contains(\"*\")) {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Executes {@code jar} using its ToolProvider API.\n+     *\n+     * @param args the arguments\n+     * @return an object containing the output and exit code from the tool\n+     * @throws Exception if there is an issue executing the tool\n+     *\/\n+    Result jar(String... args) throws Exception {\n+        return runTool(JAR, args);\n+    }\n+\n+    \/**\n+     * Executes {@code jimage} using its ToolProvider API.\n+     *\n+     * @param args the arguments\n+     * @return an object containing the output and exit code from the tool\n+     * @throws Exception if there is an issue executing the tool\n+     *\/\n+    Result jimage(String... args) throws Exception {\n+        return execTool(null, null, JIMAGE, args);\n+    }\n+\n+    \/**\n+     * Executes {@code java} in a separate process.\n+     *\n+     * @param dir the directory, or {@code null}\n+     * @param env any additional environment variables, or {@code null}\n+     * @param args the arguments\n+     * @return an object containing the output and exit code from the launcher\n+     * @throws Exception if there is an issue executing the tool\n+     *\/\n+    Result java(Path dir, Map<String, String> env, String... args) throws Exception {\n+        return execTool(dir, env, JAVA, args);\n+    }\n+\n+    \/**\n+     * Runs a tool using its ToolProvider API.\n+     *\n+     * @param args the arguments\n+     * @return an object containing the output and exit code from the launcher\n+     * @throws Exception if there is an issue executing the tool\n+     *\/\n+    Result runTool(String name, String... args) throws Exception {\n+        out.println(name + \": \" + String.join(\" \", args));\n+        var tool = ToolProvider.findFirst(name)\n+                .orElseThrow(() -> new Exception(\"cannot find \" + name));\n+        try (StringWriter sw = new StringWriter();\n+             PrintWriter pw = new PrintWriter(sw)) {\n+            int rc = tool.run(pw, pw, args);\n+            pw.flush();\n+            String output = sw.toString();\n+            output.lines()\n+                    .forEach(l -> out.println(name + \": \" + l));\n+            if (rc != 0) {\n+                out.println(name + \": exit code \" + rc);\n+            }\n+            toolCounts.put(name, toolCounts.computeIfAbsent(name, n -> 0) + 1);\n+            return new Result(rc, output);\n+        }\n+    }\n+\n+    \/**\n+     * Executes a tool in a separate process.\n+     *\n+     * Note that any value of {@code CLASSPATH} inherited from this process will always be removed.\n+     *\n+     * @param dir the directory, or {@code null}\n+     * @param env any additional environment variables, or {@code null}\n+     * @param args the arguments\n+     * @return an object containing the output and exit code from the launcher\n+     * @throws Exception if there is an issue executing the tool\n+     *\/\n+    Result execTool(Path dir, Map<String, String> env, String name, String... args) throws Exception {\n+        out.print(name + \":\");\n+        if (env != null) {\n+            out.print(\" \" + env);\n+        }\n+        if (dir != null) {\n+            out.print(\" (\" + dir + \")\");\n+        }\n+        out.println(\" \" + String.join(\" \", args));\n+\n+        Path tool = javaHome.resolve(\"bin\").resolve(name + (ToolBox.isWindows() ? \".exe\" : \"\"));\n+        if (!Files.exists(tool)) {\n+            throw new Exception(\"cannot find \" + name);\n+        }\n+        var cmd = new ArrayList<String>();\n+        cmd.add(tool.toString());\n+        cmd.addAll(List.of(args));\n+        ProcessBuilder pb = new ProcessBuilder(cmd)\n+                .redirectErrorStream(true);\n+        pb.environment().remove(\"CLASSPATH\"); \/\/ always remove default value set by jtreg\n+        if (env != null) {\n+            pb.environment().putAll(env);\n+        }\n+        if (dir != null) {\n+            pb.directory(dir.toFile());\n+        }\n+        Process p = pb.start();\n+        StringBuilder sb = new StringBuilder();\n+        try (var in = p.inputReader()) {\n+            in.lines().forEach(l -> {\n+                sb.append(l).append(\"\\n\");\n+                out.println(name + \": \" + l);\n+            });\n+        }\n+        p.waitFor();\n+        int rc = p.exitValue();\n+        if (rc != 0) {\n+            out.println(name + \": exit code \" + rc);\n+        }\n+        execCounts.put(name, execCounts.computeIfAbsent(name, n -> 0) + 1);\n+        return new Result(rc, sb.toString());\n+    }\n+\n+    \/**\n+     * Checks that a series of files exist and are readable.\n+     *\n+     * @param paths the files\n+     * @throws Exception if any of the files are not found or are not readable\n+     *\/\n+    void checkFiles(String... paths) throws Exception {\n+        for (String p : paths) {\n+            Path path = Path.of(p);\n+            if (!Files.isReadable(path) ) {\n+                throw new Exception(\"file not found: \" + path);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * List the files in a directory that match a \"glob\" pattern.\n+     *\n+     * @param dir the directory\n+     * @param glob the pattern\n+     * @return the list of files\n+     * @throws IOException if there is a problem listing the contents of the directory\n+     *\/\n+    List<Path> listFiles(Path dir, String glob) throws IOException {\n+        var files = new ArrayList<Path>();\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(dir, glob)) {\n+            for (Path p : ds) {\n+                files.add(p);\n+            }\n+        }\n+        return files;\n+    }\n+\n+    \/**\n+     * Deletes a series of files.\n+     * The files are deleted using {@link ToolBox#cleanDirectory(Path)} and\n+     * {@code ToolBox#deleteFiles}, which together try hard to delete the files,\n+     * even on Windows.\n+     *\n+     * @param paths the paths\n+     * @throws IOException if there is a problem deleting any of the files\n+     * @see #deleteFiles(List)\n+     *\/\n+    void deleteFiles(String... paths) throws IOException {\n+        deleteFiles(Arrays.stream(paths)\n+                        .map(Path::of)\n+                        .toList());\n+    }\n+\n+    \/**\n+     * Deletes a series of files.\n+     * The files are deleted using {@link ToolBox#cleanDirectory(Path)} and\n+     * {@code ToolBox#deleteFiles}, which together try hard to delete the files,\n+     * even on Windows.\n+     *\n+     * @param paths the paths\n+     * @throws IOException if there is a problem deleting any of the files\n+     *\/\n+    void deleteFiles(List<Path> paths) throws IOException {\n+        for (Path path : paths) {\n+            if (Files.exists(path)) {\n+                if (Files.isDirectory(path)) {\n+                    tb.cleanDirectory(path);\n+                }\n+                tb.deleteFiles(path);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Moves a series of files into a given directory.\n+     *\n+     * @param files the files\n+     * @param dir the target directory\n+     * @throws IOException if there is a problem moving any of the files\n+     *\/\n+    void moveFiles(List<Path> files, Path dir) throws IOException {\n+        for (Path p : files) {\n+            tb.moveFile(p, dir);\n+        }\n+    }\n+\n+    \/**\n+     * Moves a series of files into a given directory.\n+     *\n+     * @param files the files\n+     * @param dir the target directory\n+     * @throws IOException if there is a problem moving any of the files\n+     *\/\n+    void moveFiles(List<String> files, String dir) throws IOException {\n+        for (String p : files) {\n+            tb.moveFile(p, dir);\n+        }\n+    }\n+\n+    \/**\n+     * {@return a map containing a setting for the {@code CLASSPATH} env variable}\n+     *\n+     * @param classpath the value for the env variable\n+     *\/\n+    Map<String, String> classpath(String classpath) {\n+        return Map.of(\"CLASSPATH\", classpath.replace(\"${PS}\", PS));\n+    }\n+\n+    \/**\n+     * Writes a file called {@code MANIFEST.MF} containing a given value for\n+     * the {@code Class-Path} entry.\n+     *\n+     * @param path the value for the {@code Class-Path} entry\n+     * @throws IOException if there is a problem writing the file\n+     *\/\n+    void makeManifestWithClassPath(String path) throws IOException {\n+        Files.writeString(Path.of(\"MANIFEST.MF\"),\n+                \"Manifest-Version: 1.0\\n\"\n+                    + \"Class-Path: \" + path + \"\\n\");\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/Paths\/Util.java","additions":560,"deletions":0,"binary":false,"changes":560,"status":"added"},{"patch":"@@ -1,115 +0,0 @@\n-#\n-# Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# Utilities for shell tests\n-\n-: ${TESTSRC=.} ${TESTCLASSES=.}\n-  java=\"${TESTJAVA+${TESTJAVA}\/bin\/}java${EXE_SUFFIX}\"\n- javac=\"${TESTJAVA+${TESTJAVA}\/bin\/}javac${EXE_SUFFIX}\"\n-   jar=\"${TESTJAVA+${TESTJAVA}\/bin\/}jar${EXE_SUFFIX}\"\n-jimage=\"${TESTJAVA+${TESTJAVA}\/bin\/}jimage${EXE_SUFFIX}\"\n-\n-case `uname -s` in\n-  Windows*|CYGWIN*|MSYS*|MINGW*)\n-    WindowsOnly() { \"$@\"; }\n-    UnixOnly() { :; }\n-    PS=\";\" ;;\n-  *)\n-    UnixOnly() { \"$@\"; }\n-    WindowsOnly() { :; }\n-    PS=\":\";;\n-esac\n-\n-failed=\"\"\n-Fail() { echo \"FAIL: $1\"; failed=\"${failed}.\"; }\n-\n-Die() { printf \"%s\\n\" \"$*\"; exit 1; }\n-\n-Sys() {\n-    printf \"%s\\n\" \"$*\"; \"$@\"; rc=\"$?\";\n-    test \"$rc\" -eq 0 || Die \"Command \\\"$*\\\" failed with exitValue $rc\";\n-}\n-\n-CheckFiles() {\n-    for f in \"$@\"; do test -r \"$f\" || Die \"File $f not found\"; done\n-}\n-\n-Report() {\n-    test \"$#\" != 2 && Die \"Usage: Report success|failure rc\"\n-\n-    if   test \"$1\" = \"success\" -a \"$2\" = 0; then\n-        echo \"PASS: succeeded as expected\"\n-    elif test \"$1\" = \"failure\" -a \"$2\" != 0; then\n-        echo \"PASS: failed as expected\"\n-    elif test \"$1\" = \"success\" -a \"$2\" != 0; then\n-        Fail \"test failed unexpectedly\"\n-    elif test \"$1\" = \"failure\" -a \"$2\" = 0; then\n-        Fail \"test succeeded unexpectedly\"\n-    else\n-        Die \"Usage: Report success|failure rc\"\n-    fi\n-}\n-\n-MkManifestWithClassPath() {\n-    (echo \"Manifest-Version: 1.0\"; echo \"Class-Path: $*\") > MANIFEST.MF\n-}\n-\n-HorizontalRule() {\n-    echo \"-----------------------------------------------------------------\"\n-}\n-\n-Test() {\n-    HorizontalRule\n-    expectedResult=\"$1\"; shift\n-    printf \"%s\\n\" \"$*\"\n-    \"$@\"\n-    Report \"$expectedResult\" \"$?\"\n-}\n-\n-Failure() { Test failure \"$@\"; }\n-Success() { Test success \"$@\"; }\n-\n-Bottom() {\n-    test \"$#\" = 1 -a \"$1\" = \"Line\" || Die \"Usage: Bottom Line\"\n-\n-    if test -n \"$failed\"; then\n-        count=`printf \"%s\" \"$failed\" | wc -c | tr -d ' '`\n-        echo \"FAIL: $count tests failed\"\n-        exit 1\n-    else\n-        echo \"PASS: all tests gave expected results\"\n-        exit 0\n-    fi\n-}\n-\n-BadJarFile() {\n-    for jarfilename in \"$@\"; do pwd > \"$jarfilename\"; done\n-}\n-\n-\n-#----------------------------------------------------------------\n-# Foil message localization\n-#----------------------------------------------------------------\n-DiagnosticsInEnglishPlease() {\n-    LANG=\"C\" LC_ALL=\"C\" LC_MESSAGES=\"C\"; export LANG LC_ALL LC_MESSAGES\n-}\n","filename":"test\/langtools\/tools\/javac\/Paths\/Util.sh","additions":0,"deletions":115,"binary":false,"changes":115,"status":"deleted"},{"patch":"@@ -0,0 +1,340 @@\n+\/*\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6268383 8172309 8293877\n+ * @summary Test classpath wildcards for javac and java -classpath option.\n+ * @library \/tools\/lib\n+ * @build toolbox.ToolBox Util WildcardMineField\n+ * @run main WildcardMineField\n+ *\/\n+\n+\/*\n+ * Converted from wcMineField.sh, originally written by Martin Buchholz.\n+ *\n+ * For the last version of the original, wcMineField.sh, see\n+ * https:\/\/git.openjdk.org\/jdk\/blob\/jdk-19%2B36\/test\/langtools\/tools\/javac\/Paths\/wcMineField.sh\n+ *\n+ * This class primarily tests support for \"classpath wildcards\", which is a feature\n+ * by which elements of a classpath option ending in {@code *} are expanded into\n+ * the set of jar files found in the directory preceding the {@code *}.\n+ *\n+ * Note that this feature is only implemented in the launcher, even for javac,\n+ * and so is only available when running javac via its launcher, in a separate process.\n+ *\n+ * Note that this feature does not affect the use of {@code *} elsewhere in any path,\n+ * classpath or otherwise, and so this class also tests the use of {@code *} and other special\n+ * characters (like {@code ,} and {@code ;}) in filenames. Some of these tests,\n+ * labelled in the original code as \"UnixOnly\", do not apply to Windows.\n+ *\n+ * For information on the launcher support for the {@code -classpath} option,\n+ * see the java man page. As of September 2022, there is no equivalent documentation\n+ * for javac, except to say that the support is only in the native launcher for javac,\n+ * and not in the main javac source code.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import toolbox.ToolBox;\n+\n+public class WildcardMineField extends Util {\n+    public static void main(String... args) throws Exception {\n+        new WildcardMineField().run(args);\n+    }\n+\n+    void run(String... args) throws Exception {\n+        setup();\n+        tests();\n+        cleanup();\n+        bottomLine();\n+    }\n+\n+    void setup() throws Exception {\n+        cleanup();\n+        tb.createDirectories(\"GooSrc\", \"GooJar\", \"GooZip\", \"GooClass\", \"GooJar\/SubDir\");\n+        tb.createDirectories(\"BadSrc\", \"BadJar\", \"BadZip\", \"BadClass\");\n+        tb.createDirectories(\"SpeSrc\", \"SpeJar\", \"SpeZip\", \"SpeClass\");\n+        tb.createDirectories(\"JarNClass\", \"StarJar\", \"MixJar\");\n+        Files.writeString(Path.of(\"Lib.java\"), \"public class Lib  {public static void f(){}}\");\n+        Files.writeString(Path.of(\"Lib2.java\"), \"public class Lib2 {public static void g(){}}\");\n+        Files.writeString(Path.of(\"Lib3.java\"), \"public class Lib3 {public static void h(){}}\");\n+        javac(\"Lib.java\", \"Lib2.java\", \"Lib3.java\");\n+        tb.copyFile(\"Lib.class\", \"JarNClass\/.\");\n+        jar(\"cf\", \"GooJar\/Lib.jar\", \"Lib.class\");\n+        jar(\"cf\", \"GooJar\/SubDir\/Lib2.jar\", \"Lib2.class\");\n+        jar(\"cf\", \"JarNClass\/Lib.jar\", \"Lib.class\");\n+\n+        jar(\"cf\", \"GooZip\/Lib.zip\", \"Lib.class\");\n+        tb.moveFile(\"Lib.class\", \"GooClass\/.\");\n+        tb.moveFile(\"Lib2.class\", \"GooClass\/.\");\n+        tb.moveFile(\"Lib3.class\", \"GooClass\/.\");\n+        tb.moveFile(\"Lib.java\", \"GooSrc\/.\");\n+        tb.moveFile(\"Lib2.java\", \"GooSrc\/.\");\n+        tb.moveFile(\"Lib3.java\", \"GooSrc\/.\");\n+\n+        checkFiles(\"GooZip\/Lib.zip\", \"GooJar\/Lib.jar\", \"GooSrc\/Lib.java\");\n+        checkFiles(\"GooSrc\/Lib2.java\", \"GooSrc\/Lib3.java\", \"GooJar\/SubDir\/Lib2.jar\");\n+\n+        Files.writeString(Path.of(\"Spe1.java\"), \"public class Spe1 {public static void f(){}}\");\n+        Files.writeString(Path.of(\"Spe2.java\"), \"public class Spe2 {public static void f(){}}\");\n+        Files.writeString(Path.of(\"Spe3.java\"), \"public class Spe3 {public static void f(){}}\");\n+        Files.writeString(Path.of(\"Spe4.java\"), \"public class Spe4 {public static void f(){}}\");\n+        javac(\"Spe1.java\", \"Spe2.java\", \"Spe3.java\", \"Spe4.java\");\n+\n+        if (!ToolBox.isWindows()) {\n+            jar(\"cf\", \"SpeJar\/Spe:Colon.jar\", \"Spe1.class\");\n+            jar(\"cf\", \"SpeJar\/Spe*wc.jar\", \"Spe4.class\");\n+            checkFiles(\"SpeJar\/Spe*wc.jar\");\n+\n+            jar(\"cf\", \"StarJar\/*jar.jar\", \"Spe2.class\");\n+            jar(\"cf\", \"StarJar\/jar*.jar\", \"Spe3.class\");\n+            jar(\"cf\", \"StarJar\/*jar*.jar\", \"Spe4.class\");\n+            checkFiles(\"StarJar\/*jar.jar\", \"StarJar\/jar*.jar\", \"StarJar\/*jar*.jar\");\n+        }\n+\n+        jar(\"cf\", \"SpeJar\/Spe,Comma.jar\", \"Spe2.class\");\n+        jar(\"cf\", \"SpeJar\/Spe;Semi.jar\", \"Spe3.class\");\n+\n+        jar(\"cf\", \"MixJar\/mix.jAr\", \"Spe1.class\");\n+        jar(\"cf\", \"MixJar\/mix2.JAR\", \"Spe2.class\");\n+        jar(\"cf\", \"MixJar\/mix3.zip\", \"Spe3.class\");\n+        jar(\"cf\", \"MixJar\/.hiddenjar.jar\", \"Spe4.class\");\n+\n+        moveFiles(listFiles(curDir, \"Spe*.class\"), Path.of(\"SpeClass\/.\"));\n+        moveFiles(listFiles(curDir, \"Spe*.java\"), Path.of(\"SpeSrc\/.\"));\n+        checkFiles(\"SpeJar\/Spe,Comma.jar\", \"SpeJar\/Spe;Semi.jar\", \"SpeSrc\/Spe2.java\", \"SpeSrc\/Spe3.\" +\n+                \"java\", \"SpeSrc\/Spe4.java\");\n+        checkFiles(\"MixJar\/mix.jAr\", \"MixJar\/mix2.JAR\", \"MixJar\/mix3.zip\", \"MixJar\/.hiddenjar.jar\");\n+\n+        Files.writeString(Path.of(\"Main.java\"), \"public class Main {public static void main(String[] a) {Lib.f();}}\");\n+        Files.writeString(Path.of(\"Main1.java\"), \"public class Main1 {public static void main(String[] a) {Lib2.g();}}\");\n+        Files.writeString(Path.of(\"Main1b.java\"), \"public class Main1b {public static void main(String[] a) {Spe1.f();}}\");\n+        Files.writeString(Path.of(\"Main2.java\"), \"public class Main2 {public static void main(String[] a) {Spe2.f();}}\");\n+        Files.writeString(Path.of(\"Main3.java\"), \"public class Main3 {public static void main(String[] a) {Spe3.f();}}\");\n+        Files.writeString(Path.of(\"Main4.java\"), \"public class Main4 {public static void main(String[] a) {Spe4.f();}}\");\n+        Files.writeString(Path.of(\"Main5.java\"), \"public class Main5 {public static void main(String[] a) {Spe2.f(); Lib.f();}}\");\n+        Files.writeString(Path.of(\"Main6.java\"), \"public class Main6 {public static void main(String[] a) {Lib3.h();}}\");\n+    }\n+\n+    void cleanup() throws IOException {\n+        deleteFiles(\"GooSrc\", \"GooJar\", \"GooZip\", \"GooClass\");\n+        deleteFiles(\"SpeSrc\", \"SpeJar\", \"SpeZip\", \"SpeClass\");\n+        deleteFiles(\"BadSrc\", \"BadJar\", \"BadZip\", \"BadClass\");\n+        deleteFiles(\"JarNClass\", \"StarJar\", \"MixJar\", \"StarDir\");\n+        deleteFiles(\"OneDir\", \"MANIFEST.MF\");\n+        deleteFiles(listFiles(curDir, \"*.class\"));\n+        deleteFiles(listFiles(curDir, \"Main*.java\"));\n+    }\n+\n+    void tests() throws Exception {\n+        if (!ToolBox.isWindows()) {\n+            starDirTests();\n+        }\n+\n+        \/*----------------------------------------------------------------\n+         * Verify the basic jar file works\n+         *----------------------------------------------------------------*\/\n+\n+        \/\/ baseline test to verify it works.\n+        expectPass(JAVAC, \"-cp GooJar\/Lib.jar Main.java\");\n+        expectPass(JAVAC, \"-classpath GooJar\/Lib.jar Main.java\");\n+        expectPass(JAVA, \"-classpath GooJar\/Lib.jar${PS}. Main\");\n+        expectPass(JAVA, \"-cp GooJar\/Lib.jar${PS}. Main\");\n+\n+        \/\/ basic test of one jar to be loaded\n+        if (!ToolBox.isWindows()) {\n+            expectPass(JAVAC, \"-classpath GooJar\/* Main.java\");\n+        }\n+        expectPass(JAVAC, \"-classpath GooJar\/*${PS}. Main.java\");\n+        expectPass(JAVA, \"-classpath GooJar\/*${PS}. Main\");\n+\n+        \/\/ in a subdir. First * should not load jars in subdirectories unless specified\n+        expectFail(JAVAC, \"-classpath GooJar\/* Main1.java\");\n+        expectFail(JAVAC, \" -classpath GooJar\/*${PS}. Main1.java\");\n+        expectPass(JAVAC, \"-cp GooJar\/SubDir\/* Main1.java\");\n+        expectPass(JAVAC, \"-classpath GooJar\/SubDir\/* Main1.java\");\n+        expectPass(JAVAC, \"--class-path GooJar\/SubDir\/* Main1.java\");\n+        expectPass(JAVAC, \"--class-path=GooJar\/SubDir\/* Main1.java\");\n+\n+        \/\/ Same with launcher. Should not load jar in subdirectories unless specified\n+        expectFail(JAVA, \"-classpath GooJar\/*${PS}. Main1\");\n+        expectPass(JAVA, \"-classpath GooJar\/SubDir\/*${PS}. Main1\");\n+        expectPass(JAVA, \"-cp GooJar\/SubDir\/*${PS}. Main1\");\n+\n+        expectPass(classpath(\"GooJar\/SubDir\/*\"), JAVAC, \"Main1.java\");\n+        expectPass(classpath(\"GooJar\/SubDir\/*${PS}.\"), JAVA, \"Main1\");\n+\n+        \/*----------------------------------------------------------------\n+         * Verify the jar files in 2 directories\n+         *----------------------------------------------------------------*\/\n+\n+        expectPass(JAVAC, \"-classpath GooJar\/Lib.jar${PS}SpeJar\/Spe,Comma.jar Main5.java\");\n+        expectPass(JAVA, \"-classpath GooJar\/Lib.jar${PS}SpeJar\/Spe,Comma.jar${PS}. Main5\");\n+\n+        expectPass(JAVAC, \"-classpath GooJar\/*${PS}SpeJar\/* Main5.java\");\n+        expectPass(JAVA, \"-classpath GooJar\/*${PS}SpeJar\/*${PS}. Main5\");\n+\n+        \/*----------------------------------------------------------------\n+         * Verify jar file and class file in same directory.\n+         *----------------------------------------------------------------*\/\n+\n+        expectPass(JAVAC, \"-classpath JarNClass\/*${PS} Main.java\");\n+        expectPass(JAVA, \"-classpath JarNClass\/*${PS}. Main\");\n+\n+        \/*----------------------------------------------------------------\n+         * Verify these odd jar files work explicitly on classpath, kind of\n+         * a baseline. Last one is also a test with * in a jar name.\n+         *----------------------------------------------------------------*\/\n+\n+        expectFail(JAVAC, \"-classpath SpeJar\/Spe:Colon.jar Main1.java\");\n+\n+        expectPass(JAVAC, \"-classpath SpeJar\/Spe,Comma.jar Main2.java\");\n+        expectPass(JAVA, \"-classpath SpeJar\/Spe,Comma.jar${PS}. Main2\");\n+\n+        if (!ToolBox.isWindows()) {\n+            expectPass(JAVAC, \"-classpath SpeJar\/Spe;Semi.jar Main3.java\");\n+            expectPass(JAVA, \"-classpath SpeJar\/Spe;Semi.jar${PS}. Main3\");\n+\n+            expectPass(JAVAC, \"-classpath SpeJar\/Spe*wc.jar Main4.java\");\n+            expectPass(JAVA, \"-classpath SpeJar\/Spe*wc.jar${PS}. Main4\");\n+        }\n+\n+        if (!ToolBox.isWindows()) {\n+            speJar();\n+        }\n+\n+        if (!ToolBox.isWindows()) {\n+            starJar();\n+        }\n+\n+        \/*----------------------------------------------------------------\n+         * Verify these jar files with varying extensions\n+         *----------------------------------------------------------------*\/\n+\n+        \/\/ Mixed case extensions should not be loaded.\n+        expectFail(JAVAC, \"-classpath MixJar\/* Main1b.java\");\n+        expectPass(JAVAC, \"-classpath MixJar\/mix.jAr Main1b.java\");\n+        expectFail(JAVAC, \"-classpath MixJar\/* Main1b\");\n+\n+        \/\/ upper case, .JAR, extension should be loaded\n+        if (!ToolBox.isWindows()) {\n+            expectPass(JAVAC, \"-classpath MixJar\/* Main2.java\");\n+        }\n+        expectPass(JAVAC, \"-classpath .${PS}MixJar\/* Main2.java\");\n+\n+        expectPass(JAVA, \"-classpath MixJar\/*${PS}. Main2\");\n+\n+        \/\/ zip extensions should not be loaded\n+        expectFail(JAVAC, \"-classpath MixJar\/* Main3.java\");\n+        expectPass(JAVAC, \"-classpath MixJar\/mix3.zip Main3.java\");\n+        expectFail(JAVA, \"-classpath MixJar\/*${PS}. Main3\");\n+\n+        \/\/ unix \"hidden\" file\n+        if (!ToolBox.isWindows()) {\n+            expectPass(JAVAC, \"-classpath MixJar\/* Main4.java\");\n+            expectPass(JAVA, \"-classpath MixJar\/*${PS}. Main4\");\n+        }\n+    }\n+\n+    void starDirTests() throws Exception {\n+        out.println(\"Running tests with directory named \\\"*\\\"\");\n+        deleteFiles(\".\/StarDir\");\n+        tb.createDirectories(\"StarDir\/*\");\n+        tb.copyFile(\"GooClass\/Lib2.class\", \"StarDir\/*\/Lib2.class\");\n+        jar(\"cf\", \"StarDir\/Lib3.jar\", \"-C\", \"GooClass\", \"Lib3.class\");\n+        jar(\"cf\", \"StarDir\/*\/Lib.jar\", \"-C\", \"GooClass\", \"Lib.class\");\n+        checkFiles(\"StarDir\/*\/Lib.jar\", \"StarDir\/*\/Lib2.class\", \"StarDir\/Lib3.jar\");\n+        tb.copyFile(\"Main6.java\", \".\/StarDir\/.\");\n+        tb.copyFile(\"Main.java\", \".\/StarDir\/*\/.\");\n+        tb.copyFile(\"Main1.java\", \".\/StarDir\/*\/.\");\n+        Path StarDir = Path.of(\"StarDir\");\n+        expectFail(StarDir, JAVAC, \"-classpath * Main6.java\");\n+        expectFail(StarDir, JAVAC, \"-classpath .\/* Main6.java\");\n+        deleteFiles(listFiles(StarDir, \"Main6.*\"));\n+        Path StarDir_star = StarDir.resolve(\"*\");\n+        expectPass(StarDir_star, JAVAC, \"-classpath * Main.java\");\n+        expectPass(StarDir_star, JAVA, \"-classpath .${PS}* Main\");\n+        expectPass(StarDir_star, JAVAC, \"Main1.java\");\n+        expectPass(StarDir_star, JAVA, \"-classpath . Main1\");\n+\n+        expectFail(JAVAC, \"-classpath StarDir\/* Main6.java\");\n+\n+        expectPass(JAVAC, \"-classpath StarDir\/* Main1.java\");\n+        expectPass(JAVA, \"-classpath StarDir\/*:. Main1\");\n+\n+        expectPass(JAVAC, \"-classpath StarDir\/* Main1.java\");\n+        expectPass(JAVA, \"-classpath .${PS}StarDir\/* Main1\");\n+\n+        expectFail(JAVAC, \"-classpath StarDir\/\\\\*\/* Main.java\");\n+        expectPass(JAVAC, \"-classpath StarDir\/*\/* Main.java\");\n+\n+        expectPass(JAVA, \"-classpath .${PS}StarDir\/*\/* Main\");\n+        expectFail(JAVA, \"-classpath .${PS}StarDir\/\\\\*\/* Main\");\n+\n+        expectPass(JAVAC, \"-classpath StarDir\/Lib3.jar Main6.java\");\n+        expectPass(JAVA, \"-classpath .${PS}StarDir\/Lib3.jar Main6\");\n+\n+        expectPass(JAVAC, \"-classpath StarDir\/*\/Lib.jar Main.java\");\n+        expectPass(JAVA, \"-classpath .${PS}StarDir\/*\/Lib.jar Main\");\n+    }\n+\n+    void speJar() throws Exception {\n+        out.println(\"Running tests with jar file names containing special characters\");\n+\n+        expectPass(JAVAC, \"-classpath SpeJar\/* Main2.java\");\n+        expectPass(JAVA, \"-classpath SpeJar\/*${PS}. Main2\");\n+\n+        expectPass(JAVAC, \"-classpath SpeJar\/* Main3.java\");\n+        expectPass(JAVA, \"-classpath SpeJar\/*${PS}. Main3\");\n+\n+        expectPass(JAVAC, \"-classpath SpeJar\/* Main4.java\");\n+        expectPass(JAVA, \"-classpath SpeJar\/*${PS}. Main4\");\n+    }\n+\n+    \/*----------------------------------------------------------------\n+     * Verify these jar files with asterisk in jar file name\n+     *----------------------------------------------------------------*\/\n+    void starJar() throws Exception {\n+        out.println(\"Running tests with jar file names containing \\\"*\\\"\");\n+        expectPass(JAVAC, \"-classpath StarJar\/*jar.jar Main2.java\");\n+        expectPass(JAVA, \"-classpath StarJar\/*jar.jar${PS}. Main2\");\n+\n+        expectPass(JAVAC, \"-classpath StarJar\/jar*.jar Main3.java\");\n+        expectPass(JAVA, \"-classpath StarJar\/jar*.jar${PS}. Main3\");\n+\n+        expectPass(JAVAC, \"-classpath StarJar\/*jar*.jar Main4.java\");\n+        expectPass(JAVA, \"-classpath StarJar\/*jar*.jar${PS}. Main4\");\n+\n+        expectPass(JAVAC, \"-classpath StarJar\/* Main2.java\");\n+        expectPass(JAVA, \"-classpath StarJar\/*${PS}. Main2\");\n+\n+        expectPass(JAVAC, \"-classpath StarJar\/* Main3.java\");\n+        expectPass(JAVA, \"-classpath StarJar\/*${PS}. Main3\");\n+\n+        expectPass(JAVAC, \"-classpath StarJar\/* Main4.java\");\n+        expectPass(JAVA, \"-classpath StarJar\/*${PS}. Main4\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/Paths\/WildcardMineField.java","additions":340,"deletions":0,"binary":false,"changes":340,"status":"added"},{"patch":"@@ -1,296 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2005, 2015, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-# @test\n-# @summary Test classpath wildcards for javac and java -classpath option.\n-# @bug 6268383 8172309\n-# @run shell\/timeout=600 wcMineField.sh\n-\n-# To run this test manually, simply do .\/wcMineField.sh\n-#----------------------------------------------------------------\n-\n-. ${TESTSRC-.}\/Util.sh\n-\n-set -u\n-\n-#----------------------------------------------------------------\n-# Note that, on Windows only, the launcher also includes another\n-# kind of command-line wildcard expansion, via setargv.obj\n-# http:\/\/msdn.microsoft.com\/library\/default.asp?url=\/library\/en-us\/vccelng\/htm\/progs_11.asp\n-# Therefore, on Windows, -classpath \"foo\/*\" is treated differently\n-# from -classpath \".${PS}foo\/*\"\n-#----------------------------------------------------------------\n-\n-#----------------------------------------------------------------\n-# Prepare the \"Minefield\"\n-#----------------------------------------------------------------\n-Cleanup() {\n-    Sys rm -rf GooSrc GooJar GooZip GooClass\n-         Sys rm -rf SpeSrc SpeJar SpeZip SpeClass\n-    Sys rm -rf BadSrc BadJar BadZip BadClass\n-         Sys rm -rf JarNClass StarJar MixJar StarDir\n-    Sys rm -rf OneDir *.class Main*.java MANIFEST.MF\n-}\n-\n-Cleanup\n-Sys mkdir  GooSrc GooJar GooZip GooClass GooJar\/SubDir\n-Sys mkdir  BadSrc BadJar BadZip BadClass\n-Sys mkdir  SpeSrc SpeJar SpeZip SpeClass\n-Sys mkdir  JarNClass StarJar MixJar\n-echo 'public class Lib  {public static void f(){}}' > Lib.java\n-echo 'public class Lib2 {public static void g(){}}' > Lib2.java\n-echo 'public class Lib3 {public static void h(){}}' > Lib3.java\n-Sys \"$javac\" ${TESTTOOLVMOPTS} Lib.java Lib2.java Lib3.java\n-Sys cp Lib.class JarNClass\/.\n-Sys \"$jar\" cf GooJar\/Lib.jar Lib.class\n-Sys \"$jar\" cf GooJar\/SubDir\/Lib2.jar Lib2.class\n-Sys \"$jar\" cf JarNClass\/Lib.jar Lib.class\n-\n-Sys \"$jar\" cf GooZip\/Lib.zip Lib.class\n-Sys mv Lib.class GooClass\/.\n-Sys mv Lib2.class GooClass\/.\n-Sys mv Lib3.class GooClass\/.\n-Sys mv Lib.java GooSrc\/.\n-Sys mv Lib2.java GooSrc\/.\n-Sys mv Lib3.java GooSrc\n-CheckFiles GooZip\/Lib.zip GooJar\/Lib.jar GooSrc\/Lib.java\n-CheckFiles GooSrc\/Lib2.java GooSrc\/Lib3.java GooJar\/SubDir\/Lib2.jar\n-\n-echo 'public class Spe1 {public static void f(){}}' > Spe1.java\n-echo 'public class Spe2 {public static void f(){}}' > Spe2.java\n-echo 'public class Spe3 {public static void f(){}}' > Spe3.java\n-echo 'public class Spe4 {public static void f(){}}' > Spe4.java\n-Sys \"$javac\" ${TESTTOOLVMOPTS} Spe1.java\n-Sys \"$javac\" ${TESTTOOLVMOPTS} Spe2.java\n-Sys \"$javac\" ${TESTTOOLVMOPTS} Spe3.java\n-Sys \"$javac\" ${TESTTOOLVMOPTS} Spe4.java\n-\n-UnixOnly Sys \"$jar\" cf \"SpeJar\/Spe:Colon.jar\" Spe1.class\n-UnixOnly Sys \"$jar\" cf \"SpeJar\/Spe*wc.jar\" Spe4.class\n-UnixOnly CheckFiles \"SpeJar\/Spe*wc.jar\"\n-\n-UnixOnly Sys \"$jar\" cf \"StarJar\/*jar.jar\" Spe2.class\n-UnixOnly Sys \"$jar\" cf \"StarJar\/jar*.jar\" Spe3.class\n-UnixOnly Sys \"$jar\" cf \"StarJar\/*jar*.jar\" Spe4.class\n-UnixOnly CheckFiles \"StarJar\/*jar.jar\" \"StarJar\/jar*.jar\" \"StarJar\/*jar*.jar\"\n-\n-Sys \"$jar\" cf \"SpeJar\/Spe,Comma.jar\" Spe2.class\n-Sys \"$jar\" cf \"SpeJar\/Spe;Semi.jar\" Spe3.class\n-\n-Sys \"$jar\" cf \"MixJar\/mix.jAr\" Spe1.class\n-Sys \"$jar\" cf \"MixJar\/mix2.JAR\" Spe2.class\n-Sys \"$jar\" cf \"MixJar\/mix3.zip\" Spe3.class\n-Sys \"$jar\" cf \"MixJar\/.hiddenjar.jar\" Spe4.class\n-\n-Sys mv Spe*.class SpeClass\/.\n-Sys mv Spe*.java SpeSrc\/.\n-CheckFiles \"SpeJar\/Spe,Comma.jar\" \"SpeJar\/Spe;Semi.jar\" \"SpeSrc\/Spe2.java\" \"SpeSrc\/Spe3.java\" \"SpeSrc\/Spe4.java\"\n-CheckFiles \"MixJar\/mix.jAr\" \"MixJar\/mix2.JAR\" \"MixJar\/mix3.zip\" \"MixJar\/.hiddenjar.jar\"\n-\n-echo 'public class Main {public static void main(String[] a) {Lib.f();}}' > Main.java\n-echo 'public class Main1 {public static void main(String[] a) {Lib2.g();}}' > Main1.java\n-echo 'public class Main1b {public static void main(String[] a) {Spe1.f();}}' > Main1b.java\n-echo 'public class Main2 {public static void main(String[] a) {Spe2.f();}}' > Main2.java\n-echo 'public class Main3 {public static void main(String[] a) {Spe3.f();}}' > Main3.java\n-echo 'public class Main4 {public static void main(String[] a) {Spe4.f();}}' > Main4.java\n-echo 'public class Main5 {public static void main(String[] a) {Spe2.f(); Lib.f();}}' > Main5.java\n-echo 'public class Main6 {public static void main(String[] a) {Lib3.h();}}' > Main6.java\n-\n-\n-#----------------------------------------------------------------\n-# Verify expected behaviour with directory named \"*\"\n-#----------------------------------------------------------------\n-starDir() {\n-    printf \"Running tests with directory named \\\"*\\\"\\n\"\n-    Sys rm -rf .\/StarDir\n-    Sys mkdir -p StarDir\/\"*\"\n-    Sys cp \"GooClass\/Lib2.class\" \"StarDir\/*\/Lib2.class\"\n-    Sys \"$jar\" cf \"StarDir\/Lib3.jar\" -C GooClass \"Lib3.class\"\n-    Sys \"$jar\" cf \"StarDir\/*\/Lib.jar\" -C GooClass \"Lib.class\"\n-    CheckFiles \"StarDir\/*\/Lib.jar\" \"StarDir\/*\/Lib2.class\" \"StarDir\/Lib3.jar\"\n-    Sys cp Main6.java .\/StarDir\/.\n-    Sys cp Main.java  .\/StarDir\/\"*\"\/.\n-    Sys cp Main1.java .\/StarDir\/\"*\"\/.\n-    CPWC_DIR=`pwd`\n-    Sys cd StarDir\n-    Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \"*\" Main6.java\n-    Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \".\/*\" Main6.java\n-    Sys rm -f Main6.*\n-    Sys cd \"*\"\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"*\" Main.java\n-    Success \"$java\" ${TESTVMOPTS} -classpath .${PS}\"*\" Main\n-    Success \"$javac\" ${TESTTOOLVMOPTS} Main1.java\n-    Success \"$java\" ${TESTVMOPTS} -classpath \".\" Main1\n-    Sys cd $CPWC_DIR\n-\n-    Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \"StarDir\/*\" Main6.java\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath StarDir\/\\* Main1.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath StarDir\/\\*:. Main1\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"StarDir\/*\" Main1.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \".${PS}StarDir\/*\" Main1\n-\n-    Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath StarDir\/\"\\*\/*\" Main.java\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath StarDir\/\"*\/*\" Main.java\n-\n-    Success \"$java\" ${TESTVMOPTS}  -classpath .${PS}StarDir\/\"*\/*\" Main\n-    Failure \"$java\" ${TESTVMOPTS}  -classpath .${PS}StarDir\/\"\\*\/*\" Main\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"StarDir\/Lib3.jar\" Main6.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \".${PS}StarDir\/Lib3.jar\" Main6\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath StarDir\/\"*\"\/Lib.jar Main.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath .${PS}StarDir\/\"*\"\/Lib.jar Main\n-}\n-UnixOnly starDir\n-\n-#----------------------------------------------------------------\n-# Verify the basic jar file works\n-#----------------------------------------------------------------\n-#baseline test to verify it works.\n-Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"GooJar\/Lib.jar\" Main.java\n-Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"GooJar\/Lib.jar\" Main.java\n-Success \"$java\" ${TESTVMOPTS}  -classpath \"GooJar\/Lib.jar${PS}.\" Main\n-Success \"$java\" ${TESTVMOPTS}  -cp \"GooJar\/Lib.jar${PS}.\" Main\n-\n-#basic test of one jar to be loaded\n-UnixOnly Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"GooJar\/*\"       Main.java\n-         Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"GooJar\/*${PS}.\" Main.java\n-Success \"$java\" ${TESTVMOPTS}  -classpath \"GooJar\/*${PS}.\" Main\n-#in a subdir. First * should not load jars in subdirectories unless specified\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \"GooJar\/*\" Main1.java\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \"GooJar\/*${PS}.\" Main1.java\n-Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"GooJar\/SubDir\/*\" Main1.java\n-Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"GooJar\/SubDir\/*\" Main1.java\n-Success \"$javac\" ${TESTTOOLVMOPTS} --class-path \"GooJar\/SubDir\/*\" Main1.java\n-Success \"$javac\" ${TESTTOOLVMOPTS} --class-path=\"GooJar\/SubDir\/*\" Main1.java\n-#Same with launcher. Should not load jar in subdirectories unless specified\n-Failure \"$java\" ${TESTVMOPTS}  -classpath \"GooJar\/*${PS}.\" Main1\n-Success \"$java\" ${TESTVMOPTS}  -classpath \"GooJar\/SubDir\/*${PS}.\" Main1\n-Success \"$java\" ${TESTVMOPTS}  -cp \"GooJar\/SubDir\/*${PS}.\" Main1\n-\n-Success env CLASSPATH=\"GooJar\/SubDir\/*\" \"$javac\" ${TESTTOOLVMOPTS} Main1.java\n-Success env CLASSPATH=\"GooJar\/SubDir\/*${PS}.\" \"$java\" ${TESTVMOPTS} Main1\n-#----------------------------------------------------------------\n-# Verify the jar files in 2 directories\n-#----------------------------------------------------------------\n-Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"GooJar\/Lib.jar${PS}SpeJar\/Spe,Comma.jar\" Main5.java\n-Success \"$java\" ${TESTVMOPTS}  -classpath \"GooJar\/Lib.jar${PS}SpeJar\/Spe,Comma.jar${PS}.\" Main5\n-\n-Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"GooJar\/*${PS}SpeJar\/*\" Main5.java\n-Success \"$java\" ${TESTVMOPTS}  -classpath \"GooJar\/*${PS}SpeJar\/*${PS}.\" Main5\n-\n-#----------------------------------------------------------------\n-# Verify jar file and class file in same directory.\n-#----------------------------------------------------------------\n-Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"JarNClass\/*${PS}\" Main.java\n-Success \"$java\" ${TESTVMOPTS}  -classpath \"JarNClass\/*${PS}.\" Main\n-\n-#----------------------------------------------------------------\n-# Verify these odd jar files work explicitly on classpath, kind of\n-# a baseline. Last one is also a test with * in a jar name.\n-#----------------------------------------------------------------\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \"SpeJar\/Spe:Colon.jar\" Main1.java\n-\n-Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"SpeJar\/Spe,Comma.jar\" Main2.java\n-Success \"$java\" ${TESTVMOPTS}  -classpath \"SpeJar\/Spe,Comma.jar${PS}.\" Main2\n-\n-UnixOnly Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"SpeJar\/Spe;Semi.jar\" Main3.java\n-UnixOnly Success \"$java\" ${TESTVMOPTS}  -classpath \"SpeJar\/Spe;Semi.jar${PS}.\" Main3\n-\n-UnixOnly Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"SpeJar\/Spe*wc.jar\" Main4.java\n-UnixOnly Success \"$java\" ${TESTVMOPTS}  -classpath \"SpeJar\/Spe*wc.jar${PS}.\" Main4\n-#----------------------------------------------------------------\n-# Verify these odd jar files work with classpath wildcard.\n-#----------------------------------------------------------------\n-\n-speJar() {\n-    printf \"Running tests with jar file names containing special characters\\n\"\n-#     Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \"SpeJar\/*\" Main1.java\n-#     Success \"$java\" ${TESTVMOPTS}  -classpath \"SpeJar\/*\" Main1\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"SpeJar\/*\" Main2.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \"SpeJar\/*${PS}.\" Main2\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"SpeJar\/*\" Main3.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \"SpeJar\/*${PS}.\" Main3\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"SpeJar\/*\" Main4.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \"SpeJar\/*${PS}.\" Main4\n-}\n-UnixOnly speJar\n-\n-#----------------------------------------------------------------\n-# Verify these jar files with asterisk in jar file name\n-#----------------------------------------------------------------\n-starJar() {\n-    printf \"Running tests with jar file names containing \\\"*\\\"\\n\"\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"StarJar\/*jar.jar\" Main2.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \"StarJar\/*jar.jar${PS}.\" Main2\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"StarJar\/jar*.jar\" Main3.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \"StarJar\/jar*.jar${PS}.\" Main3\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"StarJar\/*jar*.jar\" Main4.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \"StarJar\/*jar*.jar${PS}.\" Main4\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"StarJar\/*\" Main2.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \"StarJar\/*${PS}.\" Main2\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"StarJar\/*\" Main3.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \"StarJar\/*${PS}.\" Main3\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"StarJar\/*\" Main4.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \"StarJar\/*${PS}.\" Main4\n-}\n-UnixOnly starJar\n-\n-#----------------------------------------------------------------\n-# Verify these jar files with varying extensions\n-#----------------------------------------------------------------\n-# Mixed case extensions should not be loaded.\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \"MixJar\/*\" Main1b.java\n-Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"MixJar\/mix.jAr\" Main1b.java\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \"MixJar\/*\" Main1b\n-\n-#upper case, .JAR, extension should be loaded\n-UnixOnly Success \"$javac\" ${TESTTOOLVMOPTS} -classpath       \"MixJar\/*\" Main2.java\n-         Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \".${PS}MixJar\/*\" Main2.java\n-\n-Success \"$java\" ${TESTVMOPTS}  -classpath \"MixJar\/*${PS}.\" Main2\n-# zip extensions should not be loaded\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \"MixJar\/*\" Main3.java\n-Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"MixJar\/mix3.zip\" Main3.java\n-Failure \"$java\" ${TESTVMOPTS}  -classpath \"MixJar\/*${PS}.\" Main3\n-# unix \"hidden\" file\n-UnixOnly Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"MixJar\/*\" Main4.java\n-UnixOnly Success \"$java\" ${TESTVMOPTS}  -classpath \"MixJar\/*${PS}.\" Main4\n-\n-Cleanup\n-\n-Bottom Line\n-#----------------------------------------------------------------\n","filename":"test\/langtools\/tools\/javac\/Paths\/wcMineField.sh","additions":0,"deletions":296,"binary":false,"changes":296,"status":"deleted"},{"patch":"@@ -248,1 +248,1 @@\n-        } else {\n+        } else if (to.getParent() != null) {\n","filename":"test\/langtools\/tools\/lib\/toolbox\/ToolBox.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,0 +123,1 @@\n+    private volatile Integer exitValue; \/\/ null implies we don't yet know\n@@ -149,0 +150,3 @@\n+      if (exitValue != null) {\n+        return exitValue;\n+      }\n@@ -153,1 +157,1 @@\n-              int result = p.waitFor();\n+              exitValue = p.waitFor();\n@@ -156,1 +160,1 @@\n-              return result;\n+              return exitValue;\n","filename":"test\/lib\/jdk\/test\/lib\/process\/OutputBuffer.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    ONE(\"1000\",\n+    ONE(\"10:00\",\n","filename":"test\/lib\/jdk\/test\/lib\/security\/TestCertificate.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-    public static final String CERT_SERIAL = \"edbec8f705af2514\";\n-    public static final String ANCHOR_CERT_SERIAL = \"8e191778b2f331be\";\n+    public static final String CERT_SERIAL = \"00:ed:be:c8:f7:05:af:25:14\";\n+    public static final String ANCHOR_CERT_SERIAL = \"8e:19:17:78:b2:f3:31:be\";\n","filename":"test\/lib\/jdk\/test\/lib\/security\/TestTLSHandshake.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}