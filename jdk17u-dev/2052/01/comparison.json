{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -358,1 +358,5 @@\n-                result = RSACore.rsa(paddingCopy, privateKey, true);\n+                if (paddingCopy != null) {\n+                    result = RSACore.rsa(paddingCopy, privateKey, true);\n+                } else {\n+                    throw new BadPaddingException(\"Padding error in signing\");\n+                }\n@@ -364,0 +368,4 @@\n+                if (result == null) {\n+                    throw new BadPaddingException\n+                            (\"Padding error in verification\");\n+                }\n@@ -367,1 +375,6 @@\n-                result = RSACore.rsa(paddingCopy, publicKey);\n+                if (paddingCopy != null) {\n+                    result = RSACore.rsa(paddingCopy, publicKey);\n+                } else {\n+                    throw new BadPaddingException\n+                            (\"Padding error in encryption\");\n+                }\n@@ -373,0 +386,4 @@\n+                if (result == null) {\n+                    throw new BadPaddingException\n+                            (\"Padding error in decryption\");\n+                }\n@@ -381,1 +398,1 @@\n-            if (paddingCopy != null             \/\/ will not happen\n+            if (paddingCopy != null\n@@ -383,1 +400,1 @@\n-                    && paddingCopy != result) { \/\/ DO NOT CLEAN, THIS IS RESULT!\n+                    && paddingCopy != result) { \/\/ DO NOT CLEAN, THIS IS RESULT\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/RSACipher.java","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import javax.crypto.BadPaddingException;\n@@ -239,1 +238,1 @@\n-     * Pad the data and return the padded block.\n+     * Pad the data and return the result or null if error occurred.\n@@ -241,1 +240,1 @@\n-    public byte[] pad(byte[] data) throws BadPaddingException {\n+    public byte[] pad(byte[] data) {\n@@ -246,1 +245,1 @@\n-     * Pad the data and return the padded block.\n+     * Pad the data and return the result or null if error occurred.\n@@ -248,2 +247,1 @@\n-    public byte[] pad(byte[] data, int ofs, int len)\n-            throws BadPaddingException {\n+    public byte[] pad(byte[] data, int ofs, int len) {\n@@ -251,3 +249,1 @@\n-            throw new BadPaddingException(\"Data must be shorter than \"\n-                + (maxDataSize + 1) + \" bytes but received \"\n-                + len + \" bytes.\");\n+            return null;\n@@ -257,0 +253,1 @@\n+            \/\/ assert len == paddedSize and data.length - ofs > len?\n@@ -269,1 +266,1 @@\n-     * Unpad the padded block and return the data.\n+     * Unpad the padded block and return the result or null if error occurred.\n@@ -271,16 +268,10 @@\n-    public byte[] unpad(byte[] padded) throws BadPaddingException {\n-        if (padded.length != paddedSize) {\n-            throw new BadPaddingException(\"Decryption error.\" +\n-                \"The padded array length (\" + padded.length +\n-                \") is not the specified padded size (\" + paddedSize + \")\");\n-        }\n-        switch (type) {\n-        case PAD_NONE:\n-            return padded;\n-        case PAD_BLOCKTYPE_1:\n-        case PAD_BLOCKTYPE_2:\n-            return unpadV15(padded);\n-        case PAD_OAEP_MGF1:\n-            return unpadOAEP(padded);\n-        default:\n-            throw new AssertionError();\n+    public byte[] unpad(byte[] padded) {\n+        if (padded.length == paddedSize) {\n+            return switch(type) {\n+                case PAD_NONE -> padded;\n+                case PAD_BLOCKTYPE_1, PAD_BLOCKTYPE_2 -> unpadV15(padded);\n+                case PAD_OAEP_MGF1 -> unpadOAEP(padded);\n+                default -> throw new AssertionError();\n+            };\n+        } else {\n+            return null;\n@@ -293,1 +284,1 @@\n-    private byte[] padV15(byte[] data, int ofs, int len) throws BadPaddingException {\n+    private byte[] padV15(byte[] data, int ofs, int len) {\n@@ -330,1 +321,1 @@\n-     *\n+     * Return the result or null if error occurred.\n@@ -333,1 +324,1 @@\n-    private byte[] unpadV15(byte[] padded) throws BadPaddingException {\n+    private byte[] unpadV15(byte[] padded) {\n@@ -369,2 +360,0 @@\n-        BadPaddingException bpe = new BadPaddingException(\"Decryption error\");\n-\n@@ -372,1 +361,1 @@\n-            throw bpe;\n+            return null;\n@@ -381,0 +370,1 @@\n+     * Return the result or null if error occurred.\n@@ -382,1 +372,1 @@\n-    private byte[] padOAEP(byte[] M, int ofs, int len) throws BadPaddingException {\n+    private byte[] padOAEP(byte[] M, int ofs, int len) {\n@@ -431,0 +421,1 @@\n+     * Return the result or null if error occurred.\n@@ -432,1 +423,1 @@\n-    private byte[] unpadOAEP(byte[] padded) throws BadPaddingException {\n+    private byte[] unpadOAEP(byte[] padded) {\n@@ -488,7 +479,1 @@\n-        BadPaddingException bpe = new BadPaddingException(\"Decryption error\");\n-\n-        if (bp) {\n-            throw bpe;\n-        } else {\n-            return m;\n-        }\n+        return (bp? null : m);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPadding.java","additions":27,"deletions":42,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,2 +193,3 @@\n-            byte[] encrypted = RSACore.rsa(padded, privateKey, true);\n-            return encrypted;\n+            if (padded != null) {\n+                return RSACore.rsa(padded, privateKey, true);\n+            }\n@@ -200,0 +201,1 @@\n+        throw new SignatureException(\"Could not sign data\");\n@@ -211,1 +213,1 @@\n-                throw new SignatureException(\"Signature length not correct: got \" +\n+                throw new SignatureException(\"Bad signature length: got \" +\n@@ -215,1 +217,3 @@\n-            byte[] digest = getDigestValue();\n+\n+            \/\/ https:\/\/www.rfc-editor.org\/rfc\/rfc8017.html#section-8.2.2\n+            \/\/ Step 4 suggests comparing the encoded message\n@@ -217,3 +221,14 @@\n-            byte[] unpadded = padding.unpad(decrypted);\n-            byte[] decodedDigest = decodeSignature(digestOID, unpadded);\n-            return MessageDigest.isEqual(digest, decodedDigest);\n+\n+            byte[] digest = getDigestValue();\n+\n+            byte[] encoded = encodeSignature(digestOID, digest);\n+            byte[] padded = padding.pad(encoded);\n+            if (MessageDigest.isEqual(padded, decrypted)) {\n+                return true;\n+            }\n+\n+            \/\/ Some vendors might omit the NULL params in digest algorithm\n+            \/\/ identifier. Try again.\n+            encoded = encodeSignatureWithoutNULL(digestOID, digest);\n+            padded = padding.pad(encoded);\n+            return MessageDigest.isEqual(padded, decrypted);\n@@ -221,4 +236,0 @@\n-            \/\/ occurs if the app has used the wrong RSA public key\n-            \/\/ or if sigBytes is invalid\n-            \/\/ return false rather than propagating the exception for\n-            \/\/ compatibility\/ease of use\n@@ -248,2 +259,2 @@\n-     * Decode the signature data. Verify that the object identifier matches\n-     * and return the message digest.\n+     * Encode the digest without the NULL params, return the to-be-signed data.\n+     * This is only used by SunRsaSign.\n@@ -251,1 +262,1 @@\n-    public static byte[] decodeSignature(ObjectIdentifier oid, byte[] sig)\n+    static byte[] encodeSignatureWithoutNULL(ObjectIdentifier oid, byte[] digest)\n@@ -253,16 +264,8 @@\n-        \/\/ Enforce strict DER checking for signatures\n-        DerInputStream in = new DerInputStream(sig, 0, sig.length, false);\n-        DerValue[] values = in.getSequence(2);\n-        if ((values.length != 2) || (in.available() != 0)) {\n-            throw new IOException(\"SEQUENCE length error\");\n-        }\n-        AlgorithmId algId = AlgorithmId.parse(values[0]);\n-        if (algId.getOID().equals(oid) == false) {\n-            throw new IOException(\"ObjectIdentifier mismatch: \"\n-                + algId.getOID());\n-        }\n-        if (algId.getEncodedParams() != null) {\n-            throw new IOException(\"Unexpected AlgorithmId parameters\");\n-        }\n-        byte[] digest = values[1].getOctetString();\n-        return digest;\n+        DerOutputStream out = new DerOutputStream();\n+        DerOutputStream oidout = new DerOutputStream();\n+        oidout.putOID(oid);\n+        out.write(DerValue.tag_Sequence, oidout);\n+        out.putOctetString(digest);\n+        DerValue result =\n+                new DerValue(DerValue.tag_Sequence, out.toByteArray());\n+        return result.toByteArray();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSASignature.java","additions":34,"deletions":31,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -755,3 +755,6 @@\n-            byte[] padded = padding.pad(data);\n-            return padded;\n-        } catch (GeneralSecurityException e) {\n+            byte[] result = padding.pad(data);\n+            if (result == null) {\n+                throw new ProviderException(\"Error padding data\");\n+            }\n+            return result;\n+        } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8302017\n+ * @summary Ensure that RSAPadding class works as expected after refactoring\n+ * @modules java.base\/sun.security.rsa\n+ *\/\n+import java.util.Arrays;\n+import sun.security.rsa.RSAPadding;\n+\n+public class RSAPaddingCheck {\n+\n+    private static int[] PADDING_TYPES =  {\n+        RSAPadding.PAD_BLOCKTYPE_1,\n+        RSAPadding.PAD_BLOCKTYPE_2,\n+        RSAPadding.PAD_NONE,\n+        RSAPadding.PAD_OAEP_MGF1,\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        int size = 2048 >> 3;\n+        byte[] testData = \"This is some random to-be-padded Data\".getBytes();\n+        for (int type : PADDING_TYPES) {\n+            byte[] data = (type == RSAPadding.PAD_NONE?\n+                    Arrays.copyOf(testData, size) : testData);\n+            System.out.println(\"Testing PaddingType: \" + type);\n+            RSAPadding padding = RSAPadding.getInstance(type, size);\n+            byte[] paddedData = padding.pad(data);\n+            if (paddedData == null) {\n+                throw new RuntimeException(\"Unexpected padding op failure!\");\n+            }\n+\n+            byte[] data2 = padding.unpad(paddedData);\n+            if (data2 == null) {\n+                throw new RuntimeException(\"Unexpected unpadding op failure!\");\n+            }\n+            if (!Arrays.equals(data, data2)) {\n+                throw new RuntimeException(\"diff check failure!\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/rsa\/RSAPaddingCheck.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8320597\n+ * @summary Verify RSA signature with omitted digest params (should be encoded as NULL)\n+ * for backward compatibility\n+ *\/\n+import java.security.KeyFactory;\n+import java.security.Signature;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Base64;\n+\n+public class WithoutNULL {\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ A 1024-bit RSA public key\n+        byte[] key = Base64.getMimeDecoder().decode(\"\"\"\n+                MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrfTrEm4KvdFSpGAM7InrFEzALTKdphT9fK6Gu\n+                eVjHtKsuCSEaULCdjhJvPpFK40ONr1JEC1Ywp1UYrfBBdKunnbDZqNZL1cFv+IzF4Yj6JO6pOeHi\n+                1Zpur1GaQRRlYTvzmyWY\/AATQDh8JfKObNnDVwXeezFODUG8h5+XL1ZXZQIDAQAB\"\"\");\n+\n+        \/\/ A SHA1withRSA signature on an empty input where the digestAlgorithm\n+        \/\/ inside DigestInfo does not have a parameters field.\n+        byte[] sig = Base64.getMimeDecoder().decode(\"\"\"\n+                D1FpiT44WEXlDfYK880bdorLO+e9qJVXZWiBgqs9dfK7lYQwyEt9dL23mbUAKm5TVEj2ZxtHkEvk\n+                b8oaWkxk069jDTM1RhllPJZkAjeQRbw4gkg4N6wKZz9B\/jdSRMNJg\/b9QdRYZOHOBxsEHMbUREPV\n+                DoCOLaxB8eIXX0EWkiE=\"\"\");\n+\n+        Signature s = Signature.getInstance(\"SHA1withRSA\", \"SunRsaSign\");\n+        s.initVerify(KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(key)));\n+        if (!s.verify(sig)) {\n+            throw new RuntimeException(\"Does not verify\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/rsa\/WithoutNULL.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"}]}