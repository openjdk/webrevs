{"files":[{"patch":"@@ -91,1 +91,1 @@\n-CodeBuffer::CodeBuffer(CodeBlob* blob) {\n+CodeBuffer::CodeBuffer(CodeBlob* blob) DEBUG_ONLY(: Scrubber(this, sizeof(*this))) {\n@@ -129,5 +129,3 @@\n-  \/\/ If we allocate our code buffer from the CodeCache\n-  \/\/ via a BufferBlob, and it's not permanent, then\n-  \/\/ free the BufferBlob.\n-  \/\/ The rest of the memory will be freed when the ResourceObj\n-  \/\/ is released.\n+  \/\/ If we allocated our code buffer from the CodeCache via a BufferBlob, and\n+  \/\/ it's not permanent, then free the BufferBlob.  The rest of the memory\n+  \/\/ will be freed when the ResourceObj is released.\n@@ -143,3 +141,1 @@\n-  \/\/ Claim is that stack allocation ensures resources are cleaned up.\n-  \/\/ This is resource clean up, let's hope that all were properly copied out.\n-  NOT_PRODUCT(free_strings();)\n+  NOT_PRODUCT(clear_strings());\n@@ -147,3 +143,0 @@\n-#ifdef ASSERT\n-  \/\/ Save allocation type to execute assert in ~ResourceObj()\n-  \/\/ which is called after this destructor.\n@@ -151,4 +144,0 @@\n-  ResourceObj::allocation_type at = _default_oop_recorder.get_allocation_type();\n-  Copy::fill_to_bytes(this, sizeof(*this), badResourceValue);\n-  ResourceObj::set_allocation_type((address)(&_default_oop_recorder), at);\n-#endif\n@@ -718,2 +707,3 @@\n-  \/\/ transfer strings and comments from buffer to blob\n-  NOT_PRODUCT(dest_blob->set_strings(_code_strings);)\n+  \/\/ Share assembly remarks and debug strings with the blob.\n+  NOT_PRODUCT(dest_blob->use_remarks(_asm_remarks));\n+  NOT_PRODUCT(dest_blob->use_strings(_dbg_strings));\n@@ -992,2 +982,1 @@\n-\n-void CodeBuffer::block_comment(intptr_t offset, const char * comment) {\n+void CodeBuffer::block_comment(ptrdiff_t offset, const char* comment) {\n@@ -995,1 +984,2 @@\n-    _code_strings.add_comment(offset, comment);\n+    const char* str = _asm_remarks.insert(offset, comment);\n+    postcond(str != comment);\n@@ -1000,1 +990,3 @@\n-  return _code_strings.add_string(str);\n+  const char* tmp = _dbg_strings.insert(str);\n+  postcond(tmp != str);\n+  return tmp;\n@@ -1003,15 +995,15 @@\n-class CodeString: public CHeapObj<mtCode> {\n- private:\n-  friend class CodeStrings;\n-  const char * _string;\n-  CodeString*  _next;\n-  CodeString*  _prev;\n-  intptr_t     _offset;\n-\n-  static long allocated_code_strings;\n-\n-  ~CodeString() {\n-    assert(_next == NULL && _prev == NULL, \"wrong interface for freeing list\");\n-    allocated_code_strings--;\n-    log_trace(codestrings)(\"Freeing CodeString [%s] (%p)\", _string, (void*)_string);\n-    os::free((void*)_string);\n+void CodeBuffer::decode() {\n+  ttyLocker ttyl;\n+  Disassembler::decode(decode_begin(), insts_end(), tty NOT_PRODUCT(COMMA &asm_remarks()));\n+  _decode_begin = insts_end();\n+}\n+\n+void CodeSection::print(const char* name) {\n+  csize_t locs_size = locs_end() - locs_start();\n+  tty->print_cr(\" %7s.code = \" PTR_FORMAT \" : \" PTR_FORMAT \" : \" PTR_FORMAT \" (%d of %d)\",\n+                name, p2i(start()), p2i(end()), p2i(limit()), size(), capacity());\n+  tty->print_cr(\" %7s.locs = \" PTR_FORMAT \" : \" PTR_FORMAT \" : \" PTR_FORMAT \" (%d of %d) point=%d\",\n+                name, p2i(locs_start()), p2i(locs_end()), p2i(locs_limit()), locs_size, locs_capacity(), locs_point_off());\n+  if (PrintRelocations) {\n+    RelocIterator iter(this);\n+    iter.print();\n@@ -1019,0 +1011,1 @@\n+}\n@@ -1020,1 +1013,5 @@\n-  bool is_comment() const { return _offset >= 0; }\n+void CodeBuffer::print() {\n+  if (this == NULL) {\n+    tty->print_cr(\"NULL CodeBuffer pointer\");\n+    return;\n+  }\n@@ -1022,0 +1019,11 @@\n+  tty->print_cr(\"CodeBuffer:\");\n+  for (int n = 0; n < (int)SECT_LIMIT; n++) {\n+    \/\/ print each section\n+    CodeSection* cs = code_section(n);\n+    cs->print(code_section_name(n));\n+  }\n+}\n+\n+\/\/ ----- CHeapString -----------------------------------------------------------\n+\n+class CHeapString : public CHeapObj<mtCode> {\n@@ -1023,5 +1031,4 @@\n-  CodeString(const char * string, intptr_t offset = -1)\n-    : _next(NULL), _prev(NULL), _offset(offset) {\n-    allocated_code_strings++;\n-    _string = os::strdup(string, mtCode);\n-    log_trace(codestrings)(\"Created CodeString [%s] (%p)\", _string, (void*)_string);\n+  CHeapString(const char* str) : _string(os::strdup(str)) {}\n+ ~CHeapString() {\n+    os::free((void*)_string);\n+    _string = nullptr;\n@@ -1029,0 +1036,5 @@\n+  const char* string() const { return _string; }\n+\n+ private:\n+  const char* _string;\n+};\n@@ -1030,3 +1042,1 @@\n-  const char * string() const { return _string; }\n-  intptr_t     offset() const { assert(_offset >= 0, \"offset for non comment?\"); return _offset;  }\n-  CodeString*  next()   const { return _next; }\n+\/\/ ----- AsmRemarkCollection ---------------------------------------------------\n@@ -1034,5 +1044,10 @@\n-  void set_next(CodeString* next) {\n-    _next = next;\n-    if (next != NULL) {\n-      next->_prev = this;\n-    }\n+class AsmRemarkCollection : public CHeapObj<mtCode> {\n+ public:\n+  AsmRemarkCollection() : _ref_cnt(1), _remarks(nullptr), _next(nullptr) {}\n+ ~AsmRemarkCollection() {\n+    assert(is_empty(), \"Must 'clear()' before deleting!\");\n+    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n+  }\n+  AsmRemarkCollection* reuse() {\n+    precond(_ref_cnt > 0);\n+    return _ref_cnt++, this;\n@@ -1041,5 +1056,18 @@\n-  CodeString* first_comment() {\n-    if (is_comment()) {\n-      return this;\n-    } else {\n-      return next_comment();\n+  const char* insert(uint offset, const char* remark);\n+  const char* lookup(uint offset) const;\n+  const char* next(uint offset) const;\n+\n+  bool is_empty() const { return _remarks == nullptr; }\n+  uint clear();\n+\n+ private:\n+  struct Cell : CHeapString {\n+    Cell(const char* remark, uint offset) :\n+        CHeapString(remark), offset(offset), prev(nullptr), next(nullptr) {}\n+    void push_back(Cell* cell) {\n+      Cell* head = this;\n+      Cell* tail = prev;\n+      tail->next = cell;\n+      cell->next = head;\n+      cell->prev = tail;\n+      prev = cell;\n@@ -1047,0 +1075,20 @@\n+    uint offset;\n+    Cell* prev;\n+    Cell* next;\n+  };\n+  uint  _ref_cnt;\n+  Cell* _remarks;\n+  \/\/ Using a 'mutable' iteration pointer to allow 'const' on lookup\/next (that\n+  \/\/ does not change the state of the list per se), supportig a simplistic\n+  \/\/ iteration scheme.\n+  mutable Cell* _next;\n+};\n+\n+\/\/ ----- DbgStringCollection ---------------------------------------------------\n+\n+class DbgStringCollection : public CHeapObj<mtCode> {\n+ public:\n+  DbgStringCollection() : _ref_cnt(1), _strings(nullptr) {}\n+ ~DbgStringCollection() {\n+    assert(is_empty(), \"Must 'clear()' before deleting!\");\n+    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n@@ -1048,6 +1096,3 @@\n-  CodeString* next_comment() const {\n-    CodeString* s = _next;\n-    while (s != NULL && !s->is_comment()) {\n-      s = s->_next;\n-    }\n-    return s;\n+  DbgStringCollection* reuse() {\n+    precond(_ref_cnt > 0);\n+    return _ref_cnt++, this;\n@@ -1055,0 +1100,24 @@\n+\n+  const char* insert(const char* str);\n+  const char* lookup(const char* str) const;\n+\n+  bool is_empty() const { return _strings == nullptr; }\n+  uint clear();\n+\n+ private:\n+  struct Cell : CHeapString {\n+    Cell(const char* dbgstr) :\n+        CHeapString(dbgstr), prev(nullptr), next(nullptr) {}\n+    void push_back(Cell* cell) {\n+      Cell* head = this;\n+      Cell* tail = prev;\n+      tail->next = cell;\n+      cell->next = head;\n+      cell->prev = tail;\n+      prev = cell;\n+    }\n+    Cell* prev;\n+    Cell* next;\n+  };\n+  uint  _ref_cnt;\n+  Cell* _strings;\n@@ -1057,3 +1126,9 @@\n-\/\/ For tracing statistics. Will use raw increment\/decrement, so it might not be\n-\/\/ exact\n-long CodeString::allocated_code_strings = 0;\n+\/\/ ----- AsmRemarks ------------------------------------------------------------\n+\/\/\n+\/\/ Acting as interface to reference counted mapping [offset -> remark], where\n+\/\/ offset is a byte offset into an instruction stream (CodeBuffer, CodeBlob or\n+\/\/ other memory buffer) and remark is a string (comment).\n+\/\/\n+AsmRemarks::AsmRemarks() : _remarks(new AsmRemarkCollection()) {\n+  assert(_remarks != nullptr, \"Allocation failure!\");\n+}\n@@ -1061,6 +1136,2 @@\n-CodeString* CodeStrings::find(intptr_t offset) const {\n-  CodeString* a = _strings->first_comment();\n-  while (a != NULL && a->offset() != offset) {\n-    a = a->next_comment();\n-  }\n-  return a;\n+AsmRemarks::~AsmRemarks() {\n+  assert(_remarks == nullptr, \"Must 'clear()' before deleting!\");\n@@ -1069,7 +1140,3 @@\n-\/\/ Convenience for add_comment.\n-CodeString* CodeStrings::find_last(intptr_t offset) const {\n-  CodeString* a = _strings_last;\n-  while (a != NULL && !(a->is_comment() && a->offset() == offset)) {\n-    a = a->_prev;\n-  }\n-  return a;\n+const char* AsmRemarks::insert(uint offset, const char* remstr) {\n+  precond(remstr != nullptr);\n+  return _remarks->insert(offset, remstr);\n@@ -1078,4 +1145,3 @@\n-void CodeStrings::add_comment(intptr_t offset, const char * comment) {\n-  check_valid();\n-  CodeString* c      = new CodeString(comment, offset);\n-  CodeString* inspos = (_strings == NULL) ? NULL : find_last(offset);\n+bool AsmRemarks::is_empty() const {\n+  return _remarks->is_empty();\n+}\n@@ -1083,12 +1149,4 @@\n-  if (inspos != NULL) {\n-    \/\/ insert after already existing comments with same offset\n-    c->set_next(inspos->next());\n-    inspos->set_next(c);\n-  } else {\n-    \/\/ no comments with such offset, yet. Insert before anything else.\n-    c->set_next(_strings);\n-    _strings = c;\n-  }\n-  if (c->next() == NULL) {\n-    _strings_last = c;\n-  }\n+void AsmRemarks::share(const AsmRemarks &src) {\n+  precond(is_empty());\n+  clear();\n+  _remarks = src._remarks->reuse();\n@@ -1097,20 +1155,3 @@\n-\/\/ Deep copy of CodeStrings for consistent memory management.\n-void CodeStrings::copy(CodeStrings& other) {\n-  log_debug(codestrings)(\"Copying %d Codestring(s)\", other.count());\n-\n-  other.check_valid();\n-  check_valid();\n-  assert(is_null(), \"Cannot copy onto non-empty CodeStrings\");\n-  CodeString* n = other._strings;\n-  CodeString** ps = &_strings;\n-  CodeString* prev = NULL;\n-  while (n != NULL) {\n-    if (n->is_comment()) {\n-      *ps = new CodeString(n->string(), n->offset());\n-    } else {\n-      *ps = new CodeString(n->string());\n-    }\n-    (*ps)->_prev = prev;\n-    prev = *ps;\n-    ps = &((*ps)->_next);\n-    n = n->next();\n+void AsmRemarks::clear() {\n+  if (_remarks->clear() == 0) {\n+    delete _remarks;\n@@ -1118,0 +1159,1 @@\n+  _remarks = nullptr;\n@@ -1120,14 +1162,13 @@\n-const char* CodeStrings::_prefix = \" ;; \";  \/\/ default: can be changed via set_prefix\n-\n-void CodeStrings::print_block_comment(outputStream* stream, intptr_t offset) const {\n-  check_valid();\n-  if (_strings != NULL) {\n-    CodeString* c = find(offset);\n-    while (c && c->offset() == offset) {\n-      stream->bol();\n-      stream->print(\"%s\", _prefix);\n-      \/\/ Don't interpret as format strings since it could contain %\n-      stream->print_raw(c->string());\n-      stream->bol(); \/\/ advance to next line only if string didn't contain a cr() at the end.\n-      c = c->next_comment();\n-    }\n+uint AsmRemarks::print(uint offset, outputStream* strm) const {\n+  uint count = 0;\n+  const char* prefix = \" ;; \";\n+  const char* remstr = _remarks->lookup(offset);\n+  while (remstr != nullptr) {\n+    strm->bol();\n+    strm->print(\"%s\", prefix);\n+    \/\/ Don't interpret as format strings since it could contain '%'.\n+    strm->print_raw(remstr);\n+    \/\/ Advance to next line iff string didn't contain a cr() at the end.\n+    strm->bol();\n+    remstr = _remarks->next(offset);\n+    count++;\n@@ -1135,0 +1176,28 @@\n+  return count;\n+}\n+\n+\/\/ ----- DbgStrings ------------------------------------------------------------\n+\/\/\n+\/\/ Acting as interface to reference counted collection of (debug) strings used\n+\/\/ in the code generated, and thus requiring a fixed address.\n+\/\/\n+DbgStrings::DbgStrings() : _strings(new DbgStringCollection()) {\n+  assert(_strings != nullptr, \"Allocation failure!\");\n+}\n+\n+DbgStrings::~DbgStrings() {\n+  assert(_strings == nullptr, \"Must 'clear()' before deleting!\");\n+}\n+\n+const char* DbgStrings::insert(const char* dbgstr) {\n+  const char* str = _strings->lookup(dbgstr);\n+  return str != nullptr ? str : _strings->insert(dbgstr);\n+}\n+\n+bool DbgStrings::is_empty() const {\n+  return _strings->is_empty();\n+}\n+\n+void DbgStrings::share(const DbgStrings &src) {\n+  precond(is_empty());\n+  _strings = src._strings->reuse();\n@@ -1137,6 +1206,3 @@\n-int CodeStrings::count() const {\n-  int i = 0;\n-  CodeString* s = _strings;\n-  while (s != NULL) {\n-    i++;\n-    s = s->_next;\n+void DbgStrings::clear() {\n+  if (_strings->clear() == 0) {\n+    delete _strings;\n@@ -1144,1 +1210,1 @@\n-  return i;\n+  _strings = nullptr;\n@@ -1147,14 +1213,11 @@\n-\/\/ Also sets is_null()\n-void CodeStrings::free() {\n-  log_debug(codestrings)(\"Freeing %d out of approx. %ld CodeString(s), \", count(), CodeString::allocated_code_strings);\n-  CodeString* n = _strings;\n-  while (n) {\n-    \/\/ unlink the node from the list saving a pointer to the next\n-    CodeString* p = n->next();\n-    n->set_next(NULL);\n-    if (p != NULL) {\n-      assert(p->_prev == n, \"missing prev link\");\n-      p->_prev = NULL;\n-    }\n-    delete n;\n-    n = p;\n+\/\/ ----- AsmRemarkCollection ---------------------------------------------------\n+\n+const char* AsmRemarkCollection::insert(uint offset, const char* remstr) {\n+  precond(remstr != nullptr);\n+  Cell* cell = new Cell { remstr, offset };\n+  if (is_empty()) {\n+    cell->prev = cell;\n+    cell->next = cell;\n+    _remarks = cell;\n+  } else {\n+    _remarks->push_back(cell);\n@@ -1162,1 +1225,1 @@\n-  set_null_and_invalidate();\n+  return cell->string();\n@@ -1165,6 +1228,16 @@\n-const char* CodeStrings::add_string(const char * string) {\n-  check_valid();\n-  CodeString* s = new CodeString(string);\n-  s->set_next(_strings);\n-  if (_strings == NULL) {\n-    _strings_last = s;\n+const char* AsmRemarkCollection::lookup(uint offset) const {\n+  _next = _remarks;\n+  return next(offset);\n+}\n+\n+const char* AsmRemarkCollection::next(uint offset) const {\n+  if (_next != nullptr) {\n+    Cell* i = _next;\n+    do {\n+      if (i->offset == offset) {\n+        _next = i->next == _remarks ? nullptr : i->next;\n+        return i->string();\n+      }\n+      i = i->next;\n+    } while (i != _remarks);\n+    _next = nullptr;\n@@ -1172,3 +1245,1 @@\n-  _strings = s;\n-  assert(s->string() != NULL, \"should have a string\");\n-  return s->string();\n+  return nullptr;\n@@ -1177,4 +1248,19 @@\n-void CodeBuffer::decode() {\n-  ttyLocker ttyl;\n-  Disassembler::decode(decode_begin(), insts_end(), tty NOT_PRODUCT(COMMA &strings()));\n-  _decode_begin = insts_end();\n+uint AsmRemarkCollection::clear() {\n+  precond(_ref_cnt > 0);\n+  if (--_ref_cnt > 0) {\n+    return _ref_cnt;\n+  }\n+  if (!is_empty()) {\n+    uint count = 0;\n+    Cell* i = _remarks;\n+    do {\n+      Cell* next = i->next;\n+      delete i;\n+      i = next;\n+      count++;\n+    } while (i != _remarks);\n+\n+    log_debug(codestrings)(\"Clear %u asm-remark%s.\", count, count == 1 ? \"\" : \"s\");\n+    _remarks = nullptr;\n+  }\n+  return 0; \/\/ i.e. _ref_cnt == 0\n@@ -1183,9 +1269,12 @@\n-void CodeSection::print(const char* name) {\n-  csize_t locs_size = locs_end() - locs_start();\n-  tty->print_cr(\" %7s.code = \" PTR_FORMAT \" : \" PTR_FORMAT \" : \" PTR_FORMAT \" (%d of %d)\",\n-                name, p2i(start()), p2i(end()), p2i(limit()), size(), capacity());\n-  tty->print_cr(\" %7s.locs = \" PTR_FORMAT \" : \" PTR_FORMAT \" : \" PTR_FORMAT \" (%d of %d) point=%d\",\n-                name, p2i(locs_start()), p2i(locs_end()), p2i(locs_limit()), locs_size, locs_capacity(), locs_point_off());\n-  if (PrintRelocations) {\n-    RelocIterator iter(this);\n-    iter.print();\n+\/\/ ----- DbgStringCollection ---------------------------------------------------\n+\n+const char* DbgStringCollection::insert(const char* dbgstr) {\n+  precond(dbgstr != nullptr);\n+  Cell* cell = new Cell { dbgstr };\n+\n+  if (is_empty()) {\n+     cell->prev = cell;\n+     cell->next = cell;\n+     _strings = cell;\n+  } else {\n+    _strings->push_back(cell);\n@@ -1193,0 +1282,1 @@\n+  return cell->string();\n@@ -1195,4 +1285,10 @@\n-void CodeBuffer::print() {\n-  if (this == NULL) {\n-    tty->print_cr(\"NULL CodeBuffer pointer\");\n-    return;\n+const char* DbgStringCollection::lookup(const char* dbgstr) const {\n+  precond(dbgstr != nullptr);\n+  if (_strings != nullptr) {\n+    Cell* i = _strings;\n+    do {\n+      if (strcmp(i->string(), dbgstr) == 0) {\n+        return i->string();\n+      }\n+      i = i->next;\n+    } while (i != _strings);\n@@ -1200,0 +1296,2 @@\n+  return nullptr;\n+}\n@@ -1201,5 +1299,17 @@\n-  tty->print_cr(\"CodeBuffer:\");\n-  for (int n = 0; n < (int)SECT_LIMIT; n++) {\n-    \/\/ print each section\n-    CodeSection* cs = code_section(n);\n-    cs->print(code_section_name(n));\n+uint DbgStringCollection::clear() {\n+  precond(_ref_cnt > 0);\n+  if (--_ref_cnt > 0) {\n+    return _ref_cnt;\n+  }\n+  if (!is_empty()) {\n+    uint count = 0;\n+    Cell* i = _strings;\n+    do {\n+      Cell* next = i->next;\n+      delete i;\n+      i = next;\n+      count++;\n+    } while (i != _strings);\n+\n+    log_debug(codestrings)(\"Clear %u dbg-string%s.\", count, count == 1 ? \"\" : \"s\");\n+    _strings = nullptr;\n@@ -1207,0 +1317,1 @@\n+  return 0; \/\/ i.e. _ref_cnt == 0\n@@ -1209,1 +1320,1 @@\n-#endif \/\/ PRODUCT\n+#endif \/\/ not PRODUCT\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":293,"deletions":182,"binary":false,"changes":475,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-class CodeStrings;\n@@ -276,3 +275,1 @@\n-class CodeString;\n-class CodeStrings {\n-private:\n+\n@@ -280,7 +277,0 @@\n-  CodeString* _strings;\n-  CodeString* _strings_last;\n-#ifdef ASSERT\n-  \/\/ Becomes true after copy-out, forbids further use.\n-  bool _defunct; \/\/ Zero bit pattern is \"valid\", see memset call in decode_env::decode_env\n-#endif\n-  static const char* _prefix; \/\/ defaults to \" ;; \"\n@@ -288,2 +278,2 @@\n-  CodeString* find(intptr_t offset) const;\n-  CodeString* find_last(intptr_t offset) const;\n+class AsmRemarkCollection;\n+class DbgStringCollection;\n@@ -291,8 +281,4 @@\n-  void set_null_and_invalidate() {\n-    _strings = NULL;\n-    _strings_last = NULL;\n-#ifdef ASSERT\n-    _defunct = true;\n-#endif\n-  }\n-#endif\n+\/\/ The assumption made here is that most code remarks (or comments) added to\n+\/\/ the generated assembly code are unique, i.e. there is very little gain in\n+\/\/ trying to share the strings between the different offsets tracked in a\n+\/\/ buffer (or blob).\n@@ -300,10 +286,4 @@\n-public:\n-  CodeStrings() {\n-#ifndef PRODUCT\n-    _strings = NULL;\n-    _strings_last = NULL;\n-#ifdef ASSERT\n-    _defunct = false;\n-#endif\n-#endif\n-  }\n+class AsmRemarks {\n+ public:\n+  AsmRemarks();\n+ ~AsmRemarks();\n@@ -311,8 +291,1 @@\n-#ifndef PRODUCT\n-  bool is_null() {\n-#ifdef ASSERT\n-    return _strings == NULL;\n-#else\n-    return true;\n-#endif\n-  }\n+  const char* insert(uint offset, const char* remstr);\n@@ -320,1 +293,1 @@\n-  const char* add_string(const char * string);\n+  bool is_empty() const;\n@@ -322,7 +295,3 @@\n-  void add_comment(intptr_t offset, const char * comment);\n-  void print_block_comment(outputStream* stream, intptr_t offset) const;\n-  int  count() const;\n-  \/\/ COPY strings from other to this; leave other valid.\n-  void copy(CodeStrings& other);\n-  \/\/ FREE strings; invalidate this.\n-  void free();\n+  void share(const AsmRemarks &src);\n+  void clear();\n+  uint print(uint offset, outputStream* strm = tty) const;\n@@ -330,4 +299,2 @@\n-  \/\/ Guarantee that _strings are used at most once; assign and free invalidate a buffer.\n-  inline void check_valid() const {\n-    assert(!_defunct, \"Use of invalid CodeStrings\");\n-  }\n+  \/\/ For testing purposes only.\n+  const AsmRemarkCollection* ref() const { return _remarks; }\n@@ -335,2 +302,36 @@\n-  static void set_prefix(const char *prefix) {\n-    _prefix = prefix;\n+private:\n+  AsmRemarkCollection* _remarks;\n+};\n+\n+\/\/ The assumption made here is that the number of debug strings (with a fixed\n+\/\/ address requirement) is a rather small set per compilation unit.\n+\n+class DbgStrings {\n+ public:\n+  DbgStrings();\n+ ~DbgStrings();\n+\n+  const char* insert(const char* dbgstr);\n+\n+  bool is_empty() const;\n+\n+  void share(const DbgStrings &src);\n+  void clear();\n+\n+  \/\/ For testing purposes only.\n+  const DbgStringCollection* ref() const { return _strings; }\n+\n+private:\n+  DbgStringCollection* _strings;\n+};\n+#endif \/\/ not PRODUCT\n+\n+\n+#ifdef ASSERT\n+#include \"utilities\/copy.hpp\"\n+\n+class Scrubber {\n+ public:\n+  Scrubber(void* addr, size_t size) : _addr(addr), _size(size) {}\n+ ~Scrubber() {\n+    Copy::fill_to_bytes(_addr, _size, badResourceValue);\n@@ -338,1 +339,3 @@\n-#endif \/\/ !PRODUCT\n+ private:\n+  void*  _addr;\n+  size_t _size;\n@@ -340,0 +343,1 @@\n+#endif \/\/ ASSERT\n@@ -365,1 +369,1 @@\n-class CodeBuffer: public StackObj {\n+class CodeBuffer: public StackObj DEBUG_ONLY(COMMA private Scrubber) {\n@@ -414,1 +418,2 @@\n-  CodeStrings  _code_strings;\n+  AsmRemarks   _asm_remarks;\n+  DbgStrings   _dbg_strings;\n@@ -432,1 +437,0 @@\n-    _code_strings    = CodeStrings();\n@@ -487,1 +491,3 @@\n-  CodeBuffer(address code_start, csize_t code_size) {\n+  CodeBuffer(address code_start, csize_t code_size)\n+    DEBUG_ONLY(: Scrubber(this, sizeof(*this)))\n+  {\n@@ -500,1 +506,3 @@\n-  CodeBuffer(const char* name) {\n+  CodeBuffer(const char* name)\n+    DEBUG_ONLY(: Scrubber(this, sizeof(*this)))\n+  {\n@@ -507,1 +515,3 @@\n-  CodeBuffer(const char* name, csize_t code_size, csize_t locs_size) {\n+  CodeBuffer(const char* name, csize_t code_size, csize_t locs_size)\n+    DEBUG_ONLY(: Scrubber(this, sizeof(*this)))\n+  {\n@@ -637,1 +647,2 @@\n-  CodeStrings& strings() { return _code_strings; }\n+  AsmRemarks &asm_remarks() { return _asm_remarks; }\n+  DbgStrings &dbg_strings() { return _dbg_strings; }\n@@ -639,4 +650,3 @@\n-  void free_strings() {\n-    if (!_code_strings.is_null()) {\n-      _code_strings.free(); \/\/ sets _strings Null as a side-effect.\n-    }\n+  void clear_strings() {\n+    _asm_remarks.clear();\n+    _dbg_strings.clear();\n@@ -669,1 +679,1 @@\n-  void block_comment(intptr_t offset, const char * comment) PRODUCT_RETURN;\n+  void block_comment(ptrdiff_t offset, const char* comment) PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":76,"deletions":66,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -97,1 +97,0 @@\n-  NOT_PRODUCT(COMMA _strings(CodeStrings()))\n@@ -110,1 +109,1 @@\n-CodeBlob::CodeBlob(const char* name, CompilerType type, const CodeBlobLayout& layout, CodeBuffer* cb, int frame_complete_offset, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments) :\n+CodeBlob::CodeBlob(const char* name, CompilerType type, const CodeBlobLayout& layout, CodeBuffer* cb \/*UNUSED*\/, int frame_complete_offset, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments) :\n@@ -125,1 +124,0 @@\n-  NOT_PRODUCT(COMMA _strings(CodeStrings()))\n@@ -167,1 +165,2 @@\n-  NOT_PRODUCT(_strings.free();)\n+  NOT_PRODUCT(_asm_remarks.clear());\n+  NOT_PRODUCT(_dbg_strings.clear());\n@@ -194,1 +193,2 @@\n-      Disassembler::decode(stub->code_begin(), stub->code_end(), tty);\n+      Disassembler::decode(stub->code_begin(), stub->code_end(), tty\n+                           NOT_PRODUCT(COMMA &stub->asm_remarks()));\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -115,1 +115,9 @@\n-  NOT_PRODUCT(CodeStrings _strings;)\n+#ifndef PRODUCT\n+  AsmRemarks _asm_remarks;\n+  DbgStrings _dbg_strings;\n+\n+ ~CodeBlob() {\n+    _asm_remarks.clear();\n+    _dbg_strings.clear();\n+  }\n+#endif \/\/ not PRODUCT\n@@ -122,2 +130,1 @@\n-  CodeBlob()\n-    : _type(compiler_none) {}\n+  CodeBlob() : _type(compiler_none) {}\n@@ -235,1 +242,1 @@\n-  \/\/ Print the comment associated with offset on stream, if there is one\n+  \/\/ Print to stream, any comments associated with offset.\n@@ -237,4 +244,5 @@\n-  #ifndef PRODUCT\n-    intptr_t offset = (intptr_t)(block_begin - code_begin());\n-    _strings.print_block_comment(stream, offset);\n-  #endif\n+#ifndef PRODUCT\n+    ptrdiff_t offset = block_begin - code_begin();\n+    assert(offset >= 0, \"Expecting non-negative offset!\");\n+    _asm_remarks.print(uint(offset), stream);\n+#endif\n@@ -244,3 +252,5 @@\n-  void set_strings(CodeStrings& strings) {\n-    _strings.copy(strings);\n-  }\n+  AsmRemarks &asm_remarks() { return _asm_remarks; }\n+  DbgStrings &dbg_strings() { return _dbg_strings; }\n+\n+  void use_remarks(AsmRemarks &remarks) { _asm_remarks.share(remarks); }\n+  void use_strings(DbgStrings &strings) { _dbg_strings.share(strings); }\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -59,2 +59,1 @@\n-  void    initialize(int size,\n-                     CodeStrings strings)        { _size = size; _ic_site = NULL; }\n+  void    initialize(int size)                   { _size = size; _ic_site = NULL; }\n","filename":"src\/hotspot\/share\/code\/icBuffer.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -112,2 +112,1 @@\n-  CodeStrings strings;\n-  if (s != NULL) commit(code_size, strings);\n+  if (s != NULL) commit(code_size);\n@@ -130,2 +129,1 @@\n-        CodeStrings strings;\n-        stub_initialize(s, requested_size, strings);\n+        stub_initialize(s, requested_size);\n@@ -148,2 +146,1 @@\n-    CodeStrings strings;\n-    stub_initialize(s, requested_size, strings);\n+    stub_initialize(s, requested_size);\n@@ -158,1 +155,1 @@\n-void StubQueue::commit(int committed_code_size, CodeStrings& strings) {\n+void StubQueue::commit(int committed_code_size) {\n@@ -163,1 +160,1 @@\n-  stub_initialize(s, committed_size, strings);\n+  stub_initialize(s, committed_size);\n","filename":"src\/hotspot\/share\/code\/stubs.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -63,2 +63,1 @@\n-  void    initialize(int size,\n-                     CodeStrings& strings)       { ShouldNotCallThis(); }                \/\/ called to initialize\/specify the stub's size\n+  void    initialize(int size)                   { ShouldNotCallThis(); }                \/\/ called to initialize\/specify the stub's size\n@@ -97,2 +96,1 @@\n-  virtual void    initialize(Stub* self, int size,\n-                             CodeStrings& strings)         = 0; \/\/ called after creation (called twice if allocated via (request, commit))\n+  virtual void    initialize(Stub* self, int size)         = 0; \/\/ called after creation (called twice if allocated via (request, commit))\n@@ -126,2 +124,1 @@\n-    virtual void    initialize(Stub* self, int size,       \\\n-                               CodeStrings& strings)       { cast(self)->initialize(size, strings); } \\\n+    virtual void    initialize(Stub* self, int size)       { cast(self)->initialize(size); }       \\\n@@ -166,2 +163,1 @@\n-  void  stub_initialize(Stub* s, int size,\n-                        CodeStrings& strings)    { assert(size % CodeEntryAlignment == 0, \"size not aligned\"); _stub_interface->initialize(s, size, strings); }\n+  void  stub_initialize(Stub* s, int size)       { assert(size % CodeEntryAlignment == 0, \"size not aligned\"); _stub_interface->initialize(s, size); }\n@@ -194,2 +190,1 @@\n-  void  commit (int committed_code_size,\n-                CodeStrings& strings);           \/\/ commit the previously requested stub - unlocks the queue\n+  void  commit (int committed_code_size);        \/\/ commit the previously requested stub - unlocks the queue\n","filename":"src\/hotspot\/share\/code\/stubs.hpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -75,1 +75,4 @@\n-  NOT_PRODUCT(const CodeStrings* _strings;)\n+#ifndef PRODUCT\n+  const AsmRemarks* _remarks; \/\/ Used with start\/end range to provide code remarks.\n+  ptrdiff_t         _disp;    \/\/ Adjustment to offset -> remark mapping.\n+#endif\n@@ -217,1 +220,2 @@\n-  decode_env(address start, address end, outputStream* output, const CodeStrings* strings = NULL);\n+  decode_env(address start, address end, outputStream* output\n+             NOT_PRODUCT(COMMA const AsmRemarks* remarks = NULL COMMA ptrdiff_t disp = 0));\n@@ -335,2 +339,3 @@\n-  NOT_PRODUCT(COMMA _strings(NULL)) {\n-\n+  NOT_PRODUCT(COMMA _remarks(nullptr))\n+  NOT_PRODUCT(COMMA _disp(0))\n+{\n@@ -339,1 +344,0 @@\n-\n@@ -357,2 +361,3 @@\n-  NOT_PRODUCT(COMMA _strings(NULL))  {\n-\n+  NOT_PRODUCT(COMMA _remarks(nullptr))\n+  NOT_PRODUCT(COMMA _disp(0))\n+{\n@@ -365,1 +370,2 @@\n-decode_env::decode_env(address start, address end, outputStream* output, const CodeStrings* c) :\n+decode_env::decode_env(address start, address end, outputStream* output\n+                       NOT_PRODUCT(COMMA const AsmRemarks* remarks COMMA ptrdiff_t disp)) :\n@@ -380,2 +386,3 @@\n-  NOT_PRODUCT(COMMA _strings(c))  {\n-\n+  NOT_PRODUCT(COMMA _remarks(remarks))\n+  NOT_PRODUCT(COMMA _disp(disp))\n+{\n@@ -648,1 +655,1 @@\n-    if (_nm != NULL) {\n+    if (_nm != nullptr) {\n@@ -651,1 +658,1 @@\n-    if (_codeBlob != NULL) {\n+    else if (_codeBlob != nullptr) {\n@@ -655,2 +662,2 @@\n-    if (_strings != NULL) {\n-      _strings->print_block_comment(st, (intptr_t)(p - _start));\n+    else if (_remarks != nullptr) {\n+      _remarks->print((p - _start) + _disp, st);\n@@ -933,1 +940,2 @@\n-void Disassembler::decode(address start, address end, outputStream* st, const CodeStrings* c) {\n+void Disassembler::decode(address start, address end, outputStream* st\n+                          NOT_PRODUCT(COMMA const AsmRemarks* remarks COMMA ptrdiff_t disp)) {\n@@ -946,14 +954,1 @@\n-    return;\n-  }\n-\n-\/\/ Don't do that fancy stuff. If we just have two addresses, live with it\n-\/\/ and treat the memory contents as \"amorphic\" piece of code.\n-#if 0\n-  CodeBlob* cb = CodeCache::find_blob_unsafe(start);\n-  if (cb != NULL) {\n-    \/\/ If we  have an CodeBlob at hand,\n-    \/\/ call the specialized decoder directly.\n-    decode(cb, st, c);\n-  } else\n-#endif\n-  {\n+  } else {\n@@ -961,1 +956,1 @@\n-    decode_env env(start, end, st, c);\n+    decode_env env(start, end, st NOT_PRODUCT(COMMA remarks COMMA disp));\n","filename":"src\/hotspot\/share\/compiler\/disassembler.cpp","additions":25,"deletions":30,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-  static void decode(CodeBlob *cb,               outputStream* st = NULL);\n+  static void decode(CodeBlob* cb,               outputStream* st = NULL);\n@@ -106,1 +106,2 @@\n-  static void decode(address start, address end, outputStream* st = NULL, const CodeStrings* = NULL);\n+  static void decode(address start, address end, outputStream* st = NULL\n+                     NOT_PRODUCT(COMMA const AsmRemarks* remarks = NULL COMMA ptrdiff_t disp = 0));\n","filename":"src\/hotspot\/share\/compiler\/disassembler.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-\/\/------------------------------------------------------------------------------------------------------------------------\n+\/\/------------------------------------------------------------------------------\n@@ -54,6 +54,8 @@\n-  _description       = description;\n-  _bytecode          = bytecode;\n-}\n-\n-\n-void InterpreterCodelet::verify() {\n+  _description = description;\n+  _bytecode    = bytecode;\n+#ifndef PRODUCT\n+  AsmRemarks* arp = new(&_asm_remarks) AsmRemarks();\n+  DbgStrings* dsp = new(&_dbg_strings) DbgStrings();\n+  postcond(arp == &_asm_remarks);\n+  postcond(dsp == &_dbg_strings);\n+#endif\n@@ -62,0 +64,1 @@\n+void InterpreterCodelet::verify() {}\n@@ -78,1 +81,1 @@\n-    Disassembler::decode(code_begin(), code_end(), st DEBUG_ONLY(COMMA &_strings));\n+    Disassembler::decode(code_begin(), code_end(), st NOT_PRODUCT(COMMA &_asm_remarks));\n@@ -107,3 +110,7 @@\n-  if (committed_code_size) {\n-    CodeStrings cs NOT_PRODUCT(= (*_masm)->code()->strings());\n-    AbstractInterpreter::code()->commit(committed_code_size, cs);\n+  if (committed_code_size > 0) {\n+    \/\/ This is  the ONE place where  we pickup any assembly  remarks and debug\n+    \/\/ strings, and propagate these to the codelet.\n+    NOT_PRODUCT(_clet->use_remarks((*_masm)->code()->asm_remarks()));\n+    NOT_PRODUCT(_clet->use_strings((*_masm)->code()->dbg_strings()));\n+\n+    AbstractInterpreter::code()->commit(committed_code_size);\n","filename":"src\/hotspot\/share\/interpreter\/interpreter.cpp","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-  NOT_PRODUCT(CodeStrings _strings;)              \/\/ Comments for annotating assembler output.\n@@ -53,0 +52,2 @@\n+  NOT_PRODUCT(AsmRemarks _asm_remarks;)   \/\/ Comments for annotating assembler output.\n+  NOT_PRODUCT(DbgStrings _dbg_strings;)   \/\/ Debug strings used in generated code.\n@@ -56,4 +57,1 @@\n-  void    initialize(int size,\n-                     CodeStrings& strings)       { _size = size;\n-                                                   NOT_PRODUCT(_strings = CodeStrings();)\n-                                                   NOT_PRODUCT(_strings.copy(strings);) }\n+  void    initialize(int size)                   { _size = size; }\n@@ -82,0 +80,9 @@\n+#ifndef PRODUCT\n+ ~InterpreterCodelet() {\n+    \/\/ InterpreterCodelets reside in the StubQueue and should not be deleted,\n+    \/\/ nor are they ever finalized (see above).\n+    ShouldNotCallThis();\n+  }\n+  void use_remarks(AsmRemarks &remarks) { _asm_remarks.share(remarks); }\n+  void use_strings(DbgStrings &strings) { _dbg_strings.share(strings); }\n+#endif\n","filename":"src\/hotspot\/share\/interpreter\/interpreter.hpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1348,1 +1348,2 @@\n-              Disassembler::decode(handler, handler + buffer.insts_size());\n+              Disassembler::decode(handler, handler + buffer.insts_size(), tty\n+                                   NOT_PRODUCT(COMMA &buffer.asm_remarks()));\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2948,1 +2948,2 @@\n-        Disassembler::decode(first_pc, first_pc + insts_size);\n+        Disassembler::decode(first_pc, first_pc + insts_size, tty\n+                             NOT_PRODUCT(COMMA &new_adapter->asm_remarks()));\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -81,1 +81,2 @@\n-    blob->set_strings(cbuf->strings());\n+    blob->use_remarks(cbuf->asm_remarks());\n+    blob->use_strings(cbuf->dbg_strings());\n@@ -93,3 +94,2 @@\n-    \/\/ Find the code strings in the outer CodeBuffer.\n-    CodeBuffer *outer_cbuf = _masm->code_section()->outer();\n-    CodeStrings* cs = &outer_cbuf->strings();\n+    \/\/ Find the assembly code remarks in the outer CodeBuffer.\n+    AsmRemarks* remarks = &_masm->code_section()->outer()->asm_remarks();\n@@ -101,1 +101,2 @@\n-    Disassembler::decode(cdesc->begin(), cdesc->end(), tty NOT_PRODUCT(COMMA cs));\n+    Disassembler::decode(cdesc->begin(), cdesc->end(), tty\n+                         NOT_PRODUCT(COMMA remarks COMMA cdesc->disp()));\n@@ -122,0 +123,5 @@\n+#ifndef PRODUCT\n+  address base = _cgen->assembler()->code_section()->outer()->insts_begin();\n+  address head = _cdesc->begin();\n+  _cdesc->set_disp(uint(head - base));\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n-  static StubCodeDesc* _list;                  \/\/ the list of all descriptors\n-  static bool          _frozen;                \/\/ determines whether _list modifications are allowed\n+  static StubCodeDesc* _list;     \/\/ the list of all descriptors\n+  static bool          _frozen;   \/\/ determines whether _list modifications are allowed\n@@ -44,5 +44,6 @@\n-  StubCodeDesc*        _next;                  \/\/ the next element in the linked list\n-  const char*          _group;                 \/\/ the group to which the stub code belongs\n-  const char*          _name;                  \/\/ the name assigned to the stub code\n-  address              _begin;                 \/\/ points to the first byte of the stub code    (included)\n-  address              _end;                   \/\/ points to the first byte after the stub code (excluded)\n+  StubCodeDesc*        _next;     \/\/ the next element in the linked list\n+  const char*          _group;    \/\/ the group to which the stub code belongs\n+  const char*          _name;     \/\/ the name assigned to the stub code\n+  address              _begin;    \/\/ points to the first byte of the stub code    (included)\n+  address              _end;      \/\/ points to the first byte after the stub code (excluded)\n+  uint                 _disp;     \/\/ Displacement relative base address in buffer.\n@@ -50,4 +51,2 @@\n-  void set_end(address end) {\n-    assert(_begin <= end, \"begin & end not properly ordered\");\n-    _end = end;\n-  }\n+  friend class StubCodeMark;\n+  friend class StubCodeGenerator;\n@@ -61,2 +60,6 @@\n-  friend class StubCodeMark;\n-  friend class StubCodeGenerator;\n+  void set_end(address end) {\n+    assert(_begin <= end, \"begin & end not properly ordered\");\n+    _end = end;\n+  }\n+\n+  void set_disp(uint disp) { _disp = disp; }\n@@ -79,0 +82,1 @@\n+    _disp           = 0;\n@@ -88,0 +92,1 @@\n+  uint        disp() const                       { return _disp; }\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.hpp","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,263 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifndef PRODUCT\n+#ifndef ZERO\n+\n+#include \"asm\/macroAssembler.inline.hpp\"\n+#include \"compiler\/disassembler.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"unittest.hpp\"\n+\n+#include <regex>\n+\n+static const char* replace_addr_expr(const char* str)\n+{\n+    \/\/ Remove any address expression \"0x0123456789abcdef\" found in order to\n+    \/\/ aid string comparison. Also remove any trailing printout from a padded\n+    \/\/ buffer.\n+\n+    std::basic_string<char> tmp = std::regex_replace(str, std::regex(\"0x[0-9a-fA-F]+\"), \"<addr>\");\n+    std::basic_string<char> red = std::regex_replace(tmp, std::regex(\"\\\\s+<addr>:\\\\s+\\\\.inst\\\\t<addr> ; undefined\"), \"\");\n+\n+    return os::strdup(red.c_str());\n+}\n+\n+static const char* delete_header_line(const char* str)\n+{\n+    \/\/ Remove (second) header line in output, e.g.:\n+    \/\/ Decoding CodeBlob, name: CodeStringTest, at [<addr>, <addr>] 8 bytes\\n\n+\n+    std::basic_string<char> red = std::regex_replace(str, std::regex(\"Decoding.+bytes\\\\n\"), \"\");\n+\n+    return os::strdup(red.c_str());\n+}\n+\n+static void asm_remarks_check(const AsmRemarks &rem1,\n+                              const AsmRemarks &rem2)\n+{\n+    ASSERT_EQ(rem1.ref(), rem2.ref()) << \"Should share the same collection.\";\n+}\n+\n+static void dbg_strings_check(const DbgStrings &dbg1,\n+                              const DbgStrings &dbg2)\n+{\n+    ASSERT_EQ(dbg1.ref(), dbg2.ref()) << \"Should share the same collection.\";\n+}\n+\n+static void disasm_string_check(CodeBuffer* cbuf, CodeBlob* blob)\n+{\n+    if (Disassembler::is_abstract())\n+    {\n+        return;   \/\/ No disassembler available (no comments will be used).\n+    }\n+    stringStream out1, out2;\n+\n+    Disassembler::decode(cbuf->insts_begin(), cbuf->insts_end(), &out1, &cbuf->asm_remarks());\n+    Disassembler::decode(blob->code_begin(), blob->code_end(), &out2, &blob->asm_remarks());\n+\n+    EXPECT_STREQ(replace_addr_expr(out1.as_string()),\n+                 replace_addr_expr(out2.as_string()))\n+        << \"1. Output should be identical.\";\n+\n+    stringStream out3;\n+\n+    Disassembler::decode(blob, &out3);\n+\n+    EXPECT_STREQ(replace_addr_expr(out2.as_string()),\n+                 replace_addr_expr(delete_header_line(out3.as_string())))\n+        << \"2. Output should be identical.\";\n+}\n+\n+static void copy_and_compare(CodeBuffer* cbuf)\n+{\n+    bool remarks_empty = cbuf->asm_remarks().is_empty();\n+    bool strings_empty = cbuf->dbg_strings().is_empty();\n+\n+    BufferBlob* blob = BufferBlob::create(\"CodeBuffer Copy&Compare\", cbuf);\n+\n+    \/\/ 1. Check Assembly Remarks are shared by buffer and blob.\n+    asm_remarks_check(cbuf->asm_remarks(), blob->asm_remarks());\n+\n+    \/\/ 2. Check Debug Strings are shared by buffer and blob.\n+    dbg_strings_check(cbuf->dbg_strings(), blob->dbg_strings());\n+\n+    \/\/ 3. Check that the disassembly output matches.\n+    disasm_string_check(cbuf, blob);\n+\n+    BufferBlob::free(blob);\n+\n+    ASSERT_EQ(remarks_empty, cbuf->asm_remarks().is_empty())\n+        << \"Expecting property to be unchanged.\";\n+    ASSERT_EQ(strings_empty, cbuf->dbg_strings().is_empty())\n+        << \"Expecting property to be unchanged.\";\n+}\n+\n+static void code_buffer_test()\n+{\n+    constexpr int BUF_SZ = 256;\n+\n+    ResourceMark rm;\n+    CodeBuffer cbuf(\"CodeStringTest\", BUF_SZ, BUF_SZ);\n+    MacroAssembler as(&cbuf);\n+\n+    ASSERT_TRUE(cbuf.asm_remarks().is_empty());\n+    ASSERT_TRUE(cbuf.dbg_strings().is_empty());\n+\n+    ASSERT_TRUE(cbuf.blob()->asm_remarks().is_empty());\n+    ASSERT_TRUE(cbuf.blob()->dbg_strings().is_empty());\n+\n+    int re, sz, n;\n+\n+    re = cbuf.insts_remaining();\n+\n+    \/\/ 1. Generate a first entry.\n+    as.block_comment(\"First block comment.\");\n+    as.nop();\n+\n+    sz = re - cbuf.insts_remaining();\n+\n+    ASSERT_TRUE(sz > 0);\n+\n+    ASSERT_FALSE(cbuf.asm_remarks().is_empty());\n+    ASSERT_TRUE(cbuf.dbg_strings().is_empty());\n+\n+    ASSERT_TRUE(cbuf.blob()->asm_remarks().is_empty());\n+    ASSERT_TRUE(cbuf.blob()->dbg_strings().is_empty());\n+\n+    copy_and_compare(&cbuf);\n+\n+    n = re\/sz;\n+    ASSERT_TRUE(n > 0);\n+\n+    \/\/ 2. Generate additional entries without causing the buffer to expand.\n+    for (unsigned i = 0; i < unsigned(n)\/2; i++)\n+    {\n+        ASSERT_FALSE(cbuf.insts()->maybe_expand_to_ensure_remaining(sz));\n+        ASSERT_TRUE(cbuf.insts_remaining()\/sz >= n\/2);\n+\n+        stringStream strm;\n+        strm.print(\"Comment No. %d\", i);\n+        as.block_comment(strm.as_string());\n+        as.nop();\n+    }\n+    ASSERT_FALSE(cbuf.asm_remarks().is_empty());\n+\n+    copy_and_compare(&cbuf);\n+\n+    re = cbuf.insts_remaining();\n+\n+    \/\/ 3. Generate a single code with a debug string.\n+    as.unimplemented(\"First debug string.\");\n+\n+    ASSERT_FALSE(cbuf.asm_remarks().is_empty());\n+    ASSERT_FALSE(cbuf.dbg_strings().is_empty());\n+\n+    sz = re - cbuf.insts_remaining();\n+    n = (re - sz)\/sz;\n+    ASSERT_TRUE(n > 0);\n+\n+    \/\/ 4. Generate additional code with debug strings.\n+    for (unsigned i = 0; i < unsigned(n); i++)\n+    {\n+        ASSERT_TRUE(cbuf.insts_remaining() >= sz);\n+\n+        stringStream strm;\n+        strm.print(\"Fixed address string No. %d\", i);\n+        as.unimplemented(strm.as_string());\n+    }\n+    ASSERT_TRUE(cbuf.insts_remaining() >= 0);\n+\n+    ASSERT_FALSE(cbuf.asm_remarks().is_empty());\n+    ASSERT_FALSE(cbuf.dbg_strings().is_empty());\n+\n+    ASSERT_TRUE(cbuf.blob()->asm_remarks().is_empty());\n+    ASSERT_TRUE(cbuf.blob()->dbg_strings().is_empty());\n+\n+    copy_and_compare(&cbuf);\n+}\n+\n+static void buffer_blob_test()\n+{\n+    constexpr int BUF_SZ = 256;\n+\n+    ResourceMark rm;\n+    BufferBlob* blob = BufferBlob::create(\"BufferBlob Test\", BUF_SZ);\n+    CodeBuffer cbuf(blob);\n+    MacroAssembler as(&cbuf);\n+\n+    ASSERT_FALSE(cbuf.insts()->has_locs());\n+\n+    \/\/ The x86-64 version of 'stop' will use relocation info. that will result\n+    \/\/ in tainting the location start and limit if no location info. buffer is\n+    \/\/ present.\n+    static uint8_t s_loc_buf[BUF_SZ];  \/\/ Raw memory buffer used for relocInfo.\n+    cbuf.insts()->initialize_shared_locs((relocInfo*)&s_loc_buf[0], BUF_SZ);\n+\n+    int re = cbuf.insts_remaining();\n+\n+    as.block_comment(\"First block comment.\");\n+    as.nop();\n+    as.unimplemented(\"First debug string.\");\n+\n+    int sz = re - cbuf.insts_remaining();\n+\n+    ASSERT_TRUE(sz > 0);\n+    constexpr int LIM_GEN = 51; \/\/ Limit number of entries generated.\n+\n+    for (unsigned i = 0; i < LIM_GEN; i++)\n+    {\n+        if (cbuf.insts_remaining() < sz) break;\n+\n+        stringStream strm1;\n+        strm1.print(\"Comment No. %d\", i);\n+        as.block_comment(strm1.as_string());\n+        as.nop();\n+\n+        stringStream strm2;\n+        strm2.print(\"Fixed address string No. %d\", i);\n+        as.unimplemented(strm2.as_string());\n+    }\n+    ASSERT_TRUE(cbuf.insts_remaining() >= 0);\n+\n+    ASSERT_FALSE(cbuf.asm_remarks().is_empty());\n+    ASSERT_FALSE(cbuf.dbg_strings().is_empty());\n+\n+    copy_and_compare(&cbuf);\n+\n+    ASSERT_TRUE(blob->asm_remarks().is_empty());\n+    ASSERT_TRUE(blob->dbg_strings().is_empty());\n+\n+    BufferBlob::free(blob);\n+}\n+\n+TEST_VM(codestrings, validate)\n+{\n+    code_buffer_test();\n+    buffer_blob_test();\n+}\n+\n+#endif \/\/ not ZERO\n+#endif \/\/ not PRODUCT\n","filename":"test\/hotspot\/gtest\/code\/test_codestrings.cpp","additions":263,"deletions":0,"binary":false,"changes":263,"status":"added"}]}