{"files":[{"patch":"@@ -293,1 +293,1 @@\n-  virtual bool final_graph_reshaping(Compile* compile, Node* n, uint opcode) const { return false; }\n+  virtual bool final_graph_reshaping(Compile* compile, Node* n, uint opcode, Unique_Node_List& dead_nodes) const { return false; }\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1127,1 +1127,1 @@\n-bool ShenandoahBarrierSetC2::final_graph_reshaping(Compile* compile, Node* n, uint opcode) const {\n+bool ShenandoahBarrierSetC2::final_graph_reshaping(Compile* compile, Node* n, uint opcode, Unique_Node_List& dead_nodes) const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-  virtual bool final_graph_reshaping(Compile* compile, Node* n, uint opcode) const;\n+  virtual bool final_graph_reshaping(Compile* compile, Node* n, uint opcode, Unique_Node_List& dead_nodes) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1657,0 +1657,1 @@\n+  init_req( ValidLengthTest    , topnode);\n@@ -1689,48 +1690,0 @@\n-\/\/=============================================================================\n-Node* AllocateArrayNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  if (remove_dead_region(phase, can_reshape))  return this;\n-  \/\/ Don't bother trying to transform a dead node\n-  if (in(0) && in(0)->is_top())  return NULL;\n-\n-  const Type* type = phase->type(Ideal_length());\n-  if (type->isa_int() && type->is_int()->_hi < 0) {\n-    if (can_reshape) {\n-      PhaseIterGVN *igvn = phase->is_IterGVN();\n-      \/\/ Unreachable fall through path (negative array length),\n-      \/\/ the allocation can only throw so disconnect it.\n-      Node* proj = proj_out_or_null(TypeFunc::Control);\n-      Node* catchproj = NULL;\n-      if (proj != NULL) {\n-        for (DUIterator_Fast imax, i = proj->fast_outs(imax); i < imax; i++) {\n-          Node *cn = proj->fast_out(i);\n-          if (cn->is_Catch()) {\n-            catchproj = cn->as_Multi()->proj_out_or_null(CatchProjNode::fall_through_index);\n-            break;\n-          }\n-        }\n-      }\n-      if (catchproj != NULL && catchproj->outcnt() > 0 &&\n-          (catchproj->outcnt() > 1 ||\n-           catchproj->unique_out()->Opcode() != Op_Halt)) {\n-        assert(catchproj->is_CatchProj(), \"must be a CatchProjNode\");\n-        Node* nproj = catchproj->clone();\n-        igvn->register_new_node_with_optimizer(nproj);\n-\n-        Node *frame = new ParmNode( phase->C->start(), TypeFunc::FramePtr );\n-        frame = phase->transform(frame);\n-        \/\/ Halt & Catch Fire\n-        Node* halt = new HaltNode(nproj, frame, \"unexpected negative array length\");\n-        phase->C->root()->add_req(halt);\n-        phase->transform(halt);\n-\n-        igvn->replace_node(catchproj, phase->C->top());\n-        return this;\n-      }\n-    } else {\n-      \/\/ Can't correct it during regular GVN so register for IGVN\n-      phase->C->record_for_igvn(this);\n-    }\n-  }\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":48,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -916,0 +916,1 @@\n+    ValidLengthTest,\n@@ -925,0 +926,1 @@\n+    fields[ValidLengthTest] = TypeInt::BOOL;\n@@ -1019,4 +1021,2 @@\n-  AllocateArrayNode(Compile* C, const TypeFunc *atype, Node *ctrl, Node *mem, Node *abio,\n-                    Node* size, Node* klass_node, Node* initial_test,\n-                    Node* count_val\n-                    )\n+  AllocateArrayNode(Compile* C, const TypeFunc* atype, Node* ctrl, Node* mem, Node* abio, Node* size, Node* klass_node,\n+                    Node* initial_test, Node* count_val, Node* valid_length_test)\n@@ -1028,0 +1028,1 @@\n+    set_req(AllocateNode::ValidLengthTest, valid_length_test);\n@@ -1030,1 +1031,0 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2642,0 +2642,11 @@\n+      } else if (call->is_AllocateArray()) {\n+        Node* klass_node = call->in(AllocateNode::KlassNode);\n+        Node* length = call->in(AllocateNode::ALength);\n+        const Type* length_type = phase->type(length);\n+        const Type* klass_type = phase->type(klass_node);\n+        Node* valid_length_test = call->in(AllocateNode::ValidLengthTest);\n+        const Type* valid_length_test_t = phase->type(valid_length_test);\n+        if (length_type == Type::TOP || klass_type == Type::TOP || valid_length_test_t == Type::TOP ||\n+            valid_length_test_t->is_int()->is_con(0)) {\n+          f[CatchProjNode::fall_through_index] = Type::TOP;\n+        }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2874,1 +2874,1 @@\n-void Compile::final_graph_reshaping_impl( Node *n, Final_Reshape_Counts &frc) {\n+void Compile::final_graph_reshaping_impl(Node *n, Final_Reshape_Counts& frc, Unique_Node_List& dead_nodes) {\n@@ -2925,1 +2925,1 @@\n-  bool gc_handled = BarrierSet::barrier_set()->barrier_set_c2()->final_graph_reshaping(this, n, nop);\n+  bool gc_handled = BarrierSet::barrier_set()->barrier_set_c2()->final_graph_reshaping(this, n, nop, dead_nodes);\n@@ -2927,1 +2927,1 @@\n-    final_graph_reshaping_main_switch(n, frc, nop);\n+    final_graph_reshaping_main_switch(n, frc, nop, dead_nodes);\n@@ -2936,1 +2936,1 @@\n-void Compile::final_graph_reshaping_main_switch(Node* n, Final_Reshape_Counts& frc, uint nop) {\n+void Compile::final_graph_reshaping_main_switch(Node* n, Final_Reshape_Counts& frc, uint nop, Unique_Node_List& dead_nodes) {\n@@ -3521,3 +3521,1 @@\n-      ResourceMark rm;\n-      Unique_Node_List wq;\n-      wq.push(n->in(MemBarNode::Precedent));\n+      dead_nodes.push(n->in(MemBarNode::Precedent));\n@@ -3525,12 +3523,0 @@\n-      while (wq.size() > 0) {\n-        Node* m = wq.pop();\n-        if (m->outcnt() == 0 && m != top()) {\n-          for (uint j = 0; j < m->req(); j++) {\n-            Node* in = m->in(j);\n-            if (in != NULL) {\n-              wq.push(in);\n-            }\n-          }\n-          m->disconnect_inputs(this);\n-        }\n-      }\n@@ -3609,1 +3595,1 @@\n-void Compile::final_graph_reshaping_walk( Node_Stack &nstack, Node *root, Final_Reshape_Counts &frc ) {\n+void Compile::final_graph_reshaping_walk(Node_Stack& nstack, Node* root, Final_Reshape_Counts& frc, Unique_Node_List& dead_nodes) {\n@@ -3635,1 +3621,1 @@\n-      final_graph_reshaping_impl( n, frc );\n+      final_graph_reshaping_impl(n, frc, dead_nodes);\n@@ -3735,1 +3721,2 @@\n-  final_graph_reshaping_walk(nstack, root(), frc);\n+  Unique_Node_List dead_nodes;\n+  final_graph_reshaping_walk(nstack, root(), frc, dead_nodes);\n@@ -3748,1 +3735,1 @@\n-          CallNode *call = n->in(0)->in(0)->as_Call();\n+          CallNode* call = n->in(0)->in(0)->as_Call();\n@@ -3757,1 +3744,1 @@\n-            Node *arg0 = call->in(TypeFunc::Parms);\n+            Node* arg0 = call->in(TypeFunc::Parms);\n@@ -3762,4 +3749,3 @@\n-          } else if (call->entry_point() == OptoRuntime::new_array_Java() &&\n-                     call->req() > TypeFunc::Parms+1 &&\n-                     call->is_CallStaticJava()) {\n-            \/\/ Check for negative array length. In such case, the optimizer has\n+          } else if (call->entry_point() == OptoRuntime::new_array_Java() ||\n+                     call->entry_point() == OptoRuntime::new_array_nozero_Java()) {\n+            \/\/ Check for illegal array length. In such case, the optimizer has\n@@ -3768,3 +3754,6 @@\n-            Node *arg1 = call->in(TypeFunc::Parms+1);\n-            if (arg1->is_Type() &&\n-                arg1->as_Type()->type()->join(TypeInt::POS)->empty()) {\n+            assert(call->is_CallStaticJava(), \"static call expected\");\n+            assert(call->req() == call->jvms()->endoff() + 1, \"missing extra input\");\n+            uint valid_length_test_input = call->req() - 1;\n+            Node* valid_length_test = call->in(valid_length_test_input);\n+            call->del_req(valid_length_test_input);\n+            if (valid_length_test->find_int_con(1) == 0) {\n@@ -3773,0 +3762,3 @@\n+            dead_nodes.push(valid_length_test);\n+            assert(n->outcnt() == required_outcnt, \"malformed control flow\");\n+            continue;\n@@ -3781,0 +3773,10 @@\n+    } else if (n->is_PCTable() && n->in(0) && n->in(0)->in(0) && n->in(0)->in(0)->is_Call()) {\n+      CallNode* call = n->in(0)->in(0)->as_Call();\n+      if (call->entry_point() == OptoRuntime::new_array_Java() ||\n+          call->entry_point() == OptoRuntime::new_array_nozero_Java()) {\n+        assert(call->is_CallStaticJava(), \"static call expected\");\n+        assert(call->req() == call->jvms()->endoff() + 1, \"missing extra input\");\n+        uint valid_length_test_input = call->req() - 1;\n+        dead_nodes.push(call->in(valid_length_test_input));\n+        call->del_req(valid_length_test_input); \/\/ valid length test useless now\n+      }\n@@ -3799,0 +3801,13 @@\n+  while (dead_nodes.size() > 0) {\n+    Node* m = dead_nodes.pop();\n+    if (m->outcnt() == 0 && m != top()) {\n+      for (uint j = 0; j < m->req(); j++) {\n+        Node* in = m->in(j);\n+        if (in != NULL) {\n+          dead_nodes.push(in);\n+        }\n+      }\n+      m->disconnect_inputs(this);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":46,"deletions":31,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -1116,3 +1116,3 @@\n-  void final_graph_reshaping_impl( Node *n, Final_Reshape_Counts &frc);\n-  void final_graph_reshaping_main_switch(Node* n, Final_Reshape_Counts& frc, uint nop);\n-  void final_graph_reshaping_walk( Node_Stack &nstack, Node *root, Final_Reshape_Counts &frc );\n+  void final_graph_reshaping_impl(Node *n, Final_Reshape_Counts& frc, Unique_Node_List& dead_nodes);\n+  void final_graph_reshaping_main_switch(Node* n, Final_Reshape_Counts& frc, uint nop, Unique_Node_List& dead_nodes);\n+  void final_graph_reshaping_walk(Node_Stack& nstack, Node* root, Final_Reshape_Counts& frc, Unique_Node_List& dead_nodes);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2733,1 +2733,3 @@\n-  Node* norm = _gvn.transform( new CatchProjNode(catc, CatchProjNode::fall_through_index, CatchProjNode::no_handler_bci) );\n+  Node* norm = new CatchProjNode(catc, CatchProjNode::fall_through_index, CatchProjNode::no_handler_bci);\n+  _gvn.set_type_bottom(norm);\n+  C->record_for_igvn(norm);\n@@ -3972,0 +3974,9 @@\n+  const TypeOopPtr* ary_type = _gvn.type(klass_node)->is_klassptr()->as_instance_type();\n+  Node* valid_length_test = _gvn.intcon(1);\n+  if (ary_type->isa_aryptr()) {\n+    BasicType bt = ary_type->isa_aryptr()->elem()->array_element_basic_type();\n+    jint max = TypeAryPtr::max_array_length(bt);\n+    Node* valid_length_cmp  = _gvn.transform(new CmpUNode(length, intcon(max)));\n+    valid_length_test = _gvn.transform(new BoolNode(valid_length_cmp, BoolTest::le));\n+  }\n+\n@@ -3978,1 +3989,1 @@\n-                            length);\n+                            length, valid_length_test);\n@@ -3985,1 +3996,0 @@\n-  const TypeOopPtr* ary_type = _gvn.type(klass_node)->is_klassptr()->as_instance_type();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1931,1 +1931,7 @@\n-      if (use->is_If() || use->is_CMove() || C->is_predicate_opaq(use) || use->Opcode() == Op_Opaque4) {\n+      \/\/\n+      \/\/ If the use is an AllocateArray through its ValidLengthTest input,\n+      \/\/ make sure the Bool\/Cmp input is cloned down to avoid a Phi between\n+      \/\/ the AllocateArray node and its ValidLengthTest input that could cause\n+      \/\/ split if to break.\n+      if (use->is_If() || use->is_CMove() || C->is_predicate_opaq(use) || use->Opcode() == Op_Opaque4 ||\n+          (use->Opcode() == Op_AllocateArray && use->in(AllocateNode::ValidLengthTest) == old)) {\n@@ -2445,3 +2451,4 @@\n-      if (iff->in(1)->is_Phi()) {\n-        Node *b = clone_iff(iff->in(1)->as_Phi(), loop);\n-        _igvn.replace_input_of(iff, 1, b);\n+      uint input = iff->Opcode() == Op_AllocateArray ? AllocateNode::ValidLengthTest : 1;\n+      if (iff->in(input)->is_Phi()) {\n+        Node *b = clone_iff(iff->in(input)->as_Phi(), loop);\n+        _igvn.replace_input_of(iff, input, b);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1208,1 +1208,2 @@\n-            address slow_call_address  \/\/ Address of slow call\n+            address slow_call_address,  \/\/ Address of slow call\n+            Node* valid_length_test \/\/ whether length is valid or not\n@@ -1394,0 +1395,6 @@\n+  \/\/ For array allocations, copy the valid length check to the call node so Compile::final_graph_reshaping() can verify\n+  \/\/ that the call has the expected number of CatchProj nodes (in case the allocation always fails and the fallthrough\n+  \/\/ path dies).\n+  if (valid_length_test != NULL) {\n+    call->add_req(valid_length_test);\n+  }\n@@ -1875,1 +1882,1 @@\n-                         OptoRuntime::new_instance_Java());\n+                         OptoRuntime::new_instance_Java(), NULL);\n@@ -1880,0 +1887,1 @@\n+  Node* valid_length_test = alloc->in(AllocateNode::ValidLengthTest);\n@@ -1894,1 +1902,1 @@\n-                         slow_call_address);\n+                         slow_call_address, valid_length_test);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -95,2 +95,2 @@\n-                              address slow_call_address);\n-  void yank_initalize_node(InitializeNode* node);\n+                              address slow_call_address,\n+                              Node* valid_length_test);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1645,0 +1645,10 @@\n+    \/\/ If the ValidLengthTest input changes then the fallthrough path out of the AllocateArray may have become dead.\n+    \/\/ CatchNode::Value() is responsible for killing that path. The CatchNode has to be explicitly enqueued for igvn\n+    \/\/ to guarantee the change is not missed.\n+    if (use_op == Op_AllocateArray && n == use->in(AllocateNode::ValidLengthTest)) {\n+      Node* p = use->as_AllocateArray()->proj_out_or_null(TypeFunc::Control);\n+      if (p != NULL) {\n+        add_users_to_worklist0(p);\n+      }\n+    }\n+\n@@ -1811,0 +1821,1 @@\n+        \/\/ Same is true if the type of a ValidLengthTest input to an AllocateArrayNode changes.\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -131,2 +131,2 @@\n-              assert(use->is_If() || use->is_CMove() || use->Opcode() == Op_Opaque1, \"unexpected node type\");\n-              Node *use_c = use->is_If() ? use->in(0) : get_ctrl(use);\n+              assert(use->is_If() || use->is_CMove() || use->Opcode() == Op_Opaque1 || use->is_AllocateArray(), \"unexpected node type\");\n+              Node *use_c = (use->is_If() || use->is_AllocateArray()) ? use->in(0) : get_ctrl(use);\n@@ -169,2 +169,3 @@\n-                assert(u->is_If() || u->is_CMove() || u->Opcode() == Op_Opaque1, \"unexpected node type\");\n-                assert(u->in(1) == bol, \"\");\n+                assert(u->is_If() || u->is_CMove() || u->Opcode() == Op_Opaque1 || u->is_AllocateArray(), \"unexpected node type\");\n+                assert(u->is_AllocateArray() || u->in(1) == bol, \"\");\n+                assert(!u->is_AllocateArray() || u->in(AllocateNode::ValidLengthTest) == bol, \"wrong input to AllocateArray\");\n@@ -172,1 +173,1 @@\n-                Node *u_ctrl = u->is_If() ? u->in(0) : get_ctrl(u);\n+                Node *u_ctrl = (u->is_If() || u->is_AllocateArray()) ? u->in(0) : get_ctrl(u);\n@@ -176,1 +177,1 @@\n-                _igvn.replace_input_of(u, 1, x);\n+                _igvn.replace_input_of(u, u->is_AllocateArray() ? AllocateNode::ValidLengthTest : 1, x);\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8279125\n+ * @summary fatal error: no reachable node should have no use\n+ * @requires vm.flavor == \"server\"\n+ *\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-DoEscapeAnalysis TestAllocArrayAfterAllocNoUse\n+ *\n+ *\/\n+\n+public class TestAllocArrayAfterAllocNoUse {\n+    private static Object field;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test();\n+        }\n+    }\n+\n+    private static void test() {\n+        try {\n+            final TestAllocArrayAfterAllocNoUse o = new TestAllocArrayAfterAllocNoUse();\n+        } catch (Exception e) {\n+            final int[] array = new int[100];\n+            field = array;\n+        }\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/allocation\/TestAllocArrayAfterAllocNoUse.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8279062\n+ * @summary C2: assert(t->meet(t0) == t) failed: Not monotonic after JDK-8278413\n+ *\n+ * @run main\/othervm -XX:-BackgroundCompilation TestCCPAllocateArray\n+ *\n+ *\/\n+\n+public class TestCCPAllocateArray {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            try {\n+                test();\n+            } catch (OutOfMemoryError e) {\n+            }\n+            length(42);\n+        }\n+    }\n+\n+    private static int[] test() {\n+        int i = 2;\n+        for (; i < 4; i *= 2);\n+        return new int[length(i)];\n+    }\n+\n+    private static int length(int i) {\n+        return i == 4 ? Integer.MAX_VALUE : 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/allocation\/TestCCPAllocateArray.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * bug 8279219\n+ * @summary C2 crash when allocating array of size too large\n+ * @requires vm.compiler2.enabled\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -ea -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-BackgroundCompilation TestFailedAllocationBadGraph\n+ *\/\n+\n+import jdk.test.whitebox.WhiteBox;\n+import java.lang.reflect.Method;\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+\n+public class TestFailedAllocationBadGraph {\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    private static long[] array;\n+    private static int field;\n+    private static volatile int barrier;\n+\n+    public static void main(String[] args) throws Exception {\n+        run(\"test1\");\n+        run(\"test2\");\n+    }\n+\n+    private static void run(String method) throws Exception {\n+        Method m = TestFailedAllocationBadGraph.class.getDeclaredMethod(method);\n+        WHITE_BOX.enqueueMethodForCompilation(m, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        if (!WHITE_BOX.isMethodCompiled(m) || WHITE_BOX.getMethodCompilationLevel(m) != CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION) {\n+            throw new RuntimeException(\"should still be compiled\");\n+        }\n+    }\n+\n+    private static int test1() {\n+        int length = Integer.MAX_VALUE;\n+        try {\n+            array = new long[length];\n+        } catch (OutOfMemoryError outOfMemoryError) {\n+            barrier = 0x42;\n+            length = field;\n+        }\n+        return length;\n+    }\n+\n+    private static int test2() {\n+        int length = -1;\n+        try {\n+            array = new long[length];\n+        } catch (OutOfMemoryError outOfMemoryError) {\n+            barrier = 0x42;\n+            length = field;\n+        }\n+        return length;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/allocation\/TestFailedAllocationBadGraph.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * bug 8288184\n+ * @summary C2 compilation asserts with \"Bad graph detected in compute_lca_of_uses\"\n+ * @run main\/othervm -XX:-BackgroundCompilation TestNewArrayBadSize\n+ *\/\n+\n+public class TestNewArrayBadSize {\n+    long instanceCount;\n+    int iFld;\n+\n+    void vMeth(int i, long l) {\n+        int i1, i19 = -845;\n+        for (i1 = 5; i1 > 1; i1 -= 2)\n+            try {\n+                int ax$0 = i19;\n+                try {\n+                    for (Object temp = new byte[i19]; ; i19 = \"1\".equals(\"0\") ? 2 : 1) {}\n+                } finally {\n+                    i19 = ax$0;\n+                }\n+            } catch (Throwable ax$3) {\n+            }\n+    }\n+\n+    void mainTest(String[] strArr1) {\n+        vMeth(iFld, instanceCount);\n+    }\n+\n+    public static void main(String[] strArr) {\n+        TestNewArrayBadSize _instance = new TestNewArrayBadSize();\n+        for (int i = 0; i < 10_000; ++i) _instance.mainTest(strArr);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/allocation\/TestNewArrayBadSize.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8291665\n+ * @summary C2: assert compiling SSLEngineInputRecord::decodeInputRecord\n+ * @run main\/othervm -Xbatch TestNewArrayOutsideLoopValidLengthTestInLoop\n+ *\/\n+\n+import java.util.Arrays;\n+\n+public class TestNewArrayOutsideLoopValidLengthTestInLoop {\n+    private static volatile int barrier;\n+\n+    public static void main(String[] args) {\n+        boolean[] allFalse = new boolean[100];\n+        boolean[] allTrue = new boolean[100];\n+        Arrays.fill(allTrue, true);\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(allFalse, allFalse, true);\n+            test1(allTrue, allFalse, true);\n+            test1(allFalse, allTrue, true);\n+            test1(allFalse, allFalse, false);\n+        }\n+    }\n+\n+    private static int[] test1(boolean[] flags1, boolean[] flags2, boolean flag) {\n+        for (int i = 1; i < 100; i *= 2) {\n+            boolean f = false;\n+            int j = i;\n+            if (flags1[i]) {\n+                barrier = 1;\n+                f = true;\n+                j = i \/ 2;\n+            }\n+            if (flag) {\n+                barrier = 1;\n+            }\n+            if (f) {\n+                return new int[j];\n+            }\n+            if (flags2[i]) {\n+                return new int[j];\n+            }\n+        }\n+        return null;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/allocation\/TestNewArrayOutsideLoopValidLengthTestInLoop.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"}]}