{"files":[{"patch":"@@ -49,0 +49,2 @@\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -160,0 +162,4 @@\n+    \/\/ inputQ lock: methods that take from the inputQ\n+    \/\/      must not run concurrently.\n+    private final Lock inputQLock = new ReentrantLock();\n+\n@@ -180,0 +186,2 @@\n+        \/\/ prevents drainInputQueue() from running concurrently\n+        inputQLock.lock();\n@@ -197,1 +205,1 @@\n-                DataFrame df = (DataFrame)frame;\n+                DataFrame df = (DataFrame) frame;\n@@ -247,0 +255,1 @@\n+            inputQLock.unlock();\n@@ -265,0 +274,1 @@\n+                \/\/ cancelImpl will eventually call drainInputQueue();\n@@ -266,1 +276,0 @@\n-                drainInputQueue();\n@@ -271,2 +280,3 @@\n-    \/\/ must only be called from the scheduler schedule() loop.\n-    \/\/ ensure that all received data frames are accounted for\n+    \/\/ Called from the scheduler schedule() loop,\n+    \/\/ or after resetting the stream.\n+    \/\/ Ensures that all received data frames are accounted for\n@@ -275,0 +285,2 @@\n+    \/\/ The inputQLock is used to prevent concurrently taking\n+    \/\/ from the queue.\n@@ -277,7 +289,12 @@\n-        while ((frame = inputQ.poll()) != null) {\n-            if (frame instanceof DataFrame df) {\n-                \/\/ Data frames that have been added to the inputQ\n-                \/\/ must be released using releaseUnconsumed() to\n-                \/\/ account for the amount of unprocessed bytes\n-                \/\/ tracked by the connection.windowUpdater.\n-                connection.releaseUnconsumed(df);\n+        \/\/ will wait until schedule() has finished taking\n+        \/\/ from the queue, if needed.\n+        inputQLock.lock();\n+        try {\n+            while ((frame = inputQ.poll()) != null) {\n+                if (frame instanceof DataFrame df) {\n+                    \/\/ Data frames that have been added to the inputQ\n+                    \/\/ must be released using releaseUnconsumed() to\n+                    \/\/ account for the amount of unprocessed bytes\n+                    \/\/ tracked by the connection.windowUpdater.\n+                    connection.releaseUnconsumed(df);\n+                }\n@@ -285,0 +302,2 @@\n+        } finally {\n+            inputQLock.unlock();\n@@ -396,1 +415,1 @@\n-            inputQ.add(df);\n+           pushDataFrame(len, df);\n@@ -402,0 +421,23 @@\n+    \/\/ Ensures that no data frame is pushed on the inputQ\n+    \/\/ after the stream is closed.\n+    \/\/ Changes to the `closed` boolean are guarded by the\n+    \/\/ stateLock. Contention should be low as only one\n+    \/\/ thread at a time adds to the inputQ, and\n+    \/\/ we can only contend when closing the stream.\n+    \/\/ Note that this method can run concurrently with\n+    \/\/ methods holding the inputQLock: that is OK.\n+    \/\/ The inputQLock is there to ensure that methods\n+    \/\/ taking from the queue are not running concurrently\n+    \/\/ with each others, but concurrently adding at the\n+    \/\/ end of the queue while peeking\/polling at the head\n+    \/\/ is OK.\n+    private void pushDataFrame(int len, DataFrame df) {\n+        boolean closed = false;\n+        synchronized(this) {\n+            if (!(closed = this.closed)) {\n+                inputQ.add(df);\n+            }\n+        }\n+        if (closed && len > 0) connection.releaseUnconsumed(df);\n+    }\n+\n@@ -1478,0 +1520,2 @@\n+        } finally {\n+            drainInputQueue();\n@@ -1703,1 +1747,1 @@\n-                            .formatted(streamid)), ResetFrame.FLOW_CONTROL_ERROR);\n+                        .formatted(streamid)), ResetFrame.FLOW_CONTROL_ERROR);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":57,"deletions":13,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -178,1 +178,5 @@\n-                        assertEquals(ckey, label, \"Unexpected key for \" + query);\n+                        if (i < max - 1) {\n+                            \/\/ the connection window might be exceeded at i == max - 2, which\n+                            \/\/ means that the last request could go on a new connection.\n+                            assertEquals(ckey, label, \"Unexpected key for \" + query);\n+                        }\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/ConnectionFlowControlTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8342075\n+ * @bug 8342075 8343855\n@@ -59,0 +59,1 @@\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpHeadOrGetHandler;\n@@ -75,0 +76,1 @@\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n@@ -98,0 +100,13 @@\n+    static void sleep(long wait) throws InterruptedException {\n+        if (wait <= 0) return;\n+        long remaining = Utils.adjustTimeout(wait);\n+        long start = System.nanoTime();\n+        while (remaining > 0) {\n+            Thread.sleep(remaining);\n+            long end = System.nanoTime();\n+            remaining = remaining - NANOSECONDS.toMillis(end - start);\n+        }\n+        System.out.printf(\"Waited %s ms%n\",\n+                NANOSECONDS.toMillis(System.nanoTime() - start));\n+    }\n+\n@@ -124,1 +139,1 @@\n-                        .POST(BodyPublishers.ofString(\"Hello there!\"))\n+                        .GET()\n@@ -139,1 +154,1 @@\n-                    int wait = uri.startsWith(\"https:\/\/\") ? 500 : 350;\n+                    long wait = uri.startsWith(\"https:\/\/\") ? 800 : 350;\n@@ -141,1 +156,1 @@\n-                        Thread.sleep(Utils.adjustTimeout(wait));\n+                        sleep(wait);\n@@ -190,1 +205,1 @@\n-                        .POST(BodyPublishers.ofString(\"Hello there!\"))\n+                        .GET()\n@@ -204,1 +219,1 @@\n-                    int wait = uri.startsWith(\"https:\/\/\") ? 600 : 300;\n+                    long wait = uri.startsWith(\"https:\/\/\") ? 800 : 350;\n@@ -206,1 +221,1 @@\n-                        Thread.sleep(Utils.adjustTimeout(wait));\n+                        sleep(wait);\n@@ -272,0 +287,1 @@\n+        this.https2TestServer.addHandler(new HttpHeadOrGetHandler(), \"\/https2\/head\/\");\n@@ -273,0 +289,1 @@\n+        String h2Head = \"https:\/\/\" + this.https2TestServer.serverAuthority() + \"\/https2\/head\/z\";\n@@ -281,0 +298,11 @@\n+\n+        \/\/ warmup to eliminate delay due to SSL class loading and initialization.\n+        HttpClient client = HttpClient.newBuilder().executor(Executors.newCachedThreadPool()).sslContext(sslContext).build();\n+        try {\n+            var request = HttpRequest.newBuilder(URI.create(h2Head)).method(\"HEAD\", BodyPublishers.noBody()).build();\n+            var resp = client.send(request, BodyHandlers.discarding());\n+            assertEquals(resp.statusCode(), 200);\n+        } finally {\n+            ExecutorService exec = (ExecutorService)client.executor().get();\n+            exec.shutdownNow();\n+        }\n@@ -299,2 +327,7 @@\n-                System.out.println(\"Server \" + t.getLocalAddress() + \" received:\\n\"\n-                        + t.getRequestURI() + \": \" + new String(bytes, StandardCharsets.UTF_8));\n+                if (bytes.length != 0) {\n+                    System.out.println(\"Server \" + t.getLocalAddress() + \" received:\\n\"\n+                            + t.getRequestURI() + \": \" + new String(bytes, StandardCharsets.UTF_8));\n+                } else {\n+                    System.out.println(\"No request body for \" + t.getRequestMethod());\n+                }\n+\n@@ -303,1 +336,4 @@\n-                if (bytes.length == 0) bytes = \"no request body!\".getBytes(StandardCharsets.UTF_8);\n+                if (bytes.length == 0) {\n+                    bytes = \"no request body!\"\n+                            .repeat(100).getBytes(StandardCharsets.UTF_8);\n+                }\n@@ -327,1 +363,14 @@\n-                    ((BodyOutputStream) os).writeUncontrolled(resp, 0, resp.length);\n+                    try {\n+                        ((BodyOutputStream) os).writeUncontrolled(resp, 0, resp.length);\n+                    } catch (IOException x) {\n+                        if (t instanceof FCHttp2TestExchange fct) {\n+                            fct.conn.updateConnectionWindow(resp.length);\n+                        }\n+                    }\n+                }\n+            } finally {\n+                if (t instanceof FCHttp2TestExchange fct) {\n+                    fct.responseSent(query);\n+                } else {\n+                    fail(\"Exchange is not %s but %s\"\n+                            .formatted(FCHttp2TestExchange.class.getName(), t.getClass().getName()));\n@@ -330,4 +379,0 @@\n-            if (t instanceof FCHttp2TestExchange fct) {\n-                fct.responseSent(query);\n-            } else fail(\"Exchange is not %s but %s\"\n-                    .formatted(FCHttp2TestExchange.class.getName(), t.getClass().getName()));\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/StreamFlowControlTest.java","additions":60,"deletions":15,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -69,0 +70,3 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+\n@@ -271,1 +275,1 @@\n-            public Version getServerVersion() { return Version.HTTP_1_1; }\n+            public Version getServerVersion() { return HTTP_1_1; }\n@@ -273,1 +277,1 @@\n-            public Version getExchangeVersion() { return Version.HTTP_1_1; }\n+            public Version getExchangeVersion() { return HTTP_1_1; }\n@@ -333,1 +337,1 @@\n-            public Version getServerVersion() { return Version.HTTP_2; }\n+            public Version getServerVersion() { return HTTP_2; }\n@@ -335,1 +339,1 @@\n-            public Version getExchangeVersion() { return Version.HTTP_2; }\n+            public Version getExchangeVersion() { return HTTP_2; }\n@@ -424,0 +428,47 @@\n+    \/**\n+     * An {@link HttpTestHandler} that handles only HEAD and GET\n+     * requests. If another method is used 405 is returned with\n+     * an empty body.\n+     * The response is always returned with fixed length.\n+     *\/\n+    public static class HttpHeadOrGetHandler implements HttpTestHandler {\n+        final String responseBody;\n+        public HttpHeadOrGetHandler() {\n+            this(\"pâté de tête persillé\");\n+        }\n+        public HttpHeadOrGetHandler(String responseBody) {\n+            this.responseBody = Objects.requireNonNull(responseBody);\n+        }\n+\n+        @Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            try (var exchg = t) {\n+                exchg.getRequestBody().readAllBytes();\n+                String method = exchg.getRequestMethod();\n+                switch (method) {\n+                    case \"HEAD\" -> {\n+                        byte[] resp = responseBody.getBytes(StandardCharsets.UTF_8);\n+                        if (exchg.getExchangeVersion() != HTTP_1_1) {\n+                            \/\/ with HTTP\/2 or HTTP\/3 the server will not send content-length\n+                            exchg.getResponseHeaders()\n+                                    .addHeader(\"Content-Length\", String.valueOf(resp.length));\n+                        }\n+                        exchg.sendResponseHeaders(200, resp.length);\n+                        exchg.getResponseBody().close();\n+                    }\n+                    case \"GET\" -> {\n+                        byte[] resp = responseBody.getBytes(StandardCharsets.UTF_8);\n+                        exchg.sendResponseHeaders(200, resp.length);\n+                        try (var os = exchg.getResponseBody()) {\n+                            os.write(resp);\n+                        }\n+                    }\n+                    default -> {\n+                        exchg.sendResponseHeaders(405, 0);\n+                        exchg.getResponseBody().close();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -880,1 +931,1 @@\n-            public Version getVersion() { return Version.HTTP_1_1; }\n+            public Version getVersion() { return HTTP_1_1; }\n@@ -905,1 +956,1 @@\n-            @Override public Version getVersion() { return Version.HTTP_1_1; }\n+            @Override public Version getVersion() { return HTTP_1_1; }\n@@ -936,1 +987,1 @@\n-            public Version getVersion() { return Version.HTTP_2; }\n+            public Version getVersion() { return HTTP_2; }\n@@ -974,1 +1025,1 @@\n-            @Override public Version getVersion() { return Version.HTTP_2; }\n+            @Override public Version getVersion() { return HTTP_2; }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/common\/HttpServerAdapters.java","additions":59,"deletions":8,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -1384,1 +1384,1 @@\n-    void updateConnectionWindow(int amount) {\n+    public void updateConnectionWindow(int amount) {\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServerConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}