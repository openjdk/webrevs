{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,39 @@\n-\/* @test\n+\/*\n+ * @test id=G1\n+ * @requires vm.gc.G1\n+ * @bug 8277072\n+ * @library \/test\/lib\/\n+ * @summary ObjectStreamClass caches keep ClassLoaders alive (G1 GC)\n+ * @run testng\/othervm -Xmx64m -XX:+UseG1GC ObjectStreamClassCaching\n+ *\/\n+\n+\/*\n+ * @test id=Parallel\n+ * @requires vm.gc.Parallel\n+ * @bug 8277072\n+ * @library \/test\/lib\/\n+ * @summary ObjectStreamClass caches keep ClassLoaders alive (Parallel GC)\n+ * @run testng\/othervm -Xmx64m -XX:+UseParallelGC ObjectStreamClassCaching\n+ *\/\n+\n+\/*\n+ * @test id=Z\n+ * @requires vm.gc.Z\n+ * @bug 8277072\n+ * @library \/test\/lib\/\n+ * @summary ObjectStreamClass caches keep ClassLoaders alive (Z GC)\n+ * @run testng\/othervm -Xmx64m -XX:+UseZGC ObjectStreamClassCaching\n+ *\/\n+\n+\/*\n+ * @test id=Shenandoah\n+ * @requires vm.gc.Shenandoah\n+ * @bug 8277072\n+ * @library \/test\/lib\/\n+ * @summary ObjectStreamClass caches keep ClassLoaders alive (Shenandoah GC)\n+ * @run testng\/othervm -Xmx64m -XX:+UseShenandoahGC ObjectStreamClassCaching\n+ *\/\n+\n+\/*\n+ * @test id=Serial\n+ * @requires vm.gc.Serial\n@@ -36,2 +74,2 @@\n- * @summary ObjectStreamClass caches keep ClassLoaders alive\n- * @run testng\/othervm -Xmx10m -XX:SoftRefLRUPolicyMSPerMB=1 ObjectStreamClassCaching\n+ * @summary ObjectStreamClass caches keep ClassLoaders alive (Serial GC)\n+ * @run testng\/othervm -Xmx64m -XX:+UseSerialGC ObjectStreamClassCaching\n@@ -41,0 +79,4 @@\n+    \/**\n+     * Test methods execute in same VM and are ordered by name.\n+     * We test effectiveness 1st which is sensitive to previous allocations when ZGC is used.\n+     *\/\n@@ -42,2 +84,19 @@\n-    public void testCachingEffectiveness() throws Exception {\n-        var ref = lookupObjectStreamClass(TestClass.class);\n+    public void test1CacheEffectiveness() throws Exception {\n+        var list = new ArrayList<>();\n+        var ref1 = lookupObjectStreamClass(TestClass1.class);\n+        var ref2 = newWeakRef();\n+        boolean oome = false;\n+        try {\n+            while (!ref2.refersTo(null)) {\n+                list.add(new byte[1024 * 1024 * 1]); \/\/ 1 MiB chunks\n+                System.out.println(\"1MiB allocated...\");\n+                Thread.sleep(5L);\n+            }\n+        } catch (OutOfMemoryError e) {\n+            \/\/ release\n+            list = null;\n+            oome = true;\n+        }\n+        assertFalse(oome, \"WeakReference was not cleared although memory was pressed hard\");\n+        assertFalse(ref1.refersTo(null),\n+                    \"Cache lost entry together with WeakReference being cleared although memory was not under pressure\");\n@@ -46,4 +105,0 @@\n-        \/\/ to trigger any ReferenceQueue processing...\n-        lookupObjectStreamClass(AnotherTestClass.class);\n-        assertFalse(ref.refersTo(null),\n-                    \"Cache lost entry although memory was not under pressure\");\n@@ -53,3 +108,12 @@\n-    public void testCacheReleaseUnderMemoryPressure() throws Exception {\n-        var ref = lookupObjectStreamClass(TestClass.class);\n-        pressMemoryHard(ref);\n+    public void test2CacheReleaseUnderMemoryPressure() throws Exception {\n+        var list = new ArrayList<>();\n+        var ref = lookupObjectStreamClass(TestClass2.class);\n+        try {\n+            while (!ref.refersTo(null)) {\n+                list.add(new byte[1024 * 1024 * 4]); \/\/ 4 MiB chunks\n+                System.out.println(\"4MiB allocated...\");\n+            }\n+        } catch (OutOfMemoryError e) {\n+            \/\/ release\n+            list = null;\n+        }\n@@ -63,1 +127,1 @@\n-    private static WeakReference<?> lookupObjectStreamClass(Class<?> cl) {\n+    private static Reference<?> lookupObjectStreamClass(Class<?> cl) {\n@@ -67,9 +131,3 @@\n-    private static void pressMemoryHard(Reference<?> ref) {\n-        try {\n-            var list = new ArrayList<>();\n-            while (!ref.refersTo(null)) {\n-                list.add(new byte[1024 * 1024 * 64]); \/\/ 64 MiB chunks\n-            }\n-        } catch (OutOfMemoryError e) {\n-            \/\/ release\n-        }\n+    \/\/ separate method so that the new Object() is not kept on stack\n+    private static Reference<?> newWeakRef() {\n+        return new WeakReference<>(new Object());\n@@ -77,1 +135,0 @@\n-}\n@@ -79,2 +136,2 @@\n-class TestClass implements Serializable {\n-}\n+    static class TestClass1 implements Serializable {\n+    }\n@@ -82,1 +139,2 @@\n-class AnotherTestClass implements Serializable {\n+    static class TestClass2 implements Serializable {\n+    }\n","filename":"test\/jdk\/java\/io\/ObjectStreamClass\/ObjectStreamClassCaching.java","additions":85,"deletions":27,"binary":false,"changes":112,"status":"modified"}]}