{"files":[{"patch":"@@ -1779,0 +1779,16 @@\n+\/\/ rotate left with shift bits, 32-bit version\n+void MacroAssembler::rolw_imm(Register dst, Register src, uint32_t shift, Register tmp) {\n+  if (UseZbb) {\n+    \/\/ no roliw available\n+    roriw(dst, src, 32 - shift);\n+    return;\n+  }\n+\n+  assert_different_registers(dst, tmp);\n+  assert_different_registers(src, tmp);\n+  assert(shift < 32, \"shift amount must be < 32\");\n+  srliw(tmp, src, 32 - shift);\n+  slliw(dst, src, shift);\n+  orr(dst, dst, tmp);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -571,1 +571,3 @@\n-    guarantee(is_simm13(offset) && ((offset % 2) == 0), \"offset is invalid.\");                           \\\n+    guarantee(is_simm13(offset) && is_even(offset),                                                      \\\n+              \"offset is invalid: is_simm_13: %s offset: \" INT64_FORMAT,                                 \\\n+              BOOL_TO_STR(is_simm13(offset)), offset);                                                   \\\n@@ -743,0 +745,1 @@\n+  void rolw_imm(Register dst, Register src, uint32_t, Register tmp = t0);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"utilities\/population_count.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -321,0 +323,2 @@\n+template <class RegImpl> class RegSetIterator;\n+\n@@ -328,1 +332,1 @@\n- public:\n+public:\n@@ -378,0 +382,2 @@\n+  uint size() const { return population_count(_bitset); }\n+\n@@ -379,0 +385,10 @@\n+\n+private:\n+\n+  RegImpl first();\n+\n+public:\n+\n+  friend class RegSetIterator<RegImpl>;\n+\n+  RegSetIterator<RegImpl> begin();\n@@ -385,0 +401,50 @@\n+template <class RegImpl>\n+class RegSetIterator {\n+  AbstractRegSet<RegImpl> _regs;\n+\n+public:\n+  RegSetIterator(AbstractRegSet<RegImpl> x): _regs(x) {}\n+  RegSetIterator(const RegSetIterator& mit) : _regs(mit._regs) {}\n+\n+  RegSetIterator& operator++() {\n+    RegImpl r = _regs.first();\n+    if (r->is_valid())\n+      _regs -= r;\n+    return *this;\n+  }\n+\n+  bool operator==(const RegSetIterator& rhs) const {\n+    return _regs.bits() == rhs._regs.bits();\n+  }\n+  bool operator!=(const RegSetIterator& rhs) const {\n+    return ! (rhs == *this);\n+  }\n+\n+  RegImpl operator*() {\n+    return _regs.first();\n+  }\n+};\n+\n+template <class RegImpl>\n+inline RegSetIterator<RegImpl> AbstractRegSet<RegImpl>::begin() {\n+  return RegSetIterator<RegImpl>(*this);\n+}\n+\n+template <>\n+inline Register AbstractRegSet<Register>::first() {\n+  uint32_t first = _bitset & -_bitset;\n+  return first ? as_Register(exact_log2(first)) : noreg;\n+}\n+\n+template <>\n+inline FloatRegister AbstractRegSet<FloatRegister>::first() {\n+  uint32_t first = _bitset & -_bitset;\n+  return first ? as_FloatRegister(exact_log2(first)) : fnoreg;\n+}\n+\n+template<>\n+inline VectorRegister AbstractRegSet<VectorRegister>::first() {\n+  uint32_t first = _bitset & -_bitset;\n+  return first ? as_VectorRegister(exact_log2(first)) : vnoreg;\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/register_riscv.hpp","additions":67,"deletions":1,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -3689,0 +3689,367 @@\n+  \/\/ Set of L registers that correspond to a contiguous memory area.\n+  \/\/ Each 64-bit register typically corresponds to 2 32-bit integers.\n+  template <uint L>\n+  class RegCache {\n+  private:\n+    MacroAssembler *_masm;\n+    Register _regs[L];\n+\n+  public:\n+    RegCache(MacroAssembler *masm, RegSet rs): _masm(masm) {\n+      assert(rs.size() == L, \"%u registers are used to cache %u 4-byte data\", rs.size(), 2 * L);\n+      auto it = rs.begin();\n+      for (auto &r: _regs) {\n+        r = *it;\n+        ++it;\n+      }\n+    }\n+\n+    void gen_loads(Register base) {\n+      for (uint i = 0; i < L; i += 1) {\n+        __ ld(_regs[i], Address(base, 8 * i));\n+      }\n+    }\n+\n+    \/\/ Generate code extracting i-th unsigned word (4 bytes).\n+    void get_u32(Register dest, uint i, Register rmask32) {\n+      assert(i < 2 * L, \"invalid i: %u\", i);\n+\n+      if (i % 2 == 0) {\n+        __ andr(dest, _regs[i \/ 2], rmask32);\n+      } else {\n+        __ srli(dest, _regs[i \/ 2], 32);\n+      }\n+    }\n+  };\n+\n+  typedef RegCache<8> BufRegCache;\n+\n+  \/\/ a += rtmp1 + x + ac;\n+  \/\/ a = Integer.rotateLeft(a, s) + b;\n+  void m5_FF_GG_HH_II_epilogue(BufRegCache& reg_cache,\n+                               Register a, Register b, Register c, Register d,\n+                               int k, int s, int t,\n+                               Register rtmp1, Register rtmp2, Register rmask32) {\n+    \/\/ rtmp1 = rtmp1 + x + ac\n+    reg_cache.get_u32(rtmp2, k, rmask32);\n+    __ addw(rtmp1, rtmp1, rtmp2);\n+    __ li(rtmp2, t);\n+    __ addw(rtmp1, rtmp1, rtmp2);\n+\n+    \/\/ a += rtmp1 + x + ac\n+    __ addw(a, a, rtmp1);\n+\n+    \/\/ a = Integer.rotateLeft(a, s) + b;\n+    __ rolw_imm(a, a, s, rtmp1);\n+    __ addw(a, a, b);\n+  }\n+\n+  \/\/ a += ((b & c) | ((~b) & d)) + x + ac;\n+  \/\/ a = Integer.rotateLeft(a, s) + b;\n+  void md5_FF(BufRegCache& reg_cache,\n+              Register a, Register b, Register c, Register d,\n+              int k, int s, int t,\n+              Register rtmp1, Register rtmp2, Register rmask32) {\n+    \/\/ rtmp1 = b & c\n+    __ andr(rtmp1, b, c);\n+\n+    \/\/ rtmp2 = (~b) & d\n+    __ notr(rtmp2, b);\n+    __ andr(rtmp2, rtmp2, d);\n+\n+    \/\/ rtmp1 = (b & c) | ((~b) & d)\n+    __ orr(rtmp1, rtmp1, rtmp2);\n+\n+    m5_FF_GG_HH_II_epilogue(reg_cache, a, b, c, d, k, s, t,\n+                            rtmp1, rtmp2, rmask32);\n+  }\n+\n+  \/\/ a += ((b & d) | (c & (~d))) + x + ac;\n+  \/\/ a = Integer.rotateLeft(a, s) + b;\n+  void md5_GG(BufRegCache& reg_cache,\n+              Register a, Register b, Register c, Register d,\n+              int k, int s, int t,\n+              Register rtmp1, Register rtmp2, Register rmask32) {\n+    \/\/ rtmp1 = b & d\n+    __ andr(rtmp1, b, d);\n+\n+    \/\/ rtmp2 = (c & (~d))\n+    __ notr(rtmp2, d);\n+    __ andr(rtmp2, rtmp2, c);\n+\n+    \/\/ rtmp1 = (b & d) | (c & (~d))\n+    __ orr(rtmp1, rtmp1, rtmp2);\n+\n+    m5_FF_GG_HH_II_epilogue(reg_cache, a, b, c, d, k, s, t,\n+                            rtmp1, rtmp2, rmask32);\n+  }\n+\n+  \/\/ a += ((b ^ c) ^ d) + x + ac;\n+  \/\/ a = Integer.rotateLeft(a, s) + b;\n+  void md5_HH(BufRegCache& reg_cache,\n+              Register a, Register b, Register c, Register d,\n+              int k, int s, int t,\n+              Register rtmp1, Register rtmp2, Register rmask32) {\n+    \/\/ rtmp1 = (b ^ c) ^ d\n+    __ xorr(rtmp1, b, c);\n+    __ xorr(rtmp1, rtmp1, d);\n+\n+    m5_FF_GG_HH_II_epilogue(reg_cache, a, b, c, d, k, s, t,\n+                            rtmp1, rtmp2, rmask32);\n+  }\n+\n+  \/\/ a += (c ^ (b | (~d))) + x + ac;\n+  \/\/ a = Integer.rotateLeft(a, s) + b;\n+  void md5_II(BufRegCache& reg_cache,\n+              Register a, Register b, Register c, Register d,\n+              int k, int s, int t,\n+              Register rtmp1, Register rtmp2, Register rmask32) {\n+    \/\/ rtmp1 = c ^ (b | (~d))\n+    __ notr(rtmp2, d);\n+    __ orr(rtmp1, b, rtmp2);\n+    __ xorr(rtmp1, c, rtmp1);\n+\n+    m5_FF_GG_HH_II_epilogue(reg_cache, a, b, c, d, k, s, t,\n+                            rtmp1, rtmp2, rmask32);\n+  }\n+\n+  \/\/ Arguments:\n+  \/\/\n+  \/\/ Inputs:\n+  \/\/   c_rarg0   - byte[]  source+offset\n+  \/\/   c_rarg1   - int[]   SHA.state\n+  \/\/   c_rarg2   - int     offset  (multi_block == True)\n+  \/\/   c_rarg3   - int     limit   (multi_block == True)\n+  \/\/\n+  \/\/ Registers:\n+  \/\/    x0   zero  (zero)\n+  \/\/    x1     ra  (return address)\n+  \/\/    x2     sp  (stack pointer)\n+  \/\/    x3     gp  (global pointer)\n+  \/\/    x4     tp  (thread pointer)\n+  \/\/    x5     t0  state0\n+  \/\/    x6     t1  state1\n+  \/\/    x7     t2  state2\n+  \/\/    x8  f0\/s0  (frame pointer)\n+  \/\/    x9     s1  state3  [saved-reg]\n+  \/\/   x10     a0  rtmp1 \/ c_rarg0\n+  \/\/   x11     a1  rtmp2 \/ c_rarg1\n+  \/\/   x12     a2  a     \/ c_rarg2\n+  \/\/   x13     a3  b     \/ c_rarg3\n+  \/\/   x14     a4  c\n+  \/\/   x15     a5  d\n+  \/\/   x16     a6  buf\n+  \/\/   x17     a7  state\n+  \/\/   x18     s2  ofs     [saved-reg]  (multi_block == True)\n+  \/\/   x19     s3  limit   [saved-reg]  (multi_block == True)\n+  \/\/   x20     s4\n+  \/\/   x21     s5\n+  \/\/   x22     s6  mask32  [saved-reg]\n+  \/\/   x23     s7\n+  \/\/   x24     s8  buf0    [saved-reg]\n+  \/\/   x25     s9  buf1    [saved-reg]\n+  \/\/   x26    s10  buf2    [saved-reg]\n+  \/\/   x27    s11  buf3    [saved-reg]\n+  \/\/   x28     t3  buf4\n+  \/\/   x29     t4  buf5\n+  \/\/   x30     t5  buf6\n+  \/\/   x31     t6  buf7\n+  address generate_md5_implCompress(bool multi_block, const char *name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", name);\n+    address start = __ pc();\n+\n+    \/\/ rotation constants\n+    const int S11 = 7;\n+    const int S12 = 12;\n+    const int S13 = 17;\n+    const int S14 = 22;\n+    const int S21 = 5;\n+    const int S22 = 9;\n+    const int S23 = 14;\n+    const int S24 = 20;\n+    const int S31 = 4;\n+    const int S32 = 11;\n+    const int S33 = 16;\n+    const int S34 = 23;\n+    const int S41 = 6;\n+    const int S42 = 10;\n+    const int S43 = 15;\n+    const int S44 = 21;\n+\n+    Register buf_arg   = c_rarg0; \/\/ a0\n+    Register state_arg = c_rarg1; \/\/ a1\n+    Register ofs_arg   = c_rarg2; \/\/ a2\n+    Register limit_arg = c_rarg3; \/\/ a3\n+\n+    \/\/ we'll copy the args to these registers to free up a0-a3\n+    \/\/ to use for other values manipulated by instructions\n+    \/\/ that can be compressed\n+    Register buf       = x16; \/\/ a6\n+    Register state     = x17; \/\/ a7\n+    Register ofs       = x18; \/\/ s2\n+    Register limit     = x19; \/\/ s3\n+\n+    \/\/ using x12->15 to allow compressed instructions\n+    Register a         = x12; \/\/ a2\n+    Register b         = x13; \/\/ a3\n+    Register c         = x14; \/\/ a4\n+    Register d         = x15; \/\/ a5\n+\n+    Register state0    =  x5; \/\/ t0\n+    Register state1    =  x6; \/\/ t1\n+    Register state2    =  x7; \/\/ t2\n+    Register state3    =  x9; \/\/ s1\n+\n+    \/\/ using x9->x11 to allow compressed instructions\n+    Register rtmp1     = x10; \/\/ a0\n+    Register rtmp2     = x11; \/\/ a1\n+\n+    const int64_t MASK_32 = 0xffffffff;\n+    Register rmask32   = x22; \/\/ s6\n+\n+    RegSet reg_cache_saved_regs = RegSet::of(x24, x25, x26, x27); \/\/ s8, s9, s10, s11\n+    RegSet reg_cache_regs;\n+    reg_cache_regs += reg_cache_saved_regs;\n+    reg_cache_regs += RegSet::of(x28, x29, x30, x31); \/\/ t3, t4, t5, t6\n+    BufRegCache reg_cache(_masm, reg_cache_regs);\n+\n+    RegSet saved_regs;\n+    if (multi_block) {\n+      saved_regs += RegSet::of(ofs, limit);\n+    }\n+    saved_regs += RegSet::of(state3, rmask32);\n+    saved_regs += reg_cache_saved_regs;\n+\n+    __ push_reg(saved_regs, sp);\n+\n+    __ mv(buf, buf_arg);\n+    __ mv(state, state_arg);\n+    if (multi_block) {\n+      __ mv(ofs, ofs_arg);\n+      __ mv(limit, limit_arg);\n+    }\n+    __ li(rmask32, MASK_32);\n+\n+    \/\/ to minimize the number of memory operations:\n+    \/\/ read the 4 state 4-byte values in pairs, with a single ld,\n+    \/\/ and split them into 2 registers\n+    __ ld(state0, Address(state));\n+    __ srli(state1, state0, 32);\n+    __ andr(state0, state0, rmask32);\n+    __ ld(state2, Address(state, 8));\n+    __ srli(state3, state2, 32);\n+    __ andr(state2, state2, rmask32);\n+\n+    Label md5_loop;\n+    __ BIND(md5_loop);\n+\n+    reg_cache.gen_loads(buf);\n+\n+    __ mv(a, state0);\n+    __ mv(b, state1);\n+    __ mv(c, state2);\n+    __ mv(d, state3);\n+\n+    \/\/ Round 1\n+    md5_FF(reg_cache, a, b, c, d,  0, S11, 0xd76aa478, rtmp1, rtmp2, rmask32);\n+    md5_FF(reg_cache, d, a, b, c,  1, S12, 0xe8c7b756, rtmp1, rtmp2, rmask32);\n+    md5_FF(reg_cache, c, d, a, b,  2, S13, 0x242070db, rtmp1, rtmp2, rmask32);\n+    md5_FF(reg_cache, b, c, d, a,  3, S14, 0xc1bdceee, rtmp1, rtmp2, rmask32);\n+    md5_FF(reg_cache, a, b, c, d,  4, S11, 0xf57c0faf, rtmp1, rtmp2, rmask32);\n+    md5_FF(reg_cache, d, a, b, c,  5, S12, 0x4787c62a, rtmp1, rtmp2, rmask32);\n+    md5_FF(reg_cache, c, d, a, b,  6, S13, 0xa8304613, rtmp1, rtmp2, rmask32);\n+    md5_FF(reg_cache, b, c, d, a,  7, S14, 0xfd469501, rtmp1, rtmp2, rmask32);\n+    md5_FF(reg_cache, a, b, c, d,  8, S11, 0x698098d8, rtmp1, rtmp2, rmask32);\n+    md5_FF(reg_cache, d, a, b, c,  9, S12, 0x8b44f7af, rtmp1, rtmp2, rmask32);\n+    md5_FF(reg_cache, c, d, a, b, 10, S13, 0xffff5bb1, rtmp1, rtmp2, rmask32);\n+    md5_FF(reg_cache, b, c, d, a, 11, S14, 0x895cd7be, rtmp1, rtmp2, rmask32);\n+    md5_FF(reg_cache, a, b, c, d, 12, S11, 0x6b901122, rtmp1, rtmp2, rmask32);\n+    md5_FF(reg_cache, d, a, b, c, 13, S12, 0xfd987193, rtmp1, rtmp2, rmask32);\n+    md5_FF(reg_cache, c, d, a, b, 14, S13, 0xa679438e, rtmp1, rtmp2, rmask32);\n+    md5_FF(reg_cache, b, c, d, a, 15, S14, 0x49b40821, rtmp1, rtmp2, rmask32);\n+\n+    \/\/ Round 2\n+    md5_GG(reg_cache, a, b, c, d,  1, S21, 0xf61e2562, rtmp1, rtmp2, rmask32);\n+    md5_GG(reg_cache, d, a, b, c,  6, S22, 0xc040b340, rtmp1, rtmp2, rmask32);\n+    md5_GG(reg_cache, c, d, a, b, 11, S23, 0x265e5a51, rtmp1, rtmp2, rmask32);\n+    md5_GG(reg_cache, b, c, d, a,  0, S24, 0xe9b6c7aa, rtmp1, rtmp2, rmask32);\n+    md5_GG(reg_cache, a, b, c, d,  5, S21, 0xd62f105d, rtmp1, rtmp2, rmask32);\n+    md5_GG(reg_cache, d, a, b, c, 10, S22, 0x02441453, rtmp1, rtmp2, rmask32);\n+    md5_GG(reg_cache, c, d, a, b, 15, S23, 0xd8a1e681, rtmp1, rtmp2, rmask32);\n+    md5_GG(reg_cache, b, c, d, a,  4, S24, 0xe7d3fbc8, rtmp1, rtmp2, rmask32);\n+    md5_GG(reg_cache, a, b, c, d,  9, S21, 0x21e1cde6, rtmp1, rtmp2, rmask32);\n+    md5_GG(reg_cache, d, a, b, c, 14, S22, 0xc33707d6, rtmp1, rtmp2, rmask32);\n+    md5_GG(reg_cache, c, d, a, b,  3, S23, 0xf4d50d87, rtmp1, rtmp2, rmask32);\n+    md5_GG(reg_cache, b, c, d, a,  8, S24, 0x455a14ed, rtmp1, rtmp2, rmask32);\n+    md5_GG(reg_cache, a, b, c, d, 13, S21, 0xa9e3e905, rtmp1, rtmp2, rmask32);\n+    md5_GG(reg_cache, d, a, b, c,  2, S22, 0xfcefa3f8, rtmp1, rtmp2, rmask32);\n+    md5_GG(reg_cache, c, d, a, b,  7, S23, 0x676f02d9, rtmp1, rtmp2, rmask32);\n+    md5_GG(reg_cache, b, c, d, a, 12, S24, 0x8d2a4c8a, rtmp1, rtmp2, rmask32);\n+\n+    \/\/ Round 3\n+    md5_HH(reg_cache, a, b, c, d,  5, S31, 0xfffa3942, rtmp1, rtmp2, rmask32);\n+    md5_HH(reg_cache, d, a, b, c,  8, S32, 0x8771f681, rtmp1, rtmp2, rmask32);\n+    md5_HH(reg_cache, c, d, a, b, 11, S33, 0x6d9d6122, rtmp1, rtmp2, rmask32);\n+    md5_HH(reg_cache, b, c, d, a, 14, S34, 0xfde5380c, rtmp1, rtmp2, rmask32);\n+    md5_HH(reg_cache, a, b, c, d,  1, S31, 0xa4beea44, rtmp1, rtmp2, rmask32);\n+    md5_HH(reg_cache, d, a, b, c,  4, S32, 0x4bdecfa9, rtmp1, rtmp2, rmask32);\n+    md5_HH(reg_cache, c, d, a, b,  7, S33, 0xf6bb4b60, rtmp1, rtmp2, rmask32);\n+    md5_HH(reg_cache, b, c, d, a, 10, S34, 0xbebfbc70, rtmp1, rtmp2, rmask32);\n+    md5_HH(reg_cache, a, b, c, d, 13, S31, 0x289b7ec6, rtmp1, rtmp2, rmask32);\n+    md5_HH(reg_cache, d, a, b, c,  0, S32, 0xeaa127fa, rtmp1, rtmp2, rmask32);\n+    md5_HH(reg_cache, c, d, a, b,  3, S33, 0xd4ef3085, rtmp1, rtmp2, rmask32);\n+    md5_HH(reg_cache, b, c, d, a,  6, S34, 0x04881d05, rtmp1, rtmp2, rmask32);\n+    md5_HH(reg_cache, a, b, c, d,  9, S31, 0xd9d4d039, rtmp1, rtmp2, rmask32);\n+    md5_HH(reg_cache, d, a, b, c, 12, S32, 0xe6db99e5, rtmp1, rtmp2, rmask32);\n+    md5_HH(reg_cache, c, d, a, b, 15, S33, 0x1fa27cf8, rtmp1, rtmp2, rmask32);\n+    md5_HH(reg_cache, b, c, d, a,  2, S34, 0xc4ac5665, rtmp1, rtmp2, rmask32);\n+\n+    \/\/ Round 4\n+    md5_II(reg_cache, a, b, c, d,  0, S41, 0xf4292244, rtmp1, rtmp2, rmask32);\n+    md5_II(reg_cache, d, a, b, c,  7, S42, 0x432aff97, rtmp1, rtmp2, rmask32);\n+    md5_II(reg_cache, c, d, a, b, 14, S43, 0xab9423a7, rtmp1, rtmp2, rmask32);\n+    md5_II(reg_cache, b, c, d, a,  5, S44, 0xfc93a039, rtmp1, rtmp2, rmask32);\n+    md5_II(reg_cache, a, b, c, d, 12, S41, 0x655b59c3, rtmp1, rtmp2, rmask32);\n+    md5_II(reg_cache, d, a, b, c,  3, S42, 0x8f0ccc92, rtmp1, rtmp2, rmask32);\n+    md5_II(reg_cache, c, d, a, b, 10, S43, 0xffeff47d, rtmp1, rtmp2, rmask32);\n+    md5_II(reg_cache, b, c, d, a,  1, S44, 0x85845dd1, rtmp1, rtmp2, rmask32);\n+    md5_II(reg_cache, a, b, c, d,  8, S41, 0x6fa87e4f, rtmp1, rtmp2, rmask32);\n+    md5_II(reg_cache, d, a, b, c, 15, S42, 0xfe2ce6e0, rtmp1, rtmp2, rmask32);\n+    md5_II(reg_cache, c, d, a, b,  6, S43, 0xa3014314, rtmp1, rtmp2, rmask32);\n+    md5_II(reg_cache, b, c, d, a, 13, S44, 0x4e0811a1, rtmp1, rtmp2, rmask32);\n+    md5_II(reg_cache, a, b, c, d,  4, S41, 0xf7537e82, rtmp1, rtmp2, rmask32);\n+    md5_II(reg_cache, d, a, b, c, 11, S42, 0xbd3af235, rtmp1, rtmp2, rmask32);\n+    md5_II(reg_cache, c, d, a, b,  2, S43, 0x2ad7d2bb, rtmp1, rtmp2, rmask32);\n+    md5_II(reg_cache, b, c, d, a,  9, S44, 0xeb86d391, rtmp1, rtmp2, rmask32);\n+\n+    __ addw(state0, state0, a);\n+    __ addw(state1, state1, b);\n+    __ addw(state2, state2, c);\n+    __ addw(state3, state3, d);\n+\n+    if (multi_block) {\n+      __ addi(buf, buf, 64);\n+      __ addi(ofs, ofs, 64);\n+      \/\/ if (ofs <= limit) goto m5_loop\n+      __ bge(limit, ofs, md5_loop);\n+      __ mv(c_rarg0, ofs); \/\/ return ofs\n+    }\n+\n+    \/\/ to minimize the number of memory operations:\n+    \/\/ write back the 4 state 4-byte values in pairs, with a single sd\n+    __ andr(state0, state0, rmask32);\n+    __ slli(state1, state1, 32);\n+    __ orr(state0, state0, state1);\n+    __ sd(state0, Address(state));\n+    __ andr(state2, state2, rmask32);\n+    __ slli(state3, state3, 32);\n+    __ orr(state2, state2, state3);\n+    __ sd(state2, Address(state, 8));\n+\n+    __ pop_reg(saved_regs, sp);\n+    __ ret();\n+\n+    return (address) start;\n+  }\n+\n@@ -3885,0 +4252,5 @@\n+    if (UseMD5Intrinsics) {\n+      StubRoutines::_md5_implCompress   = generate_md5_implCompress(false, \"md5_implCompress\");\n+      StubRoutines::_md5_implCompressMB = generate_md5_implCompress(true,  \"md5_implCompressMB\");\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":372,"deletions":0,"binary":false,"changes":372,"status":"modified"},{"patch":"@@ -39,2 +39,2 @@\n-  code_size1 = 19000,          \/\/ simply increase if too small (assembler will crash if too small)\n-  code_size2 = 28000           \/\/ simply increase if too small (assembler will crash if too small)\n+  code_size1 = 20000,          \/\/ simply increase if too small (assembler will crash if too small)\n+  code_size2 = 30000           \/\/ simply increase if too small (assembler will crash if too small)\n","filename":"src\/hotspot\/cpu\/riscv\/stubRoutines_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -114,3 +114,2 @@\n-  if (UseMD5Intrinsics) {\n-    warning(\"MD5 intrinsics are not available on this CPU.\");\n-    FLAG_SET_DEFAULT(UseMD5Intrinsics, false);\n+  if (FLAG_IS_DEFAULT(UseMD5Intrinsics)) {\n+    FLAG_SET_DEFAULT(UseMD5Intrinsics, true);\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}