{"files":[{"patch":"@@ -24,0 +24,1 @@\n+import static java.lang.Character.isDigit;\n@@ -43,0 +44,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -63,1 +65,2 @@\n- * VMs output to the first VM, it then exits and hopefully closes its log file.\n+ * VMs output to the first VM. The second VM then exits and hopefully closes\n+ * its log file.\n@@ -65,4 +68,5 @@\n- * The third VM waits for the second to exit and close its log file. After that,\n- * the third VM tries to rename the log file of the second VM. If it succeeds in\n- * doing so it means that the third VM did not inherit the open log file\n- * (windows can not rename opened files easily)\n+ * The third VM waits for the second to exit and close its log file.\n+ * On Windows, the third VM tries to rename the log file of the second VM.\n+ * If it succeeds in doing so it means that the third VM did not inherit\n+ * the open log file (windows cannot rename opened files easily).\n+ * On unix like systems, the third VM uses \"lsof\" for verification.\n@@ -70,4 +74,3 @@\n- * The third VM communicates the success to rename the file by printing \"CLOSED\n- * FD\". The first VM checks that the string was printed by the third VM.\n- *\n- * On unix like systems \"lsof\" is used.\n+ * The third VM communicates success by printing \"RETAINS FD\". The first VM\n+ * waits for the third VM to exit and checks that the string was printed by\n+ * the third VM.\n@@ -83,0 +86,134 @@\n+    public static final String LSOF_PID_PREFIX = \" VM lsof pid=\";\n+    public static final String SECOND_VM_PID_PREFIX = \"Second VM pid=\";\n+    public static final String THIRD_VM_PID_PREFIX = \"Third VM pid=\";\n+    public static final String THIRD_VM_WAITING_PREFIX = \"Third VM waiting for second VM pid=\";\n+\n+    public static float timeoutFactor = Float.parseFloat(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n+    public static long subProcessTimeout = (long)(15L * timeoutFactor);\n+\n+    \/\/ Extract a pid from the specified String at the specified start offset.\n+    private static long extractPidFromStringOffset(String str, int start) {\n+        int end;\n+        for (end = start; end < str.length(); end++) {\n+            if (!isDigit(str.charAt(end))) {\n+                break;\n+            }\n+        }\n+        if (start == end) {  \/\/ no digits at all\n+            return -1;\n+        }\n+        return parseLong(str.substring(start, end));\n+    }\n+\n+    \/\/ Wait for the sub-process pids identified in commFile to finish executing.\n+    \/\/ Returns true if RETAINS_FD was found in the commFile and false otherwise.\n+    private static boolean waitForSubPids(File commFile) throws Exception {\n+        String out = \"\";\n+        int sleepCnt = 0;\n+        long secondVMPID = -1;\n+        long secondVMlsofPID = -1;\n+        long thirdVMPID = -1;\n+        long thirdVMlsofPID = -1;\n+        \/\/ Only have to gather info until the doneWithPattern shows up in the output:\n+        String doneWithPattern;\n+        if (isWindows()) {\n+            doneWithPattern = THIRD_VM_PID_PREFIX;\n+        } else {\n+            doneWithPattern = \"Third\" + LSOF_PID_PREFIX;\n+        }\n+        do {\n+            out = new String(readAllBytes(commFile.toPath()));\n+            if (secondVMPID == -1) {\n+                int ind = out.indexOf(SECOND_VM_PID_PREFIX);\n+                if (ind != -1) {\n+                    int startPid = ind + SECOND_VM_PID_PREFIX.length();\n+                    secondVMPID = extractPidFromStringOffset(out, startPid);\n+                    System.out.println(\"secondVMPID=\" + secondVMPID);\n+                }\n+            }\n+            if (!isWindows() && secondVMlsofPID == -1) {\n+                String prefix = \"Second\" + LSOF_PID_PREFIX;\n+                int ind = out.indexOf(prefix);\n+                if (ind != -1) {\n+                    int startPid = ind + prefix.length();\n+                    secondVMlsofPID = extractPidFromStringOffset(out, startPid);\n+                    System.out.println(\"secondVMlsofPID=\" + secondVMlsofPID);\n+                }\n+            }\n+            if (thirdVMPID == -1) {\n+                int ind = out.indexOf(THIRD_VM_PID_PREFIX);\n+                if (ind != -1) {\n+                    int startPid = ind + THIRD_VM_PID_PREFIX.length();\n+                    thirdVMPID = extractPidFromStringOffset(out, startPid);\n+                    System.out.println(\"thirdVMPID=\" + thirdVMPID);\n+                }\n+            }\n+            if (!isWindows() && thirdVMlsofPID == -1) {\n+                String prefix = \"Third\" + LSOF_PID_PREFIX;\n+                int ind = out.indexOf(prefix);\n+                if (ind != -1) {\n+                    int startPid = ind + prefix.length();\n+                    thirdVMlsofPID = extractPidFromStringOffset(out, startPid);\n+                    System.out.println(\"thirdVMlsofPID=\" + thirdVMlsofPID);\n+                }\n+            }\n+            Thread.sleep(100);\n+            sleepCnt++;\n+        } while (!out.contains(doneWithPattern) && !out.contains(EXIT));\n+\n+        System.out.println(\"Called Thread.sleep(100) \" + sleepCnt + \" times.\");\n+\n+        long subPids[] = new long[4];       \/\/ At most 4 pids to check.\n+        String subNames[] = new String[4];  \/\/ At most 4 names for those pids.\n+        int ind = 0;\n+        if (!isWindows() && secondVMlsofPID != -1) {\n+            \/\/ The second VM's lsof cmd should be the first non-windows sub-process to finish:\n+            subPids[ind] = secondVMlsofPID;\n+            subNames[ind] = \"second VM lsof\";\n+            ind++;\n+        }\n+        \/\/ The second VM should the second non-windows or first windows sub-process to finish:\n+        subPids[ind] = secondVMPID;\n+        subNames[ind] = \"second VM\";\n+        ind++;\n+        if (!isWindows() && thirdVMlsofPID != -1) {\n+            \/\/ The third VM's lsof cmd should be the third non-windows sub-process to finish:\n+            subPids[ind] = thirdVMlsofPID;\n+            subNames[ind] = \"third VM lsof\";\n+            ind++;\n+        }\n+        \/\/ The third VM should the last sub-process to finish:\n+        subPids[ind] = thirdVMPID;\n+        subNames[ind] = \"third VM\";\n+        ind++;\n+        if (isWindows()) {\n+            \/\/ No lsof pids on windows so we use fewer array slots.\n+            \/\/ Make sure they are marked as not used.\n+            for (; ind < subPids.length; ind++) {\n+                subPids[ind] = -1;\n+            }\n+        }\n+\n+        try {\n+            for (ind = 0; ind < subPids.length; ind++) {\n+                if (subPids[ind] == -1) {\n+                    continue;\n+                }\n+                System.out.print(\"subs[\" + ind + \"]={pid=\" + subPids[ind] + \", name=\" + subNames[ind] + \"}\");\n+                ProcessHandle.of(subPids[ind]).ifPresent(handle -> handle.onExit().orTimeout(subProcessTimeout, TimeUnit.SECONDS).join());\n+                System.out.println(\" finished.\");\n+            }\n+        } catch (Exception e) {\n+            \/\/ Terminate the \"subs\" line from above:\n+            System.out.println(\" Exception was thrown while trying to join() subPids: \" + e.toString());\n+            throw e;\n+        } finally {\n+            \/\/ Reread to get everything in the commFile:\n+            out = new String(readAllBytes(commFile.toPath()));\n+            System.out.println(\"<BEGIN commFile contents>\");\n+            System.out.println(out);\n+            System.out.println(\"<END commFile contents>\");\n+        }\n+\n+        return out.contains(RETAINS_FD);\n+    }\n@@ -86,0 +223,2 @@\n+        System.out.println(\"subProcessTimeout=\" + subProcessTimeout + \" seconds.\");\n+        System.out.println(\"First VM starts.\");\n@@ -102,10 +241,2 @@\n-        String out = \"\";\n-        do {\n-            out = new String(readAllBytes(commFile.toPath()));\n-            Thread.sleep(100);\n-            System.out.println(\"SLEEP 100 millis\");\n-        } while (!out.contains(EXIT));\n-\n-        System.out.println(out);\n-        if (out.contains(RETAINS_FD)) {\n-            System.out.println(\"Log file was not inherited by third VM\");\n+        if (waitForSubPids(commFile)) {\n+            System.out.println(\"Log file was not inherited by third VM.\");\n@@ -113,1 +244,1 @@\n-            throw new RuntimeException(\"could not match: \" + RETAINS_FD);\n+            throw new RuntimeException(\"Log file was leaked to the third VM.\");\n@@ -115,0 +246,1 @@\n+        System.out.println(\"First VM ends.\");\n@@ -120,0 +252,1 @@\n+            System.out.println(SECOND_VM_PID_PREFIX + ProcessHandle.current().pid());\n@@ -129,1 +262,4 @@\n-                System.out.println(\"(Second VM) Open file descriptors:\\n\" + outputContainingFilenames().stream().collect(joining(\"\\n\")));\n+                System.out.println(\"(Second VM) Open file descriptors:\\n\" + outputContainingFilenames(\"Second\").stream().collect(joining(\"\\n\")));\n+            }\n+            if (false) {  \/\/ Enable to simulate a timeout in the second VM.\n+                Thread.sleep(300 * 1000);\n@@ -131,0 +267,1 @@\n+            System.out.println(\"Second VM ends.\");\n@@ -137,0 +274,1 @@\n+            System.out.println(THIRD_VM_PID_PREFIX + ProcessHandle.current().pid());\n@@ -142,0 +280,3 @@\n+                System.out.println(THIRD_VM_WAITING_PREFIX + parentPid);\n+                ProcessHandle.of(parentPid).ifPresent(handle -> handle.onExit().orTimeout(subProcessTimeout, TimeUnit.SECONDS).join());\n+\n@@ -143,1 +284,1 @@\n-                    windows(logFile, parentPid);\n+                    windows(logFile);\n@@ -145,1 +286,1 @@\n-                    Collection<String> output = outputContainingFilenames();\n+                    Collection<String> output = outputContainingFilenames(\"Third\");\n@@ -149,0 +290,3 @@\n+                if (false) {  \/\/ Enable to simulate a timeout in the third VM.\n+                    Thread.sleep(300 * 1000);\n+                }\n@@ -150,1 +294,2 @@\n-                System.out.println(e.toString());\n+                System.out.println(\"Exception was thrown: \" + e.toString());\n+                throw e;\n@@ -153,0 +298,1 @@\n+                System.out.println(\"Third VM ends.\");\n@@ -168,1 +314,1 @@\n-    static Stream<String> run(String... args){\n+    static Stream<String> runLsof(String whichVM, String... args){\n@@ -170,1 +316,3 @@\n-            return new BufferedReader(new InputStreamReader(new ProcessBuilder(args).start().getInputStream())).lines();\n+            Process lsof = new ProcessBuilder(args).start();\n+            System.out.println(whichVM + LSOF_PID_PREFIX + lsof.pid());\n+            return new BufferedReader(new InputStreamReader(lsof.getInputStream())).lines();\n@@ -189,1 +337,1 @@\n-    static Collection<String> outputContainingFilenames() {\n+    static Collection<String> outputContainingFilenames(String whichVM) {\n@@ -194,1 +342,1 @@\n-        return run(command[0], \"-a\", \"+d\", USER_DIR, command[1], \"\" + pid).collect(toList());\n+        return runLsof(whichVM, command[0], \"-a\", \"+d\", USER_DIR, command[1], \"\" + pid).collect(toList());\n@@ -211,3 +359,1 @@\n-    static void windows(File f, long parentPid) throws InterruptedException {\n-        System.out.println(\"waiting for pid: \" + parentPid);\n-        ProcessHandle.of(parentPid).ifPresent(handle -> handle.onExit().join());\n+    static void windows(File f) throws InterruptedException {\n","filename":"test\/hotspot\/jtreg\/runtime\/8176717\/TestInheritFD.java","additions":177,"deletions":31,"binary":false,"changes":208,"status":"modified"}]}