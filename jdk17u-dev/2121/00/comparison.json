{"files":[{"patch":"@@ -96,3 +96,1 @@\n-        URI uri = req.uri();\n-        InetSocketAddress proxy = req.proxy();\n-        String key = Http2Connection.keyFor(uri, proxy);\n+        String key = Http2Connection.keyFor(req);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2ClientImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -405,1 +405,1 @@\n-             keyFor(request.uri(), request.proxy()));\n+             keyFor(request));\n@@ -537,6 +537,5 @@\n-    static String keyFor(URI uri, InetSocketAddress proxy) {\n-        boolean isSecure = uri.getScheme().equalsIgnoreCase(\"https\");\n-\n-        String host = uri.getHost();\n-        int port = uri.getPort();\n-        return keyString(isSecure, proxy, host, port);\n+    static String keyFor(final HttpRequestImpl request) {\n+        final InetSocketAddress targetAddr = request.getAddress();\n+        final InetSocketAddress proxy = request.proxy();\n+        final boolean secure = request.secure();\n+        return keyString(secure, proxy, targetAddr.getHostString(), targetAddr.getPort());\n@@ -545,1 +544,0 @@\n-\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -230,0 +230,1 @@\n+        public abstract InetSocketAddress getRemoteAddress();\n@@ -287,0 +288,6 @@\n+\n+            @Override\n+            public InetSocketAddress getRemoteAddress() {\n+                return exchange.getRemoteAddress();\n+            }\n+\n@@ -342,0 +349,6 @@\n+\n+            @Override\n+            public InetSocketAddress getRemoteAddress() {\n+                return exchange.getRemoteAddress();\n+            }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpServerAdapters.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.test.lib.net.IPSupport;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @bug 8305906\n+ * @summary verify that the HttpClient pools and reuses a connection for HTTP\/2 requests\n+ * @library \/test\/lib server\/ ..\/\n+ * @build jdk.test.lib.net.SimpleSSLContext HttpServerAdapters\n+ *        jdk.test.lib.net.IPSupport\n+ * @modules java.net.http\/jdk.internal.net.http.common\n+ *          java.net.http\/jdk.internal.net.http.frame\n+ *          java.net.http\/jdk.internal.net.http.hpack\n+ *          java.logging\n+ *          java.base\/sun.net.www.http\n+ *          java.base\/sun.net.www\n+ *          java.base\/sun.net\n+ *\n+ * @run junit\/othervm ConnectionReuseTest\n+ * @run junit\/othervm -Djava.net.preferIPv6Addresses=true ConnectionReuseTest\n+ *\/\n+public class ConnectionReuseTest implements HttpServerAdapters {\n+\n+    private static SSLContext sslContext;\n+    private static HttpTestServer http2_Server; \/\/ h2 server over HTTP\n+    private static HttpTestServer https2_Server; \/\/ h2 server over HTTPS\n+\n+    @BeforeAll\n+    public static void beforeAll() throws Exception {\n+        if (IPSupport.preferIPv6Addresses()) {\n+            IPSupport.printPlatformSupport(System.err); \/\/ for debug purposes\n+            \/\/ this test is run with -Djava.net.preferIPv6Addresses=true, so skip (all) tests\n+            \/\/ if IPv6 isn't supported on this host\n+            Assumptions.assumeTrue(IPSupport.hasIPv6(), \"Skipping tests - IPv6 is not supported\");\n+        }\n+        sslContext = new SimpleSSLContext().get();\n+        assertNotNull(sslContext, \"Unexpected null sslContext\");\n+\n+        http2_Server = HttpTestServer.of(\n+                    new Http2TestServer(\"localhost\", false, 0));\n+        http2_Server.addHandler(new Handler(), \"\/\");\n+        http2_Server.start();\n+        System.out.println(\"Started HTTP v2 server at \" + http2_Server.serverAuthority());\n+\n+        https2_Server = HttpTestServer.of(\n+                    new Http2TestServer(\"localhost\", true, sslContext));\n+        https2_Server.addHandler(new Handler(), \"\/\");\n+        https2_Server.start();\n+        System.out.println(\"Started HTTPS v2 server at \" + https2_Server.serverAuthority());\n+    }\n+\n+    @AfterAll\n+    public static void afterAll() {\n+        if (https2_Server != null) {\n+            System.out.println(\"Stopping server \" + https2_Server);\n+            https2_Server.stop();\n+        }\n+        if (http2_Server != null) {\n+            System.out.println(\"Stopping server \" + http2_Server);\n+            http2_Server.stop();\n+        }\n+    }\n+\n+    private static Stream<Arguments> requestURIs() throws Exception {\n+        final List<Arguments> arguments = new ArrayList<>();\n+        \/\/ h2 over HTTPS\n+        arguments.add(Arguments.of(new URI(\"https:\/\/\" + https2_Server.serverAuthority() + \"\/\")));\n+        \/\/ h2 over HTTP\n+        arguments.add(Arguments.of(new URI(\"http:\/\/\" + http2_Server.serverAuthority() + \"\/\")));\n+        if (IPSupport.preferIPv6Addresses()) {\n+            if (https2_Server.getAddress().getAddress().isLoopbackAddress()) {\n+                \/\/ h2 over HTTPS, use the short form of the host, in the request URI\n+                arguments.add(Arguments.of(new URI(\"https:\/\/localhost:\" +\n+                        https2_Server.getAddress().getPort() + \"\/\")));\n+            }\n+            if (http2_Server.getAddress().getAddress().isLoopbackAddress()) {\n+                \/\/ h2 over HTTP, use the short form of the host, in the request URI\n+                arguments.add(Arguments.of(new URI(\"http:\/\/[::1]:\" +\n+                        http2_Server.getAddress().getPort() + \"\/\")));\n+            }\n+        }\n+        return arguments.stream();\n+    }\n+\n+    \/**\n+     * Uses a single instance of a HttpClient and issues multiple requests to {@code requestURI}\n+     * and expects that each of the request internally uses the same connection\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"requestURIs\")\n+    public void testConnReuse(final URI requestURI) throws Exception {\n+        final HttpClient.Builder builder = HttpClient.newBuilder()\n+                .proxy(NO_PROXY).sslContext(sslContext);\n+        final HttpRequest req = HttpRequest.newBuilder().uri(requestURI)\n+                .GET().version(HTTP_2).build();\n+        final HttpClient client = builder.build();\n+        String clientConnAddr = null;\n+        for (int i = 1; i <= 5; i++) {\n+            System.out.println(\"Issuing request(\" + i + \") \" + req);\n+            final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString());\n+            assertEquals(200, resp.statusCode(), \"unexpected response code\");\n+            final String respBody = resp.body();\n+            System.out.println(\"Server side handler responded to a request from \" + respBody);\n+            assertNotEquals(Handler.UNKNOWN_CLIENT_ADDR, respBody,\n+                    \"server handler couldn't determine client address in request\");\n+            if (i == 1) {\n+                \/\/ for the first request we just keep track of the client connection address\n+                \/\/ that got used for this request\n+                clientConnAddr = respBody;\n+            } else {\n+                \/\/ verify that the client connection used to issue the request is the same\n+                \/\/ as the previous request's client connection\n+                assertEquals(clientConnAddr, respBody, \"HttpClient unexpectedly used a\" +\n+                        \" different connection for request(\" + i + \")\");\n+            }\n+        }\n+    }\n+\n+    private static final class Handler implements HttpTestHandler {\n+\n+        private static final String UNKNOWN_CLIENT_ADDR = \"unknown\";\n+\n+        @Override\n+        public void handle(final HttpTestExchange t) throws IOException {\n+            final InetSocketAddress clientAddr = t.getRemoteAddress();\n+            System.out.println(\"Handling request \" + t.getRequestURI() + \" from \" + clientAddr);\n+            \/\/ we write out the client address into the response body\n+            final byte[] responseBody = clientAddr == null\n+                    ? UNKNOWN_CLIENT_ADDR.getBytes(StandardCharsets.UTF_8)\n+                    : clientAddr.toString().getBytes(StandardCharsets.UTF_8);\n+            t.sendResponseHeaders(200, responseBody.length);\n+            try (final OutputStream os = t.getResponseBody()) {\n+                os.write(responseBody);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/ConnectionReuseTest.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"}]}