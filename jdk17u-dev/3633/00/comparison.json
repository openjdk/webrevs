{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.System.Logger.Level;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Exchange.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.net.http.HttpClient;\n@@ -31,0 +30,1 @@\n+import java.net.http.HttpResponse.ResponseInfo;\n@@ -34,0 +34,1 @@\n+import jdk.internal.net.http.common.HttpBodySubscriberWrapper;\n@@ -69,1 +70,1 @@\n-    HttpClient client() {\n+    HttpClientImpl client() {\n@@ -184,0 +185,16 @@\n+    \/**\n+     * Creates and wraps an {@link HttpResponse.BodySubscriber} from a {@link\n+     * HttpResponse.BodyHandler} for the given {@link ResponseInfo}.\n+     * An {@code HttpBodySubscriberWrapper} wraps a response body subscriber and makes\n+     * sure its completed\/onError methods are called only once, and that its onSusbscribe\n+     * is called before onError. This is useful when errors occur asynchronously, and\n+     * most typically when the error occurs before the {@code BodySubscriber} has\n+     * subscribed.\n+     * @param handler  a body handler\n+     * @param response a response info\n+     * @return a new {@code HttpBodySubscriberWrapper} to handle the response\n+     *\/\n+    HttpBodySubscriberWrapper<T> createResponseSubscriber(HttpResponse.BodyHandler<T> handler, ResponseInfo response) {\n+        return new HttpBodySubscriberWrapper<>(handler.apply(response));\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ExchangeImpl.java","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -500,1 +500,2 @@\n-                      + \"\\t\\t queue.isEmpty: \" + queue.isEmpty(), ex);\n+                      + \"\\n\\t queue.isEmpty: \" + queue.isEmpty()\n+                      + \"\\n\\tstopRequested: \" + stopRequested, ex);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1AsyncReceiver.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.net.http.HttpClient;\n@@ -34,0 +33,1 @@\n+import java.net.http.HttpResponse.ResponseInfo;\n@@ -42,0 +42,1 @@\n+\n@@ -43,0 +44,1 @@\n+import jdk.internal.net.http.common.HttpBodySubscriberWrapper;\n@@ -50,1 +52,0 @@\n-import static jdk.internal.net.http.common.Utils.wrapWithExtraDetail;\n@@ -81,1 +82,1 @@\n-     * headers and body ( if any ). *\/\n+     * headers and body ( if any )). *\/\n@@ -89,2 +90,4 @@\n-    \/** The subscriber to the request's body published. Maybe null. *\/\n-    private volatile Http1BodySubscriber bodySubscriber;\n+    \/** The subscriber to the request's body published. May be null. *\/\n+    private volatile Http1RequestBodySubscriber bodySubscriber;\n+    \/** The subscriber to the response's body received. May be null. *\/\n+    private volatile BodySubscriber<T> responseSubscriber;\n@@ -120,1 +123,1 @@\n-    static abstract class Http1BodySubscriber implements Flow.Subscriber<ByteBuffer> {\n+    abstract static class Http1RequestBodySubscriber implements Flow.Subscriber<ByteBuffer> {\n@@ -125,1 +128,1 @@\n-        Http1BodySubscriber(Logger debug) {\n+        Http1RequestBodySubscriber(Logger debug) {\n@@ -162,2 +165,2 @@\n-        static Http1BodySubscriber completeSubscriber(Logger debug) {\n-            return new Http1BodySubscriber(debug) {\n+        static Http1RequestBodySubscriber completeSubscriber(Logger debug) {\n+            return new Http1RequestBodySubscriber(debug) {\n@@ -176,0 +179,28 @@\n+    \/**\n+     * The Http1AsyncReceiver ensures that all calls to\n+     * the subscriber, including onSubscribe, occur sequentially.\n+     * There could however be some race conditions that could happen\n+     * in case of unexpected errors thrown at unexpected places, which\n+     * may cause onError to be called multiple times.\n+     * The Http1BodySubscriber will ensure that the user subscriber\n+     * is actually completed only once - and only after it is\n+     * subscribed.\n+     * @param <U> The type of response.\n+     *\/\n+    static final class Http1ResponseBodySubscriber<U> extends HttpBodySubscriberWrapper<U> {\n+        final Http1Exchange<U> exchange;\n+        Http1ResponseBodySubscriber(BodySubscriber<U> userSubscriber, Http1Exchange<U> exchange) {\n+            super(userSubscriber);\n+            this.exchange = exchange;\n+        }\n+\n+        @Override\n+        protected void complete(Throwable t) {\n+            try {\n+                exchange.responseSubscriberCompleted(this);\n+            } finally {\n+                super.complete(t);\n+            }\n+        }\n+    }\n+\n@@ -220,0 +251,22 @@\n+    \/\/ The Http1ResponseBodySubscriber is registered with the HttpClient\n+    \/\/ to ensure that it gets completed if the SelectorManager aborts due\n+    \/\/ to unexpected exceptions.\n+    void registerResponseSubscriber(Http1ResponseBodySubscriber<T> subscriber) {\n+        Throwable failed = null;\n+        synchronized (lock) {\n+            failed = this.failed;\n+            if (failed == null) {\n+                this.responseSubscriber = subscriber;\n+            }\n+        }\n+        if (failed != null) {\n+            subscriber.onError(failed);\n+        } else {\n+            client.registerSubscriber(subscriber);\n+        }\n+    }\n+\n+    void responseSubscriberCompleted(HttpBodySubscriberWrapper<T> subscriber) {\n+        client.subscriberCompleted(subscriber);\n+    }\n+\n@@ -324,2 +377,2 @@\n-                bodySubscriber = Http1BodySubscriber.completeSubscriber(debug);\n-                appendToOutgoing(Http1BodySubscriber.COMPLETED);\n+                bodySubscriber = Http1RequestBodySubscriber.completeSubscriber(debug);\n+                appendToOutgoing(Http1RequestBodySubscriber.COMPLETED);\n@@ -329,1 +382,1 @@\n-                        .thenAccept((s) -> cancelIfFailed(s))\n+                        .thenAccept(this::cancelIfFailed)\n@@ -373,3 +426,3 @@\n-        BodySubscriber<T> bs = handler.apply(new ResponseInfoImpl(response.responseCode(),\n-                                                                  response.responseHeaders(),\n-                                                                  HTTP_1_1));\n+        var responseInfo = new ResponseInfoImpl(response.responseCode(),\n+                response.responseHeaders(), HTTP_1_1);\n+        BodySubscriber<T> bs = createResponseSubscriber(handler, responseInfo);\n@@ -382,0 +435,9 @@\n+    @Override\n+    Http1ResponseBodySubscriber<T> createResponseSubscriber(BodyHandler<T> handler, ResponseInfo response) {\n+        BodySubscriber<T> subscriber = handler.apply(response);\n+        Http1ResponseBodySubscriber<T> bs =\n+                new Http1ResponseBodySubscriber<T>(subscriber, this);\n+        registerResponseSubscriber(bs);\n+        return bs;\n+    }\n+\n@@ -442,1 +504,2 @@\n-        Throwable error;\n+        Throwable error = null;\n+        BodySubscriber<?> subscriber;\n@@ -444,0 +507,1 @@\n+            subscriber = responseSubscriber;\n@@ -476,0 +540,9 @@\n+\n+        \/\/ complete subscriber if needed\n+        if (subscriber != null && error != null) {\n+            var failure = error;\n+            if (client.isSelectorThread()) {\n+                executor.execute(() -> subscriber.onError(failure));\n+            } else subscriber.onError(failure);\n+        }\n+\n@@ -610,1 +683,1 @@\n-                if (dp.data == Http1BodySubscriber.COMPLETED) {\n+                if (dp.data == Http1RequestBodySubscriber.COMPLETED) {\n@@ -721,1 +794,1 @@\n-                        if (data == Http1BodySubscriber.COMPLETED) {\n+                        if (data == Http1RequestBodySubscriber.COMPLETED) {\n@@ -766,1 +839,2 @@\n-    HttpClient client() {\n+    @Override\n+    final HttpClientImpl client() {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Exchange.java","additions":94,"deletions":20,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-import jdk.internal.net.http.Http1Exchange.Http1BodySubscriber;\n+import jdk.internal.net.http.Http1Exchange.Http1RequestBodySubscriber;\n@@ -317,2 +317,2 @@\n-    Http1BodySubscriber continueRequest()  {\n-        Http1BodySubscriber subscriber;\n+    Http1RequestBodySubscriber continueRequest()  {\n+        Http1RequestBodySubscriber subscriber;\n@@ -332,1 +332,1 @@\n-    final class StreamSubscriber extends Http1BodySubscriber {\n+    final class StreamSubscriber extends Http1RequestBodySubscriber {\n@@ -395,1 +395,1 @@\n-    final class FixedContentSubscriber extends Http1BodySubscriber {\n+    final class FixedContentSubscriber extends Http1RequestBodySubscriber {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Request.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.net.http.HttpResponse.BodySubscriber;\n@@ -31,1 +32,0 @@\n-import java.util.List;\n@@ -33,1 +33,0 @@\n-import java.util.concurrent.CompletionStage;\n@@ -35,2 +34,0 @@\n-import java.util.concurrent.Flow;\n-import java.util.concurrent.atomic.AtomicBoolean;\n@@ -44,1 +41,0 @@\n-import jdk.internal.net.http.ResponseSubscribers.TrustedSubscriber;\n@@ -77,1 +73,1 @@\n-    static enum State {INITIAL, READING_HEADERS, READING_BODY, DONE}\n+    enum State {INITIAL, READING_HEADERS, READING_BODY, DONE}\n@@ -126,1 +122,1 @@\n-        public synchronized void acquire() {\n+        public synchronized boolean acquire() {\n@@ -135,0 +131,1 @@\n+                return true;\n@@ -140,0 +137,1 @@\n+                return false;\n@@ -280,113 +278,0 @@\n-    static final Flow.Subscription NOP = new Flow.Subscription() {\n-        @Override\n-        public void request(long n) { }\n-        public void cancel() { }\n-    };\n-\n-    \/**\n-     * The Http1AsyncReceiver ensures that all calls to\n-     * the subscriber, including onSubscribe, occur sequentially.\n-     * There could however be some race conditions that could happen\n-     * in case of unexpected errors thrown at unexpected places, which\n-     * may cause onError to be called multiple times.\n-     * The Http1BodySubscriber will ensure that the user subscriber\n-     * is actually completed only once - and only after it is\n-     * subscribed.\n-     * @param <U> The type of response.\n-     *\/\n-    final static class Http1BodySubscriber<U> implements TrustedSubscriber<U> {\n-        final HttpResponse.BodySubscriber<U> userSubscriber;\n-        final AtomicBoolean completed = new AtomicBoolean();\n-        volatile Throwable withError;\n-        volatile boolean subscribed;\n-        Http1BodySubscriber(HttpResponse.BodySubscriber<U> userSubscriber) {\n-            this.userSubscriber = userSubscriber;\n-        }\n-\n-        @Override\n-        public boolean needsExecutor() {\n-            return TrustedSubscriber.needsExecutor(userSubscriber);\n-        }\n-\n-        \/\/ propagate the error to the user subscriber, even if not\n-        \/\/ subscribed yet.\n-        private void propagateError(Throwable t) {\n-            assert t != null;\n-            try {\n-                \/\/ if unsubscribed at this point, it will not\n-                \/\/ get subscribed later - so do it now and\n-                \/\/ propagate the error\n-                if (subscribed == false) {\n-                    subscribed = true;\n-                    userSubscriber.onSubscribe(NOP);\n-                }\n-            } finally  {\n-                \/\/ if onError throws then there is nothing to do\n-                \/\/ here: let the caller deal with it by logging\n-                \/\/ and closing the connection.\n-                userSubscriber.onError(t);\n-            }\n-        }\n-\n-        \/\/ complete the subscriber, either normally or exceptionally\n-        \/\/ ensure that the subscriber is completed only once.\n-        private void complete(Throwable t) {\n-            if (completed.compareAndSet(false, true)) {\n-                t  = withError = Utils.getCompletionCause(t);\n-                if (t == null) {\n-                    assert subscribed;\n-                    try {\n-                        userSubscriber.onComplete();\n-                    } catch (Throwable x) {\n-                        \/\/ Simply propagate the error by calling\n-                        \/\/ onError on the user subscriber, and let the\n-                        \/\/ connection be reused since we should have received\n-                        \/\/ and parsed all the bytes when we reach here.\n-                        \/\/ If onError throws in turn, then we will simply\n-                        \/\/ let that new exception flow up to the caller\n-                        \/\/ and let it deal with it.\n-                        \/\/ (i.e: log and close the connection)\n-                        \/\/ Note that rethrowing here could introduce a\n-                        \/\/ race that might cause the next send() operation to\n-                        \/\/ fail as the connection has already been put back\n-                        \/\/ into the cache when we reach here.\n-                        propagateError(t = withError = Utils.getCompletionCause(x));\n-                    }\n-                } else {\n-                    propagateError(t);\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public CompletionStage<U> getBody() {\n-            return userSubscriber.getBody();\n-        }\n-\n-        @Override\n-        public void onSubscribe(Flow.Subscription subscription) {\n-            if (!subscribed) {\n-                subscribed = true;\n-                userSubscriber.onSubscribe(subscription);\n-            } else {\n-                \/\/ could be already subscribed and completed\n-                \/\/ if an unexpected error occurred before the actual\n-                \/\/ subscription - though that's not supposed\n-                \/\/ happen.\n-                assert completed.get();\n-            }\n-        }\n-        @Override\n-        public void onNext(List<ByteBuffer> item) {\n-            assert !completed.get();\n-            userSubscriber.onNext(item);\n-        }\n-        @Override\n-        public void onError(Throwable throwable) {\n-            complete(throwable);\n-        }\n-        @Override\n-        public void onComplete() {\n-            complete(null);\n-        }\n-    }\n@@ -401,1 +286,1 @@\n-                        + connection.getClass() + \"\/\" + connection );\n+                        + connection.getClass() + \"\/\" + connection);\n@@ -406,1 +291,2 @@\n-        final Http1BodySubscriber<U> subscriber = new Http1BodySubscriber<>(p);\n+        final BodySubscriber<U> subscriber = p;\n+\n@@ -423,0 +309,1 @@\n+            boolean acquired = false;\n@@ -436,1 +323,2 @@\n-                refCountTracker.acquire();\n+                acquired = refCountTracker.acquire();\n+                assert acquired == true;\n@@ -460,1 +348,1 @@\n-                CompletableFuture<?> trailingOp = bodyReaderCF.whenComplete((s,t) ->  {\n+                CompletableFuture<?> trailingOp = bodyReaderCF.whenComplete((s, t) -> {\n@@ -482,1 +370,1 @@\n-               if (debug.on()) debug.log(\"Failed reading body: \" + t);\n+                if (debug.on()) debug.log(\"Failed reading body: \" + t);\n@@ -487,0 +375,1 @@\n+                    if (acquired) refCountTracker.tryRelease();\n@@ -495,0 +384,1 @@\n+            subscriber.onError(t);\n@@ -755,3 +645,4 @@\n-            if (t instanceof EOFException && bodyParser != null &&\n-                    bodyParser instanceof UnknownLengthBodyParser) {\n-                ((UnknownLengthBodyParser)bodyParser).complete();\n+            BodyParser parser = bodyParser;\n+            if (t instanceof EOFException && parser != null &&\n+                    parser instanceof UnknownLengthBodyParser ulBodyParser) {\n+                ulBodyParser.complete();\n@@ -761,0 +652,1 @@\n+            parser.onError(t);\n@@ -827,0 +719,14 @@\n+            if (error != null) {\n+                \/\/ makes sure the parser gets the error\n+                BodyParser parser = this.parser;\n+                if (parser != null) {\n+                    if (debug.on()) {\n+                        debug.log(\"propagating error to parser: \" + error);\n+                    }\n+                    parser.onError(error);\n+                } else {\n+                    if (debug.on()) {\n+                        debug.log(\"no parser - error not propagated: \" + error);\n+                    }\n+                }\n+            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Response.java","additions":35,"deletions":129,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+    private volatile boolean stopping;\n@@ -166,0 +167,5 @@\n+            if (stopping) {\n+                if (debug.on()) debug.log(\"stopping - closing connection: %s\", c);\n+                close(c);\n+                return false;\n+            }\n@@ -210,0 +216,1 @@\n+        synchronized (this) {stopping = true;}\n@@ -213,2 +220,3 @@\n-        connections.values().forEach(this::close);\n-        connections.clear();\n+        do {\n+            connections.values().forEach(this::close);\n+        } while (!connections.isEmpty());\n@@ -218,0 +226,3 @@\n+        \/\/ close all streams\n+        try { h2c.closeAllStreams(); } catch (Throwable t) {}\n+        \/\/ send GOAWAY\n@@ -219,0 +230,1 @@\n+        \/\/ attempt graceful shutdown\n@@ -220,0 +232,2 @@\n+        \/\/ double check and close any new streams\n+        try { h2c.closeAllStreams(); } catch (Throwable t) {}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2ClientImpl.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1122,0 +1122,10 @@\n+    \/\/ This method is called when the HTTP\/2 client is being\n+    \/\/ stopped. Do not call it from anywhere else.\n+    void closeAllStreams() {\n+        for (var streamId : streams.keySet()) {\n+            \/\/ safe to call without locking - see Stream::deRegister\n+            decrementStreamsCount(streamId);\n+            closeStream(streamId);\n+        }\n+    }\n+\n@@ -1124,8 +1134,11 @@\n-        boolean isClient = (streamid % 2) == 1;\n-        Stream<?> s = streams.remove(streamid);\n-        if (s != null) {\n-            \/\/ decrement the reference count on the HttpClientImpl\n-            \/\/ to allow the SelectorManager thread to exit if no\n-            \/\/ other operation is pending and the facade is no\n-            \/\/ longer referenced.\n-            client().streamUnreference();\n+\n+        Stream<?> s;\n+        synchronized (this) {\n+            s = streams.remove(streamid);\n+            if (s != null) {\n+                \/\/ decrement the reference count on the HttpClientImpl\n+                \/\/ to allow the SelectorManager thread to exit if no\n+                \/\/ other operation is pending and the facade is no\n+                \/\/ longer referenced.\n+                client().streamUnreference();\n+            }\n@@ -1328,2 +1341,13 @@\n-        client().streamReference();\n-        streams.put(streamid, stream);\n+        synchronized (this) {\n+            if (!closed) {\n+                if (debug.on()) {\n+                    debug.log(\"Opened stream %d\", streamid);\n+                }\n+                client().streamReference();\n+                streams.put(streamid, stream);\n+                return;\n+            }\n+        }\n+        if (debug.on()) debug.log(\"connection closed: closing stream %d\", stream);\n+        stream.cancel();\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":34,"deletions":10,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.nio.channels.ClosedSelectorException;\n@@ -67,0 +68,1 @@\n+import java.util.concurrent.ConcurrentSkipListSet;\n@@ -72,0 +74,1 @@\n+import java.util.concurrent.RejectedExecutionException;\n@@ -73,0 +76,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -75,0 +79,2 @@\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n@@ -83,0 +89,1 @@\n+\n@@ -84,0 +91,1 @@\n+import jdk.internal.net.http.common.HttpBodySubscriberWrapper;\n@@ -86,0 +94,1 @@\n+import jdk.internal.net.http.common.MinimalFuture;\n@@ -106,0 +115,1 @@\n+    private final AtomicLong CONNECTION_IDS = new AtomicLong();\n@@ -144,1 +154,4 @@\n-        DelegatingExecutor(BooleanSupplier isInSelectorThread, Executor delegate) {\n+        private final BiConsumer<Runnable, Throwable> errorHandler;\n+        DelegatingExecutor(BooleanSupplier isInSelectorThread,\n+                           Executor delegate,\n+                           BiConsumer<Runnable, Throwable> errorHandler) {\n@@ -147,0 +160,1 @@\n+            this.errorHandler = errorHandler;\n@@ -153,0 +167,2 @@\n+\n+\n@@ -156,1 +172,1 @@\n-                delegate.execute(command);\n+                ensureExecutedAsync(command);\n@@ -162,0 +178,9 @@\n+        public void ensureExecutedAsync(Runnable command) {\n+            try {\n+                delegate.execute(command);\n+            } catch (Throwable t) {\n+                errorHandler.accept(command, t);\n+                ASYNC_POOL.execute(command);\n+            }\n+        }\n+\n@@ -173,0 +198,71 @@\n+    }\n+\n+    \/\/ We maintain a list of pending requests that will be aborted if ever\n+    \/\/ the selector manager thread exists abnormally.\n+    \/\/ The request, its id, and its completable future, are stored in a record-like\n+    \/\/ PendingRequest object added to the pending requests set (pendingRequests).\n+    \/\/\n+    \/\/ When the request's cf completes, either normally or abnormally, a dependent action\n+    \/\/ will remove the PendingRequest object from the pending requests set.\n+    \/\/ If the SelectorManager threads exits abnormally, all pending requests in the\n+    \/\/ pending requests set will be completed exceptionally, in the ASYNC_POOL.\n+    \/\/\n+    \/\/ HttpClientImpl::registerPending(id, req, cf, client) is called from sendAsync\n+    \/\/ to register the pending request in the pending requests set before returning\n+    \/\/ the completable future to the caller.\n+    \/\/\n+    \/\/ HttpClientImpl::abortPendingRequests(client, Throwable reason) is called from\n+    \/\/ the SelectorManager when a throwable is caught just before exiting.\n+    \/\/\n+    \/\/ A dependent action is registered with the pending request's cf to make sure\n+    \/\/ that the pending request will be removed from the pending requests set if,\n+    \/\/ or after, the cf is completed.\n+    \/\/\n+    private final Set<PendingRequest> pendingRequests;\n+    \/\/ an id to ensure total order of pending request objects\n+    private final AtomicLong pendingRequestId = new AtomicLong();\n+    private static final class PendingRequest implements Comparable<PendingRequest> {\n+        final long id;\n+        final HttpRequest request;\n+        final CompletableFuture<?> cf;\n+        final HttpClientImpl client;\n+        final MultiExchange<?> mex;\n+        Object ref;\n+        private PendingRequest(long id,\n+                               HttpRequest request,\n+                               CompletableFuture<?> cf,\n+                               MultiExchange<?> mex,\n+                               HttpClientImpl client) {\n+            this.id = id;\n+            this.request = request;\n+            this.cf = cf;\n+            this.mex = mex;\n+            this.client = client;\n+        }\n+\n+        public void abort(Throwable t) {\n+            try {\n+                if (client.isSelectorThread()) {\n+                    var done = cf.exceptionally((e) -> null);\n+                    ASYNC_POOL.execute(() -> completeExceptionally(t));\n+                    \/\/ special case for when this method is called in the SelectorManager thread:\n+                    \/\/ we want to wait until all futures are completed before proceeding to\n+                    \/\/ shutdown. This ensures that the caller receive the actual `reason`\n+                    \/\/ and not something like \"HTTP\/2 client closed\"...\n+                    done.join();\n+                } else {\n+                    cf.completeExceptionally(t);\n+                }\n+            } finally {\n+                mex.cancel(Utils.getIOException(t));\n+            }\n+        }\n+\n+        private void completeExceptionally(Throwable t) {\n+            if (client.debug.on()) {\n+                client.debug.log(\"aborting %s with %s\", this, t);\n+            }\n+            try { cf.completeExceptionally(t); } catch (Throwable e) {\n+                client.debug.log(\"Failed to complete cf for [%s]: %s\", this, e);\n+            }\n+        }\n@@ -174,0 +270,51 @@\n+\n+        @Override\n+        public int compareTo(PendingRequest o) {\n+            if (o == null) return 1;\n+            return Long.compare(id, o.id);\n+        }\n+\n+        public String toString() {\n+            return id + \": \" + request.toString();\n+        }\n+    }\n+\n+    static void registerPending(PendingRequest pending) {\n+        \/\/ shortcut if cf is already completed: no need to go through the trouble of\n+        \/\/    registering it\n+        if (pending.cf.isDone()) return;\n+\n+        var client = pending.client;\n+        var cf = pending.cf;\n+        var id = pending.id;\n+        boolean added = client.pendingRequests.add(pending);\n+        \/\/ this may immediately remove `pending` from the set is the cf is already completed\n+        pending.ref = cf.whenComplete((r,t) -> client.pendingRequests.remove(pending));\n+        assert added : \"request %d was already added\".formatted(id);\n+        \/\/ should not happen, unless the selector manager has already\n+        \/\/ exited abnormally\n+        if (client.selmgr.isClosed()) {\n+            pending.abort(client.selmgr.selectorClosedException());\n+        }\n+    }\n+\n+    static void abortPendingRequests(HttpClientImpl client, Throwable reason) {\n+        reason = Utils.getCompletionCause(reason);\n+        if (client.debug.on()) {\n+            var msg = reason instanceof RejectedExecutionException\n+                    ? reason.getClass() : reason;\n+            client.debug.log(\"aborting pending requests due to: %s\", msg);\n+        }\n+        closeSubscribers(client, reason);\n+        var pendingRequests = client.pendingRequests;\n+        while (!pendingRequests.isEmpty()) {\n+            var pendings = pendingRequests.iterator();\n+            while (pendings.hasNext()) {\n+                var pending = pendings.next();\n+                try {\n+                    pending.abort(reason);\n+                } finally {\n+                    pendings.remove();\n+                }\n+            }\n+        }\n@@ -212,0 +359,5 @@\n+    private final ConcurrentSkipListSet<PlainHttpConnection> openedConnections\n+            = new ConcurrentSkipListSet<>(HttpConnection.COMPARE_BY_ID);\n+    private final ConcurrentSkipListSet<HttpBodySubscriberWrapper<?>> subscribers\n+            = new ConcurrentSkipListSet<>(HttpBodySubscriberWrapper.COMPARE_BY_ID);\n+\n@@ -243,0 +395,1 @@\n+    private final AtomicLong pendingHttpOperationsCount = new AtomicLong();\n@@ -245,0 +398,2 @@\n+    private final AtomicLong pendingTCPConnectionCount = new AtomicLong();\n+    private final AtomicBoolean isAlive = new AtomicBoolean();\n@@ -298,1 +453,3 @@\n-        delegatingExecutor = new DelegatingExecutor(this::isSelectorThread, ex);\n+        pendingRequests = new ConcurrentSkipListSet<>();\n+        delegatingExecutor = new DelegatingExecutor(this::isSelectorThread, ex,\n+                this::onSubmitFailure);\n@@ -337,0 +494,4 @@\n+    void onSubmitFailure(Runnable command, Throwable failure) {\n+        selmgr.abort(failure);\n+    }\n+\n@@ -350,0 +511,4 @@\n+        \/\/ make sure all subscribers are completed\n+        closeSubscribers();\n+        \/\/ close TCP connection if any are still opened\n+        openedConnections.forEach(this::closeConnection);\n@@ -354,0 +519,34 @@\n+    private void closeSubscribers() {\n+        if (subscribers.isEmpty()) return;\n+        IOException io = selmgr.selectorClosedException();\n+        closeSubscribers(this, io);\n+    }\n+\n+    private static void closeSubscribers(HttpClientImpl client, Throwable t) {\n+        client.subscribers.forEach(s -> s.onError(t));\n+    }\n+\n+    public void registerSubscriber(HttpBodySubscriberWrapper<?> subscriber) {\n+        if (!selmgr.isClosed()) {\n+            synchronized (selmgr) {\n+                if (!selmgr.isClosed()) {\n+                    subscribers.add(subscriber);\n+                    return;\n+                }\n+            }\n+        }\n+        subscriber.onError(selmgr.selectorClosedException());\n+    }\n+\n+    public void subscriberCompleted(HttpBodySubscriberWrapper<?> subscriber) {\n+        subscribers.remove(subscriber);\n+    }\n+\n+    private void closeConnection(HttpConnection conn) {\n+        try { conn.close(); } catch (Throwable e) {\n+            if (Log.channel()) {\n+                Log.logChannel(\"Failed to close connection: \" + e);\n+            }\n+        }\n+    }\n+\n@@ -371,2 +570,20 @@\n-    \/\/ Increments the pendingOperationCount.\n-    final long reference() {\n+    public long newConnectionId() {\n+        return CONNECTION_IDS.incrementAndGet();\n+    }\n+\n+    \/\/ Increments the pendingTCPConnectionCount\n+    public void connectionOpened(PlainHttpConnection plainHttpConnection) {\n+        if (openedConnections.add(plainHttpConnection)) {\n+            pendingTCPConnectionCount.incrementAndGet();\n+        }\n+    }\n+\n+    \/\/ Decrements the pendingTCPConnectionCount\n+    public void connectionClosed(PlainHttpConnection plainHttpConnection) {\n+        if (openedConnections.remove(plainHttpConnection)) {\n+            pendingTCPConnectionCount.decrementAndGet();\n+        }\n+    }\n+\n+    \/\/ Increments the pendingHttpRequestCount and pendingOperationCount.\n+    final long requestReference() {\n@@ -374,0 +591,12 @@\n+        return reference();\n+    }\n+\n+    \/\/ Decrements the pendingHttpRequestCount and pendingOperationCount.\n+    final long requestUnreference() {\n+        pendingHttpRequestCount.decrementAndGet();\n+        return unreference();\n+    }\n+\n+    \/\/ Increments the pendingHttpOperationsCount and pendingOperationCount.\n+    final long reference() {\n+        pendingHttpOperationsCount.incrementAndGet();\n@@ -377,1 +606,1 @@\n-    \/\/ Decrements the pendingOperationCount.\n+    \/\/ Decrements the pendingHttpOperationsCount and pendingOperationCount.\n@@ -380,1 +609,1 @@\n-        final long httpCount = pendingHttpRequestCount.decrementAndGet();\n+        final long httpCount = pendingHttpOperationsCount.decrementAndGet();\n@@ -393,1 +622,1 @@\n-    \/\/ Increments the pendingOperationCount.\n+    \/\/ Increments the pendingHttp2StreamCount and pendingOperationCount.\n@@ -399,1 +628,1 @@\n-    \/\/ Decrements the pendingOperationCount.\n+    \/\/ Decrements the pendingHttp2StreamCount and pendingOperationCount.\n@@ -403,1 +632,1 @@\n-        final long httpCount = pendingHttpRequestCount.get();\n+        final long httpCount = pendingHttpOperationsCount.get();\n@@ -415,1 +644,1 @@\n-    \/\/ Increments the pendingOperationCount.\n+    \/\/ Increments the pendingWebSocketCount and pendingOperationCount.\n@@ -421,1 +650,1 @@\n-    \/\/ Decrements the pendingOperationCount.\n+    \/\/ Decrements the pendingWebSocketCount and pendingOperationCount.\n@@ -425,1 +654,1 @@\n-        final long httpCount = pendingHttpRequestCount.get();\n+        final long httpCount = pendingHttpOperationsCount.get();\n@@ -438,0 +667,1 @@\n+    \/\/ Incremented with any operation, whether it's HTTP\/1.1, HTTP\/2, or WebSocket\n@@ -442,0 +672,3 @@\n+    \/\/ Trackers are used in test to verify that an instance of\n+    \/\/ HttpClient has shutdown correctly, and that all operations\n+    \/\/ have terminated.\n@@ -443,0 +676,1 @@\n+        final AtomicLong requestCount;\n@@ -447,0 +681,1 @@\n+        final AtomicLong connnectionsCount;\n@@ -448,0 +683,1 @@\n+        final AtomicBoolean isAlive;\n@@ -449,1 +685,2 @@\n-        HttpClientTracker(AtomicLong http,\n+        HttpClientTracker(AtomicLong request,\n+                          AtomicLong http,\n@@ -453,0 +690,1 @@\n+                          AtomicLong conns,\n@@ -454,0 +692,1 @@\n+                          AtomicBoolean isAlive,\n@@ -455,0 +694,1 @@\n+            this.requestCount = request;\n@@ -459,0 +699,1 @@\n+            this.connnectionsCount = conns;\n@@ -460,0 +701,1 @@\n+            this.isAlive = isAlive;\n@@ -467,0 +709,6 @@\n+        public long getOutstandingHttpRequests() {\n+            return requestCount.get();\n+        }\n+        @Override\n+        public long getOutstandingTcpConnections() { return connnectionsCount.get();}\n+        @Override\n@@ -481,0 +729,2 @@\n+        public boolean isSelectorAlive() { return isAlive.get(); }\n+        @Override\n@@ -487,1 +737,3 @@\n-        return new HttpClientTracker(pendingHttpRequestCount,\n+        return new HttpClientTracker(\n+                pendingHttpRequestCount,\n+                pendingHttpOperationsCount,\n@@ -491,0 +743,1 @@\n+                pendingTCPConnectionCount,\n@@ -492,0 +745,1 @@\n+                isAlive,\n@@ -497,1 +751,1 @@\n-    final boolean isReferenced() {\n+    boolean isReferenced() {\n@@ -529,0 +783,8 @@\n+    boolean isSelectorClosed() {\n+        return selmgr.isClosed();\n+    }\n+\n+    IOException selectorClosedException() {\n+        return selmgr.selectorClosedException();\n+    }\n+\n@@ -625,0 +887,6 @@\n+        \/\/ should not happen, unless the selector manager has\n+        \/\/ exited abnormally\n+        if (selmgr.isClosed()) {\n+            return MinimalFuture.failedFuture(selmgr.selectorClosedException());\n+        }\n+\n@@ -634,0 +902,1 @@\n+        long id = pendingRequestId.incrementAndGet();\n@@ -635,1 +904,1 @@\n-        reference();\n+        requestReference();\n@@ -658,2 +927,2 @@\n-            CompletableFuture<HttpResponse<T>> res =\n-                    mex.responseAsync(executor).whenComplete((b,t) -> unreference());\n+            CompletableFuture<HttpResponse<T>> mexCf = mex.responseAsync(executor);\n+            CompletableFuture<HttpResponse<T>> res = mexCf.whenComplete((b,t) -> requestUnreference());\n@@ -671,0 +940,5 @@\n+\n+            \/\/ The mexCf is the Cf we need to abort if the SelectorManager thread\n+            \/\/ is aborted.\n+            PendingRequest pending = new PendingRequest(id, requestImpl, mexCf, mex, this);\n+            registerPending(pending);\n@@ -673,1 +947,1 @@\n-            unreference();\n+            requestUnreference();\n@@ -713,2 +987,3 @@\n-        HttpClientImpl owner;\n-        ConnectionPool pool;\n+        private final HttpClientImpl owner;\n+        private final ConnectionPool pool;\n+        private final AtomicReference<Throwable> errorRef = new AtomicReference<>();\n@@ -729,0 +1004,9 @@\n+        IOException selectorClosedException() {\n+            var io = new IOException(\"selector manager closed\");\n+            var cause = errorRef.get();\n+            if (cause != null) {\n+                io.initCause(cause);\n+            }\n+            return io;\n+        }\n+\n@@ -735,1 +1019,1 @@\n-                } else if (e.interestOps() != 0){\n+                } else if (e.interestOps() != 0) {\n@@ -752,0 +1036,1 @@\n+            if (closed) e.abort(selectorClosedException());\n@@ -768,0 +1053,42 @@\n+        void abort(Throwable t) {\n+            boolean closed = this.closed;\n+            errorRef.compareAndSet(null, t);\n+            if (debug.on()) {\n+                debug.log(\"aborting selector manager(closed=%s): \" + t, closed);\n+            }\n+            t = errorRef.get();\n+            boolean inSelectorThread = owner.isSelectorThread();\n+            if (!inSelectorThread) {\n+                \/\/ abort anything pending, then close\n+                abortPendingRequests(owner, t);\n+            }\n+            Set<SelectionKey> keys = new HashSet<>();\n+            Set<AsyncEvent> toAbort = new HashSet<>();\n+            synchronized (this) {\n+                if (closed = this.closed) return;\n+                this.closed = true;\n+                try {\n+                    keys.addAll(selector.keys());\n+                } catch (ClosedSelectorException ce) {\n+                    \/\/ OK - nothing to do...\n+                }\n+                toAbort.addAll(this.registrations);\n+                toAbort.addAll(this.deregistrations);\n+                this.registrations.clear();\n+                this.deregistrations.clear();\n+            }\n+            \/\/ double check after closing\n+            abortPendingRequests(owner, t);\n+\n+            IOException io = toAbort.isEmpty()\n+                    ? null : selectorClosedException();\n+            for (AsyncEvent e : toAbort) {\n+                try {\n+                    e.abort(io);\n+                } catch (Throwable x) {\n+                    debug.log(\"Failed to abort event: \" + x);\n+                }\n+            }\n+            if (!inSelectorThread) selector.wakeup();\n+        }\n+\n@@ -780,0 +1107,4 @@\n+        boolean isClosed() {\n+            return closed;\n+        }\n+\n@@ -785,0 +1116,1 @@\n+            owner.isAlive.set(true);\n@@ -787,1 +1119,1 @@\n-                while (!Thread.currentThread().isInterrupted()) {\n+                while (!Thread.currentThread().isInterrupted() && !closed) {\n@@ -820,1 +1152,1 @@\n-                                    throw new IOException(\"Channel closed\");\n+                                    throw new ClosedChannelException();\n@@ -939,1 +1271,2 @@\n-                    readyList.forEach((e) -> handleEvent(e, null));\n+                    IOException ioe = closed ? selectorClosedException() : null;\n+                    readyList.forEach((e) -> handleEvent(e, ioe));\n@@ -952,0 +1285,1 @@\n+                errorRef.compareAndSet(null, e);\n@@ -953,0 +1287,1 @@\n+                    closed = true; \/\/ set closed early so that new requests are rejected\n@@ -958,0 +1293,1 @@\n+                abortPendingRequests(owner, selectorClosedException());\n@@ -964,1 +1300,5 @@\n-                shutdown();\n+                try {\n+                    shutdown();\n+                } finally {\n+                    owner.isAlive.set(false);\n+                }\n@@ -981,1 +1321,4 @@\n-            if (closed || ioe != null) {\n+            if (ioe == null && closed) {\n+                ioe = selectorClosedException();\n+            }\n+            if (ioe != null) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":371,"deletions":28,"binary":false,"changes":399,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.Comparator;\n@@ -37,1 +38,0 @@\n-import java.util.TreeMap;\n@@ -72,0 +72,2 @@\n+    public static final Comparator<HttpConnection> COMPARE_BY_ID\n+            = Comparator.comparing(HttpConnection::id);\n@@ -77,0 +79,1 @@\n+    private final long id;\n@@ -82,0 +85,10 @@\n+        this.id = newConnectionId(client);\n+    }\n+\n+    \/\/ This is overridden in tests\n+    long newConnectionId(HttpClientImpl client) {\n+        return client.newConnectionId();\n+    }\n+\n+    private long id() {\n+        return id;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpConnection.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -172,0 +172,1 @@\n+            Executor ensureExecutedAsync = this.executor::ensureExecutedAsync;\n@@ -173,2 +174,2 @@\n-                    ? this.executor.delegate()\n-                    : new PrivilegedExecutor(this.executor.delegate(), acc);\n+                    ? ensureExecutedAsync\n+                    : new PrivilegedExecutor(ensureExecutedAsync, acc);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/MultiExchange.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,0 +143,1 @@\n+                client().connectionOpened(PlainHttpConnection.this);\n@@ -148,0 +149,1 @@\n+                    \/\/ complete async since the event runs on the SelectorManager thread\n@@ -152,0 +154,1 @@\n+                \/\/ complete async since the event runs on the SelectorManager thread\n@@ -159,0 +162,1 @@\n+            \/\/ complete async since the event runs on the SelectorManager thread\n@@ -191,0 +195,1 @@\n+                client().connectionOpened(this);\n@@ -200,0 +205,3 @@\n+                if (Log.channel()) {\n+                    Log.logChannel(\"Closing connection: connect failed due to: \" + throwable);\n+                }\n@@ -371,2 +379,9 @@\n-            chan.close();\n-            tube.signalClosed();\n+            if (Log.channel()) {\n+                Log.logChannel(\"Closing channel: \" + chan);\n+            }\n+            try {\n+                chan.close();\n+                tube.signalClosed();\n+            } finally {\n+                client().connectionClosed(this);\n+            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainHttpConnection.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,0 +106,1 @@\n+        void onError(Throwable t);\n@@ -180,0 +181,6 @@\n+        @Override\n+        public void onError(Throwable t) {\n+            closedExceptionally = t;\n+            onComplete.accept(t);\n+        }\n+\n@@ -479,0 +486,6 @@\n+        @Override\n+        public void onError(Throwable t) {\n+            closedExceptionally = t;\n+            onComplete.accept(t);\n+        }\n+\n@@ -568,0 +581,10 @@\n+        @Override\n+        public void onError(Throwable t) {\n+            if (contentLength != 0) {\n+                closedExceptionally = t;\n+                onComplete.accept(t);\n+            } else {\n+                onComplete.accept(null);\n+            }\n+        }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ResponseContent.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,1 @@\n+import jdk.internal.net.http.HttpClientImpl.DelegatingExecutor;\n@@ -1147,2 +1148,2 @@\n-                e = (e instanceof HttpClientImpl.DelegatingExecutor)\n-                        ? ((HttpClientImpl.DelegatingExecutor) e).delegate() : e;\n+                e = (e instanceof DelegatingExecutor exec)\n+                        ? exec::ensureExecutedAsync : e;\n@@ -1161,0 +1162,1 @@\n+                    \/\/ the errorHandler will complete the CF\n@@ -1167,0 +1169,1 @@\n+            \/\/ the errorHandler will complete the CF\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ResponseSubscribers.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -344,0 +344,4 @@\n+            if (client.isSelectorClosed()) {\n+                signalError(client.selectorClosedException());\n+                return;\n+            }\n@@ -357,0 +361,4 @@\n+                        if (client.isSelectorClosed()) {\n+                            signalError(client.selectorClosedException());\n+                            return;\n+                        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/SocketTube.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import java.net.http.HttpResponse.BodyHandler;\n+import java.net.http.HttpResponse.ResponseInfo;\n@@ -311,0 +313,3 @@\n+    \/\/ This method is called by Http2Connection::decrementStreamCount in order\n+    \/\/ to make sure that the stream count is decremented only once for\n+    \/\/ a given stream.\n@@ -323,1 +328,2 @@\n-            BodySubscriber<T> bodySubscriber = handler.apply(new ResponseInfoImpl(response));\n+            Http2StreamResponseSubscriber<T> bodySubscriber =\n+                    createResponseSubscriber(handler, new ResponseInfoImpl(response));\n@@ -339,0 +345,19 @@\n+    @Override\n+    Http2StreamResponseSubscriber<T> createResponseSubscriber(BodyHandler<T> handler, ResponseInfo response) {\n+        Http2StreamResponseSubscriber<T> subscriber =\n+                new Http2StreamResponseSubscriber<>(handler.apply(response));\n+        registerResponseSubscriber(subscriber);\n+        return subscriber;\n+    }\n+\n+    \/\/ The Http2StreamResponseSubscriber is registered with the HttpClient\n+    \/\/ to ensure that it gets completed if the SelectorManager aborts due\n+    \/\/ to unexpected exceptions.\n+    private void registerResponseSubscriber(Http2StreamResponseSubscriber<?> subscriber) {\n+        client().registerSubscriber(subscriber);\n+    }\n+\n+    private void subscriberCompleted(Http2StreamResponseSubscriber<?> subscriber) {\n+        client().subscriberCompleted(subscriber);\n+    }\n+\n@@ -396,3 +421,0 @@\n-        } else {\n-            pendingResponseSubscriber = bodySubscriber;\n-            sched.runOrSchedule(); \/\/ in case data waiting already to be processed\n@@ -400,0 +422,6 @@\n+\n+        \/\/ ensure that the body subscriber will be subsribed and onError() is\n+        \/\/ invoked\n+        pendingResponseSubscriber = bodySubscriber;\n+        sched.runOrSchedule(); \/\/ in case data waiting already to be processed, or error\n+\n@@ -1628,0 +1656,15 @@\n+    final class Http2StreamResponseSubscriber<U> extends HttpBodySubscriberWrapper<U> {\n+        Http2StreamResponseSubscriber(BodySubscriber<U> subscriber) {\n+            super(subscriber);\n+        }\n+\n+        @Override\n+        protected void complete(Throwable t) {\n+            try {\n+                Stream.this.subscriberCompleted(this);\n+            } finally {\n+                super.complete(t);\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":47,"deletions":4,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.common;\n+\n+import java.net.http.HttpResponse.BodySubscriber;\n+import java.nio.ByteBuffer;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import jdk.internal.net.http.ResponseSubscribers.TrustedSubscriber;\n+\n+\/**\n+ * A class that wraps a user supplied {@link BodySubscriber}, but on\n+ * which {@link #onError(Throwable)} can be invoked at any time,\n+ * even before {@link #onSubscribe(Subscription)} has not been called\n+ * yet.\n+ * @param <T> the type of the response body\n+ *\/\n+public class HttpBodySubscriberWrapper<T> implements TrustedSubscriber<T> {\n+\n+    public static final Comparator<HttpBodySubscriberWrapper<?>> COMPARE_BY_ID\n+            = Comparator.comparing(HttpBodySubscriberWrapper::id);\n+\n+\n+    public static final Flow.Subscription NOP = new Flow.Subscription() {\n+        @Override\n+        public void request(long n) { }\n+        public void cancel() { }\n+    };\n+\n+    static final AtomicLong IDS = new AtomicLong();\n+    final long id = IDS.incrementAndGet();\n+    final BodySubscriber<T> userSubscriber;\n+    final AtomicBoolean completed = new AtomicBoolean();\n+    final AtomicBoolean subscribed = new AtomicBoolean();\n+    volatile Subscription subscription;\n+    volatile Throwable withError;\n+    public HttpBodySubscriberWrapper(BodySubscriber<T> userSubscriber) {\n+        this.userSubscriber = userSubscriber;\n+    }\n+\n+    final long id() { return id; }\n+\n+    @Override\n+    public boolean needsExecutor() {\n+        return TrustedSubscriber.needsExecutor(userSubscriber);\n+    }\n+\n+    \/\/ propagate the error to the user subscriber, even if not\n+    \/\/ subscribed yet.\n+    private void propagateError(Throwable t) {\n+        assert t != null;\n+        try {\n+            \/\/ if unsubscribed at this point, it will not\n+            \/\/ get subscribed later - so do it now and\n+            \/\/ propagate the error\n+            \/\/ Race condition with onSubscribe: we need to wait until\n+            \/\/ subscription is finished before calling onError;\n+            synchronized (this) {\n+                if (subscribed.compareAndSet(false, true)) {\n+                    userSubscriber.onSubscribe(NOP);\n+                }\n+            }\n+        } finally  {\n+            \/\/ if onError throws then there is nothing to do\n+            \/\/ here: let the caller deal with it by logging\n+            \/\/ and closing the connection.\n+            userSubscriber.onError(t);\n+        }\n+    }\n+\n+    \/**\n+     * Complete the subscriber, either normally or exceptionally\n+     * ensure that the subscriber is completed only once.\n+     * @param t a throwable, or {@code null}\n+     *\/\n+    protected void complete(Throwable t) {\n+        if (completed.compareAndSet(false, true)) {\n+            t  = withError = Utils.getCompletionCause(t);\n+            if (t == null) {\n+                try {\n+                    assert subscribed.get();\n+                    userSubscriber.onComplete();\n+                } catch (Throwable x) {\n+                    \/\/ Simply propagate the error by calling\n+                    \/\/ onError on the user subscriber, and let the\n+                    \/\/ connection be reused since we should have received\n+                    \/\/ and parsed all the bytes when we reach here.\n+                    \/\/ If onError throws in turn, then we will simply\n+                    \/\/ let that new exception flow up to the caller\n+                    \/\/ and let it deal with it.\n+                    \/\/ (i.e: log and close the connection)\n+                    \/\/ Note that rethrowing here could introduce a\n+                    \/\/ race that might cause the next send() operation to\n+                    \/\/ fail as the connection has already been put back\n+                    \/\/ into the cache when we reach here.\n+                    propagateError(t = withError = Utils.getCompletionCause(x));\n+                }\n+            } else {\n+                propagateError(t);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public CompletionStage<T> getBody() {\n+        return userSubscriber.getBody();\n+    }\n+\n+    @Override\n+    public void onSubscribe(Flow.Subscription subscription) {\n+        this.subscription = subscription;\n+        \/\/ race condition with propagateError: we need to wait until\n+        \/\/ subscription is finished before calling onError;\n+        synchronized (this) {\n+            if (subscribed.compareAndSet(false, true)) {\n+                userSubscriber.onSubscribe(subscription);\n+            } else {\n+                \/\/ could be already subscribed and completed\n+                \/\/ if an unexpected error occurred before the actual\n+                \/\/ subscription - though that's not supposed\n+                \/\/ happen.\n+                assert completed.get();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onNext(List<ByteBuffer> item) {\n+        if (completed.get()) {\n+            if (subscription != null) {\n+                subscription.cancel();\n+            }\n+        } else {\n+            userSubscriber.onNext(item);\n+        }\n+    }\n+    @Override\n+    public void onError(Throwable throwable) {\n+        complete(throwable);\n+    }\n+    @Override\n+    public void onComplete() {\n+        complete(null);\n+    }\n+}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/HttpBodySubscriberWrapper.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,4 @@\n+        \/\/ The number of outstandanding requests: this is\n+        \/\/ the number of CF returned by send\/sendAsync which\n+        \/\/ have not been completed.\n+        long getOutstandingHttpRequests();\n@@ -56,0 +60,2 @@\n+        \/\/ number of TCP connections still opened\n+        long getOutstandingTcpConnections();\n@@ -59,0 +65,2 @@\n+        \/\/ whether the Selector Manager thread is still running\n+        boolean isSelectorAlive();\n@@ -61,0 +69,1 @@\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/OperationTrackers.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,417 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8277969\n+ * @summary Test for edge case where the executor is not accepting\n+ *          new tasks while the client is still running\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer jdk.test.lib.net.SimpleSSLContext\n+ *        ReferenceTracker\n+ * @run testng\/othervm\n+ *       -Djdk.internal.httpclient.debug=true\n+ *       -Djdk.httpclient.HttpClient.log=trace,headers,requests\n+ *       AsyncExecutorShutdown\n+ *\/\n+\/\/ -Djdk.internal.httpclient.debug=true\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Redirect;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.out;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.fail;\n+\n+public class AsyncExecutorShutdown implements HttpServerAdapters {\n+\n+    static {\n+        HttpServerAdapters.enableServerLogging();\n+    }\n+    static final Random RANDOM = RandomFactory.getRandom();\n+\n+    SSLContext sslContext;\n+    HttpTestServer httpTestServer;        \/\/ HTTP\/1.1    [ 4 servers ]\n+    HttpTestServer httpsTestServer;       \/\/ HTTPS\/1.1\n+    HttpTestServer http2TestServer;       \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;      \/\/ HTTP\/2 ( h2  )\n+    String httpURI;\n+    String httpsURI;\n+    String http2URI;\n+    String https2URI;\n+\n+    static final String MESSAGE = \"AsyncExecutorShutdown message body\";\n+    static final int ITERATIONS = 3;\n+\n+    @DataProvider(name = \"positive\")\n+    public Object[][] positive() {\n+        return new Object[][] {\n+                { httpURI,    },\n+                { httpsURI,   },\n+                { http2URI,   },\n+                { https2URI,  },\n+        };\n+    }\n+\n+    static final AtomicLong requestCounter = new AtomicLong();\n+    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+\n+    static Throwable getCause(Throwable t) {\n+        while (t instanceof CompletionException || t instanceof ExecutionException) {\n+            t = t.getCause();\n+        }\n+        return t;\n+    }\n+\n+    static String readBody(InputStream in) {\n+        try {\n+            return new String(in.readAllBytes(), StandardCharsets.UTF_8);\n+        } catch (IOException io) {\n+            throw new UncheckedIOException(io);\n+        }\n+    }\n+\n+    static void checkCause(String what, Throwable cause) {\n+        Throwable t = cause;\n+        Throwable accepted = null;\n+        while (t != null) {\n+            out.println(what + \": checking \" + t);\n+            if (t instanceof  RejectedExecutionException) {\n+                out.println(what + \": Got expected RejectedExecutionException in cause: \" + t);\n+                return;\n+            } else if (t instanceof ClosedChannelException) {\n+                out.println(what + \": Accepting ClosedChannelException as a valid cause: \" + t);\n+                accepted = t;\n+            }\n+            t = t.getCause();\n+        }\n+        if (accepted != null) {\n+            out.println(what + \": Didn't find expected RejectedExecutionException, \" +\n+                    \"but accepting \" + accepted.getClass().getSimpleName()\n+                    + \" as a valid cause: \" + accepted);\n+            return;\n+        }\n+        throw new AssertionError(what + \": Unexpected exception: \" + cause, cause);\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testConcurrent(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+        ExecutorService readerService = Executors.newCachedThreadPool();\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .executor(executorService)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+        assert client.executor().isPresent();\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        try {\n+            List<CompletableFuture<String>> bodies = new ArrayList<>();\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/concurrent\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                CompletableFuture<HttpResponse<InputStream>> responseCF;\n+                CompletableFuture<String> bodyCF;\n+                final int si = i;\n+                try {\n+                    responseCF = client.sendAsync(request, BodyHandlers.ofInputStream())\n+                            .thenApply((response) -> {\n+                                out.println(si + \":  Got response: \" + response);\n+                                assertEquals(response.statusCode(), 200);\n+                                return response;\n+                            });\n+                    bodyCF = responseCF.thenApplyAsync(HttpResponse::body, readerService)\n+                            .thenApply(AsyncExecutorShutdown::readBody)\n+                            .thenApply((s) -> { assertEquals(s, MESSAGE); return s;});\n+                } catch (RejectedExecutionException x) {\n+                    out.println(i + \": Got expected exception: \" + x);\n+                    continue;\n+                }\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i == step) {\n+                    out.printf(\"%d: shutting down executor now%n\", i, sleep);\n+                    executorService.shutdownNow();\n+                }\n+                var cf = bodyCF.exceptionally((t) -> {\n+                    Throwable cause = getCause(t);\n+                    out.println(si + \": Got expected exception: \" + cause);\n+                    if (UncheckedIOException.class.isAssignableFrom(cause.getClass())) {\n+                        if (cause.getCause() != null) {\n+                            out.println(si + \": Got expected exception: \" + cause);\n+                            cause = cause.getCause();\n+                        }\n+                    }\n+                    checkCause(String.valueOf(si), cause);\n+                    return null;\n+                });\n+                bodies.add(cf);\n+            }\n+            CompletableFuture.allOf(bodies.toArray(new CompletableFuture<?>[0])).get();\n+        } finally {\n+            client = null;\n+            executorService.awaitTermination(2000, TimeUnit.MILLISECONDS);\n+            readerService.shutdown();\n+            readerService.awaitTermination(2000, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testSequential(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+        ExecutorService readerService = Executors.newCachedThreadPool();\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .executor(executorService)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+        assert client.executor().isPresent();\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        out.printf(\"will shutdown executor in step %d%n\", step);\n+        try {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/sequential\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                            .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                            .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                final int si = i;\n+                CompletableFuture<HttpResponse<InputStream>> responseCF;\n+                CompletableFuture<String> bodyCF;\n+                try {\n+                    responseCF = client.sendAsync(request, BodyHandlers.ofInputStream())\n+                            .thenApply((response) -> {\n+                                out.println(si + \":  Got response: \" + response);\n+                                assertEquals(response.statusCode(), 200);\n+                                return response;\n+                            });\n+                    bodyCF = responseCF.thenApplyAsync(HttpResponse::body, readerService)\n+                            .thenApply(AsyncExecutorShutdown::readBody)\n+                            .thenApply((s) -> {assertEquals(s, MESSAGE); return s;})\n+                            .thenApply((s) -> {out.println(si + \":  Got body: \" + s); return s;});\n+                } catch (RejectedExecutionException x) {\n+                    out.println(i + \": Got expected exception: \" + x);\n+                    continue;\n+                }\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i == step) {\n+                    out.printf(\"%d: shutting down executor now%n\", i, sleep);\n+                    executorService.shutdownNow();\n+                }\n+                bodyCF.handle((r,t) -> {\n+                    if (t != null) {\n+                        try {\n+                            Throwable cause = getCause(t);\n+                            out.println(si + \": Got expected exception: \" + cause);\n+                            if (UncheckedIOException.class.isAssignableFrom(cause.getClass())) {\n+                                if (cause.getCause() != null) {\n+                                    out.println(si + \": Got expected exception: \" + cause);\n+                                    cause = cause.getCause();\n+                                }\n+                            }\n+                            checkCause(String.valueOf(si), cause);\n+                        } catch (Throwable ase) {\n+                            return CompletableFuture.failedFuture(ase);\n+                        }\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return CompletableFuture.completedFuture(r);\n+                    }\n+                }).thenCompose((c) -> c).get();\n+            }\n+       } finally {\n+            client = null;\n+            executorService.awaitTermination(2000, TimeUnit.MILLISECONDS);\n+            readerService.shutdown();\n+            readerService.awaitTermination(2000, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    \/\/ -- Infrastructure\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        out.println(\"\\n**** Setup ****\\n\");\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+\n+        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer.addHandler(new ServerRequestHandler(), \"\/http1\/exec\/\");\n+        httpURI = \"http:\/\/\" + httpTestServer.serverAuthority() + \"\/http1\/exec\/retry\";\n+        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n+        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer.addHandler(new ServerRequestHandler(),\"\/https1\/exec\/\");\n+        httpsURI = \"https:\/\/\" + httpsTestServer.serverAuthority() + \"\/https1\/exec\/retry\";\n+\n+        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer.addHandler(new ServerRequestHandler(), \"\/http2\/exec\/\");\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/exec\/retry\";\n+        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer.addHandler(new ServerRequestHandler(), \"\/https2\/exec\/\");\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/exec\/retry\";\n+\n+        httpTestServer.start();\n+        httpsTestServer.start();\n+        http2TestServer.start();\n+        https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        Thread.sleep(100);\n+        AssertionError fail = TRACKER.checkShutdown(5000);\n+        try {\n+            httpTestServer.stop();\n+            httpsTestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+        } finally {\n+            if (fail != null) throw fail;\n+        }\n+    }\n+\n+    static class ServerRequestHandler implements HttpTestHandler {\n+        ConcurrentHashMap<String,String> closedRequests = new ConcurrentHashMap<>();\n+\n+        @java.lang.Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            out.println(\"ServerRequestHandler for: \" + t.getRequestURI());\n+\n+            List<String> uuids = t.getRequestHeaders().get(\"X-uuid\");\n+            if (uuids == null || uuids.size() != 1) {\n+                readAllRequestData(t);\n+                try (OutputStream os = t.getResponseBody()) {\n+                    String msg = \"Incorrect uuid header values:[\" + uuids + \"]\";\n+                    (new RuntimeException(msg)).printStackTrace();\n+                    t.sendResponseHeaders(500, -1);\n+                    os.write(msg.getBytes(UTF_8));\n+                }\n+                return;\n+            }\n+\n+            String uuid = uuids.get(0);\n+            \/\/ retrying\n+            if (closedRequests.putIfAbsent(uuid, t.getRequestURI().toString()) == null) {\n+                if (t.getExchangeVersion() == HttpClient.Version.HTTP_1_1) {\n+                    \/\/ Throwing an exception here only causes a retry\n+                    \/\/ with HTTP_1_1 - where it forces the server to close\n+                    \/\/ the connection.\n+                    \/\/ For HTTP\/2 then throwing an IOE would cause the server\n+                    \/\/ to close the stream, and throwing anything else would\n+                    \/\/ cause it to close the connection, but neither would\n+                    \/\/ cause the client to retry.\n+                    \/\/ So we simply do not try to retry with HTTP\/2.\n+                    out.println(\"Server will close connection, client will retry: \"\n+                            + t.getRequestURI().toString());\n+                    throw new IOException(\"Closing on first request\");\n+                }\n+            }\n+\n+            \/\/ not retrying\n+            readAllRequestData(t);\n+            try (OutputStream os = t.getResponseBody()) {\n+                byte[] bytes = MESSAGE.getBytes(UTF_8);\n+                t.sendResponseHeaders(200, bytes.length);\n+                for (int i=0; i<bytes.length; i++) {\n+                    os.write(bytes, i, 1);\n+                    os.flush();\n+                    try {\n+                        Thread.sleep(RANDOM.nextInt(5));\n+                    } catch (InterruptedException x) { }\n+                }\n+            }\n+\n+            closedRequests.remove(uuid);\n+        }\n+    }\n+\n+    static void readAllRequestData(HttpTestExchange t) throws IOException {\n+        try (InputStream is = t.getRequestBody()) {\n+            is.readAllBytes();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/AsyncExecutorShutdown.java","additions":417,"deletions":0,"binary":false,"changes":417,"status":"added"},{"patch":"@@ -0,0 +1,380 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8277969\n+ * @summary Test for edge case where the executor is not accepting\n+ *          new tasks while the client is still running\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer jdk.test.lib.net.SimpleSSLContext\n+ *        ReferenceTracker\n+ * @run testng\/othervm\n+ *       -Djdk.internal.httpclient.debug=true\n+ *       -Djdk.httpclient.HttpClient.log=trace,headers,requests\n+ *       ExecutorShutdown\n+ *\/\n+\/\/ -Djdk.internal.httpclient.debug=true\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Redirect;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.channels.ClosedChannelException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.out;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.fail;\n+\n+public class ExecutorShutdown implements HttpServerAdapters {\n+\n+    static {\n+        HttpServerAdapters.enableServerLogging();\n+    }\n+    static final Random RANDOM = RandomFactory.getRandom();\n+\n+    SSLContext sslContext;\n+    HttpTestServer httpTestServer;        \/\/ HTTP\/1.1    [ 4 servers ]\n+    HttpTestServer httpsTestServer;       \/\/ HTTPS\/1.1\n+    HttpTestServer http2TestServer;       \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;      \/\/ HTTP\/2 ( h2  )\n+    String httpURI;\n+    String httpsURI;\n+    String http2URI;\n+    String https2URI;\n+\n+    static final String MESSAGE = \"ExecutorShutdown message body\";\n+    static final int ITERATIONS = 3;\n+\n+    @DataProvider(name = \"positive\")\n+    public Object[][] positive() {\n+        return new Object[][] {\n+                { httpURI,    },\n+                { httpsURI,   },\n+                { http2URI,   },\n+                { https2URI,  },\n+        };\n+    }\n+\n+    static final AtomicLong requestCounter = new AtomicLong();\n+    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+\n+    static Throwable getCause(Throwable t) {\n+        while (t instanceof CompletionException || t instanceof ExecutionException) {\n+            t = t.getCause();\n+        }\n+        return t;\n+    }\n+\n+    static void checkCause(String what, Throwable cause) {\n+        Throwable t = cause;\n+        Throwable accepted = null;\n+        while (t != null) {\n+            out.println(what + \": checking \" + t);\n+            if (t instanceof  RejectedExecutionException) {\n+                out.println(what + \": Got expected RejectedExecutionException in cause: \" + t);\n+                return;\n+            } else if (t instanceof ClosedChannelException) {\n+                out.println(what + \": Accepting ClosedChannelException as a valid cause: \" + t);\n+                accepted = t;\n+            }\n+            t = t.getCause();\n+        }\n+        if (accepted != null) {\n+            out.println(what + \": Didn't find expected RejectedExecutionException, \" +\n+                    \"but accepting \" + accepted.getClass().getSimpleName()\n+                    + \" as a valid cause: \" + accepted);\n+            return;\n+        }\n+        throw new AssertionError(what + \": Unexpected exception: \" + cause, cause);\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testConcurrent(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .executor(executorService)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+        assert client.executor().isPresent();\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        try {\n+            List<CompletableFuture<HttpResponse<String>>> responses = new ArrayList<>();\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/concurrent\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                CompletableFuture<HttpResponse<String>> responseCF;\n+                try {\n+                    responseCF = client.sendAsync(request, BodyHandlers.ofString());\n+                } catch (RejectedExecutionException x) {\n+                    out.println(i + \": Got expected exception: \" + x);\n+                    continue;\n+                }\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i == step) {\n+                    out.printf(\"%d: shutting down executor now%n\", i, sleep);\n+                    executorService.shutdownNow();\n+                }\n+                final int si = i;\n+                var cf = responseCF.thenApply((response) -> {\n+                    out.println(si + \":  Got response: \" + response);\n+                    out.println(si + \":  Got body Path: \" + response.body());\n+                    assertEquals(response.statusCode(), 200);\n+                    assertEquals(response.body(), MESSAGE);\n+                    return response;\n+                }).exceptionally((t) -> {\n+                    Throwable cause = getCause(t);\n+                    out.println(si + \": Got expected exception: \" + cause);\n+                    checkCause(String.valueOf(si), cause);\n+                    return null;\n+                });\n+                responses.add(cf);\n+            }\n+            CompletableFuture.allOf(responses.toArray(new CompletableFuture<?>[0])).get();\n+        } finally {\n+            client = null;\n+            executorService.awaitTermination(2000, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testSequential(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .executor(executorService)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+        assert client.executor().isPresent();\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        out.printf(\"will shutdown executor in step %d%n\", step);\n+        try {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/sequential\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                            .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                            .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                CompletableFuture<HttpResponse<String>> responseCF;\n+                try {\n+                    responseCF = client.sendAsync(request, BodyHandlers.ofString());\n+                } catch (RejectedExecutionException x) {\n+                    out.println(i + \": Got expected exception: \" + x);\n+                    continue;\n+                }\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i == step) {\n+                    out.printf(\"%d: shutting down executor now%n\", i, sleep);\n+                    executorService.shutdownNow();\n+                }\n+                final int si = i;\n+                responseCF.thenApply((response) -> {\n+                    out.println(si + \":  Got response: \" + response);\n+                    out.println(si + \":  Got body Path: \" + response.body());\n+                    assertEquals(response.statusCode(), 200);\n+                    assertEquals(response.body(), MESSAGE);\n+                    return response;\n+                }).handle((r,t) -> {\n+                    if (t != null) {\n+                        try {\n+                            Throwable cause = getCause(t);\n+                            out.println(si + \": Got expected exception: \" + cause);\n+                            checkCause(String.valueOf(si), cause);\n+                         } catch (Throwable ase) {\n+                            return CompletableFuture.failedFuture(ase);\n+                        }\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return CompletableFuture.completedFuture(r);\n+                    }\n+                }).thenCompose((c) -> c).get();\n+            }\n+       } finally {\n+            client = null;\n+            executorService.awaitTermination(2000, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    \/\/ -- Infrastructure\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        out.println(\"\\n**** Setup ****\\n\");\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        InetSocketAddress sa = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+\n+        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer.addHandler(new ServerRequestHandler(), \"\/http1\/exec\/\");\n+        httpURI = \"http:\/\/\" + httpTestServer.serverAuthority() + \"\/http1\/exec\/retry\";\n+        HttpsServer httpsServer = HttpsServer.create(sa, 0);\n+        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer.addHandler(new ServerRequestHandler(),\"\/https1\/exec\/\");\n+        httpsURI = \"https:\/\/\" + httpsTestServer.serverAuthority() + \"\/https1\/exec\/retry\";\n+\n+        http2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2TestServer.addHandler(new ServerRequestHandler(), \"\/http2\/exec\/\");\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/exec\/retry\";\n+        https2TestServer = HttpTestServer.of(new Http2TestServer(\"localhost\", true, sslContext));\n+        https2TestServer.addHandler(new ServerRequestHandler(), \"\/https2\/exec\/\");\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/exec\/retry\";\n+\n+        httpTestServer.start();\n+        httpsTestServer.start();\n+        http2TestServer.start();\n+        https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        Thread.sleep(100);\n+        AssertionError fail = TRACKER.check(5000);\n+        try {\n+            httpTestServer.stop();\n+            httpsTestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+        } finally {\n+            if (fail != null) throw fail;\n+        }\n+    }\n+\n+    static class ServerRequestHandler implements HttpTestHandler {\n+        ConcurrentHashMap<String,String> closedRequests = new ConcurrentHashMap<>();\n+\n+        @java.lang.Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            out.println(\"ServerRequestHandler for: \" + t.getRequestURI());\n+\n+            List<String> uuids = t.getRequestHeaders().get(\"X-uuid\");\n+            if (uuids == null || uuids.size() != 1) {\n+                readAllRequestData(t);\n+                try (OutputStream os = t.getResponseBody()) {\n+                    String msg = \"Incorrect uuid header values:[\" + uuids + \"]\";\n+                    (new RuntimeException(msg)).printStackTrace();\n+                    t.sendResponseHeaders(500, -1);\n+                    os.write(msg.getBytes(UTF_8));\n+                }\n+                return;\n+            }\n+\n+            String uuid = uuids.get(0);\n+            \/\/ retrying\n+            if (closedRequests.putIfAbsent(uuid, t.getRequestURI().toString()) == null) {\n+                if (t.getExchangeVersion() == HttpClient.Version.HTTP_1_1) {\n+                    \/\/ Throwing an exception here only causes a retry\n+                    \/\/ with HTTP_1_1 - where it forces the server to close\n+                    \/\/ the connection.\n+                    \/\/ For HTTP\/2 then throwing an IOE would cause the server\n+                    \/\/ to close the stream, and throwing anything else would\n+                    \/\/ cause it to close the connection, but neither would\n+                    \/\/ cause the client to retry.\n+                    \/\/ So we simply do not try to retry with HTTP\/2.\n+                    out.println(\"Server will close connection, client will retry: \"\n+                            + t.getRequestURI().toString());\n+                    throw new IOException(\"Closing on first request\");\n+                }\n+            }\n+\n+            \/\/ not retrying\n+            readAllRequestData(t);\n+            try (OutputStream os = t.getResponseBody()) {\n+                byte[] bytes = MESSAGE.getBytes(UTF_8);\n+                t.sendResponseHeaders(200, bytes.length);\n+                for (int i=0; i<bytes.length; i++) {\n+                    os.write(bytes, i, 1);\n+                    os.flush();\n+                    try {\n+                        Thread.sleep(RANDOM.nextInt(5));\n+                    } catch (InterruptedException x) { }\n+                }\n+            }\n+\n+            closedRequests.remove(uuid);\n+        }\n+    }\n+\n+    static void readAllRequestData(HttpTestExchange t) throws IOException {\n+        try (InputStream is = t.getRequestBody()) {\n+            is.readAllBytes();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/ExecutorShutdown.java","additions":380,"deletions":0,"binary":false,"changes":380,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import java.io.PrintStream;\n+import java.lang.management.ManagementFactory;\n@@ -28,0 +30,1 @@\n+import java.util.Arrays;\n@@ -29,0 +32,1 @@\n+import java.util.function.Predicate;\n@@ -54,0 +58,4 @@\n+        return diagnose(warnings, (t) -> t.getOutstandingHttpOperations() > 0);\n+    }\n+\n+    public StringBuilder diagnose(StringBuilder warnings, Predicate<Tracker> hasOutstanding) {\n@@ -55,1 +63,1 @@\n-            checkOutstandingOperations(warnings, tracker);\n+            checkOutstandingOperations(warnings, tracker, hasOutstanding);\n@@ -79,0 +87,16 @@\n+        return check(graceDelayMs,\n+                (t) -> t.getOutstandingHttpOperations() > 0,\n+                \"outstanding operations\", true);\n+    }\n+\n+    private void printThreads(String why, PrintStream out) {\n+        out.println(why);\n+        Arrays.stream(ManagementFactory.getThreadMXBean()\n+                        .dumpAllThreads(true, true))\n+                .forEach(out::println);\n+    }\n+\n+    public AssertionError check(long graceDelayMs,\n+                                Predicate<Tracker> hasOutstanding,\n+                                String description,\n+                                boolean printThreads) {\n@@ -80,7 +104,16 @@\n-        if (hasOutstandingOperations()) {\n-            try {\n-                Thread.sleep(graceDelayMs);\n-            } catch (InterruptedException x) {\n-                \/\/ OK\n-            }\n-            StringBuilder warnings = diagnose(new StringBuilder());\n+        graceDelayMs = Math.max(graceDelayMs, 100);\n+        long delay = Math.min(graceDelayMs, 500);\n+        var count = delay > 0 ? graceDelayMs \/ delay : 1;\n+        for (int i = 0; i < count; i++) {\n+            if (TRACKERS.stream().anyMatch(hasOutstanding)) {\n+                System.gc();\n+                try {\n+                    System.out.println(\"Waiting for HTTP operations to terminate...\");\n+                    Thread.sleep(Math.min(graceDelayMs, Math.max(delay, 1)));\n+                } catch (InterruptedException x) {\n+                    \/\/ OK\n+                }\n+            } else break;\n+        }\n+        if (TRACKERS.stream().anyMatch(hasOutstanding)) {\n+            StringBuilder warnings = diagnose(new StringBuilder(), hasOutstanding);\n@@ -88,1 +121,1 @@\n-            if (hasOutstandingOperations()) {\n+            if (TRACKERS.stream().anyMatch(hasOutstanding)) {\n@@ -92,1 +125,1 @@\n-            System.out.println(\"PASSED: No outstanding operations found in \"\n+            System.out.println(\"PASSED: No \" + description + \" found in \"\n@@ -95,0 +128,7 @@\n+        if (fail != null) {\n+            Predicate<Tracker> isAlive = Tracker::isSelectorAlive;\n+            if (printThreads && TRACKERS.stream().anyMatch(isAlive)) {\n+                printThreads(\"Some selector manager threads are still alive: \", System.out);\n+                printThreads(\"Some selector manager threads are still alive: \", System.err);\n+            }\n+        }\n@@ -111,2 +151,2 @@\n-        System.out.println(warning.toString().substring(pos));\n-        System.err.println(warning.toString().substring(pos));\n+        System.out.println(warning.substring(pos));\n+        System.err.println(warning.substring(pos));\n@@ -115,2 +155,4 @@\n-    private static void checkOutstandingOperations(StringBuilder warning, Tracker tracker) {\n-        if (tracker.getOutstandingOperations() > 0) {\n+    private static void checkOutstandingOperations(StringBuilder warning,\n+                                                   Tracker tracker,\n+                                                   Predicate<Tracker> hasOutsanding) {\n+        if (hasOutsanding.test(tracker)) {\n@@ -120,0 +162,1 @@\n+            warning.append(\"\\n\\tPending HTTP Requests: \" + tracker.getOutstandingHttpRequests());\n@@ -123,0 +166,1 @@\n+            warning.append(\"\\n\\tPending TCP connections: \" + tracker.getOutstandingTcpConnections());\n@@ -125,2 +169,3 @@\n-            System.out.println(warning.toString().substring(pos));\n-            System.err.println(warning.toString().substring(pos));\n+            warning.append(\"\\n\\tSelector alive: \" + tracker.isSelectorAlive());\n+            System.out.println(warning.substring(pos));\n+            System.err.println(warning.substring(pos));\n@@ -130,0 +175,21 @@\n+    private boolean isSelectorManager(Thread t) {\n+        String name = t.getName();\n+        if (name == null) return false;\n+        return name.contains(\"SelectorManager\");\n+    }\n+\n+    \/\/ This is a slightly more permissive check than the default checks,\n+    \/\/ it only verifies that all CFs returned by send\/sendAsync have been\n+    \/\/ completed, and that all opened channels have been closed, and that\n+    \/\/ the selector manager thread has exited.\n+    \/\/ It doesn't check that all refcounts have reached 0.\n+    \/\/ This is typically useful to only check that resources have been released.\n+    public AssertionError checkShutdown(long graceDelayMs) {\n+        Predicate<Tracker> isAlive = Tracker::isSelectorAlive;\n+        Predicate<Tracker> hasPendingRequests = (t) -> t.getOutstandingHttpRequests() > 0;\n+        Predicate<Tracker> hasPendingConnections = (t) -> t.getOutstandingTcpConnections() > 0;\n+        AssertionError failed = check(graceDelayMs,\n+                isAlive.or(hasPendingRequests).or(hasPendingConnections),\n+                \"outstanding unclosed resources\", true);\n+        return failed;\n+    }\n","filename":"test\/jdk\/java\/net\/httpclient\/ReferenceTracker.java","additions":83,"deletions":17,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -32,0 +33,1 @@\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -33,1 +35,0 @@\n-import java.util.function.Consumer;\n@@ -38,2 +39,0 @@\n-import javax.net.ssl.SSLServerSocketFactory;\n-import javax.net.ssl.SNIServerName;\n@@ -50,0 +49,2 @@\n+    static final AtomicLong IDS = new AtomicLong();\n+    final long id = IDS.incrementAndGet();\n@@ -54,1 +55,1 @@\n-    volatile boolean stopping = false;\n+    private volatile boolean stopping = false;\n@@ -58,1 +59,1 @@\n-    final HashMap<InetSocketAddress,Http2TestServerConnection> connections;\n+    final Set<Http2TestServerConnection> connections;\n@@ -60,0 +61,1 @@\n+    final String name;\n@@ -180,0 +182,1 @@\n+        this.name = \"TestServer(%d)\".formatted(id);\n@@ -196,1 +199,1 @@\n-        this.connections = new HashMap<>();\n+        this.connections = ConcurrentHashMap.newKeySet();\n@@ -235,1 +238,1 @@\n-        System.err.println(\"Using handler for: \" + bestMatch.get());\n+        System.err.println(name + \": Using handler for: \" + bestMatch.get());\n@@ -249,2 +252,2 @@\n-        System.err.printf(\"Server stopping %d connections\\n\", connections.size());\n-        for (Http2TestServerConnection connection : connections.values()) {\n+        System.err.printf(\"%s: stopping %d connections\\n\", name, connections.size());\n+        for (Http2TestServerConnection connection : connections) {\n@@ -287,1 +290,1 @@\n-            connections.put(addr, c);\n+            connections.add(c);\n@@ -291,1 +294,46 @@\n-        connections.remove(addr, c);\n+        connections.remove(c);\n+    }\n+\n+    record AcceptedConnection(Http2TestServer server,\n+                              Socket socket) {\n+        void startConnection() {\n+            String name = server.name;\n+            Http2TestServerConnection c = null;\n+            InetSocketAddress addr = null;\n+            try {\n+                addr = (InetSocketAddress) socket.getRemoteSocketAddress();\n+                System.err.println(name + \": creating connection\");\n+                c = server.createConnection(server, socket, server.exchangeSupplier);\n+                server.putConnection(addr, c);\n+                System.err.println(name + \": starting connection\");\n+                c.run();\n+                System.err.println(name + \": connection started\");\n+            } catch (Throwable e) {\n+                boolean stopping = server.stopping;\n+                if (!stopping) {\n+                    System.err.println(name + \": unexpected exception: \" + e);\n+                    e.printStackTrace();\n+                }\n+                \/\/ we should not reach here, but if we do\n+                \/\/ the connection might not have been closed\n+                \/\/ and if so then the client might wait\n+                \/\/ forever.\n+                if (c != null) {\n+                    server.removeConnection(addr, c);\n+                }\n+                try {\n+                    if (c != null) c.close(ErrorFrame.PROTOCOL_ERROR);\n+                } catch (Exception x) {\n+                    if (!stopping)\n+                        System.err.println(name + \": failed to close connection: \" + e);\n+                } finally {\n+                    try {\n+                        socket.close();\n+                    } catch (IOException x) {\n+                        if (!stopping)\n+                            System.err.println(name + \": failed to close socket: \" + e);\n+                    }\n+                }\n+                System.err.println(name + \": failed to start connection: \" + e);\n+            }\n+        }\n@@ -301,0 +349,1 @@\n+                    System.err.println(name + \": accepting connections\");\n@@ -302,2 +351,1 @@\n-                    Http2TestServerConnection c = null;\n-                    InetSocketAddress addr = null;\n+                    System.err.println(name + \": connection accepted\");\n@@ -305,4 +353,2 @@\n-                        addr = (InetSocketAddress) socket.getRemoteSocketAddress();\n-                        c = createConnection(this, socket, exchangeSupplier);\n-                        putConnection(addr, c);\n-                        c.run();\n+                        var accepted = new AcceptedConnection(this, socket);\n+                        exec.submit(accepted::startConnection);\n@@ -310,0 +356,4 @@\n+                        if (!stopping) {\n+                            System.err.println(name + \": unexpected exception: \" + e);\n+                            e.printStackTrace();\n+                        }\n@@ -314,7 +364,1 @@\n-                        if (c != null) {\n-                            removeConnection(addr, c);\n-                            c.close(ErrorFrame.PROTOCOL_ERROR);\n-                        } else {\n-                            socket.close();\n-                        }\n-                        System.err.println(\"TestServer: start exception: \" + e);\n+                        System.err.println(name + \": start exception: \" + e);\n@@ -322,0 +366,1 @@\n+                    System.err.println(name + \": stopping is: \" + stopping);\n@@ -324,1 +369,1 @@\n-                System.err.println(\"TestServer: terminating, caught \" + se);\n+                System.err.println(name + \": terminating, caught \" + se);\n@@ -330,1 +375,1 @@\n-                    System.err.println(\"TestServer: terminating, caught \" + e);\n+                    System.err.println(name + \": terminating, caught \" + e);\n@@ -333,0 +378,2 @@\n+            } finally {\n+                System.err.println(name + \": finished\");\n@@ -346,0 +393,1 @@\n+        System.err.println(name + \": closing\");\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServer.java","additions":74,"deletions":26,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -65,1 +66,0 @@\n- * @author danielfuchs\n@@ -444,0 +444,2 @@\n+        static final AtomicLong IDS = new AtomicLong();\n+\n@@ -476,0 +478,6 @@\n+        \/\/ Called from within super constructor\n+        @Override\n+        long newConnectionId(HttpClientImpl client) {\n+            return IDS.incrementAndGet();\n+        }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/java.net.http\/jdk\/internal\/net\/http\/ConnectionPoolTest.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -302,1 +302,1 @@\n-            if (unfulfilled <= maxQueueSize\/2) {\n+            if (unfulfilled <= maxQueueSize \/ 2) {\n@@ -307,1 +307,1 @@\n-                        req, requested-req, queue.size(), unfulfilled );\n+                        req, requested - req, queue.size(), unfulfilled);\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/java.net.http\/jdk\/internal\/net\/http\/SSLEchoTubeTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}