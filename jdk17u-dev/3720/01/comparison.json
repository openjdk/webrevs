{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,4 @@\n- * Utility class for zipfile name and comment decoding and encoding\n+ * Utility class for ZIP file entry name and comment decoding and encoding.\n+ * <p>\n+ * The {@code ZipCoder} for UTF-8 charset is thread safe, {@code ZipCoder}\n+ * for other charsets require external synchronization.\n@@ -160,0 +163,7 @@\n+    \/**\n+     * {@return the {@link Charset} used by this {@code ZipCoder}}\n+     *\/\n+    final Charset charset() {\n+        return this.cs;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,0 +99,2 @@\n+    \/\/ Used when decoding entry names and comments\n+    private final ZipCoder zipCoder;\n@@ -251,1 +253,2 @@\n-        this.res = new CleanableResource(this, ZipCoder.get(charset), file, mode);\n+        this.zipCoder = ZipCoder.get(charset);\n+        this.res = new CleanableResource(this, zipCoder, file, mode);\n@@ -322,1 +325,1 @@\n-            return res.zsrc.zc.toString(res.zsrc.comment);\n+            return zipCoder.toString(res.zsrc.comment);\n@@ -339,1 +342,4 @@\n-            int pos = res.zsrc.getEntryPos(name, true);\n+            \/\/ Look up the name and CEN header position of the entry.\n+            \/\/ The resolved name may include a trailing slash.\n+            \/\/ See Source::getEntryPos for details.\n+            int pos = res.zsrc.getEntryPos(name, true, zipCoder);\n@@ -372,1 +378,1 @@\n-                pos = zsrc.getEntryPos(entry.name, false);\n+                pos = zsrc.getEntryPos(entry.name, false, zipCoder);\n@@ -405,0 +411,29 @@\n+    \/**\n+     * Determines and returns a {@link ZipCoder} to use for decoding\n+     * name and comment fields of the ZIP entry identified by the {@code pos}\n+     * in the ZIP file's {@code cen}.\n+     * <p>\n+     * A ZIP entry's name and comment fields may be encoded using UTF-8, in\n+     * which case this method returns a UTF-8 capable {@code ZipCoder}. If the\n+     * entry doesn't require UTF-8, then this method returns the {@code fallback}\n+     * {@code ZipCoder}.\n+     *\n+     * @param cen the CEN\n+     * @param pos the ZIP entry's position in CEN\n+     * @param fallback the fallback ZipCoder to return if the entry doesn't require UTF-8\n+     *\/\n+    private static ZipCoder zipCoderFor(final byte[] cen, final int pos, final ZipCoder fallback) {\n+        if (fallback.isUTF8()) {\n+            \/\/ the fallback ZipCoder is capable of handling UTF-8,\n+            \/\/ so no need to parse the entry flags to determine if\n+            \/\/ the entry has UTF-8 flag.\n+            return fallback;\n+        }\n+        if ((CENFLG(cen, pos) & USE_UTF8) != 0) {\n+            \/\/ entry requires a UTF-8 ZipCoder\n+            return ZipCoder.UTF8;\n+        }\n+        \/\/ entry doesn't require a UTF-8 ZipCoder\n+        return fallback;\n+    }\n+\n@@ -595,1 +630,1 @@\n-        ZipCoder zc = res.zsrc.zipCoderForPos(pos);\n+        ZipCoder zc = zipCoderFor(cen, pos, zipCoder);\n@@ -645,1 +680,1 @@\n-        ZipCoder zc = res.zsrc.zipCoderForPos(pos);\n+        ZipCoder zc = zipCoderFor(cen, pos, zipCoder);\n@@ -713,1 +748,2 @@\n-        CleanableResource(ZipFile zf, ZipCoder zc, File file, int mode) throws IOException {\n+        CleanableResource(ZipFile zf, ZipCoder zipCoder, File file, int mode) throws IOException {\n+            assert zipCoder != null : \"null ZipCoder\";\n@@ -717,1 +753,1 @@\n-            this.zsrc = Source.get(file, (mode & OPEN_DELETE) != 0, zc);\n+            this.zsrc = Source.get(file, (mode & OPEN_DELETE) != 0, zipCoder);\n@@ -1155,0 +1191,1 @@\n+    \/\/ Implementation note: This class is thread safe.\n@@ -1164,1 +1201,0 @@\n-        private final @Stable ZipCoder zc;   \/\/ zip coder used to decode\/encode\n@@ -1200,2 +1236,3 @@\n-        \/\/ then returns the length of the entry name.\n-        private int checkAndAddEntry(int pos, int index)\n+        \/\/ then returns the length of the entry name. Uses the given zipCoder for processing the\n+        \/\/ entry name and the entry comment (if any).\n+        private int checkAndAddEntry(final int pos, final int index, final ZipCoder zipCoder)\n@@ -1232,2 +1269,1 @@\n-                ZipCoder zcp = zipCoderForPos(pos);\n-                int hash = zcp.checkedHash(cen, entryPos, nlen);\n+                int hash = zipCoder.checkedHash(cen, entryPos, nlen);\n@@ -1238,3 +1274,3 @@\n-                entries[index++] = hash;\n-                entries[index++] = next;\n-                entries[index  ] = pos;\n+                entries[index] = hash;\n+                entries[index + 1] = next;\n+                entries[index + 2] = pos;\n@@ -1385,0 +1421,10 @@\n+        \/**\n+         * A class representing a key to the Source of a ZipFile.\n+         * The Key is composed of:\n+         * - The BasicFileAttributes.fileKey() if available, or the Path of the ZIP file\n+         * if the fileKey() is not available.\n+         * - The ZIP file's last modified time (to allow for cases\n+         * where a ZIP file is re-opened after it has been modified).\n+         * - The Charset that was provided when constructing the ZipFile instance.\n+         * The unique combination of these components identifies a Source of a ZipFile.\n+         *\/\n@@ -1386,5 +1432,13 @@\n-            final BasicFileAttributes attrs;\n-            File file;\n-            final boolean utf8;\n-\n-            public Key(File file, BasicFileAttributes attrs, ZipCoder zc) {\n+            private final BasicFileAttributes attrs;\n+            private final File file;\n+            \/\/ the Charset that was provided when constructing the ZipFile instance\n+            private final Charset charset;\n+\n+            \/**\n+             * Constructs a {@code Key} to a {@code Source} of a {@code ZipFile}\n+             *\n+             * @param file    the ZIP file\n+             * @param attrs   the attributes of the ZIP file\n+             * @param charset the Charset that was provided when constructing the ZipFile instance\n+             *\/\n+            public Key(File file, BasicFileAttributes attrs, Charset charset) {\n@@ -1393,1 +1447,1 @@\n-                this.utf8 = zc.isUTF8();\n+                this.charset = charset;\n@@ -1396,0 +1450,1 @@\n+            @Override\n@@ -1397,1 +1452,1 @@\n-                long t = utf8 ? 0 : Long.MAX_VALUE;\n+                long t = charset.hashCode();\n@@ -1402,0 +1457,1 @@\n+            @Override\n@@ -1404,1 +1460,1 @@\n-                    if (key.utf8 != utf8) {\n+                    if (!charset.equals(key.charset)) {\n@@ -1428,1 +1484,1 @@\n-        static Source get(File file, boolean toDelete, ZipCoder zc) throws IOException {\n+        static Source get(File file, boolean toDelete, ZipCoder zipCoder) throws IOException {\n@@ -1433,1 +1489,1 @@\n-                                BasicFileAttributes.class), zc);\n+                                BasicFileAttributes.class), zipCoder.charset());\n@@ -1445,1 +1501,1 @@\n-            src = new Source(key, toDelete, zc);\n+            src = new Source(key, toDelete, zipCoder);\n@@ -1468,2 +1524,1 @@\n-        private Source(Key key, boolean toDelete, ZipCoder zc) throws IOException {\n-            this.zc = zc;\n+        private Source(Key key, boolean toDelete, ZipCoder zipCoder) throws IOException {\n@@ -1483,1 +1538,1 @@\n-                initCEN(-1);\n+                initCEN(-1, zipCoder);\n@@ -1640,2 +1695,2 @@\n-        \/\/ Reads zip file central directory.\n-        private void initCEN(int knownTotal) throws IOException {\n+        \/\/ Reads ZIP file central directory.\n+        private void initCEN(final int knownTotal, final ZipCoder zipCoder) throws IOException {\n@@ -1703,1 +1758,1 @@\n-                    initCEN(countCENHeaders(cen, limit));\n+                    initCEN(countCENHeaders(cen, limit), zipCoder);\n@@ -1707,0 +1762,2 @@\n+                \/\/ the ZipCoder for any non-UTF8 entries\n+                final ZipCoder entryZipCoder = zipCoderFor(cen, pos, zipCoder);\n@@ -1708,1 +1765,1 @@\n-                int nlen = checkAndAddEntry(pos, idx);\n+                int nlen = checkAndAddEntry(pos, idx, entryZipCoder);\n@@ -1773,2 +1830,2 @@\n-         * Returns the {@code pos} of the zip cen entry corresponding to the\n-         * specified entry name, or -1 if not found.\n+         * Returns the resolved name and position of the ZIP cen entry corresponding\n+         * to the specified entry name, or {@code null} if not found.\n@@ -1776,1 +1833,2 @@\n-        private int getEntryPos(String name, boolean addSlash) {\n+        private int getEntryPos(final String name, final boolean addSlash,\n+                                final ZipCoder zipCoder) {\n@@ -1792,1 +1850,1 @@\n-                        ZipCoder zc = zipCoderForPos(pos);\n+                        final ZipCoder zc = zipCoderFor(cen, pos, zipCoder);\n@@ -1809,1 +1867,1 @@\n-                            int exactPos = getEntryPos(name, false);\n+                            int exactPos = getEntryPos(name, false, zipCoder);\n@@ -1821,10 +1879,0 @@\n-        private ZipCoder zipCoderForPos(int pos) {\n-            if (zc.isUTF8()) {\n-                return zc;\n-            }\n-            if ((CENFLG(cen, pos) & USE_UTF8) != 0) {\n-                return ZipCoder.UTF8;\n-            }\n-            return zc;\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":98,"deletions":50,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import org.junit.jupiter.api.Test;\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assumptions.assumeTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8355975\n+ * @summary verify that the internal ZIP structure caching in java.util.zip.ZipFile\n+ *          uses the correct Charset when parsing the ZIP structure of a ZIP file\n+ * @run junit ZipFileCharsetTest\n+ *\/\n+public class ZipFileCharsetTest {\n+\n+    private static final String ISO_8859_15_NAME = \"ISO-8859-15\";\n+\n+    \/**\n+     * The internal implementation of java.util.zip.ZipFile maintains a cache\n+     * of the ZIP structure of each ZIP file that's currently open. This cache\n+     * helps prevent repeat parsing of the ZIP structure of the same underlying\n+     * ZIP file, every time a ZipFile instance is created for the same ZIP file.\n+     * The cache uses an internal key to map a ZIP file to the corresponding\n+     * ZIP structure that's cached.\n+     * A ZipFile can be constructed by passing a Charset which will be used to\n+     * decode the entry names (and comment) in a ZIP file.\n+     * The test verifies that when multiple ZipFile instances are\n+     * constructed using different Charsets but the same underlying ZIP file,\n+     * then the internal caching implementation of ZipFile doesn't end up using\n+     * a wrong Charset for parsing the ZIP structure of the ZIP file.\n+     *\/\n+    @Test\n+    void testCachedZipFileSource() throws Exception {\n+        \/\/ ISO-8859-15 is not a standard charset in Java. We skip this test\n+        \/\/ when it is unavailable\n+        assumeTrue(Charset.availableCharsets().containsKey(ISO_8859_15_NAME),\n+                \"skipping test since \" + ISO_8859_15_NAME + \" charset isn't available\");\n+\n+        \/\/ We choose the byte 0xA4 for entry name in the ZIP file.\n+        \/\/ 0xA4 is \"Euro sign\" in ISO-8859-15 charset and\n+        \/\/ \"Currency sign (generic)\" in ISO-8859-1 charset.\n+        final byte[] entryNameBytes = new byte[]{(byte) 0xA4}; \/\/ intentional cast\n+        final Charset euroSignCharset = Charset.forName(ISO_8859_15_NAME);\n+        final Charset currencySignCharset = ISO_8859_1;\n+\n+        final String euroSign = new String(entryNameBytes, euroSignCharset);\n+        final String currencySign = new String(entryNameBytes, currencySignCharset);\n+\n+        \/\/ create a ZIP file whose entry name is encoded using ISO-8859-15 charset\n+        final Path zip = createZIP(\"euro\", euroSignCharset, entryNameBytes);\n+\n+        \/\/ Construct a ZipFile instance using the (incorrect) charset ISO-8859-1.\n+        \/\/ While that ZipFile instance is still open (and the ZIP file structure\n+        \/\/ still cached), construct another instance for the same ZIP file, using\n+        \/\/ the (correct) charset ISO-8859-15.\n+        try (ZipFile incorrect = new ZipFile(zip.toFile(), currencySignCharset);\n+             ZipFile correct = new ZipFile(zip.toFile(), euroSignCharset)) {\n+\n+            \/\/ correct encoding should resolve the entry name to euro sign\n+            \/\/ and the entry should be thus be located\n+            assertNotNull(correct.getEntry(euroSign), \"euro sign entry missing in \" + correct);\n+            \/\/ correct encoding should not be able to find an entry name\n+            \/\/ with the currency sign\n+            assertNull(correct.getEntry(currencySign), \"currency sign entry unexpectedly found in \"\n+                    + correct);\n+\n+            \/\/ incorrect encoding should resolve the entry name to currency sign\n+            \/\/ and the entry should be thus be located by the currency sign name\n+            assertNotNull(incorrect.getEntry(currencySign), \"currency sign entry missing in \"\n+                    + incorrect);\n+            \/\/ incorrect encoding should not be able to find an entry name\n+            \/\/ with the euro sign\n+            assertNull(incorrect.getEntry(euroSign), \"euro sign entry unexpectedly found in \"\n+                    + incorrect);\n+        }\n+    }\n+\n+    \/**\n+     * Creates and return ZIP file whose entry names are encoded using the given {@code charset}\n+     *\/\n+    private static Path createZIP(final String fileNamePrefix, final Charset charset,\n+                                  final byte[] entryNameBytes) throws IOException {\n+        final Path zip = Files.createTempFile(Path.of(\".\"), fileNamePrefix, \".zip\");\n+        \/\/ create a ZIP file whose entry name(s) use the given charset\n+        try (ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(zip), charset)) {\n+            zos.putNextEntry(new ZipEntry(new String(entryNameBytes, charset)));\n+            final byte[] entryContent = \"doesnotmatter\".getBytes(US_ASCII);\n+            zos.write(entryContent);\n+            zos.closeEntry();\n+        }\n+        return zip;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ZipFileCharsetTest.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+\n+\/*\n+ * @test\n+ * @bug 8347712\n+ * @summary verify that different instances of java.util.zip.ZipFile do not share\n+ *          the same instance of (non-thread-safe) java.nio.charset.CharsetEncoder\/CharsetDecoder\n+ * @run junit ZipFileSharedSourceTest\n+ *\/\n+public class ZipFileSharedSourceTest {\n+\n+    static Path createZipFile(final Charset charset) throws Exception {\n+        final Path zipFilePath = Files.createTempFile(Path.of(\".\"), \"8347712\", \".zip\");\n+        try (OutputStream os = Files.newOutputStream(zipFilePath);\n+             ZipOutputStream zos = new ZipOutputStream(os, charset)) {\n+            final int numEntries = 10240;\n+            for (int i = 1; i <= numEntries; i++) {\n+                final ZipEntry entry = new ZipEntry(\"entry-\" + i);\n+                zos.putNextEntry(entry);\n+                zos.write(\"foo bar\".getBytes(US_ASCII));\n+                zos.closeEntry();\n+            }\n+        }\n+        return zipFilePath;\n+    }\n+\n+    static List<Arguments> charsets() {\n+        return List.of(\n+                Arguments.of(StandardCharsets.UTF_8),\n+                Arguments.of(StandardCharsets.ISO_8859_1),\n+                Arguments.of(US_ASCII)\n+        );\n+    }\n+\n+    \/**\n+     * In this test, multiple concurrent threads each create an instance of java.util.zip.ZipFile\n+     * with the given {@code charset} for the same underlying ZIP file. Each of the threads\n+     * then iterate over the entries of their ZipFile instance. The test verifies that such access,\n+     * where each thread is accessing an independent ZipFile instance corresponding to the same\n+     * underlying ZIP file, doesn't lead to unexpected failures contributed by concurrent\n+     * threads.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"charsets\")\n+    void testMultipleZipFileInstances(final Charset charset) throws Exception {\n+        final Path zipFilePath = createZipFile(charset);\n+        final int numTasks = 200;\n+        final CountDownLatch startLatch = new CountDownLatch(numTasks);\n+        final List<Future<Void>> results = new ArrayList<>();\n+        ExecutorService executor = Executors.newFixedThreadPool(\n+            numTasks, Executors.defaultThreadFactory());\n+        try {\n+            for (int i = 0; i < numTasks; i++) {\n+                final var task = new ZipEntryIteratingTask(zipFilePath, charset,\n+                        startLatch);\n+                results.add(executor.submit(task));\n+            }\n+            System.out.println(numTasks + \" tasks submitted, waiting for them to complete\");\n+            for (final Future<Void> f : results) {\n+                f.get();\n+            }\n+        } finally {\n+            executor.shutdown();\n+        }\n+        System.out.println(\"All \" + numTasks + \" tasks completed successfully\");\n+    }\n+\n+    private static final class ZipEntryIteratingTask implements Callable<Void> {\n+        private final Path file;\n+        private final Charset charset;\n+        private final CountDownLatch startLatch;\n+\n+        private ZipEntryIteratingTask(final Path file, final Charset charset,\n+                                      final CountDownLatch startLatch) {\n+            this.file = file;\n+            this.charset = charset;\n+            this.startLatch = startLatch;\n+        }\n+\n+        @Override\n+        public Void call() throws Exception {\n+            \/\/ let other tasks know we are ready to run\n+            this.startLatch.countDown();\n+            \/\/ wait for other tasks to be ready to run\n+            this.startLatch.await();\n+            \/\/ create a new instance of ZipFile and iterate over the entries\n+            try (final ZipFile zf = new ZipFile(this.file.toFile(), this.charset)) {\n+                final var entries = zf.entries();\n+                while (entries.hasMoreElements()) {\n+                    final ZipEntry ze = entries.nextElement();\n+                    \/\/ additionally exercise the ZipFile.getEntry() method\n+                    zf.getEntry(ze.getName());\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ZipFileSharedSourceTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"}]}