{"files":[{"patch":"@@ -1159,2 +1159,4 @@\n-    ::strncpy(ebuf, \"dll_load: empty filename specified\", ebuflen - 1);\n-    return NULL;\n+    if (ebuf != nullptr && ebuflen > 0) {\n+      ::strncpy(ebuf, \"dll_load: empty filename specified\", ebuflen - 1);\n+    }\n+    return nullptr;\n@@ -1163,4 +1165,16 @@\n-  \/\/ RTLD_LAZY is currently not implemented. The dl is loaded immediately with all its dependants.\n-  void * result= ::dlopen(filename, RTLD_LAZY);\n-  if (result != NULL) {\n-    Events::log_dll_message(NULL, \"Loaded shared library %s\", filename);\n+  \/\/ RTLD_LAZY has currently the same behavior as RTLD_NOW\n+  \/\/ The dl is loaded immediately with all its dependants.\n+  int dflags = RTLD_LAZY;\n+  \/\/ check for filename ending with ')', it indicates we want to load\n+  \/\/ a MEMBER module that is a member of an archive.\n+  int flen = strlen(filename);\n+  if (flen > 0 && filename[flen - 1] == ')') {\n+    dflags |= RTLD_MEMBER;\n+  }\n+\n+  void* result;\n+  const char* error_report = nullptr;\n+  JFR_ONLY(NativeLibraryLoadEvent load_event(filename, &result);)\n+  result = Aix_dlopen(filename, dflags, &error_report);\n+  if (result != nullptr) {\n+    Events::log_dll_message(nullptr, \"Loaded shared library %s\", filename);\n@@ -1173,2 +1187,1 @@\n-    const char* error_report = ::dlerror();\n-    if (error_report == NULL) {\n+    if (error_report == nullptr) {\n@@ -3121,0 +3134,7 @@\n+\n+#if INCLUDE_JFR\n+\n+void os::jfr_report_memory_info() {}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -180,0 +180,4 @@\n+\n+  static bool platform_print_native_stack(outputStream* st, const void* context, char *buf, int buf_size, address& lastpc);\n+  static void* resolve_function_descriptor(void* p);\n+\n","filename":"src\/hotspot\/os\/aix\/os_aix.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,0 +24,6 @@\n+\/\/ needs to be defined first, so that the implicit loaded xcoff.h header defines\n+\/\/ the right structures to analyze the loader header of 64 Bit executable files\n+\/\/ this is needed for rtv_linkedin_libpath() to get the linked (burned) in library\n+\/\/ search path of an XCOFF executable\n+#define __XCOFF64__\n+#include <xcoff.h>\n@@ -892,0 +898,2 @@\n+\/\/ variables needed to emulate linux behavior in os::dll_load() if library is loaded twice\n+static pthread_mutex_t g_handletable_mutex = PTHREAD_MUTEX_INITIALIZER;\n@@ -893,0 +901,264 @@\n+struct TableLocker {\n+  TableLocker() { pthread_mutex_lock(&g_handletable_mutex); }\n+  ~TableLocker() { pthread_mutex_unlock(&g_handletable_mutex); }\n+};\n+struct handletableentry{\n+    void*   handle;\n+    ino64_t inode;\n+    dev64_t devid;\n+    uint    refcount;\n+};\n+constexpr unsigned init_num_handles = 128;\n+static unsigned max_handletable = 0;\n+static unsigned g_handletable_used = 0;\n+\/\/ We start with an empty array. At first use we will dynamically allocate memory for 128 entries.\n+\/\/ If this table is full we dynamically reallocate a memory reagion of double size, and so on.\n+static struct handletableentry* p_handletable = nullptr;\n+\n+\/\/ get the library search path burned in to the executable file during linking\n+\/\/ If the libpath cannot be retrieved return an empty path\n+static const char* rtv_linkedin_libpath() {\n+  constexpr int bufsize = 4096;\n+  static char buffer[bufsize];\n+  static const char* libpath = 0;\n+\n+  \/\/ we only try to retrieve the libpath once. After that try we\n+  \/\/ let libpath point to buffer, which then contains a valid libpath\n+  \/\/ or an empty string\n+  if (libpath != nullptr) {\n+    return libpath;\n+  }\n+\n+  \/\/ retrieve the path to the currently running executable binary\n+  \/\/ to open it\n+  snprintf(buffer, 100, \"\/proc\/%ld\/object\/a.out\", (long)getpid());\n+  FILE* f = nullptr;\n+  struct xcoffhdr the_xcoff;\n+  struct scnhdr the_scn;\n+  struct ldhdr the_ldr;\n+  constexpr size_t xcoffsz = FILHSZ + _AOUTHSZ_EXEC;\n+  STATIC_ASSERT(sizeof(the_xcoff) == xcoffsz);\n+  STATIC_ASSERT(sizeof(the_scn) == SCNHSZ);\n+  STATIC_ASSERT(sizeof(the_ldr) == LDHDRSZ);\n+  \/\/ read the generic XCOFF header and analyze the substructures\n+  \/\/ to find the burned in libpath. In any case of error perform the assert\n+  if (nullptr == (f = fopen(buffer, \"r\")) ||\n+      xcoffsz != fread(&the_xcoff, 1, xcoffsz, f) ||\n+      the_xcoff.filehdr.f_magic != U64_TOCMAGIC ||\n+      0 != fseek(f, (FILHSZ + the_xcoff.filehdr.f_opthdr + (the_xcoff.aouthdr.o_snloader -1)*SCNHSZ), SEEK_SET) ||\n+      SCNHSZ != fread(&the_scn, 1, SCNHSZ, f) ||\n+      0 != strcmp(the_scn.s_name, \".loader\") ||\n+      0 != fseek(f, the_scn.s_scnptr, SEEK_SET) ||\n+      LDHDRSZ != fread(&the_ldr, 1, LDHDRSZ, f) ||\n+      0 != fseek(f, the_scn.s_scnptr + the_ldr.l_impoff, SEEK_SET) ||\n+      0 == fread(buffer, 1, bufsize, f)) {\n+    buffer[0] = 0;\n+    assert(false, \"could not retrieve burned in library path from executables loader section\");\n+  }\n+\n+  if (f) {\n+    fclose(f);\n+  }\n+  libpath = buffer;\n+\n+  return libpath;\n+}\n+\n+\/\/ Simulate the library search algorithm of dlopen() (in os::dll_load)\n+static bool search_file_in_LIBPATH(const char* path, struct stat64x* stat) {\n+  if (path == nullptr)\n+    return false;\n+\n+  char* path2 = os::strdup(path);\n+  \/\/ if exist, strip off trailing (shr_64.o) or similar\n+  char* substr;\n+  if (path2[strlen(path2) - 1] == ')' && (substr = strrchr(path2, '('))) {\n+    *substr = 0;\n+  }\n+\n+  bool ret = false;\n+  \/\/ If FilePath contains a slash character, FilePath is used directly,\n+  \/\/ and no directories are searched.\n+  \/\/ But if FilePath does not start with \/ or . we have to prepend it with .\/\n+  if (strchr(path2, '\/')) {\n+    stringStream combined;\n+    if (*path2 == '\/' || *path2 == '.') {\n+      combined.print(\"%s\", path2);\n+    } else {\n+      combined.print(\".\/%s\", path2);\n+    }\n+    ret = (0 == stat64x(combined.base(), stat));\n+    os::free(path2);\n+    return ret;\n+  }\n+\n+  const char* env = getenv(\"LIBPATH\");\n+  if (env == nullptr) {\n+    \/\/ no LIBPATH, try with LD_LIBRARY_PATH\n+    env = getenv(\"LD_LIBRARY_PATH\");\n+  }\n+\n+  stringStream Libpath;\n+  if (env == nullptr) {\n+    \/\/ no LIBPATH or LD_LIBRARY_PATH given -> try only with burned in libpath\n+    Libpath.print(\"%s\", rtv_linkedin_libpath());\n+  } else if (*env == 0) {\n+    \/\/ LIBPATH or LD_LIBRARY_PATH given but empty -> try first with burned\n+    \/\/  in libpath and with current working directory second\n+    Libpath.print(\"%s:.\", rtv_linkedin_libpath());\n+  } else {\n+    \/\/ LIBPATH or LD_LIBRARY_PATH given with content -> try first with\n+    \/\/ LIBPATH or LD_LIBRARY_PATH and second with burned in libpath.\n+    \/\/ No check against current working directory\n+    Libpath.print(\"%s:%s\", env, rtv_linkedin_libpath());\n+  }\n+\n+  char* libpath = os::strdup(Libpath.base());\n+\n+  char *saveptr, *token;\n+  for (token = strtok_r(libpath, \":\", &saveptr); token != nullptr; token = strtok_r(nullptr, \":\", &saveptr)) {\n+    stringStream combined;\n+    combined.print(\"%s\/%s\", token, path2);\n+    if ((ret = (0 == stat64x(combined.base(), stat))))\n+      break;\n+  }\n+\n+  os::free(libpath);\n+  os::free(path2);\n+  return ret;\n+}\n+\n+\/\/ specific AIX versions for ::dlopen() and ::dlclose(), which handles the struct g_handletable\n+\/\/ This way we mimic dl handle equality for a library\n+\/\/ opened a second time, as it is implemented on other platforms.\n+void* Aix_dlopen(const char* filename, int Flags, const char** error_report) {\n+  assert(error_report != nullptr, \"error_report is nullptr\");\n+  void* result;\n+  struct stat64x libstat;\n+\n+  if (false == search_file_in_LIBPATH(filename, &libstat)) {\n+    \/\/ file with filename does not exist\n+  #ifdef ASSERT\n+    result = ::dlopen(filename, Flags);\n+    assert(result == nullptr, \"dll_load: Could not stat() file %s, but dlopen() worked; Have to improve stat()\", filename);\n+  #endif\n+    *error_report = \"Could not load module .\\nSystem error: No such file or directory\";\n+    return nullptr;\n+  }\n+  else {\n+    unsigned i = 0;\n+    TableLocker lock;\n+    \/\/ check if library belonging to filename is already loaded.\n+    \/\/ If yes use stored handle from previous ::dlopen() and increase refcount\n+    for (i = 0; i < g_handletable_used; i++) {\n+      if ((p_handletable + i)->handle &&\n+          (p_handletable + i)->inode == libstat.st_ino &&\n+          (p_handletable + i)->devid == libstat.st_dev) {\n+        (p_handletable + i)->refcount++;\n+        result = (p_handletable + i)->handle;\n+        break;\n+      }\n+    }\n+    if (i == g_handletable_used) {\n+      \/\/ library not yet loaded. Check if there is space left in array\n+      \/\/ to store new ::dlopen() handle\n+      if (g_handletable_used == max_handletable) {\n+        \/\/ No place in array anymore; increase array.\n+        unsigned new_max = MAX2(max_handletable * 2, init_num_handles);\n+        struct handletableentry* new_tab = (struct handletableentry*)::realloc(p_handletable, new_max * sizeof(struct handletableentry));\n+        assert(new_tab != nullptr, \"no more memory for handletable\");\n+        if (new_tab == nullptr) {\n+          *error_report = \"dlopen: no more memory for handletable\";\n+          return nullptr;\n+        }\n+        max_handletable = new_max;\n+        p_handletable = new_tab;\n+      }\n+      \/\/ Library not yet loaded; load it, then store its handle in handle table\n+      result = ::dlopen(filename, Flags);\n+      if (result != nullptr) {\n+        g_handletable_used++;\n+        (p_handletable + i)->handle = result;\n+        (p_handletable + i)->inode = libstat.st_ino;\n+        (p_handletable + i)->devid = libstat.st_dev;\n+        (p_handletable + i)->refcount = 1;\n+      }\n+      else {\n+        \/\/ error analysis when dlopen fails\n+        *error_report = ::dlerror();\n+        if (*error_report == nullptr) {\n+          *error_report = \"dlerror returned no error description\";\n+        }\n+      }\n+    }\n+  }\n+  return result;\n+}\n+\n+bool os::pd_dll_unload(void* libhandle, char* ebuf, int ebuflen) {\n+  unsigned i = 0;\n+  bool res = false;\n+\n+  if (ebuf && ebuflen > 0) {\n+    ebuf[0] = '\\0';\n+    ebuf[ebuflen - 1] = '\\0';\n+  }\n+\n+  {\n+    TableLocker lock;\n+    \/\/ try to find handle in array, which means library was loaded by os::dll_load() call\n+    for (i = 0; i < g_handletable_used; i++) {\n+      if ((p_handletable + i)->handle == libhandle) {\n+        \/\/ handle found, decrease refcount\n+        assert((p_handletable + i)->refcount > 0, \"Sanity\");\n+        (p_handletable + i)->refcount--;\n+        if ((p_handletable + i)->refcount > 0) {\n+          \/\/ if refcount is still >0 then we have to keep library and just return true\n+          return true;\n+        }\n+        \/\/ refcount == 0, so we have to ::dlclose() the lib\n+        \/\/ and delete the entry from the array.\n+        break;\n+      }\n+    }\n+\n+    \/\/ If we reach this point either the libhandle was found with refcount == 0, or the libhandle\n+    \/\/ was not found in the array at all. In both cases we have to ::dlclose the lib and perform\n+    \/\/ the error handling. In the first case we then also have to delete the entry from the array\n+    \/\/ while in the second case we simply have to nag.\n+    res = (0 == ::dlclose(libhandle));\n+    if (!res) {\n+      \/\/ error analysis when dlopen fails\n+      const char* error_report = ::dlerror();\n+      if (error_report == nullptr) {\n+        error_report = \"dlerror returned no error description\";\n+      }\n+      if (ebuf != nullptr && ebuflen > 0) {\n+        snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+      }\n+      assert(false, \"os::pd_dll_unload() ::dlclose() failed\");\n+    }\n+\n+    if (i < g_handletable_used) {\n+      if (res) {\n+        \/\/ First case: libhandle was found (with refcount == 0) and ::dlclose successful,\n+        \/\/ so delete entry from array\n+        g_handletable_used--;\n+        \/\/ If the entry was the last one of the array, the previous g_handletable_used--\n+        \/\/ is sufficient to remove the entry from the array, otherwise we move the last\n+        \/\/ entry of the array to the place of the entry we want to remove and overwrite it\n+        if (i < g_handletable_used) {\n+          *(p_handletable + i) = *(p_handletable + g_handletable_used);\n+          (p_handletable + g_handletable_used)->handle = nullptr;\n+        }\n+      }\n+    }\n+    else {\n+      \/\/ Second case: libhandle was not found (library was not loaded by os::dll_load())\n+      \/\/ therefore nag\n+      assert(false, \"os::pd_dll_unload() library was not loaded by os::dll_load()\");\n+    }\n+  }\n+\n+  \/\/ Update the dll cache\n+  LoadedLibraries::reload();\n@@ -894,0 +1166,2 @@\n+  return res;\n+} \/\/ end: os::pd_dll_unload()\n","filename":"src\/hotspot\/os\/aix\/porting_aix.cpp","additions":274,"deletions":0,"binary":false,"changes":274,"status":"modified"},{"patch":"@@ -110,0 +110,2 @@\n+void* Aix_dlopen(const char* filename, int Flags, const char** error_report);\n+\n","filename":"src\/hotspot\/os\/aix\/porting_aix.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2618,0 +2618,52 @@\n+\n+#if INCLUDE_JFR\n+\n+void os::jfr_report_memory_info() {\n+#ifdef __APPLE__\n+  mach_task_basic_info info;\n+  mach_msg_type_number_t count = MACH_TASK_BASIC_INFO_COUNT;\n+\n+  kern_return_t ret = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)&info, &count);\n+  if (ret == KERN_SUCCESS) {\n+    \/\/ Send the RSS JFR event\n+    EventResidentSetSize event;\n+    event.set_size(info.resident_size);\n+    \/\/ We've seen that resident_size_max sometimes trails resident_size with one page.\n+    \/\/ Make sure we always report size <= peak\n+    event.set_peak(MAX2(info.resident_size_max, info.resident_size));\n+    event.commit();\n+  } else {\n+    \/\/ Log a warning\n+    static bool first_warning = true;\n+    if (first_warning) {\n+      log_warning(jfr)(\"Error fetching RSS values: task_info failed\");\n+      first_warning = false;\n+    }\n+  }\n+\n+#endif \/\/ __APPLE__\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n+bool os::pd_dll_unload(void* libhandle, char* ebuf, int ebuflen) {\n+\n+  if (ebuf && ebuflen > 0) {\n+    ebuf[0] = '\\0';\n+    ebuf[ebuflen - 1] = '\\0';\n+  }\n+\n+  bool res = (0 == ::dlclose(libhandle));\n+  if (!res) {\n+    \/\/ error analysis when dlopen fails\n+    const char* error_report = ::dlerror();\n+    if (error_report == nullptr) {\n+      error_report = \"dlerror returned no error description\";\n+    }\n+    if (ebuf != nullptr && ebuflen > 0) {\n+      snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+    }\n+  }\n+\n+  return res;\n+} \/\/ end: os::pd_dll_unload()\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -5563,0 +5563,22 @@\n+\n+bool os::pd_dll_unload(void* libhandle, char* ebuf, int ebuflen) {\n+\n+  if (ebuf && ebuflen > 0) {\n+    ebuf[0] = '\\0';\n+    ebuf[ebuflen - 1] = '\\0';\n+  }\n+\n+  bool res = (0 == ::dlclose(libhandle));\n+  if (!res) {\n+    \/\/ error analysis when dlopen fails\n+    const char* error_report = ::dlerror();\n+    if (error_report == nullptr) {\n+      error_report = \"dlerror returned no error description\";\n+    }\n+    if (ebuf != nullptr && ebuflen > 0) {\n+      snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+    }\n+  }\n+\n+  return res;\n+} \/\/ end: os::pd_dll_unload()\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -53,0 +53,11 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/support\/jfrNativeLibraryLoadEvent.hpp\"\n+#endif\n+\n+#ifdef AIX\n+#include \"loadlib_aix.hpp\"\n+#include \"os_aix.hpp\"\n+#endif\n+#ifdef LINUX\n+#include \"os_linux.hpp\"\n+#endif\n@@ -700,4 +711,18 @@\n-  const char* l_path = LINUX_ONLY(os::Linux::dll_path(lib))\n-                       NOT_LINUX(\"<not available>\");\n-  if (l_path == NULL) l_path = \"<not available>\";\n-  int res = ::dlclose(lib);\n+  \/\/ os::Linux::dll_path returns a pointer to a string that is owned by the dynamic loader. Upon\n+  \/\/ calling dlclose the dynamic loader may free the memory containing the string, thus we need to\n+  \/\/ copy the string to be able to reference it after dlclose.\n+  const char* l_path = nullptr;\n+\n+#ifdef LINUX\n+  char* l_pathdup = nullptr;\n+  l_path = os::Linux::dll_path(lib);\n+  if (l_path != nullptr) {\n+    l_path = l_pathdup = os::strdup(l_path);\n+  }\n+#endif  \/\/ LINUX\n+\n+  JFR_ONLY(NativeLibraryUnloadEvent unload_event(l_path);)\n+\n+  if (l_path == nullptr) {\n+    l_path = \"<not available>\";\n+  }\n@@ -705,2 +730,5 @@\n-  if (res == 0) {\n-    Events::log_dll_message(NULL, \"Unloaded shared library \\\"%s\\\" [\" INTPTR_FORMAT \"]\",\n+  char ebuf[1024];\n+  bool res = os::pd_dll_unload(lib, ebuf, sizeof(ebuf));\n+\n+  if (res) {\n+    Events::log_dll_message(nullptr, \"Unloaded shared library \\\"%s\\\" [\" INTPTR_FORMAT \"]\",\n@@ -710,7 +738,2 @@\n-    const char* error_report = ::dlerror();\n-    if (error_report == NULL) {\n-      error_report = \"dlerror returned no error description\";\n-    }\n-\n-    Events::log_dll_message(NULL, \"Attempt to unload shared library \\\"%s\\\" [\" INTPTR_FORMAT \"] failed, %s\",\n-                            l_path, p2i(lib), error_report);\n+    Events::log_dll_message(nullptr, \"Attempt to unload shared library \\\"%s\\\" [\" INTPTR_FORMAT \"] failed, %s\",\n+                            l_path, p2i(lib), ebuf);\n@@ -718,1 +741,2 @@\n-                  l_path, p2i(lib), error_report);\n+                  l_path, p2i(lib), ebuf);\n+    JFR_ONLY(unload_event.set_error_msg(ebuf);)\n@@ -720,0 +744,1 @@\n+  LINUX_ONLY(os::free(l_pathdup));\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":39,"deletions":14,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,643 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/jvmtiAgent.hpp\"\n+\n+#include \"cds\/cds_globals.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"jni.h\"\n+#include \"jvm_io.h\"\n+#include \"jvmtifiles\/jvmtiEnv.hpp\"\n+#include \"prims\/jvmtiEnvBase.hpp\"\n+#include \"prims\/jvmtiExport.hpp\"\n+#include \"prims\/jvmtiAgentList.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"utilities\/defaultStream.hpp\"\n+\n+static inline const char* copy_string(const char* str) {\n+  return str != nullptr ? os::strdup(str, mtServiceability) : nullptr;\n+}\n+\n+\/\/ Returns the lhs before '=', parsed_options output param gets the rhs.\n+static const char* split_options_and_allocate_copy(const char* options, const char** parsed_options) {\n+  assert(options != nullptr, \"invariant\");\n+  assert(parsed_options != nullptr, \"invariant\");\n+  const char* const equal_sign = strchr(options, '=');\n+  const size_t length = strlen(options);\n+  size_t name_length = length;\n+  if (equal_sign != nullptr) {\n+    name_length = equal_sign - options;\n+    const size_t options_length = length - name_length - 1;\n+    *parsed_options = copy_string(equal_sign + 1);\n+  } else {\n+    *parsed_options = nullptr;\n+    name_length = length;\n+  }\n+  char* const name = AllocateHeap(name_length + 1, mtServiceability);\n+  jio_snprintf(name, name_length + 1, \"%s\", options);\n+  assert(strncmp(name, options, name_length) == 0, \"invariant\");\n+  return name;\n+}\n+\n+JvmtiAgent::JvmtiAgent(const char* name, const char* options, bool is_absolute_path, bool dynamic \/* false *\/) :\n+  _initialization_time(),\n+  _initialization_duration(),\n+  _next(nullptr),\n+  _name(copy_string(name)),\n+  _options(copy_string(options)),\n+  _os_lib(nullptr),\n+  _os_lib_path(nullptr),\n+  _jplis(nullptr),\n+  _loaded(false),\n+  _absolute_path(is_absolute_path),\n+  _static_lib(false),\n+  _instrument_lib(strcmp(name, \"instrument\") == 0),\n+  _dynamic(dynamic),\n+  _xrun(false) {}\n+\n+JvmtiAgent* JvmtiAgent::next() const {\n+  return _next;\n+}\n+\n+void JvmtiAgent::set_next(JvmtiAgent* agent) {\n+  _next = agent;\n+}\n+\n+const char* JvmtiAgent::name() const {\n+  return _name;\n+}\n+\n+const char* JvmtiAgent::options() const {\n+  return _options;\n+}\n+\n+void* JvmtiAgent::os_lib() const {\n+  return _os_lib;\n+}\n+\n+void JvmtiAgent::set_os_lib(void* os_lib) {\n+  _os_lib = os_lib;\n+}\n+\n+void JvmtiAgent::set_os_lib_path(const char* path) {\n+  assert(path != nullptr, \"invariant\");\n+  if (_os_lib_path == nullptr) {\n+    _os_lib_path = copy_string(path);\n+  }\n+  assert(strcmp(_os_lib_path, path) == 0, \"invariant\");\n+}\n+\n+const char* JvmtiAgent::os_lib_path() const {\n+  return _os_lib_path;\n+}\n+\n+bool JvmtiAgent::is_loaded() const {\n+  return _loaded;\n+}\n+\n+void JvmtiAgent::set_loaded() {\n+  _loaded = true;\n+}\n+\n+bool JvmtiAgent::is_absolute_path() const {\n+  return _absolute_path;\n+}\n+\n+bool JvmtiAgent::is_static_lib() const {\n+  return _static_lib;\n+}\n+\n+void JvmtiAgent::set_static_lib() {\n+  _static_lib = true;\n+}\n+\n+bool JvmtiAgent::is_dynamic() const {\n+  return _dynamic;\n+}\n+\n+bool JvmtiAgent:: is_instrument_lib() const {\n+  return _instrument_lib;\n+}\n+\n+bool JvmtiAgent::is_xrun() const {\n+  return _xrun;\n+}\n+\n+void JvmtiAgent::set_xrun() {\n+  _xrun = true;\n+}\n+\n+bool JvmtiAgent::is_jplis() const {\n+  return _jplis != nullptr;\n+}\n+\n+const Ticks& JvmtiAgent::initialization_time() const {\n+  return _initialization_time;\n+}\n+\n+const Tickspan& JvmtiAgent::initialization_duration() const {\n+  return _initialization_duration;\n+}\n+\n+bool JvmtiAgent::is_initialized() const {\n+  return _initialization_time.value() != 0;\n+}\n+\n+void JvmtiAgent::initialization_begin() {\n+  assert(!is_initialized(), \"invariant\");\n+  _initialization_time = Ticks::now();\n+}\n+\n+void JvmtiAgent::initialization_end() {\n+  assert(is_initialized(), \"invariant\");\n+  assert(_initialization_duration.value() == 0, \"invariant\");\n+  _initialization_duration = Ticks::now() - initialization_time();\n+}\n+\n+\/*\n+ * The implementation builds a mapping bewteen JvmtiEnvs and JPLIS agents,\n+ * using internal JDK implementation knowledge about the way JPLIS agents\n+ * store data in their JvmtiEnv local storage.\n+ *\n+ * Please see JPLISAgent.h and JPLISAgent.c in module java.instrument.\n+ *\n+ * jvmtierror = (*jvmtienv)->SetEnvironmentLocalStorage( jvmtienv, &(agent->mNormalEnvironment));\n+ *\n+ * It is the pointer to the field agent->mNormalEnvironment that is stored in the jvmtiEnv local storage.\n+ * It has the following type:\n+ *\n+ * struct _JPLISEnvironment {\n+ *   jvmtiEnv*   mJVMTIEnv;         \/\/ the JVMTI environment\n+ *   JPLISAgent* mAgent;            \/\/ corresponding agent\n+ *   jboolean    mIsRetransformer;  \/\/ indicates if special environment\n+ * };\n+ *\n+ * We mirror this struct to get the mAgent field as an identifier.\n+ *\/\n+\n+struct JPLISEnvironmentMirror {\n+  jvmtiEnv* mJVMTIEnv; \/\/ the JVMTI environment\n+  const void* mAgent;  \/\/ corresponding agent\n+  jboolean mIsRetransformer; \/\/ indicates if special environment\n+};\n+\n+static inline const JPLISEnvironmentMirror* get_env_local_storage(JvmtiEnv* env) {\n+  assert(env != nullptr, \"invariant\");\n+  return reinterpret_cast<const JPLISEnvironmentMirror*>(env->get_env_local_storage());\n+}\n+\n+bool JvmtiAgent::is_jplis(JvmtiEnv* env) const {\n+  assert(env != nullptr, \"invariant\");\n+  assert(is_instrument_lib(), \"invariant\");\n+  const JPLISEnvironmentMirror* const jplis_env = get_env_local_storage(env);\n+  return jplis_env != nullptr && _jplis == jplis_env->mAgent;\n+}\n+\n+void JvmtiAgent::set_jplis(const void* jplis) {\n+  assert(jplis != nullptr, \"invaiant\");\n+  assert(is_instrument_lib(), \"invariant\");\n+  assert(_jplis == nullptr, \"invariant\");\n+  if (_options != nullptr) {\n+    \/\/ For JPLIS agents, update with the java name and options.\n+    os::free(const_cast<char*>(_name));\n+    const char* options = _options;\n+    _name = split_options_and_allocate_copy(options, &_options);\n+    os::free(const_cast<char*>(options));\n+  }\n+  _jplis = jplis;\n+}\n+\n+static const char* not_found_error_msg = \"Could not find agent library \";\n+static const char* missing_module_error_msg = \"\\nModule java.instrument may be missing from runtime image.\";\n+static char ebuf[1024];\n+static char buffer[JVM_MAXPATHLEN];\n+\n+static void vm_exit(const JvmtiAgent* agent, const char* sub_msg1, const char* sub_msg2) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(sub_msg1 != nullptr, \"invariant\");\n+  assert(!agent->is_instrument_lib() || sub_msg2 != nullptr, \"invariant\");\n+  const size_t len = strlen(not_found_error_msg) + strlen(agent->name()) + strlen(sub_msg1) + strlen(&ebuf[0]) + 1 + (agent->is_instrument_lib() ? strlen(sub_msg2) : 0);\n+  char* buf = NEW_C_HEAP_ARRAY(char, len, mtServiceability);\n+  if (agent->is_instrument_lib()) {\n+    jio_snprintf(buf, len, \"%s%s%s%s%s\", not_found_error_msg, agent->name(), sub_msg1, &ebuf[0], sub_msg2);\n+  } else {\n+    jio_snprintf(buf, len, \"%s%s%s%s\", not_found_error_msg, agent->name(), sub_msg1, &ebuf[0]);\n+  }\n+  vm_exit_during_initialization(buf, nullptr);\n+  FREE_C_HEAP_ARRAY(char, buf);\n+}\n+\n+#ifdef ASSERT\n+static void assert_preload(const JvmtiAgent* agent) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(!agent->is_loaded(), \"invariant\");\n+}\n+#endif\n+\n+\/\/ Check for a statically linked-in agent, i.e. in the executable.\n+\/\/ This should be the first function called when loading an agent. It is a bit special:\n+\/\/ For statically linked agents we can't rely on os_lib == nullptr because\n+\/\/ statically linked agents could have a handle of RTLD_DEFAULT which == 0 on some platforms.\n+\/\/ If this function returns true, then agent->is_static_lib() && agent->is_loaded().\n+static bool load_agent_from_executable(JvmtiAgent* agent, const char* on_load_symbols[], size_t num_symbol_entries) {\n+  DEBUG_ONLY(assert_preload(agent);)\n+  assert(on_load_symbols != nullptr, \"invariant\");\n+  return os::find_builtin_agent(agent, &on_load_symbols[0], num_symbol_entries);\n+}\n+\n+\/\/ Load the library from the absolute path of the agent, if available.\n+static void* load_agent_from_absolute_path(JvmtiAgent* agent, bool vm_exit_on_error) {\n+  DEBUG_ONLY(assert_preload(agent);)\n+  assert(agent->is_absolute_path(), \"invariant\");\n+  assert(!agent->is_instrument_lib(), \"invariant\");\n+  void* const library = os::dll_load(agent->name(), &ebuf[0], sizeof ebuf);\n+  if (library == nullptr && vm_exit_on_error) {\n+    vm_exit(agent, \" in absolute path, with error: \", nullptr);\n+  }\n+  return library;\n+}\n+\n+\/\/ Agents with relative paths are loaded from the standard dll directory.\n+static void* load_agent_from_relative_path(JvmtiAgent* agent, bool vm_exit_on_error) {\n+  DEBUG_ONLY(assert_preload(agent);)\n+  assert(!agent->is_absolute_path(), \"invariant\");\n+  const char* const name = agent->name();\n+  void* library = nullptr;\n+  \/\/ Try to load the agent from the standard dll directory\n+  if (os::dll_locate_lib(&buffer[0], sizeof buffer, Arguments::get_dll_dir(), name)) {\n+    library = os::dll_load(&buffer[0], &ebuf[0], sizeof ebuf);\n+  }\n+  if (library == nullptr && os::dll_build_name(&buffer[0], sizeof buffer, name)) {\n+    \/\/ Try the library path directory.\n+    library = os::dll_load(&buffer[0], &ebuf[0], sizeof ebuf);\n+    if (library != nullptr) {\n+      return library;\n+    }\n+    if (vm_exit_on_error) {\n+      vm_exit(agent, \" on the library path, with error: \", missing_module_error_msg);\n+    }\n+  }\n+  return library;\n+}\n+\n+\/\/ For absolute and relative paths.\n+static void* load_library(JvmtiAgent* agent, const char* on_symbols[], size_t num_symbol_entries, bool vm_exit_on_error) {\n+  return agent->is_absolute_path() ? load_agent_from_absolute_path(agent, vm_exit_on_error) :\n+                                     load_agent_from_relative_path(agent, vm_exit_on_error);\n+}\n+\n+\/\/ Type for the Agent_OnLoad and JVM_OnLoad entry points.\n+extern \"C\" {\n+  typedef jint(JNICALL* OnLoadEntry_t)(JavaVM*, char*, void*);\n+}\n+\n+\/\/ Find the OnLoad entry point for -agentlib:  -agentpath:   -Xrun agents.\n+\/\/ num_symbol_entries must be passed-in since only the caller knows the number of symbols in the array.\n+static OnLoadEntry_t lookup_On_Load_entry_point(JvmtiAgent* agent, const char* on_load_symbols[], size_t num_symbol_entries) {\n+  assert(agent != nullptr, \"invariant\");\n+  if (!agent->is_loaded()) {\n+    if (!load_agent_from_executable(agent, on_load_symbols, num_symbol_entries)) {\n+      void* const library = load_library(agent, on_load_symbols, num_symbol_entries, \/* vm exit on error *\/ true);\n+      assert(library != nullptr, \"invariant\");\n+      agent->set_os_lib(library);\n+      agent->set_loaded();\n+    }\n+  }\n+  assert(agent->is_loaded(), \"invariant\");\n+  \/\/ Find the OnLoad function.\n+  return CAST_TO_FN_PTR(OnLoadEntry_t, os::find_agent_function(agent, false, on_load_symbols, num_symbol_entries));\n+}\n+\n+static OnLoadEntry_t lookup_JVM_OnLoad_entry_point(JvmtiAgent* lib) {\n+  const char* on_load_symbols[] = JVM_ONLOAD_SYMBOLS;\n+  return lookup_On_Load_entry_point(lib, on_load_symbols, sizeof(on_load_symbols) \/ sizeof(char*));\n+}\n+\n+static OnLoadEntry_t lookup_Agent_OnLoad_entry_point(JvmtiAgent* agent) {\n+  const char* on_load_symbols[] = AGENT_ONLOAD_SYMBOLS;\n+  return lookup_On_Load_entry_point(agent, on_load_symbols, sizeof(on_load_symbols) \/ sizeof(char*));\n+}\n+\n+void JvmtiAgent::convert_xrun_agent() {\n+  assert(is_xrun(), \"invariant\");\n+  assert(!is_loaded(), \"invariant\");\n+  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_PRIMORDIAL, \"invalid init sequence\");\n+  OnLoadEntry_t on_load_entry = lookup_JVM_OnLoad_entry_point(this);\n+  \/\/ If there is an JVM_OnLoad function it will get called later,\n+  \/\/ otherwise see if there is an Agent_OnLoad.\n+  if (on_load_entry == nullptr) {\n+    on_load_entry = lookup_Agent_OnLoad_entry_point(this);\n+    if (on_load_entry == nullptr) {\n+      vm_exit_during_initialization(\"Could not find JVM_OnLoad or Agent_OnLoad function in the library\", name());\n+    }\n+    _xrun = false; \/\/ converted\n+  }\n+}\n+\n+\/\/ Called after the VM is initialized for -Xrun agents which have not been converted to JVMTI agents.\n+static bool invoke_JVM_OnLoad(JvmtiAgent* agent) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(agent->is_xrun(), \"invariant\");\n+  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_PRIMORDIAL, \"invalid init sequence\");\n+  OnLoadEntry_t on_load_entry = lookup_JVM_OnLoad_entry_point(agent);\n+  if (on_load_entry == nullptr) {\n+    vm_exit_during_initialization(\"Could not find JVM_OnLoad function in -Xrun library\", agent->name());\n+  }\n+  \/\/ Invoke the JVM_OnLoad function\n+  JavaThread* thread = JavaThread::current();\n+  ThreadToNativeFromVM ttn(thread);\n+  HandleMark hm(thread);\n+  extern struct JavaVM_ main_vm;\n+  const jint err = (*on_load_entry)(&main_vm, const_cast<char*>(agent->options()), nullptr);\n+  if (err != JNI_OK) {\n+    vm_exit_during_initialization(\"-Xrun library failed to init\", agent->name());\n+  }\n+  return true;\n+}\n+\n+\/\/ The newest jvmtiEnv is appended to the list,\n+\/\/ hence the JvmtiEnvIterator order is from oldest to newest.\n+static JvmtiEnv* get_last_jplis_jvmtienv() {\n+  JvmtiEnvIterator it;\n+  JvmtiEnv* env = it.first();\n+  assert(env != nullptr, \"invariant\");\n+  JvmtiEnv* next = it.next(env);\n+  while (next != nullptr) {\n+    assert(env != nullptr, \"invariant\");\n+    \/\/ get_env_local_storage() lets us find which JVMTI env map to which JPLIS agent.\n+    if (next->get_env_local_storage() == nullptr) {\n+      JvmtiEnv* temp = it.next(next);\n+      if (temp != nullptr) {\n+        next = temp;\n+        continue;\n+      }\n+      break;\n+    }\n+    env = next;\n+    next = it.next(env);\n+  }\n+  assert(env != nullptr, \"invariant\");\n+  assert(env->get_env_local_storage() != nullptr, \"invariant\");\n+  return env;\n+}\n+\n+\/\/ Associate the last, i.e. most recent, JvmtiEnv that is a JPLIS agent with the current agent.\n+static void convert_to_jplis(JvmtiAgent* agent) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(agent->is_instrument_lib(), \"invariant\");\n+  JvmtiEnv* const env = get_last_jplis_jvmtienv();\n+  assert(env != nullptr, \"invariant\");\n+  const JPLISEnvironmentMirror* const jplis_env = get_env_local_storage(env);\n+  assert(jplis_env != nullptr, \"invaiant\");\n+  assert(reinterpret_cast<JvmtiEnv*>(jplis_env->mJVMTIEnv) == env, \"invariant\");\n+  agent->set_jplis(jplis_env->mAgent);\n+}\n+\n+\/\/ Use this for JavaThreads and state is _thread_in_vm.\n+class AgentJavaThreadEventTransition : StackObj {\n+ private:\n+  ResourceMark _rm;\n+  ThreadToNativeFromVM _transition;\n+  HandleMark _hm;\n+ public:\n+  AgentJavaThreadEventTransition(JavaThread* thread) : _rm(), _transition(thread), _hm(thread) {};\n+};\n+\n+class AgentEventMark : StackObj {\n+ private:\n+  JavaThread* _thread;\n+  JNIEnv* _jni_env;\n+  JvmtiThreadState::ExceptionState _saved_exception_state;\n+\n+ public:\n+  AgentEventMark(JavaThread* thread) : _thread(thread),\n+                                       _jni_env(thread->jni_environment()),\n+                                       _saved_exception_state(JvmtiThreadState::ES_CLEARED) {\n+    JvmtiThreadState* state = thread->jvmti_thread_state();\n+    \/\/ we are before an event.\n+    \/\/ Save current jvmti thread exception state.\n+    if (state != nullptr) {\n+      _saved_exception_state = state->get_exception_state();\n+    }\n+    thread->push_jni_handle_block();\n+    assert(thread == JavaThread::current(), \"thread must be current!\");\n+    thread->frame_anchor()->make_walkable();\n+  }\n+\n+  ~AgentEventMark() {\n+    _thread->pop_jni_handle_block();\n+    JvmtiThreadState* state = _thread->jvmti_thread_state();\n+    \/\/ we are continuing after an event.\n+    if (state != nullptr) {\n+      \/\/ Restore the jvmti thread exception state.\n+      state->restore_exception_state(_saved_exception_state);\n+    }\n+  }\n+};\n+\n+class AgentThreadEventMark : public AgentEventMark {\n+ private:\n+  jobject _jthread;\n+ public:\n+  AgentThreadEventMark(JavaThread* thread) : AgentEventMark(thread),\n+                                             _jthread(JNIHandles::make_local(thread, thread->threadObj())) {}\n+  jthread jni_thread() { return (jthread)_jthread; }\n+};\n+\n+static void unload_library(JvmtiAgent* agent, void* library) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(agent->is_loaded(), \"invariant\");\n+  if (!agent->is_static_lib()) {\n+    assert(library != nullptr, \"invariant\");\n+    os::dll_unload(library);\n+  }\n+}\n+\n+\/\/ type for the Agent_OnAttach entry point\n+extern \"C\" {\n+  typedef jint(JNICALL* OnAttachEntry_t)(JavaVM*, char*, void*);\n+}\n+\n+\/\/ Loading the agent by invoking Agent_OnAttach.\n+\/\/ This function is called before the agent is added to JvmtiAgentList.\n+static bool invoke_Agent_OnAttach(JvmtiAgent* agent, outputStream* st) {\n+  if (!EnableDynamicAgentLoading) {\n+    st->print_cr(\"Dynamic agent loading is not enabled. \"\n+                 \"Use -XX:+EnableDynamicAgentLoading to launch target VM.\");\n+    return false;\n+  }\n+  DEBUG_ONLY(assert_preload(agent);)\n+  assert(agent->is_dynamic(), \"invariant\");\n+  assert(st != nullptr, \"invariant\");\n+  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_LIVE, \"not in live phase!\");\n+  const char* on_attach_symbols[] = AGENT_ONATTACH_SYMBOLS;\n+  const size_t num_symbol_entries = ARRAY_SIZE(on_attach_symbols);\n+  void* library = nullptr;\n+  bool previously_loaded;\n+  if (load_agent_from_executable(agent, &on_attach_symbols[0], num_symbol_entries)) {\n+    previously_loaded = JvmtiAgentList::is_static_lib_loaded(agent->name());\n+  } else {\n+    library = load_library(agent, &on_attach_symbols[0], num_symbol_entries, \/* vm_exit_on_error *\/ false);\n+    if (library == nullptr) {\n+      st->print_cr(\"%s was not loaded.\", agent->name());\n+      if (*ebuf != '\\0') {\n+        st->print_cr(\"%s\", &ebuf[0]);\n+      }\n+      return false;\n+    }\n+    agent->set_os_lib_path(&buffer[0]);\n+    agent->set_os_lib(library);\n+    agent->set_loaded();\n+    previously_loaded = JvmtiAgentList::is_dynamic_lib_loaded(library);\n+  }\n+\n+  \/\/ Print warning if agent was not previously loaded and EnableDynamicAgentLoading not enabled on the command line.\n+  if (!previously_loaded && !FLAG_IS_CMDLINE(EnableDynamicAgentLoading) && !agent->is_instrument_lib()) {\n+    jio_fprintf(defaultStream::error_stream(),\n+      \"WARNING: A JVM TI agent has been loaded dynamically (%s)\\n\"\n+      \"WARNING: If a serviceability tool is in use, please run with -XX:+EnableDynamicAgentLoading to hide this warning\\n\"\n+      \"WARNING: Dynamic loading of agents will be disallowed by default in a future release\\n\", agent->name());\n+  }\n+\n+  assert(agent->is_loaded(), \"invariant\");\n+  \/\/ The library was loaded so we attempt to lookup and invoke the Agent_OnAttach function.\n+  OnAttachEntry_t on_attach_entry = CAST_TO_FN_PTR(OnAttachEntry_t,\n+                                                   os::find_agent_function(agent, false, &on_attach_symbols[0], num_symbol_entries));\n+\n+  if (on_attach_entry == nullptr) {\n+    st->print_cr(\"%s is not available in %s\", on_attach_symbols[0], agent->name());\n+    unload_library(agent, library);\n+    return false;\n+  }\n+\n+  \/\/ Invoke the Agent_OnAttach function\n+  JavaThread* thread = JavaThread::current();\n+  jint result = JNI_ERR;\n+  {\n+    extern struct JavaVM_ main_vm;\n+    AgentThreadEventMark jem(thread);\n+    AgentJavaThreadEventTransition jet(thread);\n+\n+    agent->initialization_begin();\n+\n+    result = (*on_attach_entry)(&main_vm, (char*)agent->options(), nullptr);\n+\n+    agent->initialization_end();\n+\n+    \/\/ Agent_OnAttach may have used JNI\n+    if (thread->is_pending_jni_exception_check()) {\n+      thread->clear_pending_jni_exception_check();\n+    }\n+  }\n+\n+  \/\/ Agent_OnAttach may have used JNI\n+  if (thread->has_pending_exception()) {\n+    thread->clear_pending_exception();\n+  }\n+\n+  st->print_cr(\"return code: %d\", result);\n+\n+  if (result != JNI_OK) {\n+    unload_library(agent, library);\n+    return false;\n+  }\n+\n+  if (agent->is_instrument_lib()) {\n+    \/\/ Convert the instrument lib to the actual JPLIS \/ javaagent it represents.\n+    convert_to_jplis(agent);\n+  }\n+  return true;\n+}\n+\n+\/\/ CDS dumping does not support native JVMTI agent.\n+\/\/ CDS dumping supports Java agent if the AllowArchivingWithJavaAgent diagnostic option is specified.\n+static void check_cds_dump(JvmtiAgent* agent) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(CDSConfig::is_dumping_archive(), \"invariant\");\n+  if (!agent->is_instrument_lib()) {\n+    vm_exit_during_cds_dumping(\"CDS dumping does not support native JVMTI agent, name\", agent->name());\n+  }\n+  if (!AllowArchivingWithJavaAgent) {\n+    vm_exit_during_cds_dumping(\n+      \"Must enable AllowArchivingWithJavaAgent in order to run Java agent during CDS dumping\");\n+  }\n+}\n+\n+\/\/ Loading the agent by invoking Agent_OnLoad.\n+static bool invoke_Agent_OnLoad(JvmtiAgent* agent) {\n+  assert(agent != nullptr, \"invariant\");\n+  assert(!agent->is_xrun(), \"invariant\");\n+  assert(!agent->is_dynamic(), \"invariant\");\n+  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_ONLOAD, \"invariant\");\n+  if (CDSConfig::is_dumping_archive()) {\n+    check_cds_dump(agent);\n+  }\n+  OnLoadEntry_t on_load_entry = lookup_Agent_OnLoad_entry_point(agent);\n+  if (on_load_entry == nullptr) {\n+    vm_exit_during_initialization(\"Could not find Agent_OnLoad function in the agent library\", agent->name());\n+  }\n+  \/\/ Invoke the Agent_OnLoad function\n+  extern struct JavaVM_ main_vm;\n+  if ((*on_load_entry)(&main_vm, const_cast<char*>(agent->options()), nullptr) != JNI_OK) {\n+    vm_exit_during_initialization(\"agent library failed Agent_OnLoad\", agent->name());\n+  }\n+  \/\/ Convert the instrument lib to the actual JPLIS \/ javaagent it represents.\n+  if (agent->is_instrument_lib()) {\n+    convert_to_jplis(agent);\n+  }\n+  return true;\n+}\n+\n+bool JvmtiAgent::load(outputStream* st \/* nullptr *\/) {\n+  if (is_xrun()) {\n+    return invoke_JVM_OnLoad(this);\n+  }\n+  return is_dynamic() ? invoke_Agent_OnAttach(this, st) : invoke_Agent_OnLoad(this);\n+}\n+\n+extern \"C\" {\n+  typedef void (JNICALL* Agent_OnUnload_t)(JavaVM*);\n+}\n+\n+void JvmtiAgent::unload() {\n+  const char* on_unload_symbols[] = AGENT_ONUNLOAD_SYMBOLS;\n+  \/\/ Find the Agent_OnUnload function.\n+  Agent_OnUnload_t unload_entry = CAST_TO_FN_PTR(Agent_OnUnload_t,\n+                                                 os::find_agent_function(this, false, &on_unload_symbols[0], ARRAY_SIZE(on_unload_symbols)));\n+  if (unload_entry != nullptr) {\n+    \/\/ Invoke the Agent_OnUnload function\n+    JavaThread* thread = JavaThread::current();\n+    ThreadToNativeFromVM ttn(thread);\n+    HandleMark hm(thread);\n+    extern struct JavaVM_ main_vm;\n+    (*unload_entry)(&main_vm);\n+  }\n+}\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.cpp","additions":643,"deletions":0,"binary":false,"changes":643,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_PRIMS_JVMTIAGENT_HPP\n+#define SHARE_PRIMS_JVMTIAGENT_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+class JvmtiEnv;\n+class outputStream;\n+\n+\/\/ Represents an agent launched on the command-line by -agentlib, -agentpath or -Xrun.\n+\/\/ Also agents loaded dynamically during runtime, for example using the Attach API.\n+class JvmtiAgent : public CHeapObj<mtServiceability> {\n+  friend class JvmtiAgentList;\n+ private:\n+  Ticks _initialization_time;\n+  Tickspan _initialization_duration;\n+  JvmtiAgent* _next;\n+  const char* _name;\n+  const char* _options;\n+  void* _os_lib;\n+  const char* _os_lib_path;\n+  const void* _jplis;\n+  bool _loaded;\n+  bool _absolute_path;\n+  bool _static_lib;\n+  bool _instrument_lib;\n+  bool _dynamic;\n+  bool _xrun;\n+\n+  JvmtiAgent* next() const;\n+  void set_next(JvmtiAgent* agent);\n+  void convert_xrun_agent();\n+  void set_xrun();\n+\n+ public:\n+  JvmtiAgent(const char* name, const char* options, bool is_absolute_path, bool dynamic = false);\n+  const char* name() const NOT_JVMTI_RETURN_(nullptr);\n+  const char* options() const;\n+  bool is_absolute_path() const NOT_JVMTI_RETURN_(false);\n+  void* os_lib() const NOT_JVMTI_RETURN_(nullptr);\n+  void set_os_lib(void* os_lib) NOT_JVMTI_RETURN;\n+  const char* os_lib_path() const;\n+  void set_os_lib_path(const char* path) NOT_JVMTI_RETURN;\n+  bool is_static_lib() const NOT_JVMTI_RETURN_(false);\n+  void set_static_lib() NOT_JVMTI_RETURN;\n+  bool is_dynamic() const;\n+  bool is_xrun() const;\n+  bool is_instrument_lib() const;\n+  bool is_loaded() const NOT_JVMTI_RETURN_(false);\n+  void set_loaded() NOT_JVMTI_RETURN;\n+  bool is_jplis() const;\n+  bool is_jplis(JvmtiEnv* env) const;\n+  void set_jplis(const void* jplis);\n+  bool is_initialized() const;\n+  void initialization_begin();\n+  void initialization_end();\n+  const Ticks& initialization_time() const;\n+  const Tickspan& initialization_duration() const;\n+\n+  bool load(outputStream* st = nullptr);\n+  void unload();\n+};\n+\n+#endif \/\/ SHARE_PRIMS_JVMTIAGENT_HPP\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.hpp","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/jvmtiAgentList.hpp\"\n+\n+#include \"prims\/jvmtiEnvBase.hpp\"\n+#include \"prims\/jvmtiExport.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+\n+JvmtiAgent* JvmtiAgentList::_list = nullptr;\n+\n+\/\/ Selection as a function of the filter.\n+JvmtiAgent* JvmtiAgentList::Iterator::select(JvmtiAgent* agent) const {\n+  while (agent != nullptr) {\n+    if (_filter == ALL) {\n+      return agent;\n+    } else if (_filter == NOT_XRUN) {\n+      if (!agent->is_xrun()) {\n+        return agent;\n+      }\n+    } else if (_filter == JAVA) {\n+      if (agent->is_jplis()) {\n+        return agent;\n+      }\n+    } else if (_filter == NATIVE) {\n+      if (!agent->is_jplis() && !agent->is_xrun()) {\n+        return agent;\n+      }\n+    } else {\n+      assert(_filter == XRUN, \"invariant\");\n+      if (agent->is_xrun()) {\n+        return agent;\n+      }\n+    }\n+    agent = agent->next();\n+  }\n+  return nullptr;\n+}\n+\n+static inline JvmtiAgent* head(JvmtiAgent** list) {\n+  assert(list != nullptr, \"invariant\");\n+  return Atomic::load_acquire(list);\n+}\n+\n+\n+\/\/ The storage list is a single cas-linked-list, to allow for concurrent iterations.\n+\/\/ Especially during initial loading of agents, there exist an order requirement to iterate oldest -> newest.\n+\/\/ Our concurrent storage linked-list is newest -> oldest.\n+\/\/ The correct order is preserved by the iterator, by storing a filtered set of entries in a stack.\n+JvmtiAgentList::Iterator::Iterator(JvmtiAgent** list, Filter filter) :\n+  _stack(new GrowableArrayCHeap<JvmtiAgent*, mtServiceability>(16)), _filter(filter) {\n+  JvmtiAgent* next = head(list);\n+  while (next != nullptr) {\n+    next = select(next);\n+    if (next != nullptr) {\n+      _stack->push(next);\n+      next = next->next();\n+    }\n+  }\n+}\n+\n+bool JvmtiAgentList::Iterator::has_next() const {\n+  assert(_stack != nullptr, \"invariant\");\n+  return _stack->is_nonempty();\n+}\n+\n+const JvmtiAgent* JvmtiAgentList::Iterator::next() const {\n+  assert(has_next(), \"invariant\");\n+  return _stack->pop();\n+}\n+\n+JvmtiAgent* JvmtiAgentList::Iterator::next() {\n+  return const_cast<JvmtiAgent*>(const_cast<const Iterator*>(this)->next());\n+}\n+\n+JvmtiAgentList::Iterator JvmtiAgentList::agents() {\n+  return Iterator(&_list, Iterator::NOT_XRUN);\n+}\n+\n+JvmtiAgentList::Iterator JvmtiAgentList::java_agents() {\n+  return Iterator(&_list, Iterator::JAVA);\n+}\n+\n+JvmtiAgentList::Iterator JvmtiAgentList::native_agents() {\n+  return Iterator(&_list, Iterator::NATIVE);\n+}\n+\n+JvmtiAgentList::Iterator JvmtiAgentList::xrun_agents() {\n+  return Iterator(&_list, Iterator::XRUN);\n+}\n+\n+JvmtiAgentList::Iterator JvmtiAgentList::all() {\n+  return Iterator(&_list, Iterator::ALL);\n+}\n+\n+void JvmtiAgentList::add(JvmtiAgent* agent) {\n+  assert(agent != nullptr, \"invariant\");\n+  JvmtiAgent* next;\n+  do {\n+    next = head(&_list);\n+    agent->set_next(next);\n+  } while (Atomic::cmpxchg(&_list, next, agent) != next);\n+}\n+\n+void JvmtiAgentList::add(const char* name, char* options, bool absolute_path) {\n+  add(new JvmtiAgent(name, options, absolute_path));\n+}\n+\n+void JvmtiAgentList::add_xrun(const char* name, char* options, bool absolute_path) {\n+  JvmtiAgent* agent = new JvmtiAgent(name, options, absolute_path);\n+  agent->set_xrun();\n+  add(agent);\n+}\n+\n+#ifdef ASSERT\n+static void assert_initialized(JvmtiAgentList::Iterator& it) {\n+  while (it.has_next()) {\n+    assert(it.next()->is_initialized(), \"invariant\");\n+  }\n+}\n+#endif\n+\n+\/\/ In case an agent did not enable the VMInit callback, or if it is an -Xrun agent,\n+\/\/ it gets an initializiation timestamp here.\n+void JvmtiAgentList::initialize() {\n+  Iterator it = all();\n+  while (it.has_next()) {\n+    JvmtiAgent* agent = it.next();\n+    if (!agent->is_initialized()) {\n+      agent->initialization_begin();\n+    }\n+  }\n+  DEBUG_ONLY(Iterator assert_it = all(); assert_initialized(assert_it);)\n+}\n+\n+void JvmtiAgentList::convert_xrun_agents() {\n+  Iterator it = xrun_agents();\n+  while (it.has_next()) {\n+    it.next()->convert_xrun_agent();\n+  }\n+}\n+\n+class JvmtiPhaseTransition : public StackObj {\n+ public:\n+  JvmtiPhaseTransition() {\n+    assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_PRIMORDIAL, \"invalid init sequence\");\n+    JvmtiExport::enter_onload_phase();\n+  }\n+  ~JvmtiPhaseTransition() {\n+    assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_ONLOAD, \"invariant\");\n+    JvmtiExport::enter_primordial_phase();\n+  }\n+};\n+\n+static void load_agents(JvmtiAgentList::Iterator& it) {\n+  while (it.has_next()) {\n+    it.next()->load();\n+  }\n+}\n+\n+\/\/ Invokes Agent_OnLoad for -agentlib:.. -agentpath:  and converted -Xrun agents.\n+\/\/ Called very early -- before JavaThreads exist\n+void JvmtiAgentList::load_agents() {\n+  \/\/ Convert -Xrun to -agentlib: if there is no JVM_OnLoad\n+  convert_xrun_agents();\n+  JvmtiPhaseTransition transition;\n+  Iterator it = agents();\n+  ::load_agents(it);\n+}\n+\n+\/\/ Launch -Xrun agents\n+void JvmtiAgentList::load_xrun_agents() {\n+  assert(JvmtiEnvBase::get_phase() == JVMTI_PHASE_PRIMORDIAL, \"invalid init sequence\");\n+  Iterator it = xrun_agents();\n+  ::load_agents(it);\n+}\n+\n+\/\/ Invokes Agent_OnAttach for agents loaded dynamically during runtime.\n+jint JvmtiAgentList::load_agent(const char* agent_name, const char* absParam,\n+                           const char* options, outputStream* st) {\n+  \/\/ The abs parameter should be \"true\" or \"false\"\n+  const bool is_absolute_path = (absParam != nullptr) && (strcmp(absParam, \"true\") == 0);\n+  JvmtiAgent* const agent = new JvmtiAgent(agent_name, options, is_absolute_path, \/* dynamic agent *\/ true);\n+  if (agent->load(st)) {\n+    add(agent);\n+  } else {\n+    delete agent;\n+  }\n+  \/\/ Agent_OnAttach executed so completion status is JNI_OK\n+  return JNI_OK;\n+}\n+\n+\/\/ Send any Agent_OnUnload notifications\n+void JvmtiAgentList::unload_agents() {\n+  Iterator it = agents();\n+  while (it.has_next()) {\n+    it.next()->unload();\n+  }\n+}\n+\n+\/\/ Return true if a statically linked agent is on the list\n+bool JvmtiAgentList::is_static_lib_loaded(const char* name) {\n+  JvmtiAgentList::Iterator it = JvmtiAgentList::agents();\n+  while (it.has_next()) {\n+    JvmtiAgent* const agent = it.next();\n+    if (agent->is_static_lib() && strcmp(agent->name(), name) == 0) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\/\/ Return true if a agent library on the list\n+bool JvmtiAgentList::is_dynamic_lib_loaded(void* os_lib) {\n+  JvmtiAgentList::Iterator it = JvmtiAgentList::agents();\n+  while (it.has_next()) {\n+    JvmtiAgent* const agent = it.next();\n+    if (!agent->is_static_lib() && agent->os_lib() == os_lib) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+static bool match(JvmtiEnv* env, const JvmtiAgent* agent, const void* os_module_address) {\n+  assert(env != nullptr, \"invariant\");\n+  assert(agent != nullptr, \"invariant\");\n+  if (agent->is_static_lib()) {\n+    return os::get_default_process_handle() == os_module_address;\n+  }\n+  if (agent->os_lib() != os_module_address) {\n+    return false;\n+  }\n+  return agent->is_instrument_lib() ? agent->is_jplis(env) : true;\n+}\n+\n+\/\/ The function pointer is a JVMTI callback function.\n+\/\/ Find the os module (dll) that exports this function.\n+\/\/ Now we can map a JVMTI env to its corresponding agent.\n+JvmtiAgent* JvmtiAgentList::lookup(JvmtiEnv* env, void* f_ptr) {\n+  assert(env != nullptr, \"invariant\");\n+  assert(f_ptr != nullptr, \"invariant\");\n+  static char ebuf[1024];\n+  static char buffer[JVM_MAXPATHLEN];\n+  int offset;\n+  if (!os::dll_address_to_library_name(reinterpret_cast<address>(f_ptr), &buffer[0], JVM_MAXPATHLEN, &offset)) {\n+    return nullptr;\n+  }\n+  assert(buffer[0] != '\\0', \"invariant\");\n+  const void* const os_module_address = reinterpret_cast<address>(f_ptr) - offset;\n+\n+  JvmtiAgentList::Iterator it = JvmtiAgentList::agents();\n+  while (it.has_next()) {\n+    JvmtiAgent* const agent = it.next();\n+    if (match(env, agent, os_module_address)) {\n+      agent->set_os_lib_path(&buffer[0]);\n+      return agent;\n+    }\n+  }\n+  return nullptr;\n+}\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.cpp","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_PRIMS_JVMTIAGENTLIST_HPP\n+#define SHARE_PRIMS_JVMTIAGENTLIST_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"prims\/jvmtiAgent.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+class JvmtiEnv;\n+\n+\/\/ Maintains a single cas linked-list of JvmtiAgents.\n+class JvmtiAgentList : AllStatic {\n+  friend class Iterator;\n+  friend class JvmtiExport;\n+ public:\n+  class Iterator {\n+    friend class JvmtiAgentList;\n+   private:\n+    enum Filter {\n+      JAVA,\n+      NATIVE,\n+      XRUN,\n+      NOT_XRUN,\n+      ALL\n+    };\n+    GrowableArrayCHeap<JvmtiAgent*, mtServiceability>* _stack;\n+    const Filter _filter;\n+    Iterator() : _stack(nullptr), _filter(ALL) {}\n+    Iterator(JvmtiAgent** list, Filter filter);\n+    JvmtiAgent* select(JvmtiAgent* agent) const;\n+   public:\n+    bool has_next() const NOT_JVMTI_RETURN_(false);\n+    JvmtiAgent* next() NOT_JVMTI_RETURN_(nullptr);\n+    const JvmtiAgent* next() const NOT_JVMTI_RETURN_(nullptr);\n+    ~Iterator() { delete _stack; }\n+  };\n+\n+ private:\n+  static JvmtiAgent* _list;\n+\n+  static Iterator all();\n+  static void initialize();\n+  static void convert_xrun_agents();\n+\n+ public:\n+  static void add(JvmtiAgent* agent) NOT_JVMTI_RETURN;\n+  static void add(const char* name, char* options, bool absolute_path) NOT_JVMTI_RETURN;\n+  static void add_xrun(const char* name, char* options, bool absolute_path) NOT_JVMTI_RETURN;\n+\n+  static void load_agents() NOT_JVMTI_RETURN;\n+  static jint load_agent(const char* agent, const char* absParam,\n+                         const char* options, outputStream* st) NOT_JVMTI_RETURN_(0);\n+  static void load_xrun_agents() NOT_JVMTI_RETURN;\n+  static void unload_agents() NOT_JVMTI_RETURN;\n+\n+  static bool is_static_lib_loaded(const char* name);\n+  static bool is_dynamic_lib_loaded(void* os_lib);\n+\n+  static JvmtiAgent* lookup(JvmtiEnv* env, void* f_ptr);\n+\n+  static Iterator agents() NOT_JVMTI({ Iterator it; return it; });\n+  static Iterator java_agents();\n+  static Iterator native_agents();\n+  static Iterator xrun_agents();\n+};\n+\n+#endif \/\/ SHARE_PRIMS_JVMTIAGENTLIST_HPP\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.hpp","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -1042,0 +1042,1 @@\n+  static bool pd_dll_unload(void* libhandle, char* ebuf, int ebuflen);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}