{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * or remote mode according to test command line options.\n+ * mode according to test command line options.\n@@ -97,1 +97,1 @@\n-     * Defines mode (local or remote) and type of connector (default, launching,\n+     * Defines mode (local) and type of connector (default, launching,\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/Launcher.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,1888 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.share.jpda;\n-\n-import java.io.*;\n-import java.net.*;\n-import java.util.*;\n-\n-import nsk.share.*;\n-import nsk.share.jpda.*;\n-\n-\/**\n- * <code>BindServer<\/code> is an utility to perform JPDA tests\n- * in remote mode across network.\n- * <p>\n- * This utility should be started on remote host. It listens for connection\n- * from JPDA tests and launches debuggee VM on this host.\n- * <p>\n- * <code>BindServer<\/code> works together with <code>Binder<\/code> used in\n- * the tests to incapsulate actions required for launching debuggee VM.\n- * See <code>ProcessBinder<\/code> and <code>DebugeeArgumentHandler<\/code>\n- * to know how run tests in local or remote mode across network or\n- * on an single host.\n- * <p>\n- * <code>BindServer<\/code> is started on the debuggee host.\n- * It recognizes following command line options:\n- * <ul>\n- *   <li><code>-bind.file=<i>filename<\/i><\/code> - configuration file\n- *   <li><code>-verbose<\/code> - print verbose messages\n- * <\/ul>\n- * <p>\n- * Only required option is <code>-bind.file<\/code>, which points to the file\n- * where pairs of particular pathes are presented as they are seen from\n- * both hosts along with some other <code>BindServer<\/code> options.\n- * See <i>execution.html<\/i> to read more about format of bind-file.\n- *\n- * @see DebugeeBinder\n- * @see DebugeeArgumentHandler\n- *\/\n-public class BindServer implements Finalizable {\n-\n-    \/** Version of <code>BindServer<\/code> implementation. *\/\n-    public static final long VERSION = 2;\n-\n-    \/** Timeout in milliseconds used for waiting for inner threads. *\/\n-    private static long THREAD_TIMEOUT = DebugeeBinder.THREAD_TIMEOUT;      \/\/ milliseconds\n-\n-    private static int PASSED = 0;\n-    private static int FAILED = 2;\n-    private static int JCK_BASE = 95;\n-\n-    private static int TRACE_LEVEL_PACKETS = 10;\n-    private static int TRACE_LEVEL_THREADS = 20;\n-    private static int TRACE_LEVEL_ACTIONS = 30;\n-    private static int TRACE_LEVEL_SOCKETS = 40;\n-    private static int TRACE_LEVEL_IO = 50;\n-\n-    private static String pathSeparator = System.getProperty(\"path.separator\");\n-    private static String fileSeparator = System.getProperty(\"file.separator\");\n-\n-    private static char pathSeparatorChar = pathSeparator.charAt(0);\n-    private static char fileSeparatorChar = fileSeparator.charAt(0);\n-\n-    private static Log log = null;\n-    private static Log.Logger logger = null;\n-    private static ArgumentHandler argHandler = null;\n-\n-    private static String pathConvertions[][] = null;\n-\n-    private ListeningThread listeningThread = null;\n-\n-    private int totalRequests = 0;\n-    private int acceptedRequests = 0;\n-    private int unauthorizedRequests = 0;\n-    private int busyRequests = 0;\n-\n-    \/**\n-     * Start <code>BindServer<\/code> utility from command line.\n-     * This method invokes <code>run()<\/code> and redirects output\n-     * to <code>System.err<\/code>.\n-     *\n-     * @param argv list of command line arguments\n-     *\/\n-    public static void main (String argv[]) {\n-        System.exit(run(argv,System.err) + JCK_BASE);\n-    }\n-\n-    \/**\n-     * Start <code>BindServer<\/code> utility from JCK-compatible\n-     * environment.\n-     *\n-     * @param argv list of command line arguments\n-     * @param out outpur stream for log messages\n-     *\n-     * @return FAILED if error occured\n-     *         PASSED oterwise\n-     *\/\n-    public static int run(String argv[], PrintStream out) {\n-        return new BindServer().runIt(argv, out);\n-    }\n-\n-    \/**\n-     * Perform execution of <code>BindServer<\/code>.\n-     * This method handles command line arguments, starts seperate\n-     * thread for listening connection from test on remote host,\n-     * and waits for command \"exit\" from a user.\n-     * Finally it closes all conections and prints connections\n-     * statiscs.\n-     *\n-     * @param argv list of command line arguments\n-     * @param out outpur stream for log messages\n-     *\n-     * @return FAILED if error occured\n-     *         PASSED oterwise\n-     *\/\n-    private int runIt(String argv[], PrintStream out) {\n-        try {\n-            argHandler = new ArgumentHandler(argv);\n-        } catch (ArgumentHandler.BadOption e) {\n-            out.println(\"ERROR: \" + e.getMessage());\n-            return FAILED;\n-        }\n-\n-        if (argHandler.getArguments().length > 0) {\n-            out.println(\"ERROR: \" + \"Too many positional arguments in command line\");\n-            return FAILED;\n-        }\n-\n-        log = new Log(out, argHandler);\n-        log.enableErrorsSummary(false);\n-        log.enableVerboseOnError(false);\n-        logger = new Log.Logger(log, \"\");\n-\n-        Finalizer bindFinalizer = new Finalizer(this);\n-        bindFinalizer.activate();\n-\n-        logger.trace(TRACE_LEVEL_THREADS, \"BindServer: starting main thread\");\n-\n-        logger.display(\"Listening to port: \" + argHandler.getBindPortNumber());\n-        logger.display(\"Authorizing host: \" + argHandler.getDebuggerHost());\n-\n-        pathConvertions = new String[][] {\n-            { \"TESTED_JAVA_HOME\", argHandler.getDebuggerJavaHome(), argHandler.getDebugeeJavaHome() },\n-            { \"TESTBASE\", argHandler.getDebuggerTestbase(), argHandler.getDebugeeTestbase() },\n-            { \"WORKDIR\", argHandler.getDebuggerWorkDir(), argHandler.getDebugeeWorkDir() }\n-        };\n-\n-        logger.display(\"Translating pathes:\");\n-        for (int i = 0; i < pathConvertions.length; i++) {\n-            logger.display(pathConvertions[i][0] + \":\" +\"\\n\"\n-                         + \"  \" + pathConvertions[i][1] + \"\\n\"\n-                         + \"  =>\" + \"\\n\"\n-                         + \"  \" + pathConvertions[i][2]);\n-        }\n-\n-        String windir = argHandler.getDebugeeWinDir();\n-        if (!(windir == null || windir.equals(\"\"))) {\n-            logger.display(\"Using WINDIR: \\n\"\n-                         + \"  \" + argHandler.getDebugeeWinDir());\n-        }\n-\n-        BufferedReader stdIn = new BufferedReader(\n-            new InputStreamReader(System.in));\n-\n-        listeningThread = new ListeningThread(this);\n-        listeningThread.bind();\n-        listeningThread.start();\n-\n-        System.out.println(\"\\n\"\n-                          + \"BindServer started\" + \"\\n\"\n-                          + \"Type \\\"exit\\\" to shut down BindServer\"\n-                          + \"\\n\");\n-\n-        for (;;) {\n-            try {\n-                String userInput = stdIn.readLine();\n-                if (userInput == null || userInput.equals(\"exit\")\n-                        || userInput.equals(\"quit\")) {\n-                    logger.display(\"Shutting down BindServer\");\n-                    stdIn.close();\n-                    stdIn = null;\n-                    break;\n-                } else if (userInput.trim().equals(\"\")) {\n-                    continue;\n-                } else {\n-                    System.out.println(\"ERROR: Unknown command: \" + userInput);\n-                }\n-            } catch(IOException e) {\n-                e.printStackTrace(log.getOutStream());\n-                throw new Failure(\"Caught exception while reading console command:\\n\\t\"\n-                                    + e);\n-            }\n-        }\n-\n-        printSummary(System.out);\n-\n-        logger.trace(TRACE_LEVEL_THREADS, \"BindServer: exiting main thread\");\n-        try {\n-            finalize();\n-        } catch (Throwable e) {\n-            e.printStackTrace(log.getOutStream());\n-            logger.complain(\"Caught exception while finalization of BindServer:\\n\\t\" + e);\n-        }\n-\n-        return PASSED;\n-    }\n-\n-    \/**\n-     * Print usefull summary statistics about connections occured.\n-     *\n-     * @param out output stream for printing statistics\n-     *\/\n-    private void printSummary(PrintStream out) {\n-        out.println(\"\\n\"\n-                + \"Connections summary:\" + \"\\n\"\n-                + \"  Tolal connections:     \" + totalRequests + \"\\n\"\n-                + \"  Accepted authorized:   \" + acceptedRequests + \"\\n\"\n-                + \"  Rejected unauthorized  \" + unauthorizedRequests + \"\\n\"\n-                + \"  Rejected being busy:   \" + busyRequests + \"\\n\");\n-    };\n-\n-    \/**\n-     * Check if given <code>path<\/code> starts with the specified prefix taking\n-     * into account difference between <code>slashChar<code> used in <code>path<\/code>\n-     * and <code>fileSeparatorChar<\/code> used in <code>prefix<\/code>.\n-     *\n-     * @param path path to check\n-     * @param prefix prefix to compare with\n-     * @param slashChar file separator used in <code>path<\/code>\n-     *\/\n-    private static boolean checkPathPrefix(String path, String prefix, char slashChar) {\n-        int prefixLength = prefix.length();\n-        if (prefixLength > path.length()) {\n-            return false;\n-        }\n-        for (int i = 0; i < prefixLength; i++) {\n-            char pathChar = path.charAt(i);\n-            char prefixChar = prefix.charAt(i);\n-\n-            if (pathChar != prefixChar) {\n-                if ((pathChar == slashChar || pathChar == fileSeparatorChar\n-                         || pathChar == '\\\\' || pathChar == '\/')\n-                    && (prefixChar == slashChar || prefixChar == fileSeparatorChar\n-                         || prefixChar == '\\\\' || prefixChar == '\/')) {\n-                    \/\/ do nothing\n-                } else {\n-                    return false;\n-                }\n-            }\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Convert given path according to list of prefixes from\n-     * <code>pathConvertions<\/code> table.\n-     *\n-     * @param path path for converting\n-     * @param slash file separator used in <code>path<\/code>\n-     * @param name path identifier used for error messages\n-     * @param strict force throwing Failure if path is not matched\n-     *\n-     * @return string with the converted path\n-     *\n-     * @throws Failure if path does not matched for translation\n-     *\/\n-    private static String convertPath(String path, String slash, String name, boolean strict) {\n-        if (path == null)\n-            return null;\n-\n-        char slashChar = slash.charAt(0);\n-\n-        for (int i = 0; i < pathConvertions.length; i++) {\n-            String from = pathConvertions[i][1];\n-            String to = pathConvertions[i][2];\n-            if (checkPathPrefix(path, from, slashChar)) {\n-                return (to + path.substring(from.length())).replace(slashChar, fileSeparatorChar);\n-            }\n-        }\n-        if (strict) {\n-            throw new Failure(\"Path not matched for translation \" + name + \":\\n\\t\" + path);\n-        }\n-        return path;\n-    }\n-\n-    \/**\n-     * Convert given list of pathes according to list of prefixes from\n-     * <code>pathConvertions<\/code> table by invoking <code>convertPath()<\/code>\n-     * for each path from the list.\n-     *\n-     * @param list list of pathes for converting\n-     * @param slash file separator used in pathes\n-     * @param name path identifier used for error messages\n-     * @param strict force throwing Failure if some path is not matched\n-     *\n-     * @return list of strings with converted pathes\n-     *\n-     * @throws Failure if some path does not matched for translation\n-     *\n-     * @see #convertPath()\n-     *\/\n-    private static String[] convertPathes(String[] list, String slash, String name, boolean strict) {\n-        String[] converted = new String[list.length];\n-        for (int i = 0; i < list.length; i++) {\n-            converted[i] = convertPath(list[i], slash, name, strict);\n-        }\n-        return converted;\n-    }\n-\n-    \/**\n-     * Pause current thread for specified amount of time in milliseconds,\n-     * This method uses <code>Object.wait(long)<\/code> method as a reliable\n-     * method which prevents whole VM from suspending.\n-     *\n-     * @param millisecs - amount of time in milliseconds\n-     *\/\n-    private static void sleeping(int millisecs) {\n-        Object obj = new Object();\n-\n-        synchronized(obj) {\n-            try {\n-                obj.wait(millisecs);\n-            } catch (InterruptedException e) {\n-                e.printStackTrace(log.getOutStream());\n-                new Failure(\"Thread interrupted while sleeping:\\n\\t\" + e);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Wait for given thread finished for specified timeout or\n-     * interrupt this thread if not finished.\n-     *\n-     * @param thr thread to wait for\n-     * @param millisecs timeout in milliseconds\n-     *\/\n-    private static void waitInterruptThread(Thread thr, long millisecs) {\n-        if (thr != null) {\n-            String name = thr.getName();\n-            try {\n-                if (thr.isAlive()) {\n-                    logger.trace(TRACE_LEVEL_THREADS, \"Waiting for thread: \" + name);\n-                    thr.join(millisecs);\n-                }\n-            } catch (InterruptedException e) {\n-                e.printStackTrace(log.getOutStream());\n-                throw new Failure (\"Thread interrupted while waiting for another thread:\\n\\t\"\n-                                     + e);\n-            } finally {\n-                if (thr.isAlive()) {\n-                    logger.trace(TRACE_LEVEL_THREADS, \"Interrupting not finished thread: \" + name);\n-                    thr.interrupt();\n-\/*\n-                    logger.display(\"Stopping not finished thread: \" + thr);\n-                    thr.stop();\n- *\/\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Wait for given thread finished for default timeout\n-     * <code>THREAD_TIMEOUT<\/code> and\n-     * interrupt this thread if not finished.\n-     *\n-     * @param thr thread to wait for\n-     *\/\n-    private static void waitInterruptThread(Thread thr) {\n-        waitInterruptThread(thr, THREAD_TIMEOUT);\n-    }\n-\n-    \/**\n-     * Close <code>BindServer<\/code> by finishing all threads and closing\n-     * all conections.\n-     *\/\n-    public synchronized void close() {\n-        if (listeningThread != null) {\n-            listeningThread.close();\n-            listeningThread = null;\n-        }\n-    }\n-\n-    \/**\n-     * Make finalization of <code>BindServer<\/code> object by invoking\n-     * method <code>close()<\/code>.\n-     *\n-     * @see #close()\n-     *\/\n-    protected void finalize() throws Throwable {\n-        close();\n-        super.finalize();\n-    }\n-\n-    \/**\n-     * Make finalization of <code>BindServer<\/code> object at program exit\n-     * by invoking method <code>finalize()<\/code>.\n-     *\n-     * @see #finalize()\n-     *\/\n-    public void finalizeAtExit() throws Throwable {\n-        finalize();\n-        logger.trace(TRACE_LEVEL_THREADS, \"BindServer: finalization at exit completed\");\n-    }\n-\n-\/\/\/\/\/\/\/\/\/ Thread listening a TCP\/IP socket \/\/\/\/\/\/\/\/\/\/\n-\n-    \/**\n-     * An inner thread used for listening connection from remote test\n-     * and starting separate serving thread for each accepted connection.\n-     *\n-     * @see ServingThread\n-     *\/\n-    private static class ListeningThread extends Thread {\n-        private volatile boolean shouldStop = false;\n-        private volatile boolean closed = false;\n-\n-        private BindServer owner = null;\n-        private volatile ServingThread servingThread = null;\n-        private volatile int taskCount = 0;\n-\n-        private ObjectOutputStream socOut = null;\n-        private ObjectInputStream socIn = null;\n-\n-        private String autorizedHostName = argHandler.getDebuggerHost();\n-        private InetAddress autorizedInetAddresses[] = null;\n-        private int port = argHandler.getBindPortNumber();\n-        private Socket socket = null;\n-        private ServerSocket serverSocket = null;\n-        private InetAddress clientInetAddr = null;\n-        private String clientHostName = null;\n-        private SocketConnection connection = null;\n-\n-        \/**\n-         * Make listening thread for given <code>BindServer<\/code> object\n-         * as an owner and bind it to listening port by invoking method\n-         * <code>bind()<\/code>.\n-         *\n-         * @see bind()\n-         *\/\n-        public ListeningThread(BindServer owner) {\n-            super(\"ListeningThread\");\n-            this.owner = owner;\n-            try {\n-                autorizedInetAddresses = InetAddress.getAllByName(autorizedHostName);\n-            } catch (UnknownHostException e) {\n-                e.printStackTrace(log.getOutStream());\n-                throw new Failure(\"Cannot resolve DEBUGGER_HOST value: \" + autorizedHostName);\n-            }\n-        }\n-\n-        \/**\n-         * Bind ServerSocket to the specified port.\n-         *\/\n-        public void bind() {\n-            for (int i = 0; !shouldStop && i < DebugeeBinder.CONNECT_TRIES; i++) {\n-                try {\n-                    logger.trace(TRACE_LEVEL_SOCKETS, \"ListeningThread: binding to server socket ...\");\n-                    \/\/ length of the queue = 2\n-                    serverSocket = new ServerSocket(port, 2);\n-                    \/\/ timeout for the ServerSocket.accept()\n-                    serverSocket.setSoTimeout(DebugeeBinder.CONNECT_TRY_DELAY);\n-                    logger.trace(TRACE_LEVEL_SOCKETS, \"ListeningThread: socket bound: \" + serverSocket);\n-                    logger.display(\"Bound to listening port\");\n-                    return;\n-                } catch (BindException e) {\n-                    logger.display(\"Socket binding try #\" + i + \" failed:\\n\\t\" + e);\n-                    sleeping(DebugeeBinder.CONNECT_TRY_DELAY);\n-                } catch (IOException e) {\n-                    e.printStackTrace(log.getOutStream());\n-                    throw new Failure(\"Caught exception while binding to socket:\\n\\t\"\n-                                    + e);\n-                }\n-            }\n-            throw new Failure(\"Unable to bind to socket after \"\n-                + DebugeeBinder.CONNECT_TRIES + \" tries\");\n-        }\n-\n-        \/**\n-         * Accept socket connection from authorized remote host and\n-         * start separate <code>SrvingThread<\/code> to handle each connection.\n-         * Connection from unauthorized hosts or connections made while\n-         * current connection is alive are rejected.\n-         *\n-         * @see ServingThread\n-         * @see #llowConnection()\n-         * @see allowServing()\n-         *\/\n-        public void run() {\n-            String reply = null;\n-\n-            logger.trace(TRACE_LEVEL_THREADS, \"ListeningThread: started\");\n-            logger.display(\"Listening for connection from remote host\");\n-            while(!(shouldStop || isInterrupted())) {\n-                try {\n-                    try {\n-                        logger.trace(TRACE_LEVEL_SOCKETS, \"ListeningThread: waiting for connection from test\");\n-                        socket = serverSocket.accept();\n-                        logger.trace(TRACE_LEVEL_SOCKETS, \"ListeningThread: connection accepted\");\n-                    } catch(InterruptedIOException e) {\n-\/\/                        logger.trace(TRACE_LEVEL_SOCKETS, \"ListeningThread: timeout of waiting for connection from test\");\n-                        continue;\n-                    }\n-                    owner.totalRequests++;\n-                    logger.display(\"\");\n-                    clientInetAddr = socket.getInetAddress();\n-                    clientHostName = clientInetAddr.getHostName();\n-                    logger.display(\"Connection #\" + owner.totalRequests\n-                                    + \" requested from host: \" + clientHostName);\n-                    connection = new SocketConnection(logger, \"BindServer\");\n-\/\/                    connection.setPingTimeout(DebugeeBinder.PING_TIMEOUT);\n-                    connection.setSocket(socket);\n-                    socket = null;\n-                    if (allowConnection()) {\n-                        if (allowServing()) {\n-                            owner.acceptedRequests++;\n-                            reply = \"host authorized: \" + clientHostName;\n-                            logger.display(\"Accepting connection #\" + owner.acceptedRequests\n-                                            + \": \" + reply);\n-                            servingThread = new ServingThread(this, connection);\n-                            servingThread.start();\n-                            cleanHostConnection();\n-                        } else {\n-                            owner.busyRequests++;\n-                            reply = \"BindServer is busy\";\n-                            logger.complain(\"Rejecting connection #\" + owner.busyRequests\n-                                            + \": \" + reply);\n-                            connection.writeObject(new RequestFailed(reply));\n-                            closeHostConnection();\n-                        }\n-                    } else {\n-                        owner.unauthorizedRequests++;\n-                        reply = \"host unauthorized: \" + clientHostName;\n-                        logger.complain(\"Rejecting connection #\" + owner.unauthorizedRequests\n-                                            + \": \" + reply);\n-                        connection.writeObject(new RequestFailed(reply));\n-                        closeHostConnection();\n-                    }\n-                } catch (Exception e) {\n-                    logger.complain(\"Caught exception while accepting connection:\\n\" + e);\n-                    e.printStackTrace(log.getOutStream());\n-                }\n-            }\n-            logger.trace(TRACE_LEVEL_THREADS, \"ListeningThread: exiting\");\n-            closeConnection();\n-        }\n-\n-        \/**\n-         * Check if the connection made is from authorized host.\n-         *\n-         * @return true if connection is allowed because host authorized\n-         *         false if connection is rejected because host unauthorized\n-         *\/\n-        private boolean allowConnection() {\n-            \/\/ check if local host from loopback address\n-            if (autorizedHostName.equals(\"localhost\"))\n-                return clientInetAddr.isLoopbackAddress();\n-\n-            \/\/ check if equal hostname\n-            if (autorizedHostName.equals(clientHostName))\n-                return true;\n-\n-            \/\/ check if equal host address\n-            for (int i = 0; i < autorizedInetAddresses.length; i++) {\n-                if (clientInetAddr.equals(autorizedInetAddresses[i])) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        \/**\n-         * Check if no current connection exists or it is dead.\n-         * If current connection presents it will be tested by pinging\n-         * remote host and aborted if host sends no reply. If an alive\n-         * connection exists, new connection will be rejected.\n-         *\n-         * @return true if no alive connection exists\n-         *         false otherwise\n-         *\/\n-        private boolean allowServing() {\n-            if (servingThread == null) {\n-                return true;\n-            }\n-            if (servingThread.done) {\n-                return true;\n-            }\n-            if (!servingThread.isConnectionAlive()) {\n-                logger.display(\"# WARNING: Previous connection from remote host is dead: aborting connection\");\n-                servingThread.close();\n-                servingThread = null;\n-                return true;\n-            }\n-\n-\/*\n-            logger.complain(\"Previous connection from remote host is alive: starting new connection\");\n-            servingThread = null;\n-            return true;\n- *\/\n-            logger.complain(\"Previous connection from remote host is alive: reject new connection\");\n-            return false;\n-        }\n-\n-        \/**\n-         * Wait for this thread finished\n-         * for specified timeout or interrupt it.\n-         *\n-         * @param millis timeout in milliseconds\n-         *\/\n-        public void waitForThread(long millis) {\n-            shouldStop = true;\n-            waitInterruptThread(this, millis);\n-        }\n-\n-        \/**\n-         * Close socket connection from remote host.\n-         *\/\n-        private void closeHostConnection() {\n-            if (connection != null) {\n-                connection.close();\n-            }\n-            if (socket != null) {\n-                try {\n-                    socket.close();\n-                } catch (IOException e) {\n-                    logger.complain(\"Caught IOException while closing socket:\\n\\t\"\n-                                    + e);\n-                }\n-                socket = null;\n-            }\n-        }\n-\n-        \/**\n-         * Assign <null> to connection and socket objects\n-         * but do not close them.\n-         *\/\n-        private void cleanHostConnection() {\n-            connection = null;\n-            socket = null;\n-        }\n-\n-        \/**\n-         * Close all connections and sockets.\n-         *\/\n-        private void closeConnection() {\n-            closeHostConnection();\n-            if (serverSocket != null) {\n-                try {\n-                    serverSocket.close();\n-                } catch (IOException e) {\n-                    logger.complain(\"Caught IOException while closing ServerSocket:\\n\\t\"\n-                                    + e);\n-                }\n-                serverSocket = null;\n-            }\n-        }\n-\n-        \/**\n-         * Close thread by closing all connections and waiting\n-         * foor thread finished.\n-         *\n-         * @see #closeConnection()\n-         *\/\n-        public synchronized void close() {\n-            if (closed) {\n-                return;\n-            }\n-            closeHostConnection();\n-            if (servingThread != null) {\n-                servingThread.close();\n-                servingThread = null;\n-            }\n-            waitForThread(THREAD_TIMEOUT);\n-            closeConnection();\n-            closed = true;\n-            logger.trace(TRACE_LEVEL_THREADS, \"ListeningThread closed\");\n-        }\n-\n-    } \/\/ ListeningThread\n-\n-\/\/\/\/\/\/\/\/\/ Thread working with a communication channel \/\/\/\/\/\/\/\/\/\/\n-\n-    \/**\n-     * An internal thread for handling each connection from a test\n-     * on remote host. It reads requests from test and starts separate\n-     * <code>LaunchingThread<\/code> to execute each request.\n-     *\n-     * @see LaunchingThread\n-     *\/\n-    private static class ServingThread extends Thread {\n-        private volatile boolean shouldStop = false;\n-        private volatile boolean closed = false;\n-        private volatile boolean done = false;\n-\n-        private ListeningThread owner = null;\n-        private LaunchingThread launchingThread = null;\n-\n-        private SocketConnection connection = null;\n-\n-        \/**\n-         * Make serving thread with specified input\/output connection streams\n-         * and given <code>Listenerthread<\/code> as an owner.\n-         *\n-         * @param owner owner of this thread\n-         * @param connection established socket connection with test\n-         *\/\n-        public ServingThread(ListeningThread owner, SocketConnection connection) {\n-            super(\"ServingThread\");\n-            this.owner = owner;\n-            this.connection = connection;\n-        }\n-\n-        \/**\n-         * Read requests from socket connection and start <code>LaunchingThread<\/code>\n-         * to perform each requested action.\n-         *\/\n-        public void run() {\n-            logger.trace(TRACE_LEVEL_THREADS, \"ServingThread: starting handling requests from debugger\");\n-            try {\n-                \/\/ sending OK(version)\n-                logger.trace(TRACE_LEVEL_ACTIONS, \"ServingThread: sending initial OK(VERSION) to debugger\");\n-                connection.writeObject(new OK(VERSION));\n-\n-                \/\/ receiving TaskID(id)\n-                logger.trace(TRACE_LEVEL_IO, \"ServingThread: waiting for TaskID from debugger\");\n-                Object taskID = connection.readObject();\n-                logger.trace(TRACE_LEVEL_IO, \"ServingThread: received TaskID from debugger: \" + taskID);\n-                if (taskID instanceof TaskID) {\n-                    String id = ((TaskID)taskID).id;\n-                    owner.taskCount++;\n-                    logger.println(\"[\" + owner.taskCount + \"\/\" + owner.owner.totalRequests + \"]: \" + id);\n-                } else {\n-                    throw new Failure(\"Unexpected TaskID received form debugger: \" + taskID);\n-                }\n-\n-                \/\/ starting launching thread\n-                launchingThread = new LaunchingThread(this, connection);\n-                launchingThread.start();\n-\n-                \/\/ receiving and handling requests\n-                while(!(shouldStop || isInterrupted())) {\n-                    logger.trace(TRACE_LEVEL_IO, \"ServingThread: waiting for request from debugger\");\n-                    Object request = connection.readObject();\n-                    logger.trace(TRACE_LEVEL_IO, \"ServingThread: received request from debugger: \" + request);\n-                    if (request == null) {\n-                        logger.display(\"Connection closed\");\n-                        break;\n-                    } else if (request instanceof Disconnect) {\n-                        logger.display(\"Closing connection by request\");\n-                        request = null;\n-                        break;\n-                    } else {\n-                        boolean success = false;\n-                        long timeToFinish = System.currentTimeMillis() + THREAD_TIMEOUT;\n-                        while (System.currentTimeMillis() < timeToFinish) {\n-                            if (launchingThread.doneRequest()) {\n-                                success = true;\n-                                logger.trace(TRACE_LEVEL_ACTIONS, \"ServingThread: asking launching thread to handle request: \" + request);\n-                                launchingThread.handleRequest(request);\n-                                break;\n-                            }\n-                            try {\n-                                launchingThread.join(DebugeeBinder.TRY_DELAY);\n-                            } catch (InterruptedException e) {\n-                                throw new Failure(\"ServingThread interrupted while waiting for LaunchingThread:\\n\\t\"\n-                                                + e);\n-                            }\n-                        }\n-                        if (!success) {\n-                            logger.complain(\"Rejecting request because of being busy:\\n\" + request);\n-                            connection.writeObject(\n-                                new RequestFailed(\"Busy with handling previous request\"));\n-                        }\n-                    }\n-                }\n-            } catch (Exception e) {\n-                e.printStackTrace(log.getOutStream());\n-                logger.complain(\"Caught exception while handling request:\\n\\t\" + e);\n-            } finally {\n-                logger.trace(TRACE_LEVEL_THREADS, \"ServingThread: exiting\");\n-                closeConnection();\n-                done = true;\n-            }\n-        }\n-\n-        \/**\n-         * Check if present socket connection is alive.\n-         *\/\n-        private boolean isConnectionAlive() {\n-            return (connection != null && connection.isConnected());\n-        }\n-\n-        \/**\n-         * Wait for this thread finished\n-         * for specified timeout or interrupt it.\n-         *\n-         * @param millis timeout in milliseconds\n-         *\/\n-        public void waitForThread(long millis) {\n-            shouldStop = true;\n-            waitInterruptThread(this, millis);\n-        }\n-\n-        \/**\n-         * Close socket connection from remote host.\n-         *\/\n-        private void closeConnection() {\n-            if (connection != null) {\n-                connection.close();\n-            }\n-            if (launchingThread != null) {\n-                launchingThread.handleRequest(null);\n-            }\n-        }\n-\n-        \/**\n-         * Close thread closing socket connection and\n-         * waiting for thread finished.\n-         *\/\n-        public synchronized void close() {\n-            if (closed) {\n-                return;\n-            }\n-            closeConnection();\n-            if (launchingThread != null) {\n-                launchingThread.close();\n-                launchingThread = null;\n-            }\n-            waitForThread(THREAD_TIMEOUT);\n-            closed = true;\n-            logger.trace(TRACE_LEVEL_THREADS, \"ServingThread closed\");\n-        }\n-\n-    } \/\/ ServingThread\n-\n-\/\/\/\/\/\/\/\/\/ Thread serving a particular Binder's request \/\/\/\/\/\/\/\/\/\/\n-\n-    \/**\n-     * An internal thread to execute each request from a test on remote host.\n-     * Requests are coming from ServingThread by invoking handleRequest(Object)\n-     * method.\n-     *\/\n-    private static class LaunchingThread extends Thread {\n-        private volatile boolean shouldStop = false;\n-        private volatile boolean closed = false;\n-        public volatile boolean done = false;\n-\n-        private ServingThread owner = null;\n-\/\/        private ProcessWaitingThread waitingThread = null;\n-        private Process process = null;\n-\n-        private StreamRedirectingThread stdoutRedirectingThread = null;\n-        private StreamRedirectingThread stderrRedirectingThread = null;\n-\n-        \/** Notification about request occurence. *\/\n-        private volatile Object notification = new Object();\n-        \/** Request to execute. *\/\n-        private volatile Object request = null;\n-        \/** Socket stream to send replies to. *\/\n-        private SocketConnection connection = null;\n-\n-        \/**\n-         * Make thread for executing requests from a test and\n-         * send reply.\n-         *\n-         * @param owner owner of this thread\n-         * @connection socket connection for sending replies\n-         *\/\n-        public LaunchingThread(ServingThread owner, SocketConnection connection) {\n-            super(\"LaunchingThread\");\n-            this.owner = owner;\n-            this.connection = connection;\n-        }\n-\n-        \/**\n-         * Notify this thread that new request has come.\n-         *\n-         * @param request request to execute\n-         *\/\n-        public void handleRequest(Object request) {\n-            synchronized (notification) {\n-                this.request = request;\n-                notification.notifyAll();\n-            }\n-        }\n-\n-        \/**\n-         * Check if request has been executed.\n-         *\/\n-        public boolean doneRequest() {\n-            return done;\n-        }\n-\n-        \/**\n-         * Wait for request notification from <code>ServingThread<\/code>\n-         * and execute an action according to the request.\n-         * Request <i>null<\/code> means thread should finish.\n-         *\/\n-        public void run() {\n-            logger.trace(TRACE_LEVEL_THREADS, \"LaunchingThread: started to handle request\");\n-            done = true;\n-            while (!isInterrupted()) {\n-                \/\/ wait for new request notification\n-                logger.trace(TRACE_LEVEL_ACTIONS, \"LaunchingThread: waiting for request\");\n-                synchronized (notification) {\n-                    try {\n-                        notification.wait();\n-                    } catch (InterruptedException e) {\n-                        logger.complain(\"LaunchingThread interrupted while waiting for request:\\n\\t\"\n-                                        + e);\n-                        break;\n-                    }\n-                }\n-\n-                \/\/ execute the request\n-                try {\n-                    logger.trace(TRACE_LEVEL_ACTIONS, \"LaunchingThread: handling request: \" + request);\n-                    if (request == null) {\n-                        break;\n-                    } else if (request instanceof LaunchDebugee) {\n-                        launchDebugee((LaunchDebugee)request);\n-                    } else if (request instanceof WaitForDebugee) {\n-                        waitForDebugee((WaitForDebugee)request);\n-                    } else if (request instanceof DebugeeExitCode) {\n-                        debugeeExitCode((DebugeeExitCode)request);\n-                    } else if (request instanceof KillDebugee) {\n-                        killDebugee((KillDebugee)request);\n-                    } else {\n-                        String reason = \"Unknown request: \" + request;\n-                        logger.complain(reason);\n-                        sendReply(new RequestFailed(reason));\n-                    }\n-                } catch (Exception e) {\n-                    e.printStackTrace(log.getOutStream());\n-                    logger.complain(\"Caught exception while handling request:\\n\\t\" + e);\n-                }\n-                done = true;\n-            }\n-            done = true;\n-            logger.trace(TRACE_LEVEL_THREADS, \"LaunchingThread: exiting\");\n-            closeConnection();\n-        }\n-\n-        \/**\n-         * Send given reply to remote test.\n-         *\n-         * @param reply reply object to send\n-         *\/\n-        public void sendReply(Object reply) throws IOException {\n-            connection.writeObject(reply);\n-        }\n-\n-        \/**\n-         * Send given output line to remote test.\n-         *\n-         * @param reply wrapper object for output line to send\n-         *\/\n-        public void sendStreamMessage(RedirectedStream wrapper) throws IOException {\n-            logger.trace(TRACE_LEVEL_ACTIONS, \"Sending output line wrapper to debugger: \" + wrapper);\n-            if (connection.isConnected()) {\n-                sendReply(wrapper);\n-            } else {\n-                logger.complain(\"NOT redirected: \" + wrapper.line);\n-            }\n-        }\n-\n-        \/**\n-         * Launch two <code>StreamRedirectingThread<\/code> threads to redirect\n-         * stdin\/stderr output of debuggee VM process via <code>BindServer<\/code>\n-         * connection.\n-         *\n-         * @param process debuggee VM process\n-         *\/\n-        private void launchStreamRedirectors(Process process) {\n-            stdoutRedirectingThread =\n-                new StdoutRedirectingThread(this, process.getInputStream(),\n-                                            DebugeeProcess.DEBUGEE_STDOUT_LOG_PREFIX);\n-            stdoutRedirectingThread.start();\n-            stderrRedirectingThread =\n-                new StderrRedirectingThread(this, process.getErrorStream(),\n-                                            DebugeeProcess.DEBUGEE_STDERR_LOG_PREFIX);\n-            stderrRedirectingThread.start();\n-        }\n-\n-        \/**\n-         * Execute request for launching debuggee.\n-         *\n-         * @param request request to execute\n-         *\/\n-        private void launchDebugee(LaunchDebugee request) throws IOException {\n-            logger.trace(TRACE_LEVEL_ACTIONS, \"LaunchDebugee: handle request: \" + request);\n-\n-            if (process != null) {\n-                logger.complain(\"Unable to launch debuggee: process already launched\");\n-                sendReply(new RequestFailed(\"Debuggee process already launched\"));\n-                return;\n-            }\n-\n-            try {\n-                String[] cmd = request.cmd;\n-                cmd[0] = convertPath(cmd[0], request.slash, \"TESTED_JAVA_HOME\", true);\n-                for (int i = 1; i < cmd.length; i++) {\n-                    cmd[i] = convertPath(cmd[i], request.slash, \"JAVA_ARGS\", false);\n-                }\n-                String workDir = convertPath(request.workDir, request.slash, \"WORKDIR\", true);\n-                String[] classPathes = convertPathes(request.classPathes, request.slash, \"CLASSPATH\", true);\n-                String windir = argHandler.getDebugeeWinDir();\n-\n-                boolean win = (!(windir == null || windir.equals(\"\")));\n-                String[] envp = new String[win ? 3 : 1] ;\n-                envp[0] = \"CLASSPATH=\" + ArgumentParser.joinArguments(classPathes, \"\", pathSeparator);\n-                if (win) {\n-                    envp[1] = \"WINDIR=\" + windir;\n-                    envp[2] = \"SystemRoot=\" + windir;\n-                }\n-\n-                logger.display(\"Setting environment:\\n\"\n-                                + \"  \" + ArgumentHandler.joinArguments(envp, \"\", \"\\n  \"));\n-                logger.display(\"Setting work dir:\\n\"\n-                                + \"  \" + workDir);\n-                logger.display(\"Launching debuggee:\\n\"\n-                                + \"  \" + ArgumentHandler.joinArguments(cmd, \"\\\"\"));\n-\n-                process = Runtime.getRuntime().exec(cmd, envp, new File(workDir));\n-                logger.display(\"  debuggee launched successfully\");\n-\n-                launchStreamRedirectors(process);\n-            } catch (Exception e) {\n-                if (!(e instanceof Failure)) {\n-                    e.printStackTrace(log.getOutStream());\n-                }\n-                logger.complain(\"Caught exception while launching debuggee:\\n\\t\" + e);\n-                sendReply(new CaughtException(e));\n-                return;\n-            }\n-\n-            sendReply(new OK());\n-        }\n-\n-        \/**\n-         * Execute request for waiting for debuggee exited.\n-         *\n-         * @param request request to execute\n-         *\/\n-        private void waitForDebugee(WaitForDebugee request) throws IOException {\n-            logger.trace(TRACE_LEVEL_ACTIONS, \"WaitForDebugee: handle request: \" + request);\n-\n-            if (process == null) {\n-                String reply = \"No debuggee process to wait for\";\n-                logger.complain(reply);\n-                sendReply(new RequestFailed(reply));\n-                return;\n-            }\n-\n-            logger.display(\"Waiting for debuggee to exit\");\n-\/*\n-            \/\/ because timeout is not supported now\n-            \/\/ we do not use separate thread for waiting for process\n-            \/\/ and so following lines are commented out\n-\n-            waitingThread = new ProcessWaitingThread();\n-            logger.trace(TRACE_LEVEL_ACTIONS, \"LaunchingThread: starting thread for waiting for debugee process\");\n-            waitingThread.start();\n-            try {\n-                waitingThread.join(request.timeout);\n-                if (waitingThread.isAlive()) {\n-                    String reply = \"Timeout exceeded while waiting for debuggee to exit\";\n-                    logger.complain(reply);\n-                    waitingThread.interrupt();\n-                    sendReply(socOut, new RequestFailed(reply));\n-                    return;\n-                }\n-            } catch (InterruptedException e) {\n-                e.printStackTrace(log.getOutStream());\n-                logger.complain(\"Caught exception while waiting for debuggee:\\n\\t\" + e);\n-                sendReply(new CaughtException(e));\n-                return;\n-            }\n-            int exitStatus = waitingThread.exitStatus;\n-            waitingThread = null;\n- *\/\n-            int exitStatus;\n-            try {\n-                exitStatus = process.waitFor();\n-                waitForRedirectors(THREAD_TIMEOUT);\n-                process.destroy();\n-            } catch (InterruptedException e) {\n-                e.printStackTrace(log.getOutStream());\n-                logger.complain(\"Caught exception while waiting for debuggee process to exit:\\n\\t\"\n-                                + e);\n-                sendReply(new CaughtException(e));\n-                return;\n-            }\n-            logger.display(\"  debuggee exited with exit status: \" + exitStatus);\n-            sendReply(new OK(exitStatus));\n-        }\n-\n-        \/**\n-         * Execute request for returning debuggee exit code.\n-         *\n-         * @param request request to execute\n-         *\/\n-        private void debugeeExitCode(DebugeeExitCode request) throws IOException {\n-            logger.trace(TRACE_LEVEL_ACTIONS, \"DebugeeExitCode: handle request: \" + request);\n-\n-            if (process == null) {\n-                String reply = \"No debuggee process to get exit code for\";\n-                logger.complain(reply);\n-                sendReply(new RequestFailed(reply));\n-                return;\n-            }\n-\n-            int exitStatus = 0;\n-            try {\n-                exitStatus = process.exitValue();\n-            } catch (IllegalThreadStateException e) {\n-                logger.display(\"# WARNING: Caught exception while getting exit status of debuggee:\\n\\t\"\n-                                + e);\n-                sendReply(new CaughtException(e));\n-                return;\n-            }\n-            logger.trace(TRACE_LEVEL_ACTIONS, \"DebugeeExitCode: return debuggee exit status: \" + exitStatus);\n-            sendReply(new OK(exitStatus));\n-        }\n-\n-        \/**\n-         * Execute request for unconditional terminating debuggee process.\n-         *\n-         * @param request request to execute\n-         *\/\n-        private void killDebugee(KillDebugee request) throws IOException {\n-            logger.trace(TRACE_LEVEL_ACTIONS, \"killDebugee: handle request: \" + request);\n-\n-            if (process == null) {\n-                String reply = \"No debuggee process to kill\";\n-                logger.complain(reply);\n-                sendReply(new RequestFailed(reply));\n-                return;\n-            }\n-\n-            logger.trace(TRACE_LEVEL_ACTIONS, \"killDebugee: killing debuggee process\");\n-            process.destroy();\n-\n-            logger.trace(TRACE_LEVEL_ACTIONS, \"killDebugee: debuggee process killed\");\n-            sendReply(new OK());\n-        }\n-\n-        \/**\n-         * Terminate debigee VM process if still alive.\n-         *\/\n-        private void terminateDebugeeAtExit() {\n-            if (process != null) {\n-                logger.trace(TRACE_LEVEL_ACTIONS, \"Checking that debuggee process has exited correctly\");\n-                try {\n-                    int value = process.exitValue();\n-                } catch (IllegalThreadStateException e) {\n-                    logger.complain(\"Debuggee process has not exited correctly: trying to kill it\");\n-                    process.destroy();\n-                    try {\n-                        int value = process.exitValue();\n-                    } catch (IllegalThreadStateException ie) {\n-                        logger.complain(\"Debuggee process is alive after killing it\");\n-                    }\n-                    process = null;\n-                    return;\n-                }\n-                logger.trace(TRACE_LEVEL_ACTIONS, \"Debuggee process has exited correctly\");\n-            }\n-        }\n-\n-        \/**\n-         * Wait for stream redirecting threads finished\n-         * for specified timeout.\n-         *\n-         * @param millis timeout in milliseconds\n-         *\/\n-        private void waitForRedirectors(long millis) {\n-            try {\n-                if (stdoutRedirectingThread != null) {\n-                    stdoutRedirectingThread.join(millis);\n-                }\n-                if (stderrRedirectingThread != null) {\n-                    stderrRedirectingThread.join(millis);\n-                }\n-            } catch (InterruptedException e) {\n-                e.printStackTrace(log.getOutStream());\n-                logger.complain(\"Caught exception while waiting for debuggee process exited:\\n\\t\"\n-                                + e);\n-            }\n-        }\n-\n-        \/**\n-         * Wait for this thread finished\n-         * for specified timeout or interrupt it.\n-         *\n-         * @param millis timeout in milliseconds\n-         *\/\n-        public void waitForThread(long millis) {\n-            shouldStop = true;\n-            handleRequest(null);\n-            waitInterruptThread(this, millis);\n-        }\n-\n-        \/**\n-         * Close connection with debuggee.\n-         *\/\n-        public void closeConnection() {\n-            \/\/ no connections to close\n-        }\n-\n-        \/**\n-         * Close thread by closing all connections with debuggee,\n-         * finishing all redirectors and wait for thread finished.\n-         *\/\n-        public synchronized void close() {\n-            if (closed) {\n-                return;\n-            }\n-            closeConnection();\n-            terminateDebugeeAtExit();\n-            if (stdoutRedirectingThread != null) {\n-                stdoutRedirectingThread.close();\n-                stdoutRedirectingThread = null;\n-            }\n-            if (stderrRedirectingThread != null) {\n-                stderrRedirectingThread.close();\n-                stderrRedirectingThread = null;\n-            }\n-            waitForThread(THREAD_TIMEOUT);\n-            closed = true;\n-            logger.trace(TRACE_LEVEL_THREADS, \"LaunchingThread closed\");\n-        }\n-\n-        \/**\n-         * An inner thread for waiting for debuggee process exited\n-         * and saving its exit status. (currently not used)\n-         *\/\n-\/*\n-        private class ProcessWaitingThread extends Thread {\n-            int exitStatus = 0;\n-\n-            ProcessWaitingThread() {\n-                super(\"ProcessWaitingThread\");\n-            }\n-\n-            public void run() {\n-                logger.trace(TRACE_LEVEL_THREADS, \"ProcessWaitingThread: starting waiting for process\");\n-                try {\n-                    exitStatus = process.waitFor();\n-                } catch (InterruptedException e) {\n-                    e.printStackTrace(log.getOutStream());\n-                    logger.complain(\"Caught exception while waiting for debuggee process:\\n\\t\"\n-                                    + e);\n-                }\n-                logger.trace(TRACE_LEVEL_ACTIONS, \"ProcessWaitingThread: process finished with status: \" + exitStatus);\n-                logger.trace(TRACE_LEVEL_THREADS, \"ProcessWaitingThread: exiting\");\n-            }\n-\n-            public synchronized void close() {\n-                logger.trace(TRACE_LEVEL_THREADS, \"ProcessWaitingThread closed\");\n-            }\n-\n-        } \/\/ ProcessWaitingThread\n- *\/\n-    } \/\/ LaunchingThread\n-\n-\/\/\/\/\/\/\/\/\/ Redirecting threads \/\/\/\/\/\/\/\/\/\n-\n-    \/**\n-     * An abstract base class for internal threads which redirects stderr\/stdout\n-     * output from debuggee process via <code>BindServer<\/code> connection.\n-     * <p>\n-     * Two derived classes will redirect <i>stderr<\/i> or <\/i>stdout<\/i> stream\n-     * by enwrapping stream line by <code>DebugeeStderr<\/code> or\n-     * <code>DebugeeStderr<\/code> objects. They should implement only one\n-     * abstract method <code>enwrapLine(String)<\/code> to make the difference.\n-     *\/\n-    public static abstract class StreamRedirectingThread extends Thread {\n-        private volatile boolean shouldStop = false;\n-        private volatile boolean closed = false;\n-\n-        private LaunchingThread owner = null;\n-\n-        private BufferedReader bin = null;\n-        private String prefix = null;\n-\n-        \/**\n-         * Make a thread to enwrap and redirect lines from specified\n-         * input stream with given prefix.\n-         *\n-         * @param owner owner of this thread\n-         * @param is input stream to redirect lines from\n-         * @param prefix prefix to add to each line\n-         *\/\n-        public StreamRedirectingThread(LaunchingThread owner, InputStream is, String prefix) {\n-            super(\"StreamRedirectingThread\");\n-            this.prefix = prefix;\n-            this.owner = owner;\n-            bin = new BufferedReader(new InputStreamReader(is));\n-        }\n-\n-        \/**\n-         * Read lines from an input stream, enwrap them, and send to remote\n-         * test via <code>BindServer<\/code> connection.\n-         *\/\n-        public void run() {\n-            logger.trace(TRACE_LEVEL_THREADS, \"StreamRedirectingThread: starting redirect output stream\");\n-            try {\n-                String line;\n-                logger.trace(TRACE_LEVEL_IO, \"StreamRedirectingThread: waiting for line from debuggee output\");\n-                while(!shouldStop) {\n-                    line = bin.readLine();\n-                    if (line == null)\n-                        break;\n-                    owner.sendStreamMessage(enwrapLine(prefix + line));\n-                }\n-            } catch (EOFException e) {\n-                logger.display(\"Debuggee output stream closed by process\");\n-            } catch (IOException e) {\n-                e.printStackTrace(log.getOutStream());\n-                logger.display(\"# WARNING: Connection to debuggee output stream aborted:\\n\\t\" + e);\n-            } catch (Exception e) {\n-                e.printStackTrace(log.getOutStream());\n-                logger.complain(\"Caught exception while redirecting debuggee output stream:\\n\\t\"\n-                                + e);\n-            }\n-            logger.trace(TRACE_LEVEL_THREADS, \"StreamRedirectingThread: exiting\");\n-            closeConnection();\n-        }\n-\n-        \/**\n-         * Envrap output line by the appropriate wrapper.\n-         * @param line line to enwrap\n-         *\/\n-        protected abstract RedirectedStream enwrapLine(String line);\n-\n-        \/**\n-         * Wait for this thread finished or interrupt it.\n-         *\n-         * @param millis timeout in milliseconds\n-         *\/\n-        public void waitForThread(long millis) {\n-            shouldStop = true;\n-            waitInterruptThread(this, millis);\n-        }\n-\n-        \/**\n-         * Close redirected process output stream.\n-         *\/\n-        public void closeConnection() {\n-            if (closed) {\n-                return;\n-            }\n-            if (bin != null) {\n-                try {\n-                    bin.close();\n-                } catch (IOException e) {\n-                    e.printStackTrace(log.getOutStream());\n-                    logger.complain(\"Caught exception while closing debuggee output stream:\\n\\t\"\n-                                    + e);\n-                }\n-                bin = null;\n-            }\n-            closed = true;\n-            logger.trace(TRACE_LEVEL_THREADS, \"StreamRedirectingThread closed\");\n-        }\n-\n-        \/**\n-         * Close thread by waiting redirected stream closed\n-         * and finish the thread.\n-         *\/\n-        public synchronized void close() {\n-            if (closed) {\n-                return;\n-            }\n-            waitForThread(THREAD_TIMEOUT);\n-            closeConnection();\n-            closed = true;\n-            logger.trace(TRACE_LEVEL_THREADS, \"StreamRedirectingThread closed\");\n-        }\n-\n-    } \/\/ StreamRedirectingThread\n-\n-    \/**\n-     * Particalar case of <code>StreamRedirectingThread<\/code> to redirect\n-     * <i>stderr<\/i> stream by enwrapping lines into <code>DebugeeStderr<\/code>\n-     * objects.\n-     *\/\n-    private static class StderrRedirectingThread extends StreamRedirectingThread {\n-\n-        \/**\n-         * Make a thread to redirect <i>stderr<\/i> output stream.\n-         *\/\n-        StderrRedirectingThread(LaunchingThread owner, InputStream is, String prefix) {\n-            super(owner, is, prefix);\n-            setName(\"StderrRedirectingThread\");\n-        }\n-\n-        \/**\n-         * Enwrap given line into <code>DebugeeStderr<\/code> object.\n-         *\/\n-        protected RedirectedStream enwrapLine(String line) {\n-            return new DebugeeStderr(line);\n-        }\n-\n-    }\n-\n-    \/**\n-     * Particalar case of <code>StreamRedirectingThread<\/code> to redirect\n-     * <i>stdout<\/i> stream by enwrapping lines into <code>DebugeeStdout<\/code>\n-     * objects.\n-     *\/\n-    private static class StdoutRedirectingThread extends StreamRedirectingThread {\n-\n-        \/**\n-         * Make a thread to redirect <i>stdout<\/i> output stream.\n-         *\/\n-        StdoutRedirectingThread(LaunchingThread owner, InputStream is, String prefix) {\n-            super(owner, is, prefix);\n-            setName(\"StdoutRedirectingThread\");\n-        }\n-\n-        \/**\n-         * Enwrap given line into <code>DebugeeStdout<\/code> object.\n-         *\/\n-        protected RedirectedStream enwrapLine(String line) {\n-            return new DebugeeStdout(line);\n-        }\n-\n-    }\n-\n-\/\/\/\/\/\/\/\/\/ BinderServer's packets \/\/\/\/\/\/\/\/\/\/\n-\n-    \/**\n-     * Base serializable object to transmit request or reply\n-     * via <code>BindServer<\/code> connection.\n-     *\/\n-    public static class Packet implements Serializable {}\n-\n-    \/\/\/\/\/\/\/\/\/ Binder's requests \/\/\/\/\/\/\/\/\/\/\n-\n-    \/**\n-     * Base class to represent request to <code>BindServer<\/code>.\n-     *\/\n-    public static abstract class Request extends Packet {}\n-\n-    \/**\n-     * This class implements task identification command.\n-     *\/\n-    public static class TaskID extends Request {\n-        public String id;\n-\n-        public TaskID(String id) {\n-            this.id = id;\n-        }\n-\n-        public String toString() {\n-            return \"TaskID: id=\" + id;\n-        }\n-    }\n-\n-    \/**\n-     * This class implements a request for launching a debugee.\n-     *\/\n-    public static class LaunchDebugee extends Request {\n-        public String slash;         \/\/ slash symbol used on debugger host\n-        public String[] cmd;         \/\/ command line arguments as seen on debugger host\n-        public String workDir;       \/\/ path to working directory as seen on debugger host\n-        public String[] classPathes; \/\/ list of class pathes as seen on debugger host\n-\n-        public LaunchDebugee(String[] cmd, String slash, String workDir,\n-                            String[] pathes, String[] classPathes,\n-                            String[] libPathes) {\n-            this.cmd = cmd;\n-            this.slash = slash;\n-            this.workDir = workDir;\n-            this.classPathes = classPathes;\n-        }\n-\n-        public String toString() {\n-            return \"LaunchDebugee:\"\n-                + \"\\n\\tcommand=\" + ArgumentParser.joinArguments(cmd, \"\\\"\")\n-                + \"\\n\\tWORKDIR=\" + workDir\n-                + \"\\n\\tCLASSPATH=\" + ArgumentParser.joinArguments(classPathes, \"\", \":\")\n-                + \"\\n\\tslash=\" + slash;\n-        }\n-    }\n-\n-    \/**\n-     * This class implements a request for waiting for debugee\n-     * termination.\n-     *\/\n-    public static class WaitForDebugee extends Request {\n-        public long timeout = 0; \/\/ timeout in minutes for waiting\n-\n-        public WaitForDebugee(long value) {\n-            timeout = value;\n-        }\n-\n-        public String toString() {\n-            return \"WaitForDebugee: timeout=\" + timeout;\n-        }\n-    }\n-\n-    \/**\n-     * This class implements a request for exit code of\n-     * debugee process.\n-     *\/\n-    public static class DebugeeExitCode extends Request {\n-        public String toString() {\n-            return \"SebugeeExitCode\";\n-        }\n-    }\n-\n-    \/**\n-     * This class implements a request for killing debugee process.\n-     *\/\n-    public static class KillDebugee extends Request {\n-        public String toString() {\n-            return \"KillDebugee\";\n-        }\n-    }\n-\n-    \/**\n-     * This class implements a request to disconnect connection with test.\n-     *\/\n-    public static class Disconnect extends Request {\n-        public String toString() {\n-            return \"Disconnect\";\n-        }\n-    }\n-\n-    \/\/\/\/\/\/\/\/\/ BindServer's responses \/\/\/\/\/\/\/\/\/\/\n-\n-    \/**\n-     * Base class to represent response from <code>BindServer<\/code>.\n-     *\/\n-    public static abstract class Response extends Packet {}\n-\n-    \/**\n-     * This class implements a response that a previoulsy received\n-     * request has been successfully performed.\n-     *\/\n-    public static class OK extends Response {\n-        public long info = BindServer.VERSION; \/\/ optional additional info\n-\n-        public OK() {\n-        }\n-\n-        public OK(long value) {\n-            info = value;\n-        }\n-\n-        public String toString() {\n-            return \"OK(\" + info + \")\";\n-        }\n-    }\n-\n-    \/**\n-     * This class implements a response that the BindServer is\n-     * unable to serve a previoulsy received request.\n-     *\/\n-    public static class RequestFailed extends Response {\n-        public String reason; \/\/ the short explanation of failure\n-\n-        public RequestFailed(String reason) {\n-            this.reason = reason;\n-        }\n-\n-        public String toString() {\n-            return \"RequestFailed(\" + reason + \")\";\n-        }\n-    }\n-\n-    \/**\n-     * This class implements a response that the BindServer is\n-     * unable to serve a previoulsy received request because of\n-     * caught exception.\n-     *\/\n-    public static class CaughtException extends RequestFailed {\n-        public CaughtException(Exception cause) {\n-            super(\"Caught exception: \" + cause);\n-        }\n-    }\n-\n-    \/\/\/\/\/\/\/\/\/ Wrappers for redirected messages \/\/\/\/\/\/\/\/\/\/\n-\n-    \/**\n-     * Base class to represent wrappers for redirected streams.\n-     *\/\n-    public static class RedirectedStream extends Packet {\n-        public String line; \/\/ line containing line from redirected stream\n-\n-        public RedirectedStream(String str) {\n-            line = str;\n-        }\n-\n-        public String toString() {\n-            return \"RedirectedStream(\" + line + \")\";\n-        }\n-    }\n-\n-    \/**\n-     * This class enwraps redirected line of <i>stdout<\/i> stream.\n-     *\/\n-    public static class DebugeeStdout extends RedirectedStream {\n-\n-        public DebugeeStdout(String str) {\n-            super(str);\n-        }\n-\n-        public String toString() {\n-            return \"DebugeeStdout(\" + line + \")\";\n-        }\n-    }\n-\n-    \/**\n-     * This class enwraps redirected line of <i>stderr<\/i> stream.\n-     *\/\n-    public static class DebugeeStderr extends RedirectedStream {\n-        public DebugeeStderr(String str) {\n-            super(str);\n-        }\n-\n-        public String toString() {\n-            return \"DebugeeStderr(\" + line + \")\";\n-        }\n-    }\n-\n-\/\/\/\/\/\/\/ ArgumentHandler for BindServer command line \/\/\/\/\/\/\/\/\/\n-\n-    \/**\n-     * This class is used to parse arguments from command line\n-     * and specified <i>bind-file<\/i>,\n-     *\/\n-    private static class ArgumentHandler extends ArgumentParser {\n-\n-        protected Properties fileOptions;\n-\n-        \/**\n-         * Make parser object for command line arguments.\n-         *\n-         * @param args list of command line arguments\n-         *\/\n-        public ArgumentHandler(String[] args) {\n-            super(args);\n-        }\n-\n-        \/**\n-         * Check if given command line option is aloowed.\n-         *\n-         * @param option option name\n-         * @param value option value\n-         *\/\n-        protected boolean checkOption(String option, String value) {\n-            if (option.equals(\"bind.file\")) {\n-                \/\/ accept any file name\n-                return true;\n-            }\n-            return super.checkOption(option, value);\n-        }\n-\n-        \/**\n-         * Check if all recignized options are compatible.\n-         *\/\n-        protected void checkOptions() {\n-            if (getBindFileName() == null) {\n-                throw new BadOption(\"Option -bind.file is requred \");\n-            }\n-            super.checkOptions();\n-        }\n-\n-        \/**\n-         * Check if value of this option points to a existing directory.\n-         *\n-         * @param option option name\n-         * @param dir option value\n-         *\/\n-        private void checkDir(String option, String dir) {\n-            File file = new File(dir);\n-            if (!file.exists()) {\n-                throw new BadOption(option + \" does not exist: \" + dir);\n-            }\n-            if (!file.isAbsolute()) {\n-                throw new BadOption(option + \" is not absolute pathname: \" + dir);\n-            }\n-            if (!file.isDirectory()) {\n-                throw new BadOption(option + \" is not directory: \" + dir);\n-            }\n-        }\n-\n-        \/**\n-         * Check if option from <i>bind-file<\/i> is allowed.\n-         *\n-         * @param option option name\n-         * @param value option value\n-         *\/\n-        protected boolean checkAdditionalOption(String option, String value) {\n-\n-            if (option.equals(\"DEBUGGER_HOST\")) {\n-                \/\/ accept any hostname\n-                return true;\n-            }\n-\n-            if (option.equals(\"BINDSERVER_PORT\")) {\n-                \/\/ accept only integer value\n-                try {\n-                    int port = Integer.parseInt(value);\n-                } catch (NumberFormatException e) {\n-                    throw new Failure(\"Not integer value of bind-file option \" + option\n-                                        + \": \" + value);\n-                }\n-                return true;\n-            }\n-\n-            if (option.equals(\"DEBUGGER_TESTED_JAVA_HOME\")\n-                    || option.equals(\"DEBUGGER_WORKDIR\")\n-                    || option.equals(\"DEBUGGER_TESTBASE\")) {\n-                if (value == null || value.equals(\"\")) {\n-                    throw new BadOption(\"Empty value of bind-file option \" + option);\n-                }\n-                return true;\n-            }\n-\n-            if (option.equals(\"DEBUGGEE_TESTED_JAVA_HOME\")\n-                    || option.equals(\"DEBUGGEE_WORKDIR\")\n-                    || option.equals(\"DEBUGGEE_TESTBASE\")) {\n-                if (value == null || value.equals(\"\")) {\n-                    throw new BadOption(\"Empty value of bind-file option \" + option);\n-                }\n-                checkDir(option, value);\n-                return true;\n-            }\n-\n-            if (option.equals(\"DEBUGGEE_WINDIR\")) {\n-                if (!(value == null || value.equals(\"\"))) {\n-                    checkDir(option, value);\n-                }\n-                return true;\n-            }\n-\n-            return false;\n-        }\n-\n-        \/**\n-         * Check if all recignized options form <i>bind-file<\/i> are compatible.\n-         *\/\n-        protected void checkAdditionalOptions() {\n-\n-            if (getDebuggerJavaHome() == null) {\n-                throw new BadOption(\"Option DEBUGGER_JAVA_HOME missed from bind-file\");\n-            }\n-            if (getDebuggerWorkDir() == null) {\n-                throw new BadOption(\"Option DEBUGGER_WORKDIR missed from bind-file\");\n-            }\n-            if (getDebuggerTestbase() == null) {\n-                throw new BadOption(\"Option DEBUGGER_TESTBASE missed from bind-file\");\n-            }\n-\n-            if (getDebugeeJavaHome() == null) {\n-                throw new BadOption(\"Option DEBUGGEE_JAVA_HOME missed from bind-file\");\n-            }\n-            if (getDebugeeWorkDir() == null) {\n-                throw new BadOption(\"Option DEBUGGEE_WORKDIR missed from bind-file\");\n-            }\n-            if (getDebugeeTestbase() == null) {\n-                throw new BadOption(\"Option DEBUGGEE_TESTBASE missed from bind-file\");\n-            }\n-        }\n-\n-        \/**\n-         * Parse options form specified <i>bind-file<\/i>.\n-         *\/\n-        protected void parseAdditionalOptions() {\n-            Enumeration keys = fileOptions.keys();\n-            while (keys.hasMoreElements()) {\n-                String option = (String)keys.nextElement();\n-                String value = fileOptions.getProperty(option);\n-                if (! checkAdditionalOption(option, value)) {\n-                    throw new BadOption(\"Unrecognized bind-file option: \" + option);\n-                }\n-            }\n-            checkAdditionalOptions();\n-        }\n-\n-        \/**\n-         * Parse all options from command line and specified <i>bind-file<\/i>.\n-         *\/\n-        protected void parseArguments() {\n-            super.parseArguments();\n-            String fileName = getBindFileName();\n-            try {\n-                FileInputStream bindFile = new FileInputStream(fileName);\n-                fileOptions = new Properties();\n-                fileOptions.load(bindFile);\n-                bindFile.close();\n-            } catch(FileNotFoundException e) {\n-                throw new BadOption(\"Unable to open bind-file \" + fileName + \": \" + e);\n-            } catch(IOException e) {\n-                e.printStackTrace(log.getOutStream());\n-                throw new Failure(\"Caught exception while reading bind-file:\\n\" + e);\n-            }\n-            parseAdditionalOptions();\n-        }\n-\n-        \/** Return name of specified <i>bind-file<i>. *\/\n-        public String getBindFileName() {\n-            return options.getProperty(\"bind.file\");\n-        }\n-\n-        \/** Return specified debuggee host name . *\/\n-        public String getDebuggerHost() {\n-            return fileOptions.getProperty(\"DEBUGGER_HOST\", \"localhost\");\n-        }\n-\n-        \/** Return string representation of port number for <code>BindServer<code> connection. *\/\n-        public String getBindPort() {\n-            return fileOptions.getProperty(\"BINDSERVER_PORT\", \"9000\");\n-        }\n-\n-        \/** Return specified port number for <code>BindServer<code> connection. *\/\n-        public int getBindPortNumber() {\n-            try {\n-                return Integer.parseInt(getBindPort());\n-            } catch (NumberFormatException e) {\n-                throw new Failure(\"Not integer value of BindServer port\");\n-            }\n-        }\n-\n-        \/** Return specified path to tested JDK used for debuggee VM. *\/\n-        public String getDebugeeJavaHome() {\n-            return fileOptions.getProperty(\"DEBUGGEE_TESTED_JAVA_HOME\");\n-        }\n-\n-        \/** Return specified path to tested JDK used for debugger. *\/\n-        public String getDebuggerJavaHome() {\n-            return fileOptions.getProperty(\"DEBUGGER_TESTED_JAVA_HOME\");\n-        }\n-\n-        \/** Return specified path to working dir from debuggee host. *\/\n-        public String getDebugeeWorkDir() {\n-            return fileOptions.getProperty(\"DEBUGGEE_WORKDIR\");\n-        }\n-\n-        \/** Return specified path to working dir from debugger host. *\/\n-        public String getDebuggerWorkDir() {\n-            return fileOptions.getProperty(\"DEBUGGER_WORKDIR\");\n-        }\n-\n-        \/** Return specified path to testbase dir from debuggee host. *\/\n-        public String getDebugeeTestbase() {\n-            return fileOptions.getProperty(\"DEBUGGEE_TESTBASE\");\n-        }\n-\n-        \/** Return specified path to testbase dir from debugger host. *\/\n-        public String getDebuggerTestbase() {\n-            return fileOptions.getProperty(\"DEBUGGER_TESTBASE\");\n-        }\n-\n-        \/** Return specified path to system directory on Wimdows platform. *\/\n-        public String getDebugeeWinDir() {\n-            return fileOptions.getProperty(\"DEBUGGEE_WINDIR\");\n-        }\n-\n-    } \/\/ ArgumentHandler\n-\n-} \/\/ BindServer\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/BindServer.java","additions":0,"deletions":1888,"binary":false,"changes":1888,"status":"deleted"},{"patch":"@@ -70,2 +70,0 @@\n- * <li> <code>-bind.port=<\/code>&lt;<i>port<\/i>&gt; -\n- *   port number for BindServer connection\n@@ -414,41 +412,0 @@\n-    private boolean bindPortInited = false;\n-    \/**\n-     * Return string representation of the port number for BindServer connection,\n-     * specified by <code>-bind.port<\/code> command line option, or\n-     * \"<i>DEFAULT_BIND_PORT<\/i>\" string by default.\n-     *\n-     * @see #getBindPortNumber()\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public String getBindPort() {\n-        String port = options.getProperty(\"bind.port\");\n-        if (port == null) {\n-            if (!bindPortInited) {\n-                port = findFreePort();\n-                if (port == null) {\n-                    port = DEFAULT_BIND_PORT;\n-                }\n-                options.setProperty(\"bind.port\", port);\n-                bindPortInited = true;\n-            }\n-        }\n-        return port;\n-    }\n-\n-    \/**\n-     * Return port number for BindServer connection,\n-     * specified by <code>-bind.port<\/code> command line option, or\n-     * \"<i>DEFAULT_BIND_PORT<\/i>\" port number by default.\n-     *\n-     * @see #getBindPort()\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public int getBindPortNumber() {\n-        String value = getBindPort();\n-        try {\n-            return Integer.parseInt(value);\n-        } catch (NumberFormatException e) {\n-            throw new TestBug(\"Not integer value of \\\"bind.port\\\" argument: \" + value);\n-        }\n-    }\n-\n@@ -671,1 +628,0 @@\n-            || option.equals(\"bind.port\")\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeArgumentHandler.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,0 @@\n- * @see BindServer\n@@ -56,0 +55,1 @@\n+ * @see nsk.share.jdb.Launcher\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeBinder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * that the process should be started in (locally, remotely or manually).\n+ * that the process should be started in (locally).\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeProcess.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,4 +32,1 @@\n- * This channel is based on TCP\/IP sockets and works in all\n- * modes (local, remote and manual). In a remote mode\n- * connection to <code>BindServer<\/code> is used for redirecting IOPipe messages.\n- * In all other modes direct TCP\/IP coonnection between two VMs is used.\n+ * This channel is based on TCP\/IP sockets.\n@@ -37,1 +34,2 @@\n- * @see BindServer\n+ * @see jpda.DebugeeArgumentHandler\n+ * @see jpda.DebugeeProcess\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/IOPipe.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"}]}