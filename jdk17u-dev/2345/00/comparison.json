{"files":[{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowPublisherVerification;\n-\n-import java.net.http.HttpRequest.BodyPublisher;\n-import java.net.http.HttpRequest.BodyPublishers;\n-import java.nio.ByteBuffer;\n-import java.util.Collections;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.concurrent.Flow.Publisher;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodyPublishersConcat\n-        extends FlowPublisherVerification<ByteBuffer> {\n-\n-    private static final int ELEMENT_SIZE = 16 * 1024;\n-\n-    public BodyPublishersConcat() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    private static BodyPublisher ofByteArrays(int n, byte[] bytes) {\n-        return BodyPublishers.ofByteArrays(Collections.nCopies((int) n, bytes));\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFlowPublisher(long nElements) {\n-        System.out.println(\"BodyPublishersConcat: %d elements requested\"\n-                .formatted(nElements));\n-        byte[] bytes = S.arrayOfNRandomBytes(ELEMENT_SIZE);\n-        if (nElements == 0) {\n-            System.out.println(\"BodyPublishersConcat: empty publisher\");\n-            return BodyPublishers.concat();\n-        } else if (nElements == 1) {\n-            System.out.println(\"BodyPublishersConcat: singleton publisher\");\n-            return BodyPublishers.concat(ofByteArrays(1, bytes));\n-        } else if (nElements < 4) {\n-            int left = (int)nElements\/2;\n-            int right = (int)nElements - left;\n-            System.out.println(\"BodyPublishersConcat: dual publisher (%d, %d)\".formatted(left, right));\n-            return BodyPublishers.concat(ofByteArrays(left, bytes),\n-                    ofByteArrays(right, bytes));\n-        } else {\n-            List<BodyPublisher> publishers = new ArrayList<>();\n-            List<Integer> sizes = new ArrayList<>();\n-            long remaining = nElements;\n-            int max = (int) Math.min((long)Integer.MAX_VALUE, nElements\/2L);\n-            while (remaining > 0) {\n-                int length = S.randomIntUpTo(max);\n-                if (length == 0) length = 1;\n-                sizes.add(length);\n-                if (remaining > length) {\n-                    publishers.add(ofByteArrays(length, bytes));\n-                    remaining = remaining - length;\n-                } else {\n-                    publishers.add(ofByteArrays((int)remaining, bytes));\n-                    remaining = 0;\n-                }\n-            }\n-            System.out.println(\"BodyPublishersConcat: multi publisher \" + sizes);\n-            return BodyPublishers.concat(publishers.toArray(BodyPublisher[]::new));\n-        }\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFailedFlowPublisher() {\n-        return null;\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodyPublishersConcat.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowPublisherVerification;\n-\n-import java.net.http.HttpRequest.BodyPublishers;\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.Flow.Publisher;\n-import java.util.stream.Stream;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodyPublishersFromPublisher\n-        extends FlowPublisherVerification<ByteBuffer> {\n-\n-    public BodyPublishersFromPublisher() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFlowPublisher(long nElements) {\n-        Stream<ByteBuffer> buffers =\n-                Stream.generate(() -> S.bufferOfNRandomBytes(1024))\n-                      .limit(nElements);\n-        Publisher<ByteBuffer> pub = S.publisherOfStream(buffers);\n-        return BodyPublishers.fromPublisher(pub);\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFailedFlowPublisher() {\n-        return BodyPublishers.fromPublisher(S.newErroredPublisher());\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodyPublishersFromPublisher.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowPublisherVerification;\n-\n-import java.net.http.HttpRequest.BodyPublishers;\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.Flow.Publisher;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodyPublishersNoBody\n-        extends FlowPublisherVerification<ByteBuffer> {\n-\n-    public BodyPublishersNoBody() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFlowPublisher(long nElements) {\n-        return BodyPublishers.noBody();\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFailedFlowPublisher() {\n-        return null;\n-    }\n-\n-    @Override\n-    public long maxElementsFromPublisher() {\n-        return 0;\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodyPublishersNoBody.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowPublisherVerification;\n-\n-import java.net.http.HttpRequest.BodyPublishers;\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.Flow.Publisher;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodyPublishersOfByteArray\n-        extends FlowPublisherVerification<ByteBuffer> {\n-\n-    private static final int ELEMENT_SIZE = 16 * 1024;\n-\n-    public BodyPublishersOfByteArray() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFlowPublisher(long nElements) {\n-        byte[] b = S.arrayOfNRandomBytes(nElements * ELEMENT_SIZE);\n-        return BodyPublishers.ofByteArray(b);\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFailedFlowPublisher() {\n-        return null;\n-    }\n-\n-    @Override\n-    public long maxElementsFromPublisher() {\n-        return 21;\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodyPublishersOfByteArray.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowPublisherVerification;\n-\n-import java.net.http.HttpRequest.BodyPublishers;\n-import java.nio.ByteBuffer;\n-import java.util.Collections;\n-import java.util.concurrent.Flow.Publisher;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodyPublishersOfByteArrays\n-        extends FlowPublisherVerification<ByteBuffer> {\n-\n-    private static final int ELEMENT_SIZE = 16 * 1024;\n-\n-    public BodyPublishersOfByteArrays() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFlowPublisher(long nElements) {\n-        byte[] bytes = S.arrayOfNRandomBytes(ELEMENT_SIZE);\n-        return BodyPublishers.ofByteArrays(\n-                Collections.nCopies((int) nElements, bytes));\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFailedFlowPublisher() {\n-        return null;\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodyPublishersOfByteArrays.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowPublisherVerification;\n-\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.net.http.HttpRequest.BodyPublishers;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.concurrent.Flow.Publisher;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodyPublishersOfFile\n-        extends FlowPublisherVerification<ByteBuffer> {\n-\n-    private static final int ELEMENT_SIZE = 16 * 1024;\n-    private static final AtomicLong UNIQUE_NUMBERS = new AtomicLong();\n-\n-    public BodyPublishersOfFile() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFlowPublisher(long nElements) {\n-        try {\n-            Path f = createFile(nElements * ELEMENT_SIZE);\n-            return BodyPublishers.ofFile(f);\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    }\n-\n-    private static Path createFile(long nBytes) throws IOException {\n-        String name = \"f\" + UNIQUE_NUMBERS.getAndIncrement();\n-        Path f = Files.createFile(Path.of(name));\n-        return Files.write(f, S.arrayOfNRandomBytes(nBytes));\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFailedFlowPublisher() {\n-        return null;\n-    }\n-\n-    @Override\n-    public long maxElementsFromPublisher() {\n-        return 21;\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodyPublishersOfFile.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowPublisherVerification;\n-\n-import java.io.InputStream;\n-import java.net.http.HttpRequest.BodyPublishers;\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.Flow.Publisher;\n-import java.util.function.Supplier;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodyPublishersOfInputStream\n-        extends FlowPublisherVerification<ByteBuffer> {\n-\n-    public BodyPublishersOfInputStream() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFlowPublisher(long nElements) {\n-        Supplier<InputStream> s = () -> S.inputStreamOfNReads((int) nElements);\n-        return BodyPublishers.ofInputStream(s);\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFailedFlowPublisher() {\n-        return null;\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodyPublishersOfInputStream.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowPublisherVerification;\n-\n-import java.net.http.HttpRequest.BodyPublishers;\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.Flow.Publisher;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodyPublishersOfSubByteArray\n-        extends FlowPublisherVerification<ByteBuffer> {\n-\n-    private static final int ELEMENT_SIZE = 16 * 1024;\n-\n-    public BodyPublishersOfSubByteArray() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFlowPublisher(long nElements) {\n-        int prefixLen = S.randomIntUpTo(13);\n-        int postfixLen = S.randomIntUpTo(17);\n-        byte[] b = S.arrayOfNRandomBytes(nElements * ELEMENT_SIZE);\n-        byte[] contents = new byte[prefixLen + b.length + postfixLen];\n-        System.arraycopy(b, 0, contents, prefixLen, b.length);\n-        return BodyPublishers.ofByteArray(contents, prefixLen, b.length);\n-    }\n-\n-    @Override\n-    public Publisher<ByteBuffer> createFailedFlowPublisher() {\n-        return null;\n-    }\n-\n-    @Override\n-    public long maxElementsFromPublisher() {\n-        return 21;\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodyPublishersOfSubByteArray.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersBuffering\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersBuffering() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.buffering(BodySubscribers.discarding(),\n-                                         S.randomIntUpTo(1024) + 1);\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.listOfBuffersFromBufferOfNBytes(element % 17);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersBuffering.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersDiscarding\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersDiscarding() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.discarding();\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.listOfBuffersFromBufferOfNBytes(element % 17);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersDiscarding.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersFromLineSubscriber\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersFromLineSubscriber() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.fromLineSubscriber(\n-                S.nonCompliantSubscriber());\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.scatterBuffer(\n-                S.bufferOfNRandomASCIIBytes(element % 17));\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersFromLineSubscriber.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersFromSubscriber\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersFromSubscriber() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        Subscriber<List<ByteBuffer>> sub = S.nonCompliantSubscriber();\n-        return BodySubscribers.fromSubscriber(sub);\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.scatterBuffer(\n-                S.bufferOfNRandomASCIIBytes(element % 17));\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersFromSubscriber.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersMapping\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersMapping() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.mapping(BodySubscribers.ofByteArray(),\n-                                       bytes -> bytes.length);\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.listOfBuffersFromBufferOfNBytes(element % 17);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersMapping.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersOfByteArray\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersOfByteArray() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.ofByteArray();\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.listOfBuffersFromBufferOfNBytes(element % 17);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersOfByteArray.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersOfByteArrayConsumer\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersOfByteArrayConsumer() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.ofByteArrayConsumer(bytes -> { });\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.listOfBuffersFromBufferOfNBytes(element % 17);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersOfByteArrayConsumer.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.nio.file.Path;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersOfFile\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersOfFile() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.ofFile(Path.of(\"f1.bin\"));\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.listOfBuffersFromBufferOfNBytes(element % 17);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersOfFile.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersOfInputStream\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersOfInputStream() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.ofInputStream();\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.listOfBuffersFromBufferOfNBytes(element % 17);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersOfInputStream.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.nio.charset.StandardCharsets;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersOfLines\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersOfLines() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.ofLines(StandardCharsets.UTF_8);\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.scatterBuffer(\n-                S.bufferOfNRandomASCIIBytes(element % 17));\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersOfLines.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscriber;\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.CompletionStage;\n-import java.util.concurrent.Flow.Publisher;\n-import java.util.concurrent.Flow.Subscriber;\n-import java.util.concurrent.Flow.Subscription;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersOfPublisher\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersOfPublisher() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    \/* The reason for overriding this method is that BodySubscribers.ofPublisher\n-       is somewhat tricky. It is not an independent Subscriber, but rather\n-       an adaptor from Subscriber to Publisher. Until the Subscriber that\n-       subscribed to that resulting Publisher requests anything, nothing\n-       happens. *\/\n-    @Override\n-    public void triggerFlowRequest(\n-            Subscriber<? super List<ByteBuffer>> subscriber)\n-    {\n-        BodySubscriber<Publisher<List<ByteBuffer>>> sub =\n-                (BodySubscriber<Publisher<List<ByteBuffer>>>) subscriber;\n-        CompletionStage<Publisher<List<ByteBuffer>>> body = sub.getBody();\n-        Publisher<List<ByteBuffer>> pub = body.toCompletableFuture().join();\n-        pub.subscribe(new Subscriber<>() {\n-\n-            @Override\n-            public void onSubscribe(Subscription subscription) {\n-                subscription.request(Integer.MAX_VALUE);\n-            }\n-\n-            @Override public void onNext(List<ByteBuffer> item) { }\n-            @Override public void onError(Throwable throwable) { }\n-            @Override public void onComplete() { }\n-        });\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.ofPublisher();\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.listOfBuffersFromBufferOfNBytes(element % 17);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersOfPublisher.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscriber;\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.CompletionStage;\n-import java.util.concurrent.Flow.Publisher;\n-import java.util.concurrent.Flow.Subscriber;\n-import java.util.concurrent.Flow.Subscription;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersOfPublisher1\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersOfPublisher1() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    \/* The reason for overriding this method is that BodySubscribers.ofPublisher\n-       is somewhat tricky. It is not an independent Subscriber, but rather\n-       an adaptor from Subscriber to Publisher. Until the Subscriber that\n-       subscribed to that resulting Publisher requests anything, nothing\n-       happens. *\/\n-    @Override\n-    public void triggerFlowRequest(\n-            Subscriber<? super List<ByteBuffer>> subscriber)\n-    {\n-        BodySubscriber<Publisher<List<ByteBuffer>>> sub =\n-                (BodySubscriber<Publisher<List<ByteBuffer>>>) subscriber;\n-        CompletionStage<Publisher<List<ByteBuffer>>> body = sub.getBody();\n-        Publisher<List<ByteBuffer>> pub = body.toCompletableFuture().join();\n-        pub.subscribe(new Subscriber<>() {\n-\n-            Subscription sub;\n-\n-            @Override\n-            public void onSubscribe(Subscription subscription) {\n-                (sub = subscription).request(1);\n-            }\n-\n-            @Override public void onNext(List<ByteBuffer> item) {\n-                sub.request(1);\n-            }\n-\n-            @Override public void onError(Throwable throwable) { }\n-            @Override public void onComplete() { }\n-        });\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.ofPublisher();\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.listOfBuffersFromBufferOfNBytes(element % 17);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersOfPublisher1.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowPublisherVerification;\n-\n-import java.net.http.HttpResponse.BodySubscriber;\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.Flow.Publisher;\n-import java.util.stream.Stream;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersOfPublisherPublisher\n-        extends FlowPublisherVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersOfPublisherPublisher() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Publisher<List<ByteBuffer>> createFlowPublisher(long nElements) {\n-        BodySubscriber<Publisher<List<ByteBuffer>>> sub =\n-                BodySubscribers.ofPublisher();\n-        Stream<List<ByteBuffer>> buffers =\n-                Stream.generate(() -> S.listOfBuffersFromBufferOfNBytes(1024))\n-                      .limit(nElements);\n-        Publisher<List<ByteBuffer>> pub = S.publisherOfStream(buffers);\n-        pub.subscribe(sub);\n-        return sub.getBody().toCompletableFuture().join();\n-    }\n-\n-    @Override\n-    public Publisher<List<ByteBuffer>> createFailedFlowPublisher() {\n-        BodySubscriber<Publisher<List<ByteBuffer>>> sub =\n-                BodySubscribers.ofPublisher();\n-        Publisher<List<ByteBuffer>> pub = S.newErroredPublisher();\n-        pub.subscribe(sub);\n-        return sub.getBody().toCompletableFuture().join();\n-    }\n-\n-    @Override\n-    public long maxElementsFromPublisher() {\n-        return 21;\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersOfPublisherPublisher.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.nio.charset.StandardCharsets;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersOfString\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersOfString() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        return BodySubscribers.ofString(StandardCharsets.UTF_8);\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.scatterBuffer(\n-                S.bufferOfNRandomASCIIBytes(element % 17));\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersOfString.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowSubscriberBlackboxVerification;\n-\n-import java.net.http.HttpResponse.BodySubscribers;\n-import java.nio.ByteBuffer;\n-import java.util.List;\n-import java.util.concurrent.Flow.Subscriber;\n-\n-\/* See TckDriver.java for more information *\/\n-public class BodySubscribersReplacing\n-        extends FlowSubscriberBlackboxVerification<List<ByteBuffer>> {\n-\n-    public BodySubscribersReplacing() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Subscriber<List<ByteBuffer>> createFlowSubscriber() {\n-        \/* it doesn't matter what we are replacing with *\/\n-        return BodySubscribers.replacing(Boolean.TRUE);\n-    }\n-\n-    @Override\n-    public List<ByteBuffer> createElement(int element) {\n-        return S.listOfBuffersFromBufferOfNBytes(element % 17);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/BodySubscribersReplacing.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,277 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.ByteBuffer;\n-import java.nio.charset.StandardCharsets;\n-import java.security.SecureRandom;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Random;\n-import java.util.concurrent.Flow.Publisher;\n-import java.util.concurrent.Flow.Subscriber;\n-import java.util.concurrent.Flow.Subscription;\n-import java.util.stream.Stream;\n-\n-\/*\n- * S for Support.\n- *\n- * Auxiliary methods for tests that check conformance with reactive streams\n- * specification.\n- *\n- * Short name is for the sake of convenience calling this class' static methods.\n- * It could've been called Support or TckSupport, but then we would need to\n- * place this class in its own package so as to use \"import static\".\n- *\/\n-public class S {\n-\n-    private static final Random RANDOM = new SecureRandom();\n-\n-    private S() { }\n-\n-    public static List<ByteBuffer> listOfBuffersFromBufferOfNBytes(int nBytes) {\n-        return scatterBuffer(bufferOfNRandomBytes(nBytes));\n-    }\n-\n-    \/*\n-     * Spreads the remaining contents of the given byte buffer across a number\n-     * of buffers put into a list.\n-     *\/\n-    public static List<ByteBuffer> scatterBuffer(ByteBuffer src) {\n-        List<ByteBuffer> buffers = new ArrayList<>();\n-        while (src.hasRemaining()) {\n-            \/\/ We do not allow empty buffers ~~~~~~~~~~~~~~~~v\n-            int capacity = RANDOM.nextInt(src.remaining()) + 1;\n-            ByteBuffer b = ByteBuffer.allocate(capacity);\n-            for (int i = 0; i < capacity; i++) {\n-                b.put(src.get());\n-            }\n-            b.flip();\n-            buffers.add(b);\n-        }\n-        return List.copyOf(buffers);\n-    }\n-\n-    public static ByteBuffer bufferOfNRandomBytes(int capacity) {\n-        return ByteBuffer.wrap(arrayOfNRandomBytes(capacity));\n-    }\n-\n-    public static byte[] arrayOfNRandomBytes(int nBytes) {\n-        byte[] contents = new byte[nBytes];\n-        RANDOM.nextBytes(contents);\n-        return contents;\n-    }\n-\n-    public static InputStream inputStreamOfNReads(long n) {\n-        return new NReadsInputStream(n);\n-    }\n-\n-    \/*\n-     * Convenience method for testing publishers.\n-     *\/\n-    public static byte[] arrayOfNRandomBytes(long nBytes) {\n-        return arrayOfNRandomBytes((int) nBytes);\n-    }\n-\n-    public static ByteBuffer bufferOfNRandomASCIIBytes(int capacity) {\n-        String alphaNumeric = \"abcdefghijklmnopqrstuvwxyz1234567890\";\n-        StringBuilder builder = new StringBuilder(capacity);\n-        for (int i = 0; i < capacity; i++) {\n-            int idx = RANDOM.nextInt(alphaNumeric.length());\n-            builder.append(alphaNumeric.charAt(idx));\n-        }\n-        return ByteBuffer.wrap(builder.toString().getBytes(\n-                StandardCharsets.US_ASCII));\n-    }\n-\n-    \/*\n-     * Returns a simple non-compliant Subscriber.\n-     *\n-     * This Subscriber is useful for testing our adaptors and wrappers, to make\n-     * sure they do not delegate RS compliance to the underlying (and foreign to\n-     * java.net.http codebase) Subscribers, but rather comply themselves.\n-     *\n-     * Here's an example:\n-     *\n-     *     public void onSubscribe(Subscription s) {\n-     *         delegate.onSubscribe(s);\n-     *     }\n-     *\n-     * The snippet above cannot be considered a good implementation of a\n-     * Subscriber if `delegate` is an unknown Subscriber. In this case the\n-     * implementation should independently check all the rules from the RS spec\n-     * related to subscribers.\n-     *\/\n-    public static <T> Subscriber<T> nonCompliantSubscriber() {\n-        return new Subscriber<>() {\n-\n-            @Override\n-            public void onSubscribe(Subscription subscription) {\n-                subscription.request(Long.MAX_VALUE);\n-            }\n-\n-            @Override\n-            public void onNext(T item) { }\n-\n-            @Override\n-            public void onError(Throwable throwable) { }\n-\n-            @Override\n-            public void onComplete() { }\n-        };\n-    }\n-\n-    public static int randomIntUpTo(int bound) {\n-        return RANDOM.nextInt(bound);\n-    }\n-\n-    \/*\n-     * Signals an error to its subscribers immediately after subscription.\n-     *\/\n-    public static <T> Publisher<T> newErroredPublisher() {\n-        return subscriber -> {\n-            subscriber.onSubscribe(new Subscription() {\n-                @Override\n-                public void request(long n) { }\n-\n-                @Override\n-                public void cancel() { }\n-            });\n-            subscriber.onError(new IOException());\n-        };\n-    }\n-\n-    \/*\n-     * Publishes the elements obtained from the stream and signals completion.\n-     * Can be cancelled, but cannot signal an error.\n-     *\n-     * This trivial ad-hoc implementation of Publisher was created so as to\n-     * publish lists of byte buffers. We can publish ByteBuffer, but we can't\n-     * seem to publish List<ByteBuffer> since there's no readily available\n-     * publisher of those, nor there's a simple adaptor.\n-     *\/\n-    public static <T> Publisher<T> publisherOfStream(Stream<? extends T> stream)\n-    {\n-        if (stream == null) {\n-            throw new NullPointerException();\n-        }\n-        return new Publisher<T>() {\n-            @Override\n-            public void subscribe(Subscriber<? super T> subscriber) {\n-                if (subscriber == null) {\n-                    throw new NullPointerException();\n-                }\n-                Subscription subscription = new Subscription() {\n-\n-                    boolean inOnNext; \/\/ recursion control\n-                    volatile boolean cancelled;\n-                    long demand;\n-                    final Iterator<? extends T> supply = stream.iterator();\n-\n-                    @Override\n-                    public void request(long n) {\n-                        demand = demand + n < 0 ? Long.MAX_VALUE : demand + n;\n-                        if (inOnNext) {\n-                            return;\n-                        }\n-                        if (cancelled)\n-                            return;\n-                        if (n <= 0) {\n-                            cancelled = true;\n-                            subscriber.onError(new IllegalArgumentException(\n-                                    \"non-positive subscription request\"));\n-                            return;\n-                        }\n-                        while (supply.hasNext() && demand > 0 && !cancelled) {\n-                            demand--;\n-                            inOnNext = true;\n-                            try {\n-                                T item = supply.next();\n-                                subscriber.onNext(item);\n-                            } finally {\n-                                inOnNext = false;\n-                            }\n-                        }\n-                        if (!supply.hasNext()) {\n-                            cancelled = true;\n-                            subscriber.onComplete();\n-                        }\n-                    }\n-\n-                    @Override\n-                    public void cancel() {\n-                        cancelled = true;\n-                    }\n-                };\n-                subscriber.onSubscribe(subscription);\n-            }\n-        };\n-    }\n-\n-    static final class NReadsInputStream extends InputStream {\n-\n-        private static final int EOF = -1;\n-        private long readsLeft;\n-\n-        NReadsInputStream(long n) {\n-            if (n < 0) {\n-                throw new IllegalArgumentException(String.valueOf(n));\n-            }\n-            this.readsLeft = n;\n-        }\n-\n-        @Override\n-        public int read() {\n-            if (readsLeft == 0L) {\n-                return EOF;\n-            }\n-            readsLeft--;\n-            return S.randomIntUpTo(256);\n-        }\n-\n-        @Override\n-        public int read(byte[] b, int off, int len) {\n-            Objects.checkFromIndexSize(off, len, b.length);\n-            \/\/ Must return 0 if len == 0,\n-            \/\/ even if there are no more reads left\n-            if (len == 0) {\n-                return 0;\n-            }\n-            if (readsLeft == 0L) {\n-                return EOF;\n-            }\n-            readsLeft--;\n-            \/\/ At least one byte MUST be read, but we can read\n-            \/\/ less than `len` bytes\n-            int r = RANDOM.nextInt(len) + 1;\n-            for (int i = 0; i < r; i++) {\n-                b[i] = (byte) randomIntUpTo(256);\n-            }\n-            return r;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/S.java","additions":0,"deletions":277,"binary":false,"changes":277,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.FlowPublisherVerification;\n-\n-import java.util.concurrent.Flow.Publisher;\n-import java.util.stream.LongStream;\n-import java.util.stream.Stream;\n-\n-\/* See TckDriver.java for more information *\/\n-public class SPublisherOfStream\n-        extends FlowPublisherVerification<Long> {\n-\n-    public SPublisherOfStream() {\n-        super(new TestEnvironment(450L));\n-    }\n-\n-    @Override\n-    public Publisher<Long> createFlowPublisher(long nElements) {\n-        Stream<Long> s = LongStream.range(0, nElements).boxed();\n-        return S.publisherOfStream(s);\n-    }\n-\n-    @Override\n-    public Publisher<Long> createFailedFlowPublisher() {\n-        return null;\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/SPublisherOfStream.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.ByteBuffer;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-\n-public class STest {\n-\n-    @DataProvider(name = \"bufferSizes\")\n-    public static Object[][] bufferSizes() {\n-        return new Object[][]{\n-                { 1},\n-                { 2},\n-                { 3},\n-                { 4},\n-                {16},\n-                {17},\n-        };\n-    }\n-\n-    @DataProvider\n-    public static Object[][] inputStream() {\n-        return new Object[][] {\n-                {  0,   1},\n-                {  1,   2},\n-                {  1,   3},\n-                {  1,   4},\n-                {  2,   1},\n-                {  2,   2},\n-                {  2,   3},\n-                {  2,   4},\n-                {  2,  13},\n-                {  3,   1},\n-                {  3,   2},\n-                {  3,   3},\n-                {  3,   4},\n-                {  3,  17},\n-                {  4,   1},\n-                {  4,   2},\n-                {  4,   3},\n-                {  4,   4},\n-                {  4,   5},\n-                { 13,   1},\n-                { 13,   2},\n-                { 13,  13},\n-                { 16,  18},\n-                { 17,   2},\n-                {255,   1},\n-                {256, 255},\n-                {257, 267},\n-        };\n-    }\n-\n-    @Test\n-    public void testScatter0() {\n-        List<ByteBuffer> buffers = S.scatterBuffer(\n-                ByteBuffer.allocate(0));\n-        assertEquals(buffers.size(), 0);\n-    }\n-\n-    @Test(dataProvider = \"bufferSizes\")\n-    public void testScatterN(int n) {\n-        final ByteBuffer src = S.bufferOfNRandomBytes(n);\n-        final int srcLength = src.remaining();\n-        ByteBuffer copy = ByteBuffer.wrap(Arrays.copyOf(src.array(),\n-                                                        src.array().length));\n-        List<ByteBuffer> buffers = S.scatterBuffer(src);\n-        int m = 0;\n-        for (ByteBuffer b : buffers) {\n-            m += b.remaining();\n-            while (b.hasRemaining() & copy.hasRemaining()) {\n-                assertEquals(b.get(), copy.get());\n-            }\n-        }\n-        assertEquals(m, srcLength);\n-    }\n-\n-    @Test(dataProvider = \"inputStream\")\n-    public void testInputStreamOfNReads(int n, int capacity) throws IOException {\n-        InputStream s = S.inputStreamOfNReads(n);\n-        int count = 0;\n-        byte[] b = new byte[capacity];\n-        while (s.read(b) != -1) {\n-            count++;\n-        }\n-        assertEquals(count, n);\n-        assertTrue(s.read() == -1);\n-        assertTrue(s.read(b) == -1);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/STest.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -1,158 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8226602\n- * @summary Tests convenience reactive primitives with RS TCK\n- *\n- * @library ..\/reactivestreams-tck\n- * @build S\n- *\n- * @compile -encoding UTF-8 SPublisherOfStream.java\n- *\n- * @compile -encoding UTF-8 BodyPublishersFromPublisher.java\n- * @compile -encoding UTF-8 BodyPublishersNoBody.java\n- * @compile -encoding UTF-8 BodyPublishersOfByteArray.java\n- * @compile -encoding UTF-8 BodyPublishersOfByteArrays.java\n- * @compile -encoding UTF-8 BodyPublishersOfFile.java\n- * @compile -encoding UTF-8 BodyPublishersOfInputStream.java\n- * @compile -encoding UTF-8 BodyPublishersOfSubByteArray.java\n- * @compile -encoding UTF-8 BodyPublishersConcat.java\n- *\n- * @compile -encoding UTF-8 BodySubscribersBuffering.java\n- * @compile -encoding UTF-8 BodySubscribersDiscarding.java\n- * @compile -encoding UTF-8 BodySubscribersFromLineSubscriber.java\n- * @compile -encoding UTF-8 BodySubscribersFromSubscriber.java\n- * @compile -encoding UTF-8 BodySubscribersMapping.java\n- * @compile -encoding UTF-8 BodySubscribersOfByteArray.java\n- * @compile -encoding UTF-8 BodySubscribersOfByteArrayConsumer.java\n- * @compile -encoding UTF-8 BodySubscribersOfFile.java\n- * @compile -encoding UTF-8 BodySubscribersOfInputStream.java\n- * @compile -encoding UTF-8 BodySubscribersOfLines.java\n- * @compile -encoding UTF-8 BodySubscribersOfPublisher.java\n- * @compile -encoding UTF-8 BodySubscribersOfPublisher1.java\n- * @compile -encoding UTF-8 BodySubscribersOfPublisherPublisher.java\n- * @compile -encoding UTF-8 BodySubscribersOfString.java\n- * @compile -encoding UTF-8 BodySubscribersReplacing.java\n- *\n- * @run testng\/othervm STest\n- * @run testng\/othervm SPublisherOfStream\n- *\n- * @run testng\/othervm BodyPublishersFromPublisher\n- * @run testng\/othervm BodyPublishersNoBody\n- * @run testng\/othervm BodyPublishersOfByteArray\n- * @run testng\/othervm BodyPublishersOfByteArrays\n- * @run testng\/othervm BodyPublishersOfFile\n- * @run testng\/othervm BodyPublishersOfInputStream\n- * @run testng\/othervm BodyPublishersOfSubByteArray\n- * @run testng\/othervm BodyPublishersConcat\n- *\n- * @run testng\/othervm BodySubscribersBuffering\n- * @run testng\/othervm BodySubscribersDiscarding\n- * @run testng\/othervm BodySubscribersFromLineSubscriber\n- * @run testng\/othervm BodySubscribersFromSubscriber\n- * @run testng\/othervm BodySubscribersMapping\n- * @run testng\/othervm BodySubscribersOfByteArray\n- * @run testng\/othervm BodySubscribersOfByteArrayConsumer\n- * @run testng\/othervm BodySubscribersOfFile\n- * @run testng\/othervm BodySubscribersOfInputStream\n- * @run testng\/othervm BodySubscribersOfLines\n- * @run testng\/othervm BodySubscribersOfPublisher\n- * @run testng\/othervm BodySubscribersOfPublisher1\n- * @run testng\/othervm BodySubscribersOfPublisherPublisher\n- * @run testng\/othervm BodySubscribersOfString\n- * @run testng\/othervm BodySubscribersReplacing\n- *\n- * @key randomness\n- *\/\n-public class TckDriver {\n-   \/*\n-        #### General Information\n-\n-        1. This JTREG test aggregates multiple TestNG tests. This is because\n-        these tests share a common library (reactivestreams-tck), and we don't\n-        want this library to be compiled separately for each of those tests.\n-\n-        2. Tests that use RS TCK are compiled with the UTF-8 encoding. This is\n-        performed for the sake of reactivestreams-tck. We don't want to patch\n-        the TCK because of the extra merging work in the future, should we bring\n-        update(s) from the RS repo.\n-\n-        #### Tests\n-\n-        1. The purpose of each test should be easily digestible. The name of the\n-        test is derived from the very entity the test exercises. For example,\n-\n-            the BodyPublishersOfFile test exercises the BodyPublisher obtained\n-            by calling BodyPublishers.ofFile(Path)\n-\n-            the BodySubscribersOfFile test exercises the BodySubscriber obtained\n-            by calling BodySubscribers.ofFile(Path)\n-\n-        2. RS TCK requires PublisherVerification tests to produce publishers\n-        capable of emitting a certain number of elements. In order to achieve\n-        this, we use some knowledge of the internal workings of our publishers.\n-        An example would be a chunk size a publisher uses to deliver a portion\n-        of data. Without knowing that it is not possible to guarantee that the\n-        publisher will emit a particular number of elements.\n-\n-        3. Typically our publishers cannot be created in a known failed state.\n-        In this case the corresponding `createFailedFlowPublisher` method\n-        returns `null`.\n-\n-        4. SubscriberBlackBoxVerification uses the `createElement(int element)`\n-        method. Our implementations usually cap the amount of data created by\n-        this method, because it's not known beforehand how big the `element`\n-        value is. Hence, sometimes there's code like as follows:\n-\n-            @Override\n-            public List<ByteBuffer> createElement(int element) {\n-                return scatterBuffer(\n-                        bufferOfNRandomASCIIBytes(element % 17));\n-            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^\n-            }\n-\n-        5. The amount of testing RS TCK performs on a publisher seems to depend\n-        on the number of elements this publisher reports it can emit. Sometimes\n-        a code like the following can be seen in the tests:\n-\n-                @Override public long maxElementsFromPublisher() {\n-                    return 21;\n-                ~~~~~~~~~~~^\n-                }\n-\n-        This magic number is a result of trial and error and seems to unlock\n-        most of the tests. Reporting big values (e.g. Long.MAX_VALUE - 1) is\n-        not an option for most of our publishers because they require to have\n-        all the elements upfront.\n-\n-        6. It doesn't seem currently feasible to provide SubscriberWhiteboxVerification\n-        tests as a) it's not clear how much better the coverage is and b) it's\n-        significantly harder to code that.\n-\n-        #### S (Support)\n-\n-        Support utilities are being tested (STest) too.\n-    *\/\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck-tests\/TckDriver.java","additions":0,"deletions":158,"binary":false,"changes":158,"status":"deleted"},{"patch":"@@ -1,389 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams;\n-\n-import java.util.concurrent.Flow;\n-import static java.util.Objects.requireNonNull;\n-\n-\/**\n- * Bridge between Reactive Streams API and the Java 9 {@link java.util.concurrent.Flow} API.\n- *\/\n-public final class FlowAdapters {\n-    \/** Utility class. *\/\n-    private FlowAdapters() {\n-        throw new IllegalStateException(\"No instances!\");\n-    }\n-\n-    \/**\n-     * Converts a Flow Publisher into a Reactive Streams Publisher.\n-     * @param <T> the element type\n-     * @param flowPublisher the source Flow Publisher to convert\n-     * @return the equivalent Reactive Streams Publisher\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    public static <T> org.reactivestreams.Publisher<T> toPublisher(\n-            Flow.Publisher<? extends T> flowPublisher) {\n-        requireNonNull(flowPublisher, \"flowPublisher\");\n-        final org.reactivestreams.Publisher<T> publisher;\n-        if (flowPublisher instanceof FlowPublisherFromReactive) {\n-            publisher = (org.reactivestreams.Publisher<T>)(((FlowPublisherFromReactive<T>)flowPublisher).reactiveStreams);\n-        } else if (flowPublisher instanceof org.reactivestreams.Publisher) {\n-            publisher = (org.reactivestreams.Publisher<T>)flowPublisher;\n-        } else {\n-            publisher = new ReactivePublisherFromFlow<T>(flowPublisher);\n-        }\n-        return publisher;\n-    }\n-\n-    \/**\n-     * Converts a Reactive Streams Publisher into a Flow Publisher.\n-     * @param <T> the element type\n-     * @param reactiveStreamsPublisher the source Reactive Streams Publisher to convert\n-     * @return the equivalent Flow Publisher\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    public static <T> Flow.Publisher<T> toFlowPublisher(\n-            org.reactivestreams.Publisher<? extends T> reactiveStreamsPublisher\n-    ) {\n-        requireNonNull(reactiveStreamsPublisher, \"reactiveStreamsPublisher\");\n-        final Flow.Publisher<T> flowPublisher;\n-        if (reactiveStreamsPublisher instanceof ReactivePublisherFromFlow) {\n-            flowPublisher = (Flow.Publisher<T>)(((ReactivePublisherFromFlow<T>)reactiveStreamsPublisher).flow);\n-        } else if (reactiveStreamsPublisher instanceof Flow.Publisher) {\n-            flowPublisher = (Flow.Publisher<T>)reactiveStreamsPublisher;\n-        } else {\n-            flowPublisher = new FlowPublisherFromReactive<T>(reactiveStreamsPublisher);\n-        }\n-        return flowPublisher;\n-    }\n-\n-    \/**\n-     * Converts a Flow Processor into a Reactive Streams Processor.\n-     * @param <T> the input value type\n-     * @param <U> the output value type\n-     * @param flowProcessor the source Flow Processor to convert\n-     * @return the equivalent Reactive Streams Processor\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    public static <T, U> org.reactivestreams.Processor<T, U> toProcessor(\n-            Flow.Processor<? super T, ? extends U> flowProcessor\n-    ) {\n-        requireNonNull(flowProcessor, \"flowProcessor\");\n-        final org.reactivestreams.Processor<T, U> processor;\n-        if (flowProcessor instanceof FlowToReactiveProcessor) {\n-            processor = (org.reactivestreams.Processor<T, U>)(((FlowToReactiveProcessor<T, U>)flowProcessor).reactiveStreams);\n-        } else if (flowProcessor instanceof org.reactivestreams.Processor) {\n-            processor = (org.reactivestreams.Processor<T, U>)flowProcessor;\n-        } else {\n-            processor = new ReactiveToFlowProcessor<T, U>(flowProcessor);\n-        }\n-        return processor;\n-    }\n-\n-    \/**\n-     * Converts a Reactive Streams Processor into a Flow Processor.\n-     * @param <T> the input value type\n-     * @param <U> the output value type\n-     * @param reactiveStreamsProcessor the source Reactive Streams Processor to convert\n-     * @return the equivalent Flow Processor\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    public static <T, U> Flow.Processor<T, U> toFlowProcessor(\n-            org.reactivestreams.Processor<? super T, ? extends U> reactiveStreamsProcessor\n-        ) {\n-        requireNonNull(reactiveStreamsProcessor, \"reactiveStreamsProcessor\");\n-        final Flow.Processor<T, U> flowProcessor;\n-        if (reactiveStreamsProcessor instanceof ReactiveToFlowProcessor) {\n-            flowProcessor = (Flow.Processor<T, U>)(((ReactiveToFlowProcessor<T, U>)reactiveStreamsProcessor).flow);\n-        } else if (reactiveStreamsProcessor instanceof Flow.Processor) {\n-            flowProcessor = (Flow.Processor<T, U>)reactiveStreamsProcessor;\n-        } else {\n-            flowProcessor = new FlowToReactiveProcessor<T, U>(reactiveStreamsProcessor);\n-        }\n-        return flowProcessor;\n-    }\n-\n-    \/**\n-     * Converts a Reactive Streams Subscriber into a Flow Subscriber.\n-     * @param <T> the input and output value type\n-     * @param reactiveStreamsSubscriber the Reactive Streams Subscriber instance to convert\n-     * @return the equivalent Flow Subscriber\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    public static <T> Flow.Subscriber<T> toFlowSubscriber(org.reactivestreams.Subscriber<T> reactiveStreamsSubscriber) {\n-        requireNonNull(reactiveStreamsSubscriber, \"reactiveStreamsSubscriber\");\n-        final Flow.Subscriber<T> flowSubscriber;\n-        if (reactiveStreamsSubscriber instanceof ReactiveToFlowSubscriber) {\n-            flowSubscriber = (Flow.Subscriber<T>)((ReactiveToFlowSubscriber<T>)reactiveStreamsSubscriber).flow;\n-        } else if (reactiveStreamsSubscriber instanceof Flow.Subscriber) {\n-            flowSubscriber = (Flow.Subscriber<T>)reactiveStreamsSubscriber;\n-        } else {\n-            flowSubscriber = new FlowToReactiveSubscriber<T>(reactiveStreamsSubscriber);\n-        }\n-        return flowSubscriber;\n-    }\n-\n-    \/**\n-     * Converts a Flow Subscriber into a Reactive Streams Subscriber.\n-     * @param <T> the input and output value type\n-     * @param flowSubscriber the Flow Subscriber instance to convert\n-     * @return the equivalent Reactive Streams Subscriber\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    public static <T> org.reactivestreams.Subscriber<T> toSubscriber(Flow.Subscriber<T> flowSubscriber) {\n-        requireNonNull(flowSubscriber, \"flowSubscriber\");\n-        final org.reactivestreams.Subscriber<T> subscriber;\n-        if (flowSubscriber instanceof FlowToReactiveSubscriber) {\n-            subscriber = (org.reactivestreams.Subscriber<T>)((FlowToReactiveSubscriber<T>)flowSubscriber).reactiveStreams;\n-        } else if (flowSubscriber instanceof org.reactivestreams.Subscriber) {\n-            subscriber = (org.reactivestreams.Subscriber<T>)flowSubscriber;\n-        } else {\n-            subscriber = new ReactiveToFlowSubscriber<T>(flowSubscriber);\n-        }\n-        return subscriber;\n-    }\n-\n-    \/**\n-     * Wraps a Reactive Streams Subscription and converts the calls to a Flow Subscription.\n-     *\/\n-    static final class FlowToReactiveSubscription implements Flow.Subscription {\n-        final org.reactivestreams.Subscription reactiveStreams;\n-\n-        public FlowToReactiveSubscription(org.reactivestreams.Subscription reactive) {\n-            this.reactiveStreams = reactive;\n-        }\n-\n-        @Override\n-        public void request(long n) {\n-            reactiveStreams.request(n);\n-        }\n-\n-        @Override\n-        public void cancel() {\n-            reactiveStreams.cancel();\n-        }\n-\n-    }\n-\n-    \/**\n-     * Wraps a Flow Subscription and converts the calls to a Reactive Streams Subscription.\n-     *\/\n-    static final class ReactiveToFlowSubscription implements org.reactivestreams.Subscription {\n-        final Flow.Subscription flow;\n-\n-        public ReactiveToFlowSubscription(Flow.Subscription flow) {\n-            this.flow = flow;\n-        }\n-\n-        @Override\n-        public void request(long n) {\n-            flow.request(n);\n-        }\n-\n-        @Override\n-        public void cancel() {\n-            flow.cancel();\n-        }\n-\n-\n-    }\n-\n-    \/**\n-     * Wraps a Reactive Streams Subscriber and forwards methods of the Flow Subscriber to it.\n-     * @param <T> the element type\n-     *\/\n-    static final class FlowToReactiveSubscriber<T> implements Flow.Subscriber<T> {\n-        final org.reactivestreams.Subscriber<? super T> reactiveStreams;\n-\n-        public FlowToReactiveSubscriber(org.reactivestreams.Subscriber<? super T> reactive) {\n-            this.reactiveStreams = reactive;\n-        }\n-\n-        @Override\n-        public void onSubscribe(Flow.Subscription subscription) {\n-            reactiveStreams.onSubscribe((subscription == null) ? null : new ReactiveToFlowSubscription(subscription));\n-        }\n-\n-        @Override\n-        public void onNext(T item) {\n-            reactiveStreams.onNext(item);\n-        }\n-\n-        @Override\n-        public void onError(Throwable throwable) {\n-            reactiveStreams.onError(throwable);\n-        }\n-\n-        @Override\n-        public void onComplete() {\n-            reactiveStreams.onComplete();\n-        }\n-\n-    }\n-\n-    \/**\n-     * Wraps a Flow Subscriber and forwards methods of the Reactive Streams Subscriber to it.\n-     * @param <T> the element type\n-     *\/\n-    static final class ReactiveToFlowSubscriber<T> implements org.reactivestreams.Subscriber<T> {\n-        final Flow.Subscriber<? super T> flow;\n-\n-        public ReactiveToFlowSubscriber(Flow.Subscriber<? super T> flow) {\n-            this.flow = flow;\n-        }\n-\n-        @Override\n-        public void onSubscribe(org.reactivestreams.Subscription subscription) {\n-            flow.onSubscribe((subscription == null) ? null : new FlowToReactiveSubscription(subscription));\n-        }\n-\n-        @Override\n-        public void onNext(T item) {\n-            flow.onNext(item);\n-        }\n-\n-        @Override\n-        public void onError(Throwable throwable) {\n-            flow.onError(throwable);\n-        }\n-\n-        @Override\n-        public void onComplete() {\n-            flow.onComplete();\n-        }\n-\n-    }\n-\n-    \/**\n-     * Wraps a Flow Processor and forwards methods of the Reactive Streams Processor to it.\n-     * @param <T> the input type\n-     * @param <U> the output type\n-     *\/\n-    static final class ReactiveToFlowProcessor<T, U> implements org.reactivestreams.Processor<T, U> {\n-        final Flow.Processor<? super T, ? extends U> flow;\n-\n-        public ReactiveToFlowProcessor(Flow.Processor<? super T, ? extends U> flow) {\n-            this.flow = flow;\n-        }\n-\n-        @Override\n-        public void onSubscribe(org.reactivestreams.Subscription subscription) {\n-            flow.onSubscribe((subscription == null) ? null : new FlowToReactiveSubscription(subscription));\n-        }\n-\n-        @Override\n-        public void onNext(T t) {\n-            flow.onNext(t);\n-        }\n-\n-        @Override\n-        public void onError(Throwable t) {\n-            flow.onError(t);\n-        }\n-\n-        @Override\n-        public void onComplete() {\n-            flow.onComplete();\n-        }\n-\n-        @Override\n-        public void subscribe(org.reactivestreams.Subscriber<? super U> s) {\n-            flow.subscribe((s == null) ? null : new FlowToReactiveSubscriber<U>(s));\n-        }\n-    }\n-\n-    \/**\n-     * Wraps a Reactive Streams Processor and forwards methods of the Flow Processor to it.\n-     * @param <T> the input type\n-     * @param <U> the output type\n-     *\/\n-    static final class FlowToReactiveProcessor<T, U> implements Flow.Processor<T, U> {\n-        final org.reactivestreams.Processor<? super T, ? extends U> reactiveStreams;\n-\n-        public FlowToReactiveProcessor(org.reactivestreams.Processor<? super T, ? extends U> reactive) {\n-            this.reactiveStreams = reactive;\n-        }\n-\n-        @Override\n-        public void onSubscribe(Flow.Subscription subscription) {\n-            reactiveStreams.onSubscribe((subscription == null) ? null : new ReactiveToFlowSubscription(subscription));\n-        }\n-\n-        @Override\n-        public void onNext(T t) {\n-            reactiveStreams.onNext(t);\n-        }\n-\n-        @Override\n-        public void onError(Throwable t) {\n-            reactiveStreams.onError(t);\n-        }\n-\n-        @Override\n-        public void onComplete() {\n-            reactiveStreams.onComplete();\n-        }\n-\n-        @Override\n-        public void subscribe(Flow.Subscriber<? super U> s) {\n-            reactiveStreams.subscribe((s == null) ? null : new ReactiveToFlowSubscriber<U>(s));\n-        }\n-    }\n-\n-    \/**\n-     * Reactive Streams Publisher that wraps a Flow Publisher.\n-     * @param <T> the element type\n-     *\/\n-    static final class ReactivePublisherFromFlow<T> implements org.reactivestreams.Publisher<T> {\n-        final Flow.Publisher<? extends T> flow;\n-\n-        public ReactivePublisherFromFlow(Flow.Publisher<? extends T> flowPublisher) {\n-            this.flow = flowPublisher;\n-        }\n-\n-        @Override\n-        public void subscribe(org.reactivestreams.Subscriber<? super T> reactive) {\n-            flow.subscribe((reactive == null) ? null : new FlowToReactiveSubscriber<T>(reactive));\n-        }\n-    }\n-\n-    \/**\n-     * Flow Publisher that wraps a Reactive Streams Publisher.\n-     * @param <T> the element type\n-     *\/\n-    static final class FlowPublisherFromReactive<T> implements Flow.Publisher<T> {\n-\n-        final org.reactivestreams.Publisher<? extends T> reactiveStreams;\n-\n-        public FlowPublisherFromReactive(org.reactivestreams.Publisher<? extends T> reactivePublisher) {\n-            this.reactiveStreams = reactivePublisher;\n-        }\n-\n-        @Override\n-        public void subscribe(Flow.Subscriber<? super T> flow) {\n-            reactiveStreams.subscribe((flow == null) ? null : new ReactiveToFlowSubscriber<T>(flow));\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/FlowAdapters.java","additions":0,"deletions":389,"binary":false,"changes":389,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams;\n-\n-\/**\n- * A Processor represents a processing stagewhich is both a {@link Subscriber}\n- * and a {@link Publisher} and obeys the contracts of both.\n- *\n- * @param <T> the type of element signaled to the {@link Subscriber}\n- * @param <R> the type of element signaled by the {@link Publisher}\n- *\/\n-public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/Processor.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams;\n-\n-\/**\n- * A {@link Publisher} is a provider of a potentially unbounded number of sequenced elements, publishing them according to\n- * the demand received from its {@link Subscriber}(s).\n- * <p>\n- * A {@link Publisher} can serve multiple {@link Subscriber}s subscribed {@link #subscribe(Subscriber)} dynamically\n- * at various points in time.\n- *\n- * @param <T> the type of element signaled.\n- *\/\n-public interface Publisher<T> {\n-\n-    \/**\n-     * Request {@link Publisher} to start streaming data.\n-     * <p>\n-     * This is a \"factory method\" and can be called multiple times, each time starting a new {@link Subscription}.\n-     * <p>\n-     * Each {@link Subscription} will work for only a single {@link Subscriber}.\n-     * <p>\n-     * A {@link Subscriber} should only subscribe once to a single {@link Publisher}.\n-     * <p>\n-     * If the {@link Publisher} rejects the subscription attempt or otherwise fails it will\n-     * signal the error via {@link Subscriber#onError}.\n-     *\n-     * @param s the {@link Subscriber} that will consume signals from this {@link Publisher}\n-     *\/\n-    public void subscribe(Subscriber<? super T> s);\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/Publisher.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams;\n-\n-\/**\n- * Will receive call to {@link #onSubscribe(Subscription)} once after passing an instance of {@link Subscriber} to {@link Publisher#subscribe(Subscriber)}.\n- * <p>\n- * No further notifications will be received until {@link Subscription#request(long)} is called.\n- * <p>\n- * After signaling demand:\n- * <ul>\n- * <li>One or more invocations of {@link #onNext(Object)} up to the maximum number defined by {@link Subscription#request(long)}<\/li>\n- * <li>Single invocation of {@link #onError(Throwable)} or {@link Subscriber#onComplete()} which signals a terminal state after which no further events will be sent.\n- * <\/ul>\n- * <p>\n- * Demand can be signaled via {@link Subscription#request(long)} whenever the {@link Subscriber} instance is capable of handling more.\n- *\n- * @param <T> the type of element signaled.\n- *\/\n-public interface Subscriber<T> {\n-    \/**\n-     * Invoked after calling {@link Publisher#subscribe(Subscriber)}.\n-     * <p>\n-     * No data will start flowing until {@link Subscription#request(long)} is invoked.\n-     * <p>\n-     * It is the responsibility of this {@link Subscriber} instance to call {@link Subscription#request(long)} whenever more data is wanted.\n-     * <p>\n-     * The {@link Publisher} will send notifications only in response to {@link Subscription#request(long)}.\n-     *\n-     * @param s\n-     *            {@link Subscription} that allows requesting data via {@link Subscription#request(long)}\n-     *\/\n-    public void onSubscribe(Subscription s);\n-\n-    \/**\n-     * Data notification sent by the {@link Publisher} in response to requests to {@link Subscription#request(long)}.\n-     *\n-     * @param t the element signaled\n-     *\/\n-    public void onNext(T t);\n-\n-    \/**\n-     * Failed terminal state.\n-     * <p>\n-     * No further events will be sent even if {@link Subscription#request(long)} is invoked again.\n-     *\n-     * @param t the throwable signaled\n-     *\/\n-    public void onError(Throwable t);\n-\n-    \/**\n-     * Successful terminal state.\n-     * <p>\n-     * No further events will be sent even if {@link Subscription#request(long)} is invoked again.\n-     *\/\n-    public void onComplete();\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/Subscriber.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams;\n-\n-\/**\n- * A {@link Subscription} represents a one-to-one lifecycle of a {@link Subscriber} subscribing to a {@link Publisher}.\n- * <p>\n- * It can only be used once by a single {@link Subscriber}.\n- * <p>\n- * It is used to both signal desire for data and cancel demand (and allow resource cleanup).\n- *\n- *\/\n-public interface Subscription {\n-    \/**\n-     * No events will be sent by a {@link Publisher} until demand is signaled via this method.\n-     * <p>\n-     *  It can be called however often and whenever neededbut if the outstanding cumulative demand ever becomes Long.MAX_VALUE or more,\n-     *  it may be treated by the {@link Publisher} as \"effectively unbounded\".\n-     * <p>\n-     * Whatever has been requested can be sent by the {@link Publisher} so only signal demand for what can be safely handled.\n-     * <p>\n-     * A {@link Publisher} can send less than is requested if the stream ends but\n-     * then must emit either {@link Subscriber#onError(Throwable)} or {@link Subscriber#onComplete()}.\n-     *\n-     * @param n the strictly positive number of elements to requests to the upstream {@link Publisher}\n-     *\/\n-    public void request(long n);\n-\n-    \/**\n-     * Request the {@link Publisher} to stop sending data and clean up resources.\n-     * <p>\n-     * Data may still be sent to meet previously signalled demand after calling cancel.\n-     *\/\n-    public void cancel();\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/Subscription.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,281 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.example.unicast;\n-\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-\n-import java.util.Iterator;\n-import java.util.Collections;\n-import java.util.concurrent.Executor;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-\n-\/**\n- * AsyncIterablePublisher is an implementation of Reactive Streams `Publisher`\n- * which executes asynchronously, using a provided `Executor` and produces elements\n- * from a given `Iterable` in a \"unicast\" configuration to its `Subscribers`.\n- *\n- * NOTE: The code below uses a lot of try-catches to show the reader where exceptions can be expected, and where they are forbidden.\n- *\/\n-public class AsyncIterablePublisher<T> implements Publisher<T> {\n-  private final static int DEFAULT_BATCHSIZE = 1024;\n-\n-  private final Iterable<T> elements; \/\/ This is our data source \/ generator\n-  private final Executor executor; \/\/ This is our thread pool, which will make sure that our Publisher runs asynchronously to its Subscribers\n-  private final int batchSize; \/\/ In general, if one uses an `Executor`, one should be nice nad not hog a thread for too long, this is the cap for that, in elements\n-\n-  public AsyncIterablePublisher(final Iterable<T> elements, final Executor executor) {\n-    this(elements, DEFAULT_BATCHSIZE, executor);\n-  }\n-\n-  public AsyncIterablePublisher(final Iterable<T> elements, final int batchSize, final Executor executor) {\n-    if (elements == null) throw null;\n-    if (executor == null) throw null;\n-    if (batchSize < 1) throw new IllegalArgumentException(\"batchSize must be greater than zero!\");\n-    this.elements = elements;\n-    this.executor = executor;\n-    this.batchSize = batchSize;\n-  }\n-\n-  @Override\n-  public void subscribe(final Subscriber<? super T> s) {\n-    \/\/ As per rule 1.11, we have decided to support multiple subscribers in a unicast configuration\n-    \/\/ for this `Publisher` implementation.\n-    \/\/ As per 2.13, this method must return normally (i.e. not throw)\n-    new SubscriptionImpl(s).init();\n-  }\n-\n-  \/\/ These represent the protocol of the `AsyncIterablePublishers` SubscriptionImpls\n-  static interface Signal {};\n-  enum Cancel implements Signal { Instance; };\n-  enum Subscribe implements Signal { Instance; };\n-  enum Send implements Signal { Instance; };\n-  static final class Request implements Signal {\n-    final long n;\n-    Request(final long n) {\n-      this.n = n;\n-    }\n-  };\n-\n-  \/\/ This is our implementation of the Reactive Streams `Subscription`,\n-  \/\/ which represents the association between a `Publisher` and a `Subscriber`.\n-  final class SubscriptionImpl implements Subscription, Runnable {\n-    final Subscriber<? super T> subscriber; \/\/ We need a reference to the `Subscriber` so we can talk to it\n-    private boolean cancelled = false; \/\/ This flag will track whether this `Subscription` is to be considered cancelled or not\n-    private long demand = 0; \/\/ Here we track the current demand, i.e. what has been requested but not yet delivered\n-    private Iterator<T> iterator; \/\/ This is our cursor into the data stream, which we will send to the `Subscriber`\n-\n-    SubscriptionImpl(final Subscriber<? super T> subscriber) {\n-      \/\/ As per rule 1.09, we need to throw a `java.lang.NullPointerException` if the `Subscriber` is `null`\n-      if (subscriber == null) throw null;\n-      this.subscriber = subscriber;\n-    }\n-\n-    \/\/ This `ConcurrentLinkedQueue` will track signals that are sent to this `Subscription`, like `request` and `cancel`\n-    private final ConcurrentLinkedQueue<Signal> inboundSignals = new ConcurrentLinkedQueue<Signal>();\n-\n-    \/\/ We are using this `AtomicBoolean` to make sure that this `Subscription` doesn't run concurrently with itself,\n-    \/\/ which would violate rule 1.3 among others (no concurrent notifications).\n-    private final AtomicBoolean on = new AtomicBoolean(false);\n-\n-    \/\/ This method will register inbound demand from our `Subscriber` and validate it against rule 3.9 and rule 3.17\n-    private void doRequest(final long n) {\n-      if (n < 1)\n-        terminateDueTo(new IllegalArgumentException(subscriber + \" violated the Reactive Streams rule 3.9 by requesting a non-positive number of elements.\"));\n-      else if (demand + n < 1) {\n-        \/\/ As governed by rule 3.17, when demand overflows `Long.MAX_VALUE` we treat the signalled demand as \"effectively unbounded\"\n-        demand = Long.MAX_VALUE;  \/\/ Here we protect from the overflow and treat it as \"effectively unbounded\"\n-        doSend(); \/\/ Then we proceed with sending data downstream\n-      } else {\n-        demand += n; \/\/ Here we record the downstream demand\n-        doSend(); \/\/ Then we can proceed with sending data downstream\n-      }\n-    }\n-\n-    \/\/ This handles cancellation requests, and is idempotent, thread-safe and not synchronously performing heavy computations as specified in rule 3.5\n-    private void doCancel() {\n-      cancelled = true;\n-    }\n-\n-    \/\/ Instead of executing `subscriber.onSubscribe` synchronously from within `Publisher.subscribe`\n-    \/\/ we execute it asynchronously, this is to avoid executing the user code (`Iterable.iterator`) on the calling thread.\n-    \/\/ It also makes it easier to follow rule 1.9\n-    private void doSubscribe() {\n-      try {\n-        iterator = elements.iterator();\n-        if (iterator == null)\n-          iterator = Collections.<T>emptyList().iterator(); \/\/ So we can assume that `iterator` is never null\n-      } catch(final Throwable t) {\n-        subscriber.onSubscribe(new Subscription() { \/\/ We need to make sure we signal onSubscribe before onError, obeying rule 1.9\n-          @Override public void cancel() {}\n-          @Override public void request(long n) {}\n-        });\n-        terminateDueTo(t); \/\/ Here we send onError, obeying rule 1.09\n-      }\n-\n-      if (!cancelled) {\n-        \/\/ Deal with setting up the subscription with the subscriber\n-        try {\n-          subscriber.onSubscribe(this);\n-        } catch(final Throwable t) { \/\/ Due diligence to obey 2.13\n-          terminateDueTo(new IllegalStateException(subscriber + \" violated the Reactive Streams rule 2.13 by throwing an exception from onSubscribe.\", t));\n-        }\n-\n-        \/\/ Deal with already complete iterators promptly\n-        boolean hasElements = false;\n-        try {\n-          hasElements = iterator.hasNext();\n-        } catch(final Throwable t) {\n-          terminateDueTo(t); \/\/ If hasNext throws, there's something wrong and we need to signal onError as per 1.2, 1.4,\n-        }\n-\n-        \/\/ If we don't have anything to deliver, we're already done, so lets do the right thing and\n-        \/\/ not wait for demand to deliver `onComplete` as per rule 1.2 and 1.3\n-        if (!hasElements) {\n-          try {\n-            doCancel(); \/\/ Rule 1.6 says we need to consider the `Subscription` cancelled when `onComplete` is signalled\n-            subscriber.onComplete();\n-          } catch(final Throwable t) { \/\/ As per rule 2.13, `onComplete` is not allowed to throw exceptions, so we do what we can, and log this.\n-            (new IllegalStateException(subscriber + \" violated the Reactive Streams rule 2.13 by throwing an exception from onComplete.\", t)).printStackTrace(System.err);\n-          }\n-        }\n-      }\n-    }\n-\n-    \/\/ This is our behavior for producing elements downstream\n-    private void doSend() {\n-      try {\n-        \/\/ In order to play nice with the `Executor` we will only send at-most `batchSize` before\n-        \/\/ rescheduing ourselves and relinquishing the current thread.\n-        int leftInBatch = batchSize;\n-        do {\n-          T next;\n-          boolean hasNext;\n-          try {\n-            next = iterator.next(); \/\/ We have already checked `hasNext` when subscribing, so we can fall back to testing -after- `next` is called.\n-            hasNext = iterator.hasNext(); \/\/ Need to keep track of End-of-Stream\n-          } catch (final Throwable t) {\n-            terminateDueTo(t); \/\/ If `next` or `hasNext` throws (they can, since it is user-provided), we need to treat the stream as errored as per rule 1.4\n-            return;\n-          }\n-          subscriber.onNext(next); \/\/ Then we signal the next element downstream to the `Subscriber`\n-          if (!hasNext) { \/\/ If we are at End-of-Stream\n-            doCancel(); \/\/ We need to consider this `Subscription` as cancelled as per rule 1.6\n-            subscriber.onComplete(); \/\/ Then we signal `onComplete` as per rule 1.2 and 1.5\n-          }\n-        } while (!cancelled           \/\/ This makes sure that rule 1.8 is upheld, i.e. we need to stop signalling \"eventually\"\n-                 && --leftInBatch > 0 \/\/ This makes sure that we only send `batchSize` number of elements in one go (so we can yield to other Runnables)\n-                 && --demand > 0);    \/\/ This makes sure that rule 1.1 is upheld (sending more than was demanded)\n-\n-        if (!cancelled && demand > 0) \/\/ If the `Subscription` is still alive and well, and we have demand to satisfy, we signal ourselves to send more data\n-          signal(Send.Instance);\n-      } catch(final Throwable t) {\n-        \/\/ We can only get here if `onNext` or `onComplete` threw, and they are not allowed to according to 2.13, so we can only cancel and log here.\n-        doCancel(); \/\/ Make sure that we are cancelled, since we cannot do anything else since the `Subscriber` is faulty.\n-        (new IllegalStateException(subscriber + \" violated the Reactive Streams rule 2.13 by throwing an exception from onNext or onComplete.\", t)).printStackTrace(System.err);\n-      }\n-    }\n-\n-    \/\/ This is a helper method to ensure that we always `cancel` when we signal `onError` as per rule 1.6\n-    private void terminateDueTo(final Throwable t) {\n-      cancelled = true; \/\/ When we signal onError, the subscription must be considered as cancelled, as per rule 1.6\n-      try {\n-        subscriber.onError(t); \/\/ Then we signal the error downstream, to the `Subscriber`\n-      } catch(final Throwable t2) { \/\/ If `onError` throws an exception, this is a spec violation according to rule 1.9, and all we can do is to log it.\n-        (new IllegalStateException(subscriber + \" violated the Reactive Streams rule 2.13 by throwing an exception from onError.\", t2)).printStackTrace(System.err);\n-      }\n-    }\n-\n-    \/\/ What `signal` does is that it sends signals to the `Subscription` asynchronously\n-    private void signal(final Signal signal) {\n-      if (inboundSignals.offer(signal)) \/\/ No need to null-check here as ConcurrentLinkedQueue does this for us\n-        tryScheduleToExecute(); \/\/ Then we try to schedule it for execution, if it isn't already\n-    }\n-\n-    \/\/ This is the main \"event loop\" if you so will\n-    @Override public final void run() {\n-      if(on.get()) { \/\/ establishes a happens-before relationship with the end of the previous run\n-        try {\n-          final Signal s = inboundSignals.poll(); \/\/ We take a signal off the queue\n-          if (!cancelled) { \/\/ to make sure that we follow rule 1.8, 3.6 and 3.7\n-\n-            \/\/ Below we simply unpack the `Signal`s and invoke the corresponding methods\n-            if (s instanceof Request)\n-              doRequest(((Request)s).n);\n-            else if (s == Send.Instance)\n-              doSend();\n-            else if (s == Cancel.Instance)\n-              doCancel();\n-            else if (s == Subscribe.Instance)\n-              doSubscribe();\n-          }\n-        } finally {\n-          on.set(false); \/\/ establishes a happens-before relationship with the beginning of the next run\n-          if(!inboundSignals.isEmpty()) \/\/ If we still have signals to process\n-            tryScheduleToExecute(); \/\/ Then we try to schedule ourselves to execute again\n-        }\n-      }\n-    }\n-\n-    \/\/ This method makes sure that this `Subscription` is only running on one Thread at a time,\n-    \/\/ this is important to make sure that we follow rule 1.3\n-    private final void tryScheduleToExecute() {\n-      if(on.compareAndSet(false, true)) {\n-        try {\n-          executor.execute(this);\n-        } catch(Throwable t) { \/\/ If we can't run on the `Executor`, we need to fail gracefully\n-          if (!cancelled) {\n-            doCancel(); \/\/ First of all, this failure is not recoverable, so we need to follow rule 1.4 and 1.6\n-            try {\n-              terminateDueTo(new IllegalStateException(\"Publisher terminated due to unavailable Executor.\", t));\n-            } finally {\n-              inboundSignals.clear(); \/\/ We're not going to need these anymore\n-              \/\/ This subscription is cancelled by now, but letting it become schedulable again means\n-              \/\/ that we can drain the inboundSignals queue if anything arrives after clearing\n-              on.set(false);\n-            }\n-          }\n-        }\n-      }\n-    }\n-\n-    \/\/ Our implementation of `Subscription.request` sends a signal to the Subscription that more elements are in demand\n-    @Override public void request(final long n) {\n-      signal(new Request(n));\n-    }\n-    \/\/ Our implementation of `Subscription.cancel` sends a signal to the Subscription that the `Subscriber` is not interested in any more elements\n-    @Override public void cancel() {\n-      signal(Cancel.Instance);\n-    }\n-    \/\/ The reason for the `init` method is that we want to ensure the `SubscriptionImpl`\n-    \/\/ is completely constructed before it is exposed to the thread pool, therefor this\n-    \/\/ method is only intended to be invoked once, and immediately after the constructor has\n-    \/\/ finished.\n-    void init() {\n-      signal(Subscribe.Instance);\n-    }\n-  };\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/example\/unicast\/AsyncIterablePublisher.java","additions":0,"deletions":281,"binary":false,"changes":281,"status":"deleted"},{"patch":"@@ -1,261 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.example.unicast;\n-\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-\n-import java.util.concurrent.Executor;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-\n-\/**\n- * AsyncSubscriber is an implementation of Reactive Streams `Subscriber`,\n- * it runs asynchronously (on an Executor), requests one element\n- * at a time, and invokes a user-defined method to process each element.\n- *\n- * NOTE: The code below uses a lot of try-catches to show the reader where exceptions can be expected, and where they are forbidden.\n- *\/\n-public abstract class AsyncSubscriber<T> implements Subscriber<T>, Runnable {\n-\n-  \/\/ Signal represents the asynchronous protocol between the Publisher and Subscriber\n-  private static interface Signal {}\n-\n-  private enum OnComplete implements Signal { Instance; }\n-\n-  private static class OnError implements Signal {\n-    public final Throwable error;\n-    public OnError(final Throwable error) { this.error = error; }\n-  }\n-\n-  private static class OnNext<T> implements Signal {\n-    public final T next;\n-    public OnNext(final T next) { this.next = next; }\n-  }\n-\n-  private static class OnSubscribe implements Signal {\n-    public final Subscription subscription;\n-    public OnSubscribe(final Subscription subscription) { this.subscription = subscription; }\n-  }\n-\n-  private Subscription subscription; \/\/ Obeying rule 3.1, we make this private!\n-  private boolean done; \/\/ It's useful to keep track of whether this Subscriber is done or not\n-  private final Executor executor; \/\/ This is the Executor we'll use to be asynchronous, obeying rule 2.2\n-\n-  \/\/ Only one constructor, and it's only accessible for the subclasses\n-  protected AsyncSubscriber(Executor executor) {\n-    if (executor == null) throw null;\n-    this.executor = executor;\n-  }\n-\n-  \/\/ Showcases a convenience method to idempotently marking the Subscriber as \"done\", so we don't want to process more elements\n-  \/\/ herefor we also need to cancel our `Subscription`.\n-  private final void done() {\n-    \/\/On this line we could add a guard against `!done`, but since rule 3.7 says that `Subscription.cancel()` is idempotent, we don't need to.\n-    done = true; \/\/ If `whenNext` throws an exception, let's consider ourselves done (not accepting more elements)\n-    if (subscription != null) { \/\/ If we are bailing out before we got a `Subscription` there's little need for cancelling it.\n-      try {\n-        subscription.cancel(); \/\/ Cancel the subscription\n-      } catch(final Throwable t) {\n-        \/\/Subscription.cancel is not allowed to throw an exception, according to rule 3.15\n-        (new IllegalStateException(subscription + \" violated the Reactive Streams rule 3.15 by throwing an exception from cancel.\", t)).printStackTrace(System.err);\n-      }\n-    }\n-  }\n-\n-  \/\/ This method is invoked when the OnNext signals arrive\n-  \/\/ Returns whether more elements are desired or not, and if no more elements are desired,\n-  \/\/ for convenience.\n-  protected abstract boolean whenNext(final T element);\n-\n-  \/\/ This method is invoked when the OnComplete signal arrives\n-  \/\/ override this method to implement your own custom onComplete logic.\n-  protected void whenComplete() { }\n-\n-  \/\/ This method is invoked if the OnError signal arrives\n-  \/\/ override this method to implement your own custom onError logic.\n-  protected void whenError(Throwable error) { }\n-\n-  private final void handleOnSubscribe(final Subscription s) {\n-    if (s == null) {\n-      \/\/ Getting a null `Subscription` here is not valid so lets just ignore it.\n-    } else if (subscription != null) { \/\/ If someone has made a mistake and added this Subscriber multiple times, let's handle it gracefully\n-      try {\n-        s.cancel(); \/\/ Cancel the additional subscription to follow rule 2.5\n-      } catch(final Throwable t) {\n-        \/\/Subscription.cancel is not allowed to throw an exception, according to rule 3.15\n-        (new IllegalStateException(s + \" violated the Reactive Streams rule 3.15 by throwing an exception from cancel.\", t)).printStackTrace(System.err);\n-      }\n-    } else {\n-      \/\/ We have to assign it locally before we use it, if we want to be a synchronous `Subscriber`\n-      \/\/ Because according to rule 3.10, the Subscription is allowed to call `onNext` synchronously from within `request`\n-      subscription = s;\n-      try {\n-        \/\/ If we want elements, according to rule 2.1 we need to call `request`\n-        \/\/ And, according to rule 3.2 we are allowed to call this synchronously from within the `onSubscribe` method\n-        s.request(1); \/\/ Our Subscriber is unbuffered and modest, it requests one element at a time\n-      } catch(final Throwable t) {\n-        \/\/ Subscription.request is not allowed to throw according to rule 3.16\n-        (new IllegalStateException(s + \" violated the Reactive Streams rule 3.16 by throwing an exception from request.\", t)).printStackTrace(System.err);\n-      }\n-    }\n-  }\n-\n-  private final void handleOnNext(final T element) {\n-    if (!done) { \/\/ If we aren't already done\n-      if(subscription == null) { \/\/ Technically this check is not needed, since we are expecting Publishers to conform to the spec\n-        \/\/ Check for spec violation of 2.1 and 1.09\n-        (new IllegalStateException(\"Someone violated the Reactive Streams rule 1.09 and 2.1 by signalling OnNext before `Subscription.request`. (no Subscription)\")).printStackTrace(System.err);\n-      } else {\n-        try {\n-          if (whenNext(element)) {\n-            try {\n-              subscription.request(1); \/\/ Our Subscriber is unbuffered and modest, it requests one element at a time\n-            } catch(final Throwable t) {\n-              \/\/ Subscription.request is not allowed to throw according to rule 3.16\n-              (new IllegalStateException(subscription + \" violated the Reactive Streams rule 3.16 by throwing an exception from request.\", t)).printStackTrace(System.err);\n-            }\n-          } else {\n-            done(); \/\/ This is legal according to rule 2.6\n-          }\n-        } catch(final Throwable t) {\n-          done();\n-          try {\n-            onError(t);\n-          } catch(final Throwable t2) {\n-            \/\/Subscriber.onError is not allowed to throw an exception, according to rule 2.13\n-            (new IllegalStateException(this + \" violated the Reactive Streams rule 2.13 by throwing an exception from onError.\", t2)).printStackTrace(System.err);\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ Here it is important that we do not violate 2.2 and 2.3 by calling methods on the `Subscription` or `Publisher`\n-  private void handleOnComplete() {\n-    if (subscription == null) { \/\/ Technically this check is not needed, since we are expecting Publishers to conform to the spec\n-      \/\/ Publisher is not allowed to signal onComplete before onSubscribe according to rule 1.09\n-      (new IllegalStateException(\"Publisher violated the Reactive Streams rule 1.09 signalling onComplete prior to onSubscribe.\")).printStackTrace(System.err);\n-    } else {\n-      done = true; \/\/ Obey rule 2.4\n-      whenComplete();\n-    }\n-  }\n-\n-  \/\/ Here it is important that we do not violate 2.2 and 2.3 by calling methods on the `Subscription` or `Publisher`\n-  private void handleOnError(final Throwable error) {\n-    if (subscription == null) { \/\/ Technically this check is not needed, since we are expecting Publishers to conform to the spec\n-      \/\/ Publisher is not allowed to signal onError before onSubscribe according to rule 1.09\n-      (new IllegalStateException(\"Publisher violated the Reactive Streams rule 1.09 signalling onError prior to onSubscribe.\")).printStackTrace(System.err);\n-    } else {\n-      done = true; \/\/ Obey rule 2.4\n-      whenError(error);\n-    }\n-  }\n-\n-  \/\/ We implement the OnX methods on `Subscriber` to send Signals that we will process asycnhronously, but only one at a time\n-\n-  @Override public final void onSubscribe(final Subscription s) {\n-    \/\/ As per rule 2.13, we need to throw a `java.lang.NullPointerException` if the `Subscription` is `null`\n-    if (s == null) throw null;\n-\n-    signal(new OnSubscribe(s));\n-  }\n-\n-  @Override public final void onNext(final T element) {\n-    \/\/ As per rule 2.13, we need to throw a `java.lang.NullPointerException` if the `element` is `null`\n-    if (element == null) throw null;\n-\n-    signal(new OnNext<T>(element));\n-  }\n-\n-  @Override public final void onError(final Throwable t) {\n-    \/\/ As per rule 2.13, we need to throw a `java.lang.NullPointerException` if the `Throwable` is `null`\n-    if (t == null) throw null;\n-\n-    signal(new OnError(t));\n-  }\n-\n-  @Override public final void onComplete() {\n-     signal(OnComplete.Instance);\n-  }\n-\n-  \/\/ This `ConcurrentLinkedQueue` will track signals that are sent to this `Subscriber`, like `OnComplete` and `OnNext` ,\n-  \/\/ and obeying rule 2.11\n-  private final ConcurrentLinkedQueue<Signal> inboundSignals = new ConcurrentLinkedQueue<Signal>();\n-\n-  \/\/ We are using this `AtomicBoolean` to make sure that this `Subscriber` doesn't run concurrently with itself,\n-  \/\/ obeying rule 2.7 and 2.11\n-  private final AtomicBoolean on = new AtomicBoolean(false);\n-\n-   @SuppressWarnings(\"unchecked\")\n-   @Override public final void run() {\n-    if(on.get()) { \/\/ establishes a happens-before relationship with the end of the previous run\n-      try {\n-        final Signal s = inboundSignals.poll(); \/\/ We take a signal off the queue\n-        if (!done) { \/\/ If we're done, we shouldn't process any more signals, obeying rule 2.8\n-          \/\/ Below we simply unpack the `Signal`s and invoke the corresponding methods\n-          if (s instanceof OnNext<?>)\n-            handleOnNext(((OnNext<T>)s).next);\n-          else if (s instanceof OnSubscribe)\n-            handleOnSubscribe(((OnSubscribe)s).subscription);\n-          else if (s instanceof OnError) \/\/ We are always able to handle OnError, obeying rule 2.10\n-            handleOnError(((OnError)s).error);\n-          else if (s == OnComplete.Instance) \/\/ We are always able to handle OnComplete, obeying rule 2.9\n-            handleOnComplete();\n-        }\n-      } finally {\n-        on.set(false); \/\/ establishes a happens-before relationship with the beginning of the next run\n-        if(!inboundSignals.isEmpty()) \/\/ If we still have signals to process\n-          tryScheduleToExecute(); \/\/ Then we try to schedule ourselves to execute again\n-      }\n-    }\n-  }\n-\n-  \/\/ What `signal` does is that it sends signals to the `Subscription` asynchronously\n-  private void signal(final Signal signal) {\n-    if (inboundSignals.offer(signal)) \/\/ No need to null-check here as ConcurrentLinkedQueue does this for us\n-      tryScheduleToExecute(); \/\/ Then we try to schedule it for execution, if it isn't already\n-  }\n-\n-  \/\/ This method makes sure that this `Subscriber` is only executing on one Thread at a time\n-  private final void tryScheduleToExecute() {\n-    if(on.compareAndSet(false, true)) {\n-      try {\n-        executor.execute(this);\n-      } catch(Throwable t) { \/\/ If we can't run on the `Executor`, we need to fail gracefully and not violate rule 2.13\n-        if (!done) {\n-          try {\n-            done(); \/\/ First of all, this failure is not recoverable, so we need to cancel our subscription\n-          } finally {\n-            inboundSignals.clear(); \/\/ We're not going to need these anymore\n-            \/\/ This subscription is cancelled by now, but letting the Subscriber become schedulable again means\n-            \/\/ that we can drain the inboundSignals queue if anything arrives after clearing\n-            on.set(false);\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/example\/unicast\/AsyncSubscriber.java","additions":0,"deletions":261,"binary":false,"changes":261,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.example.unicast;\n-\n-import java.util.Iterator;\n-import java.util.concurrent.Executor;\n-\n-import org.reactivestreams.Subscription;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Publisher;\n-\n-public class InfiniteIncrementNumberPublisher extends AsyncIterablePublisher<Integer> {\n-    public InfiniteIncrementNumberPublisher(final Executor executor) {\n-        super(new Iterable<Integer>() {\n-          @Override public Iterator<Integer> iterator() {\n-            return new Iterator<Integer>() {\n-              private int at = 0;\n-              @Override public boolean hasNext() { return true; }\n-              @Override public Integer next() { return at++; } \/\/ Wraps around on overflow\n-              @Override public void remove() { throw new UnsupportedOperationException(); }\n-            };\n-          }\n-        }, executor);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/example\/unicast\/InfiniteIncrementNumberPublisher.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.example.unicast;\n-\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.concurrent.Executor;\n-import org.reactivestreams.Subscription;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Publisher;\n-\n-public class NumberIterablePublisher extends AsyncIterablePublisher<Integer> {\n-    public NumberIterablePublisher(final int from, final int to, final Executor executor) {\n-        super(new Iterable<Integer>() {\n-          { if(from > to) throw new IllegalArgumentException(\"from must be equal or greater than to!\"); }\n-          @Override public Iterator<Integer> iterator() {\n-            return new Iterator<Integer>() {\n-              private int at = from;\n-              @Override public boolean hasNext() { return at < to; }\n-              @Override public Integer next() {\n-                if (!hasNext()) return Collections.<Integer>emptyList().iterator().next();\n-                else return at++;\n-              }\n-              @Override public void remove() { throw new UnsupportedOperationException(); }\n-            };\n-          }\n-        }, executor);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/example\/unicast\/NumberIterablePublisher.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,254 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.example.unicast;\n-\n-import org.reactivestreams.*;\n-\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-\/**\n- * A synchronous implementation of the {@link Publisher} that can\n- * be subscribed to multiple times and each individual subscription\n- * will receive range of monotonically increasing integer values on demand.\n- *\/\n-public final class RangePublisher implements Publisher<Integer> {\n-\n-    \/** The starting value of the range. *\/\n-    final int start;\n-\n-    \/** The number of items to emit. *\/\n-    final int count;\n-\n-    \/**\n-     * Constructs a RangePublisher instance with the given start and count values\n-     * that yields a sequence of [start, start + count).\n-     * @param start the starting value of the range\n-     * @param count the number of items to emit\n-     *\/\n-    public RangePublisher(int start, int count) {\n-        this.start = start;\n-        this.count = count;\n-    }\n-\n-    @Override\n-    public void subscribe(Subscriber<? super Integer> subscriber) {\n-        \/\/ As per rule 1.11, we have decided to support multiple subscribers\n-        \/\/ in a unicast configuration for this `Publisher` implementation.\n-\n-        \/\/ As per rule 1.09, we need to throw a `java.lang.NullPointerException`\n-        \/\/ if the `Subscriber` is `null`\n-        if (subscriber == null) throw null;\n-\n-        \/\/ As per 2.13, this method must return normally (i.e. not throw).\n-        try {\n-            subscriber.onSubscribe(new RangeSubscription(subscriber, start, start + count));\n-        } catch (Throwable ex) {\n-            new IllegalStateException(subscriber + \" violated the Reactive Streams rule 2.13 \" +\n-                    \"by throwing an exception from onSubscribe.\", ex)\n-                    \/\/ When onSubscribe fails this way, we don't know what state the\n-                    \/\/ subscriber is thus calling onError may cause more crashes.\n-                    .printStackTrace();\n-        }\n-    }\n-\n-    \/**\n-     * A Subscription implementation that holds the current downstream\n-     * requested amount and responds to the downstream's request() and\n-     * cancel() calls.\n-     *\/\n-    static final class RangeSubscription\n-            \/\/ We are using this `AtomicLong` to make sure that this `Subscription`\n-            \/\/ doesn't run concurrently with itself, which would violate rule 1.3\n-            \/\/ among others (no concurrent notifications).\n-            \/\/ The atomic transition from 0L to N > 0L will ensure this.\n-            extends AtomicLong implements Subscription {\n-\n-        private static final long serialVersionUID = -9000845542177067735L;\n-\n-        \/** The Subscriber we are emitting integer values to. *\/\n-        final Subscriber<? super Integer> downstream;\n-\n-        \/** The end index (exclusive). *\/\n-        final int end;\n-\n-        \/**\n-         * The current index and within the [start, start + count) range that\n-         * will be emitted as downstream.onNext().\n-         *\/\n-        int index;\n-\n-        \/**\n-         * Indicates the emission should stop.\n-         *\/\n-        volatile boolean cancelled;\n-\n-        \/**\n-         * Holds onto the IllegalArgumentException (containing the offending stacktrace)\n-         * indicating there was a non-positive request() call from the downstream.\n-         *\/\n-        volatile Throwable invalidRequest;\n-\n-        \/**\n-         * Constructs a stateful RangeSubscription that emits signals to the given\n-         * downstream from an integer range of [start, end).\n-         * @param downstream the Subscriber receiving the integer values and the completion signal.\n-         * @param start the first integer value emitted, start of the range\n-         * @param end the end of the range, exclusive\n-         *\/\n-        RangeSubscription(Subscriber<? super Integer> downstream, int start, int end) {\n-            this.downstream = downstream;\n-            this.index = start;\n-            this.end = end;\n-        }\n-\n-        \/\/ This method will register inbound demand from our `Subscriber` and\n-        \/\/ validate it against rule 3.9 and rule 3.17\n-        @Override\n-        public void request(long n) {\n-            \/\/ Non-positive requests should be honored with IllegalArgumentException\n-            if (n <= 0L) {\n-                invalidRequest = new IllegalArgumentException(\"3.9: non-positive requests are not allowed!\");\n-                n = 1;\n-            }\n-            \/\/ Downstream requests are cumulative and may come from any thread\n-            for (;;) {\n-                long requested = get();\n-                long update = requested + n;\n-                \/\/ As governed by rule 3.17, when demand overflows `Long.MAX_VALUE`\n-                \/\/ we treat the signalled demand as \"effectively unbounded\"\n-                if (update < 0L) {\n-                    update = Long.MAX_VALUE;\n-                }\n-                \/\/ atomically update the current requested amount\n-                if (compareAndSet(requested, update)) {\n-                    \/\/ if there was no prior request amount, we start the emission loop\n-                    if (requested == 0L) {\n-                        emit(update);\n-                    }\n-                    break;\n-                }\n-            }\n-        }\n-\n-        \/\/ This handles cancellation requests, and is idempotent, thread-safe and not\n-        \/\/ synchronously performing heavy computations as specified in rule 3.5\n-        @Override\n-        public void cancel() {\n-            \/\/ Indicate to the emission loop it should stop.\n-            cancelled = true;\n-        }\n-\n-        void emit(long currentRequested) {\n-            \/\/ Load fields to avoid re-reading them from memory due to volatile accesses in the loop.\n-            Subscriber<? super Integer> downstream = this.downstream;\n-            int index = this.index;\n-            int end = this.end;\n-            int emitted = 0;\n-\n-            try {\n-                for (; ; ) {\n-                    \/\/ Check if there was an invalid request and then report its exception\n-                    \/\/ as mandated by rule 3.9. The stacktrace in it should\n-                    \/\/ help locate the faulty logic in the Subscriber.\n-                    Throwable invalidRequest = this.invalidRequest;\n-                    if (invalidRequest != null) {\n-                        \/\/ When we signal onError, the subscription must be considered as cancelled, as per rule 1.6\n-                        cancelled = true;\n-\n-                        downstream.onError(invalidRequest);\n-                        return;\n-                    }\n-\n-                    \/\/ Loop while the index hasn't reached the end and we haven't\n-                    \/\/ emitted all that's been requested\n-                    while (index != end && emitted != currentRequested) {\n-                        \/\/ to make sure that we follow rule 1.8, 3.6 and 3.7\n-                        \/\/ We stop if cancellation was requested.\n-                        if (cancelled) {\n-                            return;\n-                        }\n-\n-                        downstream.onNext(index);\n-\n-                        \/\/ Increment the index for the next possible emission.\n-                        index++;\n-                        \/\/ Increment the emitted count to prevent overflowing the downstream.\n-                        emitted++;\n-                    }\n-\n-                    \/\/ If the index reached the end, we complete the downstream.\n-                    if (index == end) {\n-                        \/\/ to make sure that we follow rule 1.8, 3.6 and 3.7\n-                        \/\/ Unless cancellation was requested by the last onNext.\n-                        if (!cancelled) {\n-                            \/\/ We need to consider this `Subscription` as cancelled as per rule 1.6\n-                            \/\/ Note, however, that this state is not observable from the outside\n-                            \/\/ world and since we leave the loop with requested > 0L, any\n-                            \/\/ further request() will never trigger the loop.\n-                            cancelled = true;\n-\n-                            downstream.onComplete();\n-                        }\n-                        return;\n-                    }\n-\n-                    \/\/ Did the requested amount change while we were looping?\n-                    long freshRequested = get();\n-                    if (freshRequested == currentRequested) {\n-                        \/\/ Save where the loop has left off: the next value to be emitted\n-                        this.index = index;\n-                        \/\/ Atomically subtract the previously requested (also emitted) amount\n-                        currentRequested = addAndGet(-currentRequested);\n-                        \/\/ If there was no new request in between get() and addAndGet(), we simply quit\n-                        \/\/ The next 0 to N transition in request() will trigger the next emission loop.\n-                        if (currentRequested == 0L) {\n-                            break;\n-                        }\n-                        \/\/ Looks like there were more async requests, reset the emitted count and continue.\n-                        emitted = 0;\n-                    } else {\n-                        \/\/ Yes, avoid the atomic subtraction and resume.\n-                        \/\/ emitted != currentRequest in this case and index\n-                        \/\/ still points to the next value to be emitted\n-                        currentRequested = freshRequested;\n-                    }\n-                }\n-            } catch (Throwable ex) {\n-                \/\/ We can only get here if `onNext`, `onError` or `onComplete` threw, and they\n-                \/\/ are not allowed to according to 2.13, so we can only cancel and log here.\n-                \/\/ If `onError` throws an exception, this is a spec violation according to rule 1.9,\n-                \/\/ and all we can do is to log it.\n-\n-                \/\/ Make sure that we are cancelled, since we cannot do anything else\n-                \/\/ since the `Subscriber` is faulty.\n-                cancelled = true;\n-\n-                \/\/ We can't report the failure to onError as the Subscriber is unreliable.\n-                (new IllegalStateException(downstream + \" violated the Reactive Streams rule 2.13 by \" +\n-                        \"throwing an exception from onNext, onError or onComplete.\", ex))\n-                        .printStackTrace();\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/example\/unicast\/RangePublisher.java","additions":0,"deletions":254,"binary":false,"changes":254,"status":"deleted"},{"patch":"@@ -1,134 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.example.unicast;\n-\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-\n-\/**\n- * SyncSubscriber is an implementation of Reactive Streams `Subscriber`,\n- * it runs synchronously (on the Publisher's thread) and requests one element\n- * at a time and invokes a user-defined method to process each element.\n- *\n- * NOTE: The code below uses a lot of try-catches to show the reader where exceptions can be expected, and where they are forbidden.\n- *\/\n-public abstract class SyncSubscriber<T> implements Subscriber<T> {\n-  private Subscription subscription; \/\/ Obeying rule 3.1, we make this private!\n-  private boolean done = false;\n-\n-  @Override public void onSubscribe(final Subscription s) {\n-    \/\/ As per rule 2.13, we need to throw a `java.lang.NullPointerException` if the `Subscription` is `null`\n-    if (s == null) throw null;\n-\n-    if (subscription != null) { \/\/ If someone has made a mistake and added this Subscriber multiple times, let's handle it gracefully\n-      try {\n-        s.cancel(); \/\/ Cancel the additional subscription\n-      } catch(final Throwable t) {\n-        \/\/Subscription.cancel is not allowed to throw an exception, according to rule 3.15\n-        (new IllegalStateException(s + \" violated the Reactive Streams rule 3.15 by throwing an exception from cancel.\", t)).printStackTrace(System.err);\n-      }\n-    } else {\n-      \/\/ We have to assign it locally before we use it, if we want to be a synchronous `Subscriber`\n-      \/\/ Because according to rule 3.10, the Subscription is allowed to call `onNext` synchronously from within `request`\n-      subscription = s;\n-      try {\n-        \/\/ If we want elements, according to rule 2.1 we need to call `request`\n-        \/\/ And, according to rule 3.2 we are allowed to call this synchronously from within the `onSubscribe` method\n-        s.request(1); \/\/ Our Subscriber is unbuffered and modest, it requests one element at a time\n-      } catch(final Throwable t) {\n-        \/\/ Subscription.request is not allowed to throw according to rule 3.16\n-        (new IllegalStateException(s + \" violated the Reactive Streams rule 3.16 by throwing an exception from request.\", t)).printStackTrace(System.err);\n-      }\n-    }\n-  }\n-\n-  @Override public void onNext(final T element) {\n-    if (subscription == null) { \/\/ Technically this check is not needed, since we are expecting Publishers to conform to the spec\n-      (new IllegalStateException(\"Publisher violated the Reactive Streams rule 1.09 signalling onNext prior to onSubscribe.\")).printStackTrace(System.err);\n-    } else {\n-      \/\/ As per rule 2.13, we need to throw a `java.lang.NullPointerException` if the `element` is `null`\n-      if (element == null) throw null;\n-\n-      if (!done) { \/\/ If we aren't already done\n-        try {\n-          if (whenNext(element)) {\n-            try {\n-              subscription.request(1); \/\/ Our Subscriber is unbuffered and modest, it requests one element at a time\n-            } catch (final Throwable t) {\n-              \/\/ Subscription.request is not allowed to throw according to rule 3.16\n-              (new IllegalStateException(subscription + \" violated the Reactive Streams rule 3.16 by throwing an exception from request.\", t)).printStackTrace(System.err);\n-            }\n-          } else {\n-            done();\n-          }\n-        } catch (final Throwable t) {\n-          done();\n-          try {\n-            onError(t);\n-          } catch (final Throwable t2) {\n-            \/\/Subscriber.onError is not allowed to throw an exception, according to rule 2.13\n-            (new IllegalStateException(this + \" violated the Reactive Streams rule 2.13 by throwing an exception from onError.\", t2)).printStackTrace(System.err);\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ Showcases a convenience method to idempotently marking the Subscriber as \"done\", so we don't want to process more elements\n-  \/\/ herefor we also need to cancel our `Subscription`.\n-  private void done() {\n-    \/\/On this line we could add a guard against `!done`, but since rule 3.7 says that `Subscription.cancel()` is idempotent, we don't need to.\n-    done = true; \/\/ If we `whenNext` throws an exception, let's consider ourselves done (not accepting more elements)\n-    try {\n-      subscription.cancel(); \/\/ Cancel the subscription\n-    } catch(final Throwable t) {\n-      \/\/Subscription.cancel is not allowed to throw an exception, according to rule 3.15\n-      (new IllegalStateException(subscription + \" violated the Reactive Streams rule 3.15 by throwing an exception from cancel.\", t)).printStackTrace(System.err);\n-    }\n-  }\n-\n-  \/\/ This method is left as an exercise to the reader\/extension point\n-  \/\/ Returns whether more elements are desired or not, and if no more elements are desired\n-  protected abstract boolean whenNext(final T element);\n-\n-  @Override public void onError(final Throwable t) {\n-    if (subscription == null) { \/\/ Technically this check is not needed, since we are expecting Publishers to conform to the spec\n-      (new IllegalStateException(\"Publisher violated the Reactive Streams rule 1.09 signalling onError prior to onSubscribe.\")).printStackTrace(System.err);\n-    } else {\n-      \/\/ As per rule 2.13, we need to throw a `java.lang.NullPointerException` if the `Throwable` is `null`\n-      if (t == null) throw null;\n-      \/\/ Here we are not allowed to call any methods on the `Subscription` or the `Publisher`, as per rule 2.3\n-      \/\/ And anyway, the `Subscription` is considered to be cancelled if this method gets called, as per rule 2.4\n-    }\n-  }\n-\n-  @Override public void onComplete() {\n-    if (subscription == null) { \/\/ Technically this check is not needed, since we are expecting Publishers to conform to the spec\n-      (new IllegalStateException(\"Publisher violated the Reactive Streams rule 1.09 signalling onComplete prior to onSubscribe.\")).printStackTrace(System.err);\n-    } else {\n-      \/\/ Here we are not allowed to call any methods on the `Subscription` or the `Publisher`, as per rule 2.3\n-      \/\/ And anyway, the `Subscription` is considered to be cancelled if this method gets called, as per rule 2.4\n-    }\n-  }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/example\/unicast\/SyncSubscriber.java","additions":0,"deletions":134,"binary":false,"changes":134,"status":"deleted"},{"patch":"@@ -1,896 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck;\n-\n-import org.reactivestreams.Processor;\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-import org.reactivestreams.tck.TestEnvironment.ManualPublisher;\n-import org.reactivestreams.tck.TestEnvironment.ManualSubscriber;\n-import org.reactivestreams.tck.TestEnvironment.ManualSubscriberWithSubscriptionSupport;\n-import org.reactivestreams.tck.TestEnvironment.Promise;\n-import org.reactivestreams.tck.flow.support.Function;\n-import org.reactivestreams.tck.flow.support.SubscriberWhiteboxVerificationRules;\n-import org.reactivestreams.tck.flow.support.PublisherVerificationRules;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n-\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-public abstract class IdentityProcessorVerification<T> extends WithHelperPublisher<T>\n-  implements SubscriberWhiteboxVerificationRules, PublisherVerificationRules {\n-\n-  private final TestEnvironment env;\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ DELEGATED TO SPECS \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  \/\/ for delegating tests\n-  private final SubscriberWhiteboxVerification<T> subscriberVerification;\n-\n-  \/\/ for delegating tests\n-  private final PublisherVerification<T> publisherVerification;\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ END OF DELEGATED TO SPECS \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  \/\/ number of elements the processor under test must be able ot buffer,\n-  \/\/ without dropping elements. Defaults to `TestEnvironment.TEST_BUFFER_SIZE`.\n-  private final int processorBufferSize;\n-\n-  \/**\n-   * Test class must specify the expected time it takes for the publisher to\n-   * shut itself down when the the last downstream {@code Subscription} is cancelled.\n-   *\n-   * The processor will be required to be able to buffer {@code TestEnvironment.TEST_BUFFER_SIZE} elements.\n-   *\/\n-  @SuppressWarnings(\"unused\")\n-  public IdentityProcessorVerification(final TestEnvironment env) {\n-    this(env, PublisherVerification.envPublisherReferenceGCTimeoutMillis(), TestEnvironment.TEST_BUFFER_SIZE);\n-  }\n-\n-  \/**\n-   * Test class must specify the expected time it takes for the publisher to\n-   * shut itself down when the the last downstream {@code Subscription} is cancelled.\n-   *\n-   * The processor will be required to be able to buffer {@code TestEnvironment.TEST_BUFFER_SIZE} elements.\n-   *\n-   * @param publisherReferenceGCTimeoutMillis used to determine after how much time a reference to a Subscriber should be already dropped by the Publisher.\n-   *\/\n-  @SuppressWarnings(\"unused\")\n-  public IdentityProcessorVerification(final TestEnvironment env, long publisherReferenceGCTimeoutMillis) {\n-    this(env, publisherReferenceGCTimeoutMillis, TestEnvironment.TEST_BUFFER_SIZE);\n-  }\n-\n-  \/**\n-   * Test class must specify the expected time it takes for the publisher to\n-   * shut itself down when the the last downstream {@code Subscription} is cancelled.\n-   *\n-   * @param publisherReferenceGCTimeoutMillis used to determine after how much time a reference to a Subscriber should be already dropped by the Publisher.\n-   * @param processorBufferSize            number of elements the processor is required to be able to buffer.\n-   *\/\n-  public IdentityProcessorVerification(final TestEnvironment env, long publisherReferenceGCTimeoutMillis, int processorBufferSize) {\n-    this.env = env;\n-    this.processorBufferSize = processorBufferSize;\n-\n-    this.subscriberVerification = new SubscriberWhiteboxVerification<T>(env) {\n-      @Override\n-      public Subscriber<T> createSubscriber(WhiteboxSubscriberProbe<T> probe) {\n-        return IdentityProcessorVerification.this.createSubscriber(probe);\n-      }\n-\n-      @Override public T createElement(int element) {\n-        return IdentityProcessorVerification.this.createElement(element);\n-      }\n-\n-      @Override\n-      public Publisher<T> createHelperPublisher(long elements) {\n-        return IdentityProcessorVerification.this.createHelperPublisher(elements);\n-      }\n-    };\n-\n-    publisherVerification = new PublisherVerification<T>(env, publisherReferenceGCTimeoutMillis) {\n-      @Override\n-      public Publisher<T> createPublisher(long elements) {\n-        return IdentityProcessorVerification.this.createPublisher(elements);\n-      }\n-\n-      @Override\n-      public Publisher<T> createFailedPublisher() {\n-        return IdentityProcessorVerification.this.createFailedPublisher();\n-      }\n-\n-      @Override\n-      public long maxElementsFromPublisher() {\n-        return IdentityProcessorVerification.this.maxElementsFromPublisher();\n-      }\n-\n-      @Override\n-      public long boundedDepthOfOnNextAndRequestRecursion() {\n-        return IdentityProcessorVerification.this.boundedDepthOfOnNextAndRequestRecursion();\n-      }\n-\n-      @Override\n-      public boolean skipStochasticTests() {\n-        return IdentityProcessorVerification.this.skipStochasticTests();\n-      }\n-    };\n-  }\n-\n-  \/**\n-   * This is the main method you must implement in your test incarnation.\n-   * It must create a {@link Processor}, which simply forwards all stream elements from its upstream\n-   * to its downstream. It must be able to internally buffer the given number of elements.\n-   *\n-   * @param bufferSize number of elements the processor is required to be able to buffer.\n-   *\/\n-  public abstract Processor<T, T> createIdentityProcessor(int bufferSize);\n-\n-  \/**\n-   * By implementing this method, additional TCK tests concerning a \"failed\" publishers will be run.\n-   *\n-   * The expected behaviour of the {@link Publisher} returned by this method is hand out a subscription,\n-   * followed by signalling {@code onError} on it, as specified by Rule 1.9.\n-   *\n-   * If you want to ignore these additional tests, return {@code null} from this method.\n-   *\/\n-  public abstract Publisher<T> createFailedPublisher();\n-\n-  \/**\n-   * Override and return lower value if your Publisher is only able to produce a known number of elements.\n-   * For example, if it is designed to return at-most-one element, return {@code 1} from this method.\n-   *\n-   * Defaults to {@code Long.MAX_VALUE - 1}, meaning that the Publisher can be produce a huge but NOT an unbounded number of elements.\n-   *\n-   * To mark your Publisher will *never* signal an {@code onComplete} override this method and return {@code Long.MAX_VALUE},\n-   * which will result in *skipping all tests which require an onComplete to be triggered* (!).\n-   *\/\n-  public long maxElementsFromPublisher() {\n-    return Long.MAX_VALUE - 1;\n-  }\n-\n-  \/**\n-   * In order to verify rule 3.3 of the reactive streams spec, this number will be used to check if a\n-   * {@code Subscription} actually solves the \"unbounded recursion\" problem by not allowing the number of\n-   * recursive calls to exceed the number returned by this method.\n-   *\n-   * @see <a href=\"https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.3\">reactive streams spec, rule 3.3<\/a>\n-   * @see PublisherVerification#required_spec303_mustNotAllowUnboundedRecursion()\n-   *\/\n-  public long boundedDepthOfOnNextAndRequestRecursion() {\n-    return 1;\n-  }\n-\n-  \/**\n-   * Override and return {@code true} in order to skip executing tests marked as {@code Stochastic}.\n-   * Stochastic in this case means that the Rule is impossible or infeasible to deterministically verify\n-   * usually this means that this test case can yield false positives (\"be green\") even if for some case,\n-   * the given implementation may violate the tested behaviour.\n-   *\/\n-  public boolean skipStochasticTests() {\n-    return false;\n-  }\n-\n-  \/**\n-   * Describes the tested implementation in terms of how many subscribers they can support.\n-   * Some tests require the {@code Publisher} under test to support multiple Subscribers,\n-   * yet the spec does not require all publishers to be able to do so, thus  if an implementation\n-   * supports only a limited number of subscribers (e.g. only 1 subscriber, also known as \"no fanout\")\n-   * you MUST return that number from this method by overriding it.\n-   *\/\n-  public long maxSupportedSubscribers() {\n-      return Long.MAX_VALUE;\n-  }\n-\n-  \/**\n-   * Override this method and return {@code true} if the {@link Processor} returned by the\n-   * {@link #createIdentityProcessor(int)} coordinates its {@link Subscriber}s\n-   * request amounts and only delivers onNext signals if all Subscribers have\n-   * indicated (via their Subscription#request(long)) they are ready to receive elements.\n-   *\/\n-  public boolean doesCoordinatedEmission() {\n-    return false;\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ TEST ENV CLEANUP \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  @BeforeMethod\n-  public void setUp() throws Exception {\n-    publisherVerification.setUp();\n-    subscriberVerification.setUp();\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ PUBLISHER RULES VERIFICATION \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  \/\/ A Processor\n-  \/\/   must obey all Publisher rules on its publishing side\n-  public Publisher<T> createPublisher(long elements) {\n-    final Processor<T, T> processor = createIdentityProcessor(processorBufferSize);\n-    final Publisher<T> pub = createHelperPublisher(elements);\n-    pub.subscribe(processor);\n-    return processor; \/\/ we run the PublisherVerification against this\n-  }\n-\n-  @Override @Test\n-  public void required_validate_maxElementsFromPublisher() throws Exception {\n-    publisherVerification.required_validate_maxElementsFromPublisher();\n-  }\n-\n-  @Override @Test\n-  public void required_validate_boundedDepthOfOnNextAndRequestRecursion() throws Exception {\n-    publisherVerification.required_validate_boundedDepthOfOnNextAndRequestRecursion();\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ DELEGATED TESTS, A PROCESSOR \"IS A\" PUBLISHER \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#4.1\n-\n-  @Test\n-  public void required_createPublisher1MustProduceAStreamOfExactly1Element() throws Throwable {\n-    publisherVerification.required_createPublisher1MustProduceAStreamOfExactly1Element();\n-  }\n-\n-  @Test\n-  public void required_createPublisher3MustProduceAStreamOfExactly3Elements() throws Throwable {\n-    publisherVerification.required_createPublisher3MustProduceAStreamOfExactly3Elements();\n-  }\n-\n-  @Override @Test\n-  public void required_spec101_subscriptionRequestMustResultInTheCorrectNumberOfProducedElements() throws Throwable {\n-    publisherVerification.required_spec101_subscriptionRequestMustResultInTheCorrectNumberOfProducedElements();\n-  }\n-\n-  @Override @Test\n-  public void required_spec102_maySignalLessThanRequestedAndTerminateSubscription() throws Throwable {\n-    publisherVerification.required_spec102_maySignalLessThanRequestedAndTerminateSubscription();\n-  }\n-\n-  @Override @Test\n-  public void stochastic_spec103_mustSignalOnMethodsSequentially() throws Throwable {\n-    publisherVerification.stochastic_spec103_mustSignalOnMethodsSequentially();\n-  }\n-\n-  @Override @Test\n-  public void optional_spec104_mustSignalOnErrorWhenFails() throws Throwable {\n-    publisherVerification.optional_spec104_mustSignalOnErrorWhenFails();\n-  }\n-\n-  @Override @Test\n-  public void required_spec105_mustSignalOnCompleteWhenFiniteStreamTerminates() throws Throwable {\n-    publisherVerification.required_spec105_mustSignalOnCompleteWhenFiniteStreamTerminates();\n-  }\n-\n-  @Override @Test\n-  public void optional_spec105_emptyStreamMustTerminateBySignallingOnComplete() throws Throwable {\n-    publisherVerification.optional_spec105_emptyStreamMustTerminateBySignallingOnComplete();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec106_mustConsiderSubscriptionCancelledAfterOnErrorOrOnCompleteHasBeenCalled() throws Throwable {\n-    publisherVerification.untested_spec106_mustConsiderSubscriptionCancelledAfterOnErrorOrOnCompleteHasBeenCalled();\n-  }\n-\n-  @Override @Test\n-  public void required_spec107_mustNotEmitFurtherSignalsOnceOnCompleteHasBeenSignalled() throws Throwable {\n-    publisherVerification.required_spec107_mustNotEmitFurtherSignalsOnceOnCompleteHasBeenSignalled();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec107_mustNotEmitFurtherSignalsOnceOnErrorHasBeenSignalled() throws Throwable {\n-    publisherVerification.untested_spec107_mustNotEmitFurtherSignalsOnceOnErrorHasBeenSignalled();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec108_possiblyCanceledSubscriptionShouldNotReceiveOnErrorOrOnCompleteSignals() throws Throwable {\n-    publisherVerification.untested_spec108_possiblyCanceledSubscriptionShouldNotReceiveOnErrorOrOnCompleteSignals();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec109_subscribeShouldNotThrowNonFatalThrowable() throws Throwable {\n-    publisherVerification.untested_spec109_subscribeShouldNotThrowNonFatalThrowable();\n-  }\n-\n-  @Override @Test\n-  public void required_spec109_subscribeThrowNPEOnNullSubscriber() throws Throwable {\n-    publisherVerification.required_spec109_subscribeThrowNPEOnNullSubscriber();\n-  }\n-\n-  @Override @Test\n-  public void required_spec109_mayRejectCallsToSubscribeIfPublisherIsUnableOrUnwillingToServeThemRejectionMustTriggerOnErrorAfterOnSubscribe() throws Throwable {\n-    publisherVerification.required_spec109_mayRejectCallsToSubscribeIfPublisherIsUnableOrUnwillingToServeThemRejectionMustTriggerOnErrorAfterOnSubscribe();\n-  }\n-\n-  @Override @Test\n-  public void required_spec109_mustIssueOnSubscribeForNonNullSubscriber() throws Throwable {\n-    publisherVerification.required_spec109_mustIssueOnSubscribeForNonNullSubscriber();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec110_rejectASubscriptionRequestIfTheSameSubscriberSubscribesTwice() throws Throwable {\n-    publisherVerification.untested_spec110_rejectASubscriptionRequestIfTheSameSubscriberSubscribesTwice();\n-  }\n-\n-  @Override @Test\n-  public void optional_spec111_maySupportMultiSubscribe() throws Throwable {\n-    publisherVerification.optional_spec111_maySupportMultiSubscribe();\n-  }\n-\n-  @Override @Test\n-  public void optional_spec111_registeredSubscribersMustReceiveOnNextOrOnCompleteSignals() throws Throwable {\n-    publisherVerification.optional_spec111_registeredSubscribersMustReceiveOnNextOrOnCompleteSignals();\n-  }\n-\n-  @Override @Test\n-  public void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingOneByOne() throws Throwable {\n-    publisherVerification.optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingOneByOne();\n-  }\n-\n-  @Override @Test\n-  public void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfront() throws Throwable {\n-    publisherVerification.optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfront();\n-  }\n-\n-  @Override @Test\n-  public void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfrontAndCompleteAsExpected() throws Throwable {\n-    publisherVerification.optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfrontAndCompleteAsExpected();\n-  }\n-\n-  @Override @Test\n-  public void required_spec302_mustAllowSynchronousRequestCallsFromOnNextAndOnSubscribe() throws Throwable {\n-    publisherVerification.required_spec302_mustAllowSynchronousRequestCallsFromOnNextAndOnSubscribe();\n-  }\n-\n-  @Override @Test\n-  public void required_spec303_mustNotAllowUnboundedRecursion() throws Throwable {\n-    publisherVerification.required_spec303_mustNotAllowUnboundedRecursion();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec304_requestShouldNotPerformHeavyComputations() throws Exception {\n-    publisherVerification.untested_spec304_requestShouldNotPerformHeavyComputations();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec305_cancelMustNotSynchronouslyPerformHeavyComputation() throws Exception {\n-    publisherVerification.untested_spec305_cancelMustNotSynchronouslyPerformHeavyComputation();\n-  }\n-\n-  @Override @Test\n-  public void required_spec306_afterSubscriptionIsCancelledRequestMustBeNops() throws Throwable {\n-    publisherVerification.required_spec306_afterSubscriptionIsCancelledRequestMustBeNops();\n-  }\n-\n-  @Override @Test\n-  public void required_spec307_afterSubscriptionIsCancelledAdditionalCancelationsMustBeNops() throws Throwable {\n-    publisherVerification.required_spec307_afterSubscriptionIsCancelledAdditionalCancelationsMustBeNops();\n-  }\n-\n-  @Override @Test\n-  public void required_spec309_requestZeroMustSignalIllegalArgumentException() throws Throwable {\n-    publisherVerification.required_spec309_requestZeroMustSignalIllegalArgumentException();\n-  }\n-\n-  @Override @Test\n-  public void required_spec309_requestNegativeNumberMustSignalIllegalArgumentException() throws Throwable {\n-    publisherVerification.required_spec309_requestNegativeNumberMustSignalIllegalArgumentException();\n-  }\n-\n-  @Override @Test\n-  public void optional_spec309_requestNegativeNumberMaySignalIllegalArgumentExceptionWithSpecificMessage() throws Throwable {\n-    publisherVerification.optional_spec309_requestNegativeNumberMaySignalIllegalArgumentExceptionWithSpecificMessage();\n-  }\n-\n-  @Override @Test\n-  public void required_spec312_cancelMustMakeThePublisherToEventuallyStopSignaling() throws Throwable {\n-    publisherVerification.required_spec312_cancelMustMakeThePublisherToEventuallyStopSignaling();\n-  }\n-\n-  @Override @Test\n-  public void required_spec313_cancelMustMakeThePublisherEventuallyDropAllReferencesToTheSubscriber() throws Throwable {\n-    publisherVerification.required_spec313_cancelMustMakeThePublisherEventuallyDropAllReferencesToTheSubscriber();\n-  }\n-\n-  @Override @Test\n-  public void required_spec317_mustSupportAPendingElementCountUpToLongMaxValue() throws Throwable {\n-    publisherVerification.required_spec317_mustSupportAPendingElementCountUpToLongMaxValue();\n-  }\n-\n-  @Override @Test\n-  public void required_spec317_mustSupportACumulativePendingElementCountUpToLongMaxValue() throws Throwable {\n-    publisherVerification.required_spec317_mustSupportACumulativePendingElementCountUpToLongMaxValue();\n-  }\n-\n-  @Override @Test\n-  public void required_spec317_mustNotSignalOnErrorWhenPendingAboveLongMaxValue() throws Throwable {\n-    publisherVerification.required_spec317_mustNotSignalOnErrorWhenPendingAboveLongMaxValue();\n-  }\n-\n-\n-  \/**\n-   * Asks for a {@code Processor} that supports at least 2 {@code Subscriber}s at once and checks if two {@code Subscriber}s\n-   * receive the same items and a terminal {@code Exception}.\n-   * <p>\n-   * If the {@code Processor} requests and\/or emits items only when all of its {@code Subscriber}s have requested,\n-   * override {@link #doesCoordinatedEmission()} and return {@code true} to indicate this property.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.4'>1.4<\/a> with multiple\n-   * {@code Subscriber}s.\n-   * <p>\n-   * The test is not executed if {@link IdentityProcessorVerification#maxSupportedSubscribers()} is less than 2.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Processor} implementation:\n-   * <ul>\n-   * <li>The {@code TestEnvironment} has large enough timeout specified in case the {@code Processor} has some time-delay behavior.<\/li>\n-   * <li>The {@code Processor} is able to fulfill requests of its {@code Subscriber}s independently of each other's requests or\n-   * else override {@link #doesCoordinatedEmission()} and return {@code true} to indicate the test {@code Subscriber}s\n-   * both have to request first.<\/li>\n-   * <\/ul>\n-   *\/\n-  @Test\n-  public void required_spec104_mustCallOnErrorOnAllItsSubscribersIfItEncountersANonRecoverableError() throws Throwable {\n-    optionalMultipleSubscribersTest(2, new Function<Long,TestSetup>() {\n-      @Override\n-      public TestSetup apply(Long aLong) throws Throwable {\n-        return new TestSetup(env, processorBufferSize) {{\n-          final ManualSubscriberWithErrorCollection<T> sub1 = new ManualSubscriberWithErrorCollection<T>(env);\n-          env.subscribe(processor, sub1);\n-\n-          final ManualSubscriberWithErrorCollection<T> sub2 = new ManualSubscriberWithErrorCollection<T>(env);\n-          env.subscribe(processor, sub2);\n-\n-          final Exception ex = new RuntimeException(\"Test exception\");\n-\n-          if (doesCoordinatedEmission()) {\n-            sub1.request(1);\n-            sub2.request(1);\n-\n-            expectRequest();\n-\n-            final T x = sendNextTFromUpstream();\n-\n-            expectNextElement(sub1, x);\n-            expectNextElement(sub2, x);\n-\n-            sub1.request(1);\n-            sub2.request(1);\n-          } else {\n-            sub1.request(1);\n-\n-            expectRequest(env.defaultTimeoutMillis(),\n-                    \"If the Processor coordinates requests\/emissions when having multiple Subscribers\"\n-                    + \" at once, please override doesCoordinatedEmission() to return true in this \"\n-                    + \"IdentityProcessorVerification to allow this test to pass.\");\n-\n-            final T x = sendNextTFromUpstream();\n-            expectNextElement(sub1, x,\n-                    \"If the Processor coordinates requests\/emissions when having multiple Subscribers\"\n-                            + \" at once, please override doesCoordinatedEmission() to return true in this \"\n-                            + \"IdentityProcessorVerification to allow this test to pass.\");\n-\n-            sub1.request(1);\n-\n-            \/\/ sub1 has received one element, and has one demand pending\n-            \/\/ sub2 has not yet requested anything\n-          }\n-          sendError(ex);\n-\n-          sub1.expectError(ex);\n-          sub2.expectError(ex);\n-\n-          env.verifyNoAsyncErrorsNoDelay();\n-        }};\n-      }\n-    });\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ SUBSCRIBER RULES VERIFICATION \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#4.1\n-\n-  \/\/ A Processor\n-  \/\/   must obey all Subscriber rules on its consuming side\n-  public Subscriber<T> createSubscriber(final SubscriberWhiteboxVerification.WhiteboxSubscriberProbe<T> probe) {\n-    final Processor<T, T> processor = createIdentityProcessor(processorBufferSize);\n-    processor.subscribe(\n-        new Subscriber<T>() {\n-          private final Promise<Subscription> subs = new Promise<Subscription>(env);\n-\n-          @Override\n-          public void onSubscribe(final Subscription subscription) {\n-            if (env.debugEnabled()) {\n-              env.debug(String.format(\"whiteboxSubscriber::onSubscribe(%s)\", subscription));\n-            }\n-            if (subs.isCompleted()) subscription.cancel(); \/\/ the Probe must also pass subscriber verification\n-\n-            probe.registerOnSubscribe(new SubscriberWhiteboxVerification.SubscriberPuppet() {\n-\n-              @Override\n-              public void triggerRequest(long elements) {\n-                subscription.request(elements);\n-              }\n-\n-              @Override\n-              public void signalCancel() {\n-                subscription.cancel();\n-              }\n-            });\n-          }\n-\n-          @Override\n-          public void onNext(T element) {\n-            if (env.debugEnabled()) {\n-              env.debug(String.format(\"whiteboxSubscriber::onNext(%s)\", element));\n-            }\n-            probe.registerOnNext(element);\n-          }\n-\n-          @Override\n-          public void onComplete() {\n-            if (env.debugEnabled()) {\n-              env.debug(\"whiteboxSubscriber::onComplete()\");\n-            }\n-            probe.registerOnComplete();\n-          }\n-\n-          @Override\n-          public void onError(Throwable cause) {\n-            if (env.debugEnabled()) {\n-              env.debug(String.format(\"whiteboxSubscriber::onError(%s)\", cause));\n-            }\n-            probe.registerOnError(cause);\n-          }\n-        });\n-\n-    return processor; \/\/ we run the SubscriberVerification against this\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ OTHER RULE VERIFICATION \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  \/\/ A Processor\n-  \/\/   must immediately pass on `onError` events received from its upstream to its downstream\n-  @Test\n-  public void mustImmediatelyPassOnOnErrorEventsReceivedFromItsUpstreamToItsDownstream() throws Exception {\n-    new TestSetup(env, processorBufferSize) {{\n-      final ManualSubscriberWithErrorCollection<T> sub = new ManualSubscriberWithErrorCollection<T>(env);\n-      env.subscribe(processor, sub);\n-\n-      final Exception ex = new RuntimeException(\"Test exception\");\n-      sendError(ex);\n-      sub.expectError(ex); \/\/ \"immediately\", i.e. without a preceding request\n-\n-      env.verifyNoAsyncErrorsNoDelay();\n-    }};\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ DELEGATED TESTS, A PROCESSOR \"IS A\" SUBSCRIBER \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#4.1\n-\n-  @Test\n-  public void required_exerciseWhiteboxHappyPath() throws Throwable {\n-    subscriberVerification.required_exerciseWhiteboxHappyPath();\n-  }\n-\n-  @Override @Test\n-  public void required_spec201_mustSignalDemandViaSubscriptionRequest() throws Throwable {\n-    subscriberVerification.required_spec201_mustSignalDemandViaSubscriptionRequest();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec202_shouldAsynchronouslyDispatch() throws Exception {\n-    subscriberVerification.untested_spec202_shouldAsynchronouslyDispatch();\n-  }\n-\n-  @Override @Test\n-  public void required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnComplete() throws Throwable {\n-    subscriberVerification.required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnComplete();\n-  }\n-\n-  @Override @Test\n-  public void required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnError() throws Throwable {\n-    subscriberVerification.required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnError();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec204_mustConsiderTheSubscriptionAsCancelledInAfterRecievingOnCompleteOrOnError() throws Exception {\n-    subscriberVerification.untested_spec204_mustConsiderTheSubscriptionAsCancelledInAfterRecievingOnCompleteOrOnError();\n-  }\n-\n-  @Override @Test\n-  public void required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal() throws Throwable {\n-    subscriberVerification.required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec206_mustCallSubscriptionCancelIfItIsNoLongerValid() throws Exception {\n-    subscriberVerification.untested_spec206_mustCallSubscriptionCancelIfItIsNoLongerValid();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec207_mustEnsureAllCallsOnItsSubscriptionTakePlaceFromTheSameThreadOrTakeCareOfSynchronization() throws Exception {\n-    subscriberVerification.untested_spec207_mustEnsureAllCallsOnItsSubscriptionTakePlaceFromTheSameThreadOrTakeCareOfSynchronization();\n-  }\n-\n-  @Override @Test\n-  public void required_spec208_mustBePreparedToReceiveOnNextSignalsAfterHavingCalledSubscriptionCancel() throws Throwable {\n-    subscriberVerification.required_spec208_mustBePreparedToReceiveOnNextSignalsAfterHavingCalledSubscriptionCancel();\n-  }\n-\n-  @Override @Test\n-  public void required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithPrecedingRequestCall() throws Throwable {\n-    subscriberVerification.required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithPrecedingRequestCall();\n-  }\n-\n-  @Override @Test\n-  public void required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithoutPrecedingRequestCall() throws Throwable {\n-    subscriberVerification.required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithoutPrecedingRequestCall();\n-  }\n-\n-  @Override @Test\n-  public void required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithPrecedingRequestCall() throws Throwable {\n-    subscriberVerification.required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithPrecedingRequestCall();\n-  }\n-\n-  @Override @Test\n-  public void required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithoutPrecedingRequestCall() throws Throwable {\n-    subscriberVerification.required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithoutPrecedingRequestCall();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec211_mustMakeSureThatAllCallsOnItsMethodsHappenBeforeTheProcessingOfTheRespectiveEvents() throws Exception {\n-    subscriberVerification.untested_spec211_mustMakeSureThatAllCallsOnItsMethodsHappenBeforeTheProcessingOfTheRespectiveEvents();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec212_mustNotCallOnSubscribeMoreThanOnceBasedOnObjectEquality_specViolation() throws Throwable {\n-    subscriberVerification.untested_spec212_mustNotCallOnSubscribeMoreThanOnceBasedOnObjectEquality_specViolation();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec213_failingOnSignalInvocation() throws Exception {\n-    subscriberVerification.untested_spec213_failingOnSignalInvocation();\n-  }\n-\n-  @Override @Test\n-  public void required_spec213_onSubscribe_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {\n-    subscriberVerification.required_spec213_onSubscribe_mustThrowNullPointerExceptionWhenParametersAreNull();\n-  }\n-  @Override @Test\n-  public void required_spec213_onNext_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {\n-    subscriberVerification.required_spec213_onNext_mustThrowNullPointerExceptionWhenParametersAreNull();\n-  }\n-  @Override @Test\n-  public void required_spec213_onError_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {\n-    subscriberVerification.required_spec213_onError_mustThrowNullPointerExceptionWhenParametersAreNull();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec301_mustNotBeCalledOutsideSubscriberContext() throws Exception {\n-    subscriberVerification.untested_spec301_mustNotBeCalledOutsideSubscriberContext();\n-  }\n-\n-  @Override @Test\n-  public void required_spec308_requestMustRegisterGivenNumberElementsToBeProduced() throws Throwable {\n-    subscriberVerification.required_spec308_requestMustRegisterGivenNumberElementsToBeProduced();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec310_requestMaySynchronouslyCallOnNextOnSubscriber() throws Exception {\n-    subscriberVerification.untested_spec310_requestMaySynchronouslyCallOnNextOnSubscriber();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec311_requestMaySynchronouslyCallOnCompleteOrOnError() throws Exception {\n-    subscriberVerification.untested_spec311_requestMaySynchronouslyCallOnCompleteOrOnError();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec314_cancelMayCauseThePublisherToShutdownIfNoOtherSubscriptionExists() throws Exception {\n-    subscriberVerification.untested_spec314_cancelMayCauseThePublisherToShutdownIfNoOtherSubscriptionExists();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec315_cancelMustNotThrowExceptionAndMustSignalOnError() throws Exception {\n-    subscriberVerification.untested_spec315_cancelMustNotThrowExceptionAndMustSignalOnError();\n-  }\n-\n-  @Override @Test\n-  public void untested_spec316_requestMustNotThrowExceptionAndMustOnErrorTheSubscriber() throws Exception {\n-    subscriberVerification.untested_spec316_requestMustNotThrowExceptionAndMustOnErrorTheSubscriber();\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ ADDITIONAL \"COROLLARY\" TESTS \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  \/**\n-   * Asks for a {@code Processor} that supports at least 2 {@code Subscriber}s at once and checks requests\n-   * from {@code Subscriber}s will eventually lead to requests towards the upstream of the {@code Processor}.\n-   * <p>\n-   * If the {@code Processor} requests and\/or emits items only when all of its {@code Subscriber}s have requested,\n-   * override {@link #doesCoordinatedEmission()} and return {@code true} to indicate this property.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.4'>2.1<\/a> with multiple\n-   * {@code Subscriber}s.\n-   * <p>\n-   * The test is not executed if {@link IdentityProcessorVerification#maxSupportedSubscribers()} is less than 2.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Processor} implementation:\n-   * <ul>\n-   * <li>The {@code TestEnvironment} has large enough timeout specified in case the {@code Processor} has some time-delay behavior.<\/li>\n-   * <li>The {@code Processor} is able to fulfill requests of its {@code Subscriber}s independently of each other's requests or\n-   * else override {@link #doesCoordinatedEmission()} and return {@code true} to indicate the test {@code Subscriber}s\n-   * both have to request first.<\/li>\n-   * <\/ul>\n-   *\/\n-  @Test\n-  public void required_mustRequestFromUpstreamForElementsThatHaveBeenRequestedLongAgo() throws Throwable {\n-    optionalMultipleSubscribersTest(2, new Function<Long,TestSetup>() {\n-      @Override\n-      public TestSetup apply(Long subscribers) throws Throwable {\n-        return new TestSetup(env, processorBufferSize) {{\n-          ManualSubscriber<T> sub1 = newSubscriber();\n-          sub1.request(20);\n-\n-          long totalRequests = expectRequest();\n-          final T x = sendNextTFromUpstream();\n-          expectNextElement(sub1, x);\n-\n-          if (totalRequests == 1) {\n-            totalRequests += expectRequest();\n-          }\n-          final T y = sendNextTFromUpstream();\n-          expectNextElement(sub1, y);\n-\n-          if (totalRequests == 2) {\n-            totalRequests += expectRequest();\n-          }\n-\n-          final ManualSubscriber<T> sub2 = newSubscriber();\n-\n-          \/\/ sub1 now has 18 pending\n-          \/\/ sub2 has 0 pending\n-\n-          if (doesCoordinatedEmission()) {\n-            sub2.expectNone(); \/\/ since sub2 hasn't requested anything yet\n-\n-            sub2.request(1);\n-\n-            final T z = sendNextTFromUpstream();\n-            expectNextElement(sub1, z);\n-            expectNextElement(sub2, z);\n-          } else {\n-            final T z = sendNextTFromUpstream();\n-            expectNextElement(sub1, z,\n-                    \"If the Processor coordinates requests\/emissions when having multiple Subscribers\"\n-                            + \" at once, please override doesCoordinatedEmission() to return true in this \"\n-                            + \"IdentityProcessorVerification to allow this test to pass.\");\n-            sub2.expectNone(); \/\/ since sub2 hasn't requested anything yet\n-\n-            sub2.request(1);\n-            expectNextElement(sub2, z);\n-          }\n-          if (totalRequests == 3) {\n-            expectRequest();\n-          }\n-\n-          \/\/ to avoid error messages during test harness shutdown\n-          sendCompletion();\n-          sub1.expectCompletion(env.defaultTimeoutMillis());\n-          sub2.expectCompletion(env.defaultTimeoutMillis());\n-\n-          env.verifyNoAsyncErrorsNoDelay();\n-        }};\n-      }\n-    });\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ TEST INFRASTRUCTURE \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  public void notVerified() {\n-    publisherVerification.notVerified();\n-  }\n-\n-  public void notVerified(String message) {\n-    publisherVerification.notVerified(message);\n-  }\n-\n-  \/**\n-   * Test for feature that REQUIRES multiple subscribers to be supported by Publisher.\n-   *\/\n-  public void optionalMultipleSubscribersTest(long requiredSubscribersSupport, Function<Long, TestSetup> body) throws Throwable {\n-    if (requiredSubscribersSupport > maxSupportedSubscribers())\n-      notVerified(String.format(\"The Publisher under test only supports %d subscribers, while this test requires at least %d to run.\",\n-                                maxSupportedSubscribers(), requiredSubscribersSupport));\n-    else body.apply(requiredSubscribersSupport);\n-  }\n-\n-  public abstract class TestSetup extends ManualPublisher<T> {\n-    final private ManualSubscriber<T> tees; \/\/ gives us access to an infinite stream of T values\n-    private Set<T> seenTees = new HashSet<T>();\n-\n-    final Processor<T, T> processor;\n-\n-    public TestSetup(TestEnvironment env, int testBufferSize) throws InterruptedException {\n-      super(env);\n-      tees = env.newManualSubscriber(createHelperPublisher(Long.MAX_VALUE));\n-      processor = createIdentityProcessor(testBufferSize);\n-      subscribe(processor);\n-    }\n-\n-    public ManualSubscriber<T> newSubscriber() throws InterruptedException {\n-      return env.newManualSubscriber(processor);\n-    }\n-\n-    public T nextT() throws InterruptedException {\n-      final T t = tees.requestNextElement();\n-      if (seenTees.contains(t)) {\n-        env.flop(String.format(\"Helper publisher illegally produced the same element %s twice\", t));\n-      }\n-      seenTees.add(t);\n-      return t;\n-    }\n-\n-    public void expectNextElement(ManualSubscriber<T> sub, T expected) throws InterruptedException {\n-      final T elem = sub.nextElement(String.format(\"timeout while awaiting %s\", expected));\n-      if (!elem.equals(expected)) {\n-        env.flop(String.format(\"Received `onNext(%s)` on downstream but expected `onNext(%s)`\", elem, expected));\n-      }\n-    }\n-\n-    public void expectNextElement(ManualSubscriber<T> sub, T expected, String errorMessageAddendum) throws InterruptedException {\n-      final T elem = sub.nextElement(String.format(\"timeout while awaiting %s. %s\", expected, errorMessageAddendum));\n-      if (!elem.equals(expected)) {\n-        env.flop(String.format(\"Received `onNext(%s)` on downstream but expected `onNext(%s)`\", elem, expected));\n-      }\n-    }\n-\n-    public T sendNextTFromUpstream() throws InterruptedException {\n-      final T x = nextT();\n-      sendNext(x);\n-      return x;\n-    }\n-  }\n-\n-  public class ManualSubscriberWithErrorCollection<A> extends ManualSubscriberWithSubscriptionSupport<A> {\n-    Promise<Throwable> error;\n-\n-    public ManualSubscriberWithErrorCollection(TestEnvironment env) {\n-      super(env);\n-      error = new Promise<Throwable>(env);\n-    }\n-\n-    @Override\n-    public void onError(Throwable cause) {\n-      error.complete(cause);\n-    }\n-\n-    public void expectError(Throwable cause) throws InterruptedException {\n-      expectError(cause, env.defaultTimeoutMillis());\n-    }\n-\n-    @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n-    public void expectError(Throwable cause, long timeoutMillis) throws InterruptedException {\n-      error.expectCompletion(timeoutMillis, \"Did not receive expected error on downstream\");\n-      if (!cause.equals(error.value())) {\n-        env.flop(String.format(\"Expected error %s but got %s\", cause, error.value()));\n-      }\n-    }\n-  }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/IdentityProcessorVerification.java","additions":0,"deletions":896,"binary":false,"changes":896,"status":"deleted"},{"patch":"@@ -1,1245 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck;\n-\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-import org.reactivestreams.tck.TestEnvironment.BlackholeSubscriberWithSubscriptionSupport;\n-import org.reactivestreams.tck.TestEnvironment.Latch;\n-import org.reactivestreams.tck.TestEnvironment.ManualSubscriber;\n-import org.reactivestreams.tck.TestEnvironment.ManualSubscriberWithSubscriptionSupport;\n-import org.reactivestreams.tck.flow.support.Function;\n-import org.reactivestreams.tck.flow.support.Optional;\n-import org.reactivestreams.tck.flow.support.PublisherVerificationRules;\n-import org.testng.SkipException;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n-\n-import java.lang.Override;\n-import java.lang.ref.ReferenceQueue;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Random;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-\n-\/**\n- * Provides tests for verifying {@code Publisher} specification rules.\n- *\n- * @see org.reactivestreams.Publisher\n- *\/\n-public abstract class PublisherVerification<T> implements PublisherVerificationRules {\n-\n-  private static final String PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS_ENV = \"PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS\";\n-  private static final long DEFAULT_PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS = 300L;\n-\n-  private final TestEnvironment env;\n-\n-  \/**\n-   * The amount of time after which a cancelled Subscriber reference should be dropped.\n-   * See Rule 3.13 for details.\n-   *\/\n-  private final long publisherReferenceGCTimeoutMillis;\n-\n-  \/**\n-   * Constructs a new verification class using the given env and configuration.\n-   *\n-   * @param publisherReferenceGCTimeoutMillis used to determine after how much time a reference to a Subscriber should be already dropped by the Publisher.\n-   *\/\n-  public PublisherVerification(TestEnvironment env, long publisherReferenceGCTimeoutMillis) {\n-    this.env = env;\n-    this.publisherReferenceGCTimeoutMillis = publisherReferenceGCTimeoutMillis;\n-  }\n-\n-  \/**\n-   * Constructs a new verification class using the given env and configuration.\n-   *\n-   * The value for {@code publisherReferenceGCTimeoutMillis} will be obtained by using {@link PublisherVerification#envPublisherReferenceGCTimeoutMillis()}.\n-   *\/\n-  public PublisherVerification(TestEnvironment env) {\n-    this.env = env;\n-    this.publisherReferenceGCTimeoutMillis = envPublisherReferenceGCTimeoutMillis();\n-  }\n-\n-  \/**\n-   * Tries to parse the env variable {@code PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS} as long and returns the value if present,\n-   * OR its default value ({@link PublisherVerification#DEFAULT_PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS}).\n-   *\n-   * This value is used to determine after how much time a reference to a Subscriber should be already dropped by the Publisher.\n-   *\n-   * @throws java.lang.IllegalArgumentException when unable to parse the env variable\n-   *\/\n-  public static long envPublisherReferenceGCTimeoutMillis() {\n-    final String envMillis = System.getenv(PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS_ENV);\n-    if (envMillis == null) return DEFAULT_PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS;\n-    else try {\n-      return Long.parseLong(envMillis);\n-    } catch (NumberFormatException ex) {\n-      throw new IllegalArgumentException(String.format(\"Unable to parse %s env value [%s] as long!\", PUBLISHER_REFERENCE_GC_TIMEOUT_MILLIS_ENV, envMillis), ex);\n-    }\n-  }\n-\n-  \/**\n-   * This is the main method you must implement in your test incarnation.\n-   * It must create a Publisher for a stream with exactly the given number of elements.\n-   * If `elements` is `Long.MAX_VALUE` the produced stream must be infinite.\n-   *\/\n-  public abstract Publisher<T> createPublisher(long elements);\n-\n-  \/**\n-   * By implementing this method, additional TCK tests concerning a \"failed\" publishers will be run.\n-   *\n-   * The expected behaviour of the {@link Publisher} returned by this method is hand out a subscription,\n-   * followed by signalling {@code onError} on it, as specified by Rule 1.9.\n-   *\n-   * If you ignore these additional tests, return {@code null} from this method.\n-   *\/\n-  public abstract Publisher<T> createFailedPublisher();\n-\n-\n-  \/**\n-   * Override and return lower value if your Publisher is only able to produce a known number of elements.\n-   * For example, if it is designed to return at-most-one element, return {@code 1} from this method.\n-   *\n-   * Defaults to {@code Long.MAX_VALUE - 1}, meaning that the Publisher can be produce a huge but NOT an unbounded number of elements.\n-   *\n-   * To mark your Publisher will *never* signal an {@code onComplete} override this method and return {@code Long.MAX_VALUE},\n-   * which will result in *skipping all tests which require an onComplete to be triggered* (!).\n-   *\/\n-  public long maxElementsFromPublisher() {\n-    return Long.MAX_VALUE - 1;\n-  }\n-\n-  \/**\n-   * Override and return {@code true} in order to skip executing tests marked as {@code Stochastic}.\n-   * Stochastic in this case means that the Rule is impossible or infeasible to deterministically verify\n-   * usually this means that this test case can yield false positives (\"be green\") even if for some case,\n-   * the given implementation may violate the tested behaviour.\n-   *\/\n-  public boolean skipStochasticTests() {\n-    return false;\n-  }\n-\n-  \/**\n-   * In order to verify rule 3.3 of the reactive streams spec, this number will be used to check if a\n-   * {@code Subscription} actually solves the \"unbounded recursion\" problem by not allowing the number of\n-   * recursive calls to exceed the number returned by this method.\n-   *\n-   * @see <a href=\"https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.3\">reactive streams spec, rule 3.3<\/a>\n-   * @see PublisherVerification#required_spec303_mustNotAllowUnboundedRecursion()\n-   *\/\n-  public long boundedDepthOfOnNextAndRequestRecursion() {\n-    return 1;\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ TEST ENV CLEANUP \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  @BeforeMethod\n-  public void setUp() throws Exception {\n-    env.clearAsyncErrors();\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ TEST SETUP VERIFICATION \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  @Override @Test\n-  public void required_createPublisher1MustProduceAStreamOfExactly1Element() throws Throwable {\n-    activePublisherTest(1, true, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws InterruptedException {\n-        ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        assertTrue(requestNextElementOrEndOfStream(pub, sub).isDefined(), String.format(\"Publisher %s produced no elements\", pub));\n-        sub.requestEndOfStream();\n-      }\n-\n-      Optional<T> requestNextElementOrEndOfStream(Publisher<T> pub, ManualSubscriber<T> sub) throws InterruptedException {\n-        return sub.requestNextElementOrEndOfStream(String.format(\"Timeout while waiting for next element from Publisher %s\", pub));\n-      }\n-\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_createPublisher3MustProduceAStreamOfExactly3Elements() throws Throwable {\n-    activePublisherTest(3, true, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws InterruptedException {\n-        ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        assertTrue(requestNextElementOrEndOfStream(pub, sub).isDefined(), String.format(\"Publisher %s produced no elements\", pub));\n-        assertTrue(requestNextElementOrEndOfStream(pub, sub).isDefined(), String.format(\"Publisher %s produced only 1 element\", pub));\n-        assertTrue(requestNextElementOrEndOfStream(pub, sub).isDefined(), String.format(\"Publisher %s produced only 2 elements\", pub));\n-        sub.requestEndOfStream();\n-      }\n-\n-      Optional<T> requestNextElementOrEndOfStream(Publisher<T> pub, ManualSubscriber<T> sub) throws InterruptedException {\n-        return sub.requestNextElementOrEndOfStream(String.format(\"Timeout while waiting for next element from Publisher %s\", pub));\n-      }\n-\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_validate_maxElementsFromPublisher() throws Exception {\n-    assertTrue(maxElementsFromPublisher() >= 0, \"maxElementsFromPublisher MUST return a number >= 0\");\n-  }\n-\n-  @Override @Test\n-  public void required_validate_boundedDepthOfOnNextAndRequestRecursion() throws Exception {\n-    assertTrue(boundedDepthOfOnNextAndRequestRecursion() >= 1, \"boundedDepthOfOnNextAndRequestRecursion must return a number >= 1\");\n-  }\n-\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ SPEC RULE VERIFICATION \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  @Override @Test\n-  public void required_spec101_subscriptionRequestMustResultInTheCorrectNumberOfProducedElements() throws Throwable {\n-    activePublisherTest(5, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws InterruptedException {\n-\n-        ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        try {\n-            sub.expectNone(String.format(\"Publisher %s produced value before the first `request`: \", pub));\n-            sub.request(1);\n-            sub.nextElement(String.format(\"Publisher %s produced no element after first `request`\", pub));\n-            sub.expectNone(String.format(\"Publisher %s produced unrequested: \", pub));\n-\n-            sub.request(1);\n-            sub.request(2);\n-            sub.nextElements(3, env.defaultTimeoutMillis(), String.format(\"Publisher %s produced less than 3 elements after two respective `request` calls\", pub));\n-\n-            sub.expectNone(String.format(\"Publisher %sproduced unrequested \", pub));\n-        } finally {\n-            sub.cancel();\n-        }\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec102_maySignalLessThanRequestedAndTerminateSubscription() throws Throwable {\n-    final int elements = 3;\n-    final int requested = 10;\n-\n-    activePublisherTest(elements, true, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        final ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        sub.request(requested);\n-        sub.nextElements(elements);\n-        sub.expectCompletion();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void stochastic_spec103_mustSignalOnMethodsSequentially() throws Throwable {\n-    final int iterations = 100;\n-    final int elements = 10;\n-\n-    stochasticTest(iterations, new Function<Integer, Void>() {\n-      @Override\n-      public Void apply(final Integer runNumber) throws Throwable {\n-        activePublisherTest(elements, true, new PublisherTestRun<T>() {\n-          @Override\n-          public void run(Publisher<T> pub) throws Throwable {\n-            final Latch completionLatch = new Latch(env);\n-\n-            final AtomicInteger gotElements = new AtomicInteger(0);\n-            pub.subscribe(new Subscriber<T>() {\n-              private Subscription subs;\n-\n-              private ConcurrentAccessBarrier concurrentAccessBarrier = new ConcurrentAccessBarrier();\n-\n-              \/**\n-               * Concept wise very similar to a {@link org.reactivestreams.tck.TestEnvironment.Latch}, serves to protect\n-               * a critical section from concurrent access, with the added benefit of Thread tracking and same-thread-access awareness.\n-               *\n-               * Since a <i>Synchronous<\/i> Publisher may choose to synchronously (using the same {@link Thread}) call\n-               * {@code onNext} directly from either {@code subscribe} or {@code request} a plain Latch is not enough\n-               * to verify concurrent access safety - one needs to track if the caller is not still using the calling thread\n-               * to enter subsequent critical sections (\"nesting\" them effectively).\n-               *\/\n-              final class ConcurrentAccessBarrier {\n-                private AtomicReference<Thread> currentlySignallingThread = new AtomicReference<Thread>(null);\n-                private volatile String previousSignal = null;\n-\n-                public void enterSignal(String signalName) {\n-                  if((!currentlySignallingThread.compareAndSet(null, Thread.currentThread())) && !isSynchronousSignal()) {\n-                    env.flop(String.format(\n-                      \"Illegal concurrent access detected (entering critical section)! \" +\n-                        \"%s emited %s signal, before %s finished its %s signal.\",\n-                        Thread.currentThread(), signalName, currentlySignallingThread.get(), previousSignal));\n-                  }\n-                  this.previousSignal = signalName;\n-                }\n-\n-                public void leaveSignal(String signalName) {\n-                  currentlySignallingThread.set(null);\n-                  this.previousSignal = signalName;\n-                }\n-\n-                private boolean isSynchronousSignal() {\n-                  return (previousSignal != null) && Thread.currentThread().equals(currentlySignallingThread.get());\n-                }\n-\n-              }\n-\n-              @Override\n-              public void onSubscribe(Subscription s) {\n-                final String signal = \"onSubscribe()\";\n-                concurrentAccessBarrier.enterSignal(signal);\n-\n-                subs = s;\n-                subs.request(1);\n-\n-                concurrentAccessBarrier.leaveSignal(signal);\n-              }\n-\n-              @Override\n-              public void onNext(T ignore) {\n-                final String signal = String.format(\"onNext(%s)\", ignore);\n-                concurrentAccessBarrier.enterSignal(signal);\n-\n-                if (gotElements.incrementAndGet() <= elements) \/\/ requesting one more than we know are in the stream (some Publishers need this)\n-                  subs.request(1);\n-\n-                concurrentAccessBarrier.leaveSignal(signal);\n-              }\n-\n-              @Override\n-              public void onError(Throwable t) {\n-                final String signal = String.format(\"onError(%s)\", t.getMessage());\n-                concurrentAccessBarrier.enterSignal(signal);\n-\n-                \/\/ ignore value\n-\n-                concurrentAccessBarrier.leaveSignal(signal);\n-              }\n-\n-              @Override\n-              public void onComplete() {\n-                final String signal = \"onComplete()\";\n-                concurrentAccessBarrier.enterSignal(signal);\n-\n-                \/\/ entering for completeness\n-\n-                concurrentAccessBarrier.leaveSignal(signal);\n-                completionLatch.close();\n-              }\n-            });\n-\n-            completionLatch.expectClose(\n-              elements * env.defaultTimeoutMillis(),\n-              String.format(\"Failed in iteration %d of %d. Expected completion signal after signalling %d elements (signalled %d), yet did not receive it\",\n-                            runNumber, iterations, elements, gotElements.get()));\n-          }\n-        });\n-        return null;\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void optional_spec104_mustSignalOnErrorWhenFails() throws Throwable {\n-    try {\n-      whenHasErrorPublisherTest(new PublisherTestRun<T>() {\n-        @Override\n-        public void run(final Publisher<T> pub) throws InterruptedException {\n-          final Latch onErrorlatch = new Latch(env);\n-          final Latch onSubscribeLatch = new Latch(env);\n-          pub.subscribe(new TestEnvironment.TestSubscriber<T>(env) {\n-            @Override\n-            public void onSubscribe(Subscription subs) {\n-              onSubscribeLatch.assertOpen(\"Only one onSubscribe call expected\");\n-              onSubscribeLatch.close();\n-            }\n-            @Override\n-            public void onError(Throwable cause) {\n-              onSubscribeLatch.assertClosed(\"onSubscribe should be called prior to onError always\");\n-              onErrorlatch.assertOpen(String.format(\"Error-state Publisher %s called `onError` twice on new Subscriber\", pub));\n-              onErrorlatch.close();\n-            }\n-          });\n-\n-          onSubscribeLatch.expectClose(\"Should have received onSubscribe\");\n-          onErrorlatch.expectClose(String.format(\"Error-state Publisher %s did not call `onError` on new Subscriber\", pub));\n-\n-          env.verifyNoAsyncErrors();\n-          }\n-      });\n-    } catch (SkipException se) {\n-      throw se;\n-    } catch (Throwable ex) {\n-      \/\/ we also want to catch AssertionErrors and anything the publisher may have thrown inside subscribe\n-      \/\/ which was wrong of him - he should have signalled on error using onError\n-      throw new RuntimeException(String.format(\"Publisher threw exception (%s) instead of signalling error via onError!\", ex.getMessage()), ex);\n-    }\n-  }\n-\n-  @Override @Test\n-  public void required_spec105_mustSignalOnCompleteWhenFiniteStreamTerminates() throws Throwable {\n-    activePublisherTest(3, true, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        sub.requestNextElement();\n-        sub.requestNextElement();\n-        sub.requestNextElement();\n-        sub.requestEndOfStream();\n-        sub.expectNone();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void optional_spec105_emptyStreamMustTerminateBySignallingOnComplete() throws Throwable {\n-    optionalActivePublisherTest(0, true, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        sub.request(1);\n-        sub.expectCompletion();\n-        sub.expectNone();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void untested_spec106_mustConsiderSubscriptionCancelledAfterOnErrorOrOnCompleteHasBeenCalled() throws Throwable {\n-    notVerified(); \/\/ not really testable without more control over the Publisher\n-  }\n-\n-  @Override @Test\n-  public void required_spec107_mustNotEmitFurtherSignalsOnceOnCompleteHasBeenSignalled() throws Throwable {\n-    activePublisherTest(1, true, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        sub.request(10);\n-        sub.nextElement();\n-        sub.expectCompletion();\n-\n-        sub.request(10);\n-        sub.expectNone();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void untested_spec107_mustNotEmitFurtherSignalsOnceOnErrorHasBeenSignalled() throws Throwable {\n-    notVerified(); \/\/ can we meaningfully test this, without more control over the publisher?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec108_possiblyCanceledSubscriptionShouldNotReceiveOnErrorOrOnCompleteSignals() throws Throwable {\n-    notVerified(); \/\/ can we meaningfully test this?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec109_subscribeShouldNotThrowNonFatalThrowable() throws Throwable {\n-    notVerified(); \/\/ can we meaningfully test this?\n-  }\n-\n-  @Override @Test\n-  public void required_spec109_subscribeThrowNPEOnNullSubscriber() throws Throwable {\n-    activePublisherTest(0, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        try {\n-            pub.subscribe(null);\n-            env.flop(\"Publisher did not throw a NullPointerException when given a null Subscribe in subscribe\");\n-        } catch (NullPointerException ignored) {\n-          \/\/ valid behaviour\n-        }\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec109_mustIssueOnSubscribeForNonNullSubscriber() throws Throwable {\n-    activePublisherTest(0, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        final Latch onSubscribeLatch = new Latch(env);\n-        final AtomicReference<Subscription> cancel = new AtomicReference<Subscription>();\n-        try {\n-          pub.subscribe(new Subscriber<T>() {\n-            @Override\n-            public void onError(Throwable cause) {\n-              onSubscribeLatch.assertClosed(\"onSubscribe should be called prior to onError always\");\n-            }\n-\n-            @Override\n-            public void onSubscribe(Subscription subs) {\n-              cancel.set(subs);\n-              onSubscribeLatch.assertOpen(\"Only one onSubscribe call expected\");\n-              onSubscribeLatch.close();\n-            }\n-\n-            @Override\n-            public void onNext(T elem) {\n-              onSubscribeLatch.assertClosed(\"onSubscribe should be called prior to onNext always\");\n-            }\n-\n-            @Override\n-            public void onComplete() {\n-              onSubscribeLatch.assertClosed(\"onSubscribe should be called prior to onComplete always\");\n-            }\n-          });\n-          onSubscribeLatch.expectClose(\"Should have received onSubscribe\");\n-          env.verifyNoAsyncErrorsNoDelay();\n-        } finally {\n-          Subscription s = cancel.getAndSet(null);\n-          if (s != null) {\n-            s.cancel();\n-          }\n-        }\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec109_mayRejectCallsToSubscribeIfPublisherIsUnableOrUnwillingToServeThemRejectionMustTriggerOnErrorAfterOnSubscribe() throws Throwable {\n-    whenHasErrorPublisherTest(new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        final Latch onErrorLatch = new Latch(env);\n-        final Latch onSubscribeLatch = new Latch(env);\n-        ManualSubscriberWithSubscriptionSupport<T> sub = new ManualSubscriberWithSubscriptionSupport<T>(env) {\n-          @Override\n-          public void onError(Throwable cause) {\n-            onSubscribeLatch.assertClosed(\"onSubscribe should be called prior to onError always\");\n-            onErrorLatch.assertOpen(\"Only one onError call expected\");\n-            onErrorLatch.close();\n-          }\n-\n-          @Override\n-          public void onSubscribe(Subscription subs) {\n-            onSubscribeLatch.assertOpen(\"Only one onSubscribe call expected\");\n-            onSubscribeLatch.close();\n-          }\n-        };\n-        pub.subscribe(sub);\n-        onSubscribeLatch.expectClose(\"Should have received onSubscribe\");\n-        onErrorLatch.expectClose(\"Should have received onError\");\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void untested_spec110_rejectASubscriptionRequestIfTheSameSubscriberSubscribesTwice() throws Throwable {\n-    notVerified(); \/\/ can we meaningfully test this?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.11\n-  @Override @Test\n-  public void optional_spec111_maySupportMultiSubscribe() throws Throwable {\n-    optionalActivePublisherTest(1, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        ManualSubscriber<T> sub1 = env.newManualSubscriber(pub);\n-        ManualSubscriber<T> sub2 = env.newManualSubscriber(pub);\n-\n-        try {\n-          env.verifyNoAsyncErrors();\n-        } finally {\n-          try {\n-            sub1.cancel();\n-          } finally {\n-            sub2.cancel();\n-          }\n-        }\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void optional_spec111_registeredSubscribersMustReceiveOnNextOrOnCompleteSignals() throws Throwable {\n-    optionalActivePublisherTest(1, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        ManualSubscriber<T> sub1 = env.newManualSubscriber(pub);\n-        ManualSubscriber<T> sub2 = env.newManualSubscriber(pub);\n-        \/\/ Since we're testing the case when the Publisher DOES support the optional multi-subscribers scenario,\n-        \/\/ and decides if it handles them uni-cast or multi-cast, we don't know which subscriber will receive an\n-        \/\/ onNext (and optional onComplete) signal(s) and which just onComplete signal.\n-        \/\/ Plus, even if subscription assumed to be unicast, it's implementation choice, which one will be signalled\n-        \/\/ with onNext.\n-        sub1.requestNextElementOrEndOfStream();\n-        sub2.requestNextElementOrEndOfStream();\n-        try {\n-            env.verifyNoAsyncErrors();\n-        } finally {\n-            try {\n-                sub1.cancel();\n-            } finally {\n-                sub2.cancel();\n-            }\n-        }\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingOneByOne() throws Throwable {\n-    optionalActivePublisherTest(5, true, new PublisherTestRun<T>() { \/\/ This test is skipped if the publisher is unbounded (never sends onComplete)\n-      @Override\n-      public void run(Publisher<T> pub) throws InterruptedException {\n-        ManualSubscriber<T> sub1 = env.newManualSubscriber(pub);\n-        ManualSubscriber<T> sub2 = env.newManualSubscriber(pub);\n-        ManualSubscriber<T> sub3 = env.newManualSubscriber(pub);\n-\n-        sub1.request(1);\n-        T x1 = sub1.nextElement(String.format(\"Publisher %s did not produce the requested 1 element on 1st subscriber\", pub));\n-        sub2.request(2);\n-        List<T> y1 = sub2.nextElements(2, String.format(\"Publisher %s did not produce the requested 2 elements on 2nd subscriber\", pub));\n-        sub1.request(1);\n-        T x2 = sub1.nextElement(String.format(\"Publisher %s did not produce the requested 1 element on 1st subscriber\", pub));\n-        sub3.request(3);\n-        List<T> z1 = sub3.nextElements(3, String.format(\"Publisher %s did not produce the requested 3 elements on 3rd subscriber\", pub));\n-        sub3.request(1);\n-        T z2 = sub3.nextElement(String.format(\"Publisher %s did not produce the requested 1 element on 3rd subscriber\", pub));\n-        sub3.request(1);\n-        T z3 = sub3.nextElement(String.format(\"Publisher %s did not produce the requested 1 element on 3rd subscriber\", pub));\n-        sub3.requestEndOfStream(String.format(\"Publisher %s did not complete the stream as expected on 3rd subscriber\", pub));\n-        sub2.request(3);\n-        List<T> y2 = sub2.nextElements(3, String.format(\"Publisher %s did not produce the requested 3 elements on 2nd subscriber\", pub));\n-        sub2.requestEndOfStream(String.format(\"Publisher %s did not complete the stream as expected on 2nd subscriber\", pub));\n-        sub1.request(2);\n-        List<T> x3 = sub1.nextElements(2, String.format(\"Publisher %s did not produce the requested 2 elements on 1st subscriber\", pub));\n-        sub1.request(1);\n-        T x4 = sub1.nextElement(String.format(\"Publisher %s did not produce the requested 1 element on 1st subscriber\", pub));\n-        sub1.requestEndOfStream(String.format(\"Publisher %s did not complete the stream as expected on 1st subscriber\", pub));\n-\n-        @SuppressWarnings(\"unchecked\")\n-        List<T> r = new ArrayList<T>(Arrays.asList(x1, x2));\n-        r.addAll(x3);\n-        r.addAll(Collections.singleton(x4));\n-\n-        List<T> check1 = new ArrayList<T>(y1);\n-        check1.addAll(y2);\n-\n-        \/\/noinspection unchecked\n-        List<T> check2 = new ArrayList<T>(z1);\n-        check2.add(z2);\n-        check2.add(z3);\n-\n-        assertEquals(r, check1, String.format(\"Publisher %s did not produce the same element sequence for subscribers 1 and 2\", pub));\n-        assertEquals(r, check2, String.format(\"Publisher %s did not produce the same element sequence for subscribers 1 and 3\", pub));\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfront() throws Throwable {\n-    optionalActivePublisherTest(3, false, new PublisherTestRun<T>() { \/\/ This test is skipped if the publisher cannot produce enough elements\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        ManualSubscriber<T> sub1 = env.newManualSubscriber(pub);\n-        ManualSubscriber<T> sub2 = env.newManualSubscriber(pub);\n-        ManualSubscriber<T> sub3 = env.newManualSubscriber(pub);\n-\n-        List<T> received1 = new ArrayList<T>();\n-        List<T> received2 = new ArrayList<T>();\n-        List<T> received3 = new ArrayList<T>();\n-\n-        \/\/ if the publisher must touch it's source to notice it's been drained, the OnComplete won't come until we ask for more than it actually contains...\n-        \/\/ edgy edge case?\n-        sub1.request(4);\n-        sub2.request(4);\n-        sub3.request(4);\n-\n-        received1.addAll(sub1.nextElements(3));\n-        received2.addAll(sub2.nextElements(3));\n-        received3.addAll(sub3.nextElements(3));\n-\n-        \/\/ NOTE: can't check completion, the Publisher may not be able to signal it\n-        \/\/       a similar test *with* completion checking is implemented\n-\n-        assertEquals(received1, received2, String.format(\"Expected elements to be signaled in the same sequence to 1st and 2nd subscribers\"));\n-        assertEquals(received2, received3, String.format(\"Expected elements to be signaled in the same sequence to 2nd and 3rd subscribers\"));\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfrontAndCompleteAsExpected() throws Throwable {\n-    optionalActivePublisherTest(3, true, new PublisherTestRun<T>() { \/\/ This test is skipped if the publisher is unbounded (never sends onComplete)\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        ManualSubscriber<T> sub1 = env.newManualSubscriber(pub);\n-        ManualSubscriber<T> sub2 = env.newManualSubscriber(pub);\n-        ManualSubscriber<T> sub3 = env.newManualSubscriber(pub);\n-\n-        List<T> received1 = new ArrayList<T>();\n-        List<T> received2 = new ArrayList<T>();\n-        List<T> received3 = new ArrayList<T>();\n-\n-        \/\/ if the publisher must touch it's source to notice it's been drained, the OnComplete won't come until we ask for more than it actually contains...\n-        \/\/ edgy edge case?\n-        sub1.request(4);\n-        sub2.request(4);\n-        sub3.request(4);\n-\n-        received1.addAll(sub1.nextElements(3));\n-        received2.addAll(sub2.nextElements(3));\n-        received3.addAll(sub3.nextElements(3));\n-\n-        sub1.expectCompletion();\n-        sub2.expectCompletion();\n-        sub3.expectCompletion();\n-\n-        assertEquals(received1, received2, String.format(\"Expected elements to be signaled in the same sequence to 1st and 2nd subscribers\"));\n-        assertEquals(received2, received3, String.format(\"Expected elements to be signaled in the same sequence to 2nd and 3rd subscribers\"));\n-      }\n-    });\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ SUBSCRIPTION TESTS \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  @Override @Test\n-  public void required_spec302_mustAllowSynchronousRequestCallsFromOnNextAndOnSubscribe() throws Throwable {\n-    activePublisherTest(6, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        ManualSubscriber<T> sub = new ManualSubscriber<T>(env) {\n-          @Override\n-          public void onSubscribe(Subscription subs) {\n-            this.subscription.completeImmediatly(subs);\n-\n-            subs.request(1);\n-            subs.request(1);\n-            subs.request(1);\n-          }\n-\n-          @Override\n-          public void onNext(T element) {\n-            Subscription subs = this.subscription.value();\n-            subs.request(1);\n-          }\n-        };\n-\n-        env.subscribe(pub, sub);\n-\n-        env.verifyNoAsyncErrors();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec303_mustNotAllowUnboundedRecursion() throws Throwable {\n-    final long oneMoreThanBoundedLimit = boundedDepthOfOnNextAndRequestRecursion() + 1;\n-\n-    activePublisherTest(oneMoreThanBoundedLimit, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        final ThreadLocal<Long> stackDepthCounter = new ThreadLocal<Long>() {\n-          @Override\n-          protected Long initialValue() {\n-            return 0L;\n-          }\n-        };\n-\n-        final Latch runCompleted = new Latch(env);\n-\n-        final ManualSubscriber<T> sub = new ManualSubscriberWithSubscriptionSupport<T>(env) {\n-          \/\/ counts the number of signals received, used to break out from possibly infinite request\/onNext loops\n-          long signalsReceived = 0L;\n-\n-          @Override\n-          public void onNext(T element) {\n-            \/\/ NOT calling super.onNext as this test only cares about stack depths, not the actual values of elements\n-            \/\/ which also simplifies this test as we do not have to drain the test buffer, which would otherwise be in danger of overflowing\n-\n-            signalsReceived += 1;\n-            stackDepthCounter.set(stackDepthCounter.get() + 1);\n-            if (env.debugEnabled()) {\n-              env.debug(String.format(\"%s(recursion depth: %d)::onNext(%s)\", this, stackDepthCounter.get(), element));\n-            }\n-\n-            final long callsUntilNow = stackDepthCounter.get();\n-            if (callsUntilNow > boundedDepthOfOnNextAndRequestRecursion()) {\n-              env.flop(String.format(\"Got %d onNext calls within thread: %s, yet expected recursive bound was %d\",\n-                                     callsUntilNow, Thread.currentThread(), boundedDepthOfOnNextAndRequestRecursion()));\n-\n-              \/\/ stop the recursive call chain\n-              runCompleted.close();\n-              return;\n-            } else if (signalsReceived >= oneMoreThanBoundedLimit) {\n-              \/\/ since max number of signals reached, and recursion depth not exceeded, we judge this as a success and\n-              \/\/ stop the recursive call chain\n-              runCompleted.close();\n-              return;\n-            }\n-\n-            \/\/ request more right away, the Publisher must break the recursion\n-            subscription.value().request(1);\n-\n-            stackDepthCounter.set(stackDepthCounter.get() - 1);\n-          }\n-\n-          @Override\n-          public void onComplete() {\n-            super.onComplete();\n-            runCompleted.close();\n-          }\n-\n-          @Override\n-          public void onError(Throwable cause) {\n-            super.onError(cause);\n-            runCompleted.close();\n-          }\n-        };\n-\n-        try {\n-          env.subscribe(pub, sub);\n-\n-          sub.request(1); \/\/ kick-off the `request -> onNext -> request -> onNext -> ...`\n-\n-          final String msg = String.format(\"Unable to validate call stack depth safety, \" +\n-                                               \"awaited at-most %s signals (`maxOnNextSignalsInRecursionTest()`) or completion\",\n-                                           oneMoreThanBoundedLimit);\n-          runCompleted.expectClose(env.defaultTimeoutMillis(), msg);\n-          env.verifyNoAsyncErrorsNoDelay();\n-        } finally {\n-          \/\/ since the request\/onNext recursive calls may keep the publisher running \"forever\",\n-          \/\/ we MUST cancel it manually before exiting this test case\n-          sub.cancel();\n-        }\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void untested_spec304_requestShouldNotPerformHeavyComputations() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec305_cancelMustNotSynchronouslyPerformHeavyComputation() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void required_spec306_afterSubscriptionIsCancelledRequestMustBeNops() throws Throwable {\n-    activePublisherTest(3, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-\n-        \/\/ override ManualSubscriberWithSubscriptionSupport#cancel because by default a ManualSubscriber will drop the\n-        \/\/ subscription once it's cancelled (as expected).\n-        \/\/ In this test however it must keep the cancelled Subscription and keep issuing `request(long)` to it.\n-        ManualSubscriber<T> sub = new ManualSubscriberWithSubscriptionSupport<T>(env) {\n-          @Override\n-          public void cancel() {\n-            if (subscription.isCompleted()) {\n-              subscription.value().cancel();\n-            } else {\n-              env.flop(\"Cannot cancel a subscription before having received it\");\n-            }\n-          }\n-        };\n-\n-        env.subscribe(pub, sub);\n-\n-        sub.cancel();\n-        sub.request(1);\n-        sub.request(1);\n-        sub.request(1);\n-\n-        sub.expectNone();\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec307_afterSubscriptionIsCancelledAdditionalCancelationsMustBeNops() throws Throwable {\n-    activePublisherTest(1, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        final ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-\n-        \/\/ leak the Subscription\n-        final Subscription subs = sub.subscription.value();\n-\n-        subs.cancel();\n-        subs.cancel();\n-        subs.cancel();\n-\n-        sub.expectNone();\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec309_requestZeroMustSignalIllegalArgumentException() throws Throwable {\n-    activePublisherTest(10, false, new PublisherTestRun<T>() {\n-      @Override public void run(Publisher<T> pub) throws Throwable {\n-        final ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        sub.request(0);\n-        sub.expectError(IllegalArgumentException.class);\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec309_requestNegativeNumberMustSignalIllegalArgumentException() throws Throwable {\n-    activePublisherTest(10, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        final ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        final Random r = new Random();\n-        sub.request(-r.nextInt(Integer.MAX_VALUE) - 1);\n-        \/\/ we do require implementations to mention the rule number at the very least, or mentioning that the non-negative request is the problem\n-        sub.expectError(IllegalArgumentException.class);\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void optional_spec309_requestNegativeNumberMaySignalIllegalArgumentExceptionWithSpecificMessage() throws Throwable {\n-    optionalActivePublisherTest(10, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        final ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        final Random r = new Random();\n-        sub.request(-r.nextInt(Integer.MAX_VALUE) - 1);\n-        \/\/ we do require implementations to mention the rule number at the very least, or mentioning that the non-negative request is the problem\n-        sub.expectErrorWithMessage(IllegalArgumentException.class, Arrays.asList(\"3.9\", \"non-positive subscription request\", \"negative subscription request\"));\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec312_cancelMustMakeThePublisherToEventuallyStopSignaling() throws Throwable {\n-    \/\/ the publisher is able to signal more elements than the subscriber will be requesting in total\n-    final int publisherElements = 20;\n-\n-    final int demand1 = 10;\n-    final int demand2 = 5;\n-    final int totalDemand = demand1 + demand2;\n-\n-    activePublisherTest(publisherElements, false, new PublisherTestRun<T>() {\n-      @Override @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n-      public void run(Publisher<T> pub) throws Throwable {\n-        final ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-\n-        sub.request(demand1);\n-        sub.request(demand2);\n-\n-        \/*\n-          NOTE: The order of the nextElement\/cancel calls below is very important (!)\n-\n-          If this ordering was reversed, given an asynchronous publisher,\n-          the following scenario would be *legal* and would break this test:\n-\n-          > AsyncPublisher receives request(10) - it does not emit data right away, it's asynchronous\n-          > AsyncPublisher receives request(5) - demand is now 15\n-          ! AsyncPublisher didn't emit any onNext yet (!)\n-          > AsyncPublisher receives cancel() - handles it right away, by \"stopping itself\" for example\n-          ! cancel was handled hefore the AsyncPublisher ever got the chance to emit data\n-          ! the subscriber ends up never receiving even one element - the test is stuck (and fails, even on valid Publisher)\n-\n-          Which is why we must first expect an element, and then cancel, once the producing is \"running\".\n-         *\/\n-        sub.nextElement();\n-        sub.cancel();\n-\n-        int onNextsSignalled = 1;\n-\n-        boolean stillBeingSignalled;\n-        do {\n-          \/\/ put asyncError if onNext signal received\n-          sub.expectNone();\n-          Throwable error = env.dropAsyncError();\n-\n-          if (error == null) {\n-            stillBeingSignalled = false;\n-          } else {\n-            onNextsSignalled += 1;\n-            stillBeingSignalled = true;\n-          }\n-\n-          \/\/ if the Publisher tries to emit more elements than was requested (and\/or ignores cancellation) this will throw\n-          assertTrue(onNextsSignalled <= totalDemand,\n-                     String.format(\"Publisher signalled [%d] elements, which is more than the signalled demand: %d\",\n-                                   onNextsSignalled, totalDemand));\n-\n-        } while (stillBeingSignalled);\n-      }\n-    });\n-\n-    env.verifyNoAsyncErrorsNoDelay();\n-  }\n-\n-  @Override @Test\n-  public void required_spec313_cancelMustMakeThePublisherEventuallyDropAllReferencesToTheSubscriber() throws Throwable {\n-    final ReferenceQueue<ManualSubscriber<T>> queue = new ReferenceQueue<ManualSubscriber<T>>();\n-\n-    final Function<Publisher<T>, WeakReference<ManualSubscriber<T>>> run = new Function<Publisher<T>, WeakReference<ManualSubscriber<T>>>() {\n-      @Override\n-      public WeakReference<ManualSubscriber<T>> apply(Publisher<T> pub) throws Exception {\n-        final ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        final WeakReference<ManualSubscriber<T>> ref = new WeakReference<ManualSubscriber<T>>(sub, queue);\n-\n-        sub.request(1);\n-        sub.nextElement();\n-        sub.cancel();\n-\n-        return ref;\n-      }\n-    };\n-\n-    activePublisherTest(3, false, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        final WeakReference<ManualSubscriber<T>> ref = run.apply(pub);\n-\n-        \/\/ cancel may be run asynchronously so we add a sleep before running the GC\n-        \/\/ to \"resolve\" the race\n-        Thread.sleep(publisherReferenceGCTimeoutMillis);\n-        System.gc();\n-\n-        if (!ref.equals(queue.remove(100))) {\n-          env.flop(String.format(\"Publisher %s did not drop reference to test subscriber after subscription cancellation\", pub));\n-        }\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec317_mustSupportAPendingElementCountUpToLongMaxValue() throws Throwable {\n-    final int totalElements = 3;\n-\n-    activePublisherTest(totalElements, true, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        sub.request(Long.MAX_VALUE);\n-\n-        sub.nextElements(totalElements);\n-        sub.expectCompletion();\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec317_mustSupportACumulativePendingElementCountUpToLongMaxValue() throws Throwable {\n-    final int totalElements = 3;\n-\n-    activePublisherTest(totalElements, true, new PublisherTestRun<T>() {\n-      @Override\n-      public void run(Publisher<T> pub) throws Throwable {\n-        final ManualSubscriber<T> sub = env.newManualSubscriber(pub);\n-        sub.request(Long.MAX_VALUE \/ 2); \/\/ pending = Long.MAX_VALUE \/ 2\n-        sub.request(Long.MAX_VALUE \/ 2); \/\/ pending = Long.MAX_VALUE - 1\n-        sub.request(1); \/\/ pending = Long.MAX_VALUE\n-\n-        sub.nextElements(totalElements);\n-        sub.expectCompletion();\n-\n-        try {\n-          env.verifyNoAsyncErrorsNoDelay();\n-        } finally {\n-          sub.cancel();\n-        }\n-\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec317_mustNotSignalOnErrorWhenPendingAboveLongMaxValue() throws Throwable {\n-    activePublisherTest(Integer.MAX_VALUE, false, new PublisherTestRun<T>() {\n-      @Override public void run(Publisher<T> pub) throws Throwable {\n-        final ManualSubscriberWithSubscriptionSupport<T> sub = new BlackholeSubscriberWithSubscriptionSupport<T>(env) {\n-           \/\/ arbitrarily set limit on nuber of request calls signalled, we expect overflow after already 2 calls,\n-           \/\/ so 10 is relatively high and safe even if arbitrarily chosen\n-          int callsCounter = 10;\n-\n-          @Override\n-          public void onNext(T element) {\n-            if (env.debugEnabled()) {\n-              env.debug(String.format(\"%s::onNext(%s)\", this, element));\n-            }\n-            if (subscription.isCompleted()) {\n-              if (callsCounter > 0) {\n-                subscription.value().request(Long.MAX_VALUE - 1);\n-                callsCounter--;\n-              } else {\n-                  subscription.value().cancel();\n-              }\n-            } else {\n-              env.flop(String.format(\"Subscriber::onNext(%s) called before Subscriber::onSubscribe\", element));\n-            }\n-          }\n-        };\n-        env.subscribe(pub, sub, env.defaultTimeoutMillis());\n-\n-        \/\/ eventually triggers `onNext`, which will then trigger up to `callsCounter` times `request(Long.MAX_VALUE - 1)`\n-        \/\/ we're pretty sure to overflow from those\n-        sub.request(1);\n-\n-        \/\/ no onError should be signalled\n-        try {\n-          env.verifyNoAsyncErrors();\n-        } finally {\n-          sub.cancel();\n-        }\n-      }\n-    });\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ ADDITIONAL \"COROLLARY\" TESTS \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ TEST INFRASTRUCTURE \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  public interface PublisherTestRun<T> {\n-    public void run(Publisher<T> pub) throws Throwable;\n-  }\n-\n-  \/**\n-   * Test for feature that SHOULD\/MUST be implemented, using a live publisher.\n-   *\n-   * @param elements the number of elements the Publisher under test  must be able to emit to run this test\n-   * @param completionSignalRequired true if an {@code onComplete} signal is required by this test to run.\n-   *                                 If the tested Publisher is unable to signal completion, tests requireing onComplete signals will be skipped.\n-   *                                 To signal if your Publisher is able to signal completion see {@link PublisherVerification#maxElementsFromPublisher()}.\n-   *\/\n-  public void activePublisherTest(long elements, boolean completionSignalRequired, PublisherTestRun<T> body) throws Throwable {\n-    if (elements > maxElementsFromPublisher()) {\n-      throw new SkipException(String.format(\"Unable to run this test, as required elements nr: %d is higher than supported by given producer: %d\", elements, maxElementsFromPublisher()));\n-    } else if (completionSignalRequired && maxElementsFromPublisher() == Long.MAX_VALUE) {\n-      throw new SkipException(\"Unable to run this test, as it requires an onComplete signal, \" +\n-                                \"which this Publisher is unable to provide (as signalled by returning Long.MAX_VALUE from `maxElementsFromPublisher()`)\");\n-    } else {\n-      Publisher<T> pub = createPublisher(elements);\n-      body.run(pub);\n-      env.verifyNoAsyncErrorsNoDelay();\n-    }\n-  }\n-\n-  \/**\n-   * Test for feature that MAY be implemented. This test will be marked as SKIPPED if it fails.\n-   *\n-   * @param elements the number of elements the Publisher under test  must be able to emit to run this test\n-   * @param completionSignalRequired true if an {@code onComplete} signal is required by this test to run.\n-   *                                 If the tested Publisher is unable to signal completion, tests requireing onComplete signals will be skipped.\n-   *                                 To signal if your Publisher is able to signal completion see {@link PublisherVerification#maxElementsFromPublisher()}.\n-   *\/\n-  public void optionalActivePublisherTest(long elements, boolean completionSignalRequired, PublisherTestRun<T> body) throws Throwable {\n-    if (elements > maxElementsFromPublisher()) {\n-      throw new SkipException(String.format(\"Unable to run this test, as required elements nr: %d is higher than supported by given producer: %d\", elements, maxElementsFromPublisher()));\n-    } else if (completionSignalRequired && maxElementsFromPublisher() == Long.MAX_VALUE) {\n-      throw new SkipException(\"Unable to run this test, as it requires an onComplete signal, \" +\n-                                \"which this Publisher is unable to provide (as signalled by returning Long.MAX_VALUE from `maxElementsFromPublisher()`)\");\n-    } else {\n-\n-      final Publisher<T> pub = createPublisher(elements);\n-      final String skipMessage = \"Skipped because tested publisher does NOT implement this OPTIONAL requirement.\";\n-\n-      try {\n-        potentiallyPendingTest(pub, body);\n-      } catch (Exception ex) {\n-        notVerified(skipMessage);\n-      } catch (AssertionError ex) {\n-        notVerified(skipMessage + \" Reason for skipping was: \" + ex.getMessage());\n-      }\n-    }\n-  }\n-\n-  public static final String SKIPPING_NO_ERROR_PUBLISHER_AVAILABLE =\n-    \"Skipping because no error state Publisher provided, and the test requires it. \" +\n-          \"Please implement PublisherVerification#createFailedPublisher to run this test.\";\n-\n-  public static final String SKIPPING_OPTIONAL_TEST_FAILED =\n-    \"Skipping, because provided Publisher does not pass this *additional* verification.\";\n-  \/**\n-   * Additional test for Publisher in error state\n-   *\/\n-  public void whenHasErrorPublisherTest(PublisherTestRun<T> body) throws Throwable {\n-    potentiallyPendingTest(createFailedPublisher(), body, SKIPPING_NO_ERROR_PUBLISHER_AVAILABLE);\n-  }\n-\n-  public void potentiallyPendingTest(Publisher<T> pub, PublisherTestRun<T> body) throws Throwable {\n-    potentiallyPendingTest(pub, body, SKIPPING_OPTIONAL_TEST_FAILED);\n-  }\n-\n-  public void potentiallyPendingTest(Publisher<T> pub, PublisherTestRun<T> body, String message) throws Throwable {\n-    if (pub != null) {\n-      body.run(pub);\n-    } else {\n-      throw new SkipException(message);\n-    }\n-  }\n-\n-  \/**\n-   * Executes a given test body {@code n} times.\n-   * All the test runs must pass in order for the stochastic test to pass.\n-   *\/\n-  public void stochasticTest(int n, Function<Integer, Void> body) throws Throwable {\n-    if (skipStochasticTests()) {\n-      notVerified(\"Skipping @Stochastic test because `skipStochasticTests()` returned `true`!\");\n-    }\n-\n-    for (int i = 0; i < n; i++) {\n-      body.apply(i);\n-    }\n-  }\n-\n-  public void notVerified() {\n-    throw new SkipException(\"Not verified by this TCK.\");\n-  }\n-\n-  \/**\n-   * Return this value from {@link PublisherVerification#maxElementsFromPublisher()} to mark that the given {@link org.reactivestreams.Publisher},\n-   * is not able to signal completion. For example it is strictly a time-bound or unbounded source of data.\n-   *\n-   * <b>Returning this value from {@link PublisherVerification#maxElementsFromPublisher()} will result in skipping all TCK tests which require onComplete signals!<\/b>\n-   *\/\n-  public long publisherUnableToSignalOnComplete() {\n-    return Long.MAX_VALUE;\n-  }\n-\n-  public void notVerified(String message) {\n-    throw new SkipException(message);\n-  }\n-\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/PublisherVerification.java","additions":0,"deletions":1245,"binary":false,"changes":1245,"status":"deleted"},{"patch":"@@ -1,516 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck;\n-\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-import org.reactivestreams.tck.TestEnvironment.ManualPublisher;\n-import org.reactivestreams.tck.TestEnvironment.ManualSubscriber;\n-import org.reactivestreams.tck.flow.support.Optional;\n-import org.reactivestreams.tck.flow.support.SubscriberBlackboxVerificationRules;\n-import org.reactivestreams.tck.flow.support.TestException;\n-import org.testng.SkipException;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n-\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-\n-import static org.reactivestreams.tck.SubscriberWhiteboxVerification.BlackboxSubscriberProxy;\n-import static org.testng.Assert.assertTrue;\n-\n-\/**\n- * Provides tests for verifying {@link org.reactivestreams.Subscriber} and {@link org.reactivestreams.Subscription}\n- * specification rules, without any modifications to the tested implementation (also known as \"Black Box\" testing).\n- *\n- * This verification is NOT able to check many of the rules of the spec, and if you want more\n- * verification of your implementation you'll have to implement {@code org.reactivestreams.tck.SubscriberWhiteboxVerification}\n- * instead.\n- *\n- * @see org.reactivestreams.Subscriber\n- * @see org.reactivestreams.Subscription\n- *\/\n-public abstract class SubscriberBlackboxVerification<T> extends WithHelperPublisher<T>\n-  implements SubscriberBlackboxVerificationRules {\n-\n-  protected final TestEnvironment env;\n-\n-  protected SubscriberBlackboxVerification(TestEnvironment env) {\n-    this.env = env;\n-  }\n-\n-  \/\/ USER API\n-\n-  \/**\n-   * This is the main method you must implement in your test incarnation.\n-   * It must create a new {@link org.reactivestreams.Subscriber} instance to be subjected to the testing logic.\n-   *\/\n-  public abstract Subscriber<T> createSubscriber();\n-\n-  \/**\n-   * Override this method if the Subscriber implementation you are verifying\n-   * needs an external signal before it signals demand to its Publisher.\n-   *\n-   * By default this method does nothing.\n-   *\/\n-  public void triggerRequest(final Subscriber<? super T> subscriber) {\n-    \/\/ this method is intentionally left blank\n-  }\n-\n-  \/\/ ENV SETUP\n-\n-  \/**\n-   * Executor service used by the default provided asynchronous Publisher.\n-   * @see #createHelperPublisher(long)\n-   *\/\n-  private ExecutorService publisherExecutor;\n-  @BeforeClass public void startPublisherExecutorService() { publisherExecutor = Executors.newFixedThreadPool(4); }\n-  @AfterClass public void shutdownPublisherExecutorService() { if (publisherExecutor != null) publisherExecutor.shutdown(); }\n-  @Override public ExecutorService publisherExecutorService() { return publisherExecutor; }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ TEST ENV CLEANUP \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  @BeforeMethod\n-  public void setUp() throws Exception {\n-    env.clearAsyncErrors();\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ SPEC RULE VERIFICATION \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  @Override @Test\n-  public void required_spec201_blackbox_mustSignalDemandViaSubscriptionRequest() throws Throwable {\n-    blackboxSubscriberTest(new BlackboxTestStageTestRun() {\n-      @Override\n-      public void run(BlackboxTestStage stage) throws InterruptedException {\n-        triggerRequest(stage.subProxy().sub());\n-        final long requested = stage.expectRequest();\/\/ assuming subscriber wants to consume elements...\n-        final long signalsToEmit = Math.min(requested, 512); \/\/ protecting against Subscriber which sends ridiculous large demand\n-\n-        \/\/ should cope with up to requested number of elements\n-        for (int i = 0; i < signalsToEmit && sampleIsCancelled(stage, i, 10); i++)\n-          stage.signalNext();\n-\n-        \/\/ we complete after `signalsToEmit` (which can be less than `requested`),\n-        \/\/ which is legal under https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.2\n-        stage.sendCompletion();\n-      }\n-\n-      \/**\n-       * In order to allow some \"skid\" and not check state on each iteration,\n-       * only check {@code stage.isCancelled} every {@code checkInterval}'th iteration.\n-       *\/\n-      private boolean sampleIsCancelled(BlackboxTestStage stage, int i, int checkInterval) throws InterruptedException {\n-        if (i % checkInterval == 0) return stage.isCancelled();\n-        else return false;\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void untested_spec202_blackbox_shouldAsynchronouslyDispatch() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void required_spec203_blackbox_mustNotCallMethodsOnSubscriptionOrPublisherInOnComplete() throws Throwable {\n-    blackboxSubscriberWithoutSetupTest(new BlackboxTestStageTestRun() {\n-      @Override\n-      public void run(BlackboxTestStage stage) throws Throwable {\n-        final Subscription subs = new Subscription() {\n-          @Override\n-          public void request(long n) {\n-            final Optional<StackTraceElement> onCompleteStackTraceElement = env.findCallerMethodInStackTrace(\"onComplete\");\n-            if (onCompleteStackTraceElement.isDefined()) {\n-              final StackTraceElement stackElem = onCompleteStackTraceElement.get();\n-              env.flop(String.format(\"Subscription::request MUST NOT be called from Subscriber::onComplete (Rule 2.3)! (Caller: %s::%s line %d)\",\n-                                     stackElem.getClassName(), stackElem.getMethodName(), stackElem.getLineNumber()));\n-            }\n-          }\n-\n-          @Override\n-          public void cancel() {\n-            final Optional<StackTraceElement> onCompleteStackElement = env.findCallerMethodInStackTrace(\"onComplete\");\n-            if (onCompleteStackElement.isDefined()) {\n-              final StackTraceElement stackElem = onCompleteStackElement.get();\n-              env.flop(String.format(\"Subscription::cancel MUST NOT be called from Subscriber::onComplete (Rule 2.3)! (Caller: %s::%s line %d)\",\n-                                     stackElem.getClassName(), stackElem.getMethodName(), stackElem.getLineNumber()));\n-            }\n-          }\n-        };\n-\n-        final Subscriber<T> sub = createSubscriber();\n-        sub.onSubscribe(subs);\n-        sub.onComplete();\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec203_blackbox_mustNotCallMethodsOnSubscriptionOrPublisherInOnError() throws Throwable {\n-    blackboxSubscriberWithoutSetupTest(new BlackboxTestStageTestRun() {\n-      @Override\n-      public void run(BlackboxTestStage stage) throws Throwable {\n-        final Subscription subs = new Subscription() {\n-          @Override\n-          public void request(long n) {\n-            Throwable thr = new Throwable();\n-            for (StackTraceElement stackElem : thr.getStackTrace()) {\n-              if (stackElem.getMethodName().equals(\"onError\")) {\n-                env.flop(String.format(\"Subscription::request MUST NOT be called from Subscriber::onError (Rule 2.3)! (Caller: %s::%s line %d)\",\n-                                       stackElem.getClassName(), stackElem.getMethodName(), stackElem.getLineNumber()));\n-              }\n-            }\n-          }\n-\n-          @Override\n-          public void cancel() {\n-            Throwable thr = new Throwable();\n-            for (StackTraceElement stackElem : thr.getStackTrace()) {\n-              if (stackElem.getMethodName().equals(\"onError\")) {\n-                env.flop(String.format(\"Subscription::cancel MUST NOT be called from Subscriber::onError (Rule 2.3)! (Caller: %s::%s line %d)\",\n-                                       stackElem.getClassName(), stackElem.getMethodName(), stackElem.getLineNumber()));\n-              }\n-            }\n-          }\n-        };\n-\n-        final Subscriber<T> sub = createSubscriber();\n-        sub.onSubscribe(subs);\n-        sub.onError(new TestException());\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void untested_spec204_blackbox_mustConsiderTheSubscriptionAsCancelledInAfterRecievingOnCompleteOrOnError() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void required_spec205_blackbox_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal() throws Exception {\n-    new BlackboxTestStage(env) {{\n-      \/\/ try to subscribe another time, if the subscriber calls `probe.registerOnSubscribe` the test will fail\n-      final TestEnvironment.Latch secondSubscriptionCancelled = new TestEnvironment.Latch(env);\n-      sub().onSubscribe(\n-          new Subscription() {\n-            @Override\n-            public void request(long elements) {\n-              env.flop(String.format(\"Subscriber %s illegally called `subscription.request(%s)`!\", sub(), elements));\n-            }\n-\n-            @Override\n-            public void cancel() {\n-              secondSubscriptionCancelled.close();\n-            }\n-\n-            @Override\n-            public String toString() {\n-              return \"SecondSubscription(should get cancelled)\";\n-            }\n-          });\n-\n-      secondSubscriptionCancelled.expectClose(\"Expected SecondSubscription given to subscriber to be cancelled, but `Subscription.cancel()` was not called.\");\n-      env.verifyNoAsyncErrorsNoDelay();\n-      sendCompletion(); \/\/ we're done, complete the subscriber under test\n-    }};\n-  }\n-\n-  @Override @Test\n-  public void untested_spec206_blackbox_mustCallSubscriptionCancelIfItIsNoLongerValid() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec207_blackbox_mustEnsureAllCallsOnItsSubscriptionTakePlaceFromTheSameThreadOrTakeCareOfSynchronization() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-    \/\/ the same thread part of the clause can be verified but that is not very useful, or is it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec208_blackbox_mustBePreparedToReceiveOnNextSignalsAfterHavingCalledSubscriptionCancel() throws Throwable {\n-    notVerified(); \/\/ cannot be meaningfully tested as black box, or can it?\n-  }\n-\n-  @Override @Test\n-  public void required_spec209_blackbox_mustBePreparedToReceiveAnOnCompleteSignalWithPrecedingRequestCall() throws Throwable {\n-    blackboxSubscriberTest(new BlackboxTestStageTestRun() {\n-      @Override @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n-      public void run(BlackboxTestStage stage) throws Throwable {\n-        triggerRequest(stage.subProxy().sub());\n-        final long notUsed = stage.expectRequest(); \/\/ received request signal\n-        stage.sub().onComplete();\n-        stage.subProxy().expectCompletion();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec209_blackbox_mustBePreparedToReceiveAnOnCompleteSignalWithoutPrecedingRequestCall() throws Throwable {\n-    blackboxSubscriberTest(new BlackboxTestStageTestRun() {\n-      @Override @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n-      public void run(BlackboxTestStage stage) throws Throwable {\n-        final Subscriber<? super T> sub = stage.sub();\n-        sub.onComplete();\n-        stage.subProxy().expectCompletion();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec210_blackbox_mustBePreparedToReceiveAnOnErrorSignalWithPrecedingRequestCall() throws Throwable {\n-    blackboxSubscriberTest(new BlackboxTestStageTestRun() {\n-      @Override @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n-      public void run(BlackboxTestStage stage) throws Throwable {\n-        triggerRequest(stage.subProxy().sub());\n-        final long notUsed = stage.expectRequest(); \/\/ received request signal\n-        stage.sub().onError(new TestException()); \/\/ in response to that, we fail\n-        stage.subProxy().expectError(Throwable.class);\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.10\n-  @Override @Test\n-  public void required_spec210_blackbox_mustBePreparedToReceiveAnOnErrorSignalWithoutPrecedingRequestCall() throws Throwable {\n-    blackboxSubscriberTest(new BlackboxTestStageTestRun() {\n-      @Override @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n-      public void run(BlackboxTestStage stage) throws Throwable {\n-\n-        stage.sub().onError(new TestException());\n-        stage.subProxy().expectError(Throwable.class);\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void untested_spec211_blackbox_mustMakeSureThatAllCallsOnItsMethodsHappenBeforeTheProcessingOfTheRespectiveEvents() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec212_blackbox_mustNotCallOnSubscribeMoreThanOnceBasedOnObjectEquality() throws Throwable {\n-    notVerified(); \/\/ cannot be meaningfully tested as black box, or can it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec213_blackbox_failingOnSignalInvocation() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void required_spec213_blackbox_onSubscribe_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {\n-    blackboxSubscriberWithoutSetupTest(new BlackboxTestStageTestRun() {\n-      @Override\n-      public void run(BlackboxTestStage stage) throws Throwable {\n-\n-        {\n-          final Subscriber<T> sub = createSubscriber();\n-          boolean gotNPE = false;\n-          try {\n-            sub.onSubscribe(null);\n-          } catch(final NullPointerException expected) {\n-            gotNPE = true;\n-          }\n-          assertTrue(gotNPE, \"onSubscribe(null) did not throw NullPointerException\");\n-        }\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec213_blackbox_onNext_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {\n-    blackboxSubscriberWithoutSetupTest(new BlackboxTestStageTestRun() {\n-      @Override\n-      public void run(BlackboxTestStage stage) throws Throwable {\n-        final Subscription subscription = new Subscription() {\n-          @Override public void request(final long elements) {}\n-          @Override public void cancel() {}\n-        };\n-\n-        {\n-          final Subscriber<T> sub = createSubscriber();\n-          boolean gotNPE = false;\n-          sub.onSubscribe(subscription);\n-          try {\n-            sub.onNext(null);\n-          } catch(final NullPointerException expected) {\n-            gotNPE = true;\n-          }\n-          assertTrue(gotNPE, \"onNext(null) did not throw NullPointerException\");\n-        }\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  @Override @Test\n-  public void required_spec213_blackbox_onError_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {\n-    blackboxSubscriberWithoutSetupTest(new BlackboxTestStageTestRun() {\n-      @Override\n-      public void run(BlackboxTestStage stage) throws Throwable {\n-        final Subscription subscription = new Subscription() {\n-          @Override public void request(final long elements) {}\n-          @Override public void cancel() {}\n-        };\n-\n-        {\n-          final Subscriber<T> sub = createSubscriber();\n-          boolean gotNPE = false;\n-          sub.onSubscribe(subscription);\n-          try {\n-            sub.onError(null);\n-          } catch(final NullPointerException expected) {\n-            gotNPE = true;\n-          }\n-          assertTrue(gotNPE, \"onError(null) did not throw NullPointerException\");\n-        }\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ SUBSCRIPTION SPEC RULE VERIFICATION \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  @Override @Test\n-  public void untested_spec301_blackbox_mustNotBeCalledOutsideSubscriberContext() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec308_blackbox_requestMustRegisterGivenNumberElementsToBeProduced() throws Throwable {\n-    notVerified(); \/\/ cannot be meaningfully tested as black box, or can it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec310_blackbox_requestMaySynchronouslyCallOnNextOnSubscriber() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec311_blackbox_requestMaySynchronouslyCallOnCompleteOrOnError() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec314_blackbox_cancelMayCauseThePublisherToShutdownIfNoOtherSubscriptionExists() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec315_blackbox_cancelMustNotThrowExceptionAndMustSignalOnError() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  @Override @Test\n-  public void untested_spec316_blackbox_requestMustNotThrowExceptionAndMustOnErrorTheSubscriber() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ ADDITIONAL \"COROLLARY\" TESTS \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ TEST INFRASTRUCTURE \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  abstract class BlackboxTestStageTestRun {\n-    public abstract void run(BlackboxTestStage stage) throws Throwable;\n-  }\n-\n-  public void blackboxSubscriberTest(BlackboxTestStageTestRun body) throws Throwable {\n-    BlackboxTestStage stage = new BlackboxTestStage(env, true);\n-    body.run(stage);\n-  }\n-\n-  public void blackboxSubscriberWithoutSetupTest(BlackboxTestStageTestRun body) throws Throwable {\n-    BlackboxTestStage stage = new BlackboxTestStage(env, false);\n-    body.run(stage);\n-  }\n-\n-  public class BlackboxTestStage extends ManualPublisher<T> {\n-    public Publisher<T> pub;\n-    public ManualSubscriber<T> tees; \/\/ gives us access to an infinite stream of T values\n-\n-    public T lastT = null;\n-    private Optional<BlackboxSubscriberProxy<T>> subProxy = Optional.empty();\n-\n-    public BlackboxTestStage(TestEnvironment env) throws InterruptedException {\n-      this(env, true);\n-    }\n-\n-    public BlackboxTestStage(TestEnvironment env, boolean runDefaultInit) throws InterruptedException {\n-      super(env);\n-      if (runDefaultInit) {\n-        pub = this.createHelperPublisher(Long.MAX_VALUE);\n-        tees = env.newManualSubscriber(pub);\n-        Subscriber<T> sub = createSubscriber();\n-        subProxy = Optional.of(createBlackboxSubscriberProxy(env, sub));\n-        subscribe(subProxy.get());\n-      }\n-    }\n-\n-    public Subscriber<? super T> sub() {\n-      return subscriber.value();\n-    }\n-\n-    \/**\n-     * Proxy for the {@link #sub()} {@code Subscriber}, providing certain assertions on methods being called on the Subscriber.\n-     *\/\n-    public BlackboxSubscriberProxy<T> subProxy() {\n-      return subProxy.get();\n-    }\n-\n-    public Publisher<T> createHelperPublisher(long elements) {\n-      return SubscriberBlackboxVerification.this.createHelperPublisher(elements);\n-    }\n-\n-    public BlackboxSubscriberProxy<T> createBlackboxSubscriberProxy(TestEnvironment env, Subscriber<T> sub) {\n-      return new BlackboxSubscriberProxy<T>(env, sub);\n-    }\n-\n-    public T signalNext() throws InterruptedException {\n-      T element = nextT();\n-      sendNext(element);\n-      return element;\n-    }\n-\n-    public T nextT() throws InterruptedException {\n-      lastT = tees.requestNextElement();\n-      return lastT;\n-    }\n-\n-  }\n-\n-  public void notVerified() {\n-    throw new SkipException(\"Not verified using this TCK.\");\n-  }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/SubscriberBlackboxVerification.java","additions":0,"deletions":516,"binary":false,"changes":516,"status":"deleted"},{"patch":"@@ -1,850 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck;\n-\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-import org.reactivestreams.tck.TestEnvironment.*;\n-import org.reactivestreams.tck.flow.support.Optional;\n-import org.reactivestreams.tck.flow.support.SubscriberWhiteboxVerificationRules;\n-import org.reactivestreams.tck.flow.support.TestException;\n-import org.testng.SkipException;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n-\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-\n-import static org.testng.Assert.assertTrue;\n-\n-\/**\n- * Provides whitebox style tests for verifying {@link org.reactivestreams.Subscriber}\n- * and {@link org.reactivestreams.Subscription} specification rules.\n- *\n- * @see org.reactivestreams.Subscriber\n- * @see org.reactivestreams.Subscription\n- *\/\n-public abstract class SubscriberWhiteboxVerification<T> extends WithHelperPublisher<T>\n-  implements SubscriberWhiteboxVerificationRules {\n-\n-  private final TestEnvironment env;\n-\n-  protected SubscriberWhiteboxVerification(TestEnvironment env) {\n-    this.env = env;\n-  }\n-\n-  \/\/ USER API\n-\n-  \/**\n-   * This is the main method you must implement in your test incarnation.\n-   * It must create a new {@link org.reactivestreams.Subscriber} instance to be subjected to the testing logic.\n-   *\n-   * In order to be meaningfully testable your Subscriber must inform the given\n-   * `WhiteboxSubscriberProbe` of the respective events having been received.\n-   *\/\n-  public abstract Subscriber<T> createSubscriber(WhiteboxSubscriberProbe<T> probe);\n-\n-  \/\/ ENV SETUP\n-\n-  \/**\n-   * Executor service used by the default provided asynchronous Publisher.\n-   * @see #createHelperPublisher(long)\n-   *\/\n-  private ExecutorService publisherExecutor;\n-  @BeforeClass public void startPublisherExecutorService() { publisherExecutor = Executors.newFixedThreadPool(4); }\n-  @AfterClass public void shutdownPublisherExecutorService() { if (publisherExecutor != null) publisherExecutor.shutdown(); }\n-  @Override public ExecutorService publisherExecutorService() { return publisherExecutor; }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ TEST ENV CLEANUP \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  @BeforeMethod\n-  public void setUp() throws Exception {\n-    env.clearAsyncErrors();\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ TEST SETUP VERIFICATION \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  @Test\n-  public void required_exerciseWhiteboxHappyPath() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws InterruptedException {\n-        stage.puppet().triggerRequest(1);\n-        stage.puppet().triggerRequest(1);\n-\n-        long receivedRequests = stage.expectRequest();\n-\n-        stage.signalNext();\n-        stage.probe.expectNext(stage.lastT);\n-\n-        stage.puppet().triggerRequest(1);\n-        if (receivedRequests == 1) {\n-          stage.expectRequest();\n-        }\n-\n-        stage.signalNext();\n-        stage.probe.expectNext(stage.lastT);\n-\n-        stage.puppet().signalCancel();\n-        stage.expectCancelling();\n-\n-        stage.verifyNoAsyncErrors();\n-      }\n-    });\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ SPEC RULE VERIFICATION \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.1\n-  @Override @Test\n-  public void required_spec201_mustSignalDemandViaSubscriptionRequest() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws InterruptedException {\n-        stage.puppet().triggerRequest(1);\n-        stage.expectRequest();\n-\n-        stage.signalNext();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.2\n-  @Override @Test\n-  public void untested_spec202_shouldAsynchronouslyDispatch() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.3\n-  @Override @Test\n-  public void required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnComplete() throws Throwable {\n-    subscriberTestWithoutSetup(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws Throwable {\n-        final Subscription subs = new Subscription() {\n-          @Override\n-          public void request(long n) {\n-            final Optional<StackTraceElement> onCompleteStackTraceElement = env.findCallerMethodInStackTrace(\"onComplete\");\n-            if (onCompleteStackTraceElement.isDefined()) {\n-              final StackTraceElement stackElem = onCompleteStackTraceElement.get();\n-              env.flop(String.format(\"Subscription::request MUST NOT be called from Subscriber::onComplete (Rule 2.3)! (Caller: %s::%s line %d)\",\n-                                     stackElem.getClassName(), stackElem.getMethodName(), stackElem.getLineNumber()));\n-            }\n-          }\n-\n-          @Override\n-          public void cancel() {\n-            final Optional<StackTraceElement> onCompleteStackElement = env.findCallerMethodInStackTrace(\"onComplete\");\n-            if (onCompleteStackElement.isDefined()) {\n-              final StackTraceElement stackElem = onCompleteStackElement.get();\n-              env.flop(String.format(\"Subscription::cancel MUST NOT be called from Subscriber::onComplete (Rule 2.3)! (Caller: %s::%s line %d)\",\n-                                     stackElem.getClassName(), stackElem.getMethodName(), stackElem.getLineNumber()));\n-            }\n-          }\n-        };\n-\n-        stage.probe = stage.createWhiteboxSubscriberProbe(env);\n-        final Subscriber<T> sub = createSubscriber(stage.probe);\n-\n-        sub.onSubscribe(subs);\n-        sub.onComplete();\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.3\n-  @Override @Test\n-  public void required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnError() throws Throwable {\n-    subscriberTestWithoutSetup(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws Throwable {\n-        final Subscription subs = new Subscription() {\n-          @Override\n-          public void request(long n) {\n-            Throwable thr = new Throwable();\n-            for (StackTraceElement stackElem : thr.getStackTrace()) {\n-              if (stackElem.getMethodName().equals(\"onError\")) {\n-                env.flop(String.format(\"Subscription::request MUST NOT be called from Subscriber::onError (Rule 2.3)! (Caller: %s::%s line %d)\",\n-                                       stackElem.getClassName(), stackElem.getMethodName(), stackElem.getLineNumber()));\n-              }\n-            }\n-          }\n-\n-          @Override\n-          public void cancel() {\n-            Throwable thr = new Throwable();\n-            for (StackTraceElement stackElem : thr.getStackTrace()) {\n-              if (stackElem.getMethodName().equals(\"onError\")) {\n-                env.flop(String.format(\"Subscription::cancel MUST NOT be called from Subscriber::onError (Rule 2.3)! (Caller: %s::%s line %d)\",\n-                                       stackElem.getClassName(), stackElem.getMethodName(), stackElem.getLineNumber()));\n-              }\n-            }\n-          }\n-        };\n-\n-        stage.probe = stage.createWhiteboxSubscriberProbe(env);\n-        final Subscriber<T> sub = createSubscriber(stage.probe);\n-\n-        sub.onSubscribe(subs);\n-        sub.onError(new TestException());\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.4\n-  @Override @Test\n-  public void untested_spec204_mustConsiderTheSubscriptionAsCancelledInAfterRecievingOnCompleteOrOnError() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.5\n-  @Override @Test\n-  public void required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws Throwable {\n-        \/\/ try to subscribe another time, if the subscriber calls `probe.registerOnSubscribe` the test will fail\n-        final Latch secondSubscriptionCancelled = new Latch(env);\n-        final Subscriber<? super T> sub = stage.sub();\n-        final Subscription subscription = new Subscription() {\n-          @Override\n-          public void request(long elements) {\n-            \/\/ ignore...\n-          }\n-\n-          @Override\n-          public void cancel() {\n-            secondSubscriptionCancelled.close();\n-          }\n-\n-          @Override\n-          public String toString() {\n-            return \"SecondSubscription(should get cancelled)\";\n-          }\n-        };\n-        sub.onSubscribe(subscription);\n-\n-        secondSubscriptionCancelled.expectClose(\"Expected 2nd Subscription given to subscriber to be cancelled, but `Subscription.cancel()` was not called\");\n-        env.verifyNoAsyncErrors();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.6\n-  @Override @Test\n-  public void untested_spec206_mustCallSubscriptionCancelIfItIsNoLongerValid() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.7\n-  @Override @Test\n-  public void untested_spec207_mustEnsureAllCallsOnItsSubscriptionTakePlaceFromTheSameThreadOrTakeCareOfSynchronization() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-    \/\/ the same thread part of the clause can be verified but that is not very useful, or is it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.8\n-  @Override @Test\n-  public void required_spec208_mustBePreparedToReceiveOnNextSignalsAfterHavingCalledSubscriptionCancel() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws InterruptedException {\n-        stage.puppet().triggerRequest(1);\n-        stage.expectRequest();\n-        stage.puppet().signalCancel();\n-        stage.expectCancelling();\n-        stage.signalNext();\n-\n-        stage.puppet().triggerRequest(1);\n-        stage.puppet().triggerRequest(1);\n-\n-        stage.verifyNoAsyncErrors();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.9\n-  @Override @Test\n-  public void required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithPrecedingRequestCall() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws InterruptedException {\n-        stage.puppet().triggerRequest(1);\n-        stage.sendCompletion();\n-        stage.probe.expectCompletion();\n-\n-        stage.verifyNoAsyncErrors();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.9\n-  @Override @Test\n-  public void required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithoutPrecedingRequestCall() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws InterruptedException {\n-        stage.sendCompletion();\n-        stage.probe.expectCompletion();\n-\n-        stage.verifyNoAsyncErrors();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.10\n-  @Override @Test\n-  public void required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithPrecedingRequestCall() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws InterruptedException {\n-        stage.puppet().triggerRequest(1);\n-        stage.puppet().triggerRequest(1);\n-\n-        Exception ex = new TestException();\n-        stage.sendError(ex);\n-        stage.probe.expectError(ex);\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.10\n-  @Override @Test\n-  public void required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithoutPrecedingRequestCall() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws InterruptedException {\n-        Exception ex = new TestException();\n-        stage.sendError(ex);\n-        stage.probe.expectError(ex);\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.11\n-  @Override @Test\n-  public void untested_spec211_mustMakeSureThatAllCallsOnItsMethodsHappenBeforeTheProcessingOfTheRespectiveEvents() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.12\n-  @Override @Test\n-  public void untested_spec212_mustNotCallOnSubscribeMoreThanOnceBasedOnObjectEquality_specViolation() throws Throwable {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.13\n-  @Override @Test\n-  public void untested_spec213_failingOnSignalInvocation() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.13\n-  @Override @Test\n-  public void required_spec213_onSubscribe_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws Throwable {\n-\n-        final Subscriber<? super T> sub = stage.sub();\n-        boolean gotNPE = false;\n-        try {\n-          sub.onSubscribe(null);\n-        } catch (final NullPointerException expected) {\n-          gotNPE = true;\n-        }\n-\n-        assertTrue(gotNPE, \"onSubscribe(null) did not throw NullPointerException\");\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.13\n-  @Override @Test\n-  public void required_spec213_onNext_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws Throwable {\n-\n-        final Subscriber<? super T> sub = stage.sub();\n-        boolean gotNPE = false;\n-        try {\n-          sub.onNext(null);\n-        } catch (final NullPointerException expected) {\n-          gotNPE = true;\n-        }\n-\n-        assertTrue(gotNPE, \"onNext(null) did not throw NullPointerException\");\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.13\n-  @Override @Test\n-  public void required_spec213_onError_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws Throwable {\n-\n-          final Subscriber<? super T> sub = stage.sub();\n-          boolean gotNPE = false;\n-          try {\n-            sub.onError(null);\n-          } catch (final NullPointerException expected) {\n-            gotNPE = true;\n-          } finally {\n-            assertTrue(gotNPE, \"onError(null) did not throw NullPointerException\");\n-          }\n-\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    });\n-  }\n-\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ SUBSCRIPTION SPEC RULE VERIFICATION \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.1\n-  @Override @Test\n-  public void untested_spec301_mustNotBeCalledOutsideSubscriberContext() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.8\n-  @Override @Test\n-  public void required_spec308_requestMustRegisterGivenNumberElementsToBeProduced() throws Throwable {\n-    subscriberTest(new TestStageTestRun() {\n-      @Override\n-      public void run(WhiteboxTestStage stage) throws InterruptedException {\n-        stage.puppet().triggerRequest(2);\n-        long requestedElements = stage.expectRequest();\n-        stage.probe.expectNext(stage.signalNext());\n-        \/\/ Some subscribers may only request one element at a time.\n-        if (requestedElements < 2) {\n-          stage.expectRequest();\n-        }\n-        stage.probe.expectNext(stage.signalNext());\n-\n-        stage.probe.expectNone();\n-        stage.puppet().triggerRequest(3);\n-\n-        stage.verifyNoAsyncErrors();\n-      }\n-    });\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.10\n-  @Override @Test\n-  public void untested_spec310_requestMaySynchronouslyCallOnNextOnSubscriber() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.11\n-  @Override @Test\n-  public void untested_spec311_requestMaySynchronouslyCallOnCompleteOrOnError() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.14\n-  @Override @Test\n-  public void untested_spec314_cancelMayCauseThePublisherToShutdownIfNoOtherSubscriptionExists() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.15\n-  @Override @Test\n-  public void untested_spec315_cancelMustNotThrowExceptionAndMustSignalOnError() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/ Verifies rule: https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.16\n-  @Override @Test\n-  public void untested_spec316_requestMustNotThrowExceptionAndMustOnErrorTheSubscriber() throws Exception {\n-    notVerified(); \/\/ cannot be meaningfully tested, or can it?\n-  }\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ ADDITIONAL \"COROLLARY\" TESTS \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ TEST INFRASTRUCTURE \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  abstract class TestStageTestRun {\n-    public abstract void run(WhiteboxTestStage stage) throws Throwable;\n-  }\n-\n-  \/**\n-   * Prepares subscriber and publisher pair (by subscribing the first to the latter),\n-   * and then hands over the tests {@link WhiteboxTestStage} over to the test.\n-   *\n-   * The test stage is, like in a puppet show, used to orchestrate what each participant should do.\n-   * Since this is a whitebox test, this allows the stage to completely control when and how to signal \/ expect signals.\n-   *\/\n-  public void subscriberTest(TestStageTestRun body) throws Throwable {\n-    WhiteboxTestStage stage = new WhiteboxTestStage(env, true);\n-    body.run(stage);\n-  }\n-\n-  \/**\n-   * Provides a {@link WhiteboxTestStage} without performing any additional setup,\n-   * like the {@link #subscriberTest(SubscriberWhiteboxVerification.TestStageTestRun)} would.\n-   *\n-   * Use this method to write tests in which you need full control over when and how the initial {@code subscribe} is signalled.\n-   *\/\n-  public void subscriberTestWithoutSetup(TestStageTestRun body) throws Throwable {\n-    WhiteboxTestStage stage = new WhiteboxTestStage(env, false);\n-    body.run(stage);\n-  }\n-\n-  \/**\n-   * Test for feature that MAY be implemented. This test will be marked as SKIPPED if it fails.\n-   *\/\n-  public void optionalSubscriberTestWithoutSetup(TestStageTestRun body) throws Throwable {\n-    try {\n-      subscriberTestWithoutSetup(body);\n-    } catch (Exception ex) {\n-      notVerified(\"Skipped because tested publisher does NOT implement this OPTIONAL requirement.\");\n-    }\n-  }\n-\n-  public class WhiteboxTestStage extends ManualPublisher<T> {\n-    public Publisher<T> pub;\n-    public ManualSubscriber<T> tees; \/\/ gives us access to a stream T values\n-    public WhiteboxSubscriberProbe<T> probe;\n-\n-    public T lastT = null;\n-\n-    public WhiteboxTestStage(TestEnvironment env) throws InterruptedException {\n-      this(env, true);\n-    }\n-\n-    public WhiteboxTestStage(TestEnvironment env, boolean runDefaultInit) throws InterruptedException {\n-      super(env);\n-      if (runDefaultInit) {\n-        pub = this.createHelperPublisher(Long.MAX_VALUE);\n-        tees = env.newManualSubscriber(pub);\n-        probe = new WhiteboxSubscriberProbe<T>(env, subscriber);\n-        subscribe(createSubscriber(probe));\n-        probe.puppet.expectCompletion(env.defaultTimeoutMillis(), String.format(\"Subscriber %s did not `registerOnSubscribe`\", sub()));\n-        env.verifyNoAsyncErrorsNoDelay();\n-      }\n-    }\n-\n-    public Subscriber<? super T> sub() {\n-      return subscriber.value();\n-    }\n-\n-    public SubscriberPuppet puppet() {\n-      return probe.puppet();\n-    }\n-\n-    public WhiteboxSubscriberProbe<T> probe() {\n-      return probe;\n-    }\n-\n-    public Publisher<T> createHelperPublisher(long elements) {\n-      return SubscriberWhiteboxVerification.this.createHelperPublisher(elements);\n-    }\n-\n-    public WhiteboxSubscriberProbe<T> createWhiteboxSubscriberProbe(TestEnvironment env) {\n-      return new WhiteboxSubscriberProbe<T>(env, subscriber);\n-    }\n-\n-    public T signalNext() throws InterruptedException {\n-      return signalNext(nextT());\n-    }\n-\n-    private T signalNext(T element) throws InterruptedException {\n-      sendNext(element);\n-      return element;\n-    }\n-\n-    public T nextT() throws InterruptedException {\n-      lastT = tees.requestNextElement();\n-      return lastT;\n-    }\n-\n-    public void verifyNoAsyncErrors() {\n-      env.verifyNoAsyncErrors();\n-    }\n-  }\n-\n-  \/**\n-   * This class is intented to be used as {@code Subscriber} decorator and should be used in {@code pub.subscriber(...)} calls,\n-   * in order to allow intercepting calls on the underlying {@code Subscriber}.\n-   * This delegation allows the proxy to implement {@link BlackboxProbe} assertions.\n-   *\/\n-  public static class BlackboxSubscriberProxy<T> extends BlackboxProbe<T> implements Subscriber<T> {\n-\n-    public BlackboxSubscriberProxy(TestEnvironment env, Subscriber<T> subscriber) {\n-      super(env, Promise.<Subscriber<? super T>>completed(env, subscriber));\n-    }\n-\n-    @Override\n-    public void onSubscribe(Subscription s) {\n-      sub().onSubscribe(s);\n-    }\n-\n-    @Override\n-    public void onNext(T t) {\n-      registerOnNext(t);\n-      sub().onNext(t);\n-    }\n-\n-    @Override\n-    public void onError(Throwable cause) {\n-      registerOnError(cause);\n-      sub().onError(cause);\n-    }\n-\n-    @Override\n-    public void onComplete() {\n-      registerOnComplete();\n-      sub().onComplete();\n-    }\n-  }\n-\n-  public static class BlackboxProbe<T> implements SubscriberProbe<T> {\n-    protected final TestEnvironment env;\n-    protected final Promise<Subscriber<? super T>> subscriber;\n-\n-    protected final Receptacle<T> elements;\n-    protected final Promise<Throwable> error;\n-\n-    public BlackboxProbe(TestEnvironment env, Promise<Subscriber<? super T>> subscriber) {\n-      this.env = env;\n-      this.subscriber = subscriber;\n-      elements = new Receptacle<T>(env);\n-      error = new Promise<Throwable>(env);\n-    }\n-\n-    @Override\n-    public void registerOnNext(T element) {\n-      elements.add(element);\n-    }\n-\n-    @Override\n-    public void registerOnComplete() {\n-      try {\n-        elements.complete();\n-      } catch (IllegalStateException ex) {\n-        \/\/ \"Queue full\", onComplete was already called\n-        env.flop(\"subscriber::onComplete was called a second time, which is illegal according to Rule 1.7\");\n-      }\n-    }\n-\n-    @Override\n-    public void registerOnError(Throwable cause) {\n-      try {\n-        error.complete(cause);\n-      } catch (IllegalStateException ex) {\n-        \/\/ \"Queue full\", onError was already called\n-        env.flop(\"subscriber::onError was called a second time, which is illegal according to Rule 1.7\");\n-      }\n-    }\n-\n-    public T expectNext() throws InterruptedException {\n-      return elements.next(env.defaultTimeoutMillis(), String.format(\"Subscriber %s did not call `registerOnNext(_)`\", sub()));\n-    }\n-\n-    public void expectNext(T expected) throws InterruptedException {\n-      expectNext(expected, env.defaultTimeoutMillis());\n-    }\n-\n-    public void expectNext(T expected, long timeoutMillis) throws InterruptedException {\n-      T received = elements.next(timeoutMillis, String.format(\"Subscriber %s did not call `registerOnNext(%s)`\", sub(), expected));\n-      if (!received.equals(expected)) {\n-        env.flop(String.format(\"Subscriber %s called `registerOnNext(%s)` rather than `registerOnNext(%s)`\", sub(), received, expected));\n-      }\n-    }\n-\n-    public Subscriber<? super T> sub() {\n-      return subscriber.value();\n-    }\n-\n-    public void expectCompletion() throws InterruptedException {\n-      expectCompletion(env.defaultTimeoutMillis());\n-    }\n-\n-    public void expectCompletion(long timeoutMillis) throws InterruptedException {\n-      expectCompletion(timeoutMillis, String.format(\"Subscriber %s did not call `registerOnComplete()`\", sub()));\n-    }\n-\n-    public void expectCompletion(long timeoutMillis, String msg) throws InterruptedException {\n-      elements.expectCompletion(timeoutMillis, msg);\n-    }\n-\n-    @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n-    public <E extends Throwable> void expectErrorWithMessage(Class<E> expected, String requiredMessagePart) throws InterruptedException {\n-      final E err = expectError(expected);\n-      String message = err.getMessage();\n-      assertTrue(message.contains(requiredMessagePart),\n-        String.format(\"Got expected exception %s but missing message [%s], was: %s\", err.getClass(), requiredMessagePart, expected));\n-    }\n-\n-    public <E extends Throwable> E expectError(Class<E> expected) throws InterruptedException {\n-      return expectError(expected, env.defaultTimeoutMillis());\n-    }\n-\n-    @SuppressWarnings({\"unchecked\", \"ThrowableResultOfMethodCallIgnored\"})\n-    public <E extends Throwable> E expectError(Class<E> expected, long timeoutMillis) throws InterruptedException {\n-      error.expectCompletion(timeoutMillis, String.format(\"Subscriber %s did not call `registerOnError(%s)`\", sub(), expected));\n-      if (error.value() == null) {\n-        return env.flopAndFail(String.format(\"Subscriber %s did not call `registerOnError(%s)`\", sub(), expected));\n-      } else if (expected.isInstance(error.value())) {\n-        return (E) error.value();\n-      } else {\n-        return env.flopAndFail(String.format(\"Subscriber %s called `registerOnError(%s)` rather than `registerOnError(%s)`\", sub(), error.value(), expected));\n-      }\n-    }\n-\n-    public void expectError(Throwable expected) throws InterruptedException {\n-      expectError(expected, env.defaultTimeoutMillis());\n-    }\n-\n-    @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n-    public void expectError(Throwable expected, long timeoutMillis) throws InterruptedException {\n-      error.expectCompletion(timeoutMillis, String.format(\"Subscriber %s did not call `registerOnError(%s)`\", sub(), expected));\n-      if (error.value() != expected) {\n-        env.flop(String.format(\"Subscriber %s called `registerOnError(%s)` rather than `registerOnError(%s)`\", sub(), error.value(), expected));\n-      }\n-    }\n-\n-    public void expectNone() throws InterruptedException {\n-      expectNone(env.defaultNoSignalsTimeoutMillis());\n-    }\n-\n-    public void expectNone(long withinMillis) throws InterruptedException {\n-      elements.expectNone(withinMillis, \"Expected nothing\");\n-    }\n-\n-  }\n-\n-  public static class WhiteboxSubscriberProbe<T> extends BlackboxProbe<T> implements SubscriberPuppeteer {\n-    protected Promise<SubscriberPuppet> puppet;\n-\n-    public WhiteboxSubscriberProbe(TestEnvironment env, Promise<Subscriber<? super T>> subscriber) {\n-      super(env, subscriber);\n-      puppet = new Promise<SubscriberPuppet>(env);\n-    }\n-\n-    private SubscriberPuppet puppet() {\n-      return puppet.value();\n-    }\n-\n-    @Override\n-    public void registerOnSubscribe(SubscriberPuppet p) {\n-      if (!puppet.isCompleted()) {\n-        puppet.complete(p);\n-      }\n-    }\n-\n-  }\n-\n-  public interface SubscriberPuppeteer {\n-\n-    \/**\n-     * Must be called by the test subscriber when it has successfully registered a subscription\n-     * inside the `onSubscribe` method.\n-     *\/\n-    void registerOnSubscribe(SubscriberPuppet puppet);\n-  }\n-\n-  public interface SubscriberProbe<T> {\n-\n-    \/**\n-     * Must be called by the test subscriber when it has received an`onNext` event.\n-     *\/\n-    void registerOnNext(T element);\n-\n-    \/**\n-     * Must be called by the test subscriber when it has received an `onComplete` event.\n-     *\/\n-    void registerOnComplete();\n-\n-    \/**\n-     * Must be called by the test subscriber when it has received an `onError` event.\n-     *\/\n-    void registerOnError(Throwable cause);\n-\n-  }\n-\n-  \/**\n-   * Implement this puppet in your Whitebox style tests.\n-   * The test suite will invoke the specific trigger\/signal methods requesting you to execute the specific action.\n-   * Since this is a whitebox style test, you're allowed and expected to use knowladge about your implementation to\n-   * make implement these calls.\n-   *\/\n-  public interface SubscriberPuppet {\n-\n-    \/**\n-     * Ensure that at least {@code elements} are eventually requested by your {@link Subscriber}, if it hasn't already\n-     * requested that many elements.\n-     * <p>\n-     * This does not necessarily have to correlate 1:1 with a {@code Subscription.request(elements)} call, but the sum\n-     * of the elements requested by your {@code Subscriber} must eventually be at least the the sum of the elements\n-     * triggered to be requested by all the invocations of this method.\n-     * <p>\n-     * Additionally, subscribers are permitted to delay requesting elements until previous requests for elements have\n-     * been fulfilled. For example, a subscriber that only requests one element at a time may fulfill the request made\n-     * by this method by requesting one element {@code elements} times, waiting for each element to arrive before the\n-     * next request is made.\n-     * <p>\n-     * Before sending any element to the subscriber, the TCK must wait for the subscriber to request that element, and\n-     * must be prepared for the subscriber to only request one element at a time, it is not enough for the TCK to\n-     * simply invoke this method before sending elements.\n-     * <p>\n-     * An invocation of {@link #signalCancel()} may be coalesced into any elements that have not yet been requested,\n-     * such that only a cancel signal is emitted.\n-     *\/\n-    void triggerRequest(long elements);\n-\n-    \/**\n-     * Trigger {@code cancel()} on your {@link Subscriber}.\n-     * <p>\n-     * An invocation of this method may be coalesced into any outstanding requests, as requested by\n-     *{@link #triggerRequest(long)}, such that only a cancel signal is emitted.\n-     *\/\n-    void signalCancel();\n-  }\n-\n-  public void notVerified() {\n-    throw new SkipException(\"Not verified using this TCK.\");\n-  }\n-\n-  public void notVerified(String msg) {\n-    throw new SkipException(msg);\n-  }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/SubscriberWhiteboxVerification.java","additions":0,"deletions":850,"binary":false,"changes":850,"status":"deleted"},{"patch":"@@ -1,1168 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck;\n-\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-import org.reactivestreams.tck.flow.support.Optional;\n-import org.reactivestreams.tck.flow.support.SubscriberBufferOverflowException;\n-\n-import java.util.Collections;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.concurrent.ArrayBlockingQueue;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n-import static java.util.concurrent.TimeUnit.MILLISECONDS;\n-import static java.util.concurrent.TimeUnit.NANOSECONDS;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n-\n-public class TestEnvironment {\n-  public static final int TEST_BUFFER_SIZE = 16;\n-\n-  private static final String DEFAULT_TIMEOUT_MILLIS_ENV = \"DEFAULT_TIMEOUT_MILLIS\";\n-  private static final long DEFAULT_TIMEOUT_MILLIS = 100;\n-\n-  private static final String DEFAULT_NO_SIGNALS_TIMEOUT_MILLIS_ENV = \"DEFAULT_NO_SIGNALS_TIMEOUT_MILLIS\";\n-  private static final String DEFAULT_POLL_TIMEOUT_MILLIS_ENV = \"DEFAULT_POLL_TIMEOUT_MILLIS_ENV\";\n-\n-  private final long defaultTimeoutMillis;\n-  private final long defaultPollTimeoutMillis;\n-  private final long defaultNoSignalsTimeoutMillis;\n-  private final boolean printlnDebug;\n-\n-  private CopyOnWriteArrayList<Throwable> asyncErrors = new CopyOnWriteArrayList<Throwable>();\n-\n-  \/**\n-   * Tests must specify the timeout for expected outcome of asynchronous\n-   * interactions. Longer timeout does not invalidate the correctness of\n-   * the implementation, but can in some cases result in longer time to\n-   * run the tests.\n-   * @param defaultTimeoutMillis default timeout to be used in all expect* methods\n-   * @param defaultNoSignalsTimeoutMillis default timeout to be used when no further signals are expected anymore\n-   * @param defaultPollTimeoutMillis default amount of time to poll for events if {@code defaultTimeoutMillis} isn't\n-    *                                preempted by an asynchronous event.\n-   * @param printlnDebug         if true, signals such as OnNext \/ Request \/ OnComplete etc will be printed to standard output,\n-   *\/\n-  public TestEnvironment(long defaultTimeoutMillis, long defaultNoSignalsTimeoutMillis, long defaultPollTimeoutMillis,\n-                         boolean printlnDebug) {\n-    this.defaultTimeoutMillis = defaultTimeoutMillis;\n-    this.defaultPollTimeoutMillis = defaultPollTimeoutMillis;\n-    this.defaultNoSignalsTimeoutMillis = defaultNoSignalsTimeoutMillis;\n-    this.printlnDebug = printlnDebug;\n-  }\n-\n-  \/**\n-   * Tests must specify the timeout for expected outcome of asynchronous\n-   * interactions. Longer timeout does not invalidate the correctness of\n-   * the implementation, but can in some cases result in longer time to\n-   * run the tests.\n-   * @param defaultTimeoutMillis default timeout to be used in all expect* methods\n-   * @param defaultNoSignalsTimeoutMillis default timeout to be used when no further signals are expected anymore\n-   * @param printlnDebug         if true, signals such as OnNext \/ Request \/ OnComplete etc will be printed to standard output,\n-   *\/\n-  public TestEnvironment(long defaultTimeoutMillis, long defaultNoSignalsTimeoutMillis, boolean printlnDebug) {\n-    this(defaultTimeoutMillis, defaultNoSignalsTimeoutMillis, defaultTimeoutMillis, printlnDebug);\n-  }\n-\n-  \/**\n-   * Tests must specify the timeout for expected outcome of asynchronous\n-   * interactions. Longer timeout does not invalidate the correctness of\n-   * the implementation, but can in some cases result in longer time to\n-   * run the tests.\n-   *\n-   * @param defaultTimeoutMillis default timeout to be used in all expect* methods\n-   * @param defaultNoSignalsTimeoutMillis default timeout to be used when no further signals are expected anymore\n-   * @param defaultPollTimeoutMillis default amount of time to poll for events if {@code defaultTimeoutMillis} isn't\n-   *                                 preempted by an asynchronous event.\n-   *\/\n-  public TestEnvironment(long defaultTimeoutMillis, long defaultNoSignalsTimeoutMillis, long defaultPollTimeoutMillis) {\n-      this(defaultTimeoutMillis, defaultNoSignalsTimeoutMillis, defaultPollTimeoutMillis, false);\n-  }\n-\n-  \/**\n-   * Tests must specify the timeout for expected outcome of asynchronous\n-   * interactions. Longer timeout does not invalidate the correctness of\n-   * the implementation, but can in some cases result in longer time to\n-   * run the tests.\n-   *\n-   * @param defaultTimeoutMillis default timeout to be used in all expect* methods\n-   * @param defaultNoSignalsTimeoutMillis default timeout to be used when no further signals are expected anymore\n-   *\/\n-  public TestEnvironment(long defaultTimeoutMillis, long defaultNoSignalsTimeoutMillis) {\n-    this(defaultTimeoutMillis, defaultTimeoutMillis, defaultNoSignalsTimeoutMillis);\n-  }\n-\n-  \/**\n-   * Tests must specify the timeout for expected outcome of asynchronous\n-   * interactions. Longer timeout does not invalidate the correctness of\n-   * the implementation, but can in some cases result in longer time to\n-   * run the tests.\n-   *\n-   * @param defaultTimeoutMillis default timeout to be used in all expect* methods\n-   *\/\n-  public TestEnvironment(long defaultTimeoutMillis) {\n-    this(defaultTimeoutMillis, defaultTimeoutMillis, defaultTimeoutMillis);\n-  }\n-\n-  \/**\n-   * Tests must specify the timeout for expected outcome of asynchronous\n-   * interactions. Longer timeout does not invalidate the correctness of\n-   * the implementation, but can in some cases result in longer time to\n-   * run the tests.\n-   *\n-   * The default timeout for all expect* methods will be obtained by either the env variable {@code DEFAULT_TIMEOUT_MILLIS}\n-   * or the default value ({@link TestEnvironment#DEFAULT_TIMEOUT_MILLIS}) will be used.\n-   *\n-   * @param printlnDebug if true, signals such as OnNext \/ Request \/ OnComplete etc will be printed to standard output,\n-   *                     often helpful to pinpoint simple race conditions etc.\n-   *\/\n-  public TestEnvironment(boolean printlnDebug) {\n-    this(envDefaultTimeoutMillis(), envDefaultNoSignalsTimeoutMillis(), envDefaultPollTimeoutMillis(), printlnDebug);\n-  }\n-\n-  \/**\n-   * Tests must specify the timeout for expected outcome of asynchronous\n-   * interactions. Longer timeout does not invalidate the correctness of\n-   * the implementation, but can in some cases result in longer time to\n-   * run the tests.\n-   *\n-   * The default timeout for all expect* methods will be obtained by either the env variable {@code DEFAULT_TIMEOUT_MILLIS}\n-   * or the default value ({@link TestEnvironment#DEFAULT_TIMEOUT_MILLIS}) will be used.\n-   *\/\n-  public TestEnvironment() {\n-    this(envDefaultTimeoutMillis(), envDefaultNoSignalsTimeoutMillis());\n-  }\n-\n-  \/** This timeout is used when waiting for a signal to arrive. *\/\n-  public long defaultTimeoutMillis() {\n-    return defaultTimeoutMillis;\n-  }\n-\n-  \/**\n-   * This timeout is used when asserting that no further signals are emitted.\n-   * Note that this timeout default\n-   *\/\n-  public long defaultNoSignalsTimeoutMillis() {\n-    return defaultNoSignalsTimeoutMillis;\n-  }\n-\n-  \/**\n-   * The default amount of time to poll for events if {@code defaultTimeoutMillis} isn't preempted by an asynchronous\n-   * event.\n-   *\/\n-  public long defaultPollTimeoutMillis() {\n-    return defaultPollTimeoutMillis;\n-  }\n-\n-  \/**\n-   * Tries to parse the env variable {@code DEFAULT_TIMEOUT_MILLIS} as long and returns the value if present OR its default value.\n-   *\n-   * @throws java.lang.IllegalArgumentException when unable to parse the env variable\n-   *\/\n-  public static long envDefaultTimeoutMillis() {\n-    final String envMillis = System.getenv(DEFAULT_TIMEOUT_MILLIS_ENV);\n-    if (envMillis == null) return DEFAULT_TIMEOUT_MILLIS;\n-    else try {\n-      return Long.parseLong(envMillis);\n-    } catch (NumberFormatException ex) {\n-      throw new IllegalArgumentException(String.format(\"Unable to parse %s env value [%s] as long!\", DEFAULT_TIMEOUT_MILLIS_ENV, envMillis), ex);\n-    }\n-  }\n-\n-  \/**\n-   * Tries to parse the env variable {@code DEFAULT_NO_SIGNALS_TIMEOUT_MILLIS} as long and returns the value if present OR its default value.\n-   *\n-   * @throws java.lang.IllegalArgumentException when unable to parse the env variable\n-   *\/\n-  public static long envDefaultNoSignalsTimeoutMillis() {\n-    final String envMillis = System.getenv(DEFAULT_NO_SIGNALS_TIMEOUT_MILLIS_ENV);\n-    if (envMillis == null) return envDefaultTimeoutMillis();\n-    else try {\n-      return Long.parseLong(envMillis);\n-    } catch (NumberFormatException ex) {\n-      throw new IllegalArgumentException(String.format(\"Unable to parse %s env value [%s] as long!\", DEFAULT_NO_SIGNALS_TIMEOUT_MILLIS_ENV, envMillis), ex);\n-    }\n-  }\n-\n-  \/**\n-   * Tries to parse the env variable {@code DEFAULT_POLL_TIMEOUT_MILLIS_ENV} as long and returns the value if present OR its default value.\n-   *\n-   * @throws java.lang.IllegalArgumentException when unable to parse the env variable\n-   *\/\n-  public static long envDefaultPollTimeoutMillis() {\n-    final String envMillis = System.getenv(DEFAULT_POLL_TIMEOUT_MILLIS_ENV);\n-    if (envMillis == null) return envDefaultTimeoutMillis();\n-    else try {\n-      return Long.parseLong(envMillis);\n-    } catch (NumberFormatException ex) {\n-      throw new IllegalArgumentException(String.format(\"Unable to parse %s env value [%s] as long!\", DEFAULT_POLL_TIMEOUT_MILLIS_ENV, envMillis), ex);\n-    }\n-  }\n-\n-  \/**\n-   * To flop means to \"fail asynchronously\", either by onErroring or by failing some TCK check triggered asynchronously.\n-   * This method does *NOT* fail the test - it's up to inspections of the error to fail the test if required.\n-   *\n-   * Use {@code env.verifyNoAsyncErrorsNoDelay()} at the end of your TCK tests to verify there no flops called during it's execution.\n-   * To check investigate asyncErrors more closely you can use {@code expectError} methods or collect the error directly\n-   * from the environment using {@code env.dropAsyncError()}.\n-   *\n-   * To clear asyncErrors you can call {@link org.reactivestreams.tck.TestEnvironment#clearAsyncErrors()}\n-   *\/\n-  public void flop(String msg) {\n-    try {\n-      fail(msg);\n-    } catch (Throwable t) {\n-      asyncErrors.add(t);\n-    }\n-  }\n-\n-  \/**\n-   * To flop means to \"fail asynchronously\", either by onErroring or by failing some TCK check triggered asynchronously.\n-   * This method does *NOT* fail the test - it's up to inspections of the error to fail the test if required.\n-   *\n-   * This overload keeps the passed in throwable as the asyncError, instead of creating an AssertionError for this.\n-   *\n-   * Use {@code env.verifyNoAsyncErrorsNoDelay()} at the end of your TCK tests to verify there no flops called during it's execution.\n-   * To check investigate asyncErrors more closely you can use {@code expectError} methods or collect the error directly\n-   * from the environment using {@code env.dropAsyncError()}.\n-   *\n-   * To clear asyncErrors you can call {@link org.reactivestreams.tck.TestEnvironment#clearAsyncErrors()}\n-   *\/\n-  public void flop(Throwable thr, String msg) {\n-    try {\n-      fail(msg, thr);\n-    } catch (Throwable t) {\n-      asyncErrors.add(thr);\n-    }\n-  }\n-\n-  \/**\n-   * To flop means to \"fail asynchronously\", either by onErroring or by failing some TCK check triggered asynchronously.\n-   * This method does *NOT* fail the test - it's up to inspections of the error to fail the test if required.\n-   *\n-   * This overload keeps the passed in throwable as the asyncError, instead of creating an AssertionError for this.\n-   *\n-   * Use {@code env.verifyNoAsyncErrorsNoDelay()} at the end of your TCK tests to verify there no flops called during it's execution.\n-   * To check investigate asyncErrors more closely you can use {@code expectError} methods or collect the error directly\n-   * from the environment using {@code env.dropAsyncError()}.\n-   *\n-   * To clear asyncErrors you can call {@link org.reactivestreams.tck.TestEnvironment#clearAsyncErrors()}\n-   *\/\n-  public void flop(Throwable thr) {\n-    try {\n-      fail(thr.getMessage(), thr);\n-    } catch (Throwable t) {\n-      asyncErrors.add(thr);\n-    }\n-  }\n-\n-  \/**\n-   * To flop means to \"fail asynchronously\", either by onErroring or by failing some TCK check triggered asynchronously.\n-   *\n-   * This method DOES fail the test right away (it tries to, by throwing an AssertionException),\n-   * in such it is different from {@link org.reactivestreams.tck.TestEnvironment#flop} which only records the error.\n-   *\n-   * Use {@code env.verifyNoAsyncErrorsNoDelay()} at the end of your TCK tests to verify there no flops called during it's execution.\n-   * To check investigate asyncErrors more closely you can use {@code expectError} methods or collect the error directly\n-   * from the environment using {@code env.dropAsyncError()}.\n-   *\n-   * To clear asyncErrors you can call {@link org.reactivestreams.tck.TestEnvironment#clearAsyncErrors()}\n-   *\/\n-  public <T> T flopAndFail(String msg) {\n-    try {\n-      fail(msg);\n-    } catch (Throwable t) {\n-      asyncErrors.add(t);\n-      fail(msg, t);\n-    }\n-    return null; \/\/ unreachable, the previous block will always exit by throwing\n-  }\n-\n-\n-\n-  public <T> void subscribe(Publisher<T> pub, TestSubscriber<T> sub) throws InterruptedException {\n-    subscribe(pub, sub, defaultTimeoutMillis);\n-  }\n-\n-  public <T> void subscribe(Publisher<T> pub, TestSubscriber<T> sub, long timeoutMillis) throws InterruptedException {\n-    pub.subscribe(sub);\n-    sub.subscription.expectCompletion(timeoutMillis, String.format(\"Could not subscribe %s to Publisher %s\", sub, pub));\n-    verifyNoAsyncErrorsNoDelay();\n-  }\n-\n-  public <T> ManualSubscriber<T> newBlackholeSubscriber(Publisher<T> pub) throws InterruptedException {\n-    ManualSubscriberWithSubscriptionSupport<T> sub = new BlackholeSubscriberWithSubscriptionSupport<T>(this);\n-    subscribe(pub, sub, defaultTimeoutMillis());\n-    return sub;\n-  }\n-\n-  public <T> ManualSubscriber<T> newManualSubscriber(Publisher<T> pub) throws InterruptedException {\n-    return newManualSubscriber(pub, defaultTimeoutMillis());\n-  }\n-\n-  public <T> ManualSubscriber<T> newManualSubscriber(Publisher<T> pub, long timeoutMillis) throws InterruptedException {\n-    ManualSubscriberWithSubscriptionSupport<T> sub = new ManualSubscriberWithSubscriptionSupport<T>(this);\n-    subscribe(pub, sub, timeoutMillis);\n-    return sub;\n-  }\n-\n-  public void clearAsyncErrors() {\n-    asyncErrors.clear();\n-  }\n-\n-  public Throwable dropAsyncError() {\n-    try {\n-      return asyncErrors.remove(0);\n-    } catch (IndexOutOfBoundsException ex) {\n-      return null;\n-    }\n-  }\n-\n-  \/**\n-   * Waits for {@link TestEnvironment#defaultNoSignalsTimeoutMillis()} and then verifies that no asynchronous errors\n-   * were signalled pior to, or during that time (by calling {@code flop()}).\n-   *\/\n-  public void verifyNoAsyncErrors() {\n-    verifyNoAsyncErrors(defaultNoSignalsTimeoutMillis());\n-  }\n-\n-  \/**\n-   * This version of {@code verifyNoAsyncErrors} should be used when errors still could be signalled\n-   * asynchronously during {@link TestEnvironment#defaultTimeoutMillis()} time.\n-   * <p><\/p>\n-   * It will immediatly check if any async errors were signaled (using {@link TestEnvironment#flop(String)},\n-   * and if no errors encountered wait for another default timeout as the errors may yet be signalled.\n-   * The initial check is performed in order to fail-fast in case of an already failed test.\n-   *\/\n-  public void verifyNoAsyncErrors(long delay) {\n-    try {\n-      verifyNoAsyncErrorsNoDelay();\n-\n-      Thread.sleep(delay);\n-      verifyNoAsyncErrorsNoDelay();\n-    } catch (InterruptedException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n-\n-  \/**\n-   * Verifies that no asynchronous errors were signalled pior to calling this method (by calling {@code flop()}).\n-   * This version of verifyNoAsyncError <b>does not wait before checking for asynchronous errors<\/b>, and is to be used\n-   * for example in tight loops etc.\n-   *\/\n-  public void verifyNoAsyncErrorsNoDelay() {\n-    for (Throwable e : asyncErrors) {\n-      if (e instanceof AssertionError) {\n-        throw (AssertionError) e;\n-      } else {\n-        fail(String.format(\"Async error during test execution: %s\", e.getMessage()), e);\n-      }\n-    }\n-  }\n-\n-  \/** If {@code TestEnvironment#printlnDebug} is true, print debug message to std out. *\/\n-  public void debug(String msg) {\n-    if (debugEnabled()) {\n-      System.out.printf(\"[TCK-DEBUG] %s%n\", msg);\n-    }\n-  }\n-\n-  public final boolean debugEnabled() {\n-    return printlnDebug;\n-  }\n-\n-  \/**\n-   * Looks for given {@code method} method in stack trace.\n-   * Can be used to answer questions like \"was this method called from onComplete?\".\n-   *\n-   * @return the caller's StackTraceElement at which he the looked for method was found in the call stack, EMPTY otherwise\n-   *\/\n-  public Optional<StackTraceElement> findCallerMethodInStackTrace(String method) {\n-    final Throwable thr = new Throwable(); \/\/ gets the stacktrace\n-\n-    for (StackTraceElement stackElement : thr.getStackTrace()) {\n-      if (stackElement.getMethodName().equals(method)) {\n-        return Optional.of(stackElement);\n-      }\n-    }\n-    return Optional.empty();\n-  }\n-\n-  \/\/ ---- classes ----\n-\n-  \/**\n-   * {@link Subscriber} implementation which can be steered by test code and asserted on.\n-   *\/\n-  public static class ManualSubscriber<T> extends TestSubscriber<T> {\n-    Receptacle<T> received;\n-\n-    public ManualSubscriber(TestEnvironment env) {\n-      super(env);\n-      received = new Receptacle<T>(this.env);\n-    }\n-\n-    @Override\n-    public void onNext(T element) {\n-      try {\n-        received.add(element);\n-      } catch (IllegalStateException ex) {\n-          \/\/ error message refinement\n-          throw new SubscriberBufferOverflowException(\n-            String.format(\"Received more than bufferSize (%d) onNext signals. \" +\n-                            \"The Publisher probably emited more signals than expected!\",\n-                          received.QUEUE_SIZE), ex);\n-      }\n-    }\n-\n-    @Override\n-    public void onComplete() {\n-      received.complete();\n-    }\n-\n-    public void request(long elements) {\n-      subscription.value().request(elements);\n-    }\n-\n-    public T requestNextElement() throws InterruptedException {\n-      return requestNextElement(env.defaultTimeoutMillis());\n-    }\n-\n-    public T requestNextElement(long timeoutMillis) throws InterruptedException {\n-      return requestNextElement(timeoutMillis, \"Did not receive expected element\");\n-    }\n-\n-    public T requestNextElement(String errorMsg) throws InterruptedException {\n-      return requestNextElement(env.defaultTimeoutMillis(), errorMsg);\n-    }\n-\n-    public T requestNextElement(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      request(1);\n-      return nextElement(timeoutMillis, errorMsg);\n-    }\n-\n-    public Optional<T> requestNextElementOrEndOfStream() throws InterruptedException {\n-      return requestNextElementOrEndOfStream(env.defaultTimeoutMillis(), \"Did not receive expected stream completion\");\n-    }\n-\n-    public Optional<T> requestNextElementOrEndOfStream(String errorMsg) throws InterruptedException {\n-      return requestNextElementOrEndOfStream(env.defaultTimeoutMillis(), errorMsg);\n-    }\n-\n-    public Optional<T> requestNextElementOrEndOfStream(long timeoutMillis) throws InterruptedException {\n-      return requestNextElementOrEndOfStream(timeoutMillis, \"Did not receive expected stream completion\");\n-    }\n-\n-    public Optional<T> requestNextElementOrEndOfStream(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      request(1);\n-      return nextElementOrEndOfStream(timeoutMillis, errorMsg);\n-    }\n-\n-    public void requestEndOfStream() throws InterruptedException {\n-      requestEndOfStream(env.defaultTimeoutMillis(), \"Did not receive expected stream completion\");\n-    }\n-\n-    public void requestEndOfStream(long timeoutMillis) throws InterruptedException {\n-      requestEndOfStream(timeoutMillis, \"Did not receive expected stream completion\");\n-    }\n-\n-    public void requestEndOfStream(String errorMsg) throws InterruptedException {\n-      requestEndOfStream(env.defaultTimeoutMillis(), errorMsg);\n-    }\n-\n-    public void requestEndOfStream(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      request(1);\n-      expectCompletion(timeoutMillis, errorMsg);\n-    }\n-\n-    public List<T> requestNextElements(long elements) throws InterruptedException {\n-      request(elements);\n-      return nextElements(elements, env.defaultTimeoutMillis());\n-    }\n-\n-    public List<T> requestNextElements(long elements, long timeoutMillis) throws InterruptedException {\n-      request(elements);\n-      return nextElements(elements, timeoutMillis, String.format(\"Did not receive %d expected elements\", elements));\n-    }\n-\n-    public List<T> requestNextElements(long elements, long timeoutMillis, String errorMsg) throws InterruptedException {\n-      request(elements);\n-      return nextElements(elements, timeoutMillis, errorMsg);\n-    }\n-\n-    public T nextElement() throws InterruptedException {\n-      return nextElement(env.defaultTimeoutMillis());\n-    }\n-\n-    public T nextElement(long timeoutMillis) throws InterruptedException {\n-      return nextElement(timeoutMillis, \"Did not receive expected element\");\n-    }\n-\n-    public T nextElement(String errorMsg) throws InterruptedException {\n-      return nextElement(env.defaultTimeoutMillis(), errorMsg);\n-    }\n-\n-    public T nextElement(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      return received.next(timeoutMillis, errorMsg);\n-    }\n-\n-    public Optional<T> nextElementOrEndOfStream() throws InterruptedException {\n-      return nextElementOrEndOfStream(env.defaultTimeoutMillis(), \"Did not receive expected stream completion\");\n-    }\n-\n-    public Optional<T> nextElementOrEndOfStream(long timeoutMillis) throws InterruptedException {\n-      return nextElementOrEndOfStream(timeoutMillis, \"Did not receive expected stream completion\");\n-    }\n-\n-    public Optional<T> nextElementOrEndOfStream(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      return received.nextOrEndOfStream(timeoutMillis, errorMsg);\n-    }\n-\n-    public List<T> nextElements(long elements) throws InterruptedException {\n-      return nextElements(elements, env.defaultTimeoutMillis(), \"Did not receive expected element or completion\");\n-    }\n-\n-    public List<T> nextElements(long elements, String errorMsg) throws InterruptedException {\n-      return nextElements(elements, env.defaultTimeoutMillis(), errorMsg);\n-    }\n-\n-    public List<T> nextElements(long elements, long timeoutMillis) throws InterruptedException {\n-      return nextElements(elements, timeoutMillis, \"Did not receive expected element or completion\");\n-    }\n-\n-    public List<T> nextElements(long elements, long timeoutMillis, String errorMsg) throws InterruptedException {\n-      return received.nextN(elements, timeoutMillis, errorMsg);\n-    }\n-\n-    public void expectNext(T expected) throws InterruptedException {\n-      expectNext(expected, env.defaultTimeoutMillis());\n-    }\n-\n-    public void expectNext(T expected, long timeoutMillis) throws InterruptedException {\n-      T received = nextElement(timeoutMillis, \"Did not receive expected element on downstream\");\n-      if (!received.equals(expected)) {\n-        env.flop(String.format(\"Expected element %s on downstream but received %s\", expected, received));\n-      }\n-    }\n-\n-    public void expectCompletion() throws InterruptedException {\n-      expectCompletion(env.defaultTimeoutMillis(), \"Did not receive expected stream completion\");\n-    }\n-\n-    public void expectCompletion(long timeoutMillis) throws InterruptedException {\n-      expectCompletion(timeoutMillis, \"Did not receive expected stream completion\");\n-    }\n-\n-    public void expectCompletion(String errorMsg) throws InterruptedException {\n-      expectCompletion(env.defaultTimeoutMillis(), errorMsg);\n-    }\n-\n-    public void expectCompletion(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      received.expectCompletion(timeoutMillis, errorMsg);\n-    }\n-\n-    public <E extends Throwable> void expectErrorWithMessage(Class<E> expected, String requiredMessagePart) throws Exception {\n-      expectErrorWithMessage(expected, Collections.singletonList(requiredMessagePart), env.defaultTimeoutMillis(), env.defaultPollTimeoutMillis());\n-    }\n-    public <E extends Throwable> void expectErrorWithMessage(Class<E> expected, List<String> requiredMessagePartAlternatives) throws Exception {\n-      expectErrorWithMessage(expected, requiredMessagePartAlternatives, env.defaultTimeoutMillis(), env.defaultPollTimeoutMillis());\n-    }\n-\n-    @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n-    public <E extends Throwable> void expectErrorWithMessage(Class<E> expected, String requiredMessagePart, long timeoutMillis) throws Exception {\n-      expectErrorWithMessage(expected, Collections.singletonList(requiredMessagePart), timeoutMillis);\n-    }\n-\n-    public <E extends Throwable> void expectErrorWithMessage(Class<E> expected, List<String> requiredMessagePartAlternatives, long timeoutMillis) throws Exception {\n-      expectErrorWithMessage(expected, requiredMessagePartAlternatives, timeoutMillis, timeoutMillis);\n-    }\n-\n-    public <E extends Throwable> void expectErrorWithMessage(Class<E> expected, List<String> requiredMessagePartAlternatives,\n-                                                             long totalTimeoutMillis, long pollTimeoutMillis) throws Exception {\n-      final E err = expectError(expected, totalTimeoutMillis, pollTimeoutMillis);\n-      final String message = err.getMessage();\n-\n-      boolean contains = false;\n-      for (String requiredMessagePart : requiredMessagePartAlternatives)\n-        if (message.contains(requiredMessagePart)) contains = true; \/\/ not short-circuting loop, it is expected to\n-      assertTrue(contains,\n-              String.format(\"Got expected exception [%s] but missing message part [%s], was: %s\",\n-                      err.getClass(), \"anyOf: \" + requiredMessagePartAlternatives, err.getMessage()));\n-    }\n-\n-    public <E extends Throwable> E expectError(Class<E> expected) throws Exception {\n-      return expectError(expected, env.defaultTimeoutMillis());\n-    }\n-\n-    public <E extends Throwable> E expectError(Class<E> expected, long timeoutMillis) throws Exception {\n-      return expectError(expected, timeoutMillis, env.defaultPollTimeoutMillis());\n-    }\n-\n-    public <E extends Throwable> E expectError(Class<E> expected, String errorMsg) throws Exception {\n-      return expectError(expected, env.defaultTimeoutMillis(), errorMsg);\n-    }\n-\n-    public <E extends Throwable> E expectError(Class<E> expected, long timeoutMillis, String errorMsg) throws Exception {\n-      return expectError(expected, timeoutMillis, env.defaultPollTimeoutMillis(), errorMsg);\n-    }\n-\n-    public <E extends Throwable> E expectError(Class<E> expected, long totalTimeoutMillis, long pollTimeoutMillis) throws Exception {\n-      return expectError(expected, totalTimeoutMillis, pollTimeoutMillis, String.format(\"Expected onError(%s)\", expected.getName()));\n-    }\n-\n-    public <E extends Throwable> E expectError(Class<E> expected, long totalTimeoutMillis, long pollTimeoutMillis,\n-                                               String errorMsg) throws Exception {\n-      return received.expectError(expected, totalTimeoutMillis, pollTimeoutMillis, errorMsg);\n-    }\n-\n-    public void expectNone() throws InterruptedException {\n-      expectNone(env.defaultNoSignalsTimeoutMillis());\n-    }\n-\n-    public void expectNone(String errMsgPrefix) throws InterruptedException {\n-      expectNone(env.defaultNoSignalsTimeoutMillis(), errMsgPrefix);\n-    }\n-\n-    public void expectNone(long withinMillis) throws InterruptedException {\n-      expectNone(withinMillis, \"Did not expect an element but got element\");\n-    }\n-\n-    public void expectNone(long withinMillis, String errMsgPrefix) throws InterruptedException {\n-      received.expectNone(withinMillis, errMsgPrefix);\n-    }\n-\n-  }\n-\n-  public static class ManualSubscriberWithSubscriptionSupport<T> extends ManualSubscriber<T> {\n-\n-    public ManualSubscriberWithSubscriptionSupport(TestEnvironment env) {\n-      super(env);\n-    }\n-\n-    @Override\n-    public void onNext(T element) {\n-      if (env.debugEnabled()) {\n-        env.debug(String.format(\"%s::onNext(%s)\", this, element));\n-      }\n-      if (subscription.isCompleted()) {\n-        super.onNext(element);\n-      } else {\n-        env.flop(String.format(\"Subscriber::onNext(%s) called before Subscriber::onSubscribe\", element));\n-      }\n-    }\n-\n-    @Override\n-    public void onComplete() {\n-      if (env.debugEnabled()) {\n-        env.debug(this + \"::onComplete()\");\n-      }\n-      if (subscription.isCompleted()) {\n-        super.onComplete();\n-      } else {\n-        env.flop(\"Subscriber::onComplete() called before Subscriber::onSubscribe\");\n-      }\n-    }\n-\n-    @Override\n-    public void onSubscribe(Subscription s) {\n-      if (env.debugEnabled()) {\n-        env.debug(String.format(\"%s::onSubscribe(%s)\", this, s));\n-      }\n-      if (!subscription.isCompleted()) {\n-        subscription.complete(s);\n-      } else {\n-        env.flop(\"Subscriber::onSubscribe called on an already-subscribed Subscriber\");\n-      }\n-    }\n-\n-    @Override\n-    public void onError(Throwable cause) {\n-      if (env.debugEnabled()) {\n-        env.debug(String.format(\"%s::onError(%s)\", this, cause));\n-      }\n-      if (subscription.isCompleted()) {\n-        super.onError(cause);\n-      } else {\n-        env.flop(cause, String.format(\"Subscriber::onError(%s) called before Subscriber::onSubscribe\", cause));\n-      }\n-    }\n-  }\n-\n-  \/**\n-   * Similar to {@link org.reactivestreams.tck.TestEnvironment.ManualSubscriberWithSubscriptionSupport}\n-   * but does not accumulate values signalled via <code>onNext<\/code>, thus it can not be used to assert\n-   * values signalled to this subscriber. Instead it may be used to quickly drain a given publisher.\n-   *\/\n-  public static class BlackholeSubscriberWithSubscriptionSupport<T>\n-    extends ManualSubscriberWithSubscriptionSupport<T> {\n-\n-    public BlackholeSubscriberWithSubscriptionSupport(TestEnvironment env) {\n-      super(env);\n-    }\n-\n-    @Override\n-    public void onNext(T element) {\n-      if (env.debugEnabled()) {\n-        env.debug(String.format(\"%s::onNext(%s)\", this, element));\n-      }\n-      if (!subscription.isCompleted()) {\n-        env.flop(String.format(\"Subscriber::onNext(%s) called before Subscriber::onSubscribe\", element));\n-      }\n-    }\n-\n-    @Override\n-    public T nextElement(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      throw new RuntimeException(\"Can not expect elements from BlackholeSubscriber, use ManualSubscriber instead!\");\n-    }\n-\n-    @Override\n-    public List<T> nextElements(long elements, long timeoutMillis, String errorMsg) throws InterruptedException {\n-      throw new RuntimeException(\"Can not expect elements from BlackholeSubscriber, use ManualSubscriber instead!\");\n-    }\n-  }\n-\n-  public static class TestSubscriber<T> implements Subscriber<T> {\n-    final Promise<Subscription> subscription;\n-\n-    protected final TestEnvironment env;\n-\n-    public TestSubscriber(TestEnvironment env) {\n-      this.env = env;\n-      subscription = new Promise<Subscription>(env);\n-    }\n-\n-    @Override\n-    public void onError(Throwable cause) {\n-      env.flop(cause, String.format(\"Unexpected Subscriber::onError(%s)\", cause));\n-    }\n-\n-    @Override\n-    public void onComplete() {\n-      env.flop(\"Unexpected Subscriber::onComplete()\");\n-    }\n-\n-    @Override\n-    public void onNext(T element) {\n-      env.flop(String.format(\"Unexpected Subscriber::onNext(%s)\", element));\n-    }\n-\n-    @Override\n-    public void onSubscribe(Subscription subscription) {\n-      env.flop(String.format(\"Unexpected Subscriber::onSubscribe(%s)\", subscription));\n-    }\n-\n-    public void cancel() {\n-      if (subscription.isCompleted()) {\n-        subscription.value().cancel();\n-      } else {\n-        env.flop(\"Cannot cancel a subscription before having received it\");\n-      }\n-    }\n-  }\n-\n-  public static class ManualPublisher<T> implements Publisher<T> {\n-    protected final TestEnvironment env;\n-\n-    protected long pendingDemand = 0L;\n-    protected Promise<Subscriber<? super T>> subscriber;\n-\n-    protected final Receptacle<Long> requests;\n-\n-    protected final Latch cancelled;\n-\n-    public ManualPublisher(TestEnvironment env) {\n-      this.env = env;\n-      requests = new Receptacle<Long>(env);\n-      cancelled = new Latch(env);\n-      subscriber = new Promise<Subscriber<? super T>>(this.env);\n-    }\n-\n-    @Override\n-    public void subscribe(Subscriber<? super T> s) {\n-      if (!subscriber.isCompleted()) {\n-        subscriber.completeImmediatly(s);\n-\n-        Subscription subs = new Subscription() {\n-          @Override\n-          public void request(long elements) {\n-            requests.add(elements);\n-          }\n-\n-          @Override\n-          public void cancel() {\n-            cancelled.close();\n-          }\n-        };\n-        s.onSubscribe(subs);\n-\n-      } else {\n-        env.flop(\"TestPublisher doesn't support more than one Subscriber\");\n-      }\n-    }\n-\n-    public void sendNext(T element) {\n-      if (subscriber.isCompleted()) {\n-        subscriber.value().onNext(element);\n-      } else {\n-        env.flop(\"Cannot sendNext before having a Subscriber\");\n-      }\n-    }\n-\n-    public void sendCompletion() {\n-      if (subscriber.isCompleted()) {\n-        subscriber.value().onComplete();\n-      } else {\n-        env.flop(\"Cannot sendCompletion before having a Subscriber\");\n-      }\n-    }\n-\n-    public void sendError(Throwable cause) {\n-      if (subscriber.isCompleted()) {\n-        subscriber.value().onError(cause);\n-      } else {\n-        env.flop(\"Cannot sendError before having a Subscriber\");\n-      }\n-    }\n-\n-    public long expectRequest() throws InterruptedException {\n-      return expectRequest(env.defaultTimeoutMillis());\n-    }\n-\n-    public long expectRequest(long timeoutMillis) throws InterruptedException {\n-      long requested = requests.next(timeoutMillis, \"Did not receive expected `request` call\");\n-      if (requested <= 0) {\n-        return env.<Long>flopAndFail(String.format(\"Requests cannot be zero or negative but received request(%s)\", requested));\n-      } else {\n-        pendingDemand += requested;\n-        return requested;\n-      }\n-    }\n-\n-\n-    public long expectRequest(long timeoutMillis, String errorMessageAddendum) throws InterruptedException {\n-      long requested = requests.next(timeoutMillis, String.format(\"Did not receive expected `request` call. %s\", errorMessageAddendum));\n-      if (requested <= 0) {\n-        return env.<Long>flopAndFail(String.format(\"Requests cannot be zero or negative but received request(%s)\", requested));\n-      } else {\n-        pendingDemand += requested;\n-        return requested;\n-      }\n-    }\n-\n-    public void expectExactRequest(long expected) throws InterruptedException {\n-      expectExactRequest(expected, env.defaultTimeoutMillis());\n-    }\n-\n-    public void expectExactRequest(long expected, long timeoutMillis) throws InterruptedException {\n-      long requested = expectRequest(timeoutMillis);\n-      if (requested != expected) {\n-        env.flop(String.format(\"Received `request(%d)` on upstream but expected `request(%d)`\", requested, expected));\n-      }\n-      pendingDemand += requested;\n-    }\n-\n-    public void expectNoRequest() throws InterruptedException {\n-      expectNoRequest(env.defaultTimeoutMillis());\n-    }\n-\n-    public void expectNoRequest(long timeoutMillis) throws InterruptedException {\n-      requests.expectNone(timeoutMillis, \"Received an unexpected call to: request: \");\n-    }\n-\n-    public void expectCancelling() throws InterruptedException {\n-      expectCancelling(env.defaultTimeoutMillis());\n-    }\n-\n-    public void expectCancelling(long timeoutMillis) throws InterruptedException {\n-      cancelled.expectClose(timeoutMillis, \"Did not receive expected cancelling of upstream subscription\");\n-    }\n-\n-    public boolean isCancelled() throws InterruptedException {\n-      return cancelled.isClosed();\n-    }\n-  }\n-\n-  \/**\n-   * Like a CountDownLatch, but resettable and with some convenience methods\n-   *\/\n-  public static class Latch {\n-    private final TestEnvironment env;\n-    volatile private CountDownLatch countDownLatch = new CountDownLatch(1);\n-\n-    public Latch(TestEnvironment env) {\n-      this.env = env;\n-    }\n-\n-    public void reOpen() {\n-      countDownLatch = new CountDownLatch(1);\n-    }\n-\n-    public boolean isClosed() {\n-      return countDownLatch.getCount() == 0;\n-    }\n-\n-    public void close() {\n-      countDownLatch.countDown();\n-    }\n-\n-    public void assertClosed(String openErrorMsg) {\n-      if (!isClosed()) {\n-        env.flop(new ExpectedClosedLatchException(openErrorMsg));\n-      }\n-    }\n-\n-    public void assertOpen(String closedErrorMsg) {\n-      if (isClosed()) {\n-        env.flop(new ExpectedOpenLatchException(closedErrorMsg));\n-      }\n-    }\n-\n-    public void expectClose(String notClosedErrorMsg) throws InterruptedException {\n-      expectClose(env.defaultTimeoutMillis(), notClosedErrorMsg);\n-    }\n-\n-    public void expectClose(long timeoutMillis, String notClosedErrorMsg) throws InterruptedException {\n-      countDownLatch.await(timeoutMillis, TimeUnit.MILLISECONDS);\n-      if (countDownLatch.getCount() > 0) {\n-        env.flop(String.format(\"%s within %d ms\", notClosedErrorMsg, timeoutMillis));\n-      }\n-    }\n-\n-    static final class ExpectedOpenLatchException extends RuntimeException {\n-      public ExpectedOpenLatchException(String message) {\n-        super(message);\n-      }\n-    }\n-\n-    static final class ExpectedClosedLatchException extends RuntimeException {\n-      public ExpectedClosedLatchException(String message) {\n-        super(message);\n-      }\n-    }\n-\n-  }\n-\n-  \/\/ simple promise for *one* value, which cannot be reset\n-  public static class Promise<T> {\n-    private final TestEnvironment env;\n-\n-    public static <T> Promise<T> completed(TestEnvironment env, T value) {\n-      Promise<T> promise = new Promise<T>(env);\n-      promise.completeImmediatly(value);\n-      return promise;\n-    }\n-\n-    public Promise(TestEnvironment env) {\n-      this.env = env;\n-    }\n-\n-    private ArrayBlockingQueue<T> abq = new ArrayBlockingQueue<T>(1);\n-    private AtomicReference<T> _value = new AtomicReference<T>();\n-\n-    public T value() {\n-      final T value = _value.get();\n-      if (value != null) {\n-        return value;\n-      } else {\n-        env.flop(\"Cannot access promise value before completion\");\n-        return null;\n-      }\n-    }\n-\n-    public boolean isCompleted() {\n-      return _value.get() != null;\n-    }\n-\n-    \/**\n-     * Allows using expectCompletion to await for completion of the value and complete it _then_\n-     *\/\n-    public void complete(T value) {\n-      if (_value.compareAndSet(null, value)) {\n-        \/\/ we add the value to the queue such to wake up any expectCompletion which was triggered before complete() was called\n-        abq.add(value);\n-      } else {\n-        env.flop(String.format(\"Cannot complete a promise more than once! Present value: %s, attempted to set: %s\", _value.get(), value));\n-      }\n-    }\n-\n-    \/**\n-     * Same as complete.\n-     *\n-     * Keeping this method for binary compatibility.\n-     *\/\n-    public void completeImmediatly(T value) {\n-      complete(value);\n-    }\n-\n-    public void expectCompletion(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      if (!isCompleted()) {\n-        T val = abq.poll(timeoutMillis, TimeUnit.MILLISECONDS);\n-\n-        if (val == null) {\n-          env.flop(String.format(\"%s within %d ms\", errorMsg, timeoutMillis));\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ a \"Promise\" for multiple values, which also supports \"end-of-stream reached\"\n-  public static class Receptacle<T> {\n-    final int QUEUE_SIZE = 2 * TEST_BUFFER_SIZE;\n-    private final TestEnvironment env;\n-\n-    private final ArrayBlockingQueue<Optional<T>> abq = new ArrayBlockingQueue<Optional<T>>(QUEUE_SIZE);\n-\n-    private final Latch completedLatch;\n-\n-    Receptacle(TestEnvironment env) {\n-      this.env = env;\n-      this.completedLatch = new Latch(env);\n-    }\n-\n-    public void add(T value) {\n-      completedLatch.assertOpen(String.format(\"Unexpected element %s received after stream completed\", value));\n-\n-      abq.add(Optional.of(value));\n-    }\n-\n-    public void complete() {\n-      completedLatch.assertOpen(\"Unexpected additional complete signal received!\");\n-      completedLatch.close();\n-\n-      abq.add(Optional.<T>empty());\n-    }\n-\n-    public T next(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      Optional<T> value = abq.poll(timeoutMillis, TimeUnit.MILLISECONDS);\n-\n-      if (value == null) {\n-        return env.flopAndFail(String.format(\"%s within %d ms\", errorMsg, timeoutMillis));\n-      } else if (value.isDefined()) {\n-        return value.get();\n-      } else {\n-        return env.flopAndFail(\"Expected element but got end-of-stream\");\n-      }\n-    }\n-\n-    public Optional<T> nextOrEndOfStream(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      Optional<T> value = abq.poll(timeoutMillis, TimeUnit.MILLISECONDS);\n-\n-      if (value == null) {\n-        env.flop(String.format(\"%s within %d ms\", errorMsg, timeoutMillis));\n-        return Optional.empty();\n-      }\n-\n-      return value;\n-    }\n-\n-    \/**\n-     * @param timeoutMillis total timeout time for awaiting all {@code elements} number of elements\n-     *\/\n-    public List<T> nextN(long elements, long timeoutMillis, String errorMsg) throws InterruptedException {\n-      List<T> result = new LinkedList<T>();\n-      long remaining = elements;\n-      long deadline = System.currentTimeMillis() + timeoutMillis;\n-      while (remaining > 0) {\n-        long remainingMillis = deadline - System.currentTimeMillis();\n-\n-        result.add(next(remainingMillis, errorMsg));\n-        remaining--;\n-      }\n-\n-      return result;\n-    }\n-\n-\n-    public void expectCompletion(long timeoutMillis, String errorMsg) throws InterruptedException {\n-      Optional<T> value = abq.poll(timeoutMillis, TimeUnit.MILLISECONDS);\n-\n-      if (value == null) {\n-        env.flop(String.format(\"%s within %d ms\", errorMsg, timeoutMillis));\n-      } else if (value.isDefined()) {\n-        env.flop(String.format(\"Expected end-of-stream but got element [%s]\", value.get()));\n-      } \/\/ else, ok\n-    }\n-\n-    \/**\n-     * @deprecated Deprecated in favor of {@link #expectError(Class, long, long, String)}.\n-     *\/\n-    @Deprecated\n-    public <E extends Throwable> E expectError(Class<E> clazz, long timeoutMillis, String errorMsg) throws Exception {\n-      return expectError(clazz, timeoutMillis, timeoutMillis, errorMsg);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    final <E extends Throwable> E expectError(Class<E> clazz, final long totalTimeoutMillis,\n-                                              long pollTimeoutMillis,\n-                                              String errorMsg) throws Exception {\n-      long totalTimeoutRemainingNs = MILLISECONDS.toNanos(totalTimeoutMillis);\n-      long timeStampANs = System.nanoTime();\n-      long timeStampBNs;\n-\n-      for (;;) {\n-        Thread.sleep(Math.min(pollTimeoutMillis, NANOSECONDS.toMillis(totalTimeoutRemainingNs)));\n-\n-        if (env.asyncErrors.isEmpty()) {\n-          timeStampBNs = System.nanoTime();\n-          totalTimeoutRemainingNs =- timeStampBNs - timeStampANs;\n-          timeStampANs = timeStampBNs;\n-\n-          if (totalTimeoutRemainingNs <= 0) {\n-            return env.flopAndFail(String.format(\"%s within %d ms\", errorMsg, totalTimeoutMillis));\n-          }\n-        } else {\n-          \/\/ ok, there was an expected error\n-          Throwable thrown = env.asyncErrors.remove(0);\n-\n-          if (clazz.isInstance(thrown)) {\n-            return (E) thrown;\n-          } else {\n-\n-            return env.flopAndFail(String.format(\"%s within %d ms; Got %s but expected %s\",\n-                    errorMsg, totalTimeoutMillis, thrown.getClass().getCanonicalName(), clazz.getCanonicalName()));\n-          }\n-        }\n-      }\n-    }\n-\n-    public void expectNone(long withinMillis, String errorMsgPrefix) throws InterruptedException {\n-      Thread.sleep(withinMillis);\n-      Optional<T> value = abq.poll();\n-\n-      if (value == null) {\n-        \/\/ ok\n-      } else if (value.isDefined()) {\n-        env.flop(String.format(\"%s [%s]\", errorMsgPrefix, value.get()));\n-      } else {\n-        env.flop(\"Expected no element but got end-of-stream\");\n-      }\n-    }\n-  }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/TestEnvironment.java","additions":0,"deletions":1168,"binary":false,"changes":1168,"status":"deleted"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck;\n-\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.tck.flow.support.Function;\n-import org.reactivestreams.tck.flow.support.HelperPublisher;\n-import org.reactivestreams.tck.flow.support.InfiniteHelperPublisher;\n-\n-import java.util.concurrent.ExecutorService;\n-\n-\/**\n- * Type which is able to create elements based on a seed {@code id} value.\n- * <p>\n- * Simplest implementations will simply return the incoming id as the element.\n- *\n- * @param <T> type of element to be delivered to the Subscriber\n- *\/\n-public abstract class WithHelperPublisher<T> {\n-\n-  \/** ExecutorService to be used by the provided helper {@link org.reactivestreams.Publisher} *\/\n-  public abstract ExecutorService publisherExecutorService();\n-\n-  \/**\n-   * Implement this method to match your expected element type.\n-   * In case of implementing a simple Subscriber which is able to consume any kind of element simply return the\n-   * incoming {@code element} element.\n-   * <p>\n-   * Sometimes the Subscriber may be limited in what type of element it is able to consume, this you may have to implement\n-   * this method such that the emitted element matches the Subscribers requirements. Simplest implementations would be\n-   * to simply pass in the {@code element} as payload of your custom element, such as appending it to a String or other identifier.\n-   * <p>\n-   * <b>Warning:<\/b> This method may be called concurrently by the helper publisher, thus it should be implemented in a\n-   * thread-safe manner.\n-   *\n-   * @return element of the matching type {@code T} that will be delivered to the tested Subscriber\n-   *\/\n-  public abstract T createElement(int element);\n-\n-  \/**\n-   * Helper method required for creating the Publisher to which the tested Subscriber will be subscribed and tested against.\n-   * <p>\n-   * By default an <b>asynchronously signalling Publisher<\/b> is provided, which will use {@link #createElement(int)}\n-   * to generate elements type your Subscriber is able to consume.\n-   * <p>\n-   * Sometimes you may want to implement your own custom custom helper Publisher - to validate behaviour of a Subscriber\n-   * when facing a synchronous Publisher for example. If you do, it MUST emit the exact number of elements asked for\n-   * (via the {@code elements} parameter) and MUST also must treat the following numbers of elements in these specific ways:\n-   * <ul>\n-   *   <li>\n-   *     If {@code elements} is {@code Long.MAX_VALUE} the produced stream must be infinite.\n-   *   <\/li>\n-   *   <li>\n-   *     If {@code elements} is {@code 0} the {@code Publisher} should signal {@code onComplete} immediatly.\n-   *     In other words, it should represent a \"completed stream\".\n-   *   <\/li>\n-   * <\/ul>\n-   *\/\n-  @SuppressWarnings(\"unchecked\")\n-  public Publisher<T> createHelperPublisher(long elements) {\n-    final Function<Integer, T> mkElement = new Function<Integer, T>() {\n-      @Override public T apply(Integer id) throws Throwable {\n-        return createElement(id);\n-      }\n-    };\n-\n-    if (elements > Integer.MAX_VALUE) return new InfiniteHelperPublisher(mkElement, publisherExecutorService());\n-    else return new HelperPublisher(0, (int) elements, mkElement, publisherExecutorService());\n-  }\n-\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/WithHelperPublisher.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow;\n-\n-import org.reactivestreams.Publisher;\n-import org.reactivestreams.FlowAdapters;\n-import org.reactivestreams.tck.PublisherVerification;\n-import org.reactivestreams.tck.TestEnvironment;\n-\n-import java.util.concurrent.Flow;\n-\n-\/**\n- * Provides tests for verifying a Java 9+ {@link java.util.concurrent.Flow.Publisher} specification rules.\n- *\n- * @see java.util.concurrent.Flow.Publisher\n- *\/\n-public abstract class FlowPublisherVerification<T> extends PublisherVerification<T> {\n-\n-  public FlowPublisherVerification(TestEnvironment env, long publisherReferenceGCTimeoutMillis) {\n-    super(env, publisherReferenceGCTimeoutMillis);\n-  }\n-\n-  public FlowPublisherVerification(TestEnvironment env) {\n-    super(env);\n-  }\n-\n-  @Override\n-  final public Publisher<T> createPublisher(long elements) {\n-    final Flow.Publisher<T> flowPublisher = createFlowPublisher(elements);\n-    return FlowAdapters.toPublisher(flowPublisher);\n-  }\n-  \/**\n-   * This is the main method you must implement in your test incarnation.\n-   * It must create a Publisher for a stream with exactly the given number of elements.\n-   * If `elements` is `Long.MAX_VALUE` the produced stream must be infinite.\n-   *\/\n-  public abstract Flow.Publisher<T> createFlowPublisher(long elements);\n-\n-  @Override\n-  final public Publisher<T> createFailedPublisher() {\n-    final Flow.Publisher<T> failed = createFailedFlowPublisher();\n-    if (failed == null) return null; \/\/ because `null` means \"SKIP\" in createFailedPublisher\n-    else return FlowAdapters.toPublisher(failed);\n-  }\n-  \/**\n-   * By implementing this method, additional TCK tests concerning a \"failed\" publishers will be run.\n-   *\n-   * The expected behaviour of the {@link Flow.Publisher} returned by this method is hand out a subscription,\n-   * followed by signalling {@code onError} on it, as specified by Rule 1.9.\n-   *\n-   * If you ignore these additional tests, return {@code null} from this method.\n-   *\/\n-  public abstract Flow.Publisher<T> createFailedFlowPublisher();\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/FlowPublisherVerification.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow;\n-\n-import org.reactivestreams.FlowAdapters;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-import org.reactivestreams.tck.SubscriberBlackboxVerification;\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.support.SubscriberBlackboxVerificationRules;\n-\n-import java.util.concurrent.Flow;\n-\n-\/**\n- * Provides tests for verifying {@link java.util.concurrent.Flow.Subscriber} and {@link java.util.concurrent.Flow.Subscription}\n- * specification rules, without any modifications to the tested implementation (also known as \"Black Box\" testing).\n- *\n- * This verification is NOT able to check many of the rules of the spec, and if you want more\n- * verification of your implementation you'll have to implement {@code org.reactivestreams.tck.SubscriberWhiteboxVerification}\n- * instead.\n- *\n- * @see java.util.concurrent.Flow.Subscriber\n- * @see java.util.concurrent.Flow.Subscription\n- *\/\n-public abstract class FlowSubscriberBlackboxVerification<T> extends SubscriberBlackboxVerification<T>\n-  implements SubscriberBlackboxVerificationRules {\n-\n-  protected FlowSubscriberBlackboxVerification(TestEnvironment env) {\n-    super(env);\n-  }\n-\n-  @Override\n-  public final void triggerRequest(Subscriber<? super T> subscriber) {\n-    triggerFlowRequest(FlowAdapters.toFlowSubscriber(subscriber));\n-  }\n-  \/**\n-   * Override this method if the {@link java.util.concurrent.Flow.Subscriber} implementation you are verifying\n-   * needs an external signal before it signals demand to its Publisher.\n-   *\n-   * By default this method does nothing.\n-   *\/\n-  public void triggerFlowRequest(Flow.Subscriber<? super T> subscriber) {\n-    \/\/ this method is intentionally left blank\n-  }\n-\n-  @Override\n-  public final Subscriber<T> createSubscriber() {\n-    return FlowAdapters.<T>toSubscriber(createFlowSubscriber());\n-  }\n-  \/**\n-   * This is the main method you must implement in your test incarnation.\n-   * It must create a new {@link Flow.Subscriber} instance to be subjected to the testing logic.\n-   *\/\n-  abstract public Flow.Subscriber<T> createFlowSubscriber();\n-\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/FlowSubscriberBlackboxVerification.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow;\n-\n-import org.reactivestreams.FlowAdapters;\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.tck.SubscriberWhiteboxVerification;\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.support.SubscriberWhiteboxVerificationRules;\n-\n-import java.util.concurrent.Flow;\n-\n-\/**\n- * Provides whitebox style tests for verifying {@link java.util.concurrent.Flow.Subscriber}\n- * and {@link java.util.concurrent.Flow.Subscription} specification rules.\n- *\n- * @see java.util.concurrent.Flow.Subscriber\n- * @see java.util.concurrent.Flow.Subscription\n- *\/\n-public abstract class FlowSubscriberWhiteboxVerification<T> extends SubscriberWhiteboxVerification<T>\n-  implements SubscriberWhiteboxVerificationRules {\n-\n-  protected FlowSubscriberWhiteboxVerification(TestEnvironment env) {\n-    super(env);\n-  }\n-\n-  @Override\n-  final public Subscriber<T> createSubscriber(WhiteboxSubscriberProbe<T> probe) {\n-    return FlowAdapters.toSubscriber(createFlowSubscriber(probe));\n-  }\n-  \/**\n-   * This is the main method you must implement in your test incarnation.\n-   * It must create a new {@link org.reactivestreams.Subscriber} instance to be subjected to the testing logic.\n-   *\n-   * In order to be meaningfully testable your Subscriber must inform the given\n-   * `WhiteboxSubscriberProbe` of the respective events having been received.\n-   *\/\n-  protected abstract Flow.Subscriber<T> createFlowSubscriber(WhiteboxSubscriberProbe<T> probe);\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/FlowSubscriberWhiteboxVerification.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow;\n-\n-import org.reactivestreams.*;\n-import org.reactivestreams.tck.IdentityProcessorVerification;\n-import org.reactivestreams.tck.TestEnvironment;\n-import org.reactivestreams.tck.flow.support.SubscriberWhiteboxVerificationRules;\n-import org.reactivestreams.tck.flow.support.PublisherVerificationRules;\n-\n-import java.util.concurrent.Flow;\n-\n-public abstract class IdentityFlowProcessorVerification<T> extends IdentityProcessorVerification<T>\n-  implements SubscriberWhiteboxVerificationRules, PublisherVerificationRules {\n-\n-  public IdentityFlowProcessorVerification(TestEnvironment env) {\n-    super(env);\n-  }\n-\n-  public IdentityFlowProcessorVerification(TestEnvironment env, long publisherReferenceGCTimeoutMillis) {\n-    super(env, publisherReferenceGCTimeoutMillis);\n-  }\n-\n-  public IdentityFlowProcessorVerification(TestEnvironment env, long publisherReferenceGCTimeoutMillis, int processorBufferSize) {\n-    super(env, publisherReferenceGCTimeoutMillis, processorBufferSize);\n-  }\n-\n-  \/**\n-   * By implementing this method, additional TCK tests concerning a \"failed\" Flow publishers will be run.\n-   *\n-   * The expected behaviour of the {@link Flow.Publisher} returned by this method is hand out a subscription,\n-   * followed by signalling {@code onError} on it, as specified by Rule 1.9.\n-   *\n-   * If you want to ignore these additional tests, return {@code null} from this method.\n-   *\/\n-  protected abstract Flow.Publisher<T> createFailedFlowPublisher();\n-\n-  \/**\n-   * This is the main method you must implement in your test incarnation.\n-   * It must create a {@link Flow.Processor}, which simply forwards all stream elements from its upstream\n-   * to its downstream. It must be able to internally buffer the given number of elements.\n-   *\n-   * @param bufferSize number of elements the processor is required to be able to buffer.\n-   *\/\n-  protected abstract Flow.Processor<T,T> createIdentityFlowProcessor(int bufferSize);\n-\n-  @Override\n-  public final Processor<T, T> createIdentityProcessor(int bufferSize) {\n-    return FlowAdapters.toProcessor(createIdentityFlowProcessor(bufferSize));\n-  }\n-\n-  @Override\n-  public final Publisher<T> createFailedPublisher() {\n-    Flow.Publisher<T> failed = createFailedFlowPublisher();\n-    if (failed == null) return null; \/\/ because `null` means \"SKIP\" in createFailedPublisher\n-    else return FlowAdapters.toPublisher(failed);\n-  }\n-\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/IdentityFlowProcessorVerification.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -1,28 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow.support;\n-\n-public interface Function<In, Out> {\n-  public Out apply(In in) throws Throwable;\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/support\/Function.java","additions":0,"deletions":28,"binary":false,"changes":28,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow.support;\n-\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.concurrent.Executor;\n-\n-import org.reactivestreams.example.unicast.AsyncIterablePublisher;\n-\n-public class HelperPublisher<T> extends AsyncIterablePublisher<T> {\n-\n-    public HelperPublisher(final int from, final int to, final Function<Integer, T> create, final Executor executor) {\n-        super(new Iterable<T>() {\n-          { if(from > to) throw new IllegalArgumentException(\"from must be equal or greater than to!\"); }\n-          @Override public Iterator<T> iterator() {\n-            return new Iterator<T>() {\n-              private int at = from;\n-              @Override public boolean hasNext() { return at < to; }\n-              @Override public T next() {\n-                if (!hasNext()) return Collections.<T>emptyList().iterator().next();\n-                else try {\n-                  return create.apply(at++);\n-                } catch (Throwable t) {\n-                  throw new IllegalStateException(String.format(\"Failed to create element for id %d!\", at - 1), t);\n-                }\n-              }\n-              @Override public void remove() { throw new UnsupportedOperationException(); }\n-            };\n-          }\n-        }, executor);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/support\/HelperPublisher.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow.support;\n-\n-import org.reactivestreams.example.unicast.AsyncIterablePublisher;\n-\n-import java.util.Iterator;\n-import java.util.concurrent.Executor;\n-\n-public class InfiniteHelperPublisher<T> extends AsyncIterablePublisher<T> {\n-\n-    public InfiniteHelperPublisher(final Function<Integer, T> create, final Executor executor) {\n-        super(new Iterable<T>() {\n-          @Override public Iterator<T> iterator() {\n-            return new Iterator<T>() {\n-              private int at = 0;\n-\n-              @Override public boolean hasNext() { return true; }\n-              @Override public T next() {\n-                try {\n-                  return create.apply(at++); \/\/ Wraps around on overflow\n-                } catch (Throwable t) {\n-                  throw new IllegalStateException(\n-                    String.format(\"Failed to create element in %s for id %s!\", getClass().getSimpleName(), at - 1), t);\n-                }\n-              }\n-              @Override public void remove() { throw new UnsupportedOperationException(); }\n-            };\n-          }\n-        }, executor);\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/support\/InfiniteHelperPublisher.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow.support;\n-\n-\n-\/**\n- * Copy of scala.control.util.NonFatal in order to not depend on scala-library\n- *\/\n-public class NonFatal {\n-  private NonFatal() {\n-    \/\/ no instances, please.\n-  }\n-\n-  \/**\n-   * Returns true if the provided `Throwable` is to be considered non-fatal, or false if it is to be considered fatal\n-   *\n-   * @param t throwable to be matched for fatal-ness\n-   * @return true if is a non-fatal throwable, false otherwise\n-   *\/\n-  public static boolean isNonFatal(Throwable t) {\n-    if (t instanceof StackOverflowError) {\n-      \/\/ StackOverflowError ok even though it is a VirtualMachineError\n-      return true;\n-    } else if (t instanceof VirtualMachineError ||\n-        t instanceof ThreadDeath ||\n-        t instanceof InterruptedException ||\n-        t instanceof LinkageError) {\n-      \/\/ VirtualMachineError includes OutOfMemoryError and other fatal errors\n-      return false;\n-    } else {\n-      return true;\n-    }\n-  }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/support\/NonFatal.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow.support;\n-\n-import java.util.NoSuchElementException;\n-\n-\/\/ simplest possible version of Scala's Option type\n-public abstract class Optional<T> {\n-\n-  private static final Optional<Object> NONE = new Optional<Object>() {\n-    @Override\n-    public Object get() {\n-      throw new NoSuchElementException(\".get call on None!\");\n-    }\n-\n-    @Override\n-    public boolean isEmpty() {\n-      return true;\n-    }\n-  };\n-\n-  private Optional() {\n-  }\n-\n-  @SuppressWarnings(\"unchecked\")\n-  public static <T> Optional<T> empty() {\n-    return (Optional<T>) NONE;\n-  }\n-\n-  @SuppressWarnings(\"unchecked\")\n-  public static <T> Optional<T> of(T it) {\n-    if (it == null) return (Optional<T>) Optional.NONE;\n-    else return new Some(it);\n-  }\n-\n-  public abstract T get();\n-\n-  public abstract boolean isEmpty();\n-\n-  public boolean isDefined() {\n-    return !isEmpty();\n-  }\n-\n-  public static class Some<T> extends Optional<T> {\n-    private final T value;\n-\n-    Some(T value) {\n-      this.value = value;\n-    }\n-\n-    @Override\n-    public T get() {\n-      return value;\n-    }\n-\n-    @Override\n-    public boolean isEmpty() {\n-      return false;\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return String.format(\"Some(%s)\", value);\n-    }\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"None\";\n-  }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/support\/Optional.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,658 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow.support;\n-\n-\/**\n- * Internal TCK use only.\n- * Add \/ Remove tests for PublisherVerification here to make sure that they arre added\/removed in the other places.\n- *\/\n-public interface PublisherVerificationRules {\n-  \/**\n-   * Validates that the override of {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()}\n-   * returns a non-negative value.\n-   *\/\n-  void required_validate_maxElementsFromPublisher() throws Exception;\n-  \/**\n-   * Validates that the override of {@link org.reactivestreams.tck.PublisherVerification#boundedDepthOfOnNextAndRequestRecursion()}\n-   * returns a positive value.\n-   *\/\n-  void required_validate_boundedDepthOfOnNextAndRequestRecursion() throws Exception;\n-  \/**\n-   * Asks for a {@code Publisher} that should emit exactly one item and complete (both within a\n-   * timeout specified by {@link org.reactivestreams.tck.TestEnvironment#defaultTimeoutMillis()})\n-   * in response to a request(1).\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} returns zero.\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code Publisher.subscribe(Subscriber)} method has actual implementation,<\/li>\n-   * <li>in the {@code Publisher.subscribe(Subscriber)} method, if there is an upstream {@code Publisher},\n-   * that {@code Publisher} is actually subscribed to,<\/li>\n-   * <li>if the {@code Publisher} is part of a chain, all elements actually issue a {@code request()} call\n-   * in response to the test subscriber or by default to their upstream,<\/li>\n-   * <li>in the {@code Publisher.subscribe(Subscriber)} method, the {@code Subscriber.onSubscribe} is called\n-   * as part of the preparation process (usually before subscribing to other {@code Publisher}s),<\/li>\n-   * <li>if the {@code Publisher} implementation works for a consumer that calls {@code request(1)},<\/li>\n-   * <li>if the {@code Publisher} implementation is able to emit an {@code onComplete} without requests,<\/li>\n-   * <li>that the {@code Publisher} implementation does not emit more than the allowed elements (exactly one).<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_createPublisher1MustProduceAStreamOfExactly1Element() throws Throwable;\n-  \/**\n-   * Asks for a {@code Publisher} that should emit exactly three items and complete (all within a\n-   * timeout specified by {@link org.reactivestreams.tck.TestEnvironment#defaultTimeoutMillis()}).\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.\n-   * <p>\n-   * The tests requests one-by-one and verifies each single response item arrives in time.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code Publisher.subscribe(Subscriber)} method has actual implementation,<\/li>\n-   * <li>in the {@code Publisher.subscribe(Subscriber)} method, if there is an upstream {@code Publisher},\n-   * that {@code Publisher} is actually subscribed to,<\/li>\n-   * <li>if the {@code Publisher} is part of a chain, all elements actually issue a {@code request()} call\n-   * in response to the test subscriber or by default to their upstream,<\/li>\n-   * <li>in the {@code Publisher.subscribe(Subscriber)} method, the {@code Subscriber.onSubscribe} is called\n-   * as part of the preparation process (usually before subscribing to other {@code Publisher}s),<\/li>\n-   * <li>if the {@code Publisher} implementation works for a subscriber that calls {@code request(1)} after consuming an item,<\/li>\n-   * <li>if the {@code Publisher} implementation is able to emit an {@code onComplete} without requests.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_createPublisher3MustProduceAStreamOfExactly3Elements() throws Throwable;\n-  \/**\n-   * Asks for a {@code Publisher} that responds to a request pattern of 0 (not requesting upfront), 1, 1 and 2\n-   * in a timely manner.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.1'>1.1<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 5.\n-   * <p>\n-   * This test ensures that the {@code Publisher} implementation correctly responds to {@code request()} calls that in\n-   * total are less than the number of elements this {@code Publisher} could emit (thus the completion event won't be emitted).\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>if the {@code Publisher} implementation considers the cumulative request amount it receives,<\/li>\n-   * <li>if the {@code Publisher} doesn't lose any {@code request()} signal and the state transition from idle -&gt; emitting or emitting -&gt; keep emitting works properly.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec101_subscriptionRequestMustResultInTheCorrectNumberOfProducedElements() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} and verifies that requesting once and with more than the length (but bounded) results in the\n-   * correct number of items to be emitted (i.e., length 3 and request 10) followed by an {@code onComplete} signal.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.2'>1.2<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.\n-   * <p>\n-   * This test ensures that the {@code Publisher} implementation can deal with larger requests than the number of items it can produce.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec102_maySignalLessThanRequestedAndTerminateSubscription() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (i.e., length 10), repeatedly subscribes to this {@code Publisher}, requests items\n-   * one by one and verifies the {@code Publisher} calls the {@code onXXX} methods non-overlappingly.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.3'>1.3<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 10.\n-   * <p>\n-   * Note that this test is probabilistic, that is, may not capture any concurrent invocation in a {code Publisher} implementation.\n-   * Note also that this test is sensitive to cases when a {@code request()} call in {@code onSubscribe()} triggers an asynchronous\n-   * call to the other {@code onXXX} methods. In contrast, the test allows synchronous call chain of\n-   * {@code onSubscribe -> request -> onNext}.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>if a {@code request()} call from {@code onSubscribe()} could trigger an asynchronous call to {@code onNext()} and if so, make sure\n-   * such {@code request()} calls are deferred until the call to {@code onSubscribe()} returns normally.<\/li>\n-   * <\/ul>\n-   *\/\n-  void stochastic_spec103_mustSignalOnMethodsSequentially() throws Throwable;\n-  \/**\n-   * Asks for an error {@code Publisher} that should call {@code onSubscribe} exactly once\n-   * followed by a single call to {@code onError()} without receiving any requests and otherwise\n-   * not throwing any exception.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.4'>1.4<\/a>\n-   * <p>\n-   * The test is not executed if {@code PublisherVerification.createErrorPublisher()} returns null.\n-   * <p>\n-   * If this test fails, the following could be checked within the error {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code Publisher.subscribe(Subscriber)} method has actual implementation,<\/li>\n-   * <li>in the {@code Publisher.subscribe(Subscriber)} method, if there is an upstream {@code Publisher},\n-   * that {@code Publisher} is actually subscribed to,<\/li>\n-   * <li>if the {@code Publisher} implementation does signal an {@code onSubscribe} before signalling {@code onError},<\/li>\n-   * <li>if the {@code Publisher} implementation is able to emit an {@code onError} without requests,<\/li>\n-   * <li>if the {@code Publisher} is non-empty as this test requires a {@code Publisher} to signal an\n-   * {@code onError} eagerly.<\/li>\n-   * <\/ul>\n-   *\/\n-  void optional_spec104_mustSignalOnErrorWhenFails() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (i.e., length 3) and verifies, after requesting one by one, the sequence\n-   * completes normally.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.5'>1.5<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.\n-   * <p>\n-   * Note that the tests requests 1 after the items have been received and before expecting an {@code onComplete} signal.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec105_mustSignalOnCompleteWhenFiniteStreamTerminates() throws Throwable;\n-  \/**\n-   * Asks for an empty {@code Publisher} (i.e., length 0) and verifies it completes in a timely manner.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.5'>1.5<\/a>\n-   * <p>\n-   * Note that the tests requests 1 before expecting an {@code onComplete} signal.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>if the {@code Publisher} is non-empty as this test requires a {@code Publisher} without items.<\/li>\n-   * <\/ul>\n-   *\/\n-  void optional_spec105_emptyStreamMustTerminateBySignallingOnComplete() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped because it is unclear this rule can be effectively checked\n-   * on a {@code Publisher} instance without looking into or hooking into the implementation of it.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.6'>1.6<\/a>\n-   *\/\n-  void untested_spec106_mustConsiderSubscriptionCancelledAfterOnErrorOrOnCompleteHasBeenCalled() throws Throwable;\n-  \/**\n-   * Asks for a single-element {@code Publisher} and checks if requesting after the terminal event doesn't\n-   * lead to more items or terminal signals to be emitted.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.7'>1.7<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 1.\n-   * <p>\n-   * The tests requests more items than the expected {@code Publisher} length upfront and some more items after its completion.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>the indication for the terminal state is properly persisted and a request call can't trigger emission of more items or another\n-   * terminal signal.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec107_mustNotEmitFurtherSignalsOnceOnCompleteHasBeenSignalled() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped, although it is possible to validate an error {@code Publisher} along\n-   * the same lines as {@link #required_spec107_mustNotEmitFurtherSignalsOnceOnCompleteHasBeenSignalled()}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.7'>1.7<\/a>\n-   *\/\n-  void untested_spec107_mustNotEmitFurtherSignalsOnceOnErrorHasBeenSignalled() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped because there was no agreement on how to verify its \"eventually\" requirement.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.8'>1.8<\/a>\n-   *\/\n-  void untested_spec108_possiblyCanceledSubscriptionShouldNotReceiveOnErrorOrOnCompleteSignals() throws Throwable;\n-  \/**\n-   * Asks for an empty {@code Publisher} and verifies if {@code onSubscribe} signal was emitted before\n-   * any other {@code onNext}, {@code onError} or {@code onComplete} signal.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.9'>1.9<\/a>\n-   * <p>\n-   * Note that this test doesn't request anything, however, an {@code onNext} is not considered as a failure.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>the {@code Publisher.subscribe(Subscriber)} method has actual implementation,<\/li>\n-   * <li>in the {@code Publisher.subscribe(Subscriber)} method, if there is an upstream {@code Publisher},\n-   * that {@code Publisher} is actually subscribed to,<\/li>\n-   * <li>in the {@code Publisher.subscribe(Subscriber)} method, the {@code Subscriber.onSubscribe} is called\n-   * as part of the preparation process (usually before subscribing to other {@code Publisher}s).<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec109_mustIssueOnSubscribeForNonNullSubscriber() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped because there is no common agreement on what is to be considered a fatal exception and\n-   * besides, {@code Publisher.subscribe} is only allowed throw a {@code NullPointerException} and any other\n-   * exception would require looking into or hooking into the implementation of the {@code Publisher}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.9'>1.9<\/a>\n-   *\/\n-  void untested_spec109_subscribeShouldNotThrowNonFatalThrowable() throws Throwable;\n-  \/**\n-   * Asks for an empty {@code Publisher} and calls {@code subscribe} on it with {@code null} that should result in\n-   * a {@code NullPointerException} to be thrown.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.9'>1.9<\/a>\n-   * <p>\n-   * If this test fails, check if the {@code subscribe()} implementation has an explicit null check (or a method dereference\n-   * on the {@code Subscriber}), especially if the incoming {@code Subscriber} is wrapped or stored to be used later.\n-   *\/\n-  void required_spec109_subscribeThrowNPEOnNullSubscriber() throws Throwable;\n-  \/**\n-   * Asks for an error {@code Publisher} that should call {@code onSubscribe} exactly once\n-   * followed by a single call to {@code onError()} without receiving any requests.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.9'>1.9<\/a>\n-   * <p>\n-   * The test is not executed if {@code PublisherVerification.createErrorPublisher()} returns null.\n-   * <p>\n-   * The difference between this test and {@link #optional_spec104_mustSignalOnErrorWhenFails()} is that there is\n-   * no explicit verification if exceptions were thrown in addition to the regular {@code onSubscribe+onError} signal pair.\n-   * <p>\n-   * If this test fails, the following could be checked within the error {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code Publisher.subscribe(Subscriber)} method has actual implementation,<\/li>\n-   * <li>in the {@code Publisher.subscribe(Subscriber)} method, if there is an upstream {@code Publisher},\n-   * that {@code Publisher} is actually subscribed to,<\/li>\n-   * <li>if the {@code Publisher} implementation is able to emit an {@code onError} without requests,<\/li>\n-   * <li>if the {@code Publisher} is non-empty as this test expects a {@code Publisher} without items.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec109_mayRejectCallsToSubscribeIfPublisherIsUnableOrUnwillingToServeThemRejectionMustTriggerOnErrorAfterOnSubscribe() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped because enforcing rule 1.10 requires unlimited retention and reference-equal checks on\n-   * all incoming {@code Subscriber} which is generally infeasible, plus reusing the same {@code Subscriber} instance is\n-   * better detected (or ignored) inside {@code Subscriber.onSubscribe} when the method is called multiple times.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.10'>1.10<\/a>\n-   *\/\n-  void untested_spec110_rejectASubscriptionRequestIfTheSameSubscriberSubscribesTwice() throws Throwable;\n-  \/**\n-   * Asks for a single-element {@code Publisher} and subscribes to it twice, without consuming with either\n-   * {@code Subscriber} instance\n-   * (i.e., no requests are issued).\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.11'>1.11<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 1.\n-   * <p>\n-   * Note that this test ignores what signals the {@code Publisher} emits. Any exception thrown through non-regular\n-   * means will indicate a skipped test.\n-   *\/\n-  void optional_spec111_maySupportMultiSubscribe() throws Throwable;\n-  \/**\n-   * Asks for a single-element {@code Publisher} and subscribes to it twice.\n-   * Each {@code Subscriber} requests for 1 element and checks if onNext or onComplete signals was received.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.11'>1.11<\/a>,\n-   * and depends on valid implementation of rule <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.5'>1.5<\/a>\n-   * in order to verify this.\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 1.\n-   * <p>\n-   * Any exception thrown through non-regular means will indicate a skipped test.\n-   *\/\n-  void optional_spec111_registeredSubscribersMustReceiveOnNextOrOnCompleteSignals() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 5), subscribes 3 {@code Subscriber}s to it, requests with different\n-   * patterns and checks if all 3 received the same events in the same order.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.11'>1.11<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 5.\n-   * <p>\n-   * The request pattern for the first {@code Subscriber} is (1, 1, 2, 1); for the second is (2, 3) and for the third is (3, 1, 1).\n-   * <p>\n-   * Note that this test requires a {@code Publisher} that always emits the same signals to any {@code Subscriber}, regardless of\n-   * when they subscribe and how they request elements. I.e., a \"live\" {@code Publisher} emitting the current time would not pass this test.\n-   * <p>\n-   * Note that this test is optional and may appear skipped even if the behavior should be actually supported by the {@code Publisher},\n-   * see the skip message for an indication of this.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>if the {@code Publisher} implementation considers the cumulative request amount it receives,<\/li>\n-   * <li>if the {@code Publisher} doesn't lose any {@code request()} signal and the state transition from idle -&gt; emitting or emitting -&gt; keep emitting works properly.<\/li>\n-   * <\/ul>\n-   *\/\n-  void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingOneByOne() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 3), subscribes 3 {@code Subscriber}s to it, requests more than the length items\n-   * upfront with each and verifies they all received the same items in the same order (but does not verify they all complete).\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.11'>1.11<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.\n-   * <p>\n-   * Note that this test requires a {@code Publisher} that always emits the same signals to any {@code Subscriber}, regardless of\n-   * when they subscribe and how they request elements. I.e., a \"live\" {@code Publisher} emitting the current time would not pass this test.\n-   * <p>\n-   * Note that this test is optional and may appear skipped even if the behavior should be actually supported by the {@code Publisher},\n-   * see the skip message for an indication of this.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>if the {@code Publisher} implementation considers the cumulative request amount it receives,<\/li>\n-   * <li>if the {@code Publisher} doesn't lose any {@code request()} signal and the state transition from idle -&gt; emitting or emitting -&gt; keep emitting works properly.<\/li>\n-   * <\/ul>\n-   *\/\n-  void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfront() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 3), subscribes 3 {@code Subscriber}s to it, requests more than the length items\n-   * upfront with each and verifies they all received the same items in the same order followed by an {@code onComplete} signal.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#1.11'>1.11<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.\n-   * <p>\n-   * Note that this test requires a {@code Publisher} that always emits the same signals to any {@code Subscriber}, regardless of\n-   * when they subscribe and how they request elements. I.e., a \"live\" {@code Publisher} emitting the current time would not pass this test.\n-   * <p>\n-   * Note that this test is optional and may appear skipped even if the behavior should be actually supported by the {@code Publisher},\n-   * see the skip message for an indication of this.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>if the {@code Publisher} implementation considers the cumulative request amount it receives,<\/li>\n-   * <li>if the {@code Publisher} doesn't lose any {@code request()} signal and the state transition from idle -&gt; emitting or emitting -&gt; keep emitting works properly.<\/li>\n-   * <\/ul>\n-   *\/\n-  void optional_spec111_multicast_mustProduceTheSameElementsInTheSameSequenceToAllOfItsSubscribersWhenRequestingManyUpfrontAndCompleteAsExpected() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 6), requests several times from within {@code onSubscribe} and then requests\n-   * one-by-one from {@code onNext}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.2'>3.2<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 6.\n-   * <p>\n-   * The request pattern is 3 x 1 from within {@code onSubscribe} and one from within each {@code onNext} invocation.\n-   * <p>\n-   * The test consumes the {@code Publisher} but otherwise doesn't verify the {@code Publisher} completes (however, it checks\n-   * for errors).\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>if the {@code Publisher} implementation considers the cumulative request amount it receives,<\/li>\n-   * <li>if the {@code Publisher} doesn't lose any {@code request()} signal and the state transition from idle -&gt; emitting or emitting -&gt; keep emitting works properly.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec302_mustAllowSynchronousRequestCallsFromOnNextAndOnSubscribe() throws Throwable;\n-  \/**\n-   * Asks for a {@code Publisher} with length equal to the value returned by {@link #required_validate_boundedDepthOfOnNextAndRequestRecursion()} plus 1,\n-   * calls {@code request(1)} externally and then from within {@code onNext} and checks if the stack depth did not increase beyond the\n-   * amount permitted by {@link #required_validate_boundedDepthOfOnNextAndRequestRecursion()}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.3'>3.3<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than\n-   * {@link #required_validate_boundedDepthOfOnNextAndRequestRecursion()} plus 1.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>the implementation doesn't allow unbounded recursion when {@code request()} is called from within {@code onNext}, i.e., the lack of\n-   * reentrant-safe state machine around the request amount (such as a for loop with a bound on the parameter {@code n} that calls {@code onNext}).\n-   * <\/ul>\n-   *\/\n-  void required_spec303_mustNotAllowUnboundedRecursion() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped because a {@code request} could enter into a synchronous computation via {@code onNext}\n-   * legally and otherwise there is no common agreement how to detect such heavy computation reliably.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.4'>3.4<\/a>\n-   *\/\n-  void untested_spec304_requestShouldNotPerformHeavyComputations() throws Exception;\n-  \/**\n-   * Currently, this test is skipped because there is no reliable agreed upon way to detect a heavy computation.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.5'>3.5<\/a>\n-   *\/\n-  void untested_spec305_cancelMustNotSynchronouslyPerformHeavyComputation() throws Exception;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 3) and verifies that cancelling without requesting anything, then requesting\n-   * items should result in no signals to be emitted.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.6'>3.6<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.\n-   * <p>\n-   * The post-cancellation request pattern is (1, 1, 1).\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>the cancellation indicator flag is properly persisted (may require volatile) and checked as part of the signal emission process.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec306_afterSubscriptionIsCancelledRequestMustBeNops() throws Throwable;\n-  \/**\n-   * Asks for a single-element {@code Publisher} and verifies that without requesting anything, cancelling the sequence\n-   * multiple times should result in no signals to be emitted and should result in an thrown exception.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.7'>3.7<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 1.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>the cancellation indicator flag is properly persisted (may require volatile) and checked as part of the signal emission process.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec307_afterSubscriptionIsCancelledAdditionalCancelationsMustBeNops() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 10) and issues a {@code request(0)} which should trigger an {@code onError} call\n-   * with an {@code IllegalArgumentException}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.9'>3.9<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 10.\n-   * <p>\n-   * Note that this test expects the {@code IllegalArgumentException} being signalled through {@code onError}, not by\n-   * throwing from {@code request()} (which is also forbidden) or signalling the error by any other means (i.e., through the\n-   * {@code Thread.currentThread().getUncaughtExceptionHandler()} for example).\n-   * <p>\n-   * Note also that requesting and emission may happen concurrently and honoring this rule may require extra coordination within\n-   * the {@code Publisher}.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>the {@code Publisher} can emit an {@code onError} in this particular case, even if there was no prior and legal\n-   * {@code request} call and even if the {@code Publisher} would like to emit items first before emitting an {@code onError}\n-   * in general.\n-   * <\/ul>\n-   *\/\n-  void required_spec309_requestZeroMustSignalIllegalArgumentException() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 10) and issues a random, negative {@code request()} call which should\n-   * trigger an {@code onError} call with an {@code IllegalArgumentException}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.9'>3.9<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 10.\n-   * <p>\n-   * Note that this test expects the {@code IllegalArgumentException} being signalled through {@code onError}, not by\n-   * throwing from {@code request()} (which is also forbidden) or signalling the error by any other means (i.e., through the\n-   * {@code Thread.currentThread().getUncaughtExceptionHandler()} for example).\n-   * <p>\n-   * Note also that requesting and emission may happen concurrently and honoring this rule may require extra coordination within\n-   * the {@code Publisher}.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>the {@code Publisher} can emit an {@code onError} in this particular case, even if there was no prior and legal\n-   * {@code request} call and even if the {@code Publisher} would like to emit items first before emitting an {@code onError}\n-   * in general.\n-   * <\/ul>\n-   *\/\n-  void required_spec309_requestNegativeNumberMustSignalIllegalArgumentException() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 10) and issues a random, negative {@code request()} call which should\n-   * trigger an {@code onError} call with an {@code IllegalArgumentException}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.9'>3.9<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 10.\n-   * <p>\n-   * Note that this test expects the {@code IllegalArgumentException} being signalled through {@code onError}, not by\n-   * throwing from {@code request()} (which is also forbidden) or signalling the error by any other means (i.e., through the\n-   * {@code Thread.currentThread().getUncaughtExceptionHandler()} for example).\n-   * <p>\n-   * Note also that requesting and emission may happen concurrently and honoring this rule may require extra coordination within\n-   * the {@code Publisher}.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>the {@code Publisher} can emit an {@code onError} in this particular case, even if there was no prior and legal\n-   * {@code request} call and even if the {@code Publisher} would like to emit items first before emitting an {@code onError}\n-   * in general.\n-   * <\/ul>\n-   *\/\n-  void optional_spec309_requestNegativeNumberMaySignalIllegalArgumentExceptionWithSpecificMessage() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 20), requests some items (less than the length), consumes one item then\n-   * cancels the sequence and verifies the publisher emitted at most the requested amount and stopped emitting (or terminated).\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.12'>3.12<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 20.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>the cancellation indicator flag is properly persisted (may require volatile) and checked as part of the signal emission process.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec312_cancelMustMakeThePublisherToEventuallyStopSignaling() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 3) requests and consumes one element from it, cancels the {@code Subscription}\n-   * , calls {@code System.gc()} and then checks if all references to the test {@code Subscriber} has been dropped (by checking\n-   * the {@code WeakReference} has been emptied).\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.13'>3.13<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>the cancellation indicator flag is properly persisted (may require volatile) and checked as part of the signal emission process.<\/li>\n-   * <li>the {@code Publisher} stores the {@code Subscriber} reference somewhere which is then not cleaned up when the {@code Subscriber} is cancelled.\n-   * Note that this may happen on many code paths in a {@code Publisher}, for example in an emission loop that terminates because of the\n-   * {@code cancel} signal or because reaching a terminal state. Note also that eagerly nulling {@code Subscriber} references may not be necessary\n-   * for this test to pass in case there is a self-contained chain of them (i.e., {@code Publisher.subscribe()} creates a chain of fresh\n-   * {@code Subscriber} instances where each of them only references their downstream {@code Subscriber} thus the chain can get GC'd\n-   * when the reference to the final {@code Subscriber} is dropped).\n-   * <\/ul>\n-   *\/\n-  void required_spec313_cancelMustMakeThePublisherEventuallyDropAllReferencesToTheSubscriber() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 3) and requests {@code Long.MAX_VALUE} from it, verifying that the\n-   * {@code Publisher} emits all of its items and completes normally\n-   * and does not keep spinning attempting to fulfill the {@code Long.MAX_VALUE} demand by some means.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.17'>3.17<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>if the {@code Publisher} implementation considers the cumulative request amount it receives,<\/li>\n-   * <li>if the {@code Publisher} doesn't lose any {@code request()} signal and the state transition from idle -&gt; emitting or emitting -&gt; keep emitting works properly.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec317_mustSupportAPendingElementCountUpToLongMaxValue() throws Throwable;\n-  \/**\n-   * Asks for a short {@code Publisher} (length 3) and requests {@code Long.MAX_VALUE} from it in total (split across\n-   * two {@code Long.MAX_VALUE \/ 2} and one {@code request(1)}), verifying that the\n-   * {@code Publisher} emits all of its items and completes normally.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.17'>3.17<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than 3.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>if the {@code Publisher} implementation considers the cumulative request amount it receives,<\/li>\n-   * <li>if the {@code Publisher} implements adding individual request amounts together properly (not overflowing into zero or negative pending request amounts)\n-   * or not properly deducing the number of emitted items from the pending amount,<\/li>\n-   * <li>if the {@code Publisher} doesn't lose any {@code request()} signal and the state transition from idle -&gt; emitting or emitting -&gt; keep emitting works properly.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec317_mustSupportACumulativePendingElementCountUpToLongMaxValue() throws Throwable;\n-  \/**\n-   * Asks for a very long {@code Publisher} (up to {@code Integer.MAX_VALUE}), requests {@code Long.MAX_VALUE - 1} after\n-   * each received item and expects no failure due to a potential overflow in the pending emission count while consuming\n-   * 10 items and cancelling the sequence.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.17'>3.17<\/a>\n-   * <p>\n-   * The test is not executed if {@link org.reactivestreams.tck.PublisherVerification#maxElementsFromPublisher()} is less than {@code Integer.MAX_VALUE}.\n-   * <p>\n-   * The request pattern is one {@code request(1)} upfront and ten {@code request(Long.MAX_VALUE - 1)} after.\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Publisher} implementation:\n-   * <ul>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Publisher} has some time-delay behavior,<\/li>\n-   * <li>make sure the {@link #required_createPublisher1MustProduceAStreamOfExactly1Element()} and {@link #required_createPublisher3MustProduceAStreamOfExactly3Elements()} tests pass,<\/li>\n-   * <li>if the {@code Publisher} implementation considers the cumulative request amount it receives,<\/li>\n-   * <li>if the {@code Publisher} implements adding individual request amounts together properly (not overflowing into zero or negative pending request amounts)\n-   * or not properly deducing the number of emitted items from the pending amount,<\/li>\n-   * <li>if the {@code Publisher} doesn't lose any {@code request()} signal and the state transition from idle -&gt; emitting or emitting -&gt; keep emitting works properly.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec317_mustNotSignalOnErrorWhenPendingAboveLongMaxValue() throws Throwable;\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/support\/PublisherVerificationRules.java","additions":0,"deletions":658,"binary":false,"changes":658,"status":"deleted"},{"patch":"@@ -1,395 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow.support;\n-\n-import org.reactivestreams.tck.SubscriberBlackboxVerification;\n-\n-\/**\n- * Internal TCK use only.\n- * Add \/ Remove tests for SubscriberBlackboxVerification here to make sure that they arre added\/removed in the other places.\n- *\/\n-public interface SubscriberBlackboxVerificationRules {\n-  \/**\n-   * Asks for a {@code Subscriber} instance, expects it to call {@code request()} in\n-   * a timely manner and signals as many {@code onNext} items as the very first request\n-   * amount specified by the {@code Subscriber}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.1'>2.1<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>This test emits the number of items requested thus the {@code Subscriber} implementation\n-   * should not request too much.<\/li>\n-   * <li>Only the very first {@code request} amount is considered.<\/li>\n-   * <li>This test doesn't signal {@code onComplete} after the first set of {@code onNext} signals\n-   * has been emitted and may cause resource leak in\n-   * {@code Subscriber}s that expect a finite {@code Publisher}.<\/li>\n-   * <li>The test ignores cancellation from the {@code Subscriber} and emits the requested amount regardless.<\/li>\n-   * <\/ul>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>if the {@code Subscriber} requires external stimulus to begin requesting; override the\n-   * {@link SubscriberBlackboxVerification#triggerRequest(org.reactivestreams.Subscriber)} method\n-   *  in this case,<\/li>\n-   * <li>the {@code TestEnvironment} has large enough timeout specified in case the {@code Subscriber} has some time-delay behavior,<\/li>\n-   * <li>if the {@code Subscriber} requests zero or a negative value in some circumstances,<\/li>\n-   * <li>if the {@code Subscriber} throws an unchecked exception from its {@code onSubscribe} or\n-   * {@code onNext} methods.\n-   * <\/ul>\n-   *\/\n-  void required_spec201_blackbox_mustSignalDemandViaSubscriptionRequest() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped because there is no agreed upon approach how\n-   * to detect if the {@code Subscriber} really goes async or just responds in\n-   * a timely manner.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.2'>2.2<\/a>\n-   *\/\n-  void untested_spec202_blackbox_shouldAsynchronouslyDispatch() throws Exception;\n-  \/**\n-   * Asks for a {@code Subscriber}, signals an {@code onSubscribe} followed by an {@code onComplete} synchronously,\n-   * and checks if neither {@code request} nor {@code cancel} was called from within the {@code Subscriber}'s\n-   * {@code onComplete} implementation.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.3'>2.3<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>The test checks for the presensce of method named \"onComplete\" in the current stacktrace when handling\n-   * the {@code request} or {@code cancel} calls in the test's own {@code Subscription}.\n-   * <\/ul>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>no calls happen to {@code request} or {@code cancel} in response to an {@code onComplete}\n-   * directly or indirectly,<\/li>\n-   * <li>if the {@code Subscriber} throws an unchecked exception from its {@code onSubscribe} or\n-   * {@code onComplete} methods.\n-   * <\/ul>\n-   *\/\n-  void required_spec203_blackbox_mustNotCallMethodsOnSubscriptionOrPublisherInOnComplete() throws Throwable;\n-  \/**\n-   * Asks for a {@code Subscriber}, signals an {@code onSubscribe} followed by an {@code onError} synchronously,\n-   * and checks if neither {@code request} nor {@code cancel} was called from within the {@code Subscriber}'s\n-   * {@code onComplete} implementation.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.3'>2.3<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>The test checks for the presensce of method named \"onError\" in the current stacktrace when handling\n-   * the {@code request} or {@code cancel} calls in the test's own {@code Subscription}.\n-   * <\/ul>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>no calls happen to {@code request} or {@code cancel} in response to an {@code onError}\n-   * directly or indirectly,<\/li>\n-   * <li>if the {@code Subscriber} throws an unchecked exception from its {@code onSubscribe} or\n-   * {@code onError} methods.\n-   * <\/ul>\n-   *\/\n-  void required_spec203_blackbox_mustNotCallMethodsOnSubscriptionOrPublisherInOnError() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped because there is no way to check what the {@code Subscriber} \"considers\"\n-   * since rule 2.3 forbids interaction from within the {@code onError} and {@code onComplete} methods.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.4'>2.4<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>It would be possible to check if there was an async interaction with the test's {@code Subscription}\n-   * within a grace period but such check is still not generally decisive.<\/li>\n-   * <\/ul>\n-   *\/\n-  void untested_spec204_blackbox_mustConsiderTheSubscriptionAsCancelledInAfterRecievingOnCompleteOrOnError() throws Exception;\n-  \/**\n-   * Asks for a {@code Subscriber}, signals {@code onSubscribe} twice synchronously and expects the second {@code Subscription} gets\n-   * cancelled in a timely manner and without any calls to its {@code request} method.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.5'>2.5<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>The test doesn't signal any other events than {@code onSubscribe} and may cause resource leak in\n-   * {@code Subscriber}s that expect a finite {@code Publisher}.\n-   * <\/ul>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>if the {@code Subscribe.onSubscribe} implementation actually tries to detect multiple calls to it,<\/li>\n-   * <li>if the second {@code Subscription} is cancelled asynchronously and that takes longer time than\n-   * the {@code TestEnvironment}'s timeout permits.<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec205_blackbox_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal() throws Exception;\n-\n-  \/**\n-   * Currently, this test is skipped because it requires more control over the {@code Subscriber} implementation\n-   * to make it cancel the {@code Subscription} for some external condition.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.6'>2.6<\/a>\n-   *\/\n-  void untested_spec206_blackbox_mustCallSubscriptionCancelIfItIsNoLongerValid() throws Exception;\n-  \/**\n-   * Currently, this test is skipped because it requires more control over the {@code Subscriber} implementation\n-   * to issue requests based on external stimulus.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.7'>2.7<\/a>\n-   *\/\n-  void untested_spec207_blackbox_mustEnsureAllCallsOnItsSubscriptionTakePlaceFromTheSameThreadOrTakeCareOfSynchronization() throws Exception;\n-  \/**\n-   * Currently, this test is skipped because there is no way to make the {@code Subscriber} implementation\n-   * cancel the test's {@code Subscription} and check the outcome of sending {@code onNext}s after such\n-   * cancel.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.8'>2.8<\/a>\n-   *\/\n-  void untested_spec208_blackbox_mustBePreparedToReceiveOnNextSignalsAfterHavingCalledSubscriptionCancel() throws Throwable;\n-  \/**\n-   * Asks for a {@code Subscriber}, expects it to request some amount and in turn be able to receive an {@code onComplete}\n-   * synchronously from the {@code request} call without any {@code onNext} signals before that.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.9'>2.9<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>The test ignores cancellation from the {@code Subscriber}.<\/li>\n-   * <li>Invalid request amounts are ignored by this test.<\/li>\n-   * <li>Concurrent calls to the test's {@code Subscription.request()} must be externally synchronized, otherwise\n-   * such case results probabilistically in multiple {@code onComplete} calls by the test.<\/li>\n-   * <\/ul>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>if the {@code Subscriber} throws an unchecked exception from its {@code onSubscribe} or\n-   * {@code onComplete} methods.\n-   * <li>if the {@code Subscriber} requires external stimulus to begin requesting; override the\n-   * {@link SubscriberBlackboxVerification#triggerRequest(org.reactivestreams.Subscriber)} method\n-   *  in this case,<\/li>\n-   * <\/ul>\n-   *\/\n-  void required_spec209_blackbox_mustBePreparedToReceiveAnOnCompleteSignalWithPrecedingRequestCall() throws Throwable;\n-  \/**\n-   * Asks for a {@code Subscriber} and expects it to handle {@code onComplete} independent of whether the {@code Subscriber}\n-   * requests items or not.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.9'>2.9<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>Currently, the test doesn't call {@code onSubscribe} on the {@code Subscriber} which violates 1.9.\n-   * <\/ul>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>if the {@code Subscriber} throws an unchecked exception from its {@code onSubscribe} or\n-   * {@code onComplete} methods.\n-   * <\/ul>\n-   *\/\n-  void required_spec209_blackbox_mustBePreparedToReceiveAnOnCompleteSignalWithoutPrecedingRequestCall() throws Throwable;\n-  \/**\n-   * Asks for a {@code Subscriber}, signals {@code onSubscribe} followed by an {@code onError} synchronously.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.10'>2.10<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>Despite the method name, the test doesn't expect a request signal from {@code Subscriber} and emits the\n-   * {@code onError} signal anyway.\n-   * <\/ul>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>if the {@code Subscriber} throws an unchecked exception from its {@code onSubscribe} or\n-   * {@code onError} methods.\n-   * <\/ul>\n-   *\/\n-  void required_spec210_blackbox_mustBePreparedToReceiveAnOnErrorSignalWithPrecedingRequestCall() throws Throwable;\n-\n-  \/**\n-   * Asks for a {@code Subscriber}, signals {@code onSubscribe} followed by an {@code onError} synchronously.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.10'>2.10<\/a>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>if the {@code Subscriber} throws an unchecked exception from its {@code onSubscribe} or\n-   * {@code onError} methods.\n-   * <\/ul>\n-   *\/\n-  void required_spec210_blackbox_mustBePreparedToReceiveAnOnErrorSignalWithoutPrecedingRequestCall() throws Throwable;\n-\n-  \/**\n-   * Currently, this test is skipped because it would require analyzing what the {@code Subscriber} implementation\n-   * does.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.11'>2.11<\/a>\n-   *\/\n-  void untested_spec211_blackbox_mustMakeSureThatAllCallsOnItsMethodsHappenBeforeTheProcessingOfTheRespectiveEvents() throws Exception;\n-  \/**\n-   * Currently, this test is skipped because the test for\n-   * {@link #required_spec205_blackbox_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal 2.5}\n-   * is in a better position to test for handling the reuse of the same {@code Subscriber}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.12'>2.12<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>In addition to 2.5, this rule could be better verified when testing a {@code Publisher}'s subscription behavior.\n-   * <\/ul>\n-   *\/\n-  void untested_spec212_blackbox_mustNotCallOnSubscribeMoreThanOnceBasedOnObjectEquality() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped because it would require more control over the {@code Subscriber} to\n-   * fail internally in response to a set of legal event emissions, not throw any exception from the {@code Subscriber}\n-   * methods and have it cancel the {@code Subscription}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.13'>2.13<\/a>\n-   *\/\n-  void untested_spec213_blackbox_failingOnSignalInvocation() throws Exception;\n-  \/**\n-   * Asks for a {@code Subscriber} and signals an {@code onSubscribe} event with {@code null} as a parameter and\n-   * expects an immediate {@code NullPointerException} to be thrown by the {@code Subscriber.onSubscribe} method.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.13'>2.13<\/a>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>if the {@code Subscriber} throws a {@code NullPointerException} from its {@code onSubscribe} method\n-   * in response to a {@code null} parameter and not some other unchecked exception or no exception at all.\n-   * <\/ul>\n-   *\/\n-  void required_spec213_blackbox_onSubscribe_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable;\n-  \/**\n-   * Asks for a {@code Subscriber}, signals an {@code onSubscribe} event followed by a\n-   * {@code onNext} with {@code null} as a parameter and\n-   * expects an immediate {@code NullPointerException} to be thrown by the {@code Subscriber.onNext} method.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.13'>2.13<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>The test ignores cancellation and requests from the {@code Subscriber} and emits the {@code onNext}\n-   * signal with a {@code null} parameter anyway.<\/li>\n-   * <\/ul>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>if the {@code Subscriber} throws a {@code NullPointerException} from its {@code onNext} method\n-   * in response to a {@code null} parameter and not some other unchecked exception or no exception at all.\n-   * <\/ul>\n-   *\/\n-  void required_spec213_blackbox_onNext_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable;\n-  \/**\n-   * Asks for a {@code Subscriber}, signals an {@code onSubscribe} event followed by a\n-   * {@code onError} with {@code null} as a parameter and\n-   * expects an immediate {@code NullPointerException} to be thrown by the {@code Subscriber.onError} method.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#2.13'>2.13<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>The test ignores cancellation from the {@code Subscriber} and emits the {@code onError}\n-   * signal with a {@code null} parameter anyway.<\/li>\n-   * <\/ul>\n-   * <p>\n-   * If this test fails, the following could be checked within the {@code Subscriber} implementation:\n-   * <ul>\n-   * <li>if the {@code Subscriber} throws a {@code NullPointerException} from its {@code onNext} method\n-   * in response to a {@code null} parameter and not some other unchecked exception or no exception at all.\n-   * <\/ul>\n-   *\/\n-  void required_spec213_blackbox_onError_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped because there is no agreed upon way for specifying, enforcing and testing\n-   * a {@code Subscriber} with an arbitrary context.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.1'>3.1<\/a>\n-   *\/\n-  void untested_spec301_blackbox_mustNotBeCalledOutsideSubscriberContext() throws Exception;\n-  \/**\n-   * Currently, this test is skipped because element production is the responsibility of the {@code Publisher} and\n-   * a {@code Subscription} is not expected to be the active element in an established subscription.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.8'>3.8<\/a>\n-   *\/\n-  void untested_spec308_blackbox_requestMustRegisterGivenNumberElementsToBeProduced() throws Throwable;\n-  \/**\n-   * Currently, this test is skipped because element production is the responsibility of the {@code Publisher} and\n-   * a {@code Subscription} is not expected to be the active element in an established subscription.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.10'>3.10<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>This could be tested with a synchronous source currently not available within the TCK.<\/li>\n-   * <\/ul>\n-   *\/\n-  void untested_spec310_blackbox_requestMaySynchronouslyCallOnNextOnSubscriber() throws Exception;\n-  \/**\n-   * Currently, this test is skipped because signal production is the responsibility of the {@code Publisher} and\n-   * a {@code Subscription} is not expected to be the active element in an established subscription.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.11'>3.11<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>Tests {@link #required_spec209_blackbox_mustBePreparedToReceiveAnOnCompleteSignalWithPrecedingRequestCall() 2.9}\n-   * and {@link #required_spec210_blackbox_mustBePreparedToReceiveAnOnErrorSignalWithPrecedingRequestCall() 2.10} are\n-   * supposed to cover this case from the {@code Subscriber's} perspective.<\/li>\n-   * <\/ul>\n-   *\/\n-  void untested_spec311_blackbox_requestMaySynchronouslyCallOnCompleteOrOnError() throws Exception;\n-  \/**\n-   * Currently, this test is skipped because it is the responsibility of the {@code Publisher} deal with the case\n-   * that all subscribers have cancelled their subscription.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.14'>3.14<\/a>\n-   * <p>\n-   * Notes:\n-   * <ul>\n-   * <li>The specification lists this as an optional behavior because only some {@code Publisher} implementations\n-   * (most likely {@code Processor}s) would coordinate with multiple {@code Subscriber}s.<\/li>\n-   * <\/ul>\n-   *\/\n-  void untested_spec314_blackbox_cancelMayCauseThePublisherToShutdownIfNoOtherSubscriptionExists() throws Exception;\n-  \/**\n-   * Currently, this test is skipped because it requires more control over the {@code Subscriber} implementation\n-   * thus there is no way to detect that the {@code Subscriber} called its own {@code onError} method in response\n-   * to an exception thrown from {@code Subscription.cancel}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.15'>3.15<\/a>\n-   *\/\n-  void untested_spec315_blackbox_cancelMustNotThrowExceptionAndMustSignalOnError() throws Exception;\n-  \/**\n-   * Currently, this test is skipped because it requires more control over the {@code Subscriber} implementation\n-   * thus there is no way to detect that the {@code Subscriber} called its own {@code onError} method in response\n-   * to an exception thrown from {@code Subscription.request}.\n-   * <p>\n-   * <b>Verifies rule:<\/b> <a href='https:\/\/github.com\/reactive-streams\/reactive-streams-jvm#3.16'>3.16<\/a>\n-   *\/\n-  void untested_spec316_blackbox_requestMustNotThrowExceptionAndMustOnErrorTheSubscriber() throws Exception;\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/support\/SubscriberBlackboxVerificationRules.java","additions":0,"deletions":395,"binary":false,"changes":395,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow.support;\n-\n-public final class SubscriberBufferOverflowException extends RuntimeException {\n-  public SubscriberBufferOverflowException() {\n-  }\n-\n-  public SubscriberBufferOverflowException(String message) {\n-    super(message);\n-  }\n-\n-  public SubscriberBufferOverflowException(String message, Throwable cause) {\n-    super(message, cause);\n-  }\n-\n-  public SubscriberBufferOverflowException(Throwable cause) {\n-    super(cause);\n-  }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/support\/SubscriberBufferOverflowException.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow.support;\n-\n-\/**\n- * Internal TCK use only.\n- * Add \/ Remove tests for PublisherVerificaSubscriberWhiteboxVerification here to make sure that they arre added\/removed in the other places.\n- *\/\n-public interface SubscriberWhiteboxVerificationRules {\n-  void required_exerciseWhiteboxHappyPath() throws Throwable;\n-  void required_spec201_mustSignalDemandViaSubscriptionRequest() throws Throwable;\n-  void untested_spec202_shouldAsynchronouslyDispatch() throws Exception;\n-  void required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnComplete() throws Throwable;\n-  void required_spec203_mustNotCallMethodsOnSubscriptionOrPublisherInOnError() throws Throwable;\n-  void untested_spec204_mustConsiderTheSubscriptionAsCancelledInAfterRecievingOnCompleteOrOnError() throws Exception;\n-  void required_spec205_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal() throws Throwable;\n-  void untested_spec206_mustCallSubscriptionCancelIfItIsNoLongerValid() throws Exception;\n-  void untested_spec207_mustEnsureAllCallsOnItsSubscriptionTakePlaceFromTheSameThreadOrTakeCareOfSynchronization() throws Exception;\n-  void required_spec208_mustBePreparedToReceiveOnNextSignalsAfterHavingCalledSubscriptionCancel() throws Throwable;\n-  void required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithPrecedingRequestCall() throws Throwable;\n-  void required_spec209_mustBePreparedToReceiveAnOnCompleteSignalWithoutPrecedingRequestCall() throws Throwable;\n-  void required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithPrecedingRequestCall() throws Throwable;\n-  void required_spec210_mustBePreparedToReceiveAnOnErrorSignalWithoutPrecedingRequestCall() throws Throwable;\n-  void untested_spec211_mustMakeSureThatAllCallsOnItsMethodsHappenBeforeTheProcessingOfTheRespectiveEvents() throws Exception;\n-  void untested_spec212_mustNotCallOnSubscribeMoreThanOnceBasedOnObjectEquality_specViolation() throws Throwable;\n-  void untested_spec213_failingOnSignalInvocation() throws Exception;\n-  void required_spec213_onSubscribe_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable;\n-  void required_spec213_onNext_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable;\n-  void required_spec213_onError_mustThrowNullPointerExceptionWhenParametersAreNull() throws Throwable;\n-  void untested_spec301_mustNotBeCalledOutsideSubscriberContext() throws Exception;\n-  void required_spec308_requestMustRegisterGivenNumberElementsToBeProduced() throws Throwable;\n-  void untested_spec310_requestMaySynchronouslyCallOnNextOnSubscriber() throws Exception;\n-  void untested_spec311_requestMaySynchronouslyCallOnCompleteOrOnError() throws Exception;\n-  void untested_spec314_cancelMayCauseThePublisherToShutdownIfNoOtherSubscriptionExists() throws Exception;\n-  void untested_spec315_cancelMustNotThrowExceptionAndMustSignalOnError() throws Exception;\n-  void untested_spec316_requestMustNotThrowExceptionAndMustOnErrorTheSubscriber() throws Exception;\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/support\/SubscriberWhiteboxVerificationRules.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.reactivestreams.tck.flow.support;\n-\n-\/**\n- * Exception used by the TCK to signal failures.\n- * May be thrown or signalled through {@link org.reactivestreams.Subscriber#onError(Throwable)}.\n- *\/\n-public final class TestException extends RuntimeException {\n-  public TestException() {\n-    super(\"Test Exception: Boom!\");\n-  }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/reactivestreams-tck\/org\/reactivestreams\/tck\/flow\/support\/TestException.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"}]}