{"files":[{"patch":"@@ -127,0 +127,4 @@\n+  \/\/ To allow lock-free iteration of the output list the updates in the loops\n+  \/\/ below require release semantics.\n+  OrderAccess::release();\n+\n@@ -129,2 +133,3 @@\n-    if (_level_start[l] == NULL || _level_start[l]->_level < level) {\n-      _level_start[l] = node;\n+    LogOutputNode* lnode = Atomic::load(&_level_start[l]);\n+    if (lnode == nullptr || lnode->_level < level) {\n+      Atomic::store(&_level_start[l], node);\n@@ -135,3 +140,3 @@\n-  for (LogOutputNode* cur = _level_start[LogLevel::Last]; cur != NULL; cur = cur->_next) {\n-    if (cur != node && cur->_next == node->_next) {\n-      cur->_next = node;\n+  for (LogOutputNode* cur = Atomic::load(&_level_start[LogLevel::Last]); cur != nullptr; cur = Atomic::load(&cur->_next)) {\n+    if (cur != node && Atomic::load(&cur->_next) == node->_next) {\n+      Atomic::store(&cur->_next, node);\n","filename":"src\/hotspot\/share\/logging\/logOutputList.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -51,1 +52,1 @@\n-    LogOutputNode*  _next;\n+    LogOutputNode* volatile _next;\n@@ -55,1 +56,1 @@\n-  LogOutputNode*  _level_start[LogLevel::Count];\n+  LogOutputNode* volatile _level_start[LogLevel::Count];\n@@ -127,1 +128,3 @@\n-      _current = _current->_next;\n+      \/\/ FIXME: memory_order_consume could be used here.\n+      \/\/ Atomic access on the reading side for LogOutputList.\n+      _current = Atomic::load_acquire(&_current->_next);\n@@ -141,1 +144,3 @@\n-    return Iterator(this, _level_start[level]);\n+    \/\/ FIXME: memory_order_consume could be used here.\n+    \/\/ Atomic access on the reading side for LogOutputList.\n+    return Iterator(this, Atomic::load_acquire(&_level_start[level]));\n","filename":"src\/hotspot\/share\/logging\/logOutputList.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"}]}