{"files":[{"patch":"@@ -137,1 +137,10 @@\n-#define starti Instruction_aarch64 do_not_use(this); set_current(&do_not_use)\n+#define starti Instruction_aarch64 current_insn(this);\n+\n+#define f current_insn.f\n+#define sf current_insn.sf\n+#define rf current_insn.rf\n+#define srf current_insn.srf\n+#define zrf current_insn.zrf\n+#define prf current_insn.prf\n+#define pgrf current_insn.pgrf\n+#define fixed current_insn.fixed\n@@ -159,0 +168,47 @@\n+\/\/ An \"all-purpose\" add\/subtract immediate, per ARM documentation:\n+\/\/ A \"programmer-friendly\" assembler may accept a negative immediate\n+\/\/ between -(2^24 -1) and -1 inclusive, causing it to convert a\n+\/\/ requested ADD operation to a SUB, or vice versa, and then encode\n+\/\/ the absolute value of the immediate as for uimm24.\n+void Assembler::add_sub_immediate(Instruction_aarch64 &current_insn,\n+                                  Register Rd, Register Rn, unsigned uimm, int op,\n+                                  int negated_op) {\n+  bool sets_flags = op & 1;   \/\/ this op sets flags\n+  union {\n+    unsigned u;\n+    int imm;\n+  };\n+  u = uimm;\n+  bool shift = false;\n+  bool neg = imm < 0;\n+  if (neg) {\n+    imm = -imm;\n+    op = negated_op;\n+  }\n+  assert(Rd != sp || imm % 16 == 0, \"misaligned stack\");\n+  if (imm >= (1 << 11)\n+      && ((imm >> 12) << 12 == imm)) {\n+    imm >>= 12;\n+    shift = true;\n+  }\n+  f(op, 31, 29), f(0b10001, 28, 24), f(shift, 23, 22), f(imm, 21, 10);\n+\n+  \/\/ add\/subtract immediate ops with the S bit set treat r31 as zr;\n+  \/\/ with S unset they use sp.\n+  if (sets_flags)\n+    zrf(Rd, 0);\n+  else\n+    srf(Rd, 0);\n+\n+  srf(Rn, 5);\n+}\n+\n+#undef f\n+#undef sf\n+#undef rf\n+#undef srf\n+#undef zrf\n+#undef prf\n+#undef pgrf\n+#undef fixed\n+\n@@ -263,37 +319,0 @@\n-\/\/ An \"all-purpose\" add\/subtract immediate, per ARM documentation:\n-\/\/ A \"programmer-friendly\" assembler may accept a negative immediate\n-\/\/ between -(2^24 -1) and -1 inclusive, causing it to convert a\n-\/\/ requested ADD operation to a SUB, or vice versa, and then encode\n-\/\/ the absolute value of the immediate as for uimm24.\n-void Assembler::add_sub_immediate(Register Rd, Register Rn, unsigned uimm, int op,\n-                                  int negated_op) {\n-  bool sets_flags = op & 1;   \/\/ this op sets flags\n-  union {\n-    unsigned u;\n-    int imm;\n-  };\n-  u = uimm;\n-  bool shift = false;\n-  bool neg = imm < 0;\n-  if (neg) {\n-    imm = -imm;\n-    op = negated_op;\n-  }\n-  assert(Rd != sp || imm % 16 == 0, \"misaligned stack\");\n-  if (imm >= (1 << 11)\n-      && ((imm >> 12) << 12 == imm)) {\n-    imm >>= 12;\n-    shift = true;\n-  }\n-  f(op, 31, 29), f(0b10001, 28, 24), f(shift, 23, 22), f(imm, 21, 10);\n-\n-  \/\/ add\/subtract immediate ops with the S bit set treat r31 as zr;\n-  \/\/ with S unset they use sp.\n-  if (sets_flags)\n-    zrf(Rd, 0);\n-  else\n-    srf(Rd, 0);\n-\n-  srf(Rn, 5);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":57,"deletions":38,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -250,1 +250,0 @@\n-    unsigned mask = checked_cast<unsigned>(right_n_bits(nbits));\n@@ -252,1 +251,0 @@\n-    mask <<= lsb;\n@@ -254,1 +252,0 @@\n-    assert_cond((bits & mask) == 0);\n@@ -256,0 +253,3 @@\n+    unsigned mask = checked_cast<unsigned>(right_n_bits(nbits));\n+    mask <<= lsb;\n+    assert_cond((bits & mask) == 0);\n@@ -316,1 +316,1 @@\n-#define starti Instruction_aarch64 do_not_use(this); set_current(&do_not_use)\n+#define starti Instruction_aarch64 current_insn(this);\n@@ -698,40 +698,8 @@\n-  Instruction_aarch64* current;\n-\n-  void set_current(Instruction_aarch64* i) { current = i; }\n-\n-  void f(unsigned val, int msb, int lsb) {\n-    current->f(val, msb, lsb);\n-  }\n-  void f(unsigned val, int msb) {\n-    current->f(val, msb, msb);\n-  }\n-  void sf(int64_t val, int msb, int lsb) {\n-    current->sf(val, msb, lsb);\n-  }\n-  void rf(Register reg, int lsb) {\n-    current->rf(reg, lsb);\n-  }\n-  void srf(Register reg, int lsb) {\n-    current->srf(reg, lsb);\n-  }\n-  void zrf(Register reg, int lsb) {\n-    current->zrf(reg, lsb);\n-  }\n-  void rf(FloatRegister reg, int lsb) {\n-    current->rf(reg, lsb);\n-  }\n-  void prf(PRegister reg, int lsb) {\n-    current->prf(reg, lsb);\n-  }\n-  void pgrf(PRegister reg, int lsb) {\n-    current->pgrf(reg, lsb);\n-  }\n-  void fixed(unsigned value, unsigned mask) {\n-    current->fixed(value, mask);\n-  }\n-\n-  void emit() {\n-    emit_long(current->get_insn());\n-    assert_cond(current->get_bits() == 0xffffffff);\n-    current = NULL;\n-  }\n+#define f current_insn.f\n+#define sf current_insn.sf\n+#define rf current_insn.rf\n+#define srf current_insn.srf\n+#define zrf current_insn.zrf\n+#define prf current_insn.prf\n+#define pgrf current_insn.pgrf\n+#define fixed current_insn.fixed\n@@ -768,2 +736,2 @@\n-  void add_sub_immediate(Register Rd, Register Rn, unsigned uimm, int op,\n-                         int negated_op);\n+  void add_sub_immediate(Instruction_aarch64 &current_insn, Register Rd, Register Rn,\n+                         unsigned uimm, int op, int negated_op);\n@@ -781,1 +749,1 @@\n-    add_sub_immediate(Rd, Rn, imm, decode, negated);                    \\\n+    add_sub_immediate(current_insn, Rd, Rn, imm, decode, negated);      \\\n@@ -794,1 +762,1 @@\n-    add_sub_immediate(Rd, Rn, imm, decode, negated);    \\\n+    add_sub_immediate(current_insn, Rd, Rn, imm, decode, negated);     \\\n@@ -1096,1 +1064,1 @@\n-           Register rt = (Register)0b11111) {\n+           Register rt = as_Register(0b11111)) {\n@@ -1365,1 +1333,1 @@\n-    rf((Register)Rt, 0);                                                \\\n+    rf(as_Register(Rt), 0);                                             \\\n@@ -1379,1 +1347,1 @@\n-    rf(Rn, 5), rf((Register)Rt, 0);                                     \\\n+    rf(Rn, 5), rf(as_Register(Rt), 0);                                  \\\n@@ -1412,1 +1380,1 @@\n-      adr.encode_nontemporal_pair(current);\n+      adr.encode_nontemporal_pair(&current_insn);\n@@ -1414,1 +1382,1 @@\n-      adr.encode_pair(current);\n+      adr.encode_pair(&current_insn);\n@@ -1440,1 +1408,2 @@\n-    ld_st1(size, p1, V, L, (Register)Rt1, (Register)Rt2, adr, no_allocate); \\\n+    ld_st1(size, p1, V, L,                                              \\\n+           as_Register(Rt1), as_Register(Rt2), adr, no_allocate);       \\\n@@ -1475,1 +1444,1 @@\n-    adr.encode(current);\n+    adr.encode(&current_insn);\n@@ -1503,1 +1472,1 @@\n-    ld_st2((Register)pfop, adr, size, op);                      \\\n+    ld_st2(as_Register(pfop), adr, size, op);                   \\\n@@ -1514,1 +1483,1 @@\n-    ld_st2((Register)Rt, adr, size, op, 1);             \\\n+    ld_st2(as_Register(Rt), adr, size, op, 1);          \\\n@@ -1551,1 +1520,1 @@\n-  void op_shifted_reg(unsigned decode,\n+  void op_shifted_reg(Instruction_aarch64 &current_insn, unsigned decode,\n@@ -1562,8 +1531,8 @@\n-#define INSN(NAME, size, op, N)                                 \\\n-  void NAME(Register Rd, Register Rn, Register Rm,              \\\n-            enum shift_kind kind = LSL, unsigned shift = 0) {   \\\n-    starti;                                                     \\\n-    guarantee(size == 1 || shift < 32, \"incorrect shift\");      \\\n-    f(N, 21);                                                   \\\n-    zrf(Rm, 16), zrf(Rn, 5), zrf(Rd, 0);                        \\\n-    op_shifted_reg(0b01010, kind, shift, size, op);             \\\n+#define INSN(NAME, size, op, N)                                         \\\n+  void NAME(Register Rd, Register Rn, Register Rm,                      \\\n+            enum shift_kind kind = LSL, unsigned shift = 0) {           \\\n+    starti;                                                             \\\n+    guarantee(size == 1 || shift < 32, \"incorrect shift\");              \\\n+    f(N, 21);                                                           \\\n+    zrf(Rm, 16), zrf(Rn, 5), zrf(Rd, 0);                                \\\n+    op_shifted_reg(current_insn, 0b01010, kind, shift, size, op);       \\\n@@ -1589,1 +1558,1 @@\n-    op_shifted_reg(0b01010, kind, shift, size, op);                     \\\n+    op_shifted_reg(current_insn, 0b01010, kind, shift, size, op);       \\\n@@ -1636,1 +1605,1 @@\n-    op_shifted_reg(0b01011, kind, shift, size, op);     \\\n+    op_shifted_reg(current_insn, 0b01011, kind, shift, size, op);      \\\n@@ -1657,1 +1626,1 @@\n-    add_sub_extended_reg(op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \\\n+    add_sub_extended_reg(current_insn, op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \\\n@@ -1660,1 +1629,1 @@\n-  void add_sub_extended_reg(unsigned op, unsigned decode,\n+  void add_sub_extended_reg(Instruction_aarch64 &current_insn, unsigned op, unsigned decode,\n@@ -1680,1 +1649,1 @@\n-    add_sub_extended_reg(op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \\\n+    add_sub_extended_reg(current_insn, op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \\\n@@ -1781,1 +1750,1 @@\n-  void NAME(Register Rd, Register Rn, Register Rm, Condition cond) { \\\n+  void NAME(Register Rd, Register Rn, Register Rm, Condition cond) {    \\\n@@ -1797,1 +1766,1 @@\n-  void data_processing(unsigned op29, unsigned opcode,\n+  void data_processing(Instruction_aarch64 &current_insn, unsigned op29, unsigned opcode,\n@@ -1805,5 +1774,5 @@\n-#define INSN(NAME, op29, opcode2, opcode)       \\\n-  void NAME(Register Rd, Register Rn) {         \\\n-    starti;                                     \\\n-    f(opcode2, 20, 16);                         \\\n-    data_processing(op29, opcode, Rd, Rn);      \\\n+#define INSN(NAME, op29, opcode2, opcode)                       \\\n+  void NAME(Register Rd, Register Rn) {                         \\\n+    starti;                                                     \\\n+    f(opcode2, 20, 16);                                         \\\n+    data_processing(current_insn, op29, opcode, Rd, Rn);        \\\n@@ -1828,5 +1797,5 @@\n-#define INSN(NAME, op29, opcode)                        \\\n-  void NAME(Register Rd, Register Rn, Register Rm) {    \\\n-    starti;                                             \\\n-    rf(Rm, 16);                                         \\\n-    data_processing(op29, opcode, Rd, Rn);              \\\n+#define INSN(NAME, op29, opcode)                                \\\n+  void NAME(Register Rd, Register Rn, Register Rm) {            \\\n+    starti;                                                     \\\n+    rf(Rm, 16);                                                 \\\n+    data_processing(current_insn, op29, opcode, Rd, Rn);        \\\n@@ -1877,3 +1846,3 @@\n-#define INSN(NAME, op54, op31, o0)                      \\\n-  void NAME(Register Rd, Register Rn, Register Rm) {    \\\n-    data_processing(op54, op31, o0, Rd, Rn, Rm, (Register)31);  \\\n+#define INSN(NAME, op54, op31, o0)                                      \\\n+  void NAME(Register Rd, Register Rn, Register Rm) {                    \\\n+    data_processing(op54, op31, o0, Rd, Rn, Rm, as_Register(31));       \\\n@@ -2058,1 +2027,1 @@\n-    float_int_convert(op31, type, rmode, opcode, Rd, (Register)Vn);     \\\n+    float_int_convert(op31, type, rmode, opcode, Rd, as_Register(Vn));  \\\n@@ -2075,1 +2044,1 @@\n-    float_int_convert(op31, type, rmode, opcode, (Register)Vd, Rn);     \\\n+    float_int_convert(op31, type, rmode, opcode, as_Register(Vd), Rn);  \\\n@@ -2130,1 +2099,1 @@\n-                     FloatRegister Vn, FloatRegister Vm = (FloatRegister)0) {\n+                     FloatRegister Vn, FloatRegister Vm = as_FloatRegister(0)) {\n@@ -2260,4 +2229,4 @@\n-#define INSN(NAME, op)                                            \\\n-  void NAME(FloatRegister Rt, SIMD_RegVariant T, const Address &adr) {   \\\n-    ld_st2((Register)Rt, adr, (int)T & 3, op + ((T==Q) ? 0b10:0b00), 1); \\\n-  }                                                                      \\\n+#define INSN(NAME, op)                                                  \\\n+  void NAME(FloatRegister Rt, SIMD_RegVariant T, const Address &adr) {  \\\n+    ld_st2(as_Register(Rt), adr, (int)T & 3, op + ((T==Q) ? 0b10:0b00), 1); \\\n+  }\n@@ -3276,1 +3245,2 @@\n-  assem->emit();\n+  assem->emit_int32(insn);\n+  assert_cond(get_bits() == 0xffffffff);\n@@ -3279,0 +3249,9 @@\n+#undef f\n+#undef sf\n+#undef rf\n+#undef srf\n+#undef zrf\n+#undef prf\n+#undef pgrf\n+#undef fixed\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":73,"deletions":94,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+  const Register (*to_Register)(int) = as_Register;\n@@ -50,1 +51,1 @@\n-  loadArray(inputStorage, INTEGER_TYPE, abi._integer_argument_registers, as_Register);\n+  loadArray(inputStorage, INTEGER_TYPE, abi._integer_argument_registers, to_Register);\n@@ -54,1 +55,1 @@\n-  loadArray(outputStorage, INTEGER_TYPE, abi._integer_return_registers, as_Register);\n+  loadArray(outputStorage, INTEGER_TYPE, abi._integer_return_registers, to_Register);\n@@ -58,1 +59,1 @@\n-  loadArray(volatileStorage, INTEGER_TYPE, abi._integer_additional_volatile_registers, as_Register);\n+  loadArray(volatileStorage, INTEGER_TYPE, abi._integer_additional_volatile_registers, to_Register);\n","filename":"src\/hotspot\/cpu\/aarch64\/foreign_globals_aarch64.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-inline Register as_Register(int encoding) {\n+inline const Register as_Register(int encoding) {\n@@ -56,1 +56,1 @@\n-  inline friend Register as_Register(int encoding);\n+  inline friend const Register as_Register(int encoding);\n@@ -429,0 +429,4 @@\n+inline Register as_Register(FloatRegister reg) {\n+  return as_Register(reg->encoding());\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -225,1 +225,5 @@\n-  void emit_int32(int32_t x) { *((int32_t*) end()) = x; set_end(end() + sizeof(int32_t)); }\n+  void emit_int32(int32_t x) {\n+    address curr = end();\n+    *((int32_t*) curr) = x;\n+    set_end(curr + sizeof(int32_t));\n+  }\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}