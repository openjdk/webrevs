{"files":[{"patch":"@@ -2556,1 +2556,1 @@\n-            h = h * 43 + Objects.hashCode(e.name());\n+            h += e.name().hashCode();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/ModuleDescriptor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,0 @@\n-import org.testng.annotations.Test;\n-\n@@ -29,0 +27,3 @@\n+import java.lang.module.ModuleDescriptor.Exports;\n+import java.lang.module.ModuleDescriptor.Opens;\n+import java.lang.module.ModuleDescriptor.Requires;\n@@ -31,0 +32,1 @@\n+import org.testng.annotations.Test;\n@@ -36,1 +38,2 @@\n- * @bug 8275509\n+ * @bug 8275509 8290041\n+ * @summary Tests the ModuleDescriptor.hashCode()\n@@ -39,1 +42,0 @@\n- * @summary Tests the ModuleDescriptor.hashCode() for boot layer modules\n@@ -66,0 +68,93 @@\n+    \/**\n+     * Verifies that two \"equal\" module descriptors which only differ in the order of\n+     * {@link ModuleDescriptor.Opens.Modifier opens modifiers}, that were used to construct the\n+     * descriptors, have the same hashcode.\n+     *\/\n+    @Test\n+    public void testOpensModifiersOrdering() throws Exception {\n+        \/\/ important to use Set.of() (i.e. backed by immutable set) to reproduce the issue\n+        final Set<Opens.Modifier> mods1 = Set.of(Opens.Modifier.SYNTHETIC, Opens.Modifier.MANDATED);\n+        final ModuleDescriptor desc1 = createModuleDescriptor(mods1, null, null);\n+\n+        \/\/ create the same module descriptor again and this time just change the order of the\n+        \/\/ \"opens\" modifiers' Set.\n+\n+        \/\/ important to use Set.of() (i.e. backed by immutable set) to reproduce the issue\n+        final Set<Opens.Modifier> mods2 = Set.of(Opens.Modifier.MANDATED, Opens.Modifier.SYNTHETIC);\n+        final ModuleDescriptor desc2 = createModuleDescriptor(mods2, null, null);\n+\n+        \/\/ basic verification of the modifiers themselves before we check the module descriptors\n+        assertEquals(mods1, mods2, \"Modifiers were expected to be equal\");\n+\n+        \/\/ now verify the module descriptors\n+        assertEquals(desc1, desc2, \"Module descriptors were expected to be equal\");\n+        assertEquals(desc1.compareTo(desc2), 0, \"compareTo was expected to return\" +\n+                \" 0 for module descriptors that are equal\");\n+        System.out.println(desc1 + \" hashcode = \" + desc1.hashCode());\n+        System.out.println(desc2 + \" hashcode = \" + desc2.hashCode());\n+        assertEquals(desc1.hashCode(), desc2.hashCode(), \"Module descriptor hashcodes\" +\n+                \" were expected to be equal\");\n+    }\n+\n+    \/**\n+     * Verifies that two \"equal\" module descriptors which only differ in the order of\n+     * {@link ModuleDescriptor.Exports.Modifier exports modifiers}, that were used to construct the\n+     * descriptors, have the same hashcode.\n+     *\/\n+    @Test\n+    public void testExportsModifiersOrdering() throws Exception {\n+        \/\/ important to use Set.of() (i.e. backed by immutable set) to reproduce the issue\n+        final Set<Exports.Modifier> mods1 = Set.of(Exports.Modifier.SYNTHETIC, Exports.Modifier.MANDATED);\n+        final ModuleDescriptor desc1 = createModuleDescriptor(null, null, mods1);\n+\n+        \/\/ create the same module descriptor again and this time just change the order of the\n+        \/\/ \"exports\" modifiers' Set.\n+\n+        \/\/ important to use Set.of() (i.e. backed by immutable set) to reproduce the issue\n+        final Set<Exports.Modifier> mods2 = Set.of(Exports.Modifier.MANDATED, Exports.Modifier.SYNTHETIC);\n+        final ModuleDescriptor desc2 = createModuleDescriptor(null, null, mods2);\n+\n+        \/\/ basic verification of the modifiers themselves before we check the module descriptors\n+        assertEquals(mods1, mods2, \"Modifiers were expected to be equal\");\n+\n+        \/\/ now verify the module descriptors\n+        assertEquals(desc1, desc2, \"Module descriptors were expected to be equal\");\n+        assertEquals(desc1.compareTo(desc2), 0, \"compareTo was expected to return\" +\n+                \" 0 for module descriptors that are equal\");\n+        System.out.println(desc1 + \" hashcode = \" + desc1.hashCode());\n+        System.out.println(desc2 + \" hashcode = \" + desc2.hashCode());\n+        assertEquals(desc1.hashCode(), desc2.hashCode(), \"Module descriptor hashcodes\" +\n+                \" were expected to be equal\");\n+    }\n+\n+    \/**\n+     * Verifies that two \"equal\" module descriptors which only differ in the order of\n+     * {@link ModuleDescriptor.Requires.Modifier requires modifiers}, that were used to construct the\n+     * descriptors, have the same hashcode.\n+     *\/\n+    @Test\n+    public void testRequiresModifiersOrdering() throws Exception {\n+        \/\/ important to use Set.of() (i.e. backed by immutable set) to reproduce the issue\n+        final Set<Requires.Modifier> mods1 = Set.of(Requires.Modifier.SYNTHETIC, Requires.Modifier.MANDATED);\n+        final ModuleDescriptor desc1 = createModuleDescriptor(null, mods1, null);\n+\n+        \/\/ create the same module descriptor again and this time just change the order of the\n+        \/\/ \"exports\" modifiers' Set.\n+\n+        \/\/ important to use Set.of() (i.e. backed by immutable set) to reproduce the issue\n+        final Set<Requires.Modifier> mods2 = Set.of(Requires.Modifier.MANDATED, Requires.Modifier.SYNTHETIC);\n+        final ModuleDescriptor desc2 = createModuleDescriptor(null, mods2, null);\n+\n+        \/\/ basic verification of the modifiers themselves before we check the module descriptors\n+        assertEquals(mods1, mods2, \"Modifiers were expected to be equal\");\n+\n+        \/\/ now verify the module descriptors\n+        assertEquals(desc1, desc2, \"Module descriptors were expected to be equal\");\n+        assertEquals(desc1.compareTo(desc2), 0, \"compareTo was expected to return\" +\n+                \" 0 for module descriptors that are equal\");\n+        System.out.println(desc1 + \" hashcode = \" + desc1.hashCode());\n+        System.out.println(desc2 + \" hashcode = \" + desc2.hashCode());\n+        assertEquals(desc1.hashCode(), desc2.hashCode(), \"Module descriptor hashcodes\" +\n+                \" were expected to be equal\");\n+    }\n+\n@@ -76,0 +171,19 @@\n+\n+    \/\/ creates a module descriptor with passed (optional) opens\/exports\/requires modifiers\n+    private static ModuleDescriptor createModuleDescriptor(\n+            Set<Opens.Modifier> opensModifiers,\n+            Set<Requires.Modifier> reqsModifiers,\n+            Set<Exports.Modifier> expsModifiers) {\n+\n+        final ModuleDescriptor.Builder builder = ModuleDescriptor.newModule(\"foobar\");\n+        if (opensModifiers != null) {\n+            builder.opens(opensModifiers, \"a.p1\", Set.of(\"a.m1\"));\n+        }\n+        if (reqsModifiers != null) {\n+            builder.requires(reqsModifiers, \"a.m2\");\n+        }\n+        if (expsModifiers != null) {\n+            builder.exports(expsModifiers, \"a.b.c\", Set.of(\"a.m3\"));\n+        }\n+        return builder.build();\n+    }\n","filename":"test\/jdk\/java\/lang\/module\/ModuleDescriptorHashCodeTest.java","additions":119,"deletions":5,"binary":false,"changes":124,"status":"modified"}]}