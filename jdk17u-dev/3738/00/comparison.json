{"files":[{"patch":"@@ -1375,1 +1375,1 @@\n-# JNDI Object Factories Filter\n+# Global JNDI Object Factories Filter\n@@ -1381,1 +1381,2 @@\n-# with the same format as jdk.serialFilter.\n+# with the same format as jdk.serialFilter. Limit patterns specified in the filter property\n+# are unused.\n@@ -1383,3 +1384,3 @@\n-# Each pattern is matched against the factory class name to allow or disallow it's\n-# instantiation. The access to a factory class is allowed unless the filter returns\n-# REJECTED.\n+# Each class name pattern is matched against the factory class name to allow or disallow its\n+# instantiation. The access to a factory class is allowed if the filter returns\n+# ALLOWED.\n@@ -1396,0 +1397,52 @@\n+\n+#\n+# Protocol Specific JNDI\/LDAP Object Factories Filter\n+#\n+# This filter is used by the JNDI\/LDAP provider implementation in the JDK to further control the\n+# set of object factory classes which will be allowed to instantiate objects from object\n+# references bound to LDAP contexts. The factory class named by the reference instance will\n+# be matched against this filter. The filter property supports pattern-based filter syntax\n+# with the same format as jdk.serialFilter. Limit patterns specified in the filter property\n+# are unused.\n+#\n+# Each class name pattern is matched against the factory class name to allow or disallow its\n+# instantiation. The access to a factory class is allowed only when it is not rejected by this filter\n+# or by the global filter defined by \"jdk.jndi.object.factoriesFilter\", and at least one of these\n+# two filters returns ALLOWED.\n+#\n+# Note: This property is currently used by the JDK Reference implementation.\n+# It is not guaranteed to be examined and used by other implementations.\n+#\n+# If the system property jdk.jndi.ldap.object.factoriesFilter is also specified, it supersedes\n+# the security property value defined here. The default value of the property is\n+# \"java.naming\/com.sun.jndi.ldap.**;!*\".\n+#\n+# The default pattern value allows any object factory class defined in the java.naming module\n+# to be specified by the reference instance, but rejects any other.\n+#jdk.jndi.ldap.object.factoriesFilter=java.naming\/com.sun.jndi.ldap.**;!*\n+\n+#\n+# Protocol Specific JNDI\/RMI Object Factories Filter\n+#\n+# This filter is used by the JNDI\/RMI provider implementation in the JDK to further control the\n+# set of object factory classes which will be allowed to instantiate objects from object\n+# references bound to RMI names. The factory class named by the reference instance will\n+# be matched against this filter. The filter property supports pattern-based filter syntax\n+# with the same format as jdk.serialFilter. Limit patterns specified in the filter property\n+# are unused.\n+#\n+# Each class name pattern is matched against the factory class name to allow or disallow its\n+# instantiation. The access to a factory class is allowed only when it is not rejected by this filter\n+# or by the global filter defined by \"jdk.jndi.object.factoriesFilter\", and at least one of these\n+# two filters returns ALLOWED.\n+#\n+# Note: This property is currently used by the JDK Reference implementation.\n+# It is not guaranteed to be examined and used by other implementations.\n+#\n+# If the system property jdk.jndi.rmi.object.factoriesFilter is also specified, it supersedes\n+# the security property value defined here. The default value of the property is\n+# \"jdk.naming.rmi\/com.sun.jndi.rmi.**;!*\".\n+#\n+# The default pattern value allows any object factory class defined in the jdk.naming.rmi module\n+# to be specified by the reference instance, but rejects any other.\n+#jdk.jndi.rmi.object.factoriesFilter=jdk.naming.rmi\/com.sun.jndi.rmi.**;!*\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":58,"deletions":5,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import javax.naming.spi.*;\n@@ -39,0 +38,2 @@\n+import com.sun.naming.internal.NamingManagerHelper;\n+import com.sun.naming.internal.ObjectFactoriesFilter;\n@@ -79,2 +80,2 @@\n-            obj = DirectoryManager.getObjectInstance(obj, cn, homeCtx,\n-                homeCtx.envprops, attrs);\n+            obj = NamingManagerHelper.getDirObjectInstance(obj, cn, homeCtx,\n+                    homeCtx.envprops, attrs, ObjectFactoriesFilter::checkLdapFilter);\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapBindingEnumeration.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import javax.naming.spi.*;\n@@ -57,0 +56,2 @@\n+import com.sun.naming.internal.NamingManagerHelper;\n+import com.sun.naming.internal.ObjectFactoriesFilter;\n@@ -1114,2 +1115,2 @@\n-            return DirectoryManager.getObjectInstance(obj, name,\n-                this, envprops, attrs);\n+            return NamingManagerHelper.getDirObjectInstance(obj, name, this,\n+                    envprops, attrs, ObjectFactoriesFilter::checkLdapFilter);\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapCtx.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import javax.naming.spi.*;\n@@ -36,0 +35,2 @@\n+import com.sun.naming.internal.NamingManagerHelper;\n+import com.sun.naming.internal.ObjectFactoriesFilter;\n@@ -119,2 +120,2 @@\n-                obj = NamingManager.getObjectInstance(ref, null, null, env);\n-\n+                obj = NamingManagerHelper.getObjectInstance(ref, null, null,\n+                        env, ObjectFactoriesFilter::checkLdapFilter);\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapReferralContext.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import javax.naming.spi.*;\n@@ -40,0 +39,2 @@\n+import com.sun.naming.internal.NamingManagerHelper;\n+import com.sun.naming.internal.ObjectFactoriesFilter;\n@@ -137,1 +138,1 @@\n-                obj = DirectoryManager.getObjectInstance(\n+                obj = NamingManagerHelper.getDirObjectInstance(\n@@ -139,1 +140,1 @@\n-                    homeCtx.envprops, attrs);\n+                    homeCtx.envprops, attrs, ObjectFactoriesFilter::checkLdapFilter);\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapSearchEnumeration.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,422 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.naming.internal;\n+\n+import javax.naming.Context;\n+import javax.naming.Name;\n+import javax.naming.NamingException;\n+import javax.naming.RefAddr;\n+import javax.naming.Reference;\n+import javax.naming.Referenceable;\n+import javax.naming.StringRefAddr;\n+import javax.naming.directory.Attributes;\n+import javax.naming.spi.DirObjectFactory;\n+import javax.naming.spi.ObjectFactory;\n+import javax.naming.spi.ObjectFactoryBuilder;\n+import java.net.MalformedURLException;\n+import java.util.Hashtable;\n+import java.util.function.Predicate;\n+\n+public class NamingManagerHelper {\n+\n+    public static Object getObjectInstance(Object refInfo, Name name, Context nameCtx,\n+                                           Hashtable<?,?> environment,\n+                                           Predicate<Class<?>> factoryFilter) throws Exception {\n+        ObjectFactory factory;\n+\n+        \/\/ Use builder if installed\n+        ObjectFactoryBuilder builder = getObjectFactoryBuilder();\n+        if (builder != null) {\n+            \/\/ builder must return non-null factory\n+            factory = builder.createObjectFactory(refInfo, environment);\n+            return factory.getObjectInstance(refInfo, name, nameCtx,\n+                    environment);\n+        }\n+\n+        \/\/ Use reference if possible\n+        Reference ref = null;\n+        if (refInfo instanceof Reference) {\n+            ref = (Reference) refInfo;\n+        } else if (refInfo instanceof Referenceable) {\n+            ref = ((Referenceable)(refInfo)).getReference();\n+        }\n+\n+        Object answer;\n+\n+        if (ref != null) {\n+            String f = ref.getFactoryClassName();\n+            if (f != null) {\n+                \/\/ if reference identifies a factory, use exclusively\n+\n+                factory = getObjectFactoryFromReference(ref, f, factoryFilter);\n+                if (factory != null) {\n+                    return factory.getObjectInstance(ref, name, nameCtx,\n+                            environment);\n+                }\n+                \/\/ No factory found, so return original refInfo.\n+                \/\/ That could happen if:\n+                \/\/  - a factory class is not in a class path and reference does\n+                \/\/    not contain a URL for it\n+                \/\/  - a factory class is available but object factory filters\n+                \/\/    disallow its usage\n+                return refInfo;\n+\n+            } else {\n+                \/\/ if reference has no factory, check for addresses\n+                \/\/ containing URLs\n+\n+                answer = processURLAddrs(ref, name, nameCtx, environment);\n+                if (answer != null) {\n+                    return answer;\n+                }\n+            }\n+        }\n+\n+        \/\/ try using any specified factories\n+        answer =\n+                createObjectFromFactories(refInfo, name, nameCtx, environment);\n+        return (answer != null) ? answer : refInfo;\n+    }\n+\n+\n+    public static Object getDirObjectInstance(Object refInfo, Name name, Context nameCtx,\n+                      Hashtable<?,?> environment, Attributes attrs,\n+                      Predicate<Class<?>> factoryFilter) throws Exception {\n+        ObjectFactory factory;\n+\n+        ObjectFactoryBuilder builder = getObjectFactoryBuilder();\n+        if (builder != null) {\n+            \/\/ builder must return non-null factory\n+            factory = builder.createObjectFactory(refInfo, environment);\n+            if (factory instanceof DirObjectFactory) {\n+                return ((DirObjectFactory)factory).getObjectInstance(\n+                        refInfo, name, nameCtx, environment, attrs);\n+            } else {\n+                return factory.getObjectInstance(refInfo, name, nameCtx,\n+                        environment);\n+            }\n+        }\n+\n+        \/\/ use reference if possible\n+        Reference ref = null;\n+        if (refInfo instanceof Reference) {\n+            ref = (Reference) refInfo;\n+        } else if (refInfo instanceof Referenceable) {\n+            ref = ((Referenceable)(refInfo)).getReference();\n+        }\n+\n+        Object answer;\n+\n+        if (ref != null) {\n+            String f = ref.getFactoryClassName();\n+            if (f != null) {\n+                \/\/ if reference identifies a factory, use exclusively\n+\n+                factory = getObjectFactoryFromReference(ref, f, factoryFilter);\n+                if (factory instanceof DirObjectFactory) {\n+                    return ((DirObjectFactory)factory).getObjectInstance(\n+                            ref, name, nameCtx, environment, attrs);\n+                } else if (factory != null) {\n+                    return factory.getObjectInstance(ref, name, nameCtx,\n+                            environment);\n+                }\n+                \/\/ No factory found, so return original refInfo.\n+                \/\/ That could happen if:\n+                \/\/  - a factory class is not in a class path and reference does\n+                \/\/    not contain a URL for it\n+                \/\/  - a factory class is available but object factory filters\n+                \/\/    disallow its usage\n+                return refInfo;\n+\n+            } else {\n+                \/\/ if reference has no factory, check for addresses\n+                \/\/ containing URLs\n+                \/\/ ignore name & attrs params; not used in URL factory\n+                \/\/ RMI references from '\n+                answer = processURLAddrs(ref, name, nameCtx, environment);\n+                if (answer != null) {\n+                    return answer;\n+                }\n+            }\n+        }\n+\n+        \/\/ try using any specified factories\n+        answer = createObjectFromFactories(refInfo, name, nameCtx,\n+                environment, attrs);\n+        return (answer != null) ? answer : refInfo;\n+    }\n+\n+    \/**\n+     * Retrieves the ObjectFactory for the object identified by a reference,\n+     * using the reference's factory class name and factory codebase\n+     * to load in the factory's class.\n+     * @param ref The non-null reference to use.\n+     * @param factoryName The non-null class name of the factory.\n+     * @return The object factory for the object identified by ref; null\n+     * if unable to load the factory.\n+     *\/\n+    static ObjectFactory getObjectFactoryFromReference(\n+            Reference ref, String factoryName, Predicate<Class<?>> filter)\n+            throws IllegalAccessException,\n+            InstantiationException,\n+            MalformedURLException {\n+        Class<?> clas = null;\n+\n+        \/\/ Try to use current class loader\n+        try {\n+            clas = helper.loadClassWithoutInit(factoryName);\n+            \/\/ Validate factory's class with the objects factory serial filter\n+            if (!filter.test(clas)) {\n+                return null;\n+            }\n+        } catch (ClassNotFoundException e) {\n+            \/\/ ignore and continue\n+            \/\/ e.printStackTrace();\n+        }\n+        \/\/ All other exceptions are passed up.\n+\n+        \/\/ Not in class path; try to use codebase\n+        String codebase;\n+        if (clas == null &&\n+                (codebase = ref.getFactoryClassLocation()) != null) {\n+            try {\n+                clas = helper.loadClass(factoryName, codebase);\n+                \/\/ Validate factory's class with the objects factory serial filter\n+                if (clas == null || !filter.test(clas)) {\n+                    return null;\n+                }\n+            } catch (ClassNotFoundException e) {\n+            }\n+        }\n+\n+        @SuppressWarnings(\"deprecation\") \/\/ Class.newInstance\n+        ObjectFactory result = (clas != null) ? (ObjectFactory) clas.newInstance() : null;\n+        return result;\n+    }\n+\n+    \/**\n+     * Creates an object using the factories specified in the\n+     * {@code Context.OBJECT_FACTORIES} property of the environment\n+     * or of the provider resource file associated with {@code nameCtx}.\n+     *\n+     * @return factory created; null if cannot create\n+     *\/\n+    private static Object createObjectFromFactories(Object obj, Name name,\n+                                                    Context nameCtx, Hashtable<?,?> environment, Attributes attrs)\n+            throws Exception {\n+\n+        FactoryEnumeration factories = ResourceManager.getFactories(\n+                Context.OBJECT_FACTORIES, environment, nameCtx);\n+\n+        if (factories == null)\n+            return null;\n+\n+        ObjectFactory factory;\n+        Object answer = null;\n+        \/\/ Try each factory until one succeeds\n+        while (answer == null && factories.hasMore()) {\n+            factory = (ObjectFactory)factories.next();\n+            if (factory instanceof DirObjectFactory) {\n+                answer = ((DirObjectFactory)factory).\n+                        getObjectInstance(obj, name, nameCtx, environment, attrs);\n+            } else {\n+                answer =\n+                        factory.getObjectInstance(obj, name, nameCtx, environment);\n+            }\n+        }\n+        return answer;\n+    }\n+\n+    \/*\n+     * Ref has no factory.  For each address of type \"URL\", try its URL\n+     * context factory.  Returns null if unsuccessful in creating and\n+     * invoking a factory.\n+     *\/\n+    static Object processURLAddrs(Reference ref, Name name, Context nameCtx,\n+                                  Hashtable<?,?> environment)\n+            throws NamingException {\n+\n+        for (int i = 0; i < ref.size(); i++) {\n+            RefAddr addr = ref.get(i);\n+            if (addr instanceof StringRefAddr &&\n+                    addr.getType().equalsIgnoreCase(\"URL\")) {\n+\n+                String url = (String)addr.getContent();\n+                Object answer = processURL(url, name, nameCtx, environment);\n+                if (answer != null) {\n+                    return answer;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static Object processURL(Object refInfo, Name name,\n+                                     Context nameCtx, Hashtable<?,?> environment)\n+            throws NamingException {\n+        Object answer;\n+\n+        \/\/ If refInfo is a URL string, try to use its URL context factory\n+        \/\/ If no context found, continue to try object factories.\n+        if (refInfo instanceof String) {\n+            String url = (String)refInfo;\n+            String scheme = getURLScheme(url);\n+            if (scheme != null) {\n+                answer = getURLObject(scheme, refInfo, name, nameCtx,\n+                        environment);\n+                if (answer != null) {\n+                    return answer;\n+                }\n+            }\n+        }\n+\n+        \/\/ If refInfo is an array of URL strings,\n+        \/\/ try to find a context factory for any one of its URLs.\n+        \/\/ If no context found, continue to try object factories.\n+        if (refInfo instanceof String[]) {\n+            String[] urls = (String[])refInfo;\n+            for (int i = 0; i <urls.length; i++) {\n+                String scheme = getURLScheme(urls[i]);\n+                if (scheme != null) {\n+                    answer = getURLObject(scheme, refInfo, name, nameCtx,\n+                            environment);\n+                    if (answer != null)\n+                        return answer;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static String getURLScheme(String str) {\n+        int colon_posn = str.indexOf(':');\n+        int slash_posn = str.indexOf('\/');\n+\n+        if (colon_posn > 0 && (slash_posn == -1 || colon_posn < slash_posn))\n+            return str.substring(0, colon_posn);\n+        return null;\n+    }\n+\n+    \/**\n+     * Creates an object for the given URL scheme id using\n+     * the supplied urlInfo.\n+     * <p>\n+     * If urlInfo is null, the result is a context for resolving URLs\n+     * with the scheme id 'scheme'.\n+     * If urlInfo is a URL, the result is a context named by the URL.\n+     * Names passed to this context is assumed to be relative to this\n+     * context (i.e. not a URL). For example, if urlInfo is\n+     * \"ldap:\/\/ldap.wiz.com\/o=Wiz,c=us\", the resulting context will\n+     * be that pointed to by \"o=Wiz,c=us\" on the server 'ldap.wiz.com'.\n+     * Subsequent names that can be passed to this context will be\n+     * LDAP names relative to this context (e.g. cn=\"Barbs Jensen\").\n+     * If urlInfo is an array of URLs, the URLs are assumed\n+     * to be equivalent in terms of the context to which they refer.\n+     * The resulting context is like that of the single URL case.\n+     * If urlInfo is of any other type, that is handled by the\n+     * context factory for the URL scheme.\n+     * @param scheme the URL scheme id for the context\n+     * @param urlInfo information used to create the context\n+     * @param name name of this object relative to {@code nameCtx}\n+     * @param nameCtx Context whose provider resource file will be searched\n+     *          for package prefix values (or null if none)\n+     * @param environment Environment properties for creating the context\n+     * @see javax.naming.InitialContext\n+     *\/\n+    private static Object getURLObject(String scheme, Object urlInfo,\n+                                       Name name, Context nameCtx,\n+                                       Hashtable<?,?> environment)\n+            throws NamingException {\n+\n+        \/\/ e.g. \"ftpURLContextFactory\"\n+        ObjectFactory factory = (ObjectFactory)ResourceManager.getFactory(\n+                Context.URL_PKG_PREFIXES, environment, nameCtx,\n+                \".\" + scheme + \".\" + scheme + \"URLContextFactory\", DEFAULT_PKG_PREFIX);\n+\n+        if (factory == null)\n+            return null;\n+\n+        \/\/ Found object factory\n+        try {\n+            return factory.getObjectInstance(urlInfo, name, nameCtx, environment);\n+        } catch (NamingException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            NamingException ne = new NamingException();\n+            ne.setRootCause(e);\n+            throw ne;\n+        }\n+    }\n+\n+    \/**\n+     * Creates an object using the factories specified in the\n+     * {@code Context.OBJECT_FACTORIES} property of the environment\n+     * or of the provider resource file associated with {@code nameCtx}.\n+     *\n+     * @return factory created; null if cannot create\n+     *\/\n+    private static Object createObjectFromFactories(Object obj, Name name,\n+                                                    Context nameCtx, Hashtable<?,?> environment) throws Exception {\n+\n+        FactoryEnumeration factories = ResourceManager.getFactories(\n+                Context.OBJECT_FACTORIES, environment, nameCtx);\n+\n+        if (factories == null)\n+            return null;\n+\n+        \/\/ Try each factory until one succeeds\n+        ObjectFactory factory;\n+        Object answer = null;\n+        while (answer == null && factories.hasMore()) {\n+            factory = (ObjectFactory)factories.next();\n+            answer = factory.getObjectInstance(obj, name, nameCtx, environment);\n+        }\n+        return answer;\n+    }\n+\n+    public static synchronized void setObjectFactoryBuilder(\n+            ObjectFactoryBuilder builder) throws NamingException {\n+        if (object_factory_builder != null)\n+            throw new IllegalStateException(\"ObjectFactoryBuilder already set\");\n+\n+        @SuppressWarnings(\"removal\")\n+        SecurityManager security = System.getSecurityManager();\n+        if (security != null) {\n+            security.checkSetFactory();\n+        }\n+        object_factory_builder = builder;\n+    }\n+\n+    public static synchronized ObjectFactoryBuilder getObjectFactoryBuilder() {\n+        return object_factory_builder;\n+    }\n+\n+    private static final String DEFAULT_PKG_PREFIX = \"com.sun.jndi.url\";\n+    static final VersionHelper helper = VersionHelper.getVersionHelper();\n+\n+    private static ObjectFactoryBuilder object_factory_builder = null;\n+\n+}\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/naming\/internal\/NamingManagerHelper.java","additions":422,"deletions":0,"binary":false,"changes":422,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-     * If the filter result is not {@linkplain Status#REJECTED REJECTED}, the filter will\n+     * If the filter result is {@linkplain Status#ALLOWED ALLOWED}, the filter will\n@@ -56,1 +56,1 @@\n-     * @param factoryClass objects factory class\n+     * @param serialClass objects factory class\n@@ -59,2 +59,2 @@\n-    public static boolean canInstantiateObjectsFactory(Class<?> factoryClass) {\n-        return checkInput(() -> factoryClass);\n+    public static boolean checkGlobalFilter(Class<?> serialClass) {\n+        return checkInput(GLOBAL_FILTER, () -> serialClass);\n@@ -63,3 +63,42 @@\n-    private static boolean checkInput(FactoryInfo factoryInfo) {\n-        Status result = GLOBAL.checkInput(factoryInfo);\n-        return result != Status.REJECTED;\n+    \/**\n+     * Checks if the factory filters allow the given factory class for LDAP.\n+     * This method combines the global and LDAP specific filter results to determine\n+     * if the given factory class is allowed.\n+     * The given factory class is rejected if any of these two filters reject\n+     * it, or if none of them allow it.\n+     *\n+     * @param serialClass objects factory class\n+     * @return true - if the factory is allowed to be instantiated; false - otherwise\n+     *\/\n+    public static boolean checkLdapFilter(Class<?> serialClass) {\n+        return checkInput(LDAP_FILTER, () -> serialClass);\n+    }\n+\n+    \/**\n+     * Checks if the factory filters allow the given factory class for RMI.\n+     * This method combines the global and RMI specific filter results to determine\n+     * if the given factory class is allowed.\n+     * The given factory class is rejected if any of these two filters reject\n+     * it, or if none of them allow it.\n+     *\n+     * @param serialClass objects factory class\n+     * @return true - if the factory is allowed to be instantiated; false - otherwise\n+     *\/\n+    public static boolean checkRmiFilter(Class<?> serialClass) {\n+        return checkInput(RMI_FILTER, () -> serialClass);\n+    }\n+\n+    private static boolean checkInput(ConfiguredFilter filter, FactoryInfo serialClass) {\n+        var globalFilter = GLOBAL_FILTER.filter();\n+        var specificFilter = filter.filter();\n+        Status globalResult = globalFilter.checkInput(serialClass);\n+\n+        \/\/ Check if a specific filter is the global one\n+        if (filter == GLOBAL_FILTER) {\n+            return globalResult == Status.ALLOWED;\n+        }\n+        return switch (globalResult) {\n+            case ALLOWED -> specificFilter.checkInput(serialClass) != Status.REJECTED;\n+            case REJECTED -> false;\n+            case UNDECIDED -> specificFilter.checkInput(serialClass) == Status.ALLOWED;\n+        };\n@@ -100,1 +139,12 @@\n-    private static final String FACTORIES_FILTER_PROPNAME = \"jdk.jndi.object.factoriesFilter\";\n+    private static final String GLOBAL_FACTORIES_FILTER_PROPNAME =\n+            \"jdk.jndi.object.factoriesFilter\";\n+\n+    \/\/ System property name that contains the patterns to filter LDAP object factory\n+    \/\/ names\n+    private static final String LDAP_FACTORIES_FILTER_PROPNAME =\n+            \"jdk.jndi.ldap.object.factoriesFilter\";\n+\n+    \/\/ System property name that contains the patterns to filter RMI object factory\n+    \/\/ names\n+    private static final String RMI_FACTORIES_FILTER_PROPNAME =\n+            \"jdk.jndi.rmi.object.factoriesFilter\";\n@@ -102,2 +152,3 @@\n-    \/\/ Default system property value that allows the load of any object factory classes\n-    private static final String DEFAULT_SP_VALUE = \"*\";\n+    \/\/ Default system property value that allows the load of any object factory\n+    \/\/ classes\n+    private static final String DEFAULT_GLOBAL_SP_VALUE = \"*\";\n@@ -105,3 +156,63 @@\n-    \/\/ System wide object factories filter constructed from the system property\n-    private static final ObjectInputFilter GLOBAL =\n-            ObjectInputFilter.Config.createFilter(getFilterPropertyValue());\n+    \/\/ Default system property value that allows the load of any object factory\n+    \/\/ class provided by the JDK LDAP provider implementation\n+    private static final String DEFAULT_LDAP_SP_VALUE =\n+            \"java.naming\/com.sun.jndi.ldap.**;!*\";\n+\n+    \/\/ Default system property value that allows the load of any object factory\n+    \/\/ class provided by the JDK RMI provider implementation\n+    private static final String DEFAULT_RMI_SP_VALUE =\n+            \"jdk.naming.rmi\/com.sun.jndi.rmi.**;!*\";\n+\n+    \/\/ A system-wide global object factories filter constructed from the system\n+    \/\/ property\n+    private static final ConfiguredFilter GLOBAL_FILTER =\n+            initializeFilter(GLOBAL_FACTORIES_FILTER_PROPNAME, DEFAULT_GLOBAL_SP_VALUE);\n+\n+    \/\/ A system-wide LDAP specific object factories filter constructed from the system\n+    \/\/ property\n+    private static final ConfiguredFilter LDAP_FILTER =\n+            initializeFilter(LDAP_FACTORIES_FILTER_PROPNAME, DEFAULT_LDAP_SP_VALUE);\n+\n+    \/\/ A system-wide RMI specific object factories filter constructed from the system\n+    \/\/ property\n+    private static final ConfiguredFilter RMI_FILTER =\n+            initializeFilter(RMI_FACTORIES_FILTER_PROPNAME, DEFAULT_RMI_SP_VALUE);\n+\n+    \/\/ Record for storing a factory filter configuration\n+    private interface ConfiguredFilter {\n+        ObjectInputFilter filter();\n+    }\n+\n+    \/\/ Record to store an object input filter constructed from a valid filter\n+    \/\/ pattern string\n+    private record ValidFilter(ObjectInputFilter filter)\n+            implements ConfiguredFilter {\n+    }\n+\n+    \/\/ Record to store parsing results for a filter with\n+    \/\/ illegal or malformed pattern string\n+    private record InvalidFilter(String filterPropertyName,\n+                                 IllegalArgumentException error)\n+            implements ConfiguredFilter {\n+\n+        @Override\n+        public ObjectInputFilter filter() {\n+            \/\/ Report a filter property name and an error message\n+            throw new IllegalArgumentException(filterPropertyName +\n+                    \": \" + error.getMessage());\n+        }\n+    }\n+\n+    \/\/ Read filter pattern value from a system\/security property\n+    \/\/ and create a filter record from it (valid or invalid).\n+    private static ConfiguredFilter initializeFilter(String filterPropertyName,\n+                                                     String filterDefaultValue) {\n+        try {\n+            var filter = ObjectInputFilter.Config.createFilter(\n+                    getFilterPropertyValue(filterPropertyName,\n+                            filterDefaultValue));\n+            return new ValidFilter(filter);\n+        } catch (IllegalArgumentException iae) {\n+            return new InvalidFilter(filterPropertyName, iae);\n+        }\n+    }\n@@ -110,3 +221,4 @@\n-    private static String getFilterPropertyValue() {\n-        String propVal = SecurityProperties.privilegedGetOverridable(FACTORIES_FILTER_PROPNAME);\n-        return propVal != null ? propVal : DEFAULT_SP_VALUE;\n+    private static String getFilterPropertyValue(String propertyName,\n+                                                 String defaultValue) {\n+        String propVal = SecurityProperties.privilegedGetOverridable(propertyName);\n+        return propVal != null ? propVal : defaultValue;\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/naming\/internal\/ObjectFactoriesFilter.java","additions":129,"deletions":17,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-import javax.naming.Reference;\n-import javax.naming.Referenceable;\n@@ -39,0 +37,2 @@\n+import com.sun.naming.internal.NamingManagerHelper;\n+import com.sun.naming.internal.ObjectFactoriesFilter;\n@@ -157,86 +157,2 @@\n-\n-            ObjectFactory factory;\n-\n-            ObjectFactoryBuilder builder = getObjectFactoryBuilder();\n-            if (builder != null) {\n-                \/\/ builder must return non-null factory\n-                factory = builder.createObjectFactory(refInfo, environment);\n-                if (factory instanceof DirObjectFactory) {\n-                    return ((DirObjectFactory)factory).getObjectInstance(\n-                        refInfo, name, nameCtx, environment, attrs);\n-                } else {\n-                    return factory.getObjectInstance(refInfo, name, nameCtx,\n-                        environment);\n-                }\n-            }\n-\n-            \/\/ use reference if possible\n-            Reference ref = null;\n-            if (refInfo instanceof Reference) {\n-                ref = (Reference) refInfo;\n-            } else if (refInfo instanceof Referenceable) {\n-                ref = ((Referenceable)(refInfo)).getReference();\n-            }\n-\n-            Object answer;\n-\n-            if (ref != null) {\n-                String f = ref.getFactoryClassName();\n-                if (f != null) {\n-                    \/\/ if reference identifies a factory, use exclusively\n-\n-                    factory = getObjectFactoryFromReference(ref, f);\n-                    if (factory instanceof DirObjectFactory) {\n-                        return ((DirObjectFactory)factory).getObjectInstance(\n-                            ref, name, nameCtx, environment, attrs);\n-                    } else if (factory != null) {\n-                        return factory.getObjectInstance(ref, name, nameCtx,\n-                                                         environment);\n-                    }\n-                    \/\/ No factory found, so return original refInfo.\n-                    \/\/ Will reach this point if factory class is not in\n-                    \/\/ class path and reference does not contain a URL for it\n-                    return refInfo;\n-\n-                } else {\n-                    \/\/ if reference has no factory, check for addresses\n-                    \/\/ containing URLs\n-                    \/\/ ignore name & attrs params; not used in URL factory\n-\n-                    answer = processURLAddrs(ref, name, nameCtx, environment);\n-                    if (answer != null) {\n-                        return answer;\n-                    }\n-                }\n-            }\n-\n-            \/\/ try using any specified factories\n-            answer = createObjectFromFactories(refInfo, name, nameCtx,\n-                                               environment, attrs);\n-            return (answer != null) ? answer : refInfo;\n-    }\n-\n-    private static Object createObjectFromFactories(Object obj, Name name,\n-            Context nameCtx, Hashtable<?,?> environment, Attributes attrs)\n-        throws Exception {\n-\n-        FactoryEnumeration factories = ResourceManager.getFactories(\n-            Context.OBJECT_FACTORIES, environment, nameCtx);\n-\n-        if (factories == null)\n-            return null;\n-\n-        ObjectFactory factory;\n-        Object answer = null;\n-        \/\/ Try each factory until one succeeds\n-        while (answer == null && factories.hasMore()) {\n-            factory = (ObjectFactory)factories.next();\n-            if (factory instanceof DirObjectFactory) {\n-                answer = ((DirObjectFactory)factory).\n-                    getObjectInstance(obj, name, nameCtx, environment, attrs);\n-            } else {\n-                answer =\n-                    factory.getObjectInstance(obj, name, nameCtx, environment);\n-            }\n-        }\n-        return answer;\n+            return NamingManagerHelper.getDirObjectInstance(refInfo, name, nameCtx,\n+                    environment, attrs, ObjectFactoriesFilter::checkGlobalFilter);\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/spi\/DirectoryManager.java","additions":5,"deletions":89,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.net.MalformedURLException;\n@@ -35,0 +34,1 @@\n+import com.sun.naming.internal.NamingManagerHelper;\n@@ -81,5 +81,0 @@\n-    \/**\n-     * Package-private; used by DirectoryManager and NamingManager.\n-     *\/\n-    private static ObjectFactoryBuilder object_factory_builder = null;\n-\n@@ -114,1 +109,1 @@\n-    public static synchronized void setObjectFactoryBuilder(\n+    public static void setObjectFactoryBuilder(\n@@ -116,9 +111,1 @@\n-        if (object_factory_builder != null)\n-            throw new IllegalStateException(\"ObjectFactoryBuilder already set\");\n-\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkSetFactory();\n-        }\n-        object_factory_builder = builder;\n+        NamingManagerHelper.setObjectFactoryBuilder(builder);\n@@ -130,88 +117,2 @@\n-    static synchronized ObjectFactoryBuilder getObjectFactoryBuilder() {\n-        return object_factory_builder;\n-    }\n-\n-\n-    \/**\n-     * Retrieves the ObjectFactory for the object identified by a reference,\n-     * using the reference's factory class name and factory codebase\n-     * to load in the factory's class.\n-     * @param ref The non-null reference to use.\n-     * @param factoryName The non-null class name of the factory.\n-     * @return The object factory for the object identified by ref; null\n-     * if unable to load the factory.\n-     *\/\n-    static ObjectFactory getObjectFactoryFromReference(\n-        Reference ref, String factoryName)\n-        throws IllegalAccessException,\n-        InstantiationException,\n-        MalformedURLException {\n-        Class<?> clas = null;\n-\n-        \/\/ Try to use current class loader\n-        try {\n-            clas = helper.loadClassWithoutInit(factoryName);\n-            \/\/ Validate factory's class with the objects factory serial filter\n-            if (!ObjectFactoriesFilter.canInstantiateObjectsFactory(clas)) {\n-                return null;\n-            }\n-        } catch (ClassNotFoundException e) {\n-            \/\/ ignore and continue\n-            \/\/ e.printStackTrace();\n-        }\n-        \/\/ All other exceptions are passed up.\n-\n-        \/\/ Not in class path; try to use codebase\n-        String codebase;\n-        if (clas == null &&\n-                (codebase = ref.getFactoryClassLocation()) != null) {\n-            try {\n-                clas = helper.loadClass(factoryName, codebase);\n-                \/\/ Validate factory's class with the objects factory serial filter\n-                if (clas == null ||\n-                    !ObjectFactoriesFilter.canInstantiateObjectsFactory(clas)) {\n-                    return null;\n-                }\n-            } catch (ClassNotFoundException e) {\n-            }\n-        }\n-\n-        @SuppressWarnings(\"deprecation\") \/\/ Class.newInstance\n-        ObjectFactory result = (clas != null) ? (ObjectFactory) clas.newInstance() : null;\n-        return result;\n-    }\n-\n-\n-    \/**\n-     * Creates an object using the factories specified in the\n-     * {@code Context.OBJECT_FACTORIES} property of the environment\n-     * or of the provider resource file associated with {@code nameCtx}.\n-     *\n-     * @return factory created; null if cannot create\n-     *\/\n-    private static Object createObjectFromFactories(Object obj, Name name,\n-            Context nameCtx, Hashtable<?,?> environment) throws Exception {\n-\n-        FactoryEnumeration factories = ResourceManager.getFactories(\n-            Context.OBJECT_FACTORIES, environment, nameCtx);\n-\n-        if (factories == null)\n-            return null;\n-\n-        \/\/ Try each factory until one succeeds\n-        ObjectFactory factory;\n-        Object answer = null;\n-        while (answer == null && factories.hasMore()) {\n-            factory = (ObjectFactory)factories.next();\n-            answer = factory.getObjectInstance(obj, name, nameCtx, environment);\n-        }\n-        return answer;\n-    }\n-\n-    private static String getURLScheme(String str) {\n-        int colon_posn = str.indexOf(':');\n-        int slash_posn = str.indexOf('\/');\n-\n-        if (colon_posn > 0 && (slash_posn == -1 || colon_posn < slash_posn))\n-            return str.substring(0, colon_posn);\n-        return null;\n+    static ObjectFactoryBuilder getObjectFactoryBuilder() {\n+        return NamingManagerHelper.getObjectFactoryBuilder();\n@@ -311,54 +212,3 @@\n-        throws Exception\n-    {\n-\n-        ObjectFactory factory;\n-\n-        \/\/ Use builder if installed\n-        ObjectFactoryBuilder builder = getObjectFactoryBuilder();\n-        if (builder != null) {\n-            \/\/ builder must return non-null factory\n-            factory = builder.createObjectFactory(refInfo, environment);\n-            return factory.getObjectInstance(refInfo, name, nameCtx,\n-                environment);\n-        }\n-\n-        \/\/ Use reference if possible\n-        Reference ref = null;\n-        if (refInfo instanceof Reference) {\n-            ref = (Reference) refInfo;\n-        } else if (refInfo instanceof Referenceable) {\n-            ref = ((Referenceable)(refInfo)).getReference();\n-        }\n-\n-        Object answer;\n-\n-        if (ref != null) {\n-            String f = ref.getFactoryClassName();\n-            if (f != null) {\n-                \/\/ if reference identifies a factory, use exclusively\n-\n-                factory = getObjectFactoryFromReference(ref, f);\n-                if (factory != null) {\n-                    return factory.getObjectInstance(ref, name, nameCtx,\n-                                                     environment);\n-                }\n-                \/\/ No factory found, so return original refInfo.\n-                \/\/ Will reach this point if factory class is not in\n-                \/\/ class path and reference does not contain a URL for it\n-                return refInfo;\n-\n-            } else {\n-                \/\/ if reference has no factory, check for addresses\n-                \/\/ containing URLs\n-\n-                answer = processURLAddrs(ref, name, nameCtx, environment);\n-                if (answer != null) {\n-                    return answer;\n-                }\n-            }\n-        }\n-\n-        \/\/ try using any specified factories\n-        answer =\n-            createObjectFromFactories(refInfo, name, nameCtx, environment);\n-        return (answer != null) ? answer : refInfo;\n+        throws Exception {\n+        return NamingManagerHelper.getObjectInstance(refInfo, name, nameCtx,\n+                environment, ObjectFactoriesFilter::checkGlobalFilter);\n@@ -367,62 +217,0 @@\n-    \/*\n-     * Ref has no factory.  For each address of type \"URL\", try its URL\n-     * context factory.  Returns null if unsuccessful in creating and\n-     * invoking a factory.\n-     *\/\n-    static Object processURLAddrs(Reference ref, Name name, Context nameCtx,\n-                                  Hashtable<?,?> environment)\n-            throws NamingException {\n-\n-        for (int i = 0; i < ref.size(); i++) {\n-            RefAddr addr = ref.get(i);\n-            if (addr instanceof StringRefAddr &&\n-                addr.getType().equalsIgnoreCase(\"URL\")) {\n-\n-                String url = (String)addr.getContent();\n-                Object answer = processURL(url, name, nameCtx, environment);\n-                if (answer != null) {\n-                    return answer;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private static Object processURL(Object refInfo, Name name,\n-                                     Context nameCtx, Hashtable<?,?> environment)\n-            throws NamingException {\n-        Object answer;\n-\n-        \/\/ If refInfo is a URL string, try to use its URL context factory\n-        \/\/ If no context found, continue to try object factories.\n-        if (refInfo instanceof String) {\n-            String url = (String)refInfo;\n-            String scheme = getURLScheme(url);\n-            if (scheme != null) {\n-                answer = getURLObject(scheme, refInfo, name, nameCtx,\n-                                      environment);\n-                if (answer != null) {\n-                    return answer;\n-                }\n-            }\n-        }\n-\n-        \/\/ If refInfo is an array of URL strings,\n-        \/\/ try to find a context factory for any one of its URLs.\n-        \/\/ If no context found, continue to try object factories.\n-        if (refInfo instanceof String[]) {\n-            String[] urls = (String[])refInfo;\n-            for (int i = 0; i <urls.length; i++) {\n-                String scheme = getURLScheme(urls[i]);\n-                if (scheme != null) {\n-                    answer = getURLObject(scheme, refInfo, name, nameCtx,\n-                                          environment);\n-                    if (answer != null)\n-                        return answer;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/spi\/NamingManager.java","additions":9,"deletions":221,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -111,1 +111,2 @@\n- *          {@link java.io.ObjectInputFilter.Config#createFilter(String) jdk.serialFilter}.\n+ *          {@link java.io.ObjectInputFilter.Config#createFilter(String) jdk.serialFilter}. Limit patterns\n+ *          specified in the filter property are unused.\n@@ -118,0 +119,17 @@\n+ *     <li>{@systemProperty jdk.jndi.ldap.object.factoriesFilter}:\n+ *          <br>The value of this system property defines a filter used by\n+ *          the JDK LDAP provider implementation to further restrict the set of object factory classes which will\n+ *          be allowed to instantiate objects from object references returned by LDAP systems.\n+ *          The factory class named by the {@linkplain javax.naming.Reference reference instance} first will be\n+ *          matched against this specific filter and then against the global filter. The factory class is rejected\n+ *          if any of these two filters reject it, or if none of them allow it.\n+ *          The filter property supports pattern-based filter syntax with the same format as\n+ *          {@link java.io.ObjectInputFilter.Config#createFilter(String) jdk.serialFilter}. Limit patterns\n+ *          specified in the filter property are unused.\n+ *          <br>The default value allows any object factory class provided by the JDK LDAP provider\n+ *          implementation.\n+ *         <br>This system property will be used to filter LDAP specific object factories only if\n+ *         global {@link javax.naming.spi.ObjectFactoryBuilder} is {@linkplain\n+ *         javax.naming.spi.NamingManager#setObjectFactoryBuilder(javax.naming.spi.ObjectFactoryBuilder)\n+ *         not set}.\n+ *     <\/li>\n@@ -146,0 +164,2 @@\n+    exports com.sun.naming.internal to\n+         jdk.naming.rmi;\n","filename":"src\/java.naming\/share\/classes\/module-info.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,3 @@\n+import com.sun.naming.internal.NamingManagerHelper;\n+import com.sun.naming.internal.ObjectFactoriesFilter;\n+\n@@ -501,2 +504,2 @@\n-            return NamingManager.getObjectInstance(obj, name, this,\n-                                                   environment);\n+            return NamingManagerHelper.getObjectInstance(obj, name, this,\n+                    environment, ObjectFactoriesFilter::checkRmiFilter);\n","filename":"src\/jdk.naming.rmi\/share\/classes\/com\/sun\/jndi\/rmi\/registry\/RegistryContext.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,2 @@\n- *          {@link java.io.ObjectInputFilter.Config#createFilter(String) jdk.serialFilter}.\n+ *          {@link java.io.ObjectInputFilter.Config#createFilter(String) jdk.serialFilter}. Limit patterns\n+ *          specified in the filter property are unused.\n@@ -46,0 +47,13 @@\n+ *     <li>{@systemProperty jdk.jndi.rmi.object.factoriesFilter}:\n+ *          <br>The value of this system property defines a filter used by\n+ *          the JDK RMI provider implementation to further restrict the set of object factory classes which will\n+ *          be allowed to instantiate objects from object references returned by RMI systems.\n+ *          The factory class named by the {@linkplain javax.naming.Reference reference instance} first will be\n+ *          matched against this specific filter and then against the global filter. The factory class is rejected\n+ *          if any of these two filters reject it, or if none of them allow it.\n+ *          The filter property supports pattern-based filter syntax with the same format as\n+ *          {@link java.io.ObjectInputFilter.Config#createFilter(String) jdk.serialFilter}. Limit patterns\n+ *          specified in the filter property are unused.\n+ *          <br>The default value allows any object factory class provided by the JDK RMI provider\n+ *          implementation.\n+ *     <\/li>\n","filename":"src\/jdk.naming.rmi\/share\/classes\/module-info.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.net.URIBuilder;\n+\n+import javax.naming.NamingException;\n+import javax.naming.Reference;\n+import javax.naming.directory.DirContext;\n+import javax.naming.directory.InitialDirContext;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.SocketAddress;\n+import java.util.Hashtable;\n+\n+\/*\n+ * @test\n+ * @bug 8290368\n+ * @summary Checks if LDAP specific objects factory filter system and security\n+ *  properties can be used to restrict usage of object factories during\n+ *  LDAP lookup operations.\n+ * @modules java.naming\/com.sun.jndi.ldap\n+ * @library \/test\/lib ..\/..\/lib \/javax\/naming\/module\/src\/test\/test\/\n+ * @build LDAPServer LDAPTestUtils TestFactory\n+ *\n+ * @run main\/othervm LdapFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=*\n+ *                   LdapFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=com.**;!*\n+ *                   LdapFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=com.test.**;!*\n+ *                   LdapFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=com.test.*;!*\n+ *                   LdapFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=com.test.Test*;!*\n+ *                   LdapFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=!com.test.**\n+ *                   LdapFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=!com.test.TestFactory;com.**\n+ *                   LdapFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=!com.test.TestFactory;com.test.*\n+ *                   LdapFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=!com.test.Test*\n+ *                   LdapFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=com.*;!*\n+ *                   LdapFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=com.test.TestFactor;!*\n+ *                   LdapFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=com.test.TestFactoryy;!*\n+ *                   LdapFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djava.security.properties=${test.src}\/disallowLdapFilter.props\n+ *                   LdapFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djava.security.properties=${test.src}\/disallowLdapFilter.props\n+ *                   -Djdk.jndi.ldap.object.factoriesFilter=com.test.TestFactory\n+ *                   LdapFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djava.security.properties=${test.src}\/allowLdapFilter.props\n+ *                   LdapFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djava.security.properties=${test.src}\/allowLdapFilter.props\n+ *                   -Djdk.jndi.rmi.object.factoriesFilter=!com.test.TestFactory\n+ *                   LdapFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djava.security.properties=${test.src}\/allowLdapFilter.props\n+ *                   -Djdk.jndi.ldap.object.factoriesFilter=!com.test.TestFactory\n+ *                   LdapFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=.*\n+ *                   LdapFactoriesFilterTest false false\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=*\n+ *                   -Djdk.jndi.object.factoriesFilter=.*\n+ *                   LdapFactoriesFilterTest false false\n+ *\n+ * @run main\/othervm -Djdk.jndi.ldap.object.factoriesFilter=*\n+ *                   -Djdk.jndi.object.factoriesFilter=*\n+ *                   -Djdk.jndi.rmi.object.factoriesFilter=.*\n+ *                   LdapFactoriesFilterTest true true\n+ *\/\n+\n+public class LdapFactoriesFilterTest {\n+    public static void main(String[] args) throws Exception {\n+\n+        boolean testFactoryAllowed = Boolean.parseBoolean(args[0]);\n+        boolean ldapAndGlobalFiltersValid =\n+                Boolean.parseBoolean(args[1]);\n+\n+        \/\/ Create unbound server socket\n+        ServerSocket serverSocket = new ServerSocket();\n+        try (serverSocket) {\n+            \/\/ Bind it to the loopback address\n+            SocketAddress sockAddr = new InetSocketAddress(\n+                    InetAddress.getLoopbackAddress(), 0);\n+            serverSocket.bind(sockAddr);\n+\n+            \/\/ Construct the provider URL for LDAPTestUtils\n+            String providerURL = URIBuilder.newBuilder()\n+                    .scheme(\"ldap\")\n+                    .loopback()\n+                    .port(serverSocket.getLocalPort())\n+                    .buildUnchecked().toString();\n+\n+            \/\/ Create and initialize test environment variables\n+            Hashtable<Object, Object> env;\n+            env = LDAPTestUtils.initEnv(serverSocket, providerURL,\n+                    LdapFactoriesFilterTest.class.getName(), args, false);\n+            DirContext ctx = new InitialDirContext(env);\n+            Exception observedException = null;\n+            Object lookupRes = null;\n+\n+            \/\/ Lookup bound reference\n+            try {\n+                lookupRes = ctx.lookup(\"Example\");\n+                System.err.println(\"Lookup results: \" + lookupRes.getClass().getCanonicalName());\n+            } catch (Exception ex) {\n+                observedException = ex;\n+            }\n+\n+            \/\/ Check lookup operation results\n+            if (testFactoryAllowed) {\n+                \/\/ NamingException with RuntimeException cause is expected here\n+                if (observedException instanceof NamingException namingException) {\n+                    System.err.println(\"Observed NamingException: \" + observedException);\n+                    Throwable cause = namingException.getCause();\n+                    System.err.println(\"NamingException cause: \" + cause);\n+                    \/\/ We expect RuntimeException from factory for cases when LDAP factory\n+                    \/\/ filter allows the test factory\n+                    if (cause instanceof RuntimeException rte) {\n+                        String rteMessage = rte.getMessage();\n+                        System.err.println(\"RuntimeException message: \" + rteMessage);\n+                        if (!com.test.TestFactory.RUNTIME_EXCEPTION_MESSAGE.equals(rteMessage)) {\n+                            throw new AssertionError(\n+                                    \"Unexpected RuntimeException message observed\");\n+                        }\n+                    } else {\n+                        throw new AssertionError(\n+                                \"RuntimeException is expected to be thrown\" +\n+                                            \" by the test object factory\");\n+                    }\n+                } else {\n+                    throw new AssertionError(\n+                            \"NamingException was not thrown as expected\");\n+                }\n+            } else if (!ldapAndGlobalFiltersValid) {\n+                \/\/ If LDAP or GLOBAL factories filter are not properly formatted we're expecting to\n+                \/\/ get NamingException with IllegalArgumentException set as a cause that contains\n+                \/\/ formatting error message.\n+                \/\/ If RMI filter is not properly formatted we're not expecting IAE here since\n+                \/\/ this test only performing LDAP lookups\n+                if (observedException instanceof NamingException ne) {\n+                    if (ne.getCause() instanceof IllegalArgumentException iae) {\n+                        \/\/ All tests with malformed filters contain wildcards with\n+                        \/\/ package name missing, therefore the message is expected\n+                        \/\/ to start with \"package missing in:\"\n+                        System.err.println(\"Found expected exception: \" + iae);\n+                    } else {\n+                        throw new AssertionError(\"IllegalArgumentException\" +\n+                                \" is expected for malformed filter values\");\n+                    }\n+                }\n+            } else {\n+                \/\/ Object factory is not allowed by the factories filter\n+                \/\/ we expect reference here\n+                if (lookupRes instanceof Reference ref) {\n+                    System.err.println(\"Lookup result is a reference: \" +\n+                            ref.getFactoryClassLocation() + \" \" + ref.getFactoryClassName());\n+                } else {\n+                    new AssertionError(\"Reference was not returned as a lookup result\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/objects\/factory\/LdapFactoriesFilterTest.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+################################################################################\n+# Capture file for LdapFactoriesFilterTest.java\n+#\n+# NOTE: This hexadecimal dump of LDAP protocol messages was generated by\n+#       running the LdapFactoriesFilterTest application program against a real\n+#       LDAP server and setting the JNDI\/LDAP environment property:\n+#       com.sun.jndi.ldap.trace.ber to activate LDAP message tracing.\n+#\n+################################################################################\n+\n+# LDAP BindRequest\n+0000: 30 0C 02 01 01 60 07 02   01 03 04 00 80 00        0....`........\n+\n+# LDAP BindResponse\n+0000: 30 0C 02 01 01 61 07 0A   01 00 04 00 04 00        0....a........\n+\n+# LDAP SearchRequest\n+0000: 30 49 02 01 02 63 27 04   07 45 78 61 6D 70 6C 65  0I...c'..Example\n+0010: 0A 01 00 0A 01 03 02 01   00 02 01 00 01 01 00 87  ................\n+0020: 0B 6F 62 6A 65 63 74 43   6C 61 73 73 30 00 A0 1B  .objectClass0...\n+0030: 30 19 04 17 32 2E 31 36   2E 38 34 30 2E 31 2E 31  0...2.16.840.1.1\n+0040: 31 33 37 33 30 2E 33 2E   34 2E 32                 13730.3.4.2\n+\n+# LDAP SearchResultEntry\n+0000: 30 75 02 01 02 64 70 04   07 45 78 61 6D 70 6C 65  0u...dp..Example\n+0010: 30 65 30 16 04 0D 6A 61   76 61 43 6C 61 73 73 4E  0e0...javaClassN\n+0020: 61 6D 65 31 05 04 03 66   6F 6F 30 24 04 0B 6F 62  ame1...foo0$..ob\n+0030: 6A 65 63 74 43 6C 61 73   73 31 15 04 13 6A 61 76  jectClass1...jav\n+0040: 61 4E 61 6D 69 6E 67 52   65 66 65 72 65 6E 63 65  aNamingReference\n+0050: 30 25 04 0B 6A 61 76 61   46 61 63 74 6F 72 79 31  0%..javaFactory1\n+0060: 16 04 14 63 6F 6D 2E 74   65 73 74 2E 54 65 73 74  ...com.test.Test\n+0070: 46 61 63 74 6F 72 79                               Factory\n+\n+# LDAP SearchResultDone\n+0000: 30 0C 02 01 02 65 07 0A   01 00 04 00 04 00        0....e........\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/objects\/factory\/LdapFactoriesFilterTest.ldap","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.test;\n+\n+import javax.naming.Context;\n+import javax.naming.Name;\n+import javax.naming.spi.ObjectFactory;\n+import java.util.Hashtable;\n+\n+public class TestFactory implements ObjectFactory {\n+    public static final String RUNTIME_EXCEPTION_MESSAGE =\n+            \"Test object factory is called to instantiate factory\";\n+\n+    @Override\n+    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable<?, ?> environment) throws Exception {\n+        System.err.println(\"obj:\" + obj);\n+        throw new RuntimeException(RUNTIME_EXCEPTION_MESSAGE);\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/objects\/factory\/TestFactory.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+jdk.jndi.ldap.object.factoriesFilter=com.test.TestFactory;!*\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/objects\/factory\/allowLdapFilter.props","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+jdk.jndi.ldap.object.factoriesFilter=!com.test.TestFactory\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/objects\/factory\/disallowLdapFilter.props","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.naming.Context;\n+import javax.naming.InitialContext;\n+import javax.naming.NamingException;\n+import javax.naming.Reference;\n+import java.rmi.RemoteException;\n+import java.rmi.registry.Registry;\n+import java.util.Hashtable;\n+\n+\/*\n+ * @test\n+ * @bug 8290368\n+ * @summary Checks if RMI specific objects factory filter system and security\n+ *  properties can be used to restrict usage of object factories during\n+ *  RMI lookup operations.\n+ * @modules java.rmi\/sun.rmi.registry\n+ *          java.rmi\/sun.rmi.server\n+ *          java.rmi\/sun.rmi.transport\n+ *          java.rmi\/sun.rmi.transport.tcp\n+ * @library ..\/..\/..\/..\/..\/..\/java\/rmi\/testlibrary\n+ * @build TestLibrary\n+ * @compile TestFactory.java\n+ *\n+ * @run main\/othervm RmiFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=*\n+ *                   RmiFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=com.**;!*\n+ *                   RmiFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=com.test.**;!*\n+ *                   RmiFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=com.test.*;!*\n+ *                   RmiFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=com.test.Test*;!*\n+ *                   RmiFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=!com.test.**\n+ *                   RmiFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=!com.test.TestFactory;com.**\n+ *                   RmiFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=!com.test.TestFactory;com.test.*\n+ *                   RmiFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=!com.test.Test*\n+ *                   RmiFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=com.*;!*\n+ *                    RmiFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=com.test.TestFactor;!*\n+ *                   RmiFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=com.test.TestFactoryy;!*\n+ *                   RmiFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djava.security.properties=${test.src}\/disallowRmiFilter.props\n+ *                   RmiFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djava.security.properties=${test.src}\/disallowRmiFilter.props\n+ *                   -Djdk.jndi.rmi.object.factoriesFilter=com.test.TestFactory\n+ *                   RmiFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djava.security.properties=${test.src}\/allowRmiFilter.props\n+ *                   RmiFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djava.security.properties=${test.src}\/allowRmiFilter.props\n+ *                   -Djdk.jndi.ldap.object.factoriesFilter=!com.test.TestFactory\n+ *                   RmiFactoriesFilterTest true true\n+ *\n+ * @run main\/othervm -Djava.security.properties=${test.src}\/allowRmiFilter.props\n+ *                   -Djdk.jndi.rmi.object.factoriesFilter=!com.test.TestFactory\n+ *                   RmiFactoriesFilterTest false true\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=.*\n+ *                   RmiFactoriesFilterTest false false\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=*\n+ *                   -Djdk.jndi.object.factoriesFilter=.*\n+ *                   RmiFactoriesFilterTest false false\n+ *\n+ * @run main\/othervm -Djdk.jndi.rmi.object.factoriesFilter=*\n+ *                   -Djdk.jndi.object.factoriesFilter=*\n+ *                   -Djdk.jndi.ldap.object.factoriesFilter=.*\n+ *                   RmiFactoriesFilterTest true true\n+ *\/\n+\n+public class RmiFactoriesFilterTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        boolean classExpectedToLoad = Boolean.parseBoolean(args[0]);\n+        boolean rmiAndGlobalFiltersValid =\n+                Boolean.parseBoolean(args[1]);\n+        int registryPort;\n+        try {\n+            Registry registry = TestLibrary.createRegistryOnEphemeralPort();\n+            registryPort = TestLibrary.getRegistryPort(registry);\n+            System.out.println(\"Registry port: \" + registryPort);\n+        } catch (RemoteException re) {\n+            throw new RuntimeException(\"Failed to create registry\", re);\n+        }\n+\n+        Context context = getInitialContext(registryPort);\n+        \/\/ Bind the Reference object\n+        Reference ref = new Reference(\"TestObject\", \"com.test.TestFactory\",\n+                null);\n+        context.bind(\"objectTest\", ref);\n+\n+        loadUsingFactoryFromTCCL(registryPort, classExpectedToLoad, rmiAndGlobalFiltersValid);\n+        if (!rmiAndGlobalFiltersValid) {\n+            \/\/ Check that IAE is set as NamingException cause for malformed RMI or GLOBAL\n+            \/\/ filter values when lookup is called for the second time\n+            loadUsingFactoryFromTCCL(registryPort, classExpectedToLoad, false);\n+        }\n+    }\n+\n+    private static Context getInitialContext(int port) throws NamingException {\n+        Hashtable<String, String> env = new Hashtable<>();\n+        env.put(Context.INITIAL_CONTEXT_FACTORY,\n+                \"com.sun.jndi.rmi.registry.RegistryContextFactory\");\n+        env.put(Context.PROVIDER_URL, \"rmi:\/\/127.0.0.1:\" + port);\n+        return new InitialContext(env);\n+    }\n+\n+    private static void loadUsingFactoryFromTCCL(int registryPort,\n+                                                 boolean classExpectedToLoad,\n+                                                 boolean rmiAndGlobalFiltersValid) {\n+\n+\n+        try {\n+            Context context = getInitialContext(registryPort);\n+            Object object = context.lookup(\"objectTest\");\n+            System.out.println(\"Number of getObjectInstance calls:\" +\n+                    com.test.TestFactory.getNumberOfGetInstanceCalls());\n+            System.out.println(\"Loaded class type:\" + object.getClass().getCanonicalName());\n+            System.out.println(\"Loaded class: \" + object);\n+            if (classExpectedToLoad) {\n+                if (!\"TestObject\".equals(object)) {\n+                    throw new AssertionError(\"Class was expected to get loaded by the factory\");\n+                }\n+            } else {\n+                if (\"TestObject\".equals(object)) {\n+                    throw new AssertionError(\"Class was unexpectedly loaded by the factory\");\n+                }\n+            }\n+        } catch (NamingException ne) {\n+            \/\/ Only expecting NamingException for cases when RMI or GLOBAL filters are malformed\n+            if (rmiAndGlobalFiltersValid) {\n+                throw new AssertionError(\"Unexpected NamingException observed\", ne);\n+            }\n+            if (ne.getCause() instanceof IllegalArgumentException iae) {\n+                \/\/ All tests with malformed filters contain wildcards with\n+                \/\/ package name missing, therefore the message is expected\n+                \/\/ to start with \"package missing in:\"\n+                System.err.println(\"Found expected exception: \" + iae);\n+            } else {\n+                throw new AssertionError(\"IllegalArgument exception\" +\n+                        \" is expected for malformed filter values\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jndi\/rmi\/registry\/objects\/RmiFactoriesFilterTest.java","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.test;\n+\n+import javax.naming.Context;\n+import javax.naming.Name;\n+import javax.naming.Reference;\n+import javax.naming.spi.ObjectFactory;\n+import java.util.Hashtable;\n+\n+public class TestFactory implements ObjectFactory {\n+\n+    \/**\n+     * Get the number of {@code TestFactory.getObjectInstance} calls\n+     *\n+     * @return the number of calls\n+     *\/\n+    public static int getNumberOfGetInstanceCalls() {\n+        return timesGetInstanceCalled;\n+    }\n+\n+    \/**\n+     * @param obj         The possibly null object containing location or reference\n+     *                    information that can be used in creating an object.\n+     * @param name        The name of this object relative to {@code nameCtx},\n+     *                    or null if no name is specified.\n+     * @param nameCtx     The context relative to which the {@code name}\n+     *                    parameter is specified, or null if {@code name} is\n+     *                    relative to the default initial context.\n+     * @param environment The possibly null environment that is used in\n+     *                    creating the object.\n+     * @return If specified object is a {@code Reference} returns a {@code String} with a class\n+     * name specified in the reference, otherwise returns {@code \"TestObj\"}\n+     * @throws Exception\n+     *\/\n+    @Override\n+    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable<?, ?> environment) throws Exception {\n+        timesGetInstanceCalled++;\n+        String loadedObject;\n+        if (obj instanceof Reference) {\n+            Reference r = (Reference) obj;\n+            System.err.println(\"TestFactory: loading javax.naming.Reference:\");\n+            System.err.println(\"\\tFactory location=\" + r.getFactoryClassLocation());\n+            System.err.println(\"\\tFactory class name=\" + r.getFactoryClassName());\n+            System.err.println(\"\\tClass name=\" + r.getClassName());\n+            loadedObject = r.getClassName();\n+        } else {\n+            System.err.println(\"TestFactory: loading \" + obj.getClass().getName());\n+            loadedObject = \"TestObj\";\n+        }\n+        return loadedObject;\n+    }\n+\n+    private static volatile int timesGetInstanceCalled;\n+}\n+\n","filename":"test\/jdk\/com\/sun\/jndi\/rmi\/registry\/objects\/TestFactory.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+jdk.jndi.rmi.object.factoriesFilter=com.test.TestFactory;!*\n","filename":"test\/jdk\/com\/sun\/jndi\/rmi\/registry\/objects\/allowRmiFilter.props","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+jdk.jndi.rmi.object.factoriesFilter=!com.test.TestFactory;*\n","filename":"test\/jdk\/com\/sun\/jndi\/rmi\/registry\/objects\/disallowRmiFilter.props","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -101,1 +101,2 @@\n-                \"-Dcom.sun.jndi.ldap.object.trustSerialData=true\");\n+                \"-Dcom.sun.jndi.ldap.object.trustSerialData=true\",\n+                \"-Djdk.jndi.ldap.object.factoriesFilter=org.example.fruit.FruitFactory\");\n","filename":"test\/jdk\/javax\/naming\/module\/RunBasic.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}