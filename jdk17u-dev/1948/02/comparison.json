{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,1 @@\n-  \/\/ Support thin wrappers over primitive types.\n+  \/\/ Support thin wrappers over primitive types and other conversions.\n@@ -117,1 +117,14 @@\n-  template<typename T> struct Translate : public std::false_type {};\n+  template<typename T, typename Enable = void>\n+  struct Translate : public std::false_type {};\n+};\n+\n+\/\/ Enum types translate to\/from their underlying type.\n+template<typename T>\n+struct PrimitiveConversions::Translate<T, std::enable_if_t<std::is_enum<T>::value>>\n+  : public std::true_type\n+{\n+  using Value = T;\n+  using Decayed = std::underlying_type_t<T>;\n+\n+  static constexpr Decayed decay(Value x) { return static_cast<Decayed>(x); }\n+  static constexpr Value recover(Decayed x) { return static_cast<Value>(x); }\n","filename":"src\/hotspot\/share\/metaprogramming\/primitiveConversions.hpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -383,1 +383,1 @@\n-\/\/ Handle load for pointer, integral and enum types.\n+\/\/ Handle load for pointer and integral types.\n@@ -388,1 +388,1 @@\n-  typename EnableIf<IsIntegral<T>::value || std::is_enum<T>::value || IsPointer<T>::value>::type>\n+  typename EnableIf<IsIntegral<T>::value || IsPointer<T>::value>::type>\n@@ -433,1 +433,1 @@\n-\/\/ Handle store for integral and enum types.\n+\/\/ Handle store for integral types.\n@@ -440,1 +440,1 @@\n-  typename EnableIf<IsIntegral<T>::value || std::is_enum<T>::value>::type>\n+  typename EnableIf<IsIntegral<T>::value>::type>\n@@ -736,1 +736,1 @@\n-\/\/ Handle cmpxchg for integral and enum types.\n+\/\/ Handle cmpxchg for integral types.\n@@ -742,1 +742,1 @@\n-  typename EnableIf<IsIntegral<T>::value || std::is_enum<T>::value>::type>\n+  typename EnableIf<IsIntegral<T>::value>::type>\n@@ -871,1 +871,1 @@\n-\/\/ Handle xchg for integral and enum types.\n+\/\/ Handle xchg for integral types.\n@@ -877,1 +877,1 @@\n-  typename EnableIf<IsIntegral<T>::value || std::is_enum<T>::value>::type>\n+  typename EnableIf<IsIntegral<T>::value>::type>\n","filename":"src\/hotspot\/share\/runtime\/atomic.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,0 +174,17 @@\n+\n+TEST(PrimitiveConversionsTranslateTest, unscoped_enum) {\n+  enum TestEnum : int { A, B, C };\n+\n+  EXPECT_TRUE(PrimitiveConversions::Translate<TestEnum>::value);\n+  EXPECT_EQ(PrimitiveConversions::Translate<TestEnum>::decay(B), 1);\n+  EXPECT_EQ(PrimitiveConversions::Translate<TestEnum>::recover(1), B);\n+}\n+\n+TEST(PrimitiveConversionsTranslateTest, scoped_enum) {\n+  enum class TestEnum { A, B, C };\n+\n+  EXPECT_TRUE(PrimitiveConversions::Translate<TestEnum>::value);\n+  EXPECT_EQ(PrimitiveConversions::Translate<TestEnum>::decay(TestEnum::B), 1);\n+  EXPECT_EQ(PrimitiveConversions::Translate<TestEnum>::recover(1), TestEnum::B);\n+}\n+\n","filename":"test\/hotspot\/gtest\/metaprogramming\/test_primitiveConversions.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ These tests of Atomic only verify functionality.  They don't verify atomicity.\n+\n+template<typename T>\n+struct AtomicEnumTestSupport {\n+  volatile T _test_value;\n+\n+  AtomicEnumTestSupport() : _test_value{} {}\n+\n+  void test_store_load(T value) {\n+    EXPECT_NE(value, Atomic::load(&_test_value));\n+    Atomic::store(&_test_value, value);\n+    EXPECT_EQ(value, Atomic::load(&_test_value));\n+  }\n+\n+  void test_cmpxchg(T value1, T value2) {\n+    EXPECT_NE(value1, Atomic::load(&_test_value));\n+    Atomic::store(&_test_value, value1);\n+    EXPECT_EQ(value1, Atomic::cmpxchg(&_test_value, value2, value2));\n+    EXPECT_EQ(value1, Atomic::load(&_test_value));\n+    EXPECT_EQ(value1, Atomic::cmpxchg(&_test_value, value1, value2));\n+    EXPECT_EQ(value2, Atomic::load(&_test_value));\n+  }\n+\n+  void test_xchg(T value1, T value2) {\n+    EXPECT_NE(value1, Atomic::load(&_test_value));\n+    Atomic::store(&_test_value, value1);\n+    EXPECT_EQ(value1, Atomic::xchg(&_test_value, value2));\n+    EXPECT_EQ(value2, Atomic::load(&_test_value));\n+  }\n+};\n+\n+namespace AtomicEnumTestUnscoped {       \/\/ Scope the enumerators.\n+  enum TestEnum { A, B, C };\n+}\n+\n+TEST(AtomicEnumTest, unscoped_enum) {\n+  using namespace AtomicEnumTestUnscoped;\n+  using Support = AtomicEnumTestSupport<TestEnum>;\n+\n+  Support().test_store_load(B);\n+  Support().test_cmpxchg(B, C);\n+  Support().test_xchg(B, C);\n+}\n+\n+enum class AtomicEnumTestScoped { A, B, C };\n+\n+TEST(AtomicEnumTest, scoped_enum) {\n+  const AtomicEnumTestScoped B = AtomicEnumTestScoped::B;\n+  const AtomicEnumTestScoped C = AtomicEnumTestScoped::C;\n+  using Support = AtomicEnumTestSupport<AtomicEnumTestScoped>;\n+\n+  Support().test_store_load(B);\n+  Support().test_cmpxchg(B, C);\n+  Support().test_xchg(B, C);\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_atomic.cpp","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"}]}