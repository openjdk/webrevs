{"files":[{"patch":"@@ -494,3 +494,3 @@\n-static int check_stride_overflow(jlong stride_con, const TypeInteger* limit_t, BasicType bt) {\n-  if (stride_con > 0) {\n-    if (limit_t->lo_as_long() > (max_signed_integer(bt) - stride_con)) {\n+static int check_stride_overflow(jlong final_correction, const TypeInteger* limit_t, BasicType bt) {\n+  if (final_correction > 0) {\n+    if (limit_t->lo_as_long() > (max_signed_integer(bt) - final_correction)) {\n@@ -499,1 +499,1 @@\n-    if (limit_t->hi_as_long() > (max_signed_integer(bt) - stride_con)) {\n+    if (limit_t->hi_as_long() > (max_signed_integer(bt) - final_correction)) {\n@@ -503,1 +503,1 @@\n-    if (limit_t->hi_as_long() < (min_signed_integer(bt) - stride_con)) {\n+    if (limit_t->hi_as_long() < (min_signed_integer(bt) - final_correction)) {\n@@ -506,1 +506,1 @@\n-    if (limit_t->lo_as_long() < (min_signed_integer(bt) - stride_con)) {\n+    if (limit_t->lo_as_long() < (min_signed_integer(bt) - final_correction)) {\n@@ -1347,2 +1347,109 @@\n-  \/\/ Generate loop limit check to avoid integer overflow\n-  \/\/ in cases like next (cyclic loops):\n+  \/\/ We can only convert this loop to a counted loop if we can guarantee that the iv phi will never overflow at runtime.\n+  \/\/ This is an implicit assumption taken by some loop optimizations. We therefore must ensure this property at all cost.\n+  \/\/ At this point, we've already excluded some trivial cases where an overflow could have been proven statically.\n+  \/\/ But even though we cannot prove that an overflow will *not* happen, we still want to speculatively convert this loop\n+  \/\/ to a counted loop. This can be achieved by adding additional iv phi overflow checks before the loop. If they fail,\n+  \/\/ we trap and resume execution before the loop without having executed any iteration of the loop, yet.\n+  \/\/\n+  \/\/ These additional iv phi overflow checks can be inserted as Loop Limit Check Predicates above the Loop Limit Check\n+  \/\/ Parse Predicate which captures a JVM state just before the entry of the loop. If there is no such Parse Predicate,\n+  \/\/ we cannot generate a Loop Limit Check Predicate and thus cannot speculatively convert the loop to a counted loop.\n+  \/\/\n+  \/\/ In the following, we only focus on int loops with stride > 0 to keep things simple. The argumentation and proof\n+  \/\/ for stride < 0 is analogously. For long loops, we would replace max_int with max_long.\n+  \/\/\n+  \/\/\n+  \/\/ The loop to be converted does not always need to have the often used shape:\n+  \/\/\n+  \/\/                                                 i = init\n+  \/\/     i = init                                loop:\n+  \/\/     do {                                        ...\n+  \/\/         \/\/ ...               equivalent         i+=stride\n+  \/\/         i+=stride               <==>            if (i < limit)\n+  \/\/     } while (i < limit);                          goto loop\n+  \/\/                                             exit:\n+  \/\/                                                 ...\n+  \/\/\n+  \/\/ where the loop exit check uses the post-incremented iv phi and a '<'-operator.\n+  \/\/\n+  \/\/ We could also have '<='-operator (or '>='-operator for negative strides) or use the pre-incremented iv phi value\n+  \/\/ in the loop exit check:\n+  \/\/\n+  \/\/         i = init\n+  \/\/     loop:\n+  \/\/         ...\n+  \/\/         if (i <= limit)\n+  \/\/             i+=stride\n+  \/\/             goto loop\n+  \/\/     exit:\n+  \/\/         ...\n+  \/\/\n+  \/\/ Let's define the following terms:\n+  \/\/ - iv_pre_i: The pre-incremented iv phi before the i-th iteration.\n+  \/\/ - iv_post_i: The post-incremented iv phi after the i-th iteration.\n+  \/\/\n+  \/\/ The iv_pre_i and iv_post_i have the following relation:\n+  \/\/      iv_pre_i + stride = iv_post_i\n+  \/\/\n+  \/\/ When converting a loop to a counted loop, we want to have a canonicalized loop exit check of the form:\n+  \/\/     iv_post_i < adjusted_limit\n+  \/\/\n+  \/\/ If that is not the case, we need to canonicalize the loop exit check by using different values for adjusted_limit:\n+  \/\/ (LE1) iv_post_i < limit: Already canonicalized. We can directly use limit as adjusted_limit.\n+  \/\/           -> adjusted_limit = limit.\n+  \/\/ (LE2) iv_post_i <= limit:\n+  \/\/           iv_post_i < limit + 1\n+  \/\/           -> adjusted limit = limit + 1\n+  \/\/ (LE3) iv_pre_i < limit:\n+  \/\/           iv_pre_i + stride < limit + stride\n+  \/\/           iv_post_i < limit + stride\n+  \/\/           -> adjusted_limit = limit + stride\n+  \/\/ (LE4) iv_pre_i <= limit:\n+  \/\/           iv_pre_i < limit + 1\n+  \/\/           iv_pre_i + stride < limit + stride + 1\n+  \/\/           iv_post_i < limit + stride + 1\n+  \/\/           -> adjusted_limit = limit + stride + 1\n+  \/\/\n+  \/\/ Note that:\n+  \/\/     (AL) limit <= adjusted_limit.\n+  \/\/\n+  \/\/ The following loop invariant has to hold for counted loops with n iterations (i.e. loop exit check true after n-th\n+  \/\/ loop iteration) and a canonicalized loop exit check to guarantee that no iv_post_i over- or underflows:\n+  \/\/ (INV) For i = 1..n, min_int <= iv_post_i <= max_int\n+  \/\/\n+  \/\/ To prove (INV), we require the following two conditions\/assumptions:\n+  \/\/ (i): adjusted_limit - 1 + stride <= max_int\n+  \/\/ (ii): init < limit\n+  \/\/\n+  \/\/ If we can prove (INV), we know that there can be no over- or underflow of any iv phi value. We prove (INV) by\n+  \/\/ induction by assuming (i) and (ii).\n+  \/\/\n+  \/\/ Proof by Induction\n+  \/\/ ------------------\n+  \/\/ > Base case (i = 1): We show that (INV) holds after the first iteration:\n+  \/\/     min_int <= iv_post_1 = init + stride <= max_int\n+  \/\/ Proof:\n+  \/\/     First, we note that (ii) implies\n+  \/\/         (iii) init <= limit - 1\n+  \/\/     max_int >= adjusted_limit - 1 + stride   [using (i)]\n+  \/\/             >= limit - 1 + stride            [using (AL)]\n+  \/\/             >= init + stride                 [using (iii)]\n+  \/\/             >= min_int                       [using stride > 0, no underflow]\n+  \/\/ Thus, no overflow happens after the first iteration and (INV) holds for i = 1.\n+  \/\/\n+  \/\/ Note that to prove the base case we need (i) and (ii).\n+  \/\/\n+  \/\/ > Induction Hypothesis (i = j, j > 1): Assume that (INV) holds after the j-th iteration:\n+  \/\/     min_int <= iv_post_j <= max_int\n+  \/\/ > Step case (i = j + 1): We show that (INV) also holds after the j+1-th iteration:\n+  \/\/     min_int <= iv_post_{j+1} = iv_post_j + stride <= max_int\n+  \/\/ Proof:\n+  \/\/ If iv_post_j >= adjusted_limit:\n+  \/\/     We exit the loop after the j-th iteration, and we don't execute the j+1-th iteration anymore. Thus, there is\n+  \/\/     also no iv_{j+1}. Since (INV) holds for iv_j, there is nothing left to prove.\n+  \/\/ If iv_post_j < adjusted_limit:\n+  \/\/     First, we note that:\n+  \/\/         (iv) iv_post_j <= adjusted_limit - 1\n+  \/\/     max_int >= adjusted_limit - 1 + stride    [using (i)]\n+  \/\/             >= iv_post_j + stride             [using (iv)]\n+  \/\/             >= min_int                        [using stride > 0, no underflow]\n@@ -1350,2 +1457,1 @@\n-  \/\/ for (i=0; i <= max_jint; i++) {}\n-  \/\/ for (i=0; i <  max_jint; i+=2) {}\n+  \/\/ Note that to prove the step case we only need (i).\n@@ -1353,0 +1459,1 @@\n+  \/\/ Thus, by assuming (i) and (ii), we proved (INV).\n@@ -1354,4 +1461,1 @@\n-  \/\/ Limit check predicate depends on the loop test:\n-  \/\/ for(;i != limit; i++)       --> limit <= (max_jint)\n-  \/\/ for(;i <  limit; i+=stride) --> limit <= (max_jint - stride + 1)\n-  \/\/ for(;i <= limit; i+=stride) --> limit <= (max_jint - stride    )\n+  \/\/ It is therefore enough to add the following two Loop Limit Check Predicates to check assumptions (i) and (ii):\n@@ -1360,0 +1464,52 @@\n+  \/\/ (1) Loop Limit Check Predicate for (i):\n+  \/\/     Using (i): adjusted_limit - 1 + stride <= max_int\n+  \/\/\n+  \/\/     This condition is now restated to use limit instead of adjusted_limit:\n+  \/\/\n+  \/\/     To prevent an overflow of adjusted_limit -1 + stride itself, we rewrite this check to\n+  \/\/         max_int - stride + 1 >= adjusted_limit\n+  \/\/     We can merge the two constants into\n+  \/\/         canonicalized_correction = stride - 1\n+  \/\/     which gives us\n+  \/\/        max_int - canonicalized_correction >= adjusted_limit\n+  \/\/\n+  \/\/     To directly use limit instead of adjusted_limit in the predicate condition, we split adjusted_limit into:\n+  \/\/         adjusted_limit = limit + limit_correction\n+  \/\/     Since stride > 0 and limit_correction <= stride + 1, we can restate this with no over- or underflow into:\n+  \/\/         max_int - canonicalized_correction - limit_correction >= limit\n+  \/\/     Since canonicalized_correction and limit_correction are both constants, we can replace them with a new constant:\n+  \/\/         final_correction = canonicalized_correction + limit_correction\n+  \/\/     which gives us:\n+  \/\/\n+  \/\/     Final predicate condition:\n+  \/\/         max_int - final_correction >= limit\n+  \/\/\n+  \/\/ (2) Loop Limit Check Predicate for (ii):\n+  \/\/     Using (ii): init < limit\n+  \/\/\n+  \/\/     This Loop Limit Check Predicate is not required if we can prove at compile time that either:\n+  \/\/        (2.1) type(init) < type(limit)\n+  \/\/             In this case, we know:\n+  \/\/                 all possible values of init < all possible values of limit\n+  \/\/             and we can skip the predicate.\n+  \/\/\n+  \/\/        (2.2) init < limit is already checked before (i.e. found as a dominating check)\n+  \/\/            In this case, we do not need to re-check the condition and can skip the predicate.\n+  \/\/            This is often found for while- and for-loops which have the following shape:\n+  \/\/\n+  \/\/                if (init < limit) { \/\/ Dominating test. Do not need the Loop Limit Check Predicate below.\n+  \/\/                    i = init;\n+  \/\/                    if (init >= limit) { trap(); } \/\/ Here we would insert the Loop Limit Check Predicate\n+  \/\/                    do {\n+  \/\/                        i += stride;\n+  \/\/                    } while (i < limit);\n+  \/\/                }\n+  \/\/\n+  \/\/        (2.3) init + stride <= max_int\n+  \/\/            In this case, there is no overflow of the iv phi after the first loop iteration.\n+  \/\/            In the proof of the base case above we showed that init + stride <= max_int by using assumption (ii):\n+  \/\/                init < limit\n+  \/\/            In the proof of the step case above, we did not need (ii) anymore. Therefore, if we already know at\n+  \/\/            compile time that init + stride <= max_int then we have trivially proven the base case and that\n+  \/\/            there is no overflow of the iv phi after the first iteration. In this case, we don't need to check (ii)\n+  \/\/            again and can skip the predicate.\n@@ -1361,11 +1517,2 @@\n-  \/\/ Check if limit is excluded to do more precise int overflow check.\n-  bool incl_limit = (bt == BoolTest::le || bt == BoolTest::ge);\n-  jlong stride_m  = stride_con - (incl_limit ? 0 : (stride_con > 0 ? 1 : -1));\n-  \/\/ If compare points directly to the phi we need to adjust\n-  \/\/ the compare so that it points to the incr. Limit have\n-  \/\/ to be adjusted to keep trip count the same and the\n-  \/\/ adjusted limit should be checked for int overflow.\n-  Node* adjusted_limit = limit;\n-  if (phi_incr != nullptr) {\n-    stride_m  += stride_con;\n-  }\n+  \/\/ Accounting for (LE3) and (LE4) where we use pre-incremented phis in the loop exit check.\n+  const jlong limit_correction_for_pre_iv_exit_check = (phi_incr != nullptr) ? stride_con : 0;\n@@ -1374,1 +1521,10 @@\n-  Node *init_control = x->in(LoopNode::EntryControl);\n+  \/\/ Accounting for (LE2) and (LE4) where we use <= or >= in the loop exit check.\n+  const bool includes_limit = (bt == BoolTest::le || bt == BoolTest::ge);\n+  const jlong limit_correction_for_le_ge_exit_check = (includes_limit ? (stride_con > 0 ? 1 : -1) : 0);\n+\n+  const jlong limit_correction = limit_correction_for_pre_iv_exit_check + limit_correction_for_le_ge_exit_check;\n+  const jlong canonicalized_correction = stride_con + (stride_con > 0 ? -1 : 1);\n+  const jlong final_correction = canonicalized_correction + limit_correction;\n+\n+  int sov = check_stride_overflow(final_correction, limit_t, iv_bt);\n+  Node* init_control = x->in(LoopNode::EntryControl);\n@@ -1376,1 +1532,0 @@\n-  int sov = check_stride_overflow(stride_m, limit_t, iv_bt);\n@@ -1383,0 +1538,2 @@\n+    \/\/ (1) Loop Limit Check Predicate is required because we could not statically prove that\n+    \/\/     limit + final_correction = adjusted_limit - 1 + stride <= max_int\n@@ -1384,2 +1541,0 @@\n-    \/\/ Generate loop's limit check.\n-    \/\/ Loop limit check predicate should be near the loop.\n@@ -1388,1 +1543,1 @@\n-      \/\/ The limit check predicate is not generated if this method trapped here before.\n+      \/\/ The Loop Limit Check Parse Predicate is not generated if this method trapped here before.\n@@ -1409,1 +1564,1 @@\n-      cmp_limit = CmpNode::make(limit, _igvn.integercon(max_jint - stride_m, iv_bt), iv_bt);\n+      cmp_limit = CmpNode::make(limit, _igvn.integercon(max_signed_integer(iv_bt) - final_correction, iv_bt), iv_bt);\n@@ -1412,1 +1567,1 @@\n-      cmp_limit = CmpNode::make(limit, _igvn.integercon(min_jint - stride_m, iv_bt), iv_bt);\n+      cmp_limit = CmpNode::make(limit, _igvn.integercon(min_signed_integer(iv_bt) - final_correction, iv_bt), iv_bt);\n@@ -1419,13 +1574,23 @@\n-  \/\/ Now we need to canonicalize loop condition.\n-  if (bt == BoolTest::ne) {\n-    assert(stride_con == 1 || stride_con == -1, \"simple increment only\");\n-    if (stride_con > 0 && init_t->hi_as_long() < limit_t->lo_as_long()) {\n-      \/\/ 'ne' can be replaced with 'lt' only when init < limit.\n-      bt = BoolTest::lt;\n-    } else if (stride_con < 0 && init_t->lo_as_long() > limit_t->hi_as_long()) {\n-      \/\/ 'ne' can be replaced with 'gt' only when init > limit.\n-      bt = BoolTest::gt;\n-    } else {\n-      ProjNode *limit_check_proj = find_predicate_insertion_point(init_control, Deoptimization::Reason_loop_limit_check);\n-      if (!limit_check_proj) {\n-        \/\/ The limit check predicate is not generated if this method trapped here before.\n+  \/\/ (2.3)\n+  const bool init_plus_stride_could_overflow =\n+          (stride_con > 0 && init_t->hi_as_long() > max_signed_integer(iv_bt) - stride_con) ||\n+          (stride_con < 0 && init_t->lo_as_long() < min_signed_integer(iv_bt) - stride_con);\n+  \/\/ (2.1)\n+  const bool init_gte_limit = (stride_con > 0 && init_t->hi_as_long() >= limit_t->lo_as_long()) ||\n+                              (stride_con < 0 && init_t->lo_as_long() <= limit_t->hi_as_long());\n+\n+  if (init_gte_limit && \/\/ (2.1)\n+     ((bt == BoolTest::ne || init_plus_stride_could_overflow) && \/\/ (2.3)\n+      !has_dominating_loop_limit_check(init_trip, limit, stride_con, iv_bt, init_control))) { \/\/ (2.2)\n+    \/\/ (2) Iteration Loop Limit Check Predicate is required because neither (2.1), (2.2), nor (2.3) holds.\n+    \/\/ We use the following condition:\n+    \/\/ - stride > 0: init < limit\n+    \/\/ - stride < 0: init > limit\n+    \/\/\n+    \/\/ This predicate is always required if we have a non-equal-operator in the loop exit check (where stride = 1 is\n+    \/\/ a requirement). We transform the loop exit check by using a less-than-operator. By doing so, we must always\n+    \/\/ check that init < limit. Otherwise, we could have a different number of iterations at runtime.\n+\n+    ProjNode *limit_check_proj = find_predicate_insertion_point(init_control, Deoptimization::Reason_loop_limit_check);\n+    if (!limit_check_proj) {\n+      \/\/ The limit check predicate is not generated if this method trapped here before.\n@@ -1433,7 +1598,4 @@\n-        if (TraceLoopLimitCheck) {\n-          tty->print(\"missing loop limit check:\");\n-          loop->dump_head();\n-          x->dump(1);\n-        }\n-#endif\n-        return false;\n+      if (TraceLoopLimitCheck) {\n+        tty->print(\"missing loop limit check:\");\n+        loop->dump_head();\n+        x->dump(1);\n@@ -1441,1 +1603,4 @@\n-      IfNode* check_iff = limit_check_proj->in(0)->as_If();\n+#endif\n+      return false;\n+    }\n+    IfNode* check_iff = limit_check_proj->in(0)->as_If();\n@@ -1443,4 +1608,4 @@\n-      if (!is_dominator(get_ctrl(limit), check_iff->in(0)) ||\n-          !is_dominator(get_ctrl(init_trip), check_iff->in(0))) {\n-        return false;\n-      }\n+    if (!is_dominator(get_ctrl(limit), check_iff->in(0)) ||\n+        !is_dominator(get_ctrl(init_trip), check_iff->in(0))) {\n+      return false;\n+    }\n@@ -1448,2 +1613,2 @@\n-      Node* cmp_limit;\n-      Node* bol;\n+    Node* cmp_limit;\n+    Node* bol;\n@@ -1451,7 +1616,7 @@\n-      if (stride_con > 0) {\n-        cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n-        bol = new BoolNode(cmp_limit, BoolTest::lt);\n-      } else {\n-        cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n-        bol = new BoolNode(cmp_limit, BoolTest::gt);\n-      }\n+    if (stride_con > 0) {\n+      cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n+      bol = new BoolNode(cmp_limit, BoolTest::lt);\n+    } else {\n+      cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n+      bol = new BoolNode(cmp_limit, BoolTest::gt);\n+    }\n@@ -1459,1 +1624,2 @@\n-      insert_loop_limit_check(limit_check_proj, cmp_limit, bol);\n+    insert_loop_limit_check(limit_check_proj, cmp_limit, bol);\n+  }\n@@ -1461,7 +1627,10 @@\n-      if (stride_con > 0) {\n-        \/\/ 'ne' can be replaced with 'lt' only when init < limit.\n-        bt = BoolTest::lt;\n-      } else if (stride_con < 0) {\n-        \/\/ 'ne' can be replaced with 'gt' only when init > limit.\n-        bt = BoolTest::gt;\n-      }\n+  if (bt == BoolTest::ne) {\n+    \/\/ Now we need to canonicalize the loop condition if it is 'ne'.\n+    assert(stride_con == 1 || stride_con == -1, \"simple increment only - checked before\");\n+    if (stride_con > 0) {\n+      \/\/ 'ne' can be replaced with 'lt' only when init < limit. This is ensured by the inserted predicate above.\n+      bt = BoolTest::lt;\n+    } else {\n+      assert(stride_con < 0, \"must be\");\n+      \/\/ 'ne' can be replaced with 'gt' only when init > limit. This is ensured by the inserted predicate above.\n+      bt = BoolTest::gt;\n@@ -1512,0 +1681,1 @@\n+  Node* adjusted_limit = limit;\n@@ -1525,1 +1695,1 @@\n-  if (incl_limit) {\n+  if (includes_limit) {\n@@ -1706,0 +1876,31 @@\n+\/\/ Check if there is a dominating loop limit check of the form 'init < limit' starting at the loop entry.\n+\/\/ If there is one, then we do not need to create an additional Loop Limit Check Predicate.\n+bool PhaseIdealLoop::has_dominating_loop_limit_check(Node* init_trip, Node* limit, const jlong stride_con,\n+                                                     const BasicType iv_bt, Node* loop_entry) {\n+  \/\/ Eagerly call transform() on the Cmp and Bool node to common them up if possible. This is required in order to\n+  \/\/ successfully find a dominated test with the If node below.\n+  Node* cmp_limit;\n+  Node* bol;\n+  if (stride_con > 0) {\n+    cmp_limit = _igvn.transform(CmpNode::make(init_trip, limit, iv_bt));\n+    bol = _igvn.transform(new BoolNode(cmp_limit, BoolTest::lt));\n+  } else {\n+    cmp_limit = _igvn.transform(CmpNode::make(init_trip, limit, iv_bt));\n+    bol = _igvn.transform(new BoolNode(cmp_limit, BoolTest::gt));\n+  }\n+\n+  \/\/ Check if there is already a dominating init < limit check. If so, we do not need a Loop Limit Check Predicate.\n+  IfNode* iff = new IfNode(loop_entry, bol, PROB_MIN, COUNT_UNKNOWN);\n+  \/\/ Also add fake IfProj nodes in order to call transform() on the newly created IfNode.\n+  IfFalseNode* if_false = new IfFalseNode(iff);\n+  IfTrueNode* if_true = new IfTrueNode(iff);\n+  Node* dominated_iff = _igvn.transform(iff);\n+  \/\/ ConI node? Found dominating test (IfNode::dominated_by() returns a ConI node).\n+  const bool found_dominating_test = dominated_iff != nullptr && dominated_iff->is_ConI();\n+\n+  \/\/ Kill the If with its projections again in the next IGVN round by cutting it off from the graph.\n+  _igvn.replace_input_of(iff, 0, C->top());\n+  _igvn.replace_input_of(iff, 1, C->top());\n+  return found_dominating_test;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":276,"deletions":75,"binary":false,"changes":351,"status":"modified"},{"patch":"@@ -1299,0 +1299,2 @@\n+  bool has_dominating_loop_limit_check(Node* init_trip, Node* limit, jlong stride_con, BasicType iv_bt,\n+                                       Node* loop_entry);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}