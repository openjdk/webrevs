{"files":[{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.c2.cr7200264;\n-\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class TestDriver {\n-    private final Map<String, Long> expectedVectorizationNumbers\n-            = new HashMap<>();\n-\n-    public void addExpectedVectorization(String v, long num) {\n-        expectedVectorizationNumbers.put(v, num);\n-    }\n-\n-    public void run() throws Throwable {\n-        verifyVectorizationNumber(executeApplication());\n-    }\n-\n-    private List<String> executeApplication() throws Throwable {\n-        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJvm(\n-            \"-Xbatch\",\n-            \"-XX:-TieredCompilation\",\n-            \"-XX:+PrintCompilation\",\n-            \"-XX:+TraceNewVectors\",\n-            TestIntVect.class.getName());\n-        outputAnalyzer.shouldHaveExitValue(0);\n-        return outputAnalyzer.asLines();\n-    }\n-\n-    private void verifyVectorizationNumber(List<String> vectorizationLog) {\n-        for (Map.Entry<String, Long> entry : expectedVectorizationNumbers.entrySet()) {\n-            String v = entry.getKey();\n-            long actualNum = vectorizationLog.stream()\n-                    .filter(s -> s.contains(v)).count();\n-            long expectedNum = entry.getValue();\n-            Asserts.assertGTE(actualNum, expectedNum,\n-                              \"Unexpected \" + entry.getKey() + \" number\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr7200264\/TestDriver.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,8 @@\n+\/**\n+ * @test\n+ * @bug 7200264\n+ * @summary 7192963 changes disabled shift vectors\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.cr7200264.TestIntVect\n+ *\/\n+\n@@ -25,0 +33,3 @@\n+\n+import compiler.lib.ir_framework.*;\n+\n@@ -26,1 +37,1 @@\n- * Copy of test\/compiler\/6340864\/TestIntVect.java without performance tests.\n+ * Based on test\/hotspot\/jtreg\/compiler\/c2\/cr6340864\/TestIntVect.java without performance tests.\n@@ -29,452 +40,849 @@\n-  private static final int ARRLEN = 997;\n-  private static final int ITERS  = 11000;\n-  private static final int ADD_INIT = Integer.MAX_VALUE-500;\n-  private static final int BIT_MASK = 0xEC80F731;\n-  private static final int VALUE = 15;\n-  private static final int SHIFT = 32;\n-\n-  public static void main(String args[]) {\n-    System.out.println(\"Testing Integer vectors\");\n-    int errn = test();\n-    if (errn > 0) {\n-      System.err.println(\"FAILED: \" + errn + \" errors\");\n-      System.exit(97);\n-    }\n-    System.out.println(\"PASSED\");\n-  }\n-\n-  static int test() {\n-    int[] a0 = new int[ARRLEN];\n-    int[] a1 = new int[ARRLEN];\n-    int[] a2 = new int[ARRLEN];\n-    int[] a3 = new int[ARRLEN];\n-    int[] a4 = new int[ARRLEN];\n-    long[] p2 = new long[ARRLEN\/2];\n-    \/\/ Initialize\n-    int gold_sum = 0;\n-    for (int i=0; i<ARRLEN; i++) {\n-      int val = (int)(ADD_INIT+i);\n-      gold_sum += val;\n-      a1[i] = val;\n-      a2[i] = (int)VALUE;\n-      a3[i] = (int)-VALUE;\n-      a4[i] = (int)BIT_MASK;\n-    }\n-    System.out.println(\"Warmup\");\n-    for (int i=0; i<ITERS; i++) {\n-      test_sum(a1);\n-      test_addc(a0, a1);\n-      test_addv(a0, a1, (int)VALUE);\n-      test_adda(a0, a1, a2);\n-      test_subc(a0, a1);\n-      test_subv(a0, a1, (int)VALUE);\n-      test_suba(a0, a1, a2);\n-      test_mulc(a0, a1);\n-      test_mulv(a0, a1, (int)VALUE);\n-      test_mula(a0, a1, a2);\n-      test_divc(a0, a1);\n-      test_divv(a0, a1, (int)VALUE);\n-      test_diva(a0, a1, a2);\n-      test_mulc_n(a0, a1);\n-      test_mulv(a0, a1, (int)-VALUE);\n-      test_mula(a0, a1, a3);\n-      test_divc_n(a0, a1);\n-      test_divv(a0, a1, (int)-VALUE);\n-      test_diva(a0, a1, a3);\n-      test_andc(a0, a1);\n-      test_andv(a0, a1, (int)BIT_MASK);\n-      test_anda(a0, a1, a4);\n-      test_orc(a0, a1);\n-      test_orv(a0, a1, (int)BIT_MASK);\n-      test_ora(a0, a1, a4);\n-      test_xorc(a0, a1);\n-      test_xorv(a0, a1, (int)BIT_MASK);\n-      test_xora(a0, a1, a4);\n-      test_sllc(a0, a1);\n-      test_sllv(a0, a1, VALUE);\n-      test_srlc(a0, a1);\n-      test_srlv(a0, a1, VALUE);\n-      test_srac(a0, a1);\n-      test_srav(a0, a1, VALUE);\n-      test_sllc_n(a0, a1);\n-      test_sllv(a0, a1, -VALUE);\n-      test_srlc_n(a0, a1);\n-      test_srlv(a0, a1, -VALUE);\n-      test_srac_n(a0, a1);\n-      test_srav(a0, a1, -VALUE);\n-      test_sllc_o(a0, a1);\n-      test_sllv(a0, a1, SHIFT);\n-      test_srlc_o(a0, a1);\n-      test_srlv(a0, a1, SHIFT);\n-      test_srac_o(a0, a1);\n-      test_srav(a0, a1, SHIFT);\n-      test_sllc_on(a0, a1);\n-      test_sllv(a0, a1, -SHIFT);\n-      test_srlc_on(a0, a1);\n-      test_srlv(a0, a1, -SHIFT);\n-      test_srac_on(a0, a1);\n-      test_srav(a0, a1, -SHIFT);\n-      test_pack2(p2, a1);\n-      test_unpack2(a0, p2);\n-      test_pack2_swap(p2, a1);\n-      test_unpack2_swap(a0, p2);\n-    }\n-    \/\/ Test and verify results\n-    System.out.println(\"Verification\");\n-    int errn = 0;\n-    {\n-      int sum = test_sum(a1);\n-      if (sum != gold_sum) {\n-        System.err.println(\"test_sum:  \" + sum + \" != \" + gold_sum);\n-        errn++;\n-      }\n-\n-      test_addc(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_addc: \", i, a0[i], (int)((int)(ADD_INIT+i)+VALUE));\n-      }\n-      test_addv(a0, a1, (int)VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_addv: \", i, a0[i], (int)((int)(ADD_INIT+i)+VALUE));\n-      }\n-      test_adda(a0, a1, a2);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_adda: \", i, a0[i], (int)((int)(ADD_INIT+i)+VALUE));\n-      }\n-\n-      test_subc(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_subc: \", i, a0[i], (int)((int)(ADD_INIT+i)-VALUE));\n-      }\n-      test_subv(a0, a1, (int)VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_subv: \", i, a0[i], (int)((int)(ADD_INIT+i)-VALUE));\n-      }\n-      test_suba(a0, a1, a2);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_suba: \", i, a0[i], (int)((int)(ADD_INIT+i)-VALUE));\n-      }\n-\n-      test_mulc(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_mulc: \", i, a0[i], (int)((int)(ADD_INIT+i)*VALUE));\n-      }\n-      test_mulv(a0, a1, (int)VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_mulv: \", i, a0[i], (int)((int)(ADD_INIT+i)*VALUE));\n-      }\n-      test_mula(a0, a1, a2);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_mula: \", i, a0[i], (int)((int)(ADD_INIT+i)*VALUE));\n-      }\n-\n-      test_divc(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_divc: \", i, a0[i], (int)((int)(ADD_INIT+i)\/VALUE));\n-      }\n-      test_divv(a0, a1, (int)VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_divv: \", i, a0[i], (int)((int)(ADD_INIT+i)\/VALUE));\n-      }\n-      test_diva(a0, a1, a2);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_diva: \", i, a0[i], (int)((int)(ADD_INIT+i)\/VALUE));\n-      }\n-\n-      test_mulc_n(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_mulc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)*(-VALUE)));\n-      }\n-      test_mulv(a0, a1, (int)-VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_mulv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)*(-VALUE)));\n-      }\n-      test_mula(a0, a1, a3);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_mula_n: \", i, a0[i], (int)((int)(ADD_INIT+i)*(-VALUE)));\n-      }\n-\n-      test_divc_n(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_divc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)\/(-VALUE)));\n-      }\n-      test_divv(a0, a1, (int)-VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_divv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)\/(-VALUE)));\n-      }\n-      test_diva(a0, a1, a3);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_diva_n: \", i, a0[i], (int)((int)(ADD_INIT+i)\/(-VALUE)));\n-      }\n-\n-      test_andc(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_andc: \", i, a0[i], (int)((int)(ADD_INIT+i)&BIT_MASK));\n-      }\n-      test_andv(a0, a1, (int)BIT_MASK);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_andv: \", i, a0[i], (int)((int)(ADD_INIT+i)&BIT_MASK));\n-      }\n-      test_anda(a0, a1, a4);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_anda: \", i, a0[i], (int)((int)(ADD_INIT+i)&BIT_MASK));\n-      }\n-\n-      test_orc(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_orc: \", i, a0[i], (int)((int)(ADD_INIT+i)|BIT_MASK));\n-      }\n-      test_orv(a0, a1, (int)BIT_MASK);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_orv: \", i, a0[i], (int)((int)(ADD_INIT+i)|BIT_MASK));\n-      }\n-      test_ora(a0, a1, a4);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_ora: \", i, a0[i], (int)((int)(ADD_INIT+i)|BIT_MASK));\n-      }\n-\n-      test_xorc(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_xorc: \", i, a0[i], (int)((int)(ADD_INIT+i)^BIT_MASK));\n-      }\n-      test_xorv(a0, a1, (int)BIT_MASK);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_xorv: \", i, a0[i], (int)((int)(ADD_INIT+i)^BIT_MASK));\n-      }\n-      test_xora(a0, a1, a4);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_xora: \", i, a0[i], (int)((int)(ADD_INIT+i)^BIT_MASK));\n-      }\n-\n-      test_sllc(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_sllc: \", i, a0[i], (int)((int)(ADD_INIT+i)<<VALUE));\n-      }\n-      test_sllv(a0, a1, VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_sllv: \", i, a0[i], (int)((int)(ADD_INIT+i)<<VALUE));\n-      }\n-\n-      test_srlc(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srlc: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>VALUE));\n-      }\n-      test_srlv(a0, a1, VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srlv: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>VALUE));\n-      }\n-\n-      test_srac(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srac: \", i, a0[i], (int)((int)(ADD_INIT+i)>>VALUE));\n-      }\n-      test_srav(a0, a1, VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srav: \", i, a0[i], (int)((int)(ADD_INIT+i)>>VALUE));\n-      }\n-\n-      test_sllc_n(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_sllc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-VALUE)));\n-      }\n-      test_sllv(a0, a1, -VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_sllv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-VALUE)));\n-      }\n-\n-      test_srlc_n(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srlc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-VALUE)));\n-      }\n-      test_srlv(a0, a1, -VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srlv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-VALUE)));\n-      }\n-\n-      test_srac_n(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srac_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-VALUE)));\n-      }\n-      test_srav(a0, a1, -VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srav_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-VALUE)));\n-      }\n-\n-      test_sllc_o(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_sllc_o: \", i, a0[i], (int)((int)(ADD_INIT+i)<<SHIFT));\n-      }\n-      test_sllv(a0, a1, SHIFT);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_sllv_o: \", i, a0[i], (int)((int)(ADD_INIT+i)<<SHIFT));\n-      }\n-\n-      test_srlc_o(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srlc_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>SHIFT));\n-      }\n-      test_srlv(a0, a1, SHIFT);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srlv_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>SHIFT));\n-      }\n-\n-      test_srac_o(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srac_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>SHIFT));\n-      }\n-      test_srav(a0, a1, SHIFT);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srav_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>SHIFT));\n-      }\n-\n-      test_sllc_on(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_sllc_on: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-SHIFT)));\n-      }\n-      test_sllv(a0, a1, -SHIFT);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_sllv_on: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-SHIFT)));\n-      }\n-\n-      test_srlc_on(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srlc_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-SHIFT)));\n-      }\n-      test_srlv(a0, a1, -SHIFT);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srlv_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-SHIFT)));\n-      }\n-\n-      test_srac_on(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srac_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-SHIFT)));\n-      }\n-      test_srav(a0, a1, -SHIFT);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srav_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-SHIFT)));\n-      }\n-\n-      test_pack2(p2, a1);\n-      for (int i=0; i<ARRLEN\/2; i++) {\n-        errn += verify(\"test_pack2: \", i, p2[i], ((long)(ADD_INIT+2*i) & 0xFFFFFFFFl) | ((long)(ADD_INIT+2*i+1) << 32));\n-      }\n-      for (int i=0; i<ARRLEN; i++) {\n-        a0[i] = -1;\n-      }\n-      test_unpack2(a0, p2);\n-      for (int i=0; i<(ARRLEN&(-2)); i++) {\n-        errn += verify(\"test_unpack2: \", i, a0[i], (ADD_INIT+i));\n-      }\n-\n-      test_pack2_swap(p2, a1);\n-      for (int i=0; i<ARRLEN\/2; i++) {\n-        errn += verify(\"test_pack2_swap: \", i, p2[i], ((long)(ADD_INIT+2*i+1) & 0xFFFFFFFFl) | ((long)(ADD_INIT+2*i) << 32));\n-      }\n-      for (int i=0; i<ARRLEN; i++) {\n-        a0[i] = -1;\n-      }\n-      test_unpack2_swap(a0, p2);\n-      for (int i=0; i<(ARRLEN&(-2)); i++) {\n-        errn += verify(\"test_unpack2_swap: \", i, a0[i], (ADD_INIT+i));\n-      }\n-\n-    }\n-\n-    return errn;\n-  }\n-\n-  static int test_sum(int[] a1) {\n-    int sum = 0;\n-    for (int i = 0; i < a1.length; i+=1) {\n-      sum += a1[i];\n-    }\n-    return sum;\n-  }\n-\n-  static void test_addc(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]+VALUE);\n-    }\n-  }\n-  static void test_addv(int[] a0, int[] a1, int b) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]+b);\n-    }\n-  }\n-  static void test_adda(int[] a0, int[] a1, int[] a2) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]+a2[i]);\n-    }\n-  }\n-\n-  static void test_subc(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]-VALUE);\n-    }\n-  }\n-  static void test_subv(int[] a0, int[] a1, int b) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]-b);\n-    }\n-  }\n-  static void test_suba(int[] a0, int[] a1, int[] a2) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]-a2[i]);\n-    }\n-  }\n-\n-  static void test_mulc(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]*VALUE);\n-    }\n-  }\n-  static void test_mulc_n(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]*(-VALUE));\n-    }\n-  }\n-  static void test_mulv(int[] a0, int[] a1, int b) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]*b);\n-    }\n-  }\n-  static void test_mula(int[] a0, int[] a1, int[] a2) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]*a2[i]);\n-    }\n-  }\n-\n-  static void test_divc(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]\/VALUE);\n-    }\n-  }\n-  static void test_divc_n(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]\/(-VALUE));\n-    }\n-  }\n-  static void test_divv(int[] a0, int[] a1, int b) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]\/b);\n-    }\n-  }\n-  static void test_diva(int[] a0, int[] a1, int[] a2) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]\/a2[i]);\n-    }\n-  }\n-\n-  static void test_andc(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]&BIT_MASK);\n-    }\n-  }\n-  static void test_andv(int[] a0, int[] a1, int b) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]&b);\n-    }\n-  }\n-  static void test_anda(int[] a0, int[] a1, int[] a2) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]&a2[i]);\n+\n+    private static final int ARRLEN = 997;\n+    private static final int ITERS  = 11000;\n+    private static final int ADD_INIT = Integer.MAX_VALUE-500;\n+    private static final int BIT_MASK = 0xEC80F731;\n+    private static final int VALUE = 15;\n+    private static final int SHIFT = 32;\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\n+           \"test_sum\", \"test_addc\", \"test_addv\", \"test_adda\", \"test_subc\",\n+           \"test_subv\", \"test_suba\", \"test_mulc\", \"test_mulc_n\", \"test_mulv\",\n+           \"test_mula\", \"test_divc\", \"test_divc_n\", \"test_divv\", \"test_diva\",\n+           \"test_andc\", \"test_andv\", \"test_anda\", \"test_orc\", \"test_orv\",\n+           \"test_ora\", \"test_xorc\", \"test_xorv\", \"test_xora\", \"test_sllc\",\n+           \"test_sllc_n\", \"test_sllc_o\", \"test_sllc_on\", \"test_sllv\",\n+           \"test_srlc\", \"test_srlc_n\", \"test_srlc_o\", \"test_srlc_on\",\n+           \"test_srlv\", \"test_srac\", \"test_srac_n\", \"test_srac_o\",\n+           \"test_srac_on\", \"test_srav\", \"test_pack2\", \"test_unpack2\",\n+           \"test_pack2_swap\", \"test_unpack2_swap\"\n+         },\n+         mode = RunMode.STANDALONE)\n+    public void run() {\n+        System.out.println(\"Testing Integer vectors\");\n+\n+        \/\/ Initialize\n+        int[] a0 = new int[ARRLEN];\n+        int[] a1 = new int[ARRLEN];\n+        int[] a2 = new int[ARRLEN];\n+        int[] a3 = new int[ARRLEN];\n+        int[] a4 = new int[ARRLEN];\n+        long[] p2 = new long[ARRLEN\/2];\n+        int gold_sum = 0;\n+        for (int i=0; i<ARRLEN; i++) {\n+            int val = (int)(ADD_INIT+i);\n+            gold_sum += val;\n+            a1[i] = val;\n+            a2[i] = (int)VALUE;\n+            a3[i] = (int)-VALUE;\n+            a4[i] = (int)BIT_MASK;\n+        }\n+\n+        System.out.println(\"Warmup\");\n+        for (int i=0; i<ITERS; i++) {\n+            test_sum(a1);\n+            test_addc(a0, a1);\n+            test_addv(a0, a1, (int)VALUE);\n+            test_adda(a0, a1, a2);\n+            test_subc(a0, a1);\n+            test_subv(a0, a1, (int)VALUE);\n+            test_suba(a0, a1, a2);\n+            test_mulc(a0, a1);\n+            test_mulv(a0, a1, (int)VALUE);\n+            test_mula(a0, a1, a2);\n+            test_divc(a0, a1);\n+            test_divv(a0, a1, (int)VALUE);\n+            test_diva(a0, a1, a2);\n+            test_mulc_n(a0, a1);\n+            test_mulv(a0, a1, (int)-VALUE);\n+            test_mula(a0, a1, a3);\n+            test_divc_n(a0, a1);\n+            test_divv(a0, a1, (int)-VALUE);\n+            test_diva(a0, a1, a3);\n+            test_andc(a0, a1);\n+            test_andv(a0, a1, (int)BIT_MASK);\n+            test_anda(a0, a1, a4);\n+            test_orc(a0, a1);\n+            test_orv(a0, a1, (int)BIT_MASK);\n+            test_ora(a0, a1, a4);\n+            test_xorc(a0, a1);\n+            test_xorv(a0, a1, (int)BIT_MASK);\n+            test_xora(a0, a1, a4);\n+            test_sllc(a0, a1);\n+            test_sllv(a0, a1, VALUE);\n+            test_srlc(a0, a1);\n+            test_srlv(a0, a1, VALUE);\n+            test_srac(a0, a1);\n+            test_srav(a0, a1, VALUE);\n+            test_sllc_n(a0, a1);\n+            test_sllv(a0, a1, -VALUE);\n+            test_srlc_n(a0, a1);\n+            test_srlv(a0, a1, -VALUE);\n+            test_srac_n(a0, a1);\n+            test_srav(a0, a1, -VALUE);\n+            test_sllc_o(a0, a1);\n+            test_sllv(a0, a1, SHIFT);\n+            test_srlc_o(a0, a1);\n+            test_srlv(a0, a1, SHIFT);\n+            test_srac_o(a0, a1);\n+            test_srav(a0, a1, SHIFT);\n+            test_sllc_on(a0, a1);\n+            test_sllv(a0, a1, -SHIFT);\n+            test_srlc_on(a0, a1);\n+            test_srlv(a0, a1, -SHIFT);\n+            test_srac_on(a0, a1);\n+            test_srav(a0, a1, -SHIFT);\n+            test_pack2(p2, a1);\n+            test_unpack2(a0, p2);\n+            test_pack2_swap(p2, a1);\n+            test_unpack2_swap(a0, p2);\n+        }\n+\n+        \/\/ Test and verify results\n+        System.out.println(\"Verification\");\n+        int errn = 0;\n+        {\n+            int sum = test_sum(a1);\n+            if (sum != gold_sum) {\n+                System.err.println(\"test_sum:  \" + sum + \" != \" + gold_sum);\n+                errn++;\n+            }\n+\n+            test_addc(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_addc: \", i, a0[i], (int)((int)(ADD_INIT+i)+VALUE));\n+            }\n+            test_addv(a0, a1, (int)VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_addv: \", i, a0[i], (int)((int)(ADD_INIT+i)+VALUE));\n+            }\n+            test_adda(a0, a1, a2);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_adda: \", i, a0[i], (int)((int)(ADD_INIT+i)+VALUE));\n+            }\n+\n+            test_subc(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_subc: \", i, a0[i], (int)((int)(ADD_INIT+i)-VALUE));\n+            }\n+            test_subv(a0, a1, (int)VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_subv: \", i, a0[i], (int)((int)(ADD_INIT+i)-VALUE));\n+            }\n+            test_suba(a0, a1, a2);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_suba: \", i, a0[i], (int)((int)(ADD_INIT+i)-VALUE));\n+            }\n+\n+            test_mulc(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_mulc: \", i, a0[i], (int)((int)(ADD_INIT+i)*VALUE));\n+            }\n+            test_mulv(a0, a1, (int)VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_mulv: \", i, a0[i], (int)((int)(ADD_INIT+i)*VALUE));\n+            }\n+            test_mula(a0, a1, a2);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_mula: \", i, a0[i], (int)((int)(ADD_INIT+i)*VALUE));\n+            }\n+\n+            test_divc(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_divc: \", i, a0[i], (int)((int)(ADD_INIT+i)\/VALUE));\n+            }\n+            test_divv(a0, a1, (int)VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_divv: \", i, a0[i], (int)((int)(ADD_INIT+i)\/VALUE));\n+            }\n+            test_diva(a0, a1, a2);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_diva: \", i, a0[i], (int)((int)(ADD_INIT+i)\/VALUE));\n+            }\n+\n+            test_mulc_n(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_mulc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)*(-VALUE)));\n+            }\n+            test_mulv(a0, a1, (int)-VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_mulv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)*(-VALUE)));\n+            }\n+            test_mula(a0, a1, a3);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_mula_n: \", i, a0[i], (int)((int)(ADD_INIT+i)*(-VALUE)));\n+            }\n+\n+            test_divc_n(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_divc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)\/(-VALUE)));\n+            }\n+            test_divv(a0, a1, (int)-VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_divv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)\/(-VALUE)));\n+            }\n+            test_diva(a0, a1, a3);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_diva_n: \", i, a0[i], (int)((int)(ADD_INIT+i)\/(-VALUE)));\n+            }\n+\n+            test_andc(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_andc: \", i, a0[i], (int)((int)(ADD_INIT+i)&BIT_MASK));\n+            }\n+            test_andv(a0, a1, (int)BIT_MASK);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_andv: \", i, a0[i], (int)((int)(ADD_INIT+i)&BIT_MASK));\n+            }\n+            test_anda(a0, a1, a4);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_anda: \", i, a0[i], (int)((int)(ADD_INIT+i)&BIT_MASK));\n+            }\n+\n+            test_orc(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_orc: \", i, a0[i], (int)((int)(ADD_INIT+i)|BIT_MASK));\n+            }\n+            test_orv(a0, a1, (int)BIT_MASK);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_orv: \", i, a0[i], (int)((int)(ADD_INIT+i)|BIT_MASK));\n+            }\n+            test_ora(a0, a1, a4);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_ora: \", i, a0[i], (int)((int)(ADD_INIT+i)|BIT_MASK));\n+            }\n+\n+            test_xorc(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_xorc: \", i, a0[i], (int)((int)(ADD_INIT+i)^BIT_MASK));\n+            }\n+            test_xorv(a0, a1, (int)BIT_MASK);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_xorv: \", i, a0[i], (int)((int)(ADD_INIT+i)^BIT_MASK));\n+            }\n+            test_xora(a0, a1, a4);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_xora: \", i, a0[i], (int)((int)(ADD_INIT+i)^BIT_MASK));\n+            }\n+\n+            test_sllc(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_sllc: \", i, a0[i], (int)((int)(ADD_INIT+i)<<VALUE));\n+            }\n+            test_sllv(a0, a1, VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_sllv: \", i, a0[i], (int)((int)(ADD_INIT+i)<<VALUE));\n+            }\n+\n+            test_srlc(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srlc: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>VALUE));\n+            }\n+            test_srlv(a0, a1, VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srlv: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>VALUE));\n+            }\n+\n+            test_srac(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srac: \", i, a0[i], (int)((int)(ADD_INIT+i)>>VALUE));\n+            }\n+            test_srav(a0, a1, VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srav: \", i, a0[i], (int)((int)(ADD_INIT+i)>>VALUE));\n+            }\n+\n+            test_sllc_n(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_sllc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-VALUE)));\n+            }\n+            test_sllv(a0, a1, -VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_sllv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-VALUE)));\n+            }\n+\n+            test_srlc_n(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srlc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-VALUE)));\n+            }\n+            test_srlv(a0, a1, -VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srlv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-VALUE)));\n+            }\n+\n+            test_srac_n(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srac_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-VALUE)));\n+            }\n+            test_srav(a0, a1, -VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srav_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-VALUE)));\n+            }\n+\n+            test_sllc_o(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_sllc_o: \", i, a0[i], (int)((int)(ADD_INIT+i)<<SHIFT));\n+            }\n+            test_sllv(a0, a1, SHIFT);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_sllv_o: \", i, a0[i], (int)((int)(ADD_INIT+i)<<SHIFT));\n+            }\n+\n+            test_srlc_o(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srlc_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>SHIFT));\n+            }\n+            test_srlv(a0, a1, SHIFT);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srlv_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>SHIFT));\n+            }\n+\n+            test_srac_o(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srac_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>SHIFT));\n+            }\n+            test_srav(a0, a1, SHIFT);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srav_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>SHIFT));\n+            }\n+\n+            test_sllc_on(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_sllc_on: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-SHIFT)));\n+            }\n+            test_sllv(a0, a1, -SHIFT);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_sllv_on: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-SHIFT)));\n+            }\n+\n+            test_srlc_on(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srlc_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-SHIFT)));\n+            }\n+            test_srlv(a0, a1, -SHIFT);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srlv_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-SHIFT)));\n+            }\n+\n+            test_srac_on(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srac_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-SHIFT)));\n+            }\n+            test_srav(a0, a1, -SHIFT);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srav_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-SHIFT)));\n+            }\n+\n+            test_pack2(p2, a1);\n+            for (int i=0; i<ARRLEN\/2; i++) {\n+                errn += verify(\"test_pack2: \", i, p2[i], ((long)(ADD_INIT+2*i) & 0xFFFFFFFFl) | ((long)(ADD_INIT+2*i+1) << 32));\n+            }\n+            for (int i=0; i<ARRLEN; i++) {\n+                a0[i] = -1;\n+            }\n+            test_unpack2(a0, p2);\n+            for (int i=0; i<(ARRLEN&(-2)); i++) {\n+                errn += verify(\"test_unpack2: \", i, a0[i], (ADD_INIT+i));\n+            }\n+\n+            test_pack2_swap(p2, a1);\n+            for (int i=0; i<ARRLEN\/2; i++) {\n+                errn += verify(\"test_pack2_swap: \", i, p2[i], ((long)(ADD_INIT+2*i+1) & 0xFFFFFFFFl) | ((long)(ADD_INIT+2*i) << 32));\n+            }\n+            for (int i=0; i<ARRLEN; i++) {\n+                a0[i] = -1;\n+            }\n+            test_unpack2_swap(a0, p2);\n+            for (int i=0; i<(ARRLEN&(-2)); i++) {\n+                errn += verify(\"test_unpack2_swap: \", i, a0[i], (ADD_INIT+i));\n+            }\n+\n+        }\n+\n+        if (errn > 0) {\n+            throw new Error(\"FAILED: \" + errn + \" errors\");\n+        }\n+        System.out.println(\"PASSED\");\n+\n+    }\n+\n+    \/\/ Not vectorized: simple addition not profitable, see JDK-8307516. NOTE:\n+    \/\/ This check does not document the _desired_ behavior of the system but\n+    \/\/ the current behavior (no vectorization)\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n+                   IRNode.STORE_VECTOR,  \"= 0\" })\n+    int test_sum(int[] a1) {\n+        int sum = 0;\n+        for (int i = 0; i < a1.length; i+=1) {\n+            sum += a1[i];\n+        }\n+        return sum;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_addc(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]+VALUE);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_addv(int[] a0, int[] a1, int b) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]+b);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_adda(int[] a0, int[] a1, int[] a2) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]+a2[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_subc(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]-VALUE);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.SUB_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_subv(int[] a0, int[] a1, int b) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]-b);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.SUB_VI, \"> 0\", },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_suba(int[] a0, int[] a1, int[] a2) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]-a2[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.SUB_VI, \"> 0\", IRNode.LSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_mulc(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]*VALUE);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.SUB_VI, \"> 0\", IRNode.LSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_mulc_n(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]*(-VALUE));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MUL_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    void test_mulv(int[] a0, int[] a1, int b) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]*b);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MUL_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    void test_mula(int[] a0, int[] a1, int[] a2) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]*a2[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_VI,\n+                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                   IRNode.RSHIFT_VI,\n+                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                   IRNode.SUB_VI,\n+                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\" },\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    \/\/ Not vectorized: On aarch64, vectorization for this example results in\n+    \/\/ MulVL nodes, which asimd does not support.\n+    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n+                   IRNode.STORE_VECTOR,  \"= 0\",\n+                   IRNode.MUL_L,         \"> 0\" },\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n+    void test_divc(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]\/VALUE);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_VI,\n+                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                   IRNode.RSHIFT_VI,\n+                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                   IRNode.SUB_VI,\n+                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\" },\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    \/\/ Not vectorized: On aarch64, vectorization for this example results in\n+    \/\/ MulVL nodes, which asimd does not support.\n+    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n+                   IRNode.STORE_VECTOR,  \"= 0\",\n+                   IRNode.MUL_L,         \"> 0\" },\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n+    void test_divc_n(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]\/(-VALUE));\n+        }\n+    }\n+\n+    \/\/ Not vectorized: no vector div. NOTE: This check does not document the\n+    \/\/ _desired_ behavior of the system but the current behavior (no\n+    \/\/ vectorization)\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n+                   IRNode.STORE_VECTOR,  \"= 0\" })\n+    void test_divv(int[] a0, int[] a1, int b) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]\/b);\n+        }\n+    }\n+\n+    \/\/ Not vectorized: no vector div. NOTE: This check does not document the\n+    \/\/ _desired_ behavior of the system but the current behavior (no\n+    \/\/ vectorization)\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n+                   IRNode.STORE_VECTOR,  \"= 0\" })\n+    void test_diva(int[] a0, int[] a1, int[] a2) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]\/a2[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_andc(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]&BIT_MASK);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_andv(int[] a0, int[] a1, int b) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]&b);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_anda(int[] a0, int[] a1, int[] a2) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]&a2[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.OR_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_orc(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]|BIT_MASK);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.OR_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_orv(int[] a0, int[] a1, int b) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]|b);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.OR_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_ora(int[] a0, int[] a1, int[] a2) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]|a2[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_xorc(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]^BIT_MASK);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_xorv(int[] a0, int[] a1, int b) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]^b);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_xora(int[] a0, int[] a1, int[] a2) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]^a2[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_sllc(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]<<VALUE);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_sllc_n(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]<<(-VALUE));\n+        }\n+    }\n+\n+    \/\/ Vector shift not expected as shift is a NOP.\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_VI,     \"= 0\",\n+                   IRNode.LOAD_VECTOR_I, \"> 0\",\n+                   IRNode.STORE_VECTOR,  \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_sllc_o(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]<<SHIFT);\n+        }\n+    }\n+\n+    \/\/ Vector shift not expected as shift is a NOP.\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_VI,     \"= 0\",\n+                   IRNode.LOAD_VECTOR_I, \"> 0\",\n+                   IRNode.STORE_VECTOR,  \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_sllc_on(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]<<(-SHIFT));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_sllv(int[] a0, int[] a1, int b) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]<<b);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.URSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_srlc(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]>>>VALUE);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.URSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_srlc_n(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]>>>(-VALUE));\n+        }\n+    }\n+\n+    \/\/ Vector shift not expected as shift is a NOP.\n+    @Test\n+    @IR(counts = { IRNode.URSHIFT_VI,    \"= 0\",\n+                   IRNode.LOAD_VECTOR_I, \"> 0\",\n+                   IRNode.STORE_VECTOR,  \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_srlc_o(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]>>>SHIFT);\n+        }\n+    }\n+\n+    \/\/ Vector shift not expected as shift is a NOP.\n+    @Test\n+    @IR(counts = { IRNode.URSHIFT_VI,    \"= 0\",\n+                   IRNode.LOAD_VECTOR_I, \"> 0\",\n+                   IRNode.STORE_VECTOR,  \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_srlc_on(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]>>>(-SHIFT));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.URSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_srlv(int[] a0, int[] a1, int b) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]>>>b);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_srac(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]>>VALUE);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_srac_n(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]>>(-VALUE));\n+        }\n+    }\n+\n+    \/\/ Vector shift not expected as shift is a NOP.\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_VI,     \"= 0\",\n+                   IRNode.LOAD_VECTOR_I, \"> 0\",\n+                   IRNode.STORE_VECTOR,  \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_srac_o(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]>>SHIFT);\n+        }\n+    }\n+\n+    \/\/ Vector shift not expected as shift is a NOP.\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_VI,     \"= 0\",\n+                   IRNode.LOAD_VECTOR_I, \"> 0\",\n+                   IRNode.STORE_VECTOR,  \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_srac_on(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]>>(-SHIFT));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_srav(int[] a0, int[] a1, int b) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]>>b);\n+        }\n+    }\n+\n+    \/\/ Not vectorized currently. NOTE: This check does not document the\n+    \/\/ _desired_ behavior of the system but the current behavior (no\n+    \/\/ vectorization)\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n+                   IRNode.STORE_VECTOR,  \"= 0\" })\n+    void test_pack2(long[] p2, int[] a1) {\n+        if (p2.length*2 > a1.length) return;\n+        for (int i = 0; i < p2.length; i+=1) {\n+            long l0 = (long)a1[i*2+0];\n+            long l1 = (long)a1[i*2+1];\n+            p2[i] = (l1 << 32) | (l0 & 0xFFFFFFFFl);\n+        }\n+    }\n+\n+    \/\/ Not vectorized currently. NOTE: This check does not document the\n+    \/\/ _desired_ behavior of the system but the current behavior (no\n+    \/\/ vectorization)\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n+                   IRNode.STORE_VECTOR,  \"= 0\" })\n+    void test_unpack2(int[] a0, long[] p2) {\n+        if (p2.length*2 > a0.length) return;\n+        for (int i = 0; i < p2.length; i+=1) {\n+            long l = p2[i];\n+            a0[i*2+0] = (int)(l & 0xFFFFFFFFl);\n+            a0[i*2+1] = (int)(l >> 32);\n+        }\n+    }\n+\n+    \/\/ Not vectorized currently. NOTE: This check does not document the\n+    \/\/ _desired_ behavior of the system but the current behavior (no\n+    \/\/ vectorization)\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n+                   IRNode.STORE_VECTOR,  \"= 0\" })\n+    void test_pack2_swap(long[] p2, int[] a1) {\n+        if (p2.length*2 > a1.length) return;\n+        for (int i = 0; i < p2.length; i+=1) {\n+            long l0 = (long)a1[i*2+0];\n+            long l1 = (long)a1[i*2+1];\n+            p2[i] = (l0 << 32) | (l1 & 0xFFFFFFFFl);\n+        }\n+    }\n+\n+    \/\/ Not vectorized currently. NOTE: This check does not document the\n+    \/\/ _desired_ behavior of the system but the current behavior (no\n+    \/\/ vectorization)\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n+                   IRNode.STORE_VECTOR,  \"= 0\" })\n+    void test_unpack2_swap(int[] a0, long[] p2) {\n+        if (p2.length*2 > a0.length) return;\n+        for (int i = 0; i < p2.length; i+=1) {\n+            long l = p2[i];\n+            a0[i*2+0] = (int)(l >> 32);\n+            a0[i*2+1] = (int)(l & 0xFFFFFFFFl);\n+        }\n+    }\n+\n+    static int verify(String text, int i, int elem, int val) {\n+        if (elem != val) {\n+            System.err.println(text + \"[\" + i + \"] = \" + elem + \" != \" + val);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    static int verify(String text, int i, long elem, long val) {\n+        if (elem != val) {\n+            System.err.println(text + \"[\" + i + \"] = \" + Long.toHexString(elem) + \" != \" + Long.toHexString(val));\n+            return 1;\n+        }\n+        return 0;\n@@ -482,160 +890,0 @@\n-  }\n-\n-  static void test_orc(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]|BIT_MASK);\n-    }\n-  }\n-  static void test_orv(int[] a0, int[] a1, int b) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]|b);\n-    }\n-  }\n-  static void test_ora(int[] a0, int[] a1, int[] a2) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]|a2[i]);\n-    }\n-  }\n-\n-  static void test_xorc(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]^BIT_MASK);\n-    }\n-  }\n-  static void test_xorv(int[] a0, int[] a1, int b) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]^b);\n-    }\n-  }\n-  static void test_xora(int[] a0, int[] a1, int[] a2) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]^a2[i]);\n-    }\n-  }\n-\n-  static void test_sllc(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]<<VALUE);\n-    }\n-  }\n-  static void test_sllc_n(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]<<(-VALUE));\n-    }\n-  }\n-  static void test_sllc_o(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]<<SHIFT);\n-    }\n-  }\n-  static void test_sllc_on(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]<<(-SHIFT));\n-    }\n-  }\n-  static void test_sllv(int[] a0, int[] a1, int b) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]<<b);\n-    }\n-  }\n-\n-  static void test_srlc(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]>>>VALUE);\n-    }\n-  }\n-  static void test_srlc_n(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]>>>(-VALUE));\n-    }\n-  }\n-  static void test_srlc_o(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]>>>SHIFT);\n-    }\n-  }\n-  static void test_srlc_on(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]>>>(-SHIFT));\n-    }\n-  }\n-  static void test_srlv(int[] a0, int[] a1, int b) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]>>>b);\n-    }\n-  }\n-\n-  static void test_srac(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]>>VALUE);\n-    }\n-  }\n-  static void test_srac_n(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]>>(-VALUE));\n-    }\n-  }\n-  static void test_srac_o(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]>>SHIFT);\n-    }\n-  }\n-  static void test_srac_on(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]>>(-SHIFT));\n-    }\n-  }\n-  static void test_srav(int[] a0, int[] a1, int b) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]>>b);\n-    }\n-  }\n-\n-  static void test_pack2(long[] p2, int[] a1) {\n-    if (p2.length*2 > a1.length) return;\n-    for (int i = 0; i < p2.length; i+=1) {\n-      long l0 = (long)a1[i*2+0];\n-      long l1 = (long)a1[i*2+1];\n-      p2[i] = (l1 << 32) | (l0 & 0xFFFFFFFFl);\n-    }\n-  }\n-  static void test_unpack2(int[] a0, long[] p2) {\n-    if (p2.length*2 > a0.length) return;\n-    for (int i = 0; i < p2.length; i+=1) {\n-      long l = p2[i];\n-      a0[i*2+0] = (int)(l & 0xFFFFFFFFl);\n-      a0[i*2+1] = (int)(l >> 32);\n-    }\n-  }\n-  static void test_pack2_swap(long[] p2, int[] a1) {\n-    if (p2.length*2 > a1.length) return;\n-    for (int i = 0; i < p2.length; i+=1) {\n-      long l0 = (long)a1[i*2+0];\n-      long l1 = (long)a1[i*2+1];\n-      p2[i] = (l0 << 32) | (l1 & 0xFFFFFFFFl);\n-    }\n-  }\n-  static void test_unpack2_swap(int[] a0, long[] p2) {\n-    if (p2.length*2 > a0.length) return;\n-    for (int i = 0; i < p2.length; i+=1) {\n-      long l = p2[i];\n-      a0[i*2+0] = (int)(l >> 32);\n-      a0[i*2+1] = (int)(l & 0xFFFFFFFFl);\n-    }\n-  }\n-\n-  static int verify(String text, int i, int elem, int val) {\n-    if (elem != val) {\n-      System.err.println(text + \"[\" + i + \"] = \" + elem + \" != \" + val);\n-      return 1;\n-    }\n-    return 0;\n-  }\n-\n-  static int verify(String text, int i, long elem, long val) {\n-    if (elem != val) {\n-      System.err.println(text + \"[\" + i + \"] = \" + Long.toHexString(elem) + \" != \" + Long.toHexString(val));\n-      return 1;\n-    }\n-    return 0;\n-  }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr7200264\/TestIntVect.java","additions":862,"deletions":614,"binary":false,"changes":1476,"status":"modified"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 7200264\n- * @summary 7192963 changes disabled shift vectors\n- * @requires vm.cpu.features ~= \".*sse2.*\" & vm.debug & vm.flavor == \"server\"\n- * @requires !vm.emulatedClient & !vm.graal.enabled\n- * @library \/test\/lib \/\n- * @run driver compiler.c2.cr7200264.TestSSE2IntVect\n- *\/\n-\n-package compiler.c2.cr7200264;\n-\n-public class TestSSE2IntVect {\n-    public static void main(String[] args) throws Throwable {\n-        TestDriver test = new TestDriver();\n-        test.addExpectedVectorization(\"AddVI\", 4);\n-        test.addExpectedVectorization(\"SubVI\", 4);\n-        test.addExpectedVectorization(\"AndV\", 3);\n-        test.addExpectedVectorization(\"OrV\", 3);\n-        test.addExpectedVectorization(\"XorV\", 3);\n-        test.addExpectedVectorization(\"LShiftVI\", 5);\n-        test.addExpectedVectorization(\"RShiftVI\", 3);\n-        test.addExpectedVectorization(\"URShiftVI\", 3);\n-        test.run();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr7200264\/TestSSE2IntVect.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 7200264\n- * @summary 7192963 changes disabled shift vectors\n- * @requires vm.cpu.features ~= \".*sse4\\\\.1.*\" & vm.debug & vm.flavor == \"server\"\n- * @requires !vm.emulatedClient & !vm.graal.enabled\n- * @library \/test\/lib \/\n- * @run driver compiler.c2.cr7200264.TestSSE4IntVect\n- *\/\n-\n-package compiler.c2.cr7200264;\n-\n-public class TestSSE4IntVect {\n-    public static void main(String[] args) throws Throwable {\n-        TestDriver test = new TestDriver();\n-        test.addExpectedVectorization(\"MulVI\", 2);\n-        test.run();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr7200264\/TestSSE4IntVect.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"}]}