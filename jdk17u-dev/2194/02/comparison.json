{"files":[{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.c2.cr7200264;\n-\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class TestDriver {\n-    private final Map<String, Long> expectedVectorizationNumbers\n-            = new HashMap<>();\n-\n-    public void addExpectedVectorization(String v, long num) {\n-        expectedVectorizationNumbers.put(v, num);\n-    }\n-\n-    public void run() throws Throwable {\n-        verifyVectorizationNumber(executeApplication());\n-    }\n-\n-    private List<String> executeApplication() throws Throwable {\n-        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJvm(\n-            \"-Xbatch\",\n-            \"-XX:-TieredCompilation\",\n-            \"-XX:+PrintCompilation\",\n-            \"-XX:+TraceNewVectors\",\n-            TestIntVect.class.getName());\n-        outputAnalyzer.shouldHaveExitValue(0);\n-        return outputAnalyzer.asLines();\n-    }\n-\n-    private void verifyVectorizationNumber(List<String> vectorizationLog) {\n-        for (Map.Entry<String, Long> entry : expectedVectorizationNumbers.entrySet()) {\n-            String v = entry.getKey();\n-            long actualNum = vectorizationLog.stream()\n-                    .filter(s -> s.contains(v)).count();\n-            long expectedNum = entry.getValue();\n-            Asserts.assertGTE(actualNum, expectedNum,\n-                              \"Unexpected \" + entry.getKey() + \" number\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr7200264\/TestDriver.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,8 @@\n+\/**\n+ * @test\n+ * @bug 7200264\n+ * @summary 7192963 changes disabled shift vectors\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.cr7200264.TestIntVect\n+ *\/\n+\n@@ -25,0 +33,4 @@\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.driver.irmatching.mapping.IRNodeMapEntry;\n+\n@@ -26,1 +38,1 @@\n- * Copy of test\/compiler\/6340864\/TestIntVect.java without performance tests.\n+ * Based on test\/hotspot\/jtreg\/compiler\/c2\/cr6340864\/TestIntVect.java without performance tests.\n@@ -29,452 +41,849 @@\n-  private static final int ARRLEN = 997;\n-  private static final int ITERS  = 11000;\n-  private static final int ADD_INIT = Integer.MAX_VALUE-500;\n-  private static final int BIT_MASK = 0xEC80F731;\n-  private static final int VALUE = 15;\n-  private static final int SHIFT = 32;\n-\n-  public static void main(String args[]) {\n-    System.out.println(\"Testing Integer vectors\");\n-    int errn = test();\n-    if (errn > 0) {\n-      System.err.println(\"FAILED: \" + errn + \" errors\");\n-      System.exit(97);\n-    }\n-    System.out.println(\"PASSED\");\n-  }\n-\n-  static int test() {\n-    int[] a0 = new int[ARRLEN];\n-    int[] a1 = new int[ARRLEN];\n-    int[] a2 = new int[ARRLEN];\n-    int[] a3 = new int[ARRLEN];\n-    int[] a4 = new int[ARRLEN];\n-    long[] p2 = new long[ARRLEN\/2];\n-    \/\/ Initialize\n-    int gold_sum = 0;\n-    for (int i=0; i<ARRLEN; i++) {\n-      int val = (int)(ADD_INIT+i);\n-      gold_sum += val;\n-      a1[i] = val;\n-      a2[i] = (int)VALUE;\n-      a3[i] = (int)-VALUE;\n-      a4[i] = (int)BIT_MASK;\n-    }\n-    System.out.println(\"Warmup\");\n-    for (int i=0; i<ITERS; i++) {\n-      test_sum(a1);\n-      test_addc(a0, a1);\n-      test_addv(a0, a1, (int)VALUE);\n-      test_adda(a0, a1, a2);\n-      test_subc(a0, a1);\n-      test_subv(a0, a1, (int)VALUE);\n-      test_suba(a0, a1, a2);\n-      test_mulc(a0, a1);\n-      test_mulv(a0, a1, (int)VALUE);\n-      test_mula(a0, a1, a2);\n-      test_divc(a0, a1);\n-      test_divv(a0, a1, (int)VALUE);\n-      test_diva(a0, a1, a2);\n-      test_mulc_n(a0, a1);\n-      test_mulv(a0, a1, (int)-VALUE);\n-      test_mula(a0, a1, a3);\n-      test_divc_n(a0, a1);\n-      test_divv(a0, a1, (int)-VALUE);\n-      test_diva(a0, a1, a3);\n-      test_andc(a0, a1);\n-      test_andv(a0, a1, (int)BIT_MASK);\n-      test_anda(a0, a1, a4);\n-      test_orc(a0, a1);\n-      test_orv(a0, a1, (int)BIT_MASK);\n-      test_ora(a0, a1, a4);\n-      test_xorc(a0, a1);\n-      test_xorv(a0, a1, (int)BIT_MASK);\n-      test_xora(a0, a1, a4);\n-      test_sllc(a0, a1);\n-      test_sllv(a0, a1, VALUE);\n-      test_srlc(a0, a1);\n-      test_srlv(a0, a1, VALUE);\n-      test_srac(a0, a1);\n-      test_srav(a0, a1, VALUE);\n-      test_sllc_n(a0, a1);\n-      test_sllv(a0, a1, -VALUE);\n-      test_srlc_n(a0, a1);\n-      test_srlv(a0, a1, -VALUE);\n-      test_srac_n(a0, a1);\n-      test_srav(a0, a1, -VALUE);\n-      test_sllc_o(a0, a1);\n-      test_sllv(a0, a1, SHIFT);\n-      test_srlc_o(a0, a1);\n-      test_srlv(a0, a1, SHIFT);\n-      test_srac_o(a0, a1);\n-      test_srav(a0, a1, SHIFT);\n-      test_sllc_on(a0, a1);\n-      test_sllv(a0, a1, -SHIFT);\n-      test_srlc_on(a0, a1);\n-      test_srlv(a0, a1, -SHIFT);\n-      test_srac_on(a0, a1);\n-      test_srav(a0, a1, -SHIFT);\n-      test_pack2(p2, a1);\n-      test_unpack2(a0, p2);\n-      test_pack2_swap(p2, a1);\n-      test_unpack2_swap(a0, p2);\n-    }\n-    \/\/ Test and verify results\n-    System.out.println(\"Verification\");\n-    int errn = 0;\n-    {\n-      int sum = test_sum(a1);\n-      if (sum != gold_sum) {\n-        System.err.println(\"test_sum:  \" + sum + \" != \" + gold_sum);\n-        errn++;\n-      }\n-\n-      test_addc(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_addc: \", i, a0[i], (int)((int)(ADD_INIT+i)+VALUE));\n-      }\n-      test_addv(a0, a1, (int)VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_addv: \", i, a0[i], (int)((int)(ADD_INIT+i)+VALUE));\n-      }\n-      test_adda(a0, a1, a2);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_adda: \", i, a0[i], (int)((int)(ADD_INIT+i)+VALUE));\n-      }\n-\n-      test_subc(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_subc: \", i, a0[i], (int)((int)(ADD_INIT+i)-VALUE));\n-      }\n-      test_subv(a0, a1, (int)VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_subv: \", i, a0[i], (int)((int)(ADD_INIT+i)-VALUE));\n-      }\n-      test_suba(a0, a1, a2);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_suba: \", i, a0[i], (int)((int)(ADD_INIT+i)-VALUE));\n-      }\n-\n-      test_mulc(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_mulc: \", i, a0[i], (int)((int)(ADD_INIT+i)*VALUE));\n-      }\n-      test_mulv(a0, a1, (int)VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_mulv: \", i, a0[i], (int)((int)(ADD_INIT+i)*VALUE));\n-      }\n-      test_mula(a0, a1, a2);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_mula: \", i, a0[i], (int)((int)(ADD_INIT+i)*VALUE));\n-      }\n-\n-      test_divc(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_divc: \", i, a0[i], (int)((int)(ADD_INIT+i)\/VALUE));\n-      }\n-      test_divv(a0, a1, (int)VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_divv: \", i, a0[i], (int)((int)(ADD_INIT+i)\/VALUE));\n-      }\n-      test_diva(a0, a1, a2);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_diva: \", i, a0[i], (int)((int)(ADD_INIT+i)\/VALUE));\n-      }\n-\n-      test_mulc_n(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_mulc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)*(-VALUE)));\n-      }\n-      test_mulv(a0, a1, (int)-VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_mulv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)*(-VALUE)));\n-      }\n-      test_mula(a0, a1, a3);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_mula_n: \", i, a0[i], (int)((int)(ADD_INIT+i)*(-VALUE)));\n-      }\n-\n-      test_divc_n(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_divc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)\/(-VALUE)));\n-      }\n-      test_divv(a0, a1, (int)-VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_divv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)\/(-VALUE)));\n-      }\n-      test_diva(a0, a1, a3);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_diva_n: \", i, a0[i], (int)((int)(ADD_INIT+i)\/(-VALUE)));\n-      }\n-\n-      test_andc(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_andc: \", i, a0[i], (int)((int)(ADD_INIT+i)&BIT_MASK));\n-      }\n-      test_andv(a0, a1, (int)BIT_MASK);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_andv: \", i, a0[i], (int)((int)(ADD_INIT+i)&BIT_MASK));\n-      }\n-      test_anda(a0, a1, a4);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_anda: \", i, a0[i], (int)((int)(ADD_INIT+i)&BIT_MASK));\n-      }\n-\n-      test_orc(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_orc: \", i, a0[i], (int)((int)(ADD_INIT+i)|BIT_MASK));\n-      }\n-      test_orv(a0, a1, (int)BIT_MASK);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_orv: \", i, a0[i], (int)((int)(ADD_INIT+i)|BIT_MASK));\n-      }\n-      test_ora(a0, a1, a4);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_ora: \", i, a0[i], (int)((int)(ADD_INIT+i)|BIT_MASK));\n-      }\n-\n-      test_xorc(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_xorc: \", i, a0[i], (int)((int)(ADD_INIT+i)^BIT_MASK));\n-      }\n-      test_xorv(a0, a1, (int)BIT_MASK);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_xorv: \", i, a0[i], (int)((int)(ADD_INIT+i)^BIT_MASK));\n-      }\n-      test_xora(a0, a1, a4);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_xora: \", i, a0[i], (int)((int)(ADD_INIT+i)^BIT_MASK));\n-      }\n-\n-      test_sllc(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_sllc: \", i, a0[i], (int)((int)(ADD_INIT+i)<<VALUE));\n-      }\n-      test_sllv(a0, a1, VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_sllv: \", i, a0[i], (int)((int)(ADD_INIT+i)<<VALUE));\n-      }\n-\n-      test_srlc(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srlc: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>VALUE));\n-      }\n-      test_srlv(a0, a1, VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srlv: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>VALUE));\n-      }\n-\n-      test_srac(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srac: \", i, a0[i], (int)((int)(ADD_INIT+i)>>VALUE));\n-      }\n-      test_srav(a0, a1, VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srav: \", i, a0[i], (int)((int)(ADD_INIT+i)>>VALUE));\n-      }\n-\n-      test_sllc_n(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_sllc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-VALUE)));\n-      }\n-      test_sllv(a0, a1, -VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_sllv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-VALUE)));\n-      }\n-\n-      test_srlc_n(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srlc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-VALUE)));\n-      }\n-      test_srlv(a0, a1, -VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srlv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-VALUE)));\n-      }\n-\n-      test_srac_n(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srac_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-VALUE)));\n-      }\n-      test_srav(a0, a1, -VALUE);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srav_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-VALUE)));\n-      }\n-\n-      test_sllc_o(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_sllc_o: \", i, a0[i], (int)((int)(ADD_INIT+i)<<SHIFT));\n-      }\n-      test_sllv(a0, a1, SHIFT);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_sllv_o: \", i, a0[i], (int)((int)(ADD_INIT+i)<<SHIFT));\n-      }\n-\n-      test_srlc_o(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srlc_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>SHIFT));\n-      }\n-      test_srlv(a0, a1, SHIFT);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srlv_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>SHIFT));\n-      }\n-\n-      test_srac_o(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srac_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>SHIFT));\n-      }\n-      test_srav(a0, a1, SHIFT);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srav_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>SHIFT));\n-      }\n-\n-      test_sllc_on(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_sllc_on: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-SHIFT)));\n-      }\n-      test_sllv(a0, a1, -SHIFT);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_sllv_on: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-SHIFT)));\n-      }\n-\n-      test_srlc_on(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srlc_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-SHIFT)));\n-      }\n-      test_srlv(a0, a1, -SHIFT);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srlv_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-SHIFT)));\n-      }\n-\n-      test_srac_on(a0, a1);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srac_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-SHIFT)));\n-      }\n-      test_srav(a0, a1, -SHIFT);\n-      for (int i=0; i<ARRLEN; i++) {\n-        errn += verify(\"test_srav_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-SHIFT)));\n-      }\n-\n-      test_pack2(p2, a1);\n-      for (int i=0; i<ARRLEN\/2; i++) {\n-        errn += verify(\"test_pack2: \", i, p2[i], ((long)(ADD_INIT+2*i) & 0xFFFFFFFFl) | ((long)(ADD_INIT+2*i+1) << 32));\n-      }\n-      for (int i=0; i<ARRLEN; i++) {\n-        a0[i] = -1;\n-      }\n-      test_unpack2(a0, p2);\n-      for (int i=0; i<(ARRLEN&(-2)); i++) {\n-        errn += verify(\"test_unpack2: \", i, a0[i], (ADD_INIT+i));\n-      }\n-\n-      test_pack2_swap(p2, a1);\n-      for (int i=0; i<ARRLEN\/2; i++) {\n-        errn += verify(\"test_pack2_swap: \", i, p2[i], ((long)(ADD_INIT+2*i+1) & 0xFFFFFFFFl) | ((long)(ADD_INIT+2*i) << 32));\n-      }\n-      for (int i=0; i<ARRLEN; i++) {\n-        a0[i] = -1;\n-      }\n-      test_unpack2_swap(a0, p2);\n-      for (int i=0; i<(ARRLEN&(-2)); i++) {\n-        errn += verify(\"test_unpack2_swap: \", i, a0[i], (ADD_INIT+i));\n-      }\n-\n-    }\n-\n-    return errn;\n-  }\n-\n-  static int test_sum(int[] a1) {\n-    int sum = 0;\n-    for (int i = 0; i < a1.length; i+=1) {\n-      sum += a1[i];\n-    }\n-    return sum;\n-  }\n-\n-  static void test_addc(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]+VALUE);\n-    }\n-  }\n-  static void test_addv(int[] a0, int[] a1, int b) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]+b);\n-    }\n-  }\n-  static void test_adda(int[] a0, int[] a1, int[] a2) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]+a2[i]);\n-    }\n-  }\n-\n-  static void test_subc(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]-VALUE);\n-    }\n-  }\n-  static void test_subv(int[] a0, int[] a1, int b) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]-b);\n-    }\n-  }\n-  static void test_suba(int[] a0, int[] a1, int[] a2) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]-a2[i]);\n-    }\n-  }\n-\n-  static void test_mulc(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]*VALUE);\n-    }\n-  }\n-  static void test_mulc_n(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]*(-VALUE));\n-    }\n-  }\n-  static void test_mulv(int[] a0, int[] a1, int b) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]*b);\n-    }\n-  }\n-  static void test_mula(int[] a0, int[] a1, int[] a2) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]*a2[i]);\n-    }\n-  }\n-\n-  static void test_divc(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]\/VALUE);\n-    }\n-  }\n-  static void test_divc_n(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]\/(-VALUE));\n-    }\n-  }\n-  static void test_divv(int[] a0, int[] a1, int b) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]\/b);\n-    }\n-  }\n-  static void test_diva(int[] a0, int[] a1, int[] a2) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]\/a2[i]);\n-    }\n-  }\n-\n-  static void test_andc(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]&BIT_MASK);\n-    }\n-  }\n-  static void test_andv(int[] a0, int[] a1, int b) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]&b);\n-    }\n-  }\n-  static void test_anda(int[] a0, int[] a1, int[] a2) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]&a2[i]);\n+\n+    private static final int ARRLEN = 997;\n+    private static final int ITERS  = 11000;\n+    private static final int ADD_INIT = Integer.MAX_VALUE-500;\n+    private static final int BIT_MASK = 0xEC80F731;\n+    private static final int VALUE = 15;\n+    private static final int SHIFT = 32;\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\n+           \"test_sum\", \"test_addc\", \"test_addv\", \"test_adda\", \"test_subc\",\n+           \"test_subv\", \"test_suba\", \"test_mulc\", \"test_mulc_n\", \"test_mulv\",\n+           \"test_mula\", \"test_divc\", \"test_divc_n\", \"test_divv\", \"test_diva\",\n+           \"test_andc\", \"test_andv\", \"test_anda\", \"test_orc\", \"test_orv\",\n+           \"test_ora\", \"test_xorc\", \"test_xorv\", \"test_xora\", \"test_sllc\",\n+           \"test_sllc_n\", \"test_sllc_o\", \"test_sllc_on\", \"test_sllv\",\n+           \"test_srlc\", \"test_srlc_n\", \"test_srlc_o\", \"test_srlc_on\",\n+           \"test_srlv\", \"test_srac\", \"test_srac_n\", \"test_srac_o\",\n+           \"test_srac_on\", \"test_srav\", \"test_pack2\", \"test_unpack2\",\n+           \"test_pack2_swap\", \"test_unpack2_swap\"\n+         },\n+         mode = RunMode.STANDALONE)\n+    public void run() {\n+        System.out.println(\"Testing Integer vectors\");\n+\n+        \/\/ Initialize\n+        int[] a0 = new int[ARRLEN];\n+        int[] a1 = new int[ARRLEN];\n+        int[] a2 = new int[ARRLEN];\n+        int[] a3 = new int[ARRLEN];\n+        int[] a4 = new int[ARRLEN];\n+        long[] p2 = new long[ARRLEN\/2];\n+        int gold_sum = 0;\n+        for (int i=0; i<ARRLEN; i++) {\n+            int val = (int)(ADD_INIT+i);\n+            gold_sum += val;\n+            a1[i] = val;\n+            a2[i] = (int)VALUE;\n+            a3[i] = (int)-VALUE;\n+            a4[i] = (int)BIT_MASK;\n+        }\n+\n+        System.out.println(\"Warmup\");\n+        for (int i=0; i<ITERS; i++) {\n+            test_sum(a1);\n+            test_addc(a0, a1);\n+            test_addv(a0, a1, (int)VALUE);\n+            test_adda(a0, a1, a2);\n+            test_subc(a0, a1);\n+            test_subv(a0, a1, (int)VALUE);\n+            test_suba(a0, a1, a2);\n+            test_mulc(a0, a1);\n+            test_mulv(a0, a1, (int)VALUE);\n+            test_mula(a0, a1, a2);\n+            test_divc(a0, a1);\n+            test_divv(a0, a1, (int)VALUE);\n+            test_diva(a0, a1, a2);\n+            test_mulc_n(a0, a1);\n+            test_mulv(a0, a1, (int)-VALUE);\n+            test_mula(a0, a1, a3);\n+            test_divc_n(a0, a1);\n+            test_divv(a0, a1, (int)-VALUE);\n+            test_diva(a0, a1, a3);\n+            test_andc(a0, a1);\n+            test_andv(a0, a1, (int)BIT_MASK);\n+            test_anda(a0, a1, a4);\n+            test_orc(a0, a1);\n+            test_orv(a0, a1, (int)BIT_MASK);\n+            test_ora(a0, a1, a4);\n+            test_xorc(a0, a1);\n+            test_xorv(a0, a1, (int)BIT_MASK);\n+            test_xora(a0, a1, a4);\n+            test_sllc(a0, a1);\n+            test_sllv(a0, a1, VALUE);\n+            test_srlc(a0, a1);\n+            test_srlv(a0, a1, VALUE);\n+            test_srac(a0, a1);\n+            test_srav(a0, a1, VALUE);\n+            test_sllc_n(a0, a1);\n+            test_sllv(a0, a1, -VALUE);\n+            test_srlc_n(a0, a1);\n+            test_srlv(a0, a1, -VALUE);\n+            test_srac_n(a0, a1);\n+            test_srav(a0, a1, -VALUE);\n+            test_sllc_o(a0, a1);\n+            test_sllv(a0, a1, SHIFT);\n+            test_srlc_o(a0, a1);\n+            test_srlv(a0, a1, SHIFT);\n+            test_srac_o(a0, a1);\n+            test_srav(a0, a1, SHIFT);\n+            test_sllc_on(a0, a1);\n+            test_sllv(a0, a1, -SHIFT);\n+            test_srlc_on(a0, a1);\n+            test_srlv(a0, a1, -SHIFT);\n+            test_srac_on(a0, a1);\n+            test_srav(a0, a1, -SHIFT);\n+            test_pack2(p2, a1);\n+            test_unpack2(a0, p2);\n+            test_pack2_swap(p2, a1);\n+            test_unpack2_swap(a0, p2);\n+        }\n+\n+        \/\/ Test and verify results\n+        System.out.println(\"Verification\");\n+        int errn = 0;\n+        {\n+            int sum = test_sum(a1);\n+            if (sum != gold_sum) {\n+                System.err.println(\"test_sum:  \" + sum + \" != \" + gold_sum);\n+                errn++;\n+            }\n+\n+            test_addc(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_addc: \", i, a0[i], (int)((int)(ADD_INIT+i)+VALUE));\n+            }\n+            test_addv(a0, a1, (int)VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_addv: \", i, a0[i], (int)((int)(ADD_INIT+i)+VALUE));\n+            }\n+            test_adda(a0, a1, a2);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_adda: \", i, a0[i], (int)((int)(ADD_INIT+i)+VALUE));\n+            }\n+\n+            test_subc(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_subc: \", i, a0[i], (int)((int)(ADD_INIT+i)-VALUE));\n+            }\n+            test_subv(a0, a1, (int)VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_subv: \", i, a0[i], (int)((int)(ADD_INIT+i)-VALUE));\n+            }\n+            test_suba(a0, a1, a2);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_suba: \", i, a0[i], (int)((int)(ADD_INIT+i)-VALUE));\n+            }\n+\n+            test_mulc(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_mulc: \", i, a0[i], (int)((int)(ADD_INIT+i)*VALUE));\n+            }\n+            test_mulv(a0, a1, (int)VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_mulv: \", i, a0[i], (int)((int)(ADD_INIT+i)*VALUE));\n+            }\n+            test_mula(a0, a1, a2);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_mula: \", i, a0[i], (int)((int)(ADD_INIT+i)*VALUE));\n+            }\n+\n+            test_divc(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_divc: \", i, a0[i], (int)((int)(ADD_INIT+i)\/VALUE));\n+            }\n+            test_divv(a0, a1, (int)VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_divv: \", i, a0[i], (int)((int)(ADD_INIT+i)\/VALUE));\n+            }\n+            test_diva(a0, a1, a2);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_diva: \", i, a0[i], (int)((int)(ADD_INIT+i)\/VALUE));\n+            }\n+\n+            test_mulc_n(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_mulc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)*(-VALUE)));\n+            }\n+            test_mulv(a0, a1, (int)-VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_mulv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)*(-VALUE)));\n+            }\n+            test_mula(a0, a1, a3);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_mula_n: \", i, a0[i], (int)((int)(ADD_INIT+i)*(-VALUE)));\n+            }\n+\n+            test_divc_n(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_divc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)\/(-VALUE)));\n+            }\n+            test_divv(a0, a1, (int)-VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_divv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)\/(-VALUE)));\n+            }\n+            test_diva(a0, a1, a3);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_diva_n: \", i, a0[i], (int)((int)(ADD_INIT+i)\/(-VALUE)));\n+            }\n+\n+            test_andc(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_andc: \", i, a0[i], (int)((int)(ADD_INIT+i)&BIT_MASK));\n+            }\n+            test_andv(a0, a1, (int)BIT_MASK);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_andv: \", i, a0[i], (int)((int)(ADD_INIT+i)&BIT_MASK));\n+            }\n+            test_anda(a0, a1, a4);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_anda: \", i, a0[i], (int)((int)(ADD_INIT+i)&BIT_MASK));\n+            }\n+\n+            test_orc(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_orc: \", i, a0[i], (int)((int)(ADD_INIT+i)|BIT_MASK));\n+            }\n+            test_orv(a0, a1, (int)BIT_MASK);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_orv: \", i, a0[i], (int)((int)(ADD_INIT+i)|BIT_MASK));\n+            }\n+            test_ora(a0, a1, a4);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_ora: \", i, a0[i], (int)((int)(ADD_INIT+i)|BIT_MASK));\n+            }\n+\n+            test_xorc(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_xorc: \", i, a0[i], (int)((int)(ADD_INIT+i)^BIT_MASK));\n+            }\n+            test_xorv(a0, a1, (int)BIT_MASK);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_xorv: \", i, a0[i], (int)((int)(ADD_INIT+i)^BIT_MASK));\n+            }\n+            test_xora(a0, a1, a4);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_xora: \", i, a0[i], (int)((int)(ADD_INIT+i)^BIT_MASK));\n+            }\n+\n+            test_sllc(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_sllc: \", i, a0[i], (int)((int)(ADD_INIT+i)<<VALUE));\n+            }\n+            test_sllv(a0, a1, VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_sllv: \", i, a0[i], (int)((int)(ADD_INIT+i)<<VALUE));\n+            }\n+\n+            test_srlc(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srlc: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>VALUE));\n+            }\n+            test_srlv(a0, a1, VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srlv: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>VALUE));\n+            }\n+\n+            test_srac(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srac: \", i, a0[i], (int)((int)(ADD_INIT+i)>>VALUE));\n+            }\n+            test_srav(a0, a1, VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srav: \", i, a0[i], (int)((int)(ADD_INIT+i)>>VALUE));\n+            }\n+\n+            test_sllc_n(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_sllc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-VALUE)));\n+            }\n+            test_sllv(a0, a1, -VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_sllv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-VALUE)));\n+            }\n+\n+            test_srlc_n(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srlc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-VALUE)));\n+            }\n+            test_srlv(a0, a1, -VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srlv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-VALUE)));\n+            }\n+\n+            test_srac_n(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srac_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-VALUE)));\n+            }\n+            test_srav(a0, a1, -VALUE);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srav_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-VALUE)));\n+            }\n+\n+            test_sllc_o(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_sllc_o: \", i, a0[i], (int)((int)(ADD_INIT+i)<<SHIFT));\n+            }\n+            test_sllv(a0, a1, SHIFT);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_sllv_o: \", i, a0[i], (int)((int)(ADD_INIT+i)<<SHIFT));\n+            }\n+\n+            test_srlc_o(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srlc_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>SHIFT));\n+            }\n+            test_srlv(a0, a1, SHIFT);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srlv_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>SHIFT));\n+            }\n+\n+            test_srac_o(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srac_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>SHIFT));\n+            }\n+            test_srav(a0, a1, SHIFT);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srav_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>SHIFT));\n+            }\n+\n+            test_sllc_on(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_sllc_on: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-SHIFT)));\n+            }\n+            test_sllv(a0, a1, -SHIFT);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_sllv_on: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-SHIFT)));\n+            }\n+\n+            test_srlc_on(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srlc_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-SHIFT)));\n+            }\n+            test_srlv(a0, a1, -SHIFT);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srlv_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-SHIFT)));\n+            }\n+\n+            test_srac_on(a0, a1);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srac_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-SHIFT)));\n+            }\n+            test_srav(a0, a1, -SHIFT);\n+            for (int i=0; i<ARRLEN; i++) {\n+                errn += verify(\"test_srav_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-SHIFT)));\n+            }\n+\n+            test_pack2(p2, a1);\n+            for (int i=0; i<ARRLEN\/2; i++) {\n+                errn += verify(\"test_pack2: \", i, p2[i], ((long)(ADD_INIT+2*i) & 0xFFFFFFFFl) | ((long)(ADD_INIT+2*i+1) << 32));\n+            }\n+            for (int i=0; i<ARRLEN; i++) {\n+                a0[i] = -1;\n+            }\n+            test_unpack2(a0, p2);\n+            for (int i=0; i<(ARRLEN&(-2)); i++) {\n+                errn += verify(\"test_unpack2: \", i, a0[i], (ADD_INIT+i));\n+            }\n+\n+            test_pack2_swap(p2, a1);\n+            for (int i=0; i<ARRLEN\/2; i++) {\n+                errn += verify(\"test_pack2_swap: \", i, p2[i], ((long)(ADD_INIT+2*i+1) & 0xFFFFFFFFl) | ((long)(ADD_INIT+2*i) << 32));\n+            }\n+            for (int i=0; i<ARRLEN; i++) {\n+                a0[i] = -1;\n+            }\n+            test_unpack2_swap(a0, p2);\n+            for (int i=0; i<(ARRLEN&(-2)); i++) {\n+                errn += verify(\"test_unpack2_swap: \", i, a0[i], (ADD_INIT+i));\n+            }\n+\n+        }\n+\n+        if (errn > 0) {\n+            throw new Error(\"FAILED: \" + errn + \" errors\");\n+        }\n+        System.out.println(\"PASSED\");\n+\n+    }\n+\n+    \/\/ Not vectorized: simple addition not profitable, see JDK-8307516. NOTE:\n+    \/\/ This check does not document the _desired_ behavior of the system but\n+    \/\/ the current behavior (no vectorization)\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n+                   IRNode.STORE_VECTOR,  \"= 0\" })\n+    int test_sum(int[] a1) {\n+        int sum = 0;\n+        for (int i = 0; i < a1.length; i+=1) {\n+            sum += a1[i];\n+        }\n+        return sum;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_addc(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]+VALUE);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_addv(int[] a0, int[] a1, int b) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]+b);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_adda(int[] a0, int[] a1, int[] a2) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]+a2[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_subc(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]-VALUE);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.SUB_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_subv(int[] a0, int[] a1, int b) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]-b);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.SUB_VI, \"> 0\", },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_suba(int[] a0, int[] a1, int[] a2) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]-a2[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.SUB_VI, \"> 0\", IRNode.LSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_mulc(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]*VALUE);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.SUB_VI, \"> 0\", IRNode.LSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_mulc_n(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]*(-VALUE));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MUL_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    void test_mulv(int[] a0, int[] a1, int b) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]*b);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MUL_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    void test_mula(int[] a0, int[] a1, int[] a2) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]*a2[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_VI,\n+                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                   IRNode.RSHIFT_VI,\n+                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                   IRNode.SUB_VI,\n+                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\" },\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    \/\/ Not vectorized: On aarch64, vectorization for this example results in\n+    \/\/ MulVL nodes, which asimd does not support.\n+    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n+                   IRNode.STORE_VECTOR,  \"= 0\",\n+                   IRNode.MUL_L,         \"> 0\" },\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n+    void test_divc(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]\/VALUE);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_VI,\n+                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                   IRNode.RSHIFT_VI,\n+                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                   IRNode.SUB_VI,\n+                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\" },\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    \/\/ Not vectorized: On aarch64, vectorization for this example results in\n+    \/\/ MulVL nodes, which asimd does not support.\n+    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n+                   IRNode.STORE_VECTOR,  \"= 0\",\n+                   IRNode.MUL_L,         \"> 0\" },\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n+    void test_divc_n(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]\/(-VALUE));\n+        }\n+    }\n+\n+    \/\/ Not vectorized: no vector div. NOTE: This check does not document the\n+    \/\/ _desired_ behavior of the system but the current behavior (no\n+    \/\/ vectorization)\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n+                   IRNode.STORE_VECTOR,  \"= 0\" })\n+    void test_divv(int[] a0, int[] a1, int b) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]\/b);\n+        }\n+    }\n+\n+    \/\/ Not vectorized: no vector div. NOTE: This check does not document the\n+    \/\/ _desired_ behavior of the system but the current behavior (no\n+    \/\/ vectorization)\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n+                   IRNode.STORE_VECTOR,  \"= 0\" })\n+    void test_diva(int[] a0, int[] a1, int[] a2) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]\/a2[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_andc(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]&BIT_MASK);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_andv(int[] a0, int[] a1, int b) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]&b);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_anda(int[] a0, int[] a1, int[] a2) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]&a2[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.OR_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_orc(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]|BIT_MASK);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.OR_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_orv(int[] a0, int[] a1, int b) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]|b);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.OR_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_ora(int[] a0, int[] a1, int[] a2) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]|a2[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_xorc(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]^BIT_MASK);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_xorv(int[] a0, int[] a1, int b) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]^b);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_xora(int[] a0, int[] a1, int[] a2) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]^a2[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_sllc(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]<<VALUE);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_sllc_n(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]<<(-VALUE));\n+        }\n+    }\n+\n+    \/\/ Vector shift not expected as shift is a NOP.\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_VI,     \"= 0\",\n+                   IRNode.LOAD_VECTOR_I, \"> 0\",\n+                   IRNode.STORE_VECTOR,  \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_sllc_o(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]<<SHIFT);\n+        }\n+    }\n+\n+    \/\/ Vector shift not expected as shift is a NOP.\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_VI,     \"= 0\",\n+                   IRNode.LOAD_VECTOR_I, \"> 0\",\n+                   IRNode.STORE_VECTOR,  \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_sllc_on(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]<<(-SHIFT));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_sllv(int[] a0, int[] a1, int b) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]<<b);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.URSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_srlc(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]>>>VALUE);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.URSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_srlc_n(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]>>>(-VALUE));\n+        }\n+    }\n+\n+    \/\/ Vector shift not expected as shift is a NOP.\n+    @Test\n+    @IR(counts = { IRNode.URSHIFT_VI,    \"= 0\",\n+                   IRNode.LOAD_VECTOR_I, \"> 0\",\n+                   IRNode.STORE_VECTOR,  \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_srlc_o(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]>>>SHIFT);\n+        }\n+    }\n+\n+    \/\/ Vector shift not expected as shift is a NOP.\n+    @Test\n+    @IR(counts = { IRNode.URSHIFT_VI,    \"= 0\",\n+                   IRNode.LOAD_VECTOR_I, \"> 0\",\n+                   IRNode.STORE_VECTOR,  \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_srlc_on(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]>>>(-SHIFT));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.URSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_srlv(int[] a0, int[] a1, int b) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]>>>b);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_srac(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]>>VALUE);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_srac_n(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]>>(-VALUE));\n+        }\n+    }\n+\n+    \/\/ Vector shift not expected as shift is a NOP.\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_VI,     \"= 0\",\n+                   IRNode.LOAD_VECTOR_I, \"> 0\",\n+                   IRNode.STORE_VECTOR,  \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_srac_o(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]>>SHIFT);\n+        }\n+    }\n+\n+    \/\/ Vector shift not expected as shift is a NOP.\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_VI,     \"= 0\",\n+                   IRNode.LOAD_VECTOR_I, \"> 0\",\n+                   IRNode.STORE_VECTOR,  \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_srac_on(int[] a0, int[] a1) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]>>(-SHIFT));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT_VI, \"> 0\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    void test_srav(int[] a0, int[] a1, int b) {\n+        for (int i = 0; i < a0.length; i+=1) {\n+            a0[i] = (int)(a1[i]>>b);\n+        }\n+    }\n+\n+    \/\/ Not vectorized currently. NOTE: This check does not document the\n+    \/\/ _desired_ behavior of the system but the current behavior (no\n+    \/\/ vectorization)\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n+                   IRNode.STORE_VECTOR,  \"= 0\" })\n+    void test_pack2(long[] p2, int[] a1) {\n+        if (p2.length*2 > a1.length) return;\n+        for (int i = 0; i < p2.length; i+=1) {\n+            long l0 = (long)a1[i*2+0];\n+            long l1 = (long)a1[i*2+1];\n+            p2[i] = (l1 << 32) | (l0 & 0xFFFFFFFFl);\n+        }\n+    }\n+\n+    \/\/ Not vectorized currently. NOTE: This check does not document the\n+    \/\/ _desired_ behavior of the system but the current behavior (no\n+    \/\/ vectorization)\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n+                   IRNode.STORE_VECTOR,  \"= 0\" })\n+    void test_unpack2(int[] a0, long[] p2) {\n+        if (p2.length*2 > a0.length) return;\n+        for (int i = 0; i < p2.length; i+=1) {\n+            long l = p2[i];\n+            a0[i*2+0] = (int)(l & 0xFFFFFFFFl);\n+            a0[i*2+1] = (int)(l >> 32);\n+        }\n+    }\n+\n+    \/\/ Not vectorized currently. NOTE: This check does not document the\n+    \/\/ _desired_ behavior of the system but the current behavior (no\n+    \/\/ vectorization)\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n+                   IRNode.STORE_VECTOR,  \"= 0\" })\n+    void test_pack2_swap(long[] p2, int[] a1) {\n+        if (p2.length*2 > a1.length) return;\n+        for (int i = 0; i < p2.length; i+=1) {\n+            long l0 = (long)a1[i*2+0];\n+            long l1 = (long)a1[i*2+1];\n+            p2[i] = (l0 << 32) | (l1 & 0xFFFFFFFFl);\n+        }\n+    }\n+\n+    \/\/ Not vectorized currently. NOTE: This check does not document the\n+    \/\/ _desired_ behavior of the system but the current behavior (no\n+    \/\/ vectorization)\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n+                   IRNode.STORE_VECTOR,  \"= 0\" })\n+    void test_unpack2_swap(int[] a0, long[] p2) {\n+        if (p2.length*2 > a0.length) return;\n+        for (int i = 0; i < p2.length; i+=1) {\n+            long l = p2[i];\n+            a0[i*2+0] = (int)(l >> 32);\n+            a0[i*2+1] = (int)(l & 0xFFFFFFFFl);\n+        }\n+    }\n+\n+    static int verify(String text, int i, int elem, int val) {\n+        if (elem != val) {\n+            System.err.println(text + \"[\" + i + \"] = \" + elem + \" != \" + val);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    static int verify(String text, int i, long elem, long val) {\n+        if (elem != val) {\n+            System.err.println(text + \"[\" + i + \"] = \" + Long.toHexString(elem) + \" != \" + Long.toHexString(val));\n+            return 1;\n+        }\n+        return 0;\n@@ -482,160 +891,0 @@\n-  }\n-\n-  static void test_orc(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]|BIT_MASK);\n-    }\n-  }\n-  static void test_orv(int[] a0, int[] a1, int b) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]|b);\n-    }\n-  }\n-  static void test_ora(int[] a0, int[] a1, int[] a2) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]|a2[i]);\n-    }\n-  }\n-\n-  static void test_xorc(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]^BIT_MASK);\n-    }\n-  }\n-  static void test_xorv(int[] a0, int[] a1, int b) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]^b);\n-    }\n-  }\n-  static void test_xora(int[] a0, int[] a1, int[] a2) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]^a2[i]);\n-    }\n-  }\n-\n-  static void test_sllc(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]<<VALUE);\n-    }\n-  }\n-  static void test_sllc_n(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]<<(-VALUE));\n-    }\n-  }\n-  static void test_sllc_o(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]<<SHIFT);\n-    }\n-  }\n-  static void test_sllc_on(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]<<(-SHIFT));\n-    }\n-  }\n-  static void test_sllv(int[] a0, int[] a1, int b) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]<<b);\n-    }\n-  }\n-\n-  static void test_srlc(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]>>>VALUE);\n-    }\n-  }\n-  static void test_srlc_n(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]>>>(-VALUE));\n-    }\n-  }\n-  static void test_srlc_o(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]>>>SHIFT);\n-    }\n-  }\n-  static void test_srlc_on(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]>>>(-SHIFT));\n-    }\n-  }\n-  static void test_srlv(int[] a0, int[] a1, int b) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]>>>b);\n-    }\n-  }\n-\n-  static void test_srac(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]>>VALUE);\n-    }\n-  }\n-  static void test_srac_n(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]>>(-VALUE));\n-    }\n-  }\n-  static void test_srac_o(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]>>SHIFT);\n-    }\n-  }\n-  static void test_srac_on(int[] a0, int[] a1) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]>>(-SHIFT));\n-    }\n-  }\n-  static void test_srav(int[] a0, int[] a1, int b) {\n-    for (int i = 0; i < a0.length; i+=1) {\n-      a0[i] = (int)(a1[i]>>b);\n-    }\n-  }\n-\n-  static void test_pack2(long[] p2, int[] a1) {\n-    if (p2.length*2 > a1.length) return;\n-    for (int i = 0; i < p2.length; i+=1) {\n-      long l0 = (long)a1[i*2+0];\n-      long l1 = (long)a1[i*2+1];\n-      p2[i] = (l1 << 32) | (l0 & 0xFFFFFFFFl);\n-    }\n-  }\n-  static void test_unpack2(int[] a0, long[] p2) {\n-    if (p2.length*2 > a0.length) return;\n-    for (int i = 0; i < p2.length; i+=1) {\n-      long l = p2[i];\n-      a0[i*2+0] = (int)(l & 0xFFFFFFFFl);\n-      a0[i*2+1] = (int)(l >> 32);\n-    }\n-  }\n-  static void test_pack2_swap(long[] p2, int[] a1) {\n-    if (p2.length*2 > a1.length) return;\n-    for (int i = 0; i < p2.length; i+=1) {\n-      long l0 = (long)a1[i*2+0];\n-      long l1 = (long)a1[i*2+1];\n-      p2[i] = (l0 << 32) | (l1 & 0xFFFFFFFFl);\n-    }\n-  }\n-  static void test_unpack2_swap(int[] a0, long[] p2) {\n-    if (p2.length*2 > a0.length) return;\n-    for (int i = 0; i < p2.length; i+=1) {\n-      long l = p2[i];\n-      a0[i*2+0] = (int)(l >> 32);\n-      a0[i*2+1] = (int)(l & 0xFFFFFFFFl);\n-    }\n-  }\n-\n-  static int verify(String text, int i, int elem, int val) {\n-    if (elem != val) {\n-      System.err.println(text + \"[\" + i + \"] = \" + elem + \" != \" + val);\n-      return 1;\n-    }\n-    return 0;\n-  }\n-\n-  static int verify(String text, int i, long elem, long val) {\n-    if (elem != val) {\n-      System.err.println(text + \"[\" + i + \"] = \" + Long.toHexString(elem) + \" != \" + Long.toHexString(val));\n-      return 1;\n-    }\n-    return 0;\n-  }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr7200264\/TestIntVect.java","additions":863,"deletions":614,"binary":false,"changes":1477,"status":"modified"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 7200264\n- * @summary 7192963 changes disabled shift vectors\n- * @requires vm.cpu.features ~= \".*sse2.*\" & vm.debug & vm.flavor == \"server\"\n- * @requires !vm.emulatedClient & !vm.graal.enabled\n- * @library \/test\/lib \/\n- * @run driver compiler.c2.cr7200264.TestSSE2IntVect\n- *\/\n-\n-package compiler.c2.cr7200264;\n-\n-public class TestSSE2IntVect {\n-    public static void main(String[] args) throws Throwable {\n-        TestDriver test = new TestDriver();\n-        test.addExpectedVectorization(\"AddVI\", 4);\n-        test.addExpectedVectorization(\"SubVI\", 4);\n-        test.addExpectedVectorization(\"AndV\", 3);\n-        test.addExpectedVectorization(\"OrV\", 3);\n-        test.addExpectedVectorization(\"XorV\", 3);\n-        test.addExpectedVectorization(\"LShiftVI\", 5);\n-        test.addExpectedVectorization(\"RShiftVI\", 3);\n-        test.addExpectedVectorization(\"URShiftVI\", 3);\n-        test.run();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr7200264\/TestSSE2IntVect.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 7200264\n- * @summary 7192963 changes disabled shift vectors\n- * @requires vm.cpu.features ~= \".*sse4\\\\.1.*\" & vm.debug & vm.flavor == \"server\"\n- * @requires !vm.emulatedClient & !vm.graal.enabled\n- * @library \/test\/lib \/\n- * @run driver compiler.c2.cr7200264.TestSSE4IntVect\n- *\/\n-\n-package compiler.c2.cr7200264;\n-\n-public class TestSSE4IntVect {\n-    public static void main(String[] args) throws Throwable {\n-        TestDriver test = new TestDriver();\n-        test.addExpectedVectorization(\"MulVI\", 2);\n-        test.run();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr7200264\/TestSSE4IntVect.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\/**\n+ * This enum represents all available compile phases on which an IR matching can be done. There is a 1:1 mapping\n+ * between IGV phases as specified in phasetype.hpp.  Compile phases which are normally not emitted by C2 like FAILURE\n+ * or DEBUG are not listed. This enum should be kept in sync with phasetye.hpp.\n+ *\n+ * <p>\n+ * There are two additional compile phases PRINT_IDEAL and PRINT_OPTO_ASSEMBLY. PRINT_IDEAL is the output that is printed\n+ * when using -XX:+PrintIdeal and PRINT_OPTO_ASSEMBLY when using -XX:+PrintOptoAssembly. For simplicity, these two flags\n+ * are treated as a separated compile phase as well.\n+ *\/\n+public enum CompilePhase {\n+    DEFAULT(\"For IR node placeholder strings as defined in class IRNode only\"),\n+\n+    BEFORE_STRINGOPTS(\"Before StringOpts\"),\n+    AFTER_STRINGOPTS(\"After StringOpts\"),\n+    BEFORE_REMOVEUSELESS(\"Before RemoveUseless\"),\n+    AFTER_PARSING(\"After Parsing\"),\n+    ITER_GVN1(\"Iter GVN 1\"),\n+    INCREMENTAL_INLINE_STEP(\"Incremental Inline Step\"),\n+    INCREMENTAL_INLINE_CLEANUP(\"Incremental Inline Cleanup\"),\n+    INCREMENTAL_INLINE(\"Incremental Inline\"),\n+    INCREMENTAL_BOXING_INLINE(\"Incremental Boxing Inline\"),\n+    EXPAND_VUNBOX(\"Expand VectorUnbox\"),\n+    SCALARIZE_VBOX(\"Scalarize VectorBox\"),\n+    INLINE_VECTOR_REBOX(\"Inline Vector Rebox Calls\"),\n+    EXPAND_VBOX(\"Expand VectorBox\"),\n+    ELIMINATE_VBOX_ALLOC(\"Eliminate VectorBoxAllocate\"),\n+    ITER_GVN_BEFORE_EA(\"Iter GVN before EA\"),\n+    ITER_GVN_AFTER_VECTOR(\"Iter GVN after vector box elimination\"),\n+    BEFORE_BEAUTIFY_LOOPS(\"Before beautify loops\"),\n+    AFTER_BEAUTIFY_LOOPS(\"After beautify loops\"),\n+    \/\/ Match on very first BEFORE_CLOOPS phase (there could be multiple phases for multiple loops in the code).\n+    BEFORE_CLOOPS(\"Before CountedLoop\", RegexType.IDEAL_INDEPENDENT, ActionOnRepeat.KEEP_FIRST),\n+    AFTER_CLOOPS(\"After CountedLoop\"),\n+    PHASEIDEAL_BEFORE_EA(\"PhaseIdealLoop before EA\"),\n+    AFTER_EA(\"After Escape Analysis\"),\n+    ITER_GVN_AFTER_EA(\"Iter GVN after EA\"),\n+    ITER_GVN_AFTER_ELIMINATION(\"Iter GVN after eliminating allocations and locks\"),\n+    PHASEIDEALLOOP1(\"PhaseIdealLoop 1\"),\n+    PHASEIDEALLOOP2(\"PhaseIdealLoop 2\"),\n+    PHASEIDEALLOOP3(\"PhaseIdealLoop 3\"),\n+    CCP1(\"PhaseCCP 1\"),\n+    ITER_GVN2(\"Iter GVN 2\"),\n+    PHASEIDEALLOOP_ITERATIONS(\"PhaseIdealLoop iterations\"),\n+    MACRO_EXPANSION(\"Macro expand\"),\n+    BARRIER_EXPANSION(\"Barrier expand\"),\n+    OPTIMIZE_FINISHED(\"Optimize finished\"),\n+    PRINT_IDEAL(\"PrintIdeal\"),\n+    BEFORE_MATCHING(\"Before matching\"),\n+    MATCHING(\"After matching\", RegexType.MACH),\n+    MACH_ANALYSIS(\"After mach analysis\", RegexType.MACH),\n+    GLOBAL_CODE_MOTION(\"Global code motion\", RegexType.MACH),\n+    FINAL_CODE(\"Final Code\", RegexType.MACH),\n+    END(\"End\"),\n+\n+    PRINT_OPTO_ASSEMBLY(\"PrintOptoAssembly\", RegexType.OPTO_ASSEMBLY),\n+    ;\n+\n+    private static final Map<String, CompilePhase> PHASES_BY_PARSED_NAME = new HashMap<>();\n+\n+    static {\n+        for (CompilePhase phase : CompilePhase.values()) {\n+            if (phase == PRINT_IDEAL) {\n+                PHASES_BY_PARSED_NAME.put(\"print_ideal\", phase);\n+            } else {\n+                PHASES_BY_PARSED_NAME.put(phase.name(), phase);\n+            }\n+        }\n+    }\n+    private enum ActionOnRepeat {\n+        KEEP_FIRST, KEEP_LAST\n+    }\n+\n+    private final String name;\n+    private final RegexType regexType;\n+    private final ActionOnRepeat actionOnRepeat;\n+\n+    CompilePhase(String name) {\n+        this.name = name;\n+        this.regexType = RegexType.IDEAL_INDEPENDENT;\n+        this.actionOnRepeat = ActionOnRepeat.KEEP_LAST;\n+    }\n+\n+    CompilePhase(String name, RegexType regexType) {\n+        this.name = name;\n+        this.regexType = regexType;\n+        this.actionOnRepeat = ActionOnRepeat.KEEP_LAST;\n+    }\n+\n+    CompilePhase(String name, RegexType regexType, ActionOnRepeat actionOnRepeat) {\n+        this.name = name;\n+        this.regexType = regexType;\n+        this.actionOnRepeat = actionOnRepeat;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public RegexType regexType() {\n+        return regexType;\n+    }\n+\n+    public static CompilePhase forName(String phaseName) {\n+        CompilePhase phase = PHASES_BY_PARSED_NAME.get(phaseName);\n+        TestFramework.check(phase != null, \"Could not find phase with name \\\"\" + phaseName + \"\\\"\");\n+        return phase;\n+    }\n+\n+    public boolean overrideRepeatedPhase() {\n+        return actionOnRepeat == ActionOnRepeat.KEEP_LAST;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/CompilePhase.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -144,0 +144,14 @@\n+\n+     \/**\n+     * Accepts a list of feature pairs where each pair is composed of target feature string followed by a true\/false\n+     * value where a true value necessities existence of target feature and vice-versa.\n+     * IR verifications checks are enforced if any of the specified feature constraint is met.\n+     *\/\n+    String[] applyIfCPUFeatureOr() default {};\n+\n+    \/**\n+     * Accepts a list of feature pairs where each pair is composed of target feature string followed by a true\/false\n+     * value where a true value necessities existence of target feature and vice-versa.\n+     * IR verifications checks are enforced only if all the specified feature constraints are met.\n+     *\/\n+    String[] applyIfCPUFeatureAnd() default {};\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IR.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import compiler.lib.ir_framework.driver.irmatching.IRMatcher;\n+import compiler.lib.ir_framework.driver.irmatching.mapping.*;\n@@ -33,0 +33,2 @@\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -148,0 +150,22 @@\n+    private static final String PREFIX = \"_#\";\n+    private static final String VECTOR_PREFIX = PREFIX + \"V#\";\n+    private static final String POSTFIX = \"#_\";\n+    public static final String VECTOR_SIZE = \"_@\";\n+    private static final String TYPE_BYTE   = \"byte\";\n+    private static final String TYPE_CHAR   = \"char\";\n+    private static final String TYPE_SHORT  = \"short\";\n+    private static final String TYPE_INT    = \"int\";\n+    private static final String TYPE_LONG   = \"long\";\n+    private static final String TYPE_FLOAT  = \"float\";\n+    private static final String TYPE_DOUBLE = \"double\";\n+\n+    \/**\n+     * IR placeholder string to regex-for-compile-phase map.\n+     *\/\n+    private static final Map<String, IRNodeMapEntry> IR_NODE_MAPPINGS = new HashMap<>();\n+\n+    \/**\n+     * Map every vectorNode to a type string.\n+     *\/\n+    private static final Map<String, String> VECTOR_NODE_TYPE = new HashMap<>();\n+\n@@ -223,0 +247,92 @@\n+\n+    public static final String LOAD_VECTOR_I = VECTOR_PREFIX + \"LOAD_VECTOR_I\" + POSTFIX;\n+    static {\n+        vectorNode(LOAD_VECTOR_I, \"LoadVector\", TYPE_INT);\n+    }\n+\n+    public static final String STORE_VECTOR = PREFIX + \"STORE_VECTOR\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_VECTOR, \"StoreVector\");\n+    }\n+\n+    public static final String ADD_VI = VECTOR_PREFIX + \"ADD_VI\" + POSTFIX;\n+    static {\n+        vectorNode(ADD_VI, \"AddVI\", TYPE_INT);\n+    }\n+\n+    public static final String SUB_VI = VECTOR_PREFIX + \"SUB_VI\" + POSTFIX;\n+    static {\n+        vectorNode(SUB_VI, \"SubVI\", TYPE_INT);\n+    }\n+\n+    public static final String LSHIFT_VI = VECTOR_PREFIX + \"LSHIFT_VI\" + POSTFIX;\n+    static {\n+        vectorNode(LSHIFT_VI, \"LShiftVI\", TYPE_INT);\n+    }\n+\n+    public static final String MUL_VI = VECTOR_PREFIX + \"MUL_VI\" + POSTFIX;\n+    static {\n+        vectorNode(MUL_VI, \"MulVI\", TYPE_INT);\n+    }\n+\n+    \/**\n+     * Is {@code irVectorSizeString} a vector size string?\n+     *\/\n+    public static boolean isVectorSize(String irVectorSizeString) {\n+        return irVectorSizeString.startsWith(VECTOR_SIZE);\n+    }\n+\n+    public static final String RSHIFT_VI = VECTOR_PREFIX + \"RSHIFT_VI\" + POSTFIX;\n+    static {\n+        vectorNode(RSHIFT_VI, \"RShiftVI\", TYPE_INT);\n+    }\n+\n+    public static final String AND_VI = VECTOR_PREFIX + \"AND_VI\" + POSTFIX;\n+    static {\n+        vectorNode(AND_VI, \"AndV\", TYPE_INT);\n+    }\n+\n+    public static final String OR_VI = VECTOR_PREFIX + \"OR_VI\" + POSTFIX;\n+    static {\n+        vectorNode(OR_VI, \"OrV\", TYPE_INT);\n+    }\n+\n+    public static final String XOR_VI = VECTOR_PREFIX + \"XOR_VI\" + POSTFIX;\n+    static {\n+        vectorNode(XOR_VI, \"XorV\", TYPE_INT);\n+    }\n+\n+    public static final String URSHIFT_VI = VECTOR_PREFIX + \"URSHIFT_VI\" + POSTFIX;\n+    static {\n+        vectorNode(URSHIFT_VI, \"URShiftVI\", TYPE_INT);\n+    }\n+\n+    \/**\n+     * Apply {@code irNodeRegex} as regex for the IR vector node name on all machine independent ideal graph phases up to and\n+     * including {@link CompilePhase#BEFORE_MATCHING}. Since this is a vector node, we can also check the vector element\n+     * type {@code typeString} and the vector size (number of elements), {@see VECTOR_SIZE}.\n+     *\/\n+    private static void vectorNode(String irNodePlaceholder, String irNodeRegex, String typeString) {\n+        TestFramework.check(isVectorIRNode(irNodePlaceholder), \"vectorNode: failed prefix check for irNodePlaceholder \"\n+                                                               + irNodePlaceholder + \" -> did you use VECTOR_PREFIX?\");\n+        \/\/ IS_REPLACED is later replaced with the specific type and size of the vector.\n+        String regex = START + irNodeRegex + MID  + IS_REPLACED + END;\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new RegexTypeEntry(RegexType.IDEAL_INDEPENDENT, regex));\n+        VECTOR_NODE_TYPE.put(irNodePlaceholder, typeString);\n+    }\n+\n+    \/**\n+     * Apply {@code irNodeRegex} as regex for the IR node name on all machine independent ideal graph phases up to and\n+     * including {@link CompilePhase#BEFORE_MATCHING}.\n+     *\/\n+    private static void beforeMatchingNameRegex(String irNodePlaceholder, String irNodeRegex) {\n+        String regex = START + irNodeRegex + MID + END;\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new RegexTypeEntry(RegexType.IDEAL_INDEPENDENT, regex));\n+    }\n+\n+    \/**\n+     * Is {@code irVectorNodeString} an IR vector node placeholder string?\n+     *\/\n+    public static boolean isVectorIRNode(String irVectorNodeString) {\n+        return irVectorNodeString.startsWith(VECTOR_PREFIX);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":117,"deletions":1,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+\/**\n+ * Enum to denote the regex type of the associated {@link CompilePhase}.\n+ *\n+ * @see CompilePhase\n+ *\/\n+public enum RegexType {\n+    IDEAL_INDEPENDENT, MACH, OPTO_ASSEMBLY\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/RegexType.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.mapping;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+\n+\/**\n+ * This interface represents an IR node mapping entry in {@code IR_NODE_MAPPINGS} in {@link IRNode}. Each entry must\n+ * return a regex for a {@link CompilePhase} or null if it does not support the compile phase. Additionally, a default\n+ * compile phase must be specified to fall back to when a user test specifies {@link CompilePhase#DEFAULT} in\n+ * {@link IR#phase} or does not provide the {@link IR#phase} attribute.\n+ *\n+ * @see IRNode\n+ * @see CompilePhase\n+ *\/\n+public interface IRNodeMapEntry {\n+    \/**\n+     * Return the regex string which shall be used by the IR framework when matching on {@code compilePhase}.\n+     *\/\n+    String regexForCompilePhase(CompilePhase compilePhase);\n+\n+    \/**\n+     * Return the default compile phase that shall be used for an {@link IRNode} placeholeder string when the user test\n+     * specifies {@link CompilePhase#DEFAULT}.\n+     *\/\n+    CompilePhase defaultCompilePhase();\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/mapping\/IRNodeMapEntry.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.mapping;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.RegexType;\n+\n+\/**\n+ * This class represents a mapping entry for an IR node that maps to a single regex for all compile phases whose\n+ * {@link CompilePhase#regexType()} match the specified {@link RegexType} for this entry.\n+ *\/\n+public class RegexTypeEntry implements IRNodeMapEntry {\n+    private final SingleRegexEntry singleRegexEntry;\n+    private final RegexType regexType;\n+\n+    public RegexTypeEntry(RegexType regexType, String regex) {\n+        this.regexType = regexType;\n+        CompilePhase defaultCompilePhase = switch (regexType) {\n+            case IDEAL_INDEPENDENT -> CompilePhase.PRINT_IDEAL;\n+            case MACH -> CompilePhase.FINAL_CODE;\n+            case OPTO_ASSEMBLY -> CompilePhase.PRINT_OPTO_ASSEMBLY;\n+        };\n+        this.singleRegexEntry = new SingleRegexEntry(defaultCompilePhase, regex);\n+    }\n+\n+    @Override\n+    public String regexForCompilePhase(CompilePhase compilePhase) {\n+        if (compilePhase.regexType() == regexType) {\n+            return singleRegexEntry.regex();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public CompilePhase defaultCompilePhase() {\n+        return singleRegexEntry.defaultCompilePhase();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/mapping\/RegexTypeEntry.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.mapping;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+\n+\/**\n+ * This class represents a mapping entry for an IR node that maps to a single regex for multiple compile phases.\n+ * If the IR node is only applicable to a single compile phase, a {@link SinglePhaseEntry} should be used.\n+ *\/\n+record SingleRegexEntry(CompilePhase defaultCompilePhase, String regex) {\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/mapping\/SingleRegexEntry.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"}]}