{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import compiler.lib.ir_framework.driver.irmatching.mapping.IRNodeMapEntry;\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr7200264\/TestIntVect.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\/**\n+ * This enum represents all available compile phases on which an IR matching can be done. There is a 1:1 mapping\n+ * between IGV phases as specified in phasetype.hpp.  Compile phases which are normally not emitted by C2 like FAILURE\n+ * or DEBUG are not listed. This enum should be kept in sync with phasetye.hpp.\n+ *\n+ * <p>\n+ * There are two additional compile phases PRINT_IDEAL and PRINT_OPTO_ASSEMBLY. PRINT_IDEAL is the output that is printed\n+ * when using -XX:+PrintIdeal and PRINT_OPTO_ASSEMBLY when using -XX:+PrintOptoAssembly. For simplicity, these two flags\n+ * are treated as a separated compile phase as well.\n+ *\/\n+public enum CompilePhase {\n+    DEFAULT(\"For IR node placeholder strings as defined in class IRNode only\"),\n+\n+    BEFORE_STRINGOPTS(\"Before StringOpts\"),\n+    AFTER_STRINGOPTS(\"After StringOpts\"),\n+    BEFORE_REMOVEUSELESS(\"Before RemoveUseless\"),\n+    AFTER_PARSING(\"After Parsing\"),\n+    ITER_GVN1(\"Iter GVN 1\"),\n+    INCREMENTAL_INLINE_STEP(\"Incremental Inline Step\"),\n+    INCREMENTAL_INLINE_CLEANUP(\"Incremental Inline Cleanup\"),\n+    INCREMENTAL_INLINE(\"Incremental Inline\"),\n+    INCREMENTAL_BOXING_INLINE(\"Incremental Boxing Inline\"),\n+    EXPAND_VUNBOX(\"Expand VectorUnbox\"),\n+    SCALARIZE_VBOX(\"Scalarize VectorBox\"),\n+    INLINE_VECTOR_REBOX(\"Inline Vector Rebox Calls\"),\n+    EXPAND_VBOX(\"Expand VectorBox\"),\n+    ELIMINATE_VBOX_ALLOC(\"Eliminate VectorBoxAllocate\"),\n+    ITER_GVN_BEFORE_EA(\"Iter GVN before EA\"),\n+    ITER_GVN_AFTER_VECTOR(\"Iter GVN after vector box elimination\"),\n+    BEFORE_BEAUTIFY_LOOPS(\"Before beautify loops\"),\n+    AFTER_BEAUTIFY_LOOPS(\"After beautify loops\"),\n+    \/\/ Match on very first BEFORE_CLOOPS phase (there could be multiple phases for multiple loops in the code).\n+    BEFORE_CLOOPS(\"Before CountedLoop\", RegexType.IDEAL_INDEPENDENT, ActionOnRepeat.KEEP_FIRST),\n+    AFTER_CLOOPS(\"After CountedLoop\"),\n+    PHASEIDEAL_BEFORE_EA(\"PhaseIdealLoop before EA\"),\n+    AFTER_EA(\"After Escape Analysis\"),\n+    ITER_GVN_AFTER_EA(\"Iter GVN after EA\"),\n+    ITER_GVN_AFTER_ELIMINATION(\"Iter GVN after eliminating allocations and locks\"),\n+    PHASEIDEALLOOP1(\"PhaseIdealLoop 1\"),\n+    PHASEIDEALLOOP2(\"PhaseIdealLoop 2\"),\n+    PHASEIDEALLOOP3(\"PhaseIdealLoop 3\"),\n+    CCP1(\"PhaseCCP 1\"),\n+    ITER_GVN2(\"Iter GVN 2\"),\n+    PHASEIDEALLOOP_ITERATIONS(\"PhaseIdealLoop iterations\"),\n+    MACRO_EXPANSION(\"Macro expand\"),\n+    BARRIER_EXPANSION(\"Barrier expand\"),\n+    OPTIMIZE_FINISHED(\"Optimize finished\"),\n+    PRINT_IDEAL(\"PrintIdeal\"),\n+    BEFORE_MATCHING(\"Before matching\"),\n+    MATCHING(\"After matching\", RegexType.MACH),\n+    MACH_ANALYSIS(\"After mach analysis\", RegexType.MACH),\n+    GLOBAL_CODE_MOTION(\"Global code motion\", RegexType.MACH),\n+    FINAL_CODE(\"Final Code\", RegexType.MACH),\n+    END(\"End\"),\n+\n+    PRINT_OPTO_ASSEMBLY(\"PrintOptoAssembly\", RegexType.OPTO_ASSEMBLY),\n+    ;\n+\n+    private static final Map<String, CompilePhase> PHASES_BY_PARSED_NAME = new HashMap<>();\n+\n+    static {\n+        for (CompilePhase phase : CompilePhase.values()) {\n+            if (phase == PRINT_IDEAL) {\n+                PHASES_BY_PARSED_NAME.put(\"print_ideal\", phase);\n+            } else {\n+                PHASES_BY_PARSED_NAME.put(phase.name(), phase);\n+            }\n+        }\n+    }\n+    private enum ActionOnRepeat {\n+        KEEP_FIRST, KEEP_LAST\n+    }\n+\n+    private final String name;\n+    private final RegexType regexType;\n+    private final ActionOnRepeat actionOnRepeat;\n+\n+    CompilePhase(String name) {\n+        this.name = name;\n+        this.regexType = RegexType.IDEAL_INDEPENDENT;\n+        this.actionOnRepeat = ActionOnRepeat.KEEP_LAST;\n+    }\n+\n+    CompilePhase(String name, RegexType regexType) {\n+        this.name = name;\n+        this.regexType = regexType;\n+        this.actionOnRepeat = ActionOnRepeat.KEEP_LAST;\n+    }\n+\n+    CompilePhase(String name, RegexType regexType, ActionOnRepeat actionOnRepeat) {\n+        this.name = name;\n+        this.regexType = regexType;\n+        this.actionOnRepeat = actionOnRepeat;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public RegexType regexType() {\n+        return regexType;\n+    }\n+\n+    public static CompilePhase forName(String phaseName) {\n+        CompilePhase phase = PHASES_BY_PARSED_NAME.get(phaseName);\n+        TestFramework.check(phase != null, \"Could not find phase with name \\\"\" + phaseName + \"\\\"\");\n+        return phase;\n+    }\n+\n+    public boolean overrideRepeatedPhase() {\n+        return actionOnRepeat == ActionOnRepeat.KEEP_LAST;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/CompilePhase.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -144,0 +144,14 @@\n+\n+     \/**\n+     * Accepts a list of feature pairs where each pair is composed of target feature string followed by a true\/false\n+     * value where a true value necessities existence of target feature and vice-versa.\n+     * IR verifications checks are enforced if any of the specified feature constraint is met.\n+     *\/\n+    String[] applyIfCPUFeatureOr() default {};\n+\n+    \/**\n+     * Accepts a list of feature pairs where each pair is composed of target feature string followed by a true\/false\n+     * value where a true value necessities existence of target feature and vice-versa.\n+     * IR verifications checks are enforced only if all the specified feature constraints are met.\n+     *\/\n+    String[] applyIfCPUFeatureAnd() default {};\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IR.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import compiler.lib.ir_framework.driver.irmatching.IRMatcher;\n+import compiler.lib.ir_framework.driver.irmatching.mapping.*;\n@@ -33,0 +33,2 @@\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -148,0 +150,22 @@\n+    private static final String PREFIX = \"_#\";\n+    private static final String VECTOR_PREFIX = PREFIX + \"V#\";\n+    private static final String POSTFIX = \"#_\";\n+    public static final String VECTOR_SIZE = \"_@\";\n+    private static final String TYPE_BYTE   = \"byte\";\n+    private static final String TYPE_CHAR   = \"char\";\n+    private static final String TYPE_SHORT  = \"short\";\n+    private static final String TYPE_INT    = \"int\";\n+    private static final String TYPE_LONG   = \"long\";\n+    private static final String TYPE_FLOAT  = \"float\";\n+    private static final String TYPE_DOUBLE = \"double\";\n+\n+    \/**\n+     * IR placeholder string to regex-for-compile-phase map.\n+     *\/\n+    private static final Map<String, IRNodeMapEntry> IR_NODE_MAPPINGS = new HashMap<>();\n+\n+    \/**\n+     * Map every vectorNode to a type string.\n+     *\/\n+    private static final Map<String, String> VECTOR_NODE_TYPE = new HashMap<>();\n+\n@@ -223,0 +247,92 @@\n+\n+    public static final String LOAD_VECTOR_I = VECTOR_PREFIX + \"LOAD_VECTOR_I\" + POSTFIX;\n+    static {\n+        vectorNode(LOAD_VECTOR_I, \"LoadVector\", TYPE_INT);\n+    }\n+\n+    public static final String STORE_VECTOR = PREFIX + \"STORE_VECTOR\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STORE_VECTOR, \"StoreVector\");\n+    }\n+    \n+    public static final String ADD_VI = VECTOR_PREFIX + \"ADD_VI\" + POSTFIX;\n+    static {\n+        vectorNode(ADD_VI, \"AddVI\", TYPE_INT);\n+    }\n+\n+    public static final String SUB_VI = VECTOR_PREFIX + \"SUB_VI\" + POSTFIX;\n+    static {\n+        vectorNode(SUB_VI, \"SubVI\", TYPE_INT);\n+    }\n+\n+    public static final String LSHIFT_VI = VECTOR_PREFIX + \"LSHIFT_VI\" + POSTFIX;\n+    static {\n+        vectorNode(LSHIFT_VI, \"LShiftVI\", TYPE_INT);\n+    }\n+\n+    public static final String MUL_VI = VECTOR_PREFIX + \"MUL_VI\" + POSTFIX;\n+    static {\n+        vectorNode(MUL_VI, \"MulVI\", TYPE_INT);\n+    }\n+\n+    \/**\n+     * Is {@code irVectorSizeString} a vector size string?\n+     *\/\n+    public static boolean isVectorSize(String irVectorSizeString) {\n+        return irVectorSizeString.startsWith(VECTOR_SIZE);\n+    }\n+\n+    public static final String RSHIFT_VI = VECTOR_PREFIX + \"RSHIFT_VI\" + POSTFIX;\n+    static {\n+        vectorNode(RSHIFT_VI, \"RShiftVI\", TYPE_INT);\n+    }\n+\n+    public static final String AND_VI = VECTOR_PREFIX + \"AND_VI\" + POSTFIX;\n+    static {\n+        vectorNode(AND_VI, \"AndV\", TYPE_INT);\n+    }\n+\n+    public static final String OR_VI = VECTOR_PREFIX + \"OR_VI\" + POSTFIX;\n+    static {\n+        vectorNode(OR_VI, \"OrV\", TYPE_INT);\n+    }\n+\n+    public static final String XOR_VI = VECTOR_PREFIX + \"XOR_VI\" + POSTFIX;\n+    static {\n+        vectorNode(XOR_VI, \"XorV\", TYPE_INT);\n+    }\n+\n+    public static final String URSHIFT_VI = VECTOR_PREFIX + \"URSHIFT_VI\" + POSTFIX;\n+    static {\n+        vectorNode(URSHIFT_VI, \"URShiftVI\", TYPE_INT);\n+    }\n+\n+    \/**\n+     * Apply {@code irNodeRegex} as regex for the IR vector node name on all machine independent ideal graph phases up to and\n+     * including {@link CompilePhase#BEFORE_MATCHING}. Since this is a vector node, we can also check the vector element\n+     * type {@code typeString} and the vector size (number of elements), {@see VECTOR_SIZE}.\n+     *\/\n+    private static void vectorNode(String irNodePlaceholder, String irNodeRegex, String typeString) {\n+        TestFramework.check(isVectorIRNode(irNodePlaceholder), \"vectorNode: failed prefix check for irNodePlaceholder \"\n+                                                               + irNodePlaceholder + \" -> did you use VECTOR_PREFIX?\");\n+        \/\/ IS_REPLACED is later replaced with the specific type and size of the vector.\n+        String regex = START + irNodeRegex + MID  + IS_REPLACED + END;\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new RegexTypeEntry(RegexType.IDEAL_INDEPENDENT, regex));\n+        VECTOR_NODE_TYPE.put(irNodePlaceholder, typeString);\n+    }\n+\n+    \/**\n+     * Apply {@code irNodeRegex} as regex for the IR node name on all machine independent ideal graph phases up to and\n+     * including {@link CompilePhase#BEFORE_MATCHING}.\n+     *\/\n+    private static void beforeMatchingNameRegex(String irNodePlaceholder, String irNodeRegex) {\n+        String regex = START + irNodeRegex + MID + END;\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new RegexTypeEntry(RegexType.IDEAL_INDEPENDENT, regex));\n+    }\n+\n+    \/**\n+     * Is {@code irVectorNodeString} an IR vector node placeholder string?\n+     *\/\n+    public static boolean isVectorIRNode(String irVectorNodeString) {\n+        return irVectorNodeString.startsWith(VECTOR_PREFIX);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":117,"deletions":1,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+\/**\n+ * Enum to denote the regex type of the associated {@link CompilePhase}.\n+ *\n+ * @see CompilePhase\n+ *\/\n+public enum RegexType {\n+    IDEAL_INDEPENDENT, MACH, OPTO_ASSEMBLY\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/RegexType.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.mapping;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+\n+\/**\n+ * This interface represents an IR node mapping entry in {@code IR_NODE_MAPPINGS} in {@link IRNode}. Each entry must\n+ * return a regex for a {@link CompilePhase} or null if it does not support the compile phase. Additionally, a default\n+ * compile phase must be specified to fall back to when a user test specifies {@link CompilePhase#DEFAULT} in\n+ * {@link IR#phase} or does not provide the {@link IR#phase} attribute.\n+ *\n+ * @see IRNode\n+ * @see CompilePhase\n+ *\/\n+public interface IRNodeMapEntry {\n+    \/**\n+     * Return the regex string which shall be used by the IR framework when matching on {@code compilePhase}.\n+     *\/\n+    String regexForCompilePhase(CompilePhase compilePhase);\n+\n+    \/**\n+     * Return the default compile phase that shall be used for an {@link IRNode} placeholeder string when the user test\n+     * specifies {@link CompilePhase#DEFAULT}.\n+     *\/\n+    CompilePhase defaultCompilePhase();\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/mapping\/IRNodeMapEntry.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.mapping;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.RegexType;\n+\n+\/**\n+ * This class represents a mapping entry for an IR node that maps to a single regex for all compile phases whose\n+ * {@link CompilePhase#regexType()} match the specified {@link RegexType} for this entry.\n+ *\/\n+public class RegexTypeEntry implements IRNodeMapEntry {\n+    private final SingleRegexEntry singleRegexEntry;\n+    private final RegexType regexType;\n+\n+    public RegexTypeEntry(RegexType regexType, String regex) {\n+        this.regexType = regexType;\n+        CompilePhase defaultCompilePhase = switch (regexType) {\n+            case IDEAL_INDEPENDENT -> CompilePhase.PRINT_IDEAL;\n+            case MACH -> CompilePhase.FINAL_CODE;\n+            case OPTO_ASSEMBLY -> CompilePhase.PRINT_OPTO_ASSEMBLY;\n+        };\n+        this.singleRegexEntry = new SingleRegexEntry(defaultCompilePhase, regex);\n+    }\n+\n+    @Override\n+    public String regexForCompilePhase(CompilePhase compilePhase) {\n+        if (compilePhase.regexType() == regexType) {\n+            return singleRegexEntry.regex();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public CompilePhase defaultCompilePhase() {\n+        return singleRegexEntry.defaultCompilePhase();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/mapping\/RegexTypeEntry.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.mapping;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+\n+\/**\n+ * This class represents a mapping entry for an IR node that maps to a single regex for multiple compile phases.\n+ * If the IR node is only applicable to a single compile phase, a {@link SinglePhaseEntry} should be used.\n+ *\/\n+record SingleRegexEntry(CompilePhase defaultCompilePhase, String regex) {\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/mapping\/SingleRegexEntry.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"}]}