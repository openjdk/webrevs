{"files":[{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.jvm;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.spi.ToolProvider;\n+\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @summary Checks that a JDK image with and without the jdk.jfr module behaves\n+ *          as expected\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run driver jdk.jfr.jvm.TestModularImage\n+ *\/\n+public class TestModularImage {\n+    private static final String STARTED_RECORDING = \"Started recording\";\n+    private static final String HELLO_WORLD = \"hello, world\";\n+    private static final String ERROR_LINE1 = \"Error occurred during initialization of boot layer\";\n+    private static final String ERROR_LINE2 = \"java.lang.module.FindException: Module jdk.jfr not found\";\n+\n+    private static final ToolProvider javac = find(\"javac\");\n+    private static final ToolProvider jlink = find(\"jlink\");\n+\n+    private static final Path out = Path.of(\"out\");\n+    private static final Path src = out.resolve(\"src\");\n+    private static final Path classes = out.resolve(\"classes\");\n+\n+    private static final Path testJDK = Path.of(System.getProperty(\"test.jdk\"));\n+    private static final Path jmods = testJDK.resolve(\"jmods\");\n+\n+    private static final String modulePath = jmods.toString() + File.pathSeparator + classes.toString();\n+\n+    public static void main(String[] args) throws Exception {\n+        preparseSourceTree();\n+        compileSourceCode();\n+\n+        \/\/ Jcmd for the current JVM where jdk.attach module is available\n+        String currentJcmd = JDKToolFinder.getJDKTool(\"jcmd\");\n+        currentJcmd = Path.of(currentJcmd).normalize().toAbsolutePath().toString();\n+\n+        \/\/ Image 1: Should be able to start JFR if jdk.jfr module is present\n+        Path javaBin1 = jlink(\"hello.world,jdk.jfr\", \"with-jfr\");\n+        testCommandLineWithJFR(javaBin1);\n+        testJcmdWithJFR(javaBin1, currentJcmd);\n+\n+        \/\/ Image 2: Should fail if jdk.jfr module is not present\n+        Path javaBin2 = jlink(\"hello.world\", \"without-jfr\");\n+        testCommandLineWithoutJFR(javaBin2);\n+        testJcmdWithoutJFR(javaBin2, currentJcmd);\n+    }\n+\n+    private static void testCommandLineWithJFR(Path binPath) throws Exception {\n+        var result = java(binPath, \"-XX:StartFlightRecording\", \"--module\", \"hello.world\/hello.Main\");\n+        result.shouldNotContain(ERROR_LINE1);\n+        result.shouldNotContain(ERROR_LINE2);\n+        result.shouldContain(HELLO_WORLD);\n+        result.shouldContain(STARTED_RECORDING);\n+        result.shouldHaveExitValue(0);\n+    }\n+\n+    private static void testJcmdWithJFR(Path binPath, String jcmd) throws Exception {\n+        var result = java(binPath, \"--module\", \"hello.world\/hello.Main\", jcmd);\n+        result.shouldContain(HELLO_WORLD);\n+        result.shouldNotContain(ERROR_LINE1);\n+        result.shouldNotContain(ERROR_LINE2);\n+        result.shouldContain(STARTED_RECORDING);\n+        result.shouldHaveExitValue(0);\n+    }\n+\n+    private static void testCommandLineWithoutJFR(Path binPath) throws Exception {\n+        var result = java(binPath, \"-XX:StartFlightRecording\", \"--module\", \"hello.world\/hello.Main\");\n+        result.shouldContain(ERROR_LINE1);\n+        result.shouldContain(ERROR_LINE2);\n+        result.shouldNotContain(HELLO_WORLD);\n+        result.shouldNotContain(STARTED_RECORDING);\n+        result.shouldHaveExitValue(1);\n+    }\n+\n+    private static void testJcmdWithoutJFR(Path binPath, String jcmd) throws Exception {\n+        OutputAnalyzer result = java(binPath, \"--module\", \"hello.world\/hello.Main\", jcmd);\n+        result.shouldContain(HELLO_WORLD);\n+        result.shouldContain(\"Module jdk.jfr not found.\");\n+        result.shouldContain(\"Flight Recorder can not be enabled.\");\n+        result.shouldNotContain(STARTED_RECORDING);\n+        result.shouldHaveExitValue(0);\n+    }\n+\n+    private static ToolProvider find(String tool) {\n+        return ToolProvider.findFirst(tool).orElseThrow(() -> new RuntimeException(\"No \" + tool));\n+    }\n+\n+    private static void preparseSourceTree() throws IOException {\n+        String main =\n+        \"\"\"\n+        package hello;\n+        import java.io.ByteArrayOutputStream;\n+        public class Main {\n+          public static void main(String... args) throws Exception {\n+            System.out.println(\"hello, world!\");\n+            if (args.length > 0) {\n+              long pid = ProcessHandle.current().pid();\n+              String jcmd = args[0];\n+              String[] cmds = { jcmd, Long.toString(pid), \"JFR.start\" };\n+              Process process = new ProcessBuilder(cmds).redirectErrorStream(true).start();\n+              process.waitFor();\n+              var baos = new ByteArrayOutputStream();\n+              process.getInputStream().transferTo(baos);\n+              System.out.println(baos.toString());\n+              System.exit(process.exitValue());\n+            }\n+          }\n+        }\n+        \"\"\";\n+        String moduleInfo = \"module hello.world {}\";\n+        Path helloWorld = src.resolve(\"hello.world\");\n+        Files.createDirectories(helloWorld.resolve(\"hello\"));\n+        Files.write(helloWorld.resolve(\"module-info.java\"), moduleInfo.getBytes());\n+        Files.write(helloWorld.resolve(\"hello\").resolve(\"Main.java\"), main.getBytes());\n+    }\n+\n+    private static void compileSourceCode() {\n+        javac.run(System.out, System.err,\n+            \"--module-source-path\", src.toString(),\n+            \"--module\", \"hello.world\",\n+            \"-d\", classes.toString());\n+    }\n+\n+    private static Path jlink(String modules, String output) {\n+        jlink.run(System.out, System.err,\n+            \"--add-modules\", modules,\n+            \"--module-path\", modulePath,\n+            \"--output\", output);\n+        return Path.of(output).resolve(\"bin\").toAbsolutePath();\n+    }\n+\n+    private static OutputAnalyzer java(Path jvm, String... args) throws Exception {\n+        ProcessBuilder pb = new ProcessBuilder();\n+        String java = Platform.isWindows() ? \"java.exe\" : \"java\";\n+        List<String> arguments = new ArrayList<>();\n+        arguments.add(jvm.resolve(java).toString());\n+        arguments.addAll(Arrays.asList(args));\n+        pb.command(arguments);\n+        pb.directory(jvm.toFile());\n+        System.out.println(\"Executing: java \" + String.join(\" \", args));\n+        OutputAnalyzer result = ProcessTools.executeProcess(pb);\n+        System.out.println(\"--- Output ----\" + \"-\".repeat(65));\n+        System.out.println(result.getOutput());\n+        System.out.println(\"-\".repeat(80));\n+        return result;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestModularImage.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"}]}