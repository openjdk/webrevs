{"files":[{"patch":"@@ -106,4 +106,0 @@\n-static bool is_module_available(outputStream* output, TRAPS) {\n-  return JfrJavaSupport::is_jdk_jfr_module_available(output, THREAD);\n-}\n-\n@@ -122,1 +118,22 @@\n-  return is_disabled(out) || !is_module_available(out, THREAD);\n+  if (is_disabled(out)) {\n+    return true;\n+  }\n+  if (!JfrJavaSupport::is_jdk_jfr_module_available()) {\n+    JfrJavaSupport::load_jdk_jfr_module(THREAD);\n+    if (HAS_PENDING_EXCEPTION) {\n+      \/\/ Log exception here, but let is_jdk_jfr_module_available(out, THREAD)\n+      \/\/ handle output to the user.\n+      ResourceMark rm(THREAD);\n+      oop throwable = PENDING_EXCEPTION;\n+      assert(throwable != nullptr, \"invariant\");\n+      oop msg = java_lang_Throwable::message(throwable);\n+      if (msg != nullptr) {\n+        char* text = java_lang_String::as_utf8_string(msg);\n+        if (text != nullptr) {\n+          log_debug(jfr, startup)(\"Flight Recorder can not be enabled. %s\", text);\n+        }\n+      }\n+      CLEAR_PENDING_EXCEPTION;\n+    }\n+  }\n+  return !JfrJavaSupport::is_jdk_jfr_module_available(out, THREAD);\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.cpp","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/javaCalls.hpp\"\n@@ -610,0 +611,17 @@\n+\n+\n+void JfrJavaSupport::load_jdk_jfr_module(TRAPS) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+  ResourceMark rm(THREAD);\n+  HandleMark hm(THREAD);\n+  Handle h_module_name = java_lang_String::create_from_str(JDK_JFR_MODULE_NAME, CHECK);\n+  JavaValue result(T_OBJECT);\n+  JavaCalls::call_static(&result,\n+    vmClasses::module_Modules_klass(),\n+    vmSymbols::loadModule_name(),\n+    vmSymbols::loadModule_signature(),\n+    h_module_name,\n+    CHECK\n+  );\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+  static void load_jdk_jfr_module(TRAPS);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1999,0 +1999,8 @@\n+#if INCLUDE_JFR\n+  if (status && (FlightRecorderOptions || StartFlightRecording)) {\n+    if (!create_numbered_module_property(\"jdk.module.addmods\", \"jdk.jfr\", addmods_count++)) {\n+      return false;\n+    }\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8157032\n- * @key jfr\n- * @summary verify that jfr can not be used when JVM is executed only with java.base\n- * @requires vm.hasJFR & !vm.graal.enabled\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- * @run driver jdk.jfr.jvm.TestJfrJavaBase\n- *\/\n-\n-package jdk.jfr.jvm;\n-\n-\n-import jdk.test.lib.dcmd.PidJcmdExecutor;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class TestJfrJavaBase {\n-\n-    private static void checkOutput(OutputAnalyzer output) {\n-        output.shouldContain(\"Module jdk.jfr not found.\");\n-        output.shouldContain(\"Flight Recorder can not be enabled.\");\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        OutputAnalyzer output;\n-        if (args.length == 0) {\n-            output = ProcessTools.executeProcess(ProcessTools.createJavaProcessBuilder(\n-                \"-Dtest.jdk=\" + System.getProperty(\"test.jdk\"),\n-                \"--limit-modules\", \"java.base\", \"-cp\", System.getProperty(\"java.class.path\"),\n-                TestJfrJavaBase.class.getName(), \"runtest\"));\n-            output.shouldHaveExitValue(0);\n-        } else {\n-            output = ProcessTools.executeTestJava(\"-XX:StartFlightRecording:dumponexit=true\",\n-                \"--limit-modules\", \"java.base\", \"-version\");\n-            checkOutput(output);\n-            output.shouldHaveExitValue(1);\n-\n-            \/\/ Verify that JFR.start jcmd command reports an error when jdk.jfr module is not available\n-            output = new PidJcmdExecutor().execute(\"JFR.start\");\n-            checkOutput(output);\n-            output.shouldHaveExitValue(0);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestJfrJavaBase.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.jvm;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.spi.ToolProvider;\n+\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @summary Checks that a JDK image with and without the jdk.jfr module behaves\n+ *          as expected\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run driver jdk.jfr.jvm.TestModularImage\n+ *\/\n+public class TestModularImage {\n+    private static final String STARTED_RECORDING = \"Started recording\";\n+    private static final String HELLO_WORLD = \"hello, world\";\n+    private static final String ERROR_LINE1 = \"Error occurred during initialization of boot layer\";\n+    private static final String ERROR_LINE2 = \"java.lang.module.FindException: Module jdk.jfr not found\";\n+\n+    private static final ToolProvider javac = find(\"javac\");\n+    private static final ToolProvider jlink = find(\"jlink\");\n+\n+    private static final Path out = Path.of(\"out\");\n+    private static final Path src = out.resolve(\"src\");\n+    private static final Path classes = out.resolve(\"classes\");\n+\n+    private static final Path testJDK = Path.of(System.getProperty(\"test.jdk\"));\n+    private static final Path jmods = testJDK.resolve(\"jmods\");\n+\n+    private static final String modulePath = jmods.toString() + File.pathSeparator + classes.toString();\n+\n+    public static void main(String[] args) throws Exception {\n+        preparseSourceTree();\n+        compileSourceCode();\n+\n+        \/\/ Jcmd for the current JVM where jdk.attach module is available\n+        String currentJcmd = JDKToolFinder.getJDKTool(\"jcmd\");\n+        currentJcmd = Path.of(currentJcmd).normalize().toAbsolutePath().toString();\n+\n+        \/\/ Image 1: Should be able to start JFR if jdk.jfr module is present\n+        Path javaBin1 = jlink(\"hello.world,jdk.jfr\", \"with-jfr\");\n+        testCommandLineWithJFR(javaBin1);\n+        testJcmdWithJFR(javaBin1, currentJcmd);\n+\n+        \/\/ Image 2: Should fail if jdk.jfr module is not present\n+        Path javaBin2 = jlink(\"hello.world\", \"without-jfr\");\n+        testCommandLineWithoutJFR(javaBin2);\n+        testJcmdWithoutJFR(javaBin2, currentJcmd);\n+    }\n+\n+    private static void testCommandLineWithJFR(Path binPath) throws Exception {\n+        var result = java(binPath, \"-XX:StartFlightRecording\", \"--module\", \"hello.world\/hello.Main\");\n+        result.shouldNotContain(ERROR_LINE1);\n+        result.shouldNotContain(ERROR_LINE2);\n+        result.shouldContain(HELLO_WORLD);\n+        result.shouldContain(STARTED_RECORDING);\n+        result.shouldHaveExitValue(0);\n+    }\n+\n+    private static void testJcmdWithJFR(Path binPath, String jcmd) throws Exception {\n+        var result = java(binPath, \"--module\", \"hello.world\/hello.Main\", jcmd);\n+        result.shouldContain(HELLO_WORLD);\n+        result.shouldNotContain(ERROR_LINE1);\n+        result.shouldNotContain(ERROR_LINE2);\n+        result.shouldContain(STARTED_RECORDING);\n+        result.shouldHaveExitValue(0);\n+    }\n+\n+    private static void testCommandLineWithoutJFR(Path binPath) throws Exception {\n+        var result = java(binPath, \"-XX:StartFlightRecording\", \"--module\", \"hello.world\/hello.Main\");\n+        result.shouldContain(ERROR_LINE1);\n+        result.shouldContain(ERROR_LINE2);\n+        result.shouldNotContain(HELLO_WORLD);\n+        result.shouldNotContain(STARTED_RECORDING);\n+        result.shouldHaveExitValue(1);\n+    }\n+\n+    private static void testJcmdWithoutJFR(Path binPath, String jcmd) throws Exception {\n+        OutputAnalyzer result = java(binPath, \"--module\", \"hello.world\/hello.Main\", jcmd);\n+        result.shouldContain(HELLO_WORLD);\n+        result.shouldContain(\"Module jdk.jfr not found.\");\n+        result.shouldContain(\"Flight Recorder can not be enabled.\");\n+        result.shouldNotContain(STARTED_RECORDING);\n+        result.shouldHaveExitValue(0);\n+    }\n+\n+    private static ToolProvider find(String tool) {\n+        return ToolProvider.findFirst(tool).orElseThrow(() -> new RuntimeException(\"No \" + tool));\n+    }\n+\n+    private static void preparseSourceTree() throws IOException {\n+        String main =\n+        \"\"\"\n+        package hello;\n+        import java.io.ByteArrayOutputStream;\n+        public class Main {\n+          public static void main(String... args) throws Exception {\n+            System.out.println(\"hello, world!\");\n+            if (args.length > 0) {\n+              long pid = ProcessHandle.current().pid();\n+              String jcmd = args[0];\n+              String[] cmds = { jcmd, Long.toString(pid), \"JFR.start\" };\n+              Process process = new ProcessBuilder(cmds).redirectErrorStream(true).start();\n+              process.waitFor();\n+              var baos = new ByteArrayOutputStream();\n+              process.getInputStream().transferTo(baos);\n+              System.out.println(baos.toString());\n+              System.exit(process.exitValue());\n+            }\n+          }\n+        }\n+        \"\"\";\n+        String moduleInfo = \"module hello.world {}\";\n+        Path helloWorld = src.resolve(\"hello.world\");\n+        Files.createDirectories(helloWorld.resolve(\"hello\"));\n+        Files.write(helloWorld.resolve(\"module-info.java\"), moduleInfo.getBytes());\n+        Files.write(helloWorld.resolve(\"hello\").resolve(\"Main.java\"), main.getBytes());\n+    }\n+\n+    private static void compileSourceCode() {\n+        javac.run(System.out, System.err,\n+            \"--module-source-path\", src.toString(),\n+            \"--module\", \"hello.world\",\n+            \"-d\", classes.toString());\n+    }\n+\n+    private static Path jlink(String modules, String output) {\n+        jlink.run(System.out, System.err,\n+            \"--add-modules\", modules,\n+            \"--module-path\", modulePath,\n+            \"--output\", output);\n+        return Path.of(output).resolve(\"bin\").toAbsolutePath();\n+    }\n+\n+    private static OutputAnalyzer java(Path jvm, String... args) throws Exception {\n+        ProcessBuilder pb = new ProcessBuilder();\n+        String java = Platform.isWindows() ? \"java.exe\" : \"java\";\n+        List<String> arguments = new ArrayList<>();\n+        arguments.add(jvm.resolve(java).toString());\n+        arguments.addAll(Arrays.asList(args));\n+        pb.command(arguments);\n+        pb.directory(jvm.toFile());\n+        System.out.println(\"Executing: java \" + String.join(\" \", args));\n+        OutputAnalyzer result = ProcessTools.executeProcess(pb);\n+        System.out.println(\"--- Output ----\" + \"-\".repeat(65));\n+        System.out.println(result.getOutput());\n+        System.out.println(\"-\".repeat(80));\n+        return result;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestModularImage.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"}]}