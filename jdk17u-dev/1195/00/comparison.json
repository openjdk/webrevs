{"files":[{"patch":"@@ -2722,0 +2722,45 @@\n+Handle java_lang_Throwable::get_cause_with_stack_trace(Handle throwable, TRAPS) {\n+  \/\/ Call to JVM to fill in the stack trace and clear declaringClassObject to\n+  \/\/ not keep classes alive in the stack trace.\n+  \/\/ call this:  public StackTraceElement[] getStackTrace()\n+  assert(throwable.not_null(), \"shouldn't be\");\n+\n+  JavaValue result(T_ARRAY);\n+  JavaCalls::call_virtual(&result, throwable,\n+                          vmClasses::Throwable_klass(),\n+                          vmSymbols::getStackTrace_name(),\n+                          vmSymbols::getStackTrace_signature(),\n+                          CHECK_NH);\n+  Handle stack_trace(THREAD, result.get_oop());\n+  assert(stack_trace->is_objArray(), \"Should be an array\");\n+\n+  \/\/ Throw ExceptionInInitializerError as the cause with this exception in\n+  \/\/ the message and stack trace.\n+\n+  \/\/ Now create the message with the original exception and thread name.\n+  Symbol* message = java_lang_Throwable::detail_message(throwable());\n+  ResourceMark rm(THREAD);\n+  stringStream st;\n+  st.print(\"Exception %s%s \", throwable()->klass()->name()->as_klass_external_name(),\n+             message == nullptr ? \"\" : \":\");\n+  if (message == NULL) {\n+    st.print(\"[in thread \\\"%s\\\"]\", THREAD->name());\n+  } else {\n+    st.print(\"%s [in thread \\\"%s\\\"]\", message->as_C_string(), THREAD->name());\n+  }\n+\n+  Symbol* exception_name = vmSymbols::java_lang_ExceptionInInitializerError();\n+  Handle h_cause = Exceptions::new_exception(THREAD, exception_name, st.as_string());\n+\n+  \/\/ If new_exception returns a different exception while creating the exception, return null.\n+  if (h_cause->klass()->name() != exception_name) {\n+    log_info(class, init)(\"Exception thrown while saving initialization exception %s\",\n+                          h_cause->klass()->external_name());\n+    return Handle();\n+  }\n+  java_lang_Throwable::set_stacktrace(h_cause(), stack_trace());\n+  \/\/ Clear backtrace because the stacktrace should be used instead.\n+  set_backtrace(h_cause(), NULL);\n+  return h_cause;\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -570,0 +570,4 @@\n+\n+  \/\/ For recreating class initialization error exceptions.\n+  static Handle get_cause_with_stack_trace(Handle throwable, TRAPS);\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1629,0 +1629,2 @@\n+\n+    InstanceKlass::clean_initialization_error_table();\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -371,0 +371,1 @@\n+  template(getStackTrace_name,                        \"getStackTrace\")                            \\\n@@ -596,1 +597,3 @@\n-  template(reflect_method_signature,                  \"Ljava\/lang\/reflect\/Method;\")                                                    \\\n+  template(reflect_method_signature,                  \"Ljava\/lang\/reflect\/Method;\")                               \\\n+  template(getStackTrace_signature,                    \"()[Ljava\/lang\/StackTraceElement;\")                        \\\n+                                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1024,0 +1024,53 @@\n+ResourceHashtable<const InstanceKlass*, OopHandle,\n+                  primitive_hash<const InstanceKlass*>,\n+                  primitive_equals<const InstanceKlass*>,\n+                  107,\n+                  ResourceObj::C_HEAP,\n+                  mtClass>\n+      _initialization_error_table;\n+\n+void InstanceKlass::add_initialization_error(JavaThread* current, Handle exception) {\n+  \/\/ Create the same exception with a message indicating the thread name,\n+  \/\/ and the StackTraceElements.\n+  \/\/ If the initialization error is OOM, this might not work, but if GC kicks in\n+  \/\/ this would be still be helpful.\n+  JavaThread* THREAD = current;\n+  Handle cause = java_lang_Throwable::get_cause_with_stack_trace(exception, THREAD);\n+  if (HAS_PENDING_EXCEPTION || cause.is_null()) {\n+    CLEAR_PENDING_EXCEPTION;\n+    return;\n+  }\n+\n+  MutexLocker ml(THREAD, ClassInitError_lock);\n+  OopHandle elem = OopHandle(Universe::vm_global(), cause());\n+  bool created = false;\n+  _initialization_error_table.put_if_absent(this, elem, &created);\n+  assert(created, \"Initialization is single threaded\");\n+  ResourceMark rm(THREAD);\n+  log_trace(class, init)(\"Initialization error added for class %s\", external_name());\n+}\n+\n+oop InstanceKlass::get_initialization_error(JavaThread* current) {\n+  MutexLocker ml(current, ClassInitError_lock);\n+  OopHandle* h = _initialization_error_table.get(this);\n+  return (h != nullptr) ? h->resolve() : nullptr;\n+}\n+\n+\/\/ Need to remove entries for unloaded classes.\n+void InstanceKlass::clean_initialization_error_table() {\n+  struct InitErrorTableCleaner {\n+    bool do_entry(const InstanceKlass* ik, OopHandle h) {\n+      if (!ik->is_loader_alive()) {\n+        h.release(Universe::vm_global());\n+        return true;\n+      } else {\n+        return false;\n+      }\n+    }\n+  };\n+\n+  MutexLocker ml(ClassInitError_lock);\n+  InitErrorTableCleaner cleaner;\n+  _initialization_error_table.unlink(&cleaner);\n+}\n+\n@@ -1070,7 +1123,6 @@\n-      const char* desc = \"Could not initialize class \";\n-      const char* className = external_name();\n-      size_t msglen = strlen(desc) + strlen(className) + 1;\n-      char* message = NEW_RESOURCE_ARRAY(char, msglen);\n-      if (NULL == message) {\n-        \/\/ Out of memory: can't create detailed error message\n-          THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), className);\n+      Handle cause(THREAD, get_initialization_error(THREAD));\n+\n+      stringStream ss;\n+      ss.print(\"Could not initialize class %s\", external_name());\n+      if (cause.is_null()) {\n+        THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), ss.as_string());\n@@ -1078,2 +1130,2 @@\n-        jio_snprintf(message, msglen, \"%s%s\", desc, className);\n-          THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), message);\n+        THROW_MSG_CAUSE(vmSymbols::java_lang_NoClassDefFoundError(),\n+                        ss.as_string(), cause);\n@@ -1110,0 +1162,1 @@\n+        add_initialization_error(THREAD, e);\n@@ -1145,3 +1198,1 @@\n-    {\n-      debug_only(vtable().verify(tty, true);)\n-    }\n+    debug_only(vtable().verify(tty, true);)\n@@ -1158,0 +1209,1 @@\n+      add_initialization_error(THREAD, e);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":64,"deletions":12,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -1199,0 +1199,1 @@\n+  static void clean_initialization_error_table();\n@@ -1208,0 +1209,3 @@\n+  void add_initialization_error(JavaThread* current, Handle exception);\n+  oop get_initialization_error(JavaThread* current);\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+Monitor* ClassInitError_lock          = NULL;\n@@ -258,0 +259,1 @@\n+  def(ClassInitError_lock          , PaddedMonitor, leaf+1,      true,  _safepoint_check_always);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+extern Monitor* ClassInitError_lock;             \/\/ a lock on the class initialization error table\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8048190\n+ * @summary Test that the NCDFE saves the stack trace for the original exception\n+ *          during class initialization with ExceptionInInitializationError,\n+ *          and doesn't prevent the classes in the stacktrace to be unloaded.\n+ * @requires vm.opt.final.ClassUnloading\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -Xmn8m -XX:+UnlockDiagnosticVMOptions -Xlog:class+unload -XX:+WhiteBoxAPI InitExceptionUnloadTest\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+\n+import sun.hotspot.WhiteBox;\n+import jdk.test.lib.classloader.ClassUnloadCommon;\n+\n+public class InitExceptionUnloadTest {\n+    static public class ThrowsRuntimeException { static int x = 1\/0; }\n+    static public class ThrowsError { static { if (true) throw new Error(); } }\n+    static public class SpecialException extends RuntimeException {\n+        SpecialException(int count, String message) {\n+            super(message + count);\n+        }\n+    }\n+    static public class ThrowsSpecialException {\n+        static {\n+            if (true) throw new SpecialException(3, \"Very Special \");\n+        }\n+    }\n+\n+    static public class ThrowsOOM {\n+        static {\n+            if (true) {\n+                \/\/ Actually getting an OOM might be fragile but it was tested.\n+                throw new OutOfMemoryError(\"Java heap space\");\n+            }\n+        }\n+    }\n+\n+    private static void verify_stack(Throwable e, String expected, String cause) throws Exception {\n+        ByteArrayOutputStream byteOS = new ByteArrayOutputStream();\n+        PrintStream printStream = new PrintStream(byteOS);\n+        e.printStackTrace(printStream);\n+        printStream.close();\n+        String stackTrace = byteOS.toString(\"ASCII\");\n+        if (!stackTrace.contains(expected) || (cause != null && !stackTrace.contains(cause))) {\n+            throw new RuntimeException(expected + \" and \" + cause + \" missing from stacktrace\");\n+        }\n+    }\n+\n+    static String[] expected = new String[] {\n+        \"java.lang.ExceptionInInitializerError\",\n+        \"Caused by: java.lang.ArithmeticException: \/ by zero\",\n+        \"java.lang.NoClassDefFoundError: Could not initialize class InitExceptionUnloadTest$ThrowsRuntimeException\",\n+        \"Caused by: java.lang.ExceptionInInitializerError: Exception java.lang.ArithmeticException: \/ by zero [in thread\",\n+        \"java.lang.Error\",\n+        null,\n+        \"java.lang.NoClassDefFoundError: Could not initialize class InitExceptionUnloadTest$ThrowsError\",\n+        \"Caused by: java.lang.ExceptionInInitializerError: Exception java.lang.Error [in thread\",\n+        \"java.lang.ExceptionInInitializerError\",\n+        \"Caused by: InitExceptionUnloadTest$SpecialException: Very Special 3\",\n+        \"java.lang.NoClassDefFoundError: Could not initialize class InitExceptionUnloadTest$ThrowsSpecialException\",\n+        \"Caused by: java.lang.ExceptionInInitializerError: Exception InitExceptionUnloadTest$SpecialException: Very Special 3\",\n+        \"java.lang.OutOfMemoryError\",\n+        \"Java heap space\",\n+        \"java.lang.NoClassDefFoundError: Could not initialize class InitExceptionUnloadTest$ThrowsOOM\",\n+        \"Caused by: java.lang.ExceptionInInitializerError: Exception java.lang.OutOfMemoryError: Java heap space [in thread\"\n+    };\n+\n+    static String[] classNames = new String[] {\n+        \"InitExceptionUnloadTest$ThrowsRuntimeException\",\n+        \"InitExceptionUnloadTest$ThrowsError\",\n+        \"InitExceptionUnloadTest$ThrowsSpecialException\",\n+        \"InitExceptionUnloadTest$ThrowsOOM\" };\n+\n+    public static WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    static void test() throws Throwable {\n+        ClassLoader cl = ClassUnloadCommon.newClassLoader();\n+        int i = 0;\n+        for (String className : classNames) {\n+            for (int tries = 2; tries-- > 0; ) {\n+                System.err.println(\"--- try to load \" + className);\n+                try {\n+                    Class<?> c = cl.loadClass(className);\n+                    Object inst = c.newInstance();\n+                } catch (Throwable t) {\n+                    t.printStackTrace();\n+                    System.err.println();\n+                    System.err.println(\"Check results\");\n+                    verify_stack(t, expected[i], expected[i+1]);\n+                    i += 2;\n+                    System.err.println();\n+                }\n+            }\n+        }\n+        cl = null;\n+        ClassUnloadCommon.triggerUnloading();  \/\/ should unload these classes\n+        for (String className : classNames) {\n+          ClassUnloadCommon.failIf(wb.isClassAlive(className), \"should be unloaded\");\n+        }\n+    }\n+    public static void main(java.lang.String[] unused) throws Throwable {\n+        test();\n+        test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassInitErrors\/InitExceptionUnloadTest.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"}]}