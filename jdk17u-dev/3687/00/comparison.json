{"files":[{"patch":"@@ -391,0 +391,18 @@\n+            if (!sameClient) {\n+                \/\/ Wait for the client to be garbage collected.\n+                \/\/ we use the ReferenceTracker API rather than HttpClient::close here,\n+                \/\/ because these tests inject faults by throwing inside callbacks, which\n+                \/\/ is more likely to get HttpClient::close wedged until jtreg times out.\n+                \/\/ By using the ReferenceTracker, we will get some diagnosis about what\n+                \/\/ is keeping the client alive if it doesn't get GC'ed within the\n+                \/\/ expected time frame.\n+                var tracker = TRACKER.getTracker(client);\n+                client = null;\n+                System.gc();\n+                System.out.println(now() + \"waiting for client to shutdown: \" + tracker.getName());\n+                System.err.println(now() + \"waiting for client to shutdown: \" + tracker.getName());\n+                var error = TRACKER.check(tracker, 10000);\n+                if (error != null) throw error;\n+                System.out.println(now() + \"client shutdown normally: \" + tracker.getName());\n+                System.err.println(now() + \"client shutdown normally: \" + tracker.getName());\n+            }\n@@ -473,0 +491,18 @@\n+            if (!sameClient) {\n+                \/\/ Wait for the client to be garbage collected.\n+                \/\/ we use the ReferenceTracker API rather than HttpClient::close here,\n+                \/\/ because these tests inject faults by throwing inside callbacks, which\n+                \/\/ is more likely to get HttpClient::close wedged until jtreg times out.\n+                \/\/ By using the ReferenceTracker, we will get some diagnosis about what\n+                \/\/ is keeping the client alive if it doesn't get GC'ed within the\n+                \/\/ expected time frame.\n+                var tracker = TRACKER.getTracker(client);\n+                client = null;\n+                System.gc();\n+                System.out.println(now() + \"waiting for client to shutdown: \" + tracker.getName());\n+                System.err.println(now() + \"waiting for client to shutdown: \" + tracker.getName());\n+                var error = TRACKER.check(tracker, 10000);\n+                if (error != null) throw error;\n+                System.out.println(now() + \"client shutdown normally: \" + tracker.getName());\n+                System.err.println(now() + \"client shutdown normally: \" + tracker.getName());\n+            }\n","filename":"test\/jdk\/java\/net\/httpclient\/AbstractThrowingPublishers.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -343,0 +343,18 @@\n+            if (!sameClient) {\n+                \/\/ Wait for the client to be garbage collected.\n+                \/\/ we use the ReferenceTracker API rather than HttpClient::close here,\n+                \/\/ because these tests inject faults by throwing inside callbacks, which\n+                \/\/ is more likely to get HttpClient::close wedged until jtreg times out.\n+                \/\/ By using the ReferenceTracker, we will get some diagnosis about what\n+                \/\/ is keeping the client alive if it doesn't get GC'ed within the\n+                \/\/ expected time frame.\n+                var tracker = TRACKER.getTracker(client);\n+                client = null;\n+                System.gc();\n+                System.out.println(now() + \"waiting for client to shutdown: \" + tracker.getName());\n+                System.err.println(now() + \"waiting for client to shutdown: \" + tracker.getName());\n+                var error = TRACKER.check(tracker, 10000);\n+                if (error != null) throw error;\n+                System.out.println(now() + \"client shutdown normally: \" + tracker.getName());\n+                System.err.println(now() + \"client shutdown normally: \" + tracker.getName());\n+            }\n@@ -428,0 +446,18 @@\n+            if (!sameClient) {\n+                \/\/ Wait for the client to be garbage collected.\n+                \/\/ we use the ReferenceTracker API rather than HttpClient::close here,\n+                \/\/ because these tests inject faults by throwing inside callbacks, which\n+                \/\/ is more likely to get HttpClient::close wedged until jtreg times out.\n+                \/\/ By using the ReferenceTracker, we will get some diagnosis about what\n+                \/\/ is keeping the client alive if it doesn't get GC'ed within the\n+                \/\/ expected time frame.\n+                var tracker = TRACKER.getTracker(client);\n+                client = null;\n+                System.gc();\n+                System.out.println(now() + \"waiting for client to shutdown: \" + tracker.getName());\n+                System.err.println(now() + \"waiting for client to shutdown: \" + tracker.getName());\n+                var error = TRACKER.check(tracker, 10000);\n+                if (error != null) throw error;\n+                System.out.println(now() + \"client shutdown normally: \" + tracker.getName());\n+                System.err.println(now() + \"client shutdown normally: \" + tracker.getName());\n+            }\n","filename":"test\/jdk\/java\/net\/httpclient\/AbstractThrowingPushPromises.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -317,0 +317,18 @@\n+            if (!sameClient) {\n+                \/\/ Wait for the client to be garbage collected.\n+                \/\/ we use the ReferenceTracker API rather than HttpClient::close here,\n+                \/\/ because these tests inject faults by throwing inside callbacks, which\n+                \/\/ is more likely to get HttpClient::close wedged until jtreg times out.\n+                \/\/ By using the ReferenceTracker, we will get some diagnosis about what\n+                \/\/ is keeping the client alive if it doesn't get GC'ed within the\n+                \/\/ expected time frame.\n+                var tracker = TRACKER.getTracker(client);\n+                client = null;\n+                System.gc();\n+                System.out.println(now() + \"waiting for client to shutdown: \" + tracker.getName());\n+                System.err.println(now() + \"waiting for client to shutdown: \" + tracker.getName());\n+                var error = TRACKER.check(tracker, 10000);\n+                if (error != null) throw error;\n+                System.out.println(now() + \"client shutdown normally: \" + tracker.getName());\n+                System.err.println(now() + \"client shutdown normally: \" + tracker.getName());\n+            }\n@@ -464,0 +482,18 @@\n+            if (!sameClient) {\n+                \/\/ Wait for the client to be garbage collected.\n+                \/\/ we use the ReferenceTracker API rather than HttpClient::close here,\n+                \/\/ because these tests inject faults by throwing inside callbacks, which\n+                \/\/ is more likely to get HttpClient::close wedged until jtreg times out.\n+                \/\/ By using the ReferenceTracker, we will get some diagnosis about what\n+                \/\/ is keeping the client alive if it doesn't get GC'ed within the\n+                \/\/ expected time frame.\n+                var tracker = TRACKER.getTracker(client);\n+                client = null;\n+                System.gc();\n+                System.out.println(now() + \"waiting for client to shutdown: \" + tracker.getName());\n+                System.err.println(now() + \"waiting for client to shutdown: \" + tracker.getName());\n+                var error = TRACKER.check(tracker, 10000);\n+                if (error != null) throw error;\n+                System.out.println(now() + \"client shutdown normally: \" + tracker.getName());\n+                System.err.println(now() + \"client shutdown normally: \" + tracker.getName());\n+            }\n","filename":"test\/jdk\/java\/net\/httpclient\/AbstractThrowingSubscribers.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"}]}