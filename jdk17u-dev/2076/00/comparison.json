{"files":[{"patch":"@@ -2728,0 +2728,1 @@\n+    assert_different_registers(obj, tmp, rscratch1, rscratch2, mdo_addr.base(), mdo_addr.index());\n@@ -2729,0 +2730,2 @@\n+  } else {\n+    assert_different_registers(obj, rscratch1, rscratch2, mdo_addr.base(), mdo_addr.index());\n@@ -2785,2 +2788,2 @@\n-          \/\/ There is a chance that the checks above (re-reading profiling\n-          \/\/ data from memory) fail if another thread has just set the\n+          \/\/ There is a chance that the checks above\n+          \/\/ fail if another thread has just set the\n@@ -2789,0 +2792,1 @@\n+          __ eor(tmp, tmp, rscratch2); \/\/ get back original value before XOR\n@@ -2813,0 +2817,4 @@\n+#ifdef ASSERT\n+        __ andr(tmp, tmp, TypeEntries::type_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n@@ -2844,0 +2852,4 @@\n+#ifdef ASSERT\n+        __ andr(tmp, tmp, TypeEntries::type_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1641,1 +1641,1 @@\n-  assert_different_registers(obj, rscratch1);\n+  assert_different_registers(obj, rscratch1, mdo_addr.base(), mdo_addr.index());\n@@ -1663,1 +1663,0 @@\n-  ldr(rscratch1, mdo_addr);\n@@ -1667,2 +1666,2 @@\n-  \/\/ There is a chance that the checks above (re-reading profiling\n-  \/\/ data from memory) fail if another thread has just set the\n+  \/\/ There is a chance that the checks above\n+  \/\/ fail if another thread has just set the\n@@ -1670,0 +1669,1 @@\n+  eor(obj, obj, rscratch1); \/\/ get back original value before XOR\n@@ -1682,0 +1682,4 @@\n+#ifdef ASSERT\n+  andr(obj, obj, TypeEntries::type_mask);\n+  verify_klass_ptr(obj);\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1652,2 +1652,2 @@\n-      \/\/ There is a chance that the checks above (re-reading profiling\n-      \/\/ data from memory) fail if another thread has just set the\n+      \/\/ There is a chance that the checks above\n+      \/\/ fail if another thread has just set the\n@@ -1656,0 +1656,1 @@\n+      __ xorr(tmp, tmp, t1); \/\/ get back original value before XOR\n@@ -1682,0 +1683,4 @@\n+#ifdef ASSERT\n+    __ andi(tmp, tmp, TypeEntries::type_mask);\n+    __ verify_klass_ptr(tmp);\n+#endif\n@@ -1716,0 +1721,4 @@\n+#ifdef ASSERT\n+    __ andi(tmp, tmp, TypeEntries::type_mask);\n+    __ verify_klass_ptr(tmp);\n+#endif\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1685,2 +1685,2 @@\n-  ld(t0, mdo_addr);\n-  xorr(obj, obj, t0);\n+  ld(tmp, mdo_addr);\n+  xorr(obj, obj, tmp);\n@@ -1696,6 +1696,5 @@\n-  ld(t0, mdo_addr);\n-  beqz(t0, none);\n-  mv(tmp, (u1)TypeEntries::null_seen);\n-  beq(t0, tmp, none);\n-  \/\/ There is a chance that the checks above (re-reading profiling\n-  \/\/ data from memory) fail if another thread has just set the\n+  beqz(tmp, none);\n+  mv(t0, (u1)TypeEntries::null_seen);\n+  beq(tmp, t0, none);\n+  \/\/ There is a chance that the checks above\n+  \/\/ fail if another thread has just set the\n@@ -1703,2 +1702,3 @@\n-  ld(t0, mdo_addr);\n-  xorr(obj, obj, t0);\n+  xorr(obj, obj, tmp); \/\/ get back original value before XOR\n+  ld(tmp, mdo_addr);\n+  xorr(obj, obj, tmp);\n@@ -1715,0 +1715,4 @@\n+#ifdef ASSERT\n+  andi(obj, obj, TypeEntries::type_mask);\n+  verify_klass_ptr(obj);\n+#endif\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -3635,2 +3635,13 @@\n-  if (tmp != obj) {\n-    __ mov(tmp, obj);\n+#ifdef ASSERT\n+  if (obj == tmp) {\n+#ifdef _LP64\n+    assert_different_registers(obj, rscratch1, mdo_addr.base(), mdo_addr.index());\n+#else\n+    assert_different_registers(obj, mdo_addr.base(), mdo_addr.index());\n+#endif\n+  } else {\n+#ifdef _LP64\n+    assert_different_registers(obj, tmp, rscratch1, mdo_addr.base(), mdo_addr.index());\n+#else\n+    assert_different_registers(obj, tmp, mdo_addr.base(), mdo_addr.index());\n+#endif\n@@ -3638,0 +3649,1 @@\n+#endif\n@@ -3639,1 +3651,1 @@\n-    __ testptr(tmp, tmp);\n+    __ testptr(obj, obj);\n@@ -3642,0 +3654,8 @@\n+      __ testptr(mdo_addr, TypeEntries::null_seen);\n+#ifndef ASSERT\n+      __ jccb(Assembler::notZero, next); \/\/ already set\n+#else\n+      __ jcc(Assembler::notZero, next); \/\/ already set\n+#endif\n+      \/\/ atomic update to prevent overwriting Klass* with 0\n+      __ lock();\n@@ -3652,1 +3672,1 @@\n-    __ testptr(tmp, tmp);\n+    __ testptr(obj, obj);\n@@ -3664,1 +3684,1 @@\n-      __ load_klass(tmp, tmp, tmp_load_klass);\n+      __ load_klass(tmp, obj, tmp_load_klass);\n@@ -3679,1 +3699,1 @@\n-          __ load_klass(tmp, tmp, tmp_load_klass);\n+          __ load_klass(tmp, obj, tmp_load_klass);\n@@ -3681,1 +3701,3 @@\n-\n+#ifdef _LP64\n+        __ mov(rscratch1, tmp); \/\/ save original value before XOR\n+#endif\n@@ -3692,4 +3714,3 @@\n-          __ cmpptr(mdo_addr, 0);\n-          __ jccb(Assembler::equal, none);\n-          __ cmpptr(mdo_addr, TypeEntries::null_seen);\n-          __ jccb(Assembler::equal, none);\n+          __ testptr(mdo_addr, TypeEntries::type_mask);\n+          __ jccb(Assembler::zero, none);\n+#ifdef _LP64\n@@ -3699,0 +3720,1 @@\n+          __ mov(tmp, rscratch1); \/\/ get back original value before XOR\n@@ -3702,0 +3724,1 @@\n+#endif\n@@ -3707,2 +3730,1 @@\n-        __ movptr(tmp, mdo_addr);\n-        __ testptr(tmp, TypeEntries::type_unknown);\n+        __ testptr(mdo_addr, TypeEntries::type_unknown);\n@@ -3721,0 +3743,4 @@\n+#ifdef ASSERT\n+        __ andptr(tmp, TypeEntries::type_klass_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n@@ -3735,4 +3761,2 @@\n-          __ cmpptr(mdo_addr, 0);\n-          __ jcc(Assembler::equal, ok);\n-          __ cmpptr(mdo_addr, TypeEntries::null_seen);\n-          __ jcc(Assembler::equal, ok);\n+          __ testptr(mdo_addr, TypeEntries::type_mask);\n+          __ jcc(Assembler::zero, ok);\n@@ -3754,0 +3778,4 @@\n+#ifdef ASSERT\n+        __ andptr(tmp, TypeEntries::type_klass_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n@@ -3758,2 +3786,1 @@\n-        __ movptr(tmp, mdo_addr);\n-        __ testptr(tmp, TypeEntries::type_unknown);\n+        __ testptr(mdo_addr, TypeEntries::type_unknown);\n@@ -3765,2 +3792,0 @@\n-\n-    __ bind(next);\n@@ -3768,0 +3793,1 @@\n+  __ bind(next);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":47,"deletions":21,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -55,0 +55,6 @@\n+#ifdef _LP64\n+  assert_different_registers(obj, rscratch1, mdo_addr.base(), mdo_addr.index());\n+#else\n+  assert_different_registers(obj, mdo_addr.base(), mdo_addr.index());\n+#endif\n+\n@@ -59,0 +65,4 @@\n+  testptr(mdo_addr, TypeEntries::null_seen);\n+  jccb(Assembler::notZero, next); \/\/ null already seen. Nothing to do anymore.\n+  \/\/ atomic update to prevent overwriting Klass* with 0\n+  lock();\n@@ -65,0 +75,3 @@\n+#ifdef _LP64\n+  mov(rscratch1, obj);\n+#endif\n@@ -79,0 +92,1 @@\n+#ifdef _LP64\n@@ -82,0 +96,1 @@\n+  mov(obj, rscratch1);\n@@ -85,0 +100,1 @@\n+#endif\n@@ -93,0 +109,4 @@\n+#ifdef ASSERT\n+  andptr(obj, TypeEntries::type_klass_mask);\n+  verify_klass_ptr(obj);\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -843,0 +843,1 @@\n+  void testptr(Address src, int32_t imm32) {  LP64_ONLY(testq(src, imm32)) NOT_LP64(testl(src, imm32)); }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}