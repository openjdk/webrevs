{"files":[{"patch":"@@ -120,1 +120,1 @@\n-            int keyLength, CK_ATTRIBUTE[] attributes) {\n+            int keyLength, CK_ATTRIBUTE[] attrs) {\n@@ -128,9 +128,9 @@\n-        int n = (attributes == null) ? 0 : attributes.length;\n-        for (int i = 0; i < n; i++) {\n-            CK_ATTRIBUTE attr = attributes[i];\n-            if (attr.type == CKA_TOKEN) {\n-                tokenObject = attr.getBoolean();\n-            } else if (attr.type == CKA_SENSITIVE) {\n-                sensitive = attr.getBoolean();\n-            } else if (attr.type == CKA_EXTRACTABLE) {\n-                extractable = attr.getBoolean();\n+        if (attrs != null) {\n+            for (CK_ATTRIBUTE attr : attrs) {\n+                if (attr.type == CKA_TOKEN) {\n+                    tokenObject = attr.getBoolean();\n+                } else if (attr.type == CKA_SENSITIVE) {\n+                    sensitive = attr.getBoolean();\n+                } else if (attr.type == CKA_EXTRACTABLE) {\n+                    extractable = attr.getBoolean();\n+                }\n@@ -253,1 +253,1 @@\n-                + \" key, \" + keyLength + \" bits\";\n+                + \" key, \" + keyLength + \" bits \";\n@@ -284,1 +284,2 @@\n-    void fetchAttributes(CK_ATTRIBUTE[] attributes) {\n+    CK_ATTRIBUTE[] fetchAttributes(CK_ATTRIBUTE[] attrs) {\n+        Objects.requireNonNull(attrs, \"attrs must be non-null\");\n@@ -290,1 +291,1 @@\n-                        attributes);\n+                    attrs);\n@@ -297,0 +298,11 @@\n+        return attrs;\n+    }\n+\n+    \/\/ convenience method which returns the attribute values as BigInteger[]\n+    BigInteger[] fetchAttributesAsInts(CK_ATTRIBUTE[] attrs) {\n+        attrs = fetchAttributes(attrs);\n+        BigInteger[] res = new BigInteger[attrs.length];\n+        for (int i = 0; i < attrs.length; i++) {\n+            res[i] = attrs[i].getBigInteger();\n+        }\n+        return res;\n@@ -335,5 +347,5 @@\n-            int keyLength, CK_ATTRIBUTE[] attributes) {\n-        attributes = getAttributes(session, keyID, attributes, new CK_ATTRIBUTE[] {\n-            new CK_ATTRIBUTE(CKA_TOKEN),\n-            new CK_ATTRIBUTE(CKA_SENSITIVE),\n-            new CK_ATTRIBUTE(CKA_EXTRACTABLE),\n+            int keyLength, CK_ATTRIBUTE[] attrs) {\n+        attrs = getAttributes(session, keyID, attrs, new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_TOKEN),\n+                    new CK_ATTRIBUTE(CKA_SENSITIVE),\n+                    new CK_ATTRIBUTE(CKA_EXTRACTABLE),\n@@ -341,2 +353,1 @@\n-        return new P11SecretKey(session, keyID, algorithm, keyLength,\n-                attributes);\n+        return new P11SecretKey(session, keyID, algorithm, keyLength, attrs);\n@@ -345,6 +356,7 @@\n-    static SecretKey masterSecretKey(Session session, long keyID, String algorithm,\n-            int keyLength, CK_ATTRIBUTE[] attributes, int major, int minor) {\n-        attributes = getAttributes(session, keyID, attributes, new CK_ATTRIBUTE[] {\n-            new CK_ATTRIBUTE(CKA_TOKEN),\n-            new CK_ATTRIBUTE(CKA_SENSITIVE),\n-            new CK_ATTRIBUTE(CKA_EXTRACTABLE),\n+    static SecretKey masterSecretKey(Session session, long keyID,\n+            String algorithm, int keyLength, CK_ATTRIBUTE[] attrs,\n+            int major, int minor) {\n+        attrs = getAttributes(session, keyID, attrs, new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_TOKEN),\n+                    new CK_ATTRIBUTE(CKA_SENSITIVE),\n+                    new CK_ATTRIBUTE(CKA_EXTRACTABLE),\n@@ -352,3 +364,2 @@\n-        return new P11TlsMasterSecretKey(\n-                session, keyID, algorithm, keyLength, attributes, major,\n-                minor);\n+        return new P11TlsMasterSecretKey(session, keyID, algorithm, keyLength,\n+                attrs, major, minor);\n@@ -359,1 +370,1 @@\n-            int keyLength, CK_ATTRIBUTE[] attributes) {\n+            int keyLength, CK_ATTRIBUTE[] attrs) {\n@@ -363,1 +374,1 @@\n-                        keyLength, attributes);\n+                        keyLength, attrs);\n@@ -366,1 +377,1 @@\n-                        keyLength, attributes);\n+                        keyLength, attrs);\n@@ -369,1 +380,1 @@\n-                        keyLength, attributes);\n+                        keyLength, attrs);\n@@ -372,1 +383,1 @@\n-                        keyLength, attributes);\n+                        keyLength, attrs);\n@@ -380,5 +391,5 @@\n-            int keyLength, CK_ATTRIBUTE[] attributes) {\n-        attributes = getAttributes(session, keyID, attributes, new CK_ATTRIBUTE[] {\n-            new CK_ATTRIBUTE(CKA_TOKEN),\n-            new CK_ATTRIBUTE(CKA_SENSITIVE),\n-            new CK_ATTRIBUTE(CKA_EXTRACTABLE),\n+            int keyLength, CK_ATTRIBUTE[] attrs) {\n+        attrs = getAttributes(session, keyID, attrs, new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_TOKEN),\n+                    new CK_ATTRIBUTE(CKA_SENSITIVE),\n+                    new CK_ATTRIBUTE(CKA_EXTRACTABLE),\n@@ -386,50 +397,20 @@\n-        if (attributes[1].getBoolean() || (attributes[2].getBoolean() == false)) {\n-            return new P11PrivateKey\n-                (session, keyID, algorithm, keyLength, attributes);\n-        } else {\n-            switch (algorithm) {\n-                case \"RSA\":\n-                    \/\/ In order to decide if this is RSA CRT key, we first query\n-                    \/\/ and see if all extra CRT attributes are available.\n-                    CK_ATTRIBUTE[] attrs2 = new CK_ATTRIBUTE[] {\n-                        new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n-                        new CK_ATTRIBUTE(CKA_PRIME_1),\n-                        new CK_ATTRIBUTE(CKA_PRIME_2),\n-                        new CK_ATTRIBUTE(CKA_EXPONENT_1),\n-                        new CK_ATTRIBUTE(CKA_EXPONENT_2),\n-                        new CK_ATTRIBUTE(CKA_COEFFICIENT),\n-                    };\n-                    boolean crtKey;\n-                    try {\n-                        session.token.p11.C_GetAttributeValue\n-                            (session.id(), keyID, attrs2);\n-                        crtKey = ((attrs2[0].pValue instanceof byte[]) &&\n-                                  (attrs2[1].pValue instanceof byte[]) &&\n-                                  (attrs2[2].pValue instanceof byte[]) &&\n-                                  (attrs2[3].pValue instanceof byte[]) &&\n-                                  (attrs2[4].pValue instanceof byte[]) &&\n-                                  (attrs2[5].pValue instanceof byte[])) ;\n-                    } catch (PKCS11Exception e) {\n-                        \/\/ ignore, assume not available\n-                        crtKey = false;\n-                    }\n-                    if (crtKey) {\n-                        return new P11RSAPrivateKey(session, keyID, algorithm,\n-                                keyLength, attributes, attrs2);\n-                    } else {\n-                        return new P11RSAPrivateNonCRTKey(session, keyID,\n-                                algorithm, keyLength, attributes);\n-                    }\n-                case \"DSA\":\n-                    return new P11DSAPrivateKey(session, keyID, algorithm,\n-                            keyLength, attributes);\n-                case \"DH\":\n-                    return new P11DHPrivateKey(session, keyID, algorithm,\n-                            keyLength, attributes);\n-                case \"EC\":\n-                    return new P11ECPrivateKey(session, keyID, algorithm,\n-                            keyLength, attributes);\n-                default:\n-                    throw new ProviderException\n-                            (\"Unknown private key algorithm \" + algorithm);\n-            }\n+\n+        boolean keySensitive = (attrs[0].getBoolean() ||\n+                attrs[1].getBoolean() || !attrs[2].getBoolean());\n+\n+        switch (algorithm) {\n+        case \"RSA\":\n+            return P11RSAPrivateKeyInternal.of(session, keyID, algorithm,\n+                    keyLength, attrs, keySensitive);\n+        case \"DSA\":\n+            return P11DSAPrivateKeyInternal.of(session, keyID, algorithm,\n+                    keyLength, attrs, keySensitive);\n+        case \"DH\":\n+            return P11DHPrivateKeyInternal.of(session, keyID, algorithm,\n+                    keyLength, attrs, keySensitive);\n+        case \"EC\":\n+            return P11ECPrivateKeyInternal.of(session, keyID, algorithm,\n+                    keyLength, attrs, keySensitive);\n+        default:\n+            throw new ProviderException\n+                    (\"Unknown private key algorithm \" + algorithm);\n@@ -439,3 +420,3 @@\n-    \/\/ class for sensitive and unextractable private keys\n-    private static final class P11PrivateKey extends P11Key\n-                                                implements PrivateKey {\n+    \/\/ base class for all PKCS11 private keys\n+    private static abstract class P11PrivateKey extends P11Key implements\n+            PrivateKey {\n@@ -444,0 +425,2 @@\n+        protected byte[] encoded; \/\/ guard by synchronized\n+\n@@ -445,2 +428,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attributes);\n+                int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(PRIVATE, session, keyID, algorithm, keyLength, attrs);\n@@ -461,1 +444,3 @@\n-        private volatile byte[] encoded;\n+\n+        private volatile byte[] encoded; \/\/ guard by double-checked locking\n+\n@@ -463,2 +448,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(SECRET, session, keyID, algorithm, keyLength, attributes);\n+                int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(SECRET, session, keyID, algorithm, keyLength, attrs);\n@@ -466,0 +451,1 @@\n+\n@@ -474,0 +460,1 @@\n+\n@@ -479,0 +466,1 @@\n+\n@@ -484,5 +472,1 @@\n-                        Session tempSession = null;\n-                        long keyID = this.getKeyID();\n-                        try {\n-                            tempSession = token.getOpSession();\n-                            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n+                        b = fetchAttributes(new CK_ATTRIBUTE[] {\n@@ -490,10 +474,1 @@\n-                            };\n-                            token.p11.C_GetAttributeValue\n-                                    (tempSession.id(), keyID, attributes);\n-                            b = attributes[0].getByteArray();\n-                        } catch (PKCS11Exception e) {\n-                            throw new ProviderException(e);\n-                        } finally {\n-                            this.releaseKeyID();\n-                            token.releaseSession(tempSession);\n-                        }\n+                        })[0].getByteArray();\n@@ -508,0 +483,13 @@\n+    \/\/ base class for all PKCS11 public keys\n+    private static abstract class P11PublicKey extends P11Key implements\n+            PublicKey {\n+        private static final long serialVersionUID = 1L;\n+\n+        protected byte[] encoded; \/\/ guard by synchronized\n+\n+        P11PublicKey(Session session, long keyID, String algorithm,\n+                int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(PUBLIC, session, keyID, algorithm, keyLength, attrs);\n+        }\n+    }\n+\n@@ -515,2 +503,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes, int major, int minor) {\n-            super(session, keyID, algorithm, keyLength, attributes);\n+                int keyLength, CK_ATTRIBUTE[] attrs, int major, int minor) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n@@ -529,0 +517,72 @@\n+    \/\/ impl class for sensitive\/unextractable RSA private keys\n+    static class P11RSAPrivateKeyInternal extends P11PrivateKey {\n+        private static final long serialVersionUID = -2138581185214187615L;\n+\n+        static P11RSAPrivateKeyInternal of(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attrs,\n+                boolean keySensitive) {\n+            if (keySensitive) {\n+                return new P11RSAPrivateKeyInternal(session, keyID, algorithm,\n+                        keyLength, attrs);\n+            } else {\n+                CK_ATTRIBUTE[] rsaAttrs = new CK_ATTRIBUTE[] {\n+                        new CK_ATTRIBUTE(CKA_MODULUS),\n+                        new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n+                        new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n+                        new CK_ATTRIBUTE(CKA_PRIME_1),\n+                        new CK_ATTRIBUTE(CKA_PRIME_2),\n+                        new CK_ATTRIBUTE(CKA_EXPONENT_1),\n+                        new CK_ATTRIBUTE(CKA_EXPONENT_2),\n+                        new CK_ATTRIBUTE(CKA_COEFFICIENT),\n+                };\n+                boolean isCRT = true;\n+                Session tempSession = null;\n+                try {\n+                    tempSession = session.token.getOpSession();\n+                    session.token.p11.C_GetAttributeValue(tempSession.id(),\n+                            keyID, rsaAttrs);\n+                    for (CK_ATTRIBUTE attr : rsaAttrs) {\n+                        isCRT &= (attr.pValue instanceof byte[]);\n+                        if (!isCRT) break;\n+                    }\n+                } catch (PKCS11Exception e) {\n+                    \/\/ ignore, assume not available\n+                    isCRT = false;\n+                } finally {\n+                    session.token.releaseSession(tempSession);\n+                }\n+                BigInteger n = rsaAttrs[0].getBigInteger();\n+                BigInteger d = rsaAttrs[1].getBigInteger();\n+                if (isCRT) {\n+                    return new P11RSAPrivateKey(session, keyID, algorithm,\n+                           keyLength, attrs, n, d,\n+                           Arrays.copyOfRange(rsaAttrs, 2, rsaAttrs.length));\n+                } else {\n+                    return new P11RSAPrivateNonCRTKey(session, keyID,\n+                           algorithm, keyLength, attrs, n, d);\n+                }\n+            }\n+        }\n+\n+        protected transient BigInteger n;\n+\n+        private P11RSAPrivateKeyInternal(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n+        }\n+\n+        private synchronized void fetchValues() {\n+            token.ensureValid();\n+            if (n != null) return;\n+\n+            n = fetchAttributesAsInts(new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_MODULUS)\n+            })[0];\n+        }\n+\n+        public BigInteger getModulus() {\n+            fetchValues();\n+            return n;\n+        }\n+    }\n+\n@@ -530,2 +590,2 @@\n-    private static final class P11RSAPrivateKey extends P11Key\n-                implements RSAPrivateCrtKey {\n+    private static final class P11RSAPrivateKey extends P11RSAPrivateKeyInternal\n+            implements RSAPrivateCrtKey {\n@@ -534,5 +594,6 @@\n-        private BigInteger n, e, d, p, q, pe, qe, coeff;\n-        private byte[] encoded;\n-        P11RSAPrivateKey(Session session, long keyID, String algorithm,\n-                int keyLength, CK_ATTRIBUTE[] attrs, CK_ATTRIBUTE[] crtAttrs) {\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attrs);\n+        private transient BigInteger e, d, p, q, pe, qe, coeff;\n+\n+        private P11RSAPrivateKey(Session session, long keyID, String algorithm,\n+                int keyLength, CK_ATTRIBUTE[] attrs, BigInteger n, BigInteger d,\n+                CK_ATTRIBUTE[] crtAttrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n@@ -540,0 +601,2 @@\n+            this.n = n;\n+            this.d = d;\n@@ -556,13 +619,0 @@\n-        private synchronized void fetchValues() {\n-            token.ensureValid();\n-            if (n != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_MODULUS),\n-                new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n-            };\n-            fetchAttributes(attributes);\n-            n = attributes[0].getBigInteger();\n-            d = attributes[1].getBigInteger();\n-        }\n@@ -574,0 +624,1 @@\n+\n@@ -577,1 +628,0 @@\n-                fetchValues();\n@@ -588,0 +638,2 @@\n+\n+        @Override\n@@ -589,1 +641,0 @@\n-            fetchValues();\n@@ -596,1 +647,0 @@\n-            fetchValues();\n@@ -617,2 +667,2 @@\n-    private static final class P11RSAPrivateNonCRTKey extends P11Key\n-                implements RSAPrivateKey {\n+    private static final class P11RSAPrivateNonCRTKey extends\n+            P11RSAPrivateKeyInternal implements RSAPrivateKey {\n@@ -621,2 +671,2 @@\n-        private BigInteger n, d;\n-        private byte[] encoded;\n+        private transient BigInteger d;\n+\n@@ -624,15 +674,5 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attributes);\n-        }\n-        private synchronized void fetchValues() {\n-            token.ensureValid();\n-            if (n != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_MODULUS),\n-                new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n-            };\n-            fetchAttributes(attributes);\n-            n = attributes[0].getBigInteger();\n-            d = attributes[1].getBigInteger();\n+                int keyLength, CK_ATTRIBUTE[] attrs, BigInteger n,\n+                BigInteger d) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n+            this.n = n;\n+            this.d = d;\n@@ -640,0 +680,1 @@\n+\n@@ -644,0 +685,1 @@\n+\n@@ -647,1 +689,0 @@\n-                fetchValues();\n@@ -661,0 +702,2 @@\n+\n+        @Override\n@@ -662,1 +705,0 @@\n-            fetchValues();\n@@ -666,1 +708,0 @@\n-            fetchValues();\n@@ -671,1 +712,1 @@\n-    private static final class P11RSAPublicKey extends P11Key\n+    private static final class P11RSAPublicKey extends P11PublicKey\n@@ -674,2 +715,2 @@\n-        private BigInteger n, e;\n-        private byte[] encoded;\n+        private transient BigInteger n, e;\n+\n@@ -677,2 +718,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PUBLIC, session, keyID, algorithm, keyLength, attributes);\n+                int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n@@ -680,0 +721,1 @@\n+\n@@ -682,4 +724,3 @@\n-            if (n != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n+            if (n != null) return;\n+\n+            BigInteger[] res = fetchAttributesAsInts(new CK_ATTRIBUTE[] {\n@@ -687,5 +728,4 @@\n-                new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n-            };\n-            fetchAttributes(attributes);\n-            n = attributes[0].getBigInteger();\n-            e = attributes[1].getBigInteger();\n+                new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT)\n+            });\n+            n = res[0];\n+            e = res[1];\n@@ -693,0 +733,1 @@\n+\n@@ -697,0 +738,1 @@\n+\n@@ -710,0 +752,1 @@\n+\n@@ -725,1 +768,1 @@\n-    private static final class P11DSAPublicKey extends P11Key\n+    private static final class P11DSAPublicKey extends P11PublicKey\n@@ -729,3 +772,3 @@\n-        private BigInteger y;\n-        private DSAParams params;\n-        private byte[] encoded;\n+        private transient BigInteger y;\n+        private transient DSAParams params;\n+\n@@ -733,2 +776,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PUBLIC, session, keyID, algorithm, keyLength, attributes);\n+                int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n@@ -736,0 +779,1 @@\n+\n@@ -738,4 +782,3 @@\n-            if (y != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n+            if (y != null) return;\n+\n+            BigInteger[] res = fetchAttributesAsInts(new CK_ATTRIBUTE[] {\n@@ -745,9 +788,4 @@\n-                new CK_ATTRIBUTE(CKA_BASE),\n-            };\n-            fetchAttributes(attributes);\n-            y = attributes[0].getBigInteger();\n-            params = new DSAParameterSpec(\n-                attributes[1].getBigInteger(),\n-                attributes[2].getBigInteger(),\n-                attributes[3].getBigInteger()\n-            );\n+                new CK_ATTRIBUTE(CKA_BASE)\n+            });\n+            y = res[0];\n+            params = new DSAParameterSpec(res[1], res[2], res[3]);\n@@ -755,0 +793,1 @@\n+\n@@ -759,0 +798,1 @@\n+\n@@ -788,2 +828,1 @@\n-    private static final class P11DSAPrivateKey extends P11Key\n-                                                implements DSAPrivateKey {\n+    static class P11DSAPrivateKeyInternal extends P11PrivateKey {\n@@ -792,3 +831,43 @@\n-        private BigInteger x;\n-        private DSAParams params;\n-        private byte[] encoded;\n+        protected transient DSAParams params;\n+\n+        static P11DSAPrivateKeyInternal of(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attrs,\n+                boolean keySensitive) {\n+            if (keySensitive) {\n+                return new P11DSAPrivateKeyInternal(session, keyID, algorithm,\n+                        keyLength, attrs);\n+            } else {\n+                return new P11DSAPrivateKey(session, keyID, algorithm,\n+                        keyLength, attrs);\n+            }\n+        }\n+\n+        private P11DSAPrivateKeyInternal(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n+        }\n+\n+        private synchronized void fetchValues() {\n+            token.ensureValid();\n+            if (params != null) return;\n+\n+            BigInteger[] res = fetchAttributesAsInts(new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_PRIME),\n+                    new CK_ATTRIBUTE(CKA_SUBPRIME),\n+                    new CK_ATTRIBUTE(CKA_BASE),\n+            });\n+            params = new DSAParameterSpec(res[0], res[1], res[2]);\n+        }\n+\n+        protected DSAParams getParams() {\n+            fetchValues();\n+            return params;\n+        }\n+    }\n+\n+    private static final class P11DSAPrivateKey extends P11DSAPrivateKeyInternal\n+                                        implements DSAPrivateKey {\n+        private static final long serialVersionUID = 3119629997181999389L;\n+\n+        private transient BigInteger x; \/\/ params inside P11DSAPrivateKeyInternal\n+\n@@ -796,2 +875,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attributes);\n+                int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n@@ -799,0 +878,1 @@\n+\n@@ -801,16 +881,10 @@\n-            if (x != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_VALUE),\n-                new CK_ATTRIBUTE(CKA_PRIME),\n-                new CK_ATTRIBUTE(CKA_SUBPRIME),\n-                new CK_ATTRIBUTE(CKA_BASE),\n-            };\n-            fetchAttributes(attributes);\n-            x = attributes[0].getBigInteger();\n-            params = new DSAParameterSpec(\n-                attributes[1].getBigInteger(),\n-                attributes[2].getBigInteger(),\n-                attributes[3].getBigInteger()\n-            );\n+            if (x != null) return;\n+\n+            BigInteger[] res = fetchAttributesAsInts(new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_VALUE),\n+                    new CK_ATTRIBUTE(CKA_PRIME),\n+                    new CK_ATTRIBUTE(CKA_SUBPRIME),\n+                    new CK_ATTRIBUTE(CKA_BASE),\n+            });\n+            x = res[0];\n+            params = new DSAParameterSpec(res[1], res[2], res[3]);\n@@ -818,0 +892,1 @@\n+\n@@ -822,0 +897,1 @@\n+\n@@ -832,0 +908,1 @@\n+\n@@ -836,0 +913,2 @@\n+\n+        @Override\n@@ -842,1 +921,40 @@\n-    private static final class P11DHPrivateKey extends P11Key\n+    static class P11DHPrivateKeyInternal extends P11PrivateKey {\n+        private static final long serialVersionUID = 1L;\n+\n+        protected transient DHParameterSpec params;\n+\n+        static P11DHPrivateKeyInternal of(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attrs,\n+                boolean keySensitive) {\n+            if (keySensitive) {\n+                return new P11DHPrivateKeyInternal(session, keyID, algorithm,\n+                        keyLength, attrs);\n+            } else {\n+                return new P11DHPrivateKey(session, keyID, algorithm,\n+                        keyLength, attrs);\n+            }\n+        }\n+\n+        private P11DHPrivateKeyInternal(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n+        }\n+\n+        private synchronized void fetchValues() {\n+            token.ensureValid();\n+            if (params != null) return;\n+\n+            BigInteger[] res = fetchAttributesAsInts(new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_PRIME),\n+                    new CK_ATTRIBUTE(CKA_BASE),\n+            });\n+            params = new DHParameterSpec(res[0], res[1]);\n+        }\n+\n+        public DHParameterSpec getParams() {\n+            fetchValues();\n+            return params;\n+        }\n+    }\n+\n+    private static final class P11DHPrivateKey extends P11DHPrivateKeyInternal\n@@ -846,3 +964,2 @@\n-        private BigInteger x;\n-        private DHParameterSpec params;\n-        private byte[] encoded;\n+        private transient BigInteger x; \/\/ params in P11DHPrivateKeyInternal\n+\n@@ -850,2 +967,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attributes);\n+                int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n@@ -853,0 +970,1 @@\n+\n@@ -855,14 +973,9 @@\n-            if (x != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_VALUE),\n-                new CK_ATTRIBUTE(CKA_PRIME),\n-                new CK_ATTRIBUTE(CKA_BASE),\n-            };\n-            fetchAttributes(attributes);\n-            x = attributes[0].getBigInteger();\n-            params = new DHParameterSpec(\n-                attributes[1].getBigInteger(),\n-                attributes[2].getBigInteger()\n-            );\n+            if (x != null) return;\n+\n+            BigInteger[] res = fetchAttributesAsInts(new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_VALUE),\n+                    new CK_ATTRIBUTE(CKA_PRIME),\n+                    new CK_ATTRIBUTE(CKA_BASE),\n+            });\n+            x = res[0];\n+            params = new DHParameterSpec(res[1], res[2]);\n@@ -870,0 +983,1 @@\n+\n@@ -874,0 +988,1 @@\n+\n@@ -900,0 +1015,1 @@\n+            fetchValues();\n@@ -903,1 +1019,0 @@\n-            fetchValues();\n@@ -924,1 +1039,1 @@\n-    private static final class P11DHPublicKey extends P11Key\n+    private static final class P11DHPublicKey extends P11PublicKey\n@@ -928,3 +1043,3 @@\n-        private BigInteger y;\n-        private DHParameterSpec params;\n-        private byte[] encoded;\n+        private transient BigInteger y;\n+        private transient DHParameterSpec params;\n+\n@@ -932,2 +1047,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PUBLIC, session, keyID, algorithm, keyLength, attributes);\n+                int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n@@ -935,0 +1050,1 @@\n+\n@@ -937,14 +1053,9 @@\n-            if (y != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_VALUE),\n-                new CK_ATTRIBUTE(CKA_PRIME),\n-                new CK_ATTRIBUTE(CKA_BASE),\n-            };\n-            fetchAttributes(attributes);\n-            y = attributes[0].getBigInteger();\n-            params = new DHParameterSpec(\n-                attributes[1].getBigInteger(),\n-                attributes[2].getBigInteger()\n-            );\n+            if (y != null) return;\n+\n+            BigInteger[] res = fetchAttributesAsInts(new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_VALUE),\n+                    new CK_ATTRIBUTE(CKA_PRIME),\n+                    new CK_ATTRIBUTE(CKA_BASE),\n+            });\n+            y = res[0];\n+            params = new DHParameterSpec(res[1], res[2]);\n@@ -952,0 +1063,1 @@\n+\n@@ -956,0 +1068,1 @@\n+\n@@ -1011,1 +1124,45 @@\n-    private static final class P11ECPrivateKey extends P11Key\n+    static class P11ECPrivateKeyInternal extends P11PrivateKey {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        protected transient ECParameterSpec params;\n+\n+        static P11ECPrivateKeyInternal of(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attrs,\n+                boolean keySensitive) {\n+            if (keySensitive) {\n+                return new P11ECPrivateKeyInternal(session, keyID, algorithm,\n+                        keyLength, attrs);\n+            } else {\n+                return new P11ECPrivateKey(session, keyID, algorithm,\n+                        keyLength, attrs);\n+            }\n+        }\n+\n+        private P11ECPrivateKeyInternal(Session session, long keyID,\n+                String algorithm, int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n+        }\n+\n+        private synchronized void fetchValues() {\n+            token.ensureValid();\n+            if (params != null) return;\n+\n+            try {\n+                byte[] paramBytes = fetchAttributes(new CK_ATTRIBUTE[] {\n+                        new CK_ATTRIBUTE(CKA_EC_PARAMS)\n+                })[0].getByteArray();\n+\n+                params = P11ECKeyFactory.decodeParameters(paramBytes);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Could not parse key values\", e);\n+            }\n+        }\n+\n+        protected ECParameterSpec getParams() {\n+            fetchValues();\n+            return params;\n+        }\n+    }\n+\n+    private static final class P11ECPrivateKey extends P11ECPrivateKeyInternal\n@@ -1015,3 +1172,2 @@\n-        private BigInteger s;\n-        private ECParameterSpec params;\n-        private byte[] encoded;\n+        private transient BigInteger s; \/\/ params in P11ECPrivateKeyInternal\n+\n@@ -1019,2 +1175,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PRIVATE, session, keyID, algorithm, keyLength, attributes);\n+                int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n@@ -1022,0 +1178,1 @@\n+\n@@ -1024,4 +1181,3 @@\n-            if (s != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n+            if (s != null) return;\n+\n+            CK_ATTRIBUTE[] attrs = fetchAttributes(new CK_ATTRIBUTE[] {\n@@ -1029,4 +1185,4 @@\n-                new CK_ATTRIBUTE(CKA_EC_PARAMS, params),\n-            };\n-            fetchAttributes(attributes);\n-            s = attributes[0].getBigInteger();\n+                new CK_ATTRIBUTE(CKA_EC_PARAMS),\n+            });\n+\n+            s = attrs[0].getBigInteger();\n@@ -1035,1 +1191,1 @@\n-                            (attributes[1].getByteArray());\n+                            (attrs[1].getByteArray());\n@@ -1040,0 +1196,1 @@\n+\n@@ -1044,0 +1201,1 @@\n+\n@@ -1045,1 +1203,0 @@\n-            token.ensureValid();\n@@ -1047,1 +1204,0 @@\n-                fetchValues();\n@@ -1049,0 +1205,1 @@\n+                    fetchValues();\n@@ -1057,0 +1214,1 @@\n+\n@@ -1061,0 +1219,1 @@\n+\n@@ -1067,1 +1226,1 @@\n-    private static final class P11ECPublicKey extends P11Key\n+    private static final class P11ECPublicKey extends P11PublicKey\n@@ -1071,3 +1230,3 @@\n-        private ECPoint w;\n-        private ECParameterSpec params;\n-        private byte[] encoded;\n+        private transient ECPoint w;\n+        private transient ECParameterSpec params;\n+\n@@ -1075,2 +1234,2 @@\n-                int keyLength, CK_ATTRIBUTE[] attributes) {\n-            super(PUBLIC, session, keyID, algorithm, keyLength, attributes);\n+                int keyLength, CK_ATTRIBUTE[] attrs) {\n+            super(session, keyID, algorithm, keyLength, attrs);\n@@ -1078,0 +1237,1 @@\n+\n@@ -1080,4 +1240,3 @@\n-            if (w != null) {\n-                return;\n-            }\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n+            if (w != null) return;\n+\n+            CK_ATTRIBUTE[] attrs = fetchAttributes(new CK_ATTRIBUTE[] {\n@@ -1086,2 +1245,1 @@\n-            };\n-            fetchAttributes(attributes);\n+            });\n@@ -1091,2 +1249,2 @@\n-                            (attributes[1].getByteArray());\n-                byte[] ecKey = attributes[0].getByteArray();\n+                            (attrs[1].getByteArray());\n+                byte[] ecKey = attrs[0].getByteArray();\n@@ -1114,0 +1272,1 @@\n+\n@@ -1118,0 +1277,1 @@\n+\n@@ -1416,0 +1576,1 @@\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":448,"deletions":287,"binary":false,"changes":735,"status":"modified"},{"patch":"@@ -122,0 +122,3 @@\n+    \/\/ signature length expected or 0 for unknown\n+    private int sigLen;\n+\n@@ -288,1 +291,1 @@\n-                    token.p11.C_SignFinal(session.id(), 0);\n+                    token.p11.C_SignFinal(session.id(), sigLen);\n@@ -299,6 +302,1 @@\n-                byte[] signature;\n-                if (mechanism == CKM_DSA) {\n-                    signature = new byte[64]; \/\/ assume N = 256\n-                } else {\n-                    signature = new byte[(p11Key.length() + 7) >> 3];\n-                }\n+                byte[] signature = new byte[sigLen];\n@@ -376,0 +374,9 @@\n+        sigLen = 0;\n+        if (\"DSA\".equals(p11Key.getAlgorithm())) {\n+            if (p11Key instanceof P11Key.P11DSAPrivateKeyInternal) {\n+                sigLen = ((P11Key.P11DSAPrivateKeyInternal)p11Key).getParams()\n+                        .getQ().bitLength() >> 2;\n+            } else if (p11Key instanceof DSAKey) {\n+                sigLen = ((DSAKey)p11Key).getParams().getQ().bitLength() >> 2;\n+            }\n+        }\n@@ -621,1 +628,1 @@\n-                signature = token.p11.C_SignFinal(session.id(), 0);\n+                signature = token.p11.C_SignFinal(session.id(), sigLen);\n@@ -688,1 +695,1 @@\n-                    signature = asn1ToDSA(signature);\n+                    signature = asn1ToDSA(signature, sigLen);\n@@ -812,1 +819,2 @@\n-    private static byte[] asn1ToDSA(byte[] sig) throws SignatureException {\n+    private static byte[] asn1ToDSA(byte[] sig, int sigLen)\n+            throws SignatureException {\n@@ -827,2 +835,2 @@\n-            byte[] br = toByteArray(r, 20);\n-            byte[] bs = toByteArray(s, 20);\n+            byte[] br = toByteArray(r, sigLen\/2);\n+            byte[] bs = toByteArray(s, sigLen\/2);\n@@ -840,1 +848,1 @@\n-    private byte[] asn1ToECDSA(byte[] sig) throws SignatureException {\n+    private static byte[] asn1ToECDSA(byte[] sig) throws SignatureException {\n@@ -920,0 +928,1 @@\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"}]}