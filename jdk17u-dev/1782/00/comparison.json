{"files":[{"patch":"@@ -0,0 +1,287 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8274211\n+ * @summary Test man page that options are documented\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool:+open\n+ * @run main CheckManPageOptions\n+ *\/\n+\n+import jdk.javadoc.doclet.Doclet;\n+import jdk.javadoc.doclet.StandardDoclet;\n+import jdk.javadoc.internal.tool.ToolOptions;\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.TreeSet;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Checks the set of options found by fuzzy-parsing the troff or Markdown versions\n+ * of the javadoc man page against the set of options declared in the source code.\n+ *\/\n+public class CheckManPageOptions {\n+    public static void main(String... args) throws Exception {\n+        new CheckManPageOptions().run(args);\n+    }\n+\n+    static final PrintStream out = System.err;\n+\n+    \/\/ FIXME: JDK-8274295, JDK-8266666\n+    List<String> MISSING_IN_MAN_PAGE = List.of(\n+            \"--legal-notices\",\n+            \"--link-platform-properties\",\n+            \"--no-platform-links\",\n+            \"--since\",\n+            \"--since-label\",\n+            \"--snippet-path\");\n+\n+    void run(String... args) throws Exception {\n+        var file = args.length == 0 ? findDefaultFile() : Path.of(args[0]);\n+        out.println(\"File: \" + file);\n+        out.println();\n+\n+        var manPageOptions = getManPageOptions(file);\n+        out.println(\"Man page options: \" + manPageOptions);\n+        out.println();\n+\n+        var toolOptions = getToolOptions();\n+        out.println(\"ToolOptions: \" + toolOptions);\n+        out.println();\n+\n+        var docletOptions = getDocletOptions();\n+        out.println(\"DocletOptions: \" + docletOptions);\n+        out.println();\n+\n+        var toolDocletOnly = new TreeSet<String>();\n+        toolDocletOnly.addAll(toolOptions);\n+        toolDocletOnly.addAll(docletOptions);\n+        toolDocletOnly.removeAll(manPageOptions);\n+        toolDocletOnly.removeAll(MISSING_IN_MAN_PAGE);\n+        if (!toolDocletOnly.isEmpty()) {\n+            error(\"The following options are defined by the tool or doclet, but not defined in the man page:\\n\"\n+                    + toSimpleList(toolDocletOnly));\n+        }\n+\n+        var manPageOnly = new TreeSet<String>();\n+        manPageOnly.addAll(manPageOptions);\n+        manPageOnly.removeAll(toolOptions);\n+        manPageOnly.removeAll(docletOptions);\n+        if (!manPageOnly.isEmpty()) {\n+            error(\"The following options are defined in the man page, but not defined by the tool or doclet:\\n\"\n+                    + toSimpleList(manPageOnly));\n+        }\n+\n+        if (!MISSING_IN_MAN_PAGE.isEmpty()) {\n+            var notMissing = new TreeSet<>(MISSING_IN_MAN_PAGE);\n+            notMissing.retainAll(manPageOptions);\n+            if (!notMissing.isEmpty()) {\n+                error(\"The following options were declared as missing, but were found on the man page:\\n\"\n+                        + toSimpleList(notMissing));\n+            }\n+\n+            out.println(\"NOTE: the following options are currently excluded and need to be documented in the man page:\");\n+            out.println(toSimpleList(MISSING_IN_MAN_PAGE));\n+        }\n+\n+        if (errors > 0) {\n+            out.println(errors + \" errors found\");\n+            throw new Exception(errors + \" errors found\");\n+        }\n+    }\n+\n+    int errors = 0;\n+    void error(String message) {\n+        (\"Error: \" + message).lines().forEach(out::println);\n+        errors++;\n+    }\n+\n+    String toSimpleList(Collection<String> items) {\n+        return items.stream().collect(Collectors.joining(\", \", \"    \", \"\"));\n+    }\n+\n+    Path findDefaultFile() {\n+        return findRootDir().resolve(\"src\/jdk.javadoc\/share\/man\/javadoc.1\");\n+    }\n+\n+    Path findRootDir() {\n+        Path dir = Path.of(System.getProperty(\"test.src\", \".\")).toAbsolutePath();\n+        while (dir != null) {\n+            if (Files.exists(dir.resolve(\"src\"))) {\n+                return dir;\n+            } else {\n+                Path openDir = dir.resolve(\"open\");\n+                if (Files.exists(openDir.resolve(\"src\"))) {\n+                    return openDir;\n+                }\n+            }\n+            dir = dir.getParent();\n+        }\n+        throw new IllegalStateException(\"cannot find root dir\");\n+    }\n+\n+    List<String> getToolOptions() throws Error {\n+        try {\n+            Class<ToolOptions> toolOptionsClass = ToolOptions.class;\n+\n+            Constructor<ToolOptions> constr = toolOptionsClass.getDeclaredConstructor();\n+            constr.setAccessible(true);\n+\n+            Method getSupportedOptions = toolOptionsClass.getMethod(\"getSupportedOptions\");\n+            Class<?> toolOptionClass = List.of(toolOptionsClass.getDeclaredClasses()).stream()\n+                    .filter(c -> c.getSimpleName().equals(\"ToolOption\"))\n+                    .findFirst()\n+                    .orElseThrow();\n+\n+            Field kindField = toolOptionClass.getDeclaredField(\"kind\");\n+            kindField.setAccessible(true);\n+            Method getNames = toolOptionClass.getDeclaredMethod(\"getNames\");\n+            getNames.setAccessible(true);\n+\n+            ToolOptions t = constr.newInstance();\n+            var list = new ArrayList<String>();\n+            var options = (List<?>) getSupportedOptions.invoke(t);\n+            for (var option : options) {\n+                Object kind = kindField.get(option);\n+                if (kind.toString().equals(\"HIDDEN\")) {\n+                    continue;\n+                }\n+\n+                @SuppressWarnings(\"unchecked\")\n+                var oNames = (List<String>) getNames.invoke(option);\n+                oNames.stream()\n+                        .filter(o -> !o.equals(\"@\"))\n+                        .forEach(list::add);\n+            }\n+            return list;\n+        } catch (ReflectiveOperationException e) {\n+            throw new Error(e);\n+        }\n+    }\n+\n+    List<String> getDocletOptions() {\n+        StandardDoclet d = new StandardDoclet();\n+        d.init(Locale.getDefault(), null);\n+        return getDocletOptions(d);\n+    }\n+\n+    List<String> getDocletOptions(Doclet d) {\n+        return d.getSupportedOptions().stream()\n+                .filter(o -> o.getKind() != Doclet.Option.Kind.OTHER)\n+                .flatMap(o -> o.getNames().stream())\n+                .map(n -> n.replaceAll(\":$\", \"\"))\n+                .toList();\n+    }\n+\n+    List<String> getManPageOptions(Path file) throws IOException {\n+        String page = Files.readString(file);\n+        String name = file.getFileName().toString();\n+        String extn = name.substring(name.lastIndexOf('.'));\n+        return switch (extn) {\n+            case \".1\" -> parseNRoff(page);\n+            case \".md\" -> parseMarkdown(page);\n+            default -> throw new IllegalArgumentException(file.toString());\n+        };\n+    }\n+\n+    List<String> parseNRoff(String page) {\n+        var list = new ArrayList<String>();\n+\n+        \/\/ In the troff man page, options are defined in one of two forms:\n+        \/\/ 1. options delegated to javac appear in pairs of lines of the form\n+        \/\/      .IP \\[bu] 2\n+        \/\/      \\f[CB]\\-....\n+        \/\/ 2. options implemented by the tool or doclet appear in lines of the form\n+        \/\/      .B \\f[CB]\\-...\n+\n+        Pattern p1 = Pattern.compile(\"\\\\R\" + Pattern.quote(\".IP \\\\[bu] 2\") + \"\\\\R\" + Pattern.quote(\"\\\\f[CB]\\\\-\") + \".*\");\n+        Pattern p2 = Pattern.compile(\"\\\\R\" + Pattern.quote(\".B \\\\f[CB]\\\\-\") + \".*\");\n+        Pattern outer = Pattern.compile(\"(\" + p1.pattern() + \"|\" + p2.pattern() + \")\");\n+        Matcher outerMatcher = outer.matcher(page);\n+\n+        \/\/ In the defining areas, option names are represented as follows:\n+        \/\/      \\f[CB]OPTION\\f[R] or \\f[CB]OPTION:\n+        \/\/ where OPTION is the shortest string not containing whitespace or colon,\n+        \/\/ and in which all '-' characters are escaped with a single backslash.\n+\n+        Pattern inner = Pattern.compile(\"\\\\s\\\\\\\\f\\\\[CB](\\\\\\\\-[^ :]+?)(:|\\\\\\\\f\\\\[R])\");\n+\n+        while (outerMatcher.find()) {\n+            String lines = outerMatcher.group();\n+            out.println(\"found:\" + lines + \"\\n\");\n+\n+            Matcher innerMatcher = inner.matcher(lines);\n+            while (innerMatcher.find()) {\n+                String option = innerMatcher.group(1).replace(\"\\\\-\", \"-\");\n+                list.add(option);\n+            }\n+        }\n+\n+        return list;\n+    }\n+\n+    List<String> parseMarkdown(String page) {\n+        var list = new ArrayList<String>();\n+        \/\/ In the Markdown man page, options are defined in one of two forms:\n+        \/\/ 1. options delegated to javac appear in lines of the form\n+        \/\/      -   `-...\n+        \/\/ 2. options implemented by the tool or doclet appear in lines of the form\n+        \/\/      `-...`\n+\n+        Pattern p1 = Pattern.compile(\"\\\\R-   `-.*\");\n+        Pattern p2 = Pattern.compile(\"\\\\R`-.*\");\n+        Pattern outer = Pattern.compile(\"(\" + p1.pattern() + \"|\" + p2.pattern() + \")\");\n+        Matcher outerMatcher = outer.matcher(page);\n+\n+        \/\/ In the defining areas, option names are represented as follows:\n+        \/\/      `OPTION`\n+        \/\/ where OPTION is the shortest string not containing whitespace or colon\n+        Pattern inner = Pattern.compile(\"\\\\s`([^:`]+)\");\n+\n+        while (outerMatcher.find()) {\n+            String lines = outerMatcher.group();\n+            out.println(\"found:\" + lines + \"\\n\");\n+\n+            Matcher innerMatcher = inner.matcher(lines);\n+            while (innerMatcher.find()) {\n+                String option = innerMatcher.group(1);\n+                list.add(option);\n+            }\n+        }\n+\n+        return list;\n+    }\n+ }\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/CheckManPageOptions.java","additions":287,"deletions":0,"binary":false,"changes":287,"status":"added"}]}