{"files":[{"patch":"@@ -325,2 +325,2 @@\n-        flushLeftoverChar(null, true);\n-        try {\n+        try (ch; out) {\n+            flushLeftoverChar(null, true);\n@@ -341,9 +341,2 @@\n-            if (ch != null)\n-                ch.close();\n-            else {\n-                try {\n-                    out.flush();\n-                } finally {\n-                    out.close();\n-                }\n-            }\n+            if (out != null)\n+                out.flush();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/StreamEncoder.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -151,2 +151,9 @@\n-            this.subscription = subscription;\n-            whenSubscribed.complete(subscription);\n+            Flow.Subscription sub;\n+            synchronized (this) {\n+                if ((sub = this.subscription) == null) {\n+                    this.subscription = sub = subscription;\n+                }\n+            }\n+            if (sub == subscription) {\n+                whenSubscribed.complete(subscription);\n+            } else subscription.cancel();\n@@ -157,1 +164,7 @@\n-                subscription.cancel();\n+                Flow.Subscription sub;\n+                synchronized (this) {\n+                    if ((sub = this.subscription) == null) {\n+                        this.subscription = sub = HttpBodySubscriberWrapper.NOP;\n+                    }\n+                }\n+                sub.cancel();\n@@ -782,1 +795,1 @@\n-                if (debug.on()) debug.log(() -> \"hasOutgoing = \" + hasOutgoing());\n+                if (debug.on()) debug.log(() -> \"hasOutgoing = \" + hasOutgoing() + \", demand = \" + demand.get());\n@@ -785,0 +798,1 @@\n+                    if (debug.on()) debug.log(\"outgoing: \" + dp);\n@@ -806,1 +820,4 @@\n-                            if (checkRequestCancelled()) return;\n+                            if (checkRequestCancelled()) {\n+                                if (debug.on()) debug.log(\"Request cancelled!\");\n+                                return;\n+                            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Exchange.java","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -341,0 +341,1 @@\n+                subscription.cancel();\n@@ -405,0 +406,1 @@\n+                subscription.cancel();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Request.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -707,5 +707,7 @@\n-        GoAwayFrame f = new GoAwayFrame(0,\n-                                        ErrorFrame.NO_ERROR,\n-                                        \"Requested by user\".getBytes(UTF_8));\n-        \/\/ TODO: set last stream. For now zero ok.\n-        sendFrame(f);\n+        if (connection.channel().isOpen()) {\n+            GoAwayFrame f = new GoAwayFrame(0,\n+                    ErrorFrame.NO_ERROR,\n+                    \"Requested by user\".getBytes(UTF_8));\n+            \/\/ TODO: set last stream. For now zero ok.\n+            sendFrame(f);\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1035,10 +1035,14 @@\n-        synchronized void register(AsyncEvent e) {\n-            if (closed) e.abort(selectorClosedException());\n-            registrations.add(e);\n-            selector.wakeup();\n-        }\n-\n-        synchronized void cancel(SocketChannel e) {\n-            SelectionKey key = e.keyFor(selector);\n-            if (key != null) {\n-                key.cancel();\n+        void register(AsyncEvent e) {\n+            var closed = this.closed;\n+            if (!closed) {\n+                synchronized (this) {\n+                    closed = this.closed;\n+                    if (!closed) {\n+                        registrations.add(e);\n+                    }\n+                }\n+            }\n+            if (closed) {\n+                e.abort(selectorClosedException());\n+            } else {\n+                selector.wakeup();\n@@ -1046,1 +1050,0 @@\n-            selector.wakeup();\n@@ -1095,4 +1098,2 @@\n-        synchronized void shutdown() {\n-            Log.logTrace(\"{0}: shutting down\", getName());\n-            if (debug.on()) debug.log(\"SelectorManager shutting down\");\n-            closed = true;\n+        \/\/ Only called by the selector manager thread\n+        private void shutdown() {\n@@ -1100,1 +1101,6 @@\n-                selector.close();\n+                synchronized (this) {\n+                    Log.logTrace(\"{0}: shutting down\", getName());\n+                    if (debug.on()) debug.log(\"SelectorManager shutting down\");\n+                    closed = true;\n+                    selector.close();\n+                }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -798,0 +798,1 @@\n+                    if (scheduler.isStopped()) return;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/SSLFlowDelegate.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -347,0 +347,1 @@\n+        if (pushScheduler.isStopped()) return;\n@@ -382,0 +383,1 @@\n+        if (pushScheduler.isStopped()) return;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/SubscriberWrapper.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8136895\n+ * @summary Verify stream closed after write error in StreamEncoder::implClose\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.Writer;\n+import java.nio.charset.MalformedInputException;\n+import java.nio.charset.StandardCharsets;\n+\n+public class CloseWriterOnFailedFlush {\n+    private static final String STR_IOE = \"Test\";   \/\/ IOException\n+    private static final String STR_MIE = \"\\ud83c\"; \/\/ MalformedInputException\n+\n+    public static void main(String[] args) throws IOException {\n+        boolean failed = false;\n+\n+        for (String s : new String[] {STR_IOE, STR_MIE}) {\n+            System.out.println(\"string: \" + s);\n+            ErroringOutputStream stream = new ErroringOutputStream();\n+            try (Writer writer = new OutputStreamWriter(stream,\n+                     StandardCharsets.UTF_8.newEncoder())) {\n+                writer.write(s);\n+            } catch (IOException ex) {\n+                Class exClass = ex.getClass();\n+                if (s.equals(STR_IOE) && exClass != IOException.class ||\n+                    s.equals(STR_MIE) && exClass != MalformedInputException.class)\n+                    throw ex;\n+            }\n+\n+            if (stream.isOpen()) {\n+                System.err.println(\"Stream is STILL open\");\n+                failed = true;\n+            } else {\n+                System.out.println(\"Stream is closed\");\n+            }\n+        }\n+\n+        if (failed)\n+            throw new RuntimeException(\"Test failed\");\n+    }\n+\n+    private static class ErroringOutputStream extends OutputStream {\n+        private boolean open = true;\n+\n+        @Override\n+        public void write(int b) throws IOException {\n+            throw new IOException();\n+        }\n+\n+        public boolean isOpen() {\n+            return open;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            open = false;\n+            System.out.println(\"Closing\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/OutputStreamWriter\/CloseWriterOnFailedFlush.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.management.LockInfo;\n@@ -29,0 +30,2 @@\n+import java.lang.management.MonitorInfo;\n+import java.lang.management.ThreadInfo;\n@@ -92,0 +95,73 @@\n+    \/\/ This method is copied from ThreadInfo::toString, but removes the\n+    \/\/ limit on the stack trace depth (8 frames max) that ThreadInfo::toString\n+    \/\/ forcefully implement. We want to print all frames for better diagnosis.\n+    private static String toString(ThreadInfo info) {\n+        StringBuilder sb = new StringBuilder(\"\\\"\" + info.getThreadName() + \"\\\"\" +\n+                (info.isDaemon() ? \" daemon\" : \"\") +\n+                \" prio=\" + info.getPriority() +\n+                \" Id=\" + info.getThreadId() + \" \" +\n+                info.getThreadState());\n+        if (info.getLockName() != null) {\n+            sb.append(\" on \" + info.getLockName());\n+        }\n+        if (info.getLockOwnerName() != null) {\n+            sb.append(\" owned by \\\"\" + info.getLockOwnerName() +\n+                    \"\\\" Id=\" + info.getLockOwnerId());\n+        }\n+        if (info.isSuspended()) {\n+            sb.append(\" (suspended)\");\n+        }\n+        if (info.isInNative()) {\n+            sb.append(\" (in native)\");\n+        }\n+        sb.append('\\n');\n+        int i = 0;\n+        var stackTrace = info.getStackTrace();\n+        for (; i < stackTrace.length ; i++) {\n+            StackTraceElement ste = stackTrace[i];\n+            sb.append(\"\\tat \" + ste.toString());\n+            sb.append('\\n');\n+            if (i == 0 && info.getLockInfo() != null) {\n+                Thread.State ts = info.getThreadState();\n+                switch (ts) {\n+                    case BLOCKED:\n+                        sb.append(\"\\t-  blocked on \" + info.getLockInfo());\n+                        sb.append('\\n');\n+                        break;\n+                    case WAITING:\n+                        sb.append(\"\\t-  waiting on \" + info.getLockInfo());\n+                        sb.append('\\n');\n+                        break;\n+                    case TIMED_WAITING:\n+                        sb.append(\"\\t-  waiting on \" + info.getLockInfo());\n+                        sb.append('\\n');\n+                        break;\n+                    default:\n+                }\n+            }\n+\n+            for (MonitorInfo mi : info.getLockedMonitors()) {\n+                if (mi.getLockedStackDepth() == i) {\n+                    sb.append(\"\\t-  locked \" + mi);\n+                    sb.append('\\n');\n+                }\n+            }\n+        }\n+        if (i < stackTrace.length) {\n+            sb.append(\"\\t...\");\n+            sb.append('\\n');\n+        }\n+\n+        LockInfo[] locks = info.getLockedSynchronizers();\n+        if (locks.length > 0) {\n+            sb.append(\"\\n\\tNumber of locked synchronizers = \" + locks.length);\n+            sb.append('\\n');\n+            for (LockInfo li : locks) {\n+                sb.append(\"\\t- \" + li);\n+                sb.append('\\n');\n+            }\n+        }\n+        sb.append('\\n');\n+        return sb.toString();\n+    }\n+\n@@ -96,0 +172,1 @@\n+                .map(ReferenceTracker::toString)\n","filename":"test\/jdk\/java\/net\/httpclient\/ReferenceTracker.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8136895\n+ * @summary Verify channel closed after write error in StreamEncoder::implClose\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.MalformedInputException;\n+import java.nio.charset.StandardCharsets;\n+\n+public class CloseWriterOnFailedFlush {\n+    private static final String STR_IOE = \"Test\";   \/\/ IOException\n+    private static final String STR_MIE = \"\\ud83c\"; \/\/ MalformedInputException\n+\n+    public static void main(String[] args) throws IOException {\n+        boolean failed = false;\n+\n+        for (String s : new String[] {STR_IOE, STR_MIE}) {\n+            System.out.println(\"string: \" + s);\n+            ErroringByteChannel channel = new ErroringByteChannel();\n+            try (Writer writer = Channels.newWriter\n+                    (channel, StandardCharsets.UTF_8.newEncoder(), -1 )) {\n+                writer.write(s);\n+            } catch (IOException ex) {\n+                Class exClass = ex.getClass();\n+                if (s.equals(STR_IOE) && exClass != IOException.class ||\n+                    s.equals(STR_MIE) && exClass != MalformedInputException.class)\n+                    throw ex;\n+            }\n+\n+            if (channel.isOpen()) {\n+                System.err.println(\"Channel is STILL open\");\n+                failed = true;\n+            } else {\n+                System.out.println(\"Channel is closed\");\n+            }\n+        }\n+\n+        if (failed)\n+            throw new RuntimeException(\"Test failed\");\n+    }\n+\n+    private static class ErroringByteChannel implements WritableByteChannel {\n+        private boolean open = true;\n+\n+        @Override\n+        public int write(ByteBuffer src) throws IOException {\n+            throw new IOException();\n+        }\n+\n+        @Override\n+        public boolean isOpen() {\n+            return open;\n+        }\n+\n+        @Override\n+        public void close() {\n+            open = false;\n+            System.out.println(\"Closing\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/CloseWriterOnFailedFlush.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,9 @@\n+    private static void ck(String s, int actual, int expected)\n+        throws IOException {\n+        if (actual != expected) {\n+            String msg = String.format(\"%s: actual (%d) != expected (%d)%n\",\n+                                       s, actual, expected);\n+            throw new IOException(msg);\n+        }\n+    }\n+\n@@ -49,3 +58,1 @@\n-        if (out.length != expected.length) {\n-            throw new IOException(\"Failed\");\n-        }\n+        ck(\"Lengths are unequal\", out.length, expected.length);\n@@ -54,2 +61,1 @@\n-            if (out[i] != expected[i])\n-                throw new IOException(\"Failed\");\n+            ck(\"Values are unequal\", out[i], expected[i]);\n","filename":"test\/jdk\/sun\/nio\/cs\/StreamEncoderClose.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"}]}