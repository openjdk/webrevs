{"files":[{"patch":"@@ -37,0 +37,1 @@\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:PerMethodSpecTrapLimit=5000 -XX:PerMethodTrapLimit=100\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyNoInitDeopt.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+            \"-XX:+IgnoreUnrecognizedVMOptions\",\n+            \"-XX:StressLongCountedLoop=0\", \/\/ make sure int loops do not get converted to long\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr7200264\/TestDriver.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * @run driver compiler.c2.cr7200264.TestSSE2IntVect\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:StressLongCountedLoop=0\n+ *                   compiler.c2.cr7200264.TestSSE2IntVect\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr7200264\/TestSSE2IntVect.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * @run driver compiler.c2.cr7200264.TestSSE4IntVect\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:StressLongCountedLoop=0\n+ *                   compiler.c2.cr7200264.TestSSE4IntVect\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr7200264\/TestSSE4IntVect.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+            \"-XX:+UseTLAB\",\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/blackhole\/BlackholeStoreStoreEATest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+ *                   -XX:-StressMethodHandleLinkerInlining\n@@ -49,0 +50,1 @@\n+ *                   -XX:-StressMethodHandleLinkerInlining\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/AbstractRootMethod.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+ *                   -XX:-StressMethodHandleLinkerInlining\n@@ -49,0 +50,1 @@\n+ *                   -XX:-StressMethodHandleLinkerInlining\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/DefaultRootMethod.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:PerMethodTrapLimit=100 -XX:-StressReflectiveCode\n+ *                   -XX:+UncommonNullCast -XX:-StressMethodHandleLinkerInlining -XX:TypeProfileLevel=0\n@@ -359,1 +361,1 @@\n-            throw new AssertionError(\"compilation must \" + (mustExist ? \"\" : \" not \") + \" got deoptimized\");\n+            throw new AssertionError(\"compilation must \" + (mustExist ? \"\" : \" not \") + \" get deoptimized\");\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/klass\/CastNullCheckDroppingsTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+ *     -XX:CompileCommand=dontinline,compiler.jvmci.common.testcases.SimpleClass::testMethod\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/IsMatureVsReprofileTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+ *                   -XX:TypeProfileLevel=0\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/ReprofileTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  *                   -XX:+UnlockExperimentalVMOptions -XX:PerMethodSpecTrapLimit=5000 -XX:PerMethodTrapLimit=100\n@@ -47,0 +48,1 @@\n+  *                   -XX:+UnlockExperimentalVMOptions -XX:PerMethodSpecTrapLimit=5000 -XX:PerMethodTrapLimit=100\n","filename":"test\/hotspot\/jtreg\/compiler\/profiling\/TestTypeProfiling.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:PerMethodSpecTrapLimit=5000 -XX:PerMethodTrapLimit=100\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestExplicitRangeChecks.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,674 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8259609 8276116\n+ * @summary C2: optimize long range checks in long counted loops\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.util\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm -ea -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-BackgroundCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:PerMethodSpecTrapLimit=5000 -XX:PerMethodTrapLimit=100\n+ *                   TestLongRangeCheck\n+ *\n+ *\/\n+\n+import jdk.internal.util.Preconditions;\n+import sun.hotspot.WhiteBox;\n+import java.lang.reflect.Method;\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Paths;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class TestLongRangeCheck {\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+     private static void assertIsCompiled(Method m) {\n+         if (!WHITE_BOX.isMethodCompiled(m) || WHITE_BOX.getMethodCompilationLevel(m) != CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION) {\n+             throw new RuntimeException(\"should still be compiled\");\n+         }\n+    }\n+\n+     private static void assertIsNotCompiled(Method m) {\n+         if (WHITE_BOX.isMethodCompiled(m) && WHITE_BOX.getMethodCompilationLevel(m) == CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION) {\n+             throw new RuntimeException(\"should have been deoptimized\");\n+         }\n+    }\n+\n+    private static void compile(Method m) {\n+        WHITE_BOX.enqueueMethodForCompilation(m, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        assertIsCompiled(m);\n+    }\n+\n+    public static ClassLoader newClassLoader() {\n+        try {\n+            return new URLClassLoader(new URL[] {\n+                    Paths.get(System.getProperty(\"test.classes\",\".\")).toUri().toURL(),\n+            }, null);\n+        } catch (MalformedURLException e){\n+            throw new RuntimeException(\"Unexpected URL conversion failure\", e);\n+        }\n+    }\n+\n+    private static void test(String method, long start, long stop, long length, long offset) throws Exception {\n+        Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class);\n+        m.invoke(null, start, stop, length, offset); \/\/ run once so all classes are loaded\n+        compile(m);\n+\n+        m.invoke(null, start, stop, length, offset);\n+        assertIsCompiled(m);\n+        try {\n+            m.invoke(null, start-1, stop, length, offset);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch(InvocationTargetException e) {\n+            if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                throw new RuntimeException(\"unexpected exception\");\n+            }\n+        }\n+        assertIsNotCompiled(m);\n+\n+        m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class);\n+        m.invoke(null, start, stop, length, offset); \/\/ run once so all classes are loaded\n+        compile(m);\n+        assertIsCompiled(m);\n+\n+        m.invoke(null, start, stop, length, offset);\n+        assertIsCompiled(m);\n+        try {\n+            m.invoke(null, stop, stop + 100, length, offset);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch(InvocationTargetException e) {\n+            if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                throw new RuntimeException(\"unexpected exception\");\n+            }\n+        }\n+        assertIsNotCompiled(m);\n+\n+        m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class);\n+        m.invoke(null, start, stop, length, offset); \/\/ run once so all classes are loaded\n+        compile(m);\n+\n+        m.invoke(null, start, stop, length, offset);\n+        assertIsCompiled(m);\n+        try {\n+            m.invoke(null, start, stop+1, length, offset);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch(InvocationTargetException e) {\n+            if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                throw new RuntimeException(\"unexpected exception\");\n+            }\n+        }\n+        assertIsNotCompiled(m);\n+    }\n+\n+    private static void testOverflow(String method, long start, long stop, long length, long offset0, long offset1) throws Exception {\n+        Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class);\n+        m.invoke(null, start, stop, length, offset0);\n+        compile(m);\n+\n+        m.invoke(null, start, stop, length, offset0);\n+        assertIsCompiled(m);\n+        try {\n+            m.invoke(null, start, stop, length, offset1);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch(InvocationTargetException e) {\n+            if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                throw new RuntimeException(\"unexpected exception\");\n+            }\n+        }\n+        assertIsNotCompiled(m);\n+    }\n+\n+    private static void testConditional(String method, long start, long stop, long length, long offset0, long offset1, long start1, long stop1) throws Exception {\n+        Method m;\n+\n+        if (start1 != start) {\n+            m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class, long.class, long.class);\n+            m.invoke(null, start, stop, length, offset0, start, stop);\n+            compile(m);\n+\n+            m.invoke(null, start, stop, length, offset0, start, stop);\n+            assertIsCompiled(m);\n+            try {\n+                m.invoke(null, start, stop, length, offset1, start1-1, stop1);\n+                throw new RuntimeException(\"should have thrown\");\n+            } catch(InvocationTargetException e) {\n+                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                    throw new RuntimeException(\"unexpected exception\");\n+                }\n+            }\n+            assertIsNotCompiled(m);\n+        }\n+\n+        if (stop1 != stop) {\n+            m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class, long.class, long.class);\n+            m.invoke(null, start, stop, length, offset0, start, stop);\n+            compile(m);\n+\n+            m.invoke(null, start, stop, length, offset0, start, stop);\n+            assertIsCompiled(m);\n+            try {\n+                m.invoke(null, start, stop, length, offset1, start1, stop1+1);\n+                throw new RuntimeException(\"should have thrown\");\n+            } catch(InvocationTargetException e) {\n+                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                    throw new RuntimeException(\"unexpected exception\");\n+                }\n+            }\n+            assertIsNotCompiled(m);\n+        }\n+\n+        m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class, long.class, long.class);\n+        m.invoke(null, start, stop, length, offset0, start, stop);\n+        compile(m);\n+\n+        m.invoke(null, start, stop, length, offset0, start, stop);\n+        assertIsCompiled(m);\n+\n+        m.invoke(null, start, stop, length, offset1, start1, stop1);\n+        assertIsCompiled(m);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        test(\"testStridePosScalePos\", 0, 100, 100, 0);\n+\n+        test(\"testStrideNegScaleNeg\", 0, 100, 100, 100);\n+\n+        test(\"testStrideNegScalePos\", 0, 100, 100, 0);\n+\n+        test(\"testStridePosScaleNeg\", 0, 100, 100, 99);\n+\n+        test(\"testStridePosScalePosNotOne\", 0, 100, 1090, 0);\n+\n+        test(\"testStrideNegScaleNegNotOne\", 0, 100, 1090, 1100);\n+\n+        test(\"testStrideNegScalePosNotOne\", 0, 100, 1090, 0);\n+\n+        test(\"testStridePosScaleNegNotOne\", 0, 100, 1090, 1089);\n+\n+        long v = ((long)Integer.MAX_VALUE \/ 10000) * 250000;\n+\n+        test(\"testStridePosNotOneScalePos\", -v, v, v * 2, v);\n+\n+        test(\"testStrideNegNotOneScaleNeg\", -v, v, v * 2, v);\n+\n+        test(\"testStrideNegNotOneScalePos\", -v, v, v * 2, v);\n+\n+        test(\"testStridePosNotOneScaleNeg\", -v, v, v * 2, v-1);\n+\n+        \/\/ offset causes overflow\n+        testOverflow(\"testStridePosScalePos\", 0, 100, 100, 0, Long.MAX_VALUE - 50);\n+        testOverflow(\"testStrideNegScaleNeg\", 0, 100, 100, 100, Long.MIN_VALUE + 50);\n+        testOverflow(\"testStrideNegScalePos\", 0, 100, 100, 0, Long.MAX_VALUE - 50);\n+        testOverflow(\"testStridePosScaleNeg\", 0, 100, 100, 99, Long.MIN_VALUE + 50);\n+\n+        \/\/ no spurious deopt if the range check doesn't fail because not executed\n+        testConditional(\"testStridePosScalePosConditional\", 0, 100, 100, 0, -50, 50, 100);\n+        testConditional(\"testStridePosScalePosConditional\", 0, 100, Long.MAX_VALUE, 0, Long.MAX_VALUE - 50, 0, 50);\n+        testConditional(\"testStrideNegScaleNegConditional\", 0, 100, 100, 100, 50, 0, 51);\n+        testConditional(\"testStrideNegScaleNegConditional\", 0, 100, Long.MAX_VALUE, 100, Long.MIN_VALUE + 50, 52, 100);\n+        testConditional(\"testStrideNegScalePosConditional\", 0, 100, 100, 0, -50, 50, 100);\n+        testConditional(\"testStrideNegScalePosConditional\", 0, 100, Long.MAX_VALUE, 100, Long.MAX_VALUE - 50, 0, 50);\n+        testConditional(\"testStridePosScaleNegConditional\", 0, 100, 100, 99, 50, 0, 51);\n+        testConditional(\"testStridePosScaleNegConditional\", 0, 100, Long.MAX_VALUE, 99, Long.MIN_VALUE + 50, 52, 100);\n+\n+        test(\"testStridePosScalePosInIntLoop\", 0, 100, 100, 0);\n+\n+        test(\"testStrideNegScaleNegInIntLoop\", 0, 100, 100, 100);\n+\n+        test(\"testStrideNegScalePosInIntLoop\", 0, 100, 100, 0);\n+\n+        test(\"testStridePosScaleNegInIntLoop\", 0, 100, 100, 99);\n+\n+        test(\"testStridePosScalePosNotOneInIntLoop\", 0, 100, 1090, 0);\n+\n+        test(\"testStrideNegScaleNegNotOneInIntLoop\", 0, 100, 1090, 1100);\n+\n+        test(\"testStrideNegScalePosNotOneInIntLoop\", 0, 100, 1090, 0);\n+\n+        test(\"testStridePosScaleNegNotOneInIntLoop\", 0, 100, 1090, 1089);\n+\n+        v = ((long)Integer.MAX_VALUE \/ 10000) * 9999;\n+\n+        test(\"testStridePosNotOneScalePosInIntLoop\", -v, v, v * 4, 2 * v);\n+\n+        test(\"testStrideNegNotOneScaleNegInIntLoop\", -v, v, v * 4, 2 * v);\n+\n+        test(\"testStrideNegNotOneScalePosInIntLoop\", -v, v, v * 4, 2 * v);\n+\n+        test(\"testStridePosNotOneScaleNegInIntLoop\", -v, v, v * 4, 2 * v - 1);\n+\n+        \/\/ offset causes overflow\n+        testOverflow(\"testStridePosScalePosInIntLoop\", 0, 100, 100, 0, Long.MAX_VALUE - 50);\n+        testOverflow(\"testStrideNegScaleNegInIntLoop\", 0, 100, 100, 100, Long.MIN_VALUE + 50);\n+        testOverflow(\"testStrideNegScalePosInIntLoop\", 0, 100, 100, 0, Long.MAX_VALUE - 50);\n+        testOverflow(\"testStridePosScaleNegInIntLoop\", 0, 100, 100, 99, Long.MIN_VALUE + 50);\n+        \/\/ no spurious deopt if the range check doesn't fail because not executed\n+        testConditional(\"testStridePosScalePosConditionalInIntLoop\", 0, 100, 100, 0, -50, 50, 100);\n+        testConditional(\"testStridePosScalePosConditionalInIntLoop\", 0, 100, Long.MAX_VALUE, 0, Long.MAX_VALUE - 50, 0, 50);\n+        testConditional(\"testStrideNegScaleNegConditionalInIntLoop\", 0, 100, 100, 100, 50, 0, 51);\n+        testConditional(\"testStrideNegScaleNegConditionalInIntLoop\", 0, 100, Long.MAX_VALUE, 100, Long.MIN_VALUE + 50, 52, 100);\n+        testConditional(\"testStrideNegScalePosConditionalInIntLoop\", 0, 100, 100, 0, -50, 50, 100);\n+        testConditional(\"testStrideNegScalePosConditionalInIntLoop\", 0, 100, Long.MAX_VALUE, 100, Long.MAX_VALUE - 50, 0, 50);\n+        testConditional(\"testStridePosScaleNegConditionalInIntLoop\", 0, 100, 100, 99, 50, 0, 51);\n+        testConditional(\"testStridePosScaleNegConditionalInIntLoop\", 0, 100, Long.MAX_VALUE, 99, Long.MIN_VALUE + 50, 52, 100);\n+\n+        test(\"testStridePosScalePosNotOneInIntLoop2\", 0, 100, 1090, 0);\n+\n+        test(\"testStrideNegScaleNegNotOneInIntLoop2\", 0, 100, 1090, 1100);\n+\n+        test(\"testStrideNegScalePosNotOneInIntLoop2\", 0, 100, 1090, 0);\n+\n+        test(\"testStridePosScaleNegNotOneInIntLoop2\", 0, 100, 1090, 1089);\n+\n+        {\n+            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosInIntLoopOverflow\", long.class, long.class, long.class, long.class);\n+            long stride = 1 << 14;\n+            long scale = 1 << 15;\n+            long offset = stride * scale * 4;\n+            long length = offset + stride * scale * 3 + 1;\n+            long stop = stride * 5;\n+\n+            m.invoke(null, 0, stop, length, offset);\n+            compile(m);\n+\n+            m.invoke(null, 0, stop, length, offset);\n+            \/\/ deoptimizes even though no range check fails\n+        }\n+        {\n+            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosInIntLoopOverflow\", long.class, long.class, long.class, long.class);\n+            long stride = 1 << 14;\n+            long scale = 1 << 15;\n+            long offset = stride * scale * 4;\n+            long length = offset + stride * scale * 3 + 1;\n+            long stop = stride * 5;\n+\n+            m.invoke(null, 0, stop, length, offset);\n+            compile(m);\n+\n+            offset = 0;\n+            stop = stride * 5;\n+\n+            try {\n+                m.invoke(null, 0, stop, length, offset);\n+                throw new RuntimeException(\"should have thrown\");\n+            } catch(InvocationTargetException e) {\n+                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                    throw new RuntimeException(\"unexpected exception\");\n+                }\n+            }\n+            assertIsNotCompiled(m);\n+        }\n+    }\n+\n+    public static void testStridePosScalePos(long start, long stop, long length, long offset) {\n+        final long scale = 1;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScaleNeg(long start, long stop, long length, long offset) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = stop; i > start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScalePos(long start, long stop, long length, long offset) {\n+        final long scale = 1;\n+        final long stride = 1;\n+        for (long i = stop-1; i >= start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScaleNeg(long start, long stop, long length, long offset) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScalePosNotOne(long start, long stop, long length, long offset) {\n+        final long scale = 11;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScaleNegNotOne(long start, long stop, long length, long offset) {\n+        final long scale = -11;\n+        final long stride = 1;\n+        for (long i = stop; i > start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScalePosNotOne(long start, long stop, long length, long offset) {\n+        final long scale = 11;\n+        final long stride = 1;\n+        for (long i = stop-1; i >= start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScaleNegNotOne(long start, long stop, long length, long offset) {\n+        final long scale = -11;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosNotOneScalePos(long start, long stop, long length, long offset) {\n+        final long scale = 1;\n+        final long stride = Integer.MAX_VALUE \/ 10000;\n+        for (long i = start; i < stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegNotOneScaleNeg(long start, long stop, long length, long offset) {\n+        final long scale = -1;\n+        final long stride = Integer.MAX_VALUE \/ 10000;\n+        for (long i = stop; i > start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegNotOneScalePos(long start, long stop, long length, long offset) {\n+        final long scale = 1;\n+        final long stride = Integer.MAX_VALUE \/ 10000;\n+        for (long i = stop-1; i >= start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosNotOneScaleNeg(long start, long stop, long length, long offset) {\n+        final long scale = -1;\n+        final long stride = Integer.MAX_VALUE \/ 10000;\n+        for (long i = start; i < stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScalePosConditional(long start, long stop, long length, long offset, long start2, long stop2) {\n+        Preconditions.checkIndex(0, length, null);\n+        final long scale = 1;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            if (i >= start2 && i < stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStrideNegScaleNegConditional(long start, long stop, long length, long offset, long start2, long stop2) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = stop; i > start; i -= stride) {\n+            if (i >= start2 && i < stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStrideNegScalePosConditional(long start, long stop, long length, long offset, long start2, long stop2) {\n+        final long scale = 1;\n+        final long stride = 1;\n+        for (long i = stop-1; i >= start; i -= stride) {\n+            if (i >= start2 && i < stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStridePosScaleNegConditional(long start, long stop, long length, long offset, long start2, long stop2) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            if (i >= start2 && i < stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    private static void checkInputs(long... inputs) {\n+        for (int i = 0; i < inputs.length; i++) {\n+            if ((long)((int)inputs[i]) != inputs[i]) {\n+                throw new RuntimeException(\"bad arguments\");\n+            }\n+        }\n+    }\n+\n+    public static void testStridePosScalePosInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = 1;\n+        final int stride = 1;\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScaleNegInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = -1;\n+        final int stride = 1;\n+        for (int i = (int)stop; i > (int)start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScalePosInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = 1;\n+        final int stride = 1;\n+        for (int i = (int)(stop-1); i >= (int)start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScaleNegInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = -1;\n+        final int stride = 1;\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScalePosNotOneInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = 11;\n+        final int stride = 1;\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScaleNegNotOneInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = -11;\n+        final int stride = 1;\n+        for (int i = (int)stop; i > (int)start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScalePosNotOneInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = 11;\n+        final int stride = 1;\n+        for (int i = (int)(stop-1); i >= (int)start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScaleNegNotOneInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = -11;\n+        final int stride = 1;\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosNotOneScalePosInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = 2;\n+        final int stride = Integer.MAX_VALUE \/ 10000;\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegNotOneScaleNegInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = -2;\n+        final int stride = Integer.MAX_VALUE \/ 10000;\n+        for (int i = (int)stop; i > (int)start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegNotOneScalePosInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = 2;\n+        final int stride = Integer.MAX_VALUE \/ 10000;\n+        for (int i = (int)(stop-1); i >= (int)start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosNotOneScaleNegInIntLoop(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final long scale = -2;\n+        final int stride = Integer.MAX_VALUE \/ 10000;\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScalePosConditionalInIntLoop(long start, long stop, long length, long offset, long start2, long stop2) {\n+        checkInputs(start, stop, start2, stop2);\n+        final long scale = 1;\n+        final int stride = 1;\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            if (i >= (int)start2 && i < (int)stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStrideNegScaleNegConditionalInIntLoop(long start, long stop, long length, long offset, long start2, long stop2) {\n+        checkInputs(start, stop, start2, stop2);\n+        final long scale = -1;\n+        final int stride = 1;\n+        for (int i = (int)stop; i > (int)start; i -= stride) {\n+            if (i >= (int)start2 && i < (int)stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStrideNegScalePosConditionalInIntLoop(long start, long stop, long length, long offset, long start2, long stop2) {\n+        checkInputs(start, stop, start2, stop2);\n+        final long scale = 1;\n+        final int stride = 1;\n+        for (int i = (int)(stop-1); i >= (int)start; i -= stride) {\n+            if (i >= (int)start2 && i < (int)stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStridePosScaleNegConditionalInIntLoop(long start, long stop, long length, long offset, long start2, long stop2) {\n+        checkInputs(start, stop, start2, stop2);\n+        final long scale = -1;\n+        final int stride = 1;\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            if (i >= (int)start2 && i < (int)stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStridePosScalePosNotOneInIntLoop2(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final int scale = 11;\n+        final int stride = 1;\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScaleNegNotOneInIntLoop2(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final int scale = -11;\n+        final int stride = 1;\n+        for (int i = (int)stop; i > (int)start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStrideNegScalePosNotOneInIntLoop2(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final int scale = 11;\n+        final int stride = 1;\n+        for (int i = (int)(stop-1); i >= (int)start; i -= stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScaleNegNotOneInIntLoop2(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final int scale = -11;\n+        final int stride = 1;\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+\n+    public static void testStridePosScalePosInIntLoopOverflow(long start, long stop, long length, long offset) {\n+        checkInputs(start, stop);\n+        final int scale = 1 << 15;\n+        final int stride = 1 << 14;\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            Preconditions.checkIndex(scale * i + offset, length, null);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestLongRangeCheck.java","additions":674,"deletions":0,"binary":false,"changes":674,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+ * @requires vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestRangeCheckSmearing.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+ * @test\n+ * @bug 8275908\n+ * @summary Quick test for the new WhiteBox methods of JDK-8275908\n+ *\n+ * @requires vm.compiler2.enabled & vm.compMode != \"Xcomp\"\n+ * @requires vm.opt.DeoptimizeALot != true\n+ *\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-UseOnStackReplacement -XX:-TieredCompilation\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:PerMethodTrapLimit=100 -XX:PerBytecodeTrapLimit=4\n+ *                   -XX:TypeProfileLevel=0\n+ *                   -XX:CompileCommand=compileonly,compiler.uncommontrap.Decompile::uncommonTrap\n+ *                   -XX:CompileCommand=inline,compiler.uncommontrap.Decompile*::foo\n+ *                   compiler.uncommontrap.Decompile\n+ *\/\n+\n+package compiler.uncommontrap;\n+\n+import java.lang.reflect.Method;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class Decompile {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    \/\/ The number of deoptimizations after which a method will be made not-entrant\n+    private static final int PerBytecodeTrapLimit = WB.getIntxVMFlag(\"PerBytecodeTrapLimit\").intValue();\n+    \/\/ The number of interpreter invocations after which a decompiled method will be re-compiled.\n+    private static final int Tier0InvokeNotifyFreq = (int)Math.pow(2, WB.getIntxVMFlag(\"Tier0InvokeNotifyFreqLog\"));\n+    \/\/ VM builds without JVMCI like x86_32 call the bimorphic inlining trap just 'bimorphic'\n+    \/\/ while all the other builds with JVMCI call it 'bimorphic_or_optimized_type_check'.\n+    \/\/ Only builds with JVMCI have the \"EnableJVMCI\" flag.\n+    private static final boolean isJVMCISupported = (WB.getBooleanVMFlag(\"EnableJVMCI\") != null);\n+    private static final String bimorphicTrapName = isJVMCISupported ? \"bimorphic_or_optimized_type_check\" : \"bimorphic\";\n+\n+    static class Base {\n+        void foo() {}\n+    }\n+    static class X extends Base {\n+        void foo() {}\n+    }\n+    static class Y extends Base {\n+        void foo() {}\n+    }\n+\n+    static void uncommonTrap(Base t) {\n+        t.foo();\n+    }\n+\n+    private static void printCounters(Method uncommonTrap_m, int invocations) {\n+        System.out.println(\"-----------------------------------------------------------------\");\n+        System.out.println(\"invocations=\" + invocations + \" \" +\n+                           \"method compiled=\" + WB.isMethodCompiled(uncommonTrap_m) + \" \" +\n+                           \"decompileCount=\" + WB.getMethodDecompileCount(uncommonTrap_m) + \"\\n\" +\n+                           \"trapCount=\" + WB.getMethodTrapCount(uncommonTrap_m) + \" \" +\n+                           \"trapCount(class_check)=\" + WB.getMethodTrapCount(uncommonTrap_m, \"class_check\") + \" \" +\n+                           \"trapCount(\" + bimorphicTrapName + \")=\" +\n+                           WB.getMethodTrapCount(uncommonTrap_m, bimorphicTrapName) + \"\\n\" +\n+                           \"globalDeoptCount=\" + WB.getDeoptCount() + \" \" +\n+                           \"globalDeoptCount(class_check)=\" + WB.getDeoptCount(\"class_check\", null) + \" \" +\n+                           \"globalDeoptCount(\" + bimorphicTrapName + \")=\" +\n+                           WB.getDeoptCount(bimorphicTrapName, null));\n+        System.out.println(\"-----------------------------------------------------------------\");\n+    }\n+\n+    private static void check(Method uncommonTrap_m, int invocations, boolean isCompiled, int decompileCount,\n+                              int trapCount, int trapCountClassCheck, int trapCountBimorphic,\n+                              int deoptCount, int deoptCountClassCheck, int deoptCountBimorphic) {\n+\n+        printCounters(uncommonTrap_m, invocations);\n+\n+        Asserts.assertEQ(isCompiled, WB.isMethodCompiled(uncommonTrap_m),\n+                         \"Wrong compilation status.\");\n+        Asserts.assertEQ(decompileCount, WB.getMethodDecompileCount(uncommonTrap_m),\n+                         \"Wrong number of decompilations.\");\n+        Asserts.assertEQ(trapCount, WB.getMethodTrapCount(uncommonTrap_m),\n+                         \"Wrong number of traps.\");\n+        Asserts.assertEQ(trapCountClassCheck, WB.getMethodTrapCount(uncommonTrap_m, \"class_check\"),\n+                         \"Wrong number of traps.\");\n+        Asserts.assertEQ(trapCountBimorphic, WB.getMethodTrapCount(uncommonTrap_m, bimorphicTrapName),\n+                         \"Wrong number of traps.\");\n+        Asserts.assertEQ(deoptCount, WB.getDeoptCount(),\n+                         \"Wrong number of deoptimizations.\");\n+        Asserts.assertEQ(deoptCountClassCheck, WB.getDeoptCount(\"class_check\", null),\n+                         \"Wrong number of class_check deoptimizations.\");\n+        Asserts.assertEQ(deoptCountBimorphic, WB.getDeoptCount(bimorphicTrapName, null),\n+                         \"Wrong number of \" + bimorphicTrapName + \"deoptimizations.\");\n+    }\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Get a handle of the test method for usage with the WhiteBox API.\n+        Method uncommonTrap_m = Decompile.class\n+            .getDeclaredMethod(\"uncommonTrap\", new Class[] { Base.class });\n+\n+        int invocations = 0;\n+        Base b = new Base();\n+        \/\/ This is a little tricky :) We have to define 'x' already here otherwise\n+        \/\/ the class 'X' won't be loaded and 'uncommonTrap()' will be compiled without\n+        \/\/ a class check but a CHA dependency that class 'B' has no subtypes.\n+        X x = new X();\n+        Y y = new Y();\n+\n+        \/\/ Warmup and compile with an object of type 'Base' as receiver, but don't invoke compiled code.\n+        while(!WB.isMethodCompiled(uncommonTrap_m)) {\n+            invocations++;\n+            uncommonTrap(b);\n+        }\n+        check(uncommonTrap_m, invocations, true \/* is_compiled *\/, 0 \/* decompileCount *\/,\n+              0 \/* trapCount  *\/, 0 \/* trapCountClassCheck  *\/, 0 \/* trapCountBimorphic  *\/,\n+              0 \/* deoptCount *\/, 0 \/* deoptCountClassCheck *\/, 0 \/* deoptCountBimorphic *\/);\n+\n+        \/\/ Invoke compiled code 'PerBytecodeTrapLimit' times with an receiver object of type 'X'.\n+        \/\/ This should deoptimize 'PerBytecodeTrapLimit' times and finally decompile the method.\n+        for (int i = 0; i < PerBytecodeTrapLimit; i++) {\n+            invocations++;\n+            uncommonTrap(x);\n+        }\n+        check(uncommonTrap_m, invocations, false \/* is_compiled *\/, 1 \/* decompileCount *\/,\n+              PerBytecodeTrapLimit \/* trapCount  *\/, PerBytecodeTrapLimit \/* trapCountClassCheck  *\/, 0 \/* trapCountBimorphic  *\/,\n+              PerBytecodeTrapLimit \/* deoptCount *\/, PerBytecodeTrapLimit \/* deoptCountClassCheck *\/, 0 \/* deoptCountBimorphic *\/);\n+\n+        \/\/ Invoke the method 'Tier0InvokeNotifyFreq' more times with an receiver object of type 'X'.\n+        \/\/ This should re-compile the method again with bimorphic inlining for receiver types 'Base' and 'X'.\n+        for (int i = 0; i < Tier0InvokeNotifyFreq; i++) {\n+            invocations++;\n+            uncommonTrap(x);\n+        }\n+        check(uncommonTrap_m, invocations, true \/* is_compiled *\/, 1 \/* decompileCount *\/,\n+              PerBytecodeTrapLimit \/* trapCount  *\/, PerBytecodeTrapLimit \/* trapCountClassCheck  *\/, 0 \/* trapCountBimorphic  *\/,\n+              PerBytecodeTrapLimit \/* deoptCount *\/, PerBytecodeTrapLimit \/* deoptCountClassCheck *\/, 0 \/* deoptCountBimorphic *\/);\n+\n+        \/\/ Invoke compiled code 'PerBytecodeTrapLimit' times with an receiver object of type 'Y'.\n+        \/\/ This should deoptimize 'PerBytecodeTrapLimit' times and finally decompile the method.\n+        for (int i = 0; i < PerBytecodeTrapLimit; i++) {\n+            invocations++;\n+            uncommonTrap(y);\n+        }\n+        check(uncommonTrap_m, invocations, false \/* is_compiled *\/, 2 \/* decompileCount *\/,\n+              2*PerBytecodeTrapLimit \/* trapCount  *\/, PerBytecodeTrapLimit \/* trapCountClassCheck  *\/, PerBytecodeTrapLimit \/* trapCountBimorphic  *\/,\n+              2*PerBytecodeTrapLimit \/* deoptCount *\/, PerBytecodeTrapLimit \/* deoptCountClassCheck *\/, PerBytecodeTrapLimit \/* deoptCountBimorphic *\/);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/Decompile.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:PerMethodTrapLimit=100\n@@ -43,0 +44,1 @@\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:PerMethodTrapLimit=100\n@@ -48,0 +50,1 @@\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:PerMethodTrapLimit=100\n@@ -53,0 +56,1 @@\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:PerMethodTrapLimit=100\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/TestUnstableIfTrap.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}