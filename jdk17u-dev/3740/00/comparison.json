{"files":[{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\/**\n+ * @test\n+ * @bug 8353662\n+ * @summary Verify long-standing behavior of resolving non-local file URLs using FTP.\n+ * @run junit NonLocalFtpFallback\n+ *\/\n+\n+public class NonLocalFtpFallback {\n+\n+    \/\/ Port 21 may not be available, use an HTTP proxy with an ephemeral port\n+    private HttpServer proxyServer;\n+\n+    \/\/ The file requested in this test\n+    private Path file;\n+\n+    \/\/ FTP URIs requested by the proxy client\n+    private Set<URI> uris = new HashSet<>();\n+\n+    \/**\n+     * Set up the HTTP proxy used for serving FTP in this test\n+     *\n+     * @throws IOException if an unexpected IO error occurs\n+     *\/\n+    @BeforeEach\n+    public void setup() throws IOException {\n+        \/\/ Create a file with some random data\n+        byte[] data = new byte[512];\n+        new Random().nextBytes(data);\n+        file = Files.write(Path.of(\"ftp-file.txt\"), data);\n+\n+        \/\/ Set up an HTTP proxy server\n+        proxyServer = HttpServer.create();\n+        \/\/ Bind to the loopback address with an ephemeral port\n+        InetAddress loopbackAddress = InetAddress.getLoopbackAddress();\n+        proxyServer.bind(new InetSocketAddress(loopbackAddress, 0), 0);\n+        \/\/ Handler for the FTP proxy request\n+        proxyServer.createContext(\"\/\", new HttpHandler() {\n+            @Override\n+            public void handle(HttpExchange exchange) throws IOException {\n+                \/\/ Record the URI requested\n+                uris.add(exchange.getRequestURI());\n+                \/\/ Send the data\n+                exchange.sendResponseHeaders(200, Files.size(file));\n+                try (OutputStream out = exchange.getResponseBody()) {\n+                    Files.copy(file, out);\n+                }\n+                \/\/ Complete the exchange\n+                exchange.close();\n+            }\n+        });\n+        \/\/ Start the proxy server\n+        proxyServer.start();\n+    }\n+\n+    \/**\n+     * Shut down proxy server and clean up files created\n+     *\n+     * @throws IOException if an unexpected IO error occurs\n+     *\/\n+    @AfterEach\n+    public void destroy() throws IOException {\n+        proxyServer.stop(2);\n+        Files.delete(file);\n+    }\n+\n+    \/**\n+     * Verifies the long-standing and unspecified FTP fallback feature where the file\n+     * URL scheme handler attempts an FTP connection for non-local files.\n+     *\n+     * The non-local file URL used here is of the form file:\/\/127.0.0.1\/path. Since the\n+     * host component here is not equal to \"localhost\", this is considered a non-local\n+     * URL.\n+     *\n+     * @throws Exception\n+     *\/\n+    @Test\n+    public void verifyNonLocalFtpFallback() throws Exception {\n+        URL localURL = file.toUri().toURL();\n+        \/\/ We can use a fake host name here, no actual FTP request will be made\n+        String hostname = \"remotehost\";\n+        URL nonLocalURL = new URL(\"file\", hostname, localURL.getFile());\n+\n+        \/\/ Open the non-local file: URL connection using a proxy\n+        Proxy proxy = new Proxy(Proxy.Type.HTTP,\n+                new InetSocketAddress(proxyServer.getAddress().getAddress(),\n+                        proxyServer.getAddress().getPort()));\n+        URLConnection con = nonLocalURL.openConnection(proxy);\n+\n+        \/\/ Assert that the expected file content is retrieved\n+        try (InputStream in = con.getInputStream()) {\n+            byte[] retrived = in.readAllBytes();\n+            assertArrayEquals(Files.readAllBytes(file), retrived);\n+        }\n+\n+        \/\/ Assert that the expected FTP URI was requested in the HTTP proxy\n+        assertEquals(1, uris.size());\n+        URL ftpURL = new URL(\"ftp\", hostname, localURL.getFile());\n+        assertEquals(ftpURL.toURI(), uris.iterator().next());\n+    }\n+}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/file\/NonLocalFtpFallback.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"}]}