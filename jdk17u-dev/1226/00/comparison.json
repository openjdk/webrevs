{"files":[{"patch":"@@ -2722,4 +2722,5 @@\n-Handle java_lang_Throwable::get_cause_with_stack_trace(Handle throwable, TRAPS) {\n-  \/\/ Call to JVM to fill in the stack trace and clear declaringClassObject to\n-  \/\/ not keep classes alive in the stack trace.\n-  \/\/ call this:  public StackTraceElement[] getStackTrace()\n+Handle java_lang_Throwable::create_initialization_error(JavaThread* current, Handle throwable) {\n+  \/\/ Creates an ExceptionInInitializerError to be recorded as the initialization error when class initialization\n+  \/\/ failed due to the passed in 'throwable'. We cannot save 'throwable' directly due to issues with keeping alive\n+  \/\/ all objects referenced via its stacktrace. So instead we save a new EIIE instance, with the same message and\n+  \/\/ symbolic stacktrace of 'throwable'.\n@@ -2728,13 +2729,1 @@\n-  JavaValue result(T_ARRAY);\n-  JavaCalls::call_virtual(&result, throwable,\n-                          vmClasses::Throwable_klass(),\n-                          vmSymbols::getStackTrace_name(),\n-                          vmSymbols::getStackTrace_signature(),\n-                          CHECK_NH);\n-  Handle stack_trace(THREAD, result.get_oop());\n-  assert(stack_trace->is_objArray(), \"Should be an array\");\n-\n-  \/\/ Throw ExceptionInInitializerError as the cause with this exception in\n-  \/\/ the message and stack trace.\n-\n-  \/\/ Now create the message with the original exception and thread name.\n+  \/\/ Now create the message from the original exception and thread name.\n@@ -2742,1 +2731,1 @@\n-  ResourceMark rm(THREAD);\n+  ResourceMark rm(current);\n@@ -2746,2 +2735,2 @@\n-  if (message == NULL) {\n-    st.print(\"[in thread \\\"%s\\\"]\", THREAD->name());\n+  if (message == nullptr) {\n+    st.print(\"[in thread \\\"%s\\\"]\", current->name());\n@@ -2749,1 +2738,1 @@\n-    st.print(\"%s [in thread \\\"%s\\\"]\", message->as_C_string(), THREAD->name());\n+    st.print(\"%s [in thread \\\"%s\\\"]\", message->as_C_string(), current->name());\n@@ -2753,4 +2742,4 @@\n-  Handle h_cause = Exceptions::new_exception(THREAD, exception_name, st.as_string());\n-\n-  \/\/ If new_exception returns a different exception while creating the exception, return null.\n-  if (h_cause->klass()->name() != exception_name) {\n+  Handle init_error = Exceptions::new_exception(current, exception_name, st.as_string());\n+  \/\/ If new_exception returns a different exception while creating the exception,\n+  \/\/ abandon the attempt to save the initialization error and return null.\n+  if (init_error->klass()->name() != exception_name) {\n@@ -2758,1 +2747,1 @@\n-                          h_cause->klass()->external_name());\n+                        init_error->klass()->external_name());\n@@ -2761,4 +2750,23 @@\n-  java_lang_Throwable::set_stacktrace(h_cause(), stack_trace());\n-  \/\/ Clear backtrace because the stacktrace should be used instead.\n-  set_backtrace(h_cause(), NULL);\n-  return h_cause;\n+\n+  \/\/ Call to java to fill in the stack trace and clear declaringClassObject to\n+  \/\/ not keep classes alive in the stack trace.\n+  \/\/ call this:  public StackTraceElement[] getStackTrace()\n+  JavaValue result(T_ARRAY);\n+  JavaCalls::call_virtual(&result, throwable,\n+                          vmClasses::Throwable_klass(),\n+                          vmSymbols::getStackTrace_name(),\n+                          vmSymbols::getStackTrace_signature(),\n+                          current);\n+  if (!current->has_pending_exception()){\n+    Handle stack_trace(current, result.get_oop());\n+    assert(stack_trace->is_objArray(), \"Should be an array\");\n+    java_lang_Throwable::set_stacktrace(init_error(), stack_trace());\n+    \/\/ Clear backtrace because the stacktrace should be used instead.\n+    set_backtrace(init_error(), nullptr);\n+  } else {\n+    log_info(class, init)(\"Exception thrown while getting stack trace for initialization exception %s\",\n+                        init_error->klass()->external_name());\n+    current->clear_pending_exception();\n+  }\n+\n+  return init_error;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":38,"deletions":30,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -572,1 +572,1 @@\n-  static Handle get_cause_with_stack_trace(Handle throwable, TRAPS);\n+  static Handle create_initialization_error(JavaThread* current, Handle throwable);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1038,3 +1038,4 @@\n-  Handle cause = java_lang_Throwable::get_cause_with_stack_trace(exception, THREAD);\n-  if (HAS_PENDING_EXCEPTION || cause.is_null()) {\n-    CLEAR_PENDING_EXCEPTION;\n+  Handle init_error = java_lang_Throwable::create_initialization_error(current, exception);\n+  ResourceMark rm(THREAD);\n+  if (init_error.is_null()) {\n+    log_trace(class, init)(\"Initialization error is null for class %s\", external_name());\n@@ -1045,2 +1046,2 @@\n-  OopHandle elem = OopHandle(Universe::vm_global(), cause());\n-  bool created = false;\n+  OopHandle elem = OopHandle(Universe::vm_global(), init_error());\n+  bool created;\n@@ -1049,1 +1050,0 @@\n-  ResourceMark rm(THREAD);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}