{"files":[{"patch":"@@ -1,198 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-\n-# @test\n-# @bug 4212732\n-# @summary Test handling of the Class-Path attribute in jar file manifests\n-# @author Martin Buchholz\n-#\n-# @run shell Class-Path.sh\n-\n-# To run this test manually, simply do .\/Class-Path.sh\n-\n-. ${TESTSRC-.}\/Util.sh\n-\n-set -u\n-\n-Cleanup() {\n-    Sys rm -rf pkg Main.java Main.class Main.jar jars\n-    Sys rm -rf MANIFEST.MF A.jar B.zip\n-}\n-\n-Cleanup\n-Sys mkdir pkg\n-\n-#----------------------------------------------------------------\n-# Create mutually referential jar files\n-#----------------------------------------------------------------\n-cat >pkg\/A.java <<EOF\n-package pkg;\n-import pkg.B;\n-public class A {\n-    public static int f() { return B.g(); }\n-    public static int g() { return 0; }\n-}\n-EOF\n-\n-cat >pkg\/B.java <<EOF\n-package pkg;\n-import pkg.A;\n-public class B {\n-    public static int f() { return A.g(); }\n-    public static int g() { return 0; }\n-}\n-EOF\n-\n-Sys \"$javac\" ${TESTTOOLVMOPTS} pkg\/A.java pkg\/B.java\n-\n-MkManifestWithClassPath \"B.zip\"\n-Sys \"$jar\" cmf MANIFEST.MF A.jar pkg\/A.class\n-\n-MkManifestWithClassPath \"A.jar\"\n-Sys \"$jar\" cmf MANIFEST.MF B.zip pkg\/B.class\n-\n-cat >Main.java <<EOF\n-import pkg.*;\n-public class Main {\n-    public static void main(String []a) { System.exit(A.f() + B.f()); }\n-}\n-EOF\n-\n-Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"A.jar\" Main.java\n-Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"B.zip\" Main.java\n-Success \"$java\" ${TESTVMOPTS}  -cp \"A.jar${PS}.\" Main\n-Success \"$java\" ${TESTVMOPTS}  -cp \"B.zip${PS}.\" Main\n-\n-#----------------------------------------------------------------\n-# Jar file Class-Path expanded only for jars found on user class path\n-#----------------------------------------------------------------\n-Sys mkdir jars\n-Sys mv A.jar B.zip jars\/.\n-Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"jars\/A.jar\"       Main.java\n-Success \"$java\" ${TESTVMOPTS}  -cp \"jars\/A.jar${PS}.\" Main\n-\n-Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"jars\/B.zip\"       Main.java\n-Success \"$java\" ${TESTVMOPTS}  -cp \"jars\/B.zip${PS}.\" Main\n-\n-# Success \"$javac\" ${TESTTOOLVMOPTS} -extdirs \"jars\"        -cp None Main.java\n-# Success \"$javac\" ${TESTTOOLVMOPTS} -Djava.ext.dirs=\"jars\" -cp None Main.java\n-# Success \"$java\" ${TESTVMOPTS}  -Djava.ext.dirs=\"jars\" -cp .    Main\n-\n-# Success \"$javac\" ${TESTTOOLVMOPTS} -endorseddirs \"jars\"        -cp None Main.java\n-# Success \"$javac\" ${TESTTOOLVMOPTS} -Djava.endorsed.dirs=\"jars\" -cp None Main.java\n-# Success \"$java\" ${TESTVMOPTS}  -Djava.endorsed.dirs=\"jars\" -cp .    Main\n-\n-Failure \"$java\" ${TESTVMOPTS}  -Xbootclasspath\/p:\"jars\/A.jar\" -cp .    Main\n-Failure \"$java\" ${TESTVMOPTS}  -Xbootclasspath\/a:\"jars\/B.zip\" -cp .    Main\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -Xbootclasspath\/p:\"jars\/A.jar\" -cp None Main.java\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -Xbootclasspath\/a:\"jars\/B.zip\" -cp None Main.java\n-Sys mv jars\/A.jar jars\/B.zip .\n-\n-MkManifestWithClassPath \"A.jar\"\n-echo \"Main-Class: Main\" >> MANIFEST.MF\n-Sys \"$jar\" cmf MANIFEST.MF Main.jar Main.class\n-\n-Success \"$java\" ${TESTVMOPTS} -jar Main.jar\n-\n-MkManifestWithClassPath \".\"\n-Sys \"$jar\" cmf MANIFEST.MF A.jar pkg\/A.class\n-\n-Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"A.jar\" Main.java\n-Success \"$java\" ${TESTVMOPTS} -jar Main.jar\n-\n-MkManifestWithClassPath \"\"\n-Sys \"$jar\" cmf MANIFEST.MF A.jar pkg\/A.class\n-\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -cp \"A.jar\" Main.java\n-Failure \"$java\" ${TESTVMOPTS} -jar Main.jar\n-\n-#----------------------------------------------------------------\n-# Test new flag -e (application entry point)\n-#----------------------------------------------------------------\n-\n-cat > Hello.java <<EOF\n-import pkg.*;\n-public class Hello {\n-    public static void main(String []a) { System.out.println(\"Hello World!\"); }\n-}\n-EOF\n-\n-cat > Bye.java <<EOF\n-import pkg.*;\n-public class Bye {\n-    public static void main(String []a) { System.out.println(\"Good Bye!\"); }\n-}\n-EOF\n-\n-Success \"$javac\" ${TESTTOOLVMOPTS} Hello.java Bye.java\n-\n-# test jar creation without manifest\n-#\n-Success \"$jar\" cfe \"Hello.jar\" \"Hello\" Hello.class\n-Success \"$java\" ${TESTVMOPTS} -jar Hello.jar\n-\n-# test for overriding the manifest during jar creation\n-#\n-echo \"Main-Class: Hello\" >> MANIFEST.MF\n-\n-# test for error: \" 'e' flag and manifest with the 'Main-Class' \n-# attribute cannot be specified together, during creation\n-Failure \"$jar\" cmfe  MANIFEST.MF \"Bye.jar\" \"Bye\" Bye.class\n-\n-# test for overriding the manifest when updating the jar\n-#\n-Success \"$jar\" cfe \"greetings.jar\" \"Hello\" Hello.class\n-Success \"$jar\" ufe \"greetings.jar\" \"Bye\" Bye.class\n-Success \"$java\" ${TESTVMOPTS} -jar greetings.jar\n-\n-# test for error: \" 'e' flag and manifest with the 'Main-Class'\n-# attribute cannot be specified together, during update\n-Failure \"$jar\" umfe  MANIFEST.MF \"greetings.jar\" \"Hello\"\n-\n-# test jar updation when there are no inputfiles \n-#\n-Success \"$jar\" ufe \"Hello.jar\" \"Bye\"\n-Failure \"$java\" ${TESTVMOPTS} -jar Hello.jar\n-Success \"$jar\" umf  MANIFEST.MF \"Hello.jar\"\n-\n-# test creating jar when the to-be-archived files\n-# do not contain the specified main class, there is no check done\n-# for the presence of the main class, so the test will pass\n-#\n-Success \"$jar\" cfe \"Hello.jar\" \"Hello\" Bye.class\n-\n-# Jar creation and update when there is no manifest and inputfiles \n-# specified\n-Failure \"$jar\" cvf \"A.jar\"\n-Failure \"$jar\" uvf \"A.jar\"\n-\n-# error: no such file or directory\n-Failure \"$jar\" cvf \"A.jar\" non-existing.file\n-Failure \"$jar\" uvf \"A.jar\" non-existing.file\n-\n-Cleanup\n-\n-Bottom Line\n","filename":"test\/langtools\/tools\/javac\/Paths\/Class-Path.sh","additions":0,"deletions":198,"binary":false,"changes":198,"status":"deleted"},{"patch":"@@ -1,111 +0,0 @@\n-#!\/bin\/sh\n-#\n-# Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# @test \n-# @bug 4212732 6485027\n-# @summary Test handling of the Class-Path attribute in jar file manifests\n-# @author Martin Buchholz\n-#\n-# @run shell Class-Path2.sh\n-\n-# To run this test manually, simply do .\/Class-Path2.sh\n-\n-. ${TESTSRC-.}\/Util.sh\n-\n-set -u\n-\n-Cleanup() {\n-    Sys rm -rf pkg Main.java Main.class Main.jar jars\n-    Sys rm -rf MANIFEST.MF A.jar B.zip\n-}\n-\n-Cleanup\n-Sys mkdir pkg\n-\n-#----------------------------------------------------------------\n-# Create mutually referential jar files\n-#----------------------------------------------------------------\n-cat >pkg\/A.java <<EOF\n-package pkg;\n-import pkg.B;\n-public class A {\n-    public static int f() { return B.g(); }\n-    public static int g() { return 0; }\n-}\n-EOF\n-\n-cat >pkg\/B.java <<EOF\n-package pkg;\n-import pkg.A;\n-public class B {\n-    public static int f() { return A.g(); }\n-    public static int g() { return 0; }\n-}\n-EOF\n-\n-Sys \"$javac\" pkg\/A.java pkg\/B.java\n-\n-MkManifestWithClassPath \".\/sub\/B.zip\"\n-Sys \"$jar\" cmf MANIFEST.MF A.jar pkg\/A.class\n-\n-MkManifestWithClassPath \"..\/A.jar\"\n-Sys \"$jar\" cmf MANIFEST.MF B.zip pkg\/B.class\n-\n-cat >Main.java <<EOF\n-import pkg.*;\n-public class Main {\n-    public static void main(String []a) { System.exit(A.f() + B.f()); }\n-}\n-EOF\n-\n-Sys rm -rf pkg\n-\n-Sys mkdir jars\n-Sys mkdir jars\/sub\/\n-Sys mv A.jar jars\/.\n-Sys mv B.zip jars\/sub\/.\n-\n-#\n-# Test 1: Compiling \n-#\n-\n-Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"jars\/A.jar\" Main.java\n-Success \"$java\"  ${TESTVMOPTS}     -cp \"jars\/A.jar${PS}.\" Main\n-\n-Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"jars\/sub\/B.zip\"       Main.java\n-Success \"$java\"  ${TESTVMOPTS}     -cp \"jars\/sub\/B.zip${PS}.\" Main\n-\n-#\n-# Test 2: Use of extension directories is incorrect\n-#\n-\n-# Success \"$javac\" ${TESTTOOLVMOPTS} -extdirs jars          -cp None Main.java\n-# Success \"$java\"  ${TESTVMOPTS}     -Djava.ext.dirs=\"jars\" -cp .    Main\n-\n-# Success \"$javac\" ${TESTTOOLVMOPTS} -extdirs jars\/sub          -cp None Main.java\n-# Success \"$java\"  ${TESTVMOPTS}     -Djava.ext.dirs=\"jars\/sub\" -cp .    Main\n-\n-Cleanup\n-\n-Bottom Line\n","filename":"test\/langtools\/tools\/javac\/Paths\/Class-Path2.sh","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 4212732 8293877\n+ * @summary Test handling of the Class-Path attribute in jar file manifests\n+ * @library \/tools\/lib\n+ * @build toolbox.ToolBox Util ClassPath\n+ * @run main ClassPath\n+*\/\n+\n+\n+\/*\n+ * Converted from Class-Path.sh, originally written by Martin Buchholz.\n+ *\n+ * For the last version of the original, Class-Path.sh, see\n+ * https:\/\/github.com\/openjdk\/jdk\/blob\/jdk-19%2B36\/test\/langtools\/tools\/javac\/Paths\/Class-Path.sh\n+ *\n+ * This class primarily tests that the Class-Path attribute in jar files\n+ * is handled the same way by javac and java. It also has various tests\n+ * of the jar tool itself.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+\n+public class ClassPath extends Util {\n+    public static void main(String... args) throws Exception {\n+        new ClassPath().run(args);\n+    }\n+\n+    void run(String... args) throws Exception {\n+        setup();\n+        tests();\n+        cleanup();\n+        bottomLine();\n+    }\n+\n+    void setup() throws Exception {\n+        cleanup();\n+        tb.createDirectories(\"pkg\");\n+\n+        \/*----------------------------------------------------------------\n+         * Create mutually referential jar files\n+         *----------------------------------------------------------------*\/\n+\n+        Files.writeString(Path.of(\"pkg\/A.java\"), \"\"\"\n+                package pkg;\n+                import pkg.B;\n+                public class A {\n+                    public static int f() { return B.g(); }\n+                    public static int g() { return 0; }\n+                }\n+                \"\"\");\n+        Files.writeString(Path.of(\"pkg\/B.java\"), \"\"\"\n+                package pkg;\n+                import pkg.A;\n+                public class B {\n+                    public static int f() { return A.g(); }\n+                    public static int g() { return 0; }\n+                }\n+                \"\"\");\n+\n+        javac(\"pkg\/A.java\", \"pkg\/B.java\");\n+\n+        makeManifestWithClassPath(\"B.zip\");\n+        jar(\"cmf\", \"MANIFEST.MF\", \"A.jar\", \"pkg\/A.class\");\n+\n+        makeManifestWithClassPath(\"A.jar\");\n+        jar(\"cmf\", \"MANIFEST.MF\", \"B.zip\", \"pkg\/B.class\");\n+\n+        Files.writeString(Path.of(\"Main.java\"), \"\"\"\n+                import pkg.*;\n+                public class Main {\n+                    public static void main(String[] a) { System.exit(A.f() + B.f()); }\n+                }\n+                \"\"\");\n+    }\n+\n+    void cleanup() throws IOException {\n+        deleteFiles(\"pkg\", \"Main.java\", \"Main.class\", \"Main.jar\", \"jars\");\n+        deleteFiles(\"MANIFEST.MF\", \"A.jar\", \"B.zip\");\n+    }\n+\n+    void tests() throws Exception {\n+        expectPass(JAVAC, \"-cp A.jar Main.java\");\n+        expectPass(JAVAC, \"-cp B.zip Main.java\");\n+        expectPass(JAVA, \"-cp A.jar${PS}. Main\");\n+        expectPass(JAVA, \"-cp B.zip${PS}. Main\");\n+\n+        \/*----------------------------------------------------------------\n+         * Jar file Class-Path expanded only for jars found on user class path\n+         *----------------------------------------------------------------*\/\n+\n+        tb.createDirectories(\"jars\");\n+        moveFiles(List.of(\"A.jar\", \"B.zip\"), \"jars\/.\");\n+\n+        expectPass(JAVAC, \"-cp jars\/A.jar Main.java\");\n+        expectPass(JAVA, \"-cp jars\/A.jar${PS}. Main\");\n+\n+        expectPass(JAVAC, \"-cp jars\/B.zip Main.java\");\n+        expectPass(JAVA, \"-cp jars\/B.zip${PS}. Main\");\n+\n+        expectFail(JAVA, \"-Xbootclasspath\/p:jars\/A.jar -cp .    Main\");\n+        expectFail(JAVA, \"-Xbootclasspath\/a:jars\/B.zip -cp .    Main\");\n+        expectFail(JAVAC, \"-Xbootclasspath\/p:jars\/A.jar -cp None Main.java\");\n+        expectFail(JAVAC, \"-Xbootclasspath\/a:jars\/B.zip -cp None Main.java\");\n+        moveFiles(List.of(\"jars\/A.jar\", \"jars\/B.zip\"), \".\");\n+\n+        makeManifestWithClassPath(\"A.jar\");\n+        Files.writeString(Path.of(\"MANIFEST.MF\"), \"Main-Class: Main\\n\", StandardOpenOption.APPEND);\n+        jar(\"cmf\", \"MANIFEST.MF\", \"Main.jar\", \"Main.class\");\n+\n+        expectPass(JAVA, \"-jar Main.jar\");\n+\n+        makeManifestWithClassPath(\".\");\n+        jar(\"cmf\", \"MANIFEST.MF\", \"A.jar\", \"pkg\/A.class\");\n+\n+        expectPass(JAVAC, \"-cp A.jar Main.java\");\n+        expectPass(JAVA, \"-jar Main.jar\");\n+\n+        makeManifestWithClassPath(\"\");\n+        jar(\"cmf\", \"MANIFEST.MF\", \"A.jar\", \"pkg\/A.class\");\n+\n+        expectFail(JAVAC, \"-cp A.jar Main.java\");\n+        expectFail(JAVA, \"-jar Main.jar\");\n+\n+        \/*----------------------------------------------------------------\n+         * Test new flag -e (application entry point)\n+         *----------------------------------------------------------------*\/\n+\n+        Files.writeString(Path.of(\"Hello.java\"), \"\"\"\n+                import pkg.*;\n+                public class Hello {\n+                    public static void main(String[] a) { System.out.println(\"Hello World!\"); }\n+                }\n+                \"\"\");\n+\n+        Files.writeString(Path.of(\"Bye.java\"), \"\"\"\n+                import pkg.*;\n+                public class Bye {\n+                    public static void main(String[] a) { System.out.println(\"Good Bye!\"); }\n+                }\n+                \"\"\");\n+\n+        \/\/ Set an empty classpath to override any inherited setting of CLASSPATH\n+        expectPass(classpath(\"\"), JAVAC, \"Hello.java Bye.java\");\n+\n+        \/\/ test jar creation without manifest\n+        \/\/\n+        expectPass(JAR, \"cfe Hello.jar Hello Hello.class\");\n+        expectPass(JAVA, \"-jar Hello.jar\");\n+\n+        \/\/ test for overriding the manifest during jar creation\n+        \/\/\n+        Files.writeString(Path.of(\"MANIFEST.MF\"), \"Main-Class: Hello\\n\", StandardOpenOption.APPEND);\n+\n+        \/\/ test for error: \" 'e' flag and manifest with the 'Main-Class'\n+        \/\/ attribute cannot be specified together, during creation\n+        expectFail(JAR, \"cmfe MANIFEST.MF Bye.jar Bye Bye.class\");\n+\n+        \/\/ test for overriding the manifest when updating the jar\n+        \/\/\n+        expectPass(JAR, \"cfe greetings.jar Hello Hello.class\");\n+        expectPass(JAR, \"ufe greetings.jar Bye Bye.class\");\n+        expectPass(JAVA, \"-jar greetings.jar\");\n+\n+        \/\/ test for error: \" 'e' flag and manifest with the 'Main-Class'\n+        \/\/ attribute cannot be specified together, during update\n+        expectFail(JAR, \"umfe MANIFEST.MF greetings.jar Hello\");\n+\n+        \/\/ test jar update when there are no input files\n+        expectPass(JAR, \"ufe Hello.jar Bye\");\n+        expectFail(JAVA, \"-jar Hello.jar\");\n+        expectPass(JAR, \"umf MANIFEST.MF Hello.jar\");\n+\n+        \/\/ test creating jar when the to-be-archived files\n+        \/\/ do not contain the specified main class, there is no check done\n+        \/\/ for the presence of the main class, so the test will pass\n+        \/\/\n+        expectPass(JAR, \"cfe Hello.jar Hello Bye.class\");\n+\n+        \/\/ Jar creation and update when there is no manifest and inputfiles\n+        \/\/ specified\n+        expectFail(JAR, \"cvf A.jar\");\n+        expectFail(JAR, \"uvf A.jar\");\n+\n+        \/\/ error: no such file or directory\n+        expectFail(JAR, \"cvf A.jar non-existing.file\");\n+        expectFail(JAR, \"uvf A.jar non-existing.file\");\n+\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/Paths\/ClassPath.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4212732 6485027 8293877\n+ * @summary Test handling of the Class-Path attribute in jar file manifests\n+ * @library \/tools\/lib\n+ * @build toolbox.ToolBox Util ClassPath\n+ * @run main ClassPath2\n+ *\/\n+\n+\/*\n+ * Converted from Class-Path2.sh, originally written by Martin Buchholz.\n+ *\n+ * For the last version of the original, Class-Path2.sh, see\n+ * https:\/\/github.com\/openjdk\/jdk\/blob\/jdk-19%2B36\/test\/langtools\/tools\/javac\/Paths\/Class-Path2.sh\n+ *\n+ * This class provides additional tests for the Class-Path attribute in jar\n+ * files, when the entries are not in the same directory.\n+ *\/\n+\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class ClassPath2 extends Util {\n+    public static void main(String... args) throws Exception {\n+        new ClassPath2().run(args);\n+    }\n+\n+    void run(String... args) throws Exception {\n+        setup();\n+        tests();\n+        cleanup();\n+        bottomLine();\n+    }\n+\n+    void setup() throws Exception {\n+        cleanup();\n+\n+        tb.createDirectories(\"pkg\");\n+\n+        \/*----------------------------------------------------------------\n+         * Create mutually referential jar files\n+         *----------------------------------------------------------------*\/\n+\n+        Files.writeString(Path.of(\"pkg\/A.java\"), \"\"\"\n+                package pkg;\n+                import pkg.B;\n+                public class A {\n+                    public static int f() { return B.g(); }\n+                    public static int g() { return 0; }\n+                }\n+                \"\"\");\n+        Files.writeString(Path.of(\"pkg\/B.java\"), \"\"\"\n+                package pkg;\n+                import pkg.A;\n+                public class B {\n+                    public static int f() { return A.g(); }\n+                    public static int g() { return 0; }\n+                }\n+                \"\"\");\n+\n+        javac(\"pkg\/A.java\", \"pkg\/B.java\");\n+\n+        makeManifestWithClassPath(\".\/sub\/B.zip\");\n+        jar(\"cmf\", \"MANIFEST.MF\", \"A.jar\", \"pkg\/A.class\");\n+\n+        makeManifestWithClassPath(\"..\/A.jar\");\n+        jar(\"cmf\", \"MANIFEST.MF\", \"B.zip\", \"pkg\/B.class\");\n+\n+        Files.writeString(Path.of(\"Main.java\"), \"\"\"\n+                import pkg.*;\n+                public class Main {\n+                    public static void main(String[] a) { System.exit(A.f() + B.f()); }\n+                }\n+                \"\"\");\n+\n+        deleteFiles(\"pkg\");\n+        tb.createDirectories(\"jars\");\n+        tb.createDirectories(\"jars\/sub\");\n+        tb.moveFile(\"A.jar\", \"jars\/.\");\n+        tb.moveFile(\"B.zip\", \"jars\/sub\/.\");\n+    }\n+\n+    void cleanup() throws IOException {\n+        deleteFiles(\"pkg\", \"Main.java\", \"Main.class\", \"Main.jar\", \"jars\");\n+        deleteFiles(\"MANIFEST.MF\", \"A.jar\", \"B.zip\");\n+    }\n+\n+    void tests() throws Exception {\n+\n+        \/*\n+         * Test 1: Compiling\n+         *\/\n+\n+        expectPass(JAVAC, \"-cp jars\/A.jar Main.java\");\n+        expectPass(JAVA, \"-cp jars\/A.jar${PS}. Main\");\n+\n+        expectPass(JAVAC, \"-cp jars\/sub\/B.zip Main.java\");\n+        expectPass(JAVA, \"-cp jars\/sub\/B.zip${PS}. Main\");\n+\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/Paths\/ClassPath2.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4884487 6295519 6236704 6429613 8293877\n+ * @summary Test for proper diagnostics during path manipulation operations\n+ * @library \/tools\/lib\n+ * @build toolbox.ToolBox Util Diagnostics\n+ * @run main Diagnostics\n+ *\/\n+\n+\n+\/*\n+ * Converted from Diagnostics.sh, originally written by Martin Buchholz.\n+ *\n+ * For the last version of the original, Diagnostics.sh, see\n+ * https:\/\/github.com\/openjdk\/jdk\/blob\/jdk-19%2B36\/test\/langtools\/tools\/javac\/Paths\/Diagnostics.sh\n+ *\n+ * This class primarily tests that javac generates warnings or errors\n+ * as appropriate for various input conditions.\n+ *\n+ * Note: only the {@code warning:} or {@code error:} prefixes are checked,\n+ * and not the subsequent text of the diagnostic.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Locale;\n+\n+public class Diagnostics extends Util {\n+    public static void main(String... args) throws Exception {\n+        new Diagnostics().run(args);\n+    }\n+\n+    void run(String... args) throws Exception{\n+        setup();\n+\n+        Locale prev = Locale.getDefault();\n+        Locale.setDefault(Locale.US); \/\/ diagnostics in English, please!\n+        try {\n+            tests();\n+        } finally {\n+            Locale.setDefault(prev);\n+        }\n+\n+        cleanup();\n+        bottomLine();\n+    }\n+\n+    void setup() throws IOException {\n+        cleanup();\n+        Files.writeString(Path.of(\"Main.java\"), \"public class Main{public static void main(String[]a){}}\");\n+    }\n+\n+    void cleanup() throws IOException {\n+        deleteFiles(\"Main.java\", \"Main.class\");\n+        deleteFiles(\"classes\", \"classes.foo\", \"classes.jar\", \"classes.war\", \"classes.zip\");\n+        deleteFiles(\"MANIFEST.MF\", \"classesRef.jar\", \"classesRefRef.jar\", \"jars\");\n+    }\n+\n+    void tests() throws Exception {\n+        \/*----------------------------------------------------------------\n+         * No warnings unless -Xlint:path is used\n+         *----------------------------------------------------------------*\/\n+        checkWarning(false, \"Main.java\");\n+        checkWarning(false, \"-cp .${PS}classes Main.java\");\n+\n+        \/*----------------------------------------------------------------\n+         * Warn for missing elts in user-specified paths\n+         *----------------------------------------------------------------*\/\n+\n+        \/\/ use --source 8 -target 8 with bootclasspath-related options\n+        String JDK8 = \"-source 8 -target 8 -Xlint:-options \";\n+        checkWarning(true, \"-Xlint:path -cp .${PS}classes         Main.java\");\n+        checkWarning(true, JDK8 + \"-Xlint:path -Xbootclasspath\/p:classes Main.java\");\n+        checkWarning(true, JDK8 + \"-Xlint      -Xbootclasspath\/a:classes Main.java\");\n+\n+        checkWarning(true, JDK8 + \"-Xlint:-options -Xlint:path -endorseddirs classes   Main.java\");\n+        checkWarning(true, JDK8 + \"-Xlint:-options -Xlint      -extdirs      classes   Main.java\");\n+\n+        \/*----------------------------------------------------------------\n+         * No warning for missing elts in \"system\" paths\n+         *----------------------------------------------------------------*\/\n+        \/\/ TODO? there are system paths we could check, such as --module-path\n+\n+        \/*----------------------------------------------------------------\n+         * No warning if class path element exists\n+         *----------------------------------------------------------------*\/\n+        tb.createDirectories(\"classes\");\n+\n+        checkWarning(false, \"-Xlint:path -cp .${PS}classes         Main.java\");\n+        checkWarning(false, JDK8 + \"-Xlint:path -endorseddirs  classes Main.java\");\n+        checkWarning(false, JDK8 + \"-Xlint:path -extdirs       classes Main.java\");\n+        checkWarning(false, JDK8 + \"-Xlint:path -Xbootclasspath\/p:classes Main.java\");\n+        checkWarning(false, JDK8 + \"-Xlint:path -Xbootclasspath\/a:classes Main.java\");\n+\n+        jar(\"cf\", \"classes.jar\", \"Main.class\");\n+        tb.copyFile(\"classes.jar\", \"classes.war\");\n+        tb.copyFile(\"classes.war\", \"classes.zip\");\n+        checkWarning(false, \"-Xlint:path -cp .${PS}classes.jar     Main.java\");\n+        checkWarning(true,  \"-Xlint:path -cp .${PS}classes.war     Main.java\");\n+        checkWarning(false, \"-Xlint:path -cp .${PS}classes.zip     Main.java\");\n+\n+        \/*----------------------------------------------------------------\n+         * Warn if -Xlint is used and if class path element refers to\n+         * regular file which doesn't look like a zip file, but is\n+         *----------------------------------------------------------------*\/\n+        tb.copyFile(\"classes.war\", \"classes.foo\");\n+        checkWarning(true, \"-Xlint:path -cp .${PS}classes.foo     Main.java\");\n+\n+        \/*----------------------------------------------------------------\n+         * No error if class path element refers to regular file which is\n+         * not a zip file\n+         *----------------------------------------------------------------*\/\n+        checkError(false, \"-cp Main.java Main.java\"); \/\/ Main.java is NOT a jar file\n+        checkError(false, \"Main.java\");\n+\n+        \/*----------------------------------------------------------------\n+         * Warn if -Xlint is used and if class path element refers to\n+         * regular file which is not a zip file\n+         *----------------------------------------------------------------*\/\n+        checkWarning(true, \"-Xlint -cp Main.java Main.java\"); \/\/ Main.java is NOT a jar file\n+\n+        \/*----------------------------------------------------------------\n+         * Test jar file class path reference recursion\n+         *----------------------------------------------------------------*\/\n+        makeManifestWithClassPath(\"classesRef.jar\");\n+        jar(\"cmf\", \"MANIFEST.MF\", \"classesRefRef.jar\", \"Main.class\");\n+\n+        \/*----------------------------------------------------------------\n+         * Non-existent recursive Class-Path reference gives warning\n+         *----------------------------------------------------------------*\/\n+        checkWarning(false, \"                   -classpath   classesRefRef.jar Main.java\");\n+        checkWarning(true, \"        -Xlint      -classpath   classesRefRef.jar Main.java\");\n+        checkWarning(false, JDK8 + \"-Xlint -Xbootclasspath\/p:classesRefRef.jar Main.java\");\n+\n+        createBadJarFiles(\"classesRef.jar\");\n+\n+        \/*----------------------------------------------------------------\n+         * Non-jar file recursive Class-Path reference gives error\n+         *----------------------------------------------------------------*\/\n+\n+        checkError(true, \"        -classpath        classesRefRef.jar Main.java\");\n+        checkError(false, JDK8 + \"-Xbootclasspath\/a:classesRefRef.jar Main.java\");\n+\n+        makeManifestWithClassPath(\"classes\");\n+        jar(\"cmf\", \"MANIFEST.MF\", \"classesRef.jar\", \"Main.class\");\n+\n+        \/*----------------------------------------------------------------\n+         * Jar file recursive Class-Path reference is OK\n+         *----------------------------------------------------------------*\/\n+        checkWarning(false, \"       -Xlint      -classpath   classesRefRef.jar Main.java\");\n+        checkWarning(false, JDK8 + \"-Xlint -Xbootclasspath\/p:classesRefRef.jar Main.java\");\n+\n+\n+        \/*----------------------------------------------------------------\n+         * Class-Path attribute followed in extdirs or endorseddirs\n+         *----------------------------------------------------------------*\/\n+        tb.createDirectories(\"jars\");\n+        tb.copyFile(\"classesRefRef.jar\", \"jars\/.\");\n+        checkWarning(true, JDK8 + \"-Xlint -extdirs      jars Main.java\");\n+        checkWarning(true, JDK8 + \"-Xlint -endorseddirs jars Main.java\");\n+\n+        \/*----------------------------------------------------------------\n+         * Bad Jar file in extdirs and endorseddirs should not be ignored\n+         *----------------------------------------------------------------*\/\n+        createBadJarFiles(\"jars\/classesRef.jar\");\n+        checkError(true, JDK8 + \"-Xlint -extdirs      jars Main.java\");\n+        checkError(true, JDK8 + \"-Xlint -endorseddirs jars Main.java\");\n+    }\n+\n+    void checkWarning(boolean expect, String args) throws Exception {\n+        Result result = javac(splitArgs(args));\n+        int exitCode = result.exitCode();\n+        if (exitCode != 0) {\n+            throw new Exception(\"javac failed: exit code \" + exitCode);\n+        }\n+        String output = result.out();\n+        if (output.contains(\"warning:\")) {\n+            if (!expect) {\n+                out.println(\"FAIL: Command 'javac \" + args + \"' printed an unexpected warning\");\n+                failCount++;\n+            } else {\n+                passCount++;\n+            }\n+        } else {\n+            if (expect) {\n+                out.println(\"FAIL: Command 'javac \" + args + \"' did not generate the expected warning\");\n+                failCount++;\n+            } else {\n+                passCount++;\n+            }\n+        }\n+    }\n+\n+    void checkError(boolean expect, String args) throws Exception {\n+        Result result = javac(splitArgs(args));\n+        int exitCode = result.exitCode();\n+        boolean ok = true;\n+        if (expect) {\n+            if (exitCode == 0) {\n+                out.println(\"FAIL: Command 'javac \" + args + \" was supposed to exit with non-zero return code\");\n+                ok = false;\n+            }\n+            if (!result.out().contains(\"error:\")) {\n+                out.println(\"FAIL: Command 'javac \" + args + \" did not generate any error message\");\n+                ok = false;\n+            }\n+        } else {\n+            if (exitCode != 0) {\n+                out.println(\"FAIL: Command 'javac \" + args + \" failed with a non-zero return code\");\n+                ok = false;\n+            }\n+            if (result.out().contains(\"error:\")) {\n+                out.println(\"FAIL: Command 'javac \" + args + \" printed an unexpected error message\");\n+                ok = false;\n+            }\n+        }\n+        if (ok) {\n+            passCount++;\n+        } else {\n+            failCount++;\n+        }\n+    }\n+\n+    void createBadJarFiles(String... paths) throws IOException {\n+        for (String p : paths) {\n+            Files.writeString(Path.of(p), \"not a jar file\\n\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/Paths\/Diagnostics.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -1,210 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-# @test\n-# @bug 4884487 6295519 6236704 6429613\n-# @summary Test for proper diagnostics during path manipulation operations\n-# @author Martin Buchholz\n-#\n-# @run shell\/timeout=180 Diagnostics.sh\n-\n-# To run this test manually, simply do .\/Diagnostics.sh\n-\n-. ${TESTSRC-.}\/Util.sh\n-\n-set -u\n-\n-# BCP=`DefaultBootClassPath`\n-\n-DiagnosticsInEnglishPlease\n-\n-No() { NO=\"no\"; \"$@\"; NO=\"\"; }  # No means NO!\n-\n-Warning() {\n-    HorizontalRule\n-    echo \"$@\"\n-    output=`\"$@\" 2>&1`; rc=\"$?\"\n-    output2=`echo \"$output\" | grep -v \"bootstrap class path not set in conjunction with -source\"`\n-    test -n \"$output2\" && echo \"$output\"\n-    test $rc -eq 0 || Fail \"Command \\\"$*\\\" failed with exitValue $rc\";\n-    case \"$output2\" in *warning:*) gotwarning=\"yes\";; *) gotwarning=\"no\";; esac\n-\n-    if test \"$gotwarning\" = \"yes\" -a \"$NO\" = \"no\"; then\n-        Fail \"Command \\\"$*\\\" printed an unexpected warning\"\n-    elif test \"$gotwarning\" = \"no\" -a \"$NO\" != \"no\"; then\n-        Fail \"Command \\\"$*\\\" did not generate the expected warning\"\n-    fi\n-}\n-\n-Error() {\n-    HorizontalRule\n-    echo \"$@\"\n-    output=`\"$@\" 2>&1`; rc=\"$?\"\n-    test -n \"$output\" && echo \"$output\"\n-    case \"$output\" in *error:*) goterror=\"yes\";; *) goterror=\"no\";; esac\n-\n-    if test \"$NO\" = \"no\"; then\n-        test \"$rc\" -ne 0 && \\\n-            Fail \"Command \\\"$*\\\" failed with return code $rc\"\n-        test \"$goterror\" = \"yes\" && \\\n-            Fail \"Command \\\"$*\\\" did not generate any error message\"\n-    else\n-        test \"$rc\" -eq 0 && \\\n-            Fail \"Command \\\"$*\\\" was supposed to Die with fatal error\";\n-        test \"$goterror\" = \"no\" && \\\n-            Fail \"Command \\\"$*\\\" printed an unexpected error message\"\n-    fi\n-}\n-\n-Cleanup() {\n-    Sys rm -rf Main.java Main.class\n-    Sys rm -rf classes classes.foo classes.jar classes.war classes.zip\n-    Sys rm -rf MANIFEST.MF classesRef.jar classesRefRef.jar jars\n-}\n-\n-Cleanup\n-echo \"public class Main{public static void main(String[]a){}}\" > Main.java\n-\n-# We need to set -source 8 -target 8 for those cases where the option is\n-# not legal in 9 and later. However, that triggers an additional warning\n-# about not setting bootclasspath, which is filtered out in Warning.\n-# The alternative would be to extract a minimal rt.jar from JDK and\n-# specify that with -bootclasspath.\n-SRCTRG8=\"-source 8 -target 8\"\n-\n-#----------------------------------------------------------------\n-# No warnings unless -Xlint:path is used\n-#----------------------------------------------------------------\n-No Warning \"$javac\" ${TESTTOOLVMOPTS} Main.java\n-No Warning \"$javac\" ${TESTTOOLVMOPTS} -cp \".${PS}classes\" Main.java\n-\n-#----------------------------------------------------------------\n-# Warn for missing elts in user-specified paths\n-#----------------------------------------------------------------\n-Warning \"$javac\" ${TESTTOOLVMOPTS}           -Xlint:path -cp \".${PS}classes\"         Main.java\n-Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint:path \"-Xbootclasspath\/p:classes\" Main.java\n-Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint      \"-Xbootclasspath\/a:classes\" Main.java\n-\n-Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint:path \"-endorseddirs\" \"classes\"   Main.java\n-Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint      \"-extdirs\"      \"classes\"   Main.java\n-#Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint:path \"-Xbootclasspath:classes${PS}${BCP}\" Main.java\n-\n-#----------------------------------------------------------------\n-# No warning for missing elts in \"system\" paths\n-#----------------------------------------------------------------\n-# No Warning \"$javac\" ${TESTTOOLVMOPTS} -Xlint:path \"-J-Djava.endorsed.dirs=classes\" Main.java\n-# No Warning \"$javac\" ${TESTTOOLVMOPTS} -Xlint:path \"-J-Djava.ext.dirs=classes\"      Main.java\n-# No Warning \"$javac\" ${TESTTOOLVMOPTS} -Xlint:path \"-J-Xbootclasspath\/p:classes\"    Main.java\n-# No Warning \"$javac\" ${TESTTOOLVMOPTS} -Xlint:path \"-J-Xbootclasspath\/a:classes\"    Main.java\n-# No Warning \"$javac\" ${TESTTOOLVMOPTS} -Xlint:path \"-J-Xbootclasspath:classes${PS}${BCP}\" Main.java\n-\n-#----------------------------------------------------------------\n-# No warning if class path element exists\n-#----------------------------------------------------------------\n-Sys mkdir classes\n-No Warning \"$javac\" ${TESTTOOLVMOPTS}           -Xlint:path -cp \".${PS}classes\"         Main.java\n-No Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint:path \"-endorseddirs\"   \"classes\" Main.java\n-No Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint:path \"-extdirs\"        \"classes\" Main.java\n-No Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint:path \"-Xbootclasspath\/p:classes\" Main.java\n-No Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint:path \"-Xbootclasspath\/a:classes\" Main.java\n-#No Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint:path \"-Xbootclasspath:classes${PS}${BCP}\" Main.java\n-\n-Sys \"$jar\" cf classes.jar Main.class\n-Sys cp classes.jar classes.war\n-Sys cp classes.war classes.zip\n-No Warning \"$javac\" ${TESTTOOLVMOPTS} -Xlint:path -cp \".${PS}classes.jar\"     Main.java\n-   Warning \"$javac\" ${TESTTOOLVMOPTS} -Xlint:path -cp \".${PS}classes.war\"     Main.java\n-No Warning \"$javac\" ${TESTTOOLVMOPTS} -Xlint:path -cp \".${PS}classes.zip\"     Main.java\n-\n-#----------------------------------------------------------------\n-# Warn if -Xlint is used and if class path element refers to\n-# regular file which doesn't look like a zip file, but is\n-#----------------------------------------------------------------\n-Sys cp classes.war classes.foo\n-   Warning \"$javac\" ${TESTTOOLVMOPTS} -Xlint:path -cp \".${PS}classes.foo\"     Main.java\n-\n-\n-#----------------------------------------------------------------\n-# No error if class path element refers to regular file which is\n-# not a zip file\n-#----------------------------------------------------------------\n-No Error \"$javac\" ${TESTTOOLVMOPTS} -cp Main.java Main.java # Main.java is NOT a jar file\n-No Error \"$javac\" ${TESTTOOLVMOPTS} Main.java\n-\n-#----------------------------------------------------------------\n-# Warn if -Xlint is used and if class path element refers to\n-# regular file which is not a zip file\n-#----------------------------------------------------------------\n-Warning \"$javac\" ${TESTTOOLVMOPTS} -Xlint -cp Main.java Main.java # Main.java is NOT a jar file\n-\n-#----------------------------------------------------------------\n-# Test jar file class path reference recursion\n-#----------------------------------------------------------------\n-MkManifestWithClassPath classesRef.jar\n-Sys \"$jar\" cmf MANIFEST.MF classesRefRef.jar Main.class\n-\n-#----------------------------------------------------------------\n-# Non-existent recursive Class-Path reference gives warning\n-#----------------------------------------------------------------\n-No Warning \"$javac\" ${TESTTOOLVMOPTS}                        -classpath   classesRefRef.jar Main.java\n-   Warning \"$javac\" ${TESTTOOLVMOPTS}            -Xlint      -classpath   classesRefRef.jar Main.java\n-No Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint -Xbootclasspath\/p:classesRefRef.jar Main.java\n-\n-BadJarFile classesRef.jar\n-\n-#----------------------------------------------------------------\n-# Non-jar file recursive Class-Path reference gives error\n-#----------------------------------------------------------------\n-   Error \"$javac\" ${TESTTOOLVMOPTS}            -classpath        classesRefRef.jar Main.java\n-No Error \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xbootclasspath\/a:classesRefRef.jar Main.java\n-\n-MkManifestWithClassPath classes\n-Sys \"$jar\" cmf MANIFEST.MF classesRef.jar Main.class\n-\n-#----------------------------------------------------------------\n-# Jar file recursive Class-Path reference is OK\n-#----------------------------------------------------------------\n-No Warning \"$javac\" ${TESTTOOLVMOPTS}            -Xlint      -classpath   classesRefRef.jar Main.java\n-No Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint -Xbootclasspath\/p:classesRefRef.jar Main.java\n-\n-#----------------------------------------------------------------\n-# Class-Path attribute followed in extdirs or endorseddirs\n-#----------------------------------------------------------------\n-Sys mkdir jars\n-Sys cp classesRefRef.jar jars\/.\n-   Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint -extdirs      jars Main.java\n-   Warning \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint -endorseddirs jars Main.java\n-\n-#----------------------------------------------------------------\n-# Bad Jar file in extdirs and endorseddirs should not be ignored\n-#----------------------------------------------------------------\n-BadJarFile jars\/classesRef.jar\n-   Error \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint -extdirs      jars Main.java\n-   Error \"$javac\" ${TESTTOOLVMOPTS} ${SRCTRG8} -Xlint -endorseddirs jars Main.java\n-\n-Cleanup\n-\n-Bottom Line\n","filename":"test\/langtools\/tools\/javac\/Paths\/Diagnostics.sh","additions":0,"deletions":210,"binary":false,"changes":210,"status":"deleted"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 4940642 8293877\n+ * @summary Check for -help and -X flags\n+ *\/\n+\n+\/*\n+ * Converted from Help.sh, originally written by Martin Buchholz\n+ *\n+ * For the last version of the original, Help.sh, see\n+ * https:\/\/github.com\/openjdk\/jdk\/blob\/jdk-19%2B36\/test\/langtools\/tools\/javac\/Paths\/Help.sh\n+ *\n+ * This class provides rudimentary tests of the javac command-line help.\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.spi.ToolProvider;\n+\n+public class Help {\n+    public static void main(String... args) throws Exception {\n+        new Help().run(args);\n+    }\n+\n+    void run(String... args) throws Exception {\n+        String helpText = javac(\"-help\");\n+        check(helpText,\n+                \"-X \", \"-J\", \"-classpath \", \"-cp \", \"-bootclasspath \", \"-sourcepath \");\n+\n+        String xText = javac(\"-X\");\n+        check(xText, \"-Xbootclasspath\/p:\");\n+    }\n+\n+    void check(String text, String... options) throws Exception {\n+        for (String opt : options) {\n+            System.err.println(\"Checking '\" + opt + \"'\");\n+            if (!text.contains(opt)) {\n+                text.lines().forEach(System.err::println);\n+                throw new Exception(\"Bad help output\");\n+            }\n+        }\n+    }\n+\n+    String javac(String... args) throws Exception {\n+        var javac = ToolProvider.findFirst(\"javac\")\n+                .orElseThrow(() -> new Exception(\"cannot find javac\"));\n+        try (StringWriter sw = new StringWriter();\n+             PrintWriter pw = new PrintWriter(sw)) {\n+             int rc = javac.run(pw, pw, args);\n+             if (rc != 0) {\n+                 throw new Error(\"unexpected exit from javac: \" + rc);\n+             }\n+             pw.flush();\n+             return sw.toString();\n+        }\n+    }\n+}\n+\n","filename":"test\/langtools\/tools\/javac\/Paths\/Help.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -1,69 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-# @test\n-# @bug 4940642\n-# @summary Check for -help and -X flags\n-# @author Martin Buchholz\n-#\n-# @run shell Help.sh\n-\n-# To run this test manually, simply do .\/MineField.sh\n-\n-\n-. ${TESTSRC-.}\/Util.sh\n-\n-set -u\n-\n-DiagnosticsInEnglishPlease\n-\n-HELP=\"`\\\"$javac\\\" ${TESTTOOLVMOPTS} -help 2>&1`\"\n-XHELP=\"`\\\"$javac\\\" ${TESTTOOLVMOPTS} -X 2>&1`\"\n-\n-#----------------------------------------------------------------\n-# Standard options\n-#----------------------------------------------------------------\n-for opt in \\\n-    \"-X \" \\\n-    \"-J\" \\\n-    \"-classpath \" \\\n-    \"-cp \" \\\n-    \"-bootclasspath \" \\\n-    \"-sourcepath \"; \n-do\n-    case \"$HELP\" in *\"$opt\"*) ;; *) Fail \"Bad help output\" ;; esac\n-done\n-\n-#----------------------------------------------------------------\n-# Non-standard options\n-#----------------------------------------------------------------\n-for opt in \\\n-    \"-Xbootclasspath\/p:\"; \n-do\n-    case \"$XHELP\" in *\"$opt\"*) ;; *) Fail \"Bad help output\" ;; esac\n-done\n-\n-Bottom Line\n","filename":"test\/langtools\/tools\/javac\/Paths\/Help.sh","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -0,0 +1,352 @@\n+\/*\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 4758537 4809833 8149599 8293877\n+ * @summary Test that javac and java find files in similar ways\n+ * @library \/tools\/lib\n+ * @build toolbox.ToolBox Util MineField\n+ * @run main MineField\n+ *\/\n+\n+\/*\n+ * Converted from MineField.sh, originally written by Martin Buchholz.\n+ *\n+ * For the last version of the original, MineField.sh, see\n+ * https:\/\/github.com\/openjdk\/jdk\/blob\/jdk-19%2B36\/test\/langtools\/tools\/javac\/Paths\/MineField.sh\n+ *\n+ * This class primarily tests that javac and the java launcher provide\n+ * equivalent handling of all path-related options, like {@code -classpath}.\n+ *\/\n+\n+\/*\n+#----------------------------------------------------------------\n+# The search order for classes used by both java and javac is:\n+#\n+# -Xbootclasspath\/p:<path>\n+# -endorseddirs <dirs> or -Djava.endorsed.dirs=<dirs> (search for jar\/zip only)\n+# -bootclasspath <path> or -Xbootclasspath:<path>\n+# -Xbootclasspath\/a:<path>\n+# -extdirs <dirs> or -Djava.ext.dirs=<dirs> (search for jar\/zip only)\n+# -classpath <path>, -cp <path>, env CLASSPATH=<path>\n+#\n+# Peculiarities of the class file search:\n+# - Empty elements of the (user) classpath default to \".\",\n+#   while empty elements of other paths are ignored.\n+# - Only for the user classpath is an empty string value equivalent to \".\"\n+# - Specifying a bootclasspath on the command line obliterates any\n+#   previous -Xbootclasspath\/p: or -Xbootclasspath\/a: command line flags.\n+#\n+# JDK 9 update:\n+#   java: The java launcher does not support any of the following:\n+#       * -Xbootclasspath\/p: -Xbootclasspath:\n+#       * -endorseddirs -Djava.endorsed.dirs\n+#       * -extdirs -Djava.ext.dirs\n+#       All test cases exercising these features have been removed.\n+#   javac: The following features are only supported when compiling\n+#       for older releases:\n+#       * -Xbootclasspath\/p: -Xbootclasspath: -bootclasspath -Xbootclasspath\/a:\n+#       * -endorseddirs -Djava.endorsed.dirs\n+#       * -extdirs -Djava.ext.dirs\n+#       All test cases exercising these features have been modified to\n+#       use -source 8 -target 8.  In addition, javac test cases involving\n+#       use of the runtime properties java.endorsed.dirs and java.extdirs\n+#       (by means of -J-Dname=value) have been removed.\n+#       Although the primary purpose of the test cases in this file is to\n+#       compare javac and java behavior, some tests remain for javac for\n+#       which there is no java equivalent. However, the cases remain as useful\n+#       test cases for javac handling of the paths involved.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class MineField extends Util {\n+    public static void main(String... args) throws Exception {\n+        new MineField().run(args);\n+    }\n+\n+    void run(String... args) throws Exception{\n+        setup();\n+        tests();\n+        cleanup();\n+        bottomLine();\n+    }\n+\n+    void cleanup() throws IOException {\n+        deleteFiles(\"GooSrc\", \"GooJar\", \"GooZip\", \"GooClass\");\n+        deleteFiles(\"BadSrc\", \"BadJar\", \"BadZip\", \"BadClass\");\n+        deleteFiles(\"OneDir\", \"Main.java\", \"MANIFEST.MF\");\n+        deleteFiles(listFiles(Path.of(\".\"), \"*.class\"));\n+        deleteFiles(\"java-lang.jar\");\n+    }\n+\n+    \/**\n+     * \"Prepare the minefield\".\n+     *\/\n+    void setup() throws Exception {\n+        cleanup();\n+\n+        tb.createDirectories(\"GooSrc\", \"GooJar\", \"GooZip\", \"GooClass\");\n+        tb.createDirectories(\"BadSrc\", \"BadJar\", \"BadZip\", \"BadClass\");\n+\n+        Files.writeString(Path.of(\"Lib.java\"),\n+                \"public class Lib {public static void f(){}}\");\n+        javac(\"Lib.java\");\n+        jar(\"cf\", \"GooJar\/Lib.jar\", \"Lib.class\");\n+        jar(\"cf\", \"GooZip\/Lib.zip\", \"Lib.class\");\n+        tb.moveFile(\"Lib.class\", \"GooClass\/.\");\n+        tb.moveFile(\"Lib.java\", \"GooSrc\/.\");\n+        checkFiles(\"GooZip\/Lib.zip\", \"GooJar\/Lib.jar\", \"GooSrc\/Lib.java\");\n+\n+        Files.writeString(Path.of(\"Lib.java\"),\n+                \"public class Lib {\/* Bad *\/}\");\n+        javac(\"Lib.java\");\n+        jar(\"cf\", \"BadJar\/Lib.jar\", \"Lib.class\");\n+        jar(\"cf\", \"BadZip\/Lib.zip\", \"Lib.class\");\n+        tb.moveFile(\"Lib.class\", \"BadClass\/.\");\n+        tb.moveFile(\"Lib.java\", \"BadSrc\/.\");\n+        checkFiles(\"BadZip\/Lib.zip\", \"BadJar\/Lib.jar\", \"BadSrc\/Lib.java\");\n+\n+        Files.writeString(Path.of(\"Main.java\"),\n+                \"public class Main {public static void main(String[] a) {Lib.f();}}\");\n+        Path libModules = javaHome.resolve(\"lib\").resolve(\"modules\");\n+        if (Files.isReadable(libModules)) {\n+            jimage(\"extract\", \"--dir\", \"modules\", libModules.toString());\n+            jar(\"cf\", \"java-lang.jar\", \"-C\", \"modules\/java.base\", \"java\/lang\");\n+            deleteFiles(\"modules\");\n+        } else {\n+            Path modules = javaHome.resolve(\"modules\");\n+            if (Files.isDirectory(modules)) {\n+                jar(\"cf\", \"java-lang.jar\", \"-C\", modules.resolve(\"java.base\").toString(), \"java\/lang\");\n+            } else {\n+                throw new Exception(\"Cannot create java-lang.jar\");\n+            }\n+        }\n+    }\n+\n+    void tests() throws Exception {\n+\n+        \/\/----------------------------------------------------------------\n+        \/\/ Verify that javac class search order is the same as java's\n+        \/\/----------------------------------------------------------------\n+\n+        expectFail(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Xbootclasspath\/p:GooClass\n+                -bootclasspath java-lang.jar${PS}BadZip\/Lib.zip\n+                Main.java\"\"\");\n+\n+        expectPass(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Xbootclasspath\/p:BadClass${PS}GooClass\n+                -bootclasspath java-lang.jar${PS}GooZip\/Lib.zip${PS}BadClass\n+                Main.java\"\"\");\n+\n+        expectPass(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Xbootclasspath\/p:BadJar\/Lib.jar\n+                -Xbootclasspath:java-lang.jar${PS}GooClass\n+                Main.java\"\"\");\n+\n+        \/\/----------------------------------------------------------------\n+\n+        expectFail(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -bootclasspath java-lang.jar${PS}GooZip\/Lib.zip\n+                -Xbootclasspath\/p:BadClass\n+                Main.java\"\"\");\n+\n+        expectPass(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -bootclasspath java-lang.jar${PS}BadZip\/Lib.zip\n+                -Xbootclasspath\/p:GooClass${PS}BadJar\/Lib.jar\n+                Main.java\"\"\");\n+\n+        \/\/----------------------------------------------------------------\n+\n+        expectFail(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Xbootclasspath\/p:BadClass\n+                -Xbootclasspath\/a:GooClass\n+                Main.java\"\"\");\n+\n+        expectPass(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Xbootclasspath\/p:GooClass${PS}BadClass\n+                -Xbootclasspath\/a:BadClass\n+                Main.java\"\"\");\n+\n+        expectPass(JAVA, \"\"\"\n+                -Xbootclasspath\/a:GooClass\n+                Main\"\"\");\n+\n+        \/\/----------------------------------------------------------------\n+\n+        expectFail(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Xbootclasspath\/p:GooClass\n+                -Xbootclasspath:BadClass${PS}java-lang.jar\n+                -Xbootclasspath\/a:GooClass\n+                Main.java\"\"\");\n+\n+        expectPass(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Xbootclasspath\/p:BadClass\n+                -Xbootclasspath:GooClass${PS}BadClass${PS}java-lang.jar\n+                -Xbootclasspath\/a:BadClass\n+                Main.java\"\"\");\n+\n+        \/\/----------------------------------------------------------------\n+\n+        expectPass(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -endorseddirs BadClass${PS}GooZip${PS}BadJar\n+                -Xbootclasspath:\"BadClass${PS}java-lang.jar\n+                Main.java\"\"\");\n+\n+        expectPass(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Djava.endorsed.dirs=BadClass${PS}GooZip${PS}BadJar\n+                -Xbootclasspath:BadClass${PS}java-lang.jar\n+                Main.java\"\"\");\n+\n+        \/\/----------------------------------------------------------------\n+\n+        expectFail(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Xbootclasspath\/a:BadClass\n+                -extdirs GooZip\n+                Main.java\"\"\");\n+\n+        expectPass(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Xbootclasspath\/a:GooClass${PS}BadClass\n+                -extdirs BadZip\n+                Main.java\"\"\");\n+\n+        \/\/----------------------------------------------------------------\n+\n+        expectFail(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -extdirs GooClass${PS}BadZip\n+                -cp GooZip\/Lib.zip\n+                Main.java\"\"\");\n+\n+        expectPass(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -extdirs BadClass${PS}GooZip${PS}BadJar\n+                -cp BadZip\/Lib.zip\n+                Main.java\"\"\");\n+\n+        expectPass(JAVAC, \"\"\"\n+                -source 8 -target 8\n+                -Djava.ext.dirs=GooZip${PS}BadJar\n+                -classpath BadZip\/Lib.zip\n+                Main.java\"\"\");\n+\n+        \/\/----------------------------------------------------------------\n+\n+        expectFail(JAVAC, \"-classpath BadClass${PS}GooClass Main.java\");\n+        expectPass(JAVAC, \"-classpath GooClass${PS}BadClass Main.java\");\n+        expectFail(JAVA,  \"-classpath BadClass${PS}GooClass${PS}. Main\");\n+        expectPass(JAVA,  \"-classpath GooClass${PS}BadClass${PS}. Main\");\n+\n+        expectFail(JAVAC, \"-cp BadJar\/Lib.jar${PS}GooZip\/Lib.zip Main.java\");\n+        expectPass(JAVAC, \"-cp GooJar\/Lib.jar${PS}BadZip\/Lib.zip Main.java\");\n+        expectFail(JAVA,  \"-cp BadJar\/Lib.jar${PS}${PS}GooZip\/Lib.zip Main\");\n+        expectPass(JAVA,  \"-cp GooJar\/Lib.jar${PS}${PS}BadZip\/Lib.zip Main\");\n+\n+        \/\/----------------------------------------------------------------\n+\n+        expectFail(classpath(\"BadZip\/Lib.zip${PS}GooJar\/Lib.jar\"), JAVAC,\"Main.java\");\n+        expectPass(classpath(\"GooZip\/Lib.zip${PS}BadJar\/Lib.jar\"), JAVAC, \"Main.java\");\n+        expectFail(classpath(\"${PS}BadZip\/Lib.zip${PS}GooJar\/Lib.jar\"), JAVA, \"Main\");\n+        expectPass(classpath(\"${PS}GooZip\/Lib.zip${PS}BadJar\/Lib.jar\"), JAVA, \"Main\");\n+\n+        \/\/----------------------------------------------------------------\n+        \/\/ Check behavior of empty paths and empty path elements\n+        \/\/----------------------------------------------------------------\n+\n+        Path GooClass = Path.of(\"GooClass\");\n+        Path GooJar = Path.of(\"GooJar\");\n+\n+        expectFail(GooClass,  JAVAC, \"-cp .. ..\/Main.java\");\n+        expectFail(GooClass,  JAVA, \"-cp .. Main\");\n+\n+        \/\/ Unspecified classpath defaults to \".\"\n+        Path OneDir = Path.of(\"OneDir\");\n+        tb.createDirectories(OneDir);\n+        tb.copyFile(Path.of(\"Main.java\"), OneDir);\n+        tb.copyFile(GooClass.resolve(\"Lib.class\"), OneDir);\n+        expectPass(OneDir,  JAVAC, \"Main.java\");\n+        expectPass(OneDir,  JAVA, \"Main\");\n+\n+        \/\/ Empty classpath elements mean \".\"\n+        expectPass(GooClass,  JAVAC, \"-cp ${PS}.. ..\/Main.java\");\n+        expectPass(GooClass,  JAVA,  \"-cp ${PS}.. Main\");\n+\n+        expectPass(GooClass,  JAVAC, \"-cp ..${PS} ..\/Main.java\");\n+        expectPass(GooClass,  JAVA,  \"-cp ..${PS} Main\");\n+\n+        expectPass(GooClass,  JAVAC, \"-cp ..${PS}${PS}\/xyzzy ..\/Main.java\");\n+        expectPass(GooClass,  JAVA,  \"-cp ..${PS}${PS}\/xyzzy Main\");\n+\n+        \/\/ All other empty path elements are ignored.\n+\n+        \/\/ note presence of empty arg in this invocation\n+        expectFail(GooJar,  null, JAVAC, \"-source\", \"8\", \"-target\", \"8\", \"-extdirs\", \"\", \"-cp\", \"..\", \"..\/Main.java\");\n+\n+        expectFail(GooJar,  JAVAC, \"-source 8 -target 8 -extdirs        ${PS} -cp .. ..\/Main.java\");\n+        expectFail(GooJar,  JAVAC, \"-source 8 -target 8 -Djava.ext.dirs=${PS} -cp .. ..\/Main.java\");\n+\n+        expectPass(GooJar,  JAVAC, \"-source 8 -target 8 -extdirs        . -cp .. ..\/Main.java\");\n+        expectPass(GooJar,  JAVAC, \"-source 8 -target 8 -Djava.ext.dirs=. -cp .. ..\/Main.java\");\n+\n+        expectFail(GooJar,  JAVAC, \"-source 8 -target 8 -Djava.endorsed.dirs= -cp .. ..\/Main.java\");\n+\n+        expectFail(GooJar,  JAVAC, \"-source 8 -target 8 -endorseddirs        ${PS} -cp .. ..\/Main.java\");\n+\n+        expectPass(GooJar,  JAVAC, \"-source 8 -target 8 -Djava.endorsed.dirs=. -cp .. ..\/Main.java\");\n+\n+        expectFail(GooClass,  JAVAC, \"-source 8 -target 8 -Xbootclasspath\/p: -cp .. ..\/Main.java\");\n+\n+        expectPass(GooClass,  JAVAC, \"-source 8 -target 8 -Xbootclasspath\/p:. -cp .. ..\/Main.java\");\n+\n+        expectFail(GooClass,  JAVAC, \"-source 8 -target 8 -Xbootclasspath:..\/java-lang.jar -cp .. ..\/Main.java\");\n+\n+        expectPass(GooClass,  JAVAC, \"-source 8 -target 8 -Xbootclasspath:..\/java-lang.jar${PS}. -cp .. ..\/Main.java\");\n+\n+        expectFail(GooClass,  JAVAC, \"-source 8 -target 8 -Xbootclasspath\/a: -cp .. ..\/Main.java\");\n+        expectFail(GooClass,  JAVA, \"-Xbootclasspath\/a: -cp .. Main\");\n+\n+        expectPass(GooClass,  JAVAC, \"-source 8 -target 8 -Xbootclasspath\/a:. -cp .. ..\/Main.java\");\n+        expectPass(GooClass,  JAVA, \"-Xbootclasspath\/a:. -cp .. Main\");\n+\n+    }\n+\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/Paths\/MineField.java","additions":352,"deletions":0,"binary":false,"changes":352,"status":"added"},{"patch":"@@ -1,277 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-# @test\n-# @bug 4758537 4809833 8149599\n-# @summary Test that javac and java find files in similar ways\n-# @author Martin Buchholz\n-#\n-# @run shell\/timeout=600 MineField.sh\n-\n-# To run this test manually, simply do .\/MineField.sh\n-\n-#----------------------------------------------------------------\n-# The search order for classes used by both java and javac is:\n-#\n-# -Xbootclasspath\/p:<path>\n-# -endorseddirs <dirs> or -Djava.endorsed.dirs=<dirs> (search for jar\/zip only)\n-# -bootclasspath <path> or -Xbootclasspath:<path>\n-# -Xbootclasspath\/a:<path>\n-# -extdirs <dirs> or -Djava.ext.dirs=<dirs> (search for jar\/zip only)\n-# -classpath <path>, -cp <path>, env CLASSPATH=<path>\n-#\n-# Peculiarities of the class file search:\n-# - Empty elements of the (user) classpath default to \".\",\n-#   while empty elements of other paths are ignored.\n-# - Only for the user classpath is an empty string value equivalent to \".\"\n-# - Specifying a bootclasspath on the command line obliterates any\n-#   previous -Xbootclasspath\/p: or -Xbootclasspath\/a: command line flags.\n-#\n-# JDK 9 update:\n-#   java: The java launcher does not support any of the following:\n-#       * -Xbootclasspath\/p: -Xbootclasspath:\n-#       * -endorseddirs -Djava.endorsed.dirs\n-#       * -extdirs -Djava.ext.dirs\n-#       All test cases exercising these features have been removed.\n-#   javac: The following features are only supported when compiling\n-#       for older releases:\n-#       * -Xbootclasspath\/p: -Xbootclasspath: -bootclasspath -Xbootclasspath\/a:\n-#       * -endorseddirs -Djava.endorsed.dirs\n-#       * -extdirs -Djava.ext.dirs\n-#       All test cases exercising these features have been modified to\n-#       use -source 8 -target 8.  In addition, javac test cases involving\n-#       use of the runtime properties java.endorsed.dirs and java.extdirs\n-#       (by means of -J-Dname=value) have been removed.\n-#       Although the primary purpose of the test cases in this file is to\n-#       compare javac and java behavior, some tests remain for javac for\n-#       which there is no java equivalent. However, the cases remain as useful\n-#       test cases for javac handling of the paths involved.\n-\n-#----------------------------------------------------------------\n-\n-. ${TESTSRC-.}\/Util.sh\n-\n-set -u\n-\n-#----------------------------------------------------------------\n-# Prepare the \"Minefield\"\n-#----------------------------------------------------------------\n-Cleanup() {\n-    Sys rm -rf GooSrc GooJar GooZip GooClass\n-    Sys rm -rf BadSrc BadJar BadZip BadClass\n-    Sys rm -rf OneDir *.class Main.java MANIFEST.MF\n-    Sys rm -f java-lang.jar\n-}\n-\n-Cleanup\n-Sys mkdir  GooSrc GooJar GooZip GooClass\n-Sys mkdir  BadSrc BadJar BadZip BadClass\n-\n-echo 'public class Lib {public static void f(){}}' > Lib.java\n-Sys \"$javac\" ${TESTTOOLVMOPTS} Lib.java\n-Sys \"$jar\" cf GooJar\/Lib.jar Lib.class\n-Sys \"$jar\" cf GooZip\/Lib.zip Lib.class\n-Sys mv Lib.class GooClass\/.\n-Sys mv Lib.java GooSrc\/.\n-CheckFiles GooZip\/Lib.zip GooJar\/Lib.jar GooSrc\/Lib.java\n-\n-echo 'public class Lib {\/* Bad *\/}' > Lib.java\n-Sys \"$javac\" ${TESTTOOLVMOPTS} Lib.java\n-Sys \"$jar\" cf BadJar\/Lib.jar Lib.class\n-Sys \"$jar\" cf BadZip\/Lib.zip Lib.class\n-Sys mv Lib.class BadClass\/.\n-Sys mv Lib.java BadSrc\/.\n-CheckFiles BadZip\/Lib.zip BadJar\/Lib.jar BadSrc\/Lib.java\n-\n-echo 'public class Main {public static void main(String[] a) {Lib.f();}}' > Main.java\n-\n-# Create a jar file that is good enough to put on the javac boot class path (i.e. contains java.lang.**)\n-if [ -r ${TESTJAVA}\/lib\/modules ]; then\n-  Sys \"$jimage\" extract --dir modules ${TESTJAVA}\/lib\/modules\n-  Sys \"$jar\" cf java-lang.jar -C modules\/java.base java\/lang\n-  Sys rm -rf modules\n-elif [ -d ${TESTJAVA}\/modules ]; then\n-  Sys \"$jar\" cf java-lang.jar -C ${TESTJAVA}\/modules\/java.base java\/lang\n-else\n-  echo 'cannot create java-lang.jar' ; exit 1\n-fi\n-\n-#----------------------------------------------------------------\n-# Verify that javac class search order is the same as java's\n-#----------------------------------------------------------------\n-Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Xbootclasspath\/p:\"GooClass\" \\\n-    -bootclasspath \"java-lang.jar${PS}BadZip\/Lib.zip\" \\\n-    Main.java\n-Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Xbootclasspath\/p:\"BadClass${PS}GooClass\" \\\n-    -bootclasspath \"java-lang.jar${PS}GooZip\/Lib.zip${PS}BadClass\" \\\n-    Main.java\n-Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Xbootclasspath\/p:\"BadJar\/Lib.jar\" \\\n-    -Xbootclasspath:\"java-lang.jar${PS}GooClass\" \\\n-    Main.java\n-\n-#----------------------------------------------------------------\n-Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -bootclasspath \"java-lang.jar${PS}GooZip\/Lib.zip\" \\\n-    -Xbootclasspath\/p:\"BadClass\" \\\n-    Main.java\n-Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -bootclasspath \"java-lang.jar${PS}BadZip\/Lib.zip\" \\\n-    -Xbootclasspath\/p:\"GooClass${PS}BadJar\/Lib.jar\" \\\n-    Main.java\n-\n-#----------------------------------------------------------------\n-Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Xbootclasspath\/p:\"BadClass\" \\\n-    -Xbootclasspath\/a:\"GooClass\" \\\n-    Main.java\n-Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Xbootclasspath\/p:\"GooClass${PS}BadClass\" \\\n-    -Xbootclasspath\/a:\"BadClass\" \\\n-    Main.java\n-Success \"$java\" ${TESTVMOPTS} \\\n-    -Xbootclasspath\/a:\"GooClass\" \\\n-    Main\n-\n-#----------------------------------------------------------------\n-Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Xbootclasspath\/p:\"GooClass\" \\\n-    -Xbootclasspath:\"BadClass${PS}java-lang.jar\" \\\n-    -Xbootclasspath\/a:\"GooClass\" \\\n-    Main.java\n-Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Xbootclasspath\/p:\"BadClass\" \\\n-    -Xbootclasspath:\"GooClass${PS}BadClass${PS}java-lang.jar\" \\\n-    -Xbootclasspath\/a:\"BadClass\" \\\n-    Main.java\n-\n-#----------------------------------------------------------------\n-Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -endorseddirs \"BadClass${PS}GooZip${PS}BadJar\" \\\n-    -Xbootclasspath:\"BadClass${PS}java-lang.jar\" \\\n-    Main.java\n-Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Djava.endorsed.dirs=\"BadClass${PS}GooZip${PS}BadJar\" \\\n-    -Xbootclasspath:\"BadClass${PS}java-lang.jar\" \\\n-    Main.java\n-\n-#----------------------------------------------------------------\n-Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Xbootclasspath\/a:\"BadClass\" \\\n-    -extdirs \"GooZip\" \\\n-    Main.java\n-Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Xbootclasspath\/a:\"GooClass${PS}BadClass\" \\\n-    -extdirs \"BadZip\" \\\n-    Main.java\n-\n-#----------------------------------------------------------------\n-Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -extdirs \"GooClass${PS}BadZip\" \\\n-    -cp \"GooZip\/Lib.zip\" \\\n-    Main.java\n-Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -extdirs \"BadClass${PS}GooZip${PS}BadJar\" \\\n-    -cp \"BadZip\/Lib.zip\" \\\n-    Main.java\n-Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} \\\n-    -Djava.ext.dirs=\"GooZip${PS}BadJar\" \\\n-    -classpath \"BadZip\/Lib.zip\" \\\n-    Main.java\n-\n-#----------------------------------------------------------------\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \"BadClass${PS}GooClass\" Main.java\n-Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"GooClass${PS}BadClass\" Main.java\n-Failure \"$java\" ${TESTVMOPTS}  -classpath \"BadClass${PS}GooClass${PS}.\" Main\n-Success \"$java\" ${TESTVMOPTS}  -classpath \"GooClass${PS}BadClass${PS}.\" Main\n-\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -cp \"BadJar\/Lib.jar${PS}GooZip\/Lib.zip\" Main.java\n-Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"GooJar\/Lib.jar${PS}BadZip\/Lib.zip\" Main.java\n-Failure \"$java\" ${TESTVMOPTS}  -cp \"BadJar\/Lib.jar${PS}${PS}GooZip\/Lib.zip\" Main\n-Success \"$java\" ${TESTVMOPTS}  -cp \"GooJar\/Lib.jar${PS}${PS}BadZip\/Lib.zip\" Main\n-\n-Failure env CLASSPATH=\"BadZip\/Lib.zip${PS}GooJar\/Lib.jar\" \"$javac\" ${TESTTOOLVMOPTS} Main.java\n-Success env CLASSPATH=\"GooZip\/Lib.zip${PS}BadJar\/Lib.jar\" \"$javac\" ${TESTTOOLVMOPTS} Main.java\n-Failure env CLASSPATH=\"${PS}BadZip\/Lib.zip${PS}GooJar\/Lib.jar\" \"$java\" ${TESTVMOPTS} Main\n-Success env CLASSPATH=\"${PS}GooZip\/Lib.zip${PS}BadJar\/Lib.jar\" \"$java\" ${TESTVMOPTS} Main\n-\n-#----------------------------------------------------------------\n-# Check behavior of empty paths and empty path elements\n-#----------------------------------------------------------------\n-In() { cd \"$1\"; shift; \"$@\"; cd ..; }\n-\n-In GooClass Failure \"$javac\" ${TESTTOOLVMOPTS} -cp \"..\" ..\/Main.java\n-In GooClass Failure \"$java\" ${TESTVMOPTS}  -cp \"..\" Main\n-\n-# Unspecified classpath defaults to \".\"\n-Sys mkdir OneDir; Sys cp Main.java GooClass\/Lib.class OneDir\/.\n-In OneDir Success \"$javac\" ${TESTTOOLVMOPTS} Main.java\n-In OneDir Success \"$java\" ${TESTVMOPTS}  Main\n-\n-# Empty classpath elements mean \".\"\n-In GooClass Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"${PS}..\" ..\/Main.java\n-In GooClass Success \"$java\" ${TESTVMOPTS}  -cp \"${PS}..\" Main\n-\n-In GooClass Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"..${PS}\" ..\/Main.java\n-In GooClass Success \"$java\" ${TESTVMOPTS}  -cp \"..${PS}\" Main\n-\n-In GooClass Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"..${PS}${PS}\/xyzzy\" ..\/Main.java\n-In GooClass Success \"$java\" ${TESTVMOPTS}  -cp \"..${PS}${PS}\/xyzzy\" Main\n-\n-# All other empty path elements are ignored.\n-In GooJar Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} -extdirs \"\" -cp \"..\" ..\/Main.java\n-\n-In GooJar Failure \"$javac\" -source 8 -targt 8 ${TESTTOOLVMOPTS} -extdirs        \"${PS}\" -cp \"..\" ..\/Main.java\n-In GooJar Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} -Djava.ext.dirs=\"${PS}\" -cp \"..\" ..\/Main.java\n-\n-In GooJar Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} -extdirs        \".\" -cp \"..\" ..\/Main.java\n-In GooJar Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} -Djava.ext.dirs=\".\" -cp \"..\" ..\/Main.java\n-\n-In GooJar Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS}   -Djava.endorsed.dirs=\"\" -cp \"..\" ..\/Main.java\n-\n-In GooJar Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS}   -endorseddirs        \"${PS}\" -cp \"..\" ..\/Main.java\n-\n-In GooJar Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS}   -Djava.endorsed.dirs=\".\" -cp \"..\" ..\/Main.java\n-\n-In GooClass Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} -Xbootclasspath\/p: -cp \"..\" ..\/Main.java\n-\n-In GooClass Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} -Xbootclasspath\/p:. -cp \"..\" ..\/Main.java\n-\n-In GooClass Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} -Xbootclasspath:\"..\/java-lang.jar\" -cp \"..\" ..\/Main.java\n-\n-In GooClass Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} -Xbootclasspath:\"..\/java-lang.jar${PS}.\" -cp \"..\" ..\/Main.java\n-\n-In GooClass Failure \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} -Xbootclasspath\/a: -cp \"..\" ..\/Main.java\n-In GooClass Failure \"$java\" ${TESTVMOPTS}  -Xbootclasspath\/a: -cp \"..\" Main\n-\n-In GooClass Success \"$javac\" -source 8 -target 8 ${TESTTOOLVMOPTS} -Xbootclasspath\/a:. -cp \"..\" ..\/Main.java\n-In GooClass Success \"$java\" ${TESTVMOPTS}  -Xbootclasspath\/a:. -cp \"..\" Main\n-\n-Cleanup\n-\n-Bottom Line\n","filename":"test\/langtools\/tools\/javac\/Paths\/MineField.sh","additions":0,"deletions":277,"binary":false,"changes":277,"status":"deleted"},{"patch":"@@ -0,0 +1,560 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.spi.ToolProvider;\n+\n+import toolbox.ToolBox;\n+\n+\/**\n+ * Utility methods for use by tests in the `Paths` directory.\n+ *\/\n+class Util {\n+\n+    ToolBox tb = new ToolBox();\n+    PrintStream out = tb.out;\n+\n+    Path javaHome = Path.of(System.getProperty(\"java.home\"));\n+    String PS = File.pathSeparator;\n+    Path curDir = Path.of(\".\");\n+\n+    static final String JAR = \"jar\";\n+    static final String JAVA = \"java\";\n+    static final String JAVAC = \"javac\";\n+    static final String JIMAGE = \"jimage\";\n+\n+    \/** The number of test-case failures. *\/\n+    int failCount = 0;\n+    \/** The number of test-case passes. *\/\n+    int passCount = 0;\n+    \/** A map recording how often each tool is executed in a separate process. *\/\n+    Map<String, Integer> execCounts = new TreeMap<>();\n+    \/** A map recording how often each tool is invoked via its ToolProvider API. *\/\n+    Map<String, Integer> toolCounts = new TreeMap<>();\n+\n+    \/**\n+     * Reports a summary of the overall test statistics, and throws an exception\n+     * if any test cases failed.\n+     *\n+     * @throws Exception if any test cases failed\n+     *\/\n+    void bottomLine() throws Exception {\n+        out.println();\n+        out.println(\"-- Summary --\");\n+        out.println(\"Passed: \" + passCount);\n+        out.println(\"Failed: \" + failCount);\n+        out.println(\"exec: \" + execCounts);\n+        out.println(\"tool: \" + toolCounts);\n+\n+        if (failCount > 0) {\n+            throw new Exception(failCount + \" tests failed\");\n+        }\n+    }\n+\n+    \/**\n+     * The result of executing a tool, either in a separate process, or via its ToolProvider API.\n+     *\n+     * @param exitCode the exit code from the tool: 0 for success\n+     * @param out the output from the tool\n+     *\/\n+    record Result(int exitCode, String out) { }\n+\n+    \/**\n+     * Executes a tool with given arguments and verifies that it passes.\n+     *\n+     * @param command the name of a JDK tool: java, javac or jar\n+     * @param args a string containing whitespace separated arguments\n+     * @throws Exception if there was an issue trying to execute the tool\n+     * @see #passCount\n+     * @see #failCount\n+     * @see #splitArgs(String)\n+     *\/\n+    void expectPass(String command, String args) throws Exception {\n+        expectPass(null, null, command, splitArgs(args));\n+    }\n+\n+    \/**\n+     * Executes a tool in a specific directory with given arguments and verifies that it passes.\n+     * In order to set the directory, the tool will be executed in a separate process.\n+     *\n+     * @param dir the directory\n+     * @param command the name of a JDK tool: java, javac or jar\n+     * @param args a string containing whitespace separated arguments\n+     * @throws Exception if there was an issue trying to execute the tool\n+     * @see #passCount\n+     * @see #failCount\n+     * @see #splitArgs(String)\n+     *\/\n+    void expectPass(Path dir, String command, String args) throws Exception {\n+        expectPass(dir, null, command, splitArgs(args));\n+    }\n+\n+    \/**\n+     * Executes a tool with additional env variables with given arguments and verifies that it passes.\n+     * In order to set the env variables, the tool will be executed in a separate process.\n+     * Note that any value of {@code CLASSPATH} inherited from this process will always be removed.\n+     *\n+     * @param env the additional env variables\n+     * @param command the name of a JDK tool: java, javac or jar\n+     * @param args a string containing whitespace separated arguments\n+     * @throws Exception if there was an issue trying to execute the tool\n+     * @see #passCount\n+     * @see #failCount\n+     * @see #splitArgs(String)\n+     *\/\n+    void expectPass(Map<String, String> env, String command, String args) throws Exception {\n+        expectPass(null, env, command, splitArgs(args));\n+    }\n+\n+    \/**\n+     * Executes a tool in a given directory with additional env variables with given arguments\n+     * and verifies that it passes.\n+     * In order to set any directory and env variables, the tool will be executed in a separate process.\n+     * Note that any value of {@code CLASSPATH} inherited from this process will always be removed.\n+     *\n+     * @param dir the directory, or {@code null}\n+     * @param env the additional env variables, or {@code null}\n+     * @param command the name of a JDK tool: java, javac or jar\n+     * @param args the arguments\n+     * @throws Exception if there was an issue trying to execute the tool\n+     * @see #passCount\n+     * @see #failCount\n+     *\/\n+    void expectPass(Path dir, Map<String, String> env, String command, String... args) throws Exception {\n+        Result result = switch (command) {\n+            case JAR -> jar(args);\n+            case JAVAC -> javac(dir, env, args);\n+            case JAVA -> java(dir, env, args);\n+            default -> throw new Exception(\"unknown command: \" + command);\n+        };\n+\n+        if (result.exitCode == 0) {\n+            out.println(\"PASS: test passed as expected\");\n+            passCount++;\n+        } else {\n+            out.println(\"FAIL: test failed unexpectedly\");\n+            failCount++;\n+        }\n+    }\n+\n+    \/**\n+     * Executes a tool with given arguments and verifies that it fails.\n+     *\n+     * @param command the name of a JDK tool: java, javac or jar\n+     * @param args a string containing whitespace separated arguments\n+     * @throws Exception if there was an issue trying to execute the tool\n+     * @see #passCount\n+     * @see #failCount\n+     * @see #splitArgs(String)\n+     *\/\n+    void expectFail(String command, String args) throws Exception {\n+        expectFail(null, null, command, splitArgs(args));\n+    }\n+\n+    \/**\n+     * Executes a tool in a specific directory with given arguments and verifies that it fails.\n+     * In order to set the directory, the tool will be executed in a separate process.\n+     *\n+     * @param dir the directory\n+     * @param command the name of a JDK tool: java, javac or jar\n+     * @param args a string containing whitespace separated arguments\n+     * @throws Exception if there was an issue trying to execute the tool\n+     * @see #passCount\n+     * @see #failCount\n+     * @see #splitArgs(String)\n+     *\/\n+    void expectFail(Path dir, String command, String args) throws Exception {\n+        expectFail(dir, null, command, splitArgs(args));\n+    }\n+\n+    \/**\n+     * Executes a tool with additional env variables with given arguments and verifies that it passes.\n+     * In order to set the env variables, the tool will be executed in a separate process.\n+     * Note that any value of {@code CLASSPATH} inherited from this process will always be removed.\n+     *\n+     * @param env the additional env variables\n+     * @param command the name of a JDK tool: java, javac or jar\n+     * @param args a string containing whitespace separated arguments\n+     * @throws Exception if there was an issue trying to execute the tool\n+     * @see #passCount\n+     * @see #failCount\n+     * @see #splitArgs(String)\n+     *\/\n+    void expectFail(Map<String, String> env, String command, String args) throws Exception {\n+        expectFail(null, env, command, splitArgs(args));\n+    }\n+\n+    \/**\n+     * Executes a tool in a given directory with additional env variables with given arguments\n+     * and verifies that it passes.\n+     * In order to set any directory and env variables, the tool will be executed in a separate process.\n+     * Note that any value of {@code CLASSPATH} inherited from this process will always be removed.\n+     *\n+     * @param dir the directory, or {@code null}\n+     * @param env the additional env variables, or {@code null}\n+     * @param command the name of a JDK tool: java, javac or jar\n+     * @param args the arguments\n+     * @throws Exception if there was an issue trying to execute the tool\n+     * @see #passCount\n+     * @see #failCount\n+     *\/\n+    void expectFail(Path dir, Map<String, String> env, String command, String... args) throws Exception {\n+        Result result = switch (command) {\n+            case JAR -> jar(args);\n+            case JAVAC -> javac(dir, env, args);\n+            case JAVA -> java(dir, env, args);\n+            default -> throw new Exception(\"unknown command: \" + command);\n+        };\n+\n+        if (result.exitCode == 0) {\n+            out.println(\"FAIL: test passed unexpectedly\");\n+            failCount++;\n+        } else {\n+            out.println(\"PASS: failed as expected\");\n+            passCount++;\n+        }\n+    }\n+\n+    \/**\n+     * Splits a string into a list of strings that were separated by whitespace.\n+     * Leading and trailing whitespace is removed.\n+     * The character sequence {@code ${PS}} is replaced by the platform path separator.\n+     * Note, quotes are not supported, and so there is no support for embedded whitespace\n+     * or empty strings in the output.\n+     *\n+     * @param args a string of tokens separated by whitespace\n+     * @return an array of the tokens that were separated by whitespace\n+     *\/\n+    String[] splitArgs(String args) {\n+        return args.trim()\n+                .replace(\"${PS}\", PS)\n+                .split(\"\\\\s+\");\n+    }\n+\n+    \/**\n+     * Executes {@code javac} using its ToolProvider API.\n+     *\n+     * @param args the arguments\n+     * @return an object containing the output and exit code from the tool\n+     * @throws Exception if there is an issue executing the tool\n+     *\/\n+    Result javac(String... args) throws Exception {\n+        return runTool(JAVAC, args);\n+    }\n+\n+    \/**\n+     * Executes {@code javac} in either a separate process or using its ToolProvider API.\n+     * The ToolProvider API is used if the directory and env parameters are {@code null},\n+     * and if the arguments definitely do not use \"classpath wildcards\", which are\n+     * only supported when the tool is invoked by the launcher.\n+     *\n+     * @param dir the directory, or {@code null}\n+     * @param env any additional environment variables, or {@code null}\n+     * @param args the arguments\n+     * @return an object containing the output and exit code from the tool\n+     * @throws Exception if there is an issue executing the tool\n+     *\/\n+    Result javac(Path dir, Map<String, String> env, String... args) throws Exception {\n+        return (env != null || dir != null || hasWildcardClassPath(args))\n+                ? execTool(dir, env, JAVAC, args)\n+                : runTool(JAVAC, args);\n+    }\n+\n+    \/**\n+     * {@return true if the arguments may contain a classpath option using a \"classpath wildcard\"}\n+     *\n+     * The result is {@code true} if there is any form of a classpath option whose value contains {@code *}.\n+     * Note: this may include \"false positives\", where the {@code *} is not at the end of\n+     * any element in the path, such as when the character is part of the filename.\n+     * However, in context, the approximation is safe, and just means that we may sometimes\n+     * execute javac in a separate process when it would be sufficient to use its ToolProvider API.\n+     *\n+     * A more refined implementation could split apart the path elements and looking for\n+     * an element that is {@code *} or which ends in {@code *}.\n+     *\n+     * @param args the arguments to be checked\n+     *\/\n+    private boolean hasWildcardClassPath(String... args) {\n+        for (int i = 0; i < args.length; i++) {\n+            String arg = args[i];\n+            switch (arg) {\n+                case \"-classpath\", \"--class-path\", \"-cp\" -> {\n+                    if (i + 1 < args.length && args[i + 1].contains(\"*\")) {\n+                        return true;\n+                    }\n+                }\n+                default -> {\n+                    if (arg.startsWith(\"--class-path=\") && arg.contains(\"*\")) {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Executes {@code jar} using its ToolProvider API.\n+     *\n+     * @param args the arguments\n+     * @return an object containing the output and exit code from the tool\n+     * @throws Exception if there is an issue executing the tool\n+     *\/\n+    Result jar(String... args) throws Exception {\n+        return runTool(JAR, args);\n+    }\n+\n+    \/**\n+     * Executes {@code jimage} using its ToolProvider API.\n+     *\n+     * @param args the arguments\n+     * @return an object containing the output and exit code from the tool\n+     * @throws Exception if there is an issue executing the tool\n+     *\/\n+    Result jimage(String... args) throws Exception {\n+        return execTool(null, null, JIMAGE, args);\n+    }\n+\n+    \/**\n+     * Executes {@code java} in a separate process.\n+     *\n+     * @param dir the directory, or {@code null}\n+     * @param env any additional environment variables, or {@code null}\n+     * @param args the arguments\n+     * @return an object containing the output and exit code from the launcher\n+     * @throws Exception if there is an issue executing the tool\n+     *\/\n+    Result java(Path dir, Map<String, String> env, String... args) throws Exception {\n+        return execTool(dir, env, JAVA, args);\n+    }\n+\n+    \/**\n+     * Runs a tool using its ToolProvider API.\n+     *\n+     * @param args the arguments\n+     * @return an object containing the output and exit code from the launcher\n+     * @throws Exception if there is an issue executing the tool\n+     *\/\n+    Result runTool(String name, String... args) throws Exception {\n+        out.println(name + \": \" + String.join(\" \", args));\n+        var tool = ToolProvider.findFirst(name)\n+                .orElseThrow(() -> new Exception(\"cannot find \" + name));\n+        try (StringWriter sw = new StringWriter();\n+             PrintWriter pw = new PrintWriter(sw)) {\n+            int rc = tool.run(pw, pw, args);\n+            pw.flush();\n+            String output = sw.toString();\n+            output.lines()\n+                    .forEach(l -> out.println(name + \": \" + l));\n+            if (rc != 0) {\n+                out.println(name + \": exit code \" + rc);\n+            }\n+            toolCounts.put(name, toolCounts.computeIfAbsent(name, n -> 0) + 1);\n+            return new Result(rc, output);\n+        }\n+    }\n+\n+    \/**\n+     * Executes a tool in a separate process.\n+     *\n+     * Note that any value of {@code CLASSPATH} inherited from this process will always be removed.\n+     *\n+     * @param dir the directory, or {@code null}\n+     * @param env any additional environment variables, or {@code null}\n+     * @param args the arguments\n+     * @return an object containing the output and exit code from the launcher\n+     * @throws Exception if there is an issue executing the tool\n+     *\/\n+    Result execTool(Path dir, Map<String, String> env, String name, String... args) throws Exception {\n+        out.print(name + \":\");\n+        if (env != null) {\n+            out.print(\" \" + env);\n+        }\n+        if (dir != null) {\n+            out.print(\" (\" + dir + \")\");\n+        }\n+        out.println(\" \" + String.join(\" \", args));\n+\n+        Path tool = javaHome.resolve(\"bin\").resolve(name + (ToolBox.isWindows() ? \".exe\" : \"\"));\n+        if (!Files.exists(tool)) {\n+            throw new Exception(\"cannot find \" + name);\n+        }\n+        var cmd = new ArrayList<String>();\n+        cmd.add(tool.toString());\n+        cmd.addAll(List.of(args));\n+        ProcessBuilder pb = new ProcessBuilder(cmd)\n+                .redirectErrorStream(true);\n+        pb.environment().remove(\"CLASSPATH\"); \/\/ always remove default value set by jtreg\n+        if (env != null) {\n+            pb.environment().putAll(env);\n+        }\n+        if (dir != null) {\n+            pb.directory(dir.toFile());\n+        }\n+        Process p = pb.start();\n+        StringBuilder sb = new StringBuilder();\n+        try (var in = p.inputReader()) {\n+            in.lines().forEach(l -> {\n+                sb.append(l).append(\"\\n\");\n+                out.println(name + \": \" + l);\n+            });\n+        }\n+        p.waitFor();\n+        int rc = p.exitValue();\n+        if (rc != 0) {\n+            out.println(name + \": exit code \" + rc);\n+        }\n+        execCounts.put(name, execCounts.computeIfAbsent(name, n -> 0) + 1);\n+        return new Result(rc, sb.toString());\n+    }\n+\n+    \/**\n+     * Checks that a series of files exist and are readable.\n+     *\n+     * @param paths the files\n+     * @throws Exception if any of the files are not found or are not readable\n+     *\/\n+    void checkFiles(String... paths) throws Exception {\n+        for (String p : paths) {\n+            Path path = Path.of(p);\n+            if (!Files.isReadable(path) ) {\n+                throw new Exception(\"file not found: \" + path);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * List the files in a directory that match a \"glob\" pattern.\n+     *\n+     * @param dir the directory\n+     * @param glob the pattern\n+     * @return the list of files\n+     * @throws IOException if there is a problem listing the contents of the directory\n+     *\/\n+    List<Path> listFiles(Path dir, String glob) throws IOException {\n+        var files = new ArrayList<Path>();\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(dir, glob)) {\n+            for (Path p : ds) {\n+                files.add(p);\n+            }\n+        }\n+        return files;\n+    }\n+\n+    \/**\n+     * Deletes a series of files.\n+     * The files are deleted using {@link ToolBox#cleanDirectory(Path)} and\n+     * {@code ToolBox#deleteFiles}, which together try hard to delete the files,\n+     * even on Windows.\n+     *\n+     * @param paths the paths\n+     * @throws IOException if there is a problem deleting any of the files\n+     * @see #deleteFiles(List)\n+     *\/\n+    void deleteFiles(String... paths) throws IOException {\n+        deleteFiles(Arrays.stream(paths)\n+                        .map(Path::of)\n+                        .toList());\n+    }\n+\n+    \/**\n+     * Deletes a series of files.\n+     * The files are deleted using {@link ToolBox#cleanDirectory(Path)} and\n+     * {@code ToolBox#deleteFiles}, which together try hard to delete the files,\n+     * even on Windows.\n+     *\n+     * @param paths the paths\n+     * @throws IOException if there is a problem deleting any of the files\n+     *\/\n+    void deleteFiles(List<Path> paths) throws IOException {\n+        for (Path path : paths) {\n+            if (Files.exists(path)) {\n+                if (Files.isDirectory(path)) {\n+                    tb.cleanDirectory(path);\n+                }\n+                tb.deleteFiles(path);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Moves a series of files into a given directory.\n+     *\n+     * @param files the files\n+     * @param dir the target directory\n+     * @throws IOException if there is a problem moving any of the files\n+     *\/\n+    void moveFiles(List<Path> files, Path dir) throws IOException {\n+        for (Path p : files) {\n+            tb.moveFile(p, dir);\n+        }\n+    }\n+\n+    \/**\n+     * Moves a series of files into a given directory.\n+     *\n+     * @param files the files\n+     * @param dir the target directory\n+     * @throws IOException if there is a problem moving any of the files\n+     *\/\n+    void moveFiles(List<String> files, String dir) throws IOException {\n+        for (String p : files) {\n+            tb.moveFile(p, dir);\n+        }\n+    }\n+\n+    \/**\n+     * {@return a map containing a setting for the {@code CLASSPATH} env variable}\n+     *\n+     * @param classpath the value for the env variable\n+     *\/\n+    Map<String, String> classpath(String classpath) {\n+        return Map.of(\"CLASSPATH\", classpath.replace(\"${PS}\", PS));\n+    }\n+\n+    \/**\n+     * Writes a file called {@code MANIFEST.MF} containing a given value for\n+     * the {@code Class-Path} entry.\n+     *\n+     * @param path the value for the {@code Class-Path} entry\n+     * @throws IOException if there is a problem writing the file\n+     *\/\n+    void makeManifestWithClassPath(String path) throws IOException {\n+        Files.writeString(Path.of(\"MANIFEST.MF\"),\n+                \"Manifest-Version: 1.0\\n\"\n+                    + \"Class-Path: \" + path + \"\\n\");\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/Paths\/Util.java","additions":560,"deletions":0,"binary":false,"changes":560,"status":"added"},{"patch":"@@ -1,115 +0,0 @@\n-#\n-# Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# Utilities for shell tests\n-\n-: ${TESTSRC=.} ${TESTCLASSES=.}\n-  java=\"${TESTJAVA+${TESTJAVA}\/bin\/}java${EXE_SUFFIX}\"\n- javac=\"${TESTJAVA+${TESTJAVA}\/bin\/}javac${EXE_SUFFIX}\"\n-   jar=\"${TESTJAVA+${TESTJAVA}\/bin\/}jar${EXE_SUFFIX}\"\n-jimage=\"${TESTJAVA+${TESTJAVA}\/bin\/}jimage${EXE_SUFFIX}\"\n-\n-case `uname -s` in\n-  Windows*|CYGWIN*|MSYS*|MINGW*)\n-    WindowsOnly() { \"$@\"; }\n-    UnixOnly() { :; }\n-    PS=\";\" ;;\n-  *)\n-    UnixOnly() { \"$@\"; }\n-    WindowsOnly() { :; }\n-    PS=\":\";;\n-esac\n-\n-failed=\"\"\n-Fail() { echo \"FAIL: $1\"; failed=\"${failed}.\"; }\n-\n-Die() { printf \"%s\\n\" \"$*\"; exit 1; }\n-\n-Sys() {\n-    printf \"%s\\n\" \"$*\"; \"$@\"; rc=\"$?\";\n-    test \"$rc\" -eq 0 || Die \"Command \\\"$*\\\" failed with exitValue $rc\";\n-}\n-\n-CheckFiles() {\n-    for f in \"$@\"; do test -r \"$f\" || Die \"File $f not found\"; done\n-}\n-\n-Report() {\n-    test \"$#\" != 2 && Die \"Usage: Report success|failure rc\"\n-\n-    if   test \"$1\" = \"success\" -a \"$2\" = 0; then\n-        echo \"PASS: succeeded as expected\"\n-    elif test \"$1\" = \"failure\" -a \"$2\" != 0; then\n-        echo \"PASS: failed as expected\"\n-    elif test \"$1\" = \"success\" -a \"$2\" != 0; then\n-        Fail \"test failed unexpectedly\"\n-    elif test \"$1\" = \"failure\" -a \"$2\" = 0; then\n-        Fail \"test succeeded unexpectedly\"\n-    else\n-        Die \"Usage: Report success|failure rc\"\n-    fi\n-}\n-\n-MkManifestWithClassPath() {\n-    (echo \"Manifest-Version: 1.0\"; echo \"Class-Path: $*\") > MANIFEST.MF\n-}\n-\n-HorizontalRule() {\n-    echo \"-----------------------------------------------------------------\"\n-}\n-\n-Test() {\n-    HorizontalRule\n-    expectedResult=\"$1\"; shift\n-    printf \"%s\\n\" \"$*\"\n-    \"$@\"\n-    Report \"$expectedResult\" \"$?\"\n-}\n-\n-Failure() { Test failure \"$@\"; }\n-Success() { Test success \"$@\"; }\n-\n-Bottom() {\n-    test \"$#\" = 1 -a \"$1\" = \"Line\" || Die \"Usage: Bottom Line\"\n-\n-    if test -n \"$failed\"; then\n-        count=`printf \"%s\" \"$failed\" | wc -c | tr -d ' '`\n-        echo \"FAIL: $count tests failed\"\n-        exit 1\n-    else\n-        echo \"PASS: all tests gave expected results\"\n-        exit 0\n-    fi\n-}\n-\n-BadJarFile() {\n-    for jarfilename in \"$@\"; do pwd > \"$jarfilename\"; done\n-}\n-\n-\n-#----------------------------------------------------------------\n-# Foil message localization\n-#----------------------------------------------------------------\n-DiagnosticsInEnglishPlease() {\n-    LANG=\"C\" LC_ALL=\"C\" LC_MESSAGES=\"C\"; export LANG LC_ALL LC_MESSAGES\n-}\n","filename":"test\/langtools\/tools\/javac\/Paths\/Util.sh","additions":0,"deletions":115,"binary":false,"changes":115,"status":"deleted"},{"patch":"@@ -0,0 +1,340 @@\n+\/*\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6268383 8172309 8293877\n+ * @summary Test classpath wildcards for javac and java -classpath option.\n+ * @library \/tools\/lib\n+ * @build toolbox.ToolBox Util WildcardMineField\n+ * @run main WildcardMineField\n+ *\/\n+\n+\/*\n+ * Converted from wcMineField.sh, originally written by Martin Buchholz.\n+ *\n+ * For the last version of the original, wcMineField.sh, see\n+ * https:\/\/github.com\/openjdk\/jdk\/blob\/jdk-19%2B36\/test\/langtools\/tools\/javac\/Paths\/wcMineField.sh\n+ *\n+ * This class primarily tests support for \"classpath wildcards\", which is a feature\n+ * by which elements of a classpath option ending in {@code *} are expanded into\n+ * the set of jar files found in the directory preceding the {@code *}.\n+ *\n+ * Note that this feature is only implemented in the launcher, even for javac,\n+ * and so is only available when running javac via its launcher, in a separate process.\n+ *\n+ * Note that this feature does not affect the use of {@code *} elsewhere in any path,\n+ * classpath or otherwise, and so this class also tests the use of {@code *} and other special\n+ * characters (like {@code ,} and {@code ;}) in filenames. Some of these tests,\n+ * labelled in the original code as \"UnixOnly\", do not apply to Windows.\n+ *\n+ * For information on the launcher support for the {@code -classpath} option,\n+ * see the java man page. As of September 2022, there is no equivalent documentation\n+ * for javac, except to say that the support is only in the native launcher for javac,\n+ * and not in the main javac source code.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import toolbox.ToolBox;\n+\n+public class WildcardMineField extends Util {\n+    public static void main(String... args) throws Exception {\n+        new WildcardMineField().run(args);\n+    }\n+\n+    void run(String... args) throws Exception {\n+        setup();\n+        tests();\n+        cleanup();\n+        bottomLine();\n+    }\n+\n+    void setup() throws Exception {\n+        cleanup();\n+        tb.createDirectories(\"GooSrc\", \"GooJar\", \"GooZip\", \"GooClass\", \"GooJar\/SubDir\");\n+        tb.createDirectories(\"BadSrc\", \"BadJar\", \"BadZip\", \"BadClass\");\n+        tb.createDirectories(\"SpeSrc\", \"SpeJar\", \"SpeZip\", \"SpeClass\");\n+        tb.createDirectories(\"JarNClass\", \"StarJar\", \"MixJar\");\n+        Files.writeString(Path.of(\"Lib.java\"), \"public class Lib  {public static void f(){}}\");\n+        Files.writeString(Path.of(\"Lib2.java\"), \"public class Lib2 {public static void g(){}}\");\n+        Files.writeString(Path.of(\"Lib3.java\"), \"public class Lib3 {public static void h(){}}\");\n+        javac(\"Lib.java\", \"Lib2.java\", \"Lib3.java\");\n+        tb.copyFile(\"Lib.class\", \"JarNClass\/.\");\n+        jar(\"cf\", \"GooJar\/Lib.jar\", \"Lib.class\");\n+        jar(\"cf\", \"GooJar\/SubDir\/Lib2.jar\", \"Lib2.class\");\n+        jar(\"cf\", \"JarNClass\/Lib.jar\", \"Lib.class\");\n+\n+        jar(\"cf\", \"GooZip\/Lib.zip\", \"Lib.class\");\n+        tb.moveFile(\"Lib.class\", \"GooClass\/.\");\n+        tb.moveFile(\"Lib2.class\", \"GooClass\/.\");\n+        tb.moveFile(\"Lib3.class\", \"GooClass\/.\");\n+        tb.moveFile(\"Lib.java\", \"GooSrc\/.\");\n+        tb.moveFile(\"Lib2.java\", \"GooSrc\/.\");\n+        tb.moveFile(\"Lib3.java\", \"GooSrc\/.\");\n+\n+        checkFiles(\"GooZip\/Lib.zip\", \"GooJar\/Lib.jar\", \"GooSrc\/Lib.java\");\n+        checkFiles(\"GooSrc\/Lib2.java\", \"GooSrc\/Lib3.java\", \"GooJar\/SubDir\/Lib2.jar\");\n+\n+        Files.writeString(Path.of(\"Spe1.java\"), \"public class Spe1 {public static void f(){}}\");\n+        Files.writeString(Path.of(\"Spe2.java\"), \"public class Spe2 {public static void f(){}}\");\n+        Files.writeString(Path.of(\"Spe3.java\"), \"public class Spe3 {public static void f(){}}\");\n+        Files.writeString(Path.of(\"Spe4.java\"), \"public class Spe4 {public static void f(){}}\");\n+        javac(\"Spe1.java\", \"Spe2.java\", \"Spe3.java\", \"Spe4.java\");\n+\n+        if (!ToolBox.isWindows()) {\n+            jar(\"cf\", \"SpeJar\/Spe:Colon.jar\", \"Spe1.class\");\n+            jar(\"cf\", \"SpeJar\/Spe*wc.jar\", \"Spe4.class\");\n+            checkFiles(\"SpeJar\/Spe*wc.jar\");\n+\n+            jar(\"cf\", \"StarJar\/*jar.jar\", \"Spe2.class\");\n+            jar(\"cf\", \"StarJar\/jar*.jar\", \"Spe3.class\");\n+            jar(\"cf\", \"StarJar\/*jar*.jar\", \"Spe4.class\");\n+            checkFiles(\"StarJar\/*jar.jar\", \"StarJar\/jar*.jar\", \"StarJar\/*jar*.jar\");\n+        }\n+\n+        jar(\"cf\", \"SpeJar\/Spe,Comma.jar\", \"Spe2.class\");\n+        jar(\"cf\", \"SpeJar\/Spe;Semi.jar\", \"Spe3.class\");\n+\n+        jar(\"cf\", \"MixJar\/mix.jAr\", \"Spe1.class\");\n+        jar(\"cf\", \"MixJar\/mix2.JAR\", \"Spe2.class\");\n+        jar(\"cf\", \"MixJar\/mix3.zip\", \"Spe3.class\");\n+        jar(\"cf\", \"MixJar\/.hiddenjar.jar\", \"Spe4.class\");\n+\n+        moveFiles(listFiles(curDir, \"Spe*.class\"), Path.of(\"SpeClass\/.\"));\n+        moveFiles(listFiles(curDir, \"Spe*.java\"), Path.of(\"SpeSrc\/.\"));\n+        checkFiles(\"SpeJar\/Spe,Comma.jar\", \"SpeJar\/Spe;Semi.jar\", \"SpeSrc\/Spe2.java\", \"SpeSrc\/Spe3.\" +\n+                \"java\", \"SpeSrc\/Spe4.java\");\n+        checkFiles(\"MixJar\/mix.jAr\", \"MixJar\/mix2.JAR\", \"MixJar\/mix3.zip\", \"MixJar\/.hiddenjar.jar\");\n+\n+        Files.writeString(Path.of(\"Main.java\"), \"public class Main {public static void main(String[] a) {Lib.f();}}\");\n+        Files.writeString(Path.of(\"Main1.java\"), \"public class Main1 {public static void main(String[] a) {Lib2.g();}}\");\n+        Files.writeString(Path.of(\"Main1b.java\"), \"public class Main1b {public static void main(String[] a) {Spe1.f();}}\");\n+        Files.writeString(Path.of(\"Main2.java\"), \"public class Main2 {public static void main(String[] a) {Spe2.f();}}\");\n+        Files.writeString(Path.of(\"Main3.java\"), \"public class Main3 {public static void main(String[] a) {Spe3.f();}}\");\n+        Files.writeString(Path.of(\"Main4.java\"), \"public class Main4 {public static void main(String[] a) {Spe4.f();}}\");\n+        Files.writeString(Path.of(\"Main5.java\"), \"public class Main5 {public static void main(String[] a) {Spe2.f(); Lib.f();}}\");\n+        Files.writeString(Path.of(\"Main6.java\"), \"public class Main6 {public static void main(String[] a) {Lib3.h();}}\");\n+    }\n+\n+    void cleanup() throws IOException {\n+        deleteFiles(\"GooSrc\", \"GooJar\", \"GooZip\", \"GooClass\");\n+        deleteFiles(\"SpeSrc\", \"SpeJar\", \"SpeZip\", \"SpeClass\");\n+        deleteFiles(\"BadSrc\", \"BadJar\", \"BadZip\", \"BadClass\");\n+        deleteFiles(\"JarNClass\", \"StarJar\", \"MixJar\", \"StarDir\");\n+        deleteFiles(\"OneDir\", \"MANIFEST.MF\");\n+        deleteFiles(listFiles(curDir, \"*.class\"));\n+        deleteFiles(listFiles(curDir, \"Main*.java\"));\n+    }\n+\n+    void tests() throws Exception {\n+        if (!ToolBox.isWindows()) {\n+            starDirTests();\n+        }\n+\n+        \/*----------------------------------------------------------------\n+         * Verify the basic jar file works\n+         *----------------------------------------------------------------*\/\n+\n+        \/\/ baseline test to verify it works.\n+        expectPass(JAVAC, \"-cp GooJar\/Lib.jar Main.java\");\n+        expectPass(JAVAC, \"-classpath GooJar\/Lib.jar Main.java\");\n+        expectPass(JAVA, \"-classpath GooJar\/Lib.jar${PS}. Main\");\n+        expectPass(JAVA, \"-cp GooJar\/Lib.jar${PS}. Main\");\n+\n+        \/\/ basic test of one jar to be loaded\n+        if (!ToolBox.isWindows()) {\n+            expectPass(JAVAC, \"-classpath GooJar\/* Main.java\");\n+        }\n+        expectPass(JAVAC, \"-classpath GooJar\/*${PS}. Main.java\");\n+        expectPass(JAVA, \"-classpath GooJar\/*${PS}. Main\");\n+\n+        \/\/ in a subdir. First * should not load jars in subdirectories unless specified\n+        expectFail(JAVAC, \"-classpath GooJar\/* Main1.java\");\n+        expectFail(JAVAC, \" -classpath GooJar\/*${PS}. Main1.java\");\n+        expectPass(JAVAC, \"-cp GooJar\/SubDir\/* Main1.java\");\n+        expectPass(JAVAC, \"-classpath GooJar\/SubDir\/* Main1.java\");\n+        expectPass(JAVAC, \"--class-path GooJar\/SubDir\/* Main1.java\");\n+        expectPass(JAVAC, \"--class-path=GooJar\/SubDir\/* Main1.java\");\n+\n+        \/\/ Same with launcher. Should not load jar in subdirectories unless specified\n+        expectFail(JAVA, \"-classpath GooJar\/*${PS}. Main1\");\n+        expectPass(JAVA, \"-classpath GooJar\/SubDir\/*${PS}. Main1\");\n+        expectPass(JAVA, \"-cp GooJar\/SubDir\/*${PS}. Main1\");\n+\n+        expectPass(classpath(\"GooJar\/SubDir\/*\"), JAVAC, \"Main1.java\");\n+        expectPass(classpath(\"GooJar\/SubDir\/*${PS}.\"), JAVA, \"Main1\");\n+\n+        \/*----------------------------------------------------------------\n+         * Verify the jar files in 2 directories\n+         *----------------------------------------------------------------*\/\n+\n+        expectPass(JAVAC, \"-classpath GooJar\/Lib.jar${PS}SpeJar\/Spe,Comma.jar Main5.java\");\n+        expectPass(JAVA, \"-classpath GooJar\/Lib.jar${PS}SpeJar\/Spe,Comma.jar${PS}. Main5\");\n+\n+        expectPass(JAVAC, \"-classpath GooJar\/*${PS}SpeJar\/* Main5.java\");\n+        expectPass(JAVA, \"-classpath GooJar\/*${PS}SpeJar\/*${PS}. Main5\");\n+\n+        \/*----------------------------------------------------------------\n+         * Verify jar file and class file in same directory.\n+         *----------------------------------------------------------------*\/\n+\n+        expectPass(JAVAC, \"-classpath JarNClass\/*${PS} Main.java\");\n+        expectPass(JAVA, \"-classpath JarNClass\/*${PS}. Main\");\n+\n+        \/*----------------------------------------------------------------\n+         * Verify these odd jar files work explicitly on classpath, kind of\n+         * a baseline. Last one is also a test with * in a jar name.\n+         *----------------------------------------------------------------*\/\n+\n+        expectFail(JAVAC, \"-classpath SpeJar\/Spe:Colon.jar Main1.java\");\n+\n+        expectPass(JAVAC, \"-classpath SpeJar\/Spe,Comma.jar Main2.java\");\n+        expectPass(JAVA, \"-classpath SpeJar\/Spe,Comma.jar${PS}. Main2\");\n+\n+        if (!ToolBox.isWindows()) {\n+            expectPass(JAVAC, \"-classpath SpeJar\/Spe;Semi.jar Main3.java\");\n+            expectPass(JAVA, \"-classpath SpeJar\/Spe;Semi.jar${PS}. Main3\");\n+\n+            expectPass(JAVAC, \"-classpath SpeJar\/Spe*wc.jar Main4.java\");\n+            expectPass(JAVA, \"-classpath SpeJar\/Spe*wc.jar${PS}. Main4\");\n+        }\n+\n+        if (!ToolBox.isWindows()) {\n+            speJar();\n+        }\n+\n+        if (!ToolBox.isWindows()) {\n+            starJar();\n+        }\n+\n+        \/*----------------------------------------------------------------\n+         * Verify these jar files with varying extensions\n+         *----------------------------------------------------------------*\/\n+\n+        \/\/ Mixed case extensions should not be loaded.\n+        expectFail(JAVAC, \"-classpath MixJar\/* Main1b.java\");\n+        expectPass(JAVAC, \"-classpath MixJar\/mix.jAr Main1b.java\");\n+        expectFail(JAVAC, \"-classpath MixJar\/* Main1b\");\n+\n+        \/\/ upper case, .JAR, extension should be loaded\n+        if (!ToolBox.isWindows()) {\n+            expectPass(JAVAC, \"-classpath MixJar\/* Main2.java\");\n+        }\n+        expectPass(JAVAC, \"-classpath .${PS}MixJar\/* Main2.java\");\n+\n+        expectPass(JAVA, \"-classpath MixJar\/*${PS}. Main2\");\n+\n+        \/\/ zip extensions should not be loaded\n+        expectFail(JAVAC, \"-classpath MixJar\/* Main3.java\");\n+        expectPass(JAVAC, \"-classpath MixJar\/mix3.zip Main3.java\");\n+        expectFail(JAVA, \"-classpath MixJar\/*${PS}. Main3\");\n+\n+        \/\/ unix \"hidden\" file\n+        if (!ToolBox.isWindows()) {\n+            expectPass(JAVAC, \"-classpath MixJar\/* Main4.java\");\n+            expectPass(JAVA, \"-classpath MixJar\/*${PS}. Main4\");\n+        }\n+    }\n+\n+    void starDirTests() throws Exception {\n+        out.println(\"Running tests with directory named \\\"*\\\"\");\n+        deleteFiles(\".\/StarDir\");\n+        tb.createDirectories(\"StarDir\/*\");\n+        tb.copyFile(\"GooClass\/Lib2.class\", \"StarDir\/*\/Lib2.class\");\n+        jar(\"cf\", \"StarDir\/Lib3.jar\", \"-C\", \"GooClass\", \"Lib3.class\");\n+        jar(\"cf\", \"StarDir\/*\/Lib.jar\", \"-C\", \"GooClass\", \"Lib.class\");\n+        checkFiles(\"StarDir\/*\/Lib.jar\", \"StarDir\/*\/Lib2.class\", \"StarDir\/Lib3.jar\");\n+        tb.copyFile(\"Main6.java\", \".\/StarDir\/.\");\n+        tb.copyFile(\"Main.java\", \".\/StarDir\/*\/.\");\n+        tb.copyFile(\"Main1.java\", \".\/StarDir\/*\/.\");\n+        Path StarDir = Path.of(\"StarDir\");\n+        expectFail(StarDir, JAVAC, \"-classpath * Main6.java\");\n+        expectFail(StarDir, JAVAC, \"-classpath .\/* Main6.java\");\n+        deleteFiles(listFiles(StarDir, \"Main6.*\"));\n+        Path StarDir_star = StarDir.resolve(\"*\");\n+        expectPass(StarDir_star, JAVAC, \"-classpath * Main.java\");\n+        expectPass(StarDir_star, JAVA, \"-classpath .${PS}* Main\");\n+        expectPass(StarDir_star, JAVAC, \"Main1.java\");\n+        expectPass(StarDir_star, JAVA, \"-classpath . Main1\");\n+\n+        expectFail(JAVAC, \"-classpath StarDir\/* Main6.java\");\n+\n+        expectPass(JAVAC, \"-classpath StarDir\/* Main1.java\");\n+        expectPass(JAVA, \"-classpath StarDir\/*:. Main1\");\n+\n+        expectPass(JAVAC, \"-classpath StarDir\/* Main1.java\");\n+        expectPass(JAVA, \"-classpath .${PS}StarDir\/* Main1\");\n+\n+        expectFail(JAVAC, \"-classpath StarDir\/\\\\*\/* Main.java\");\n+        expectPass(JAVAC, \"-classpath StarDir\/*\/* Main.java\");\n+\n+        expectPass(JAVA, \"-classpath .${PS}StarDir\/*\/* Main\");\n+        expectFail(JAVA, \"-classpath .${PS}StarDir\/\\\\*\/* Main\");\n+\n+        expectPass(JAVAC, \"-classpath StarDir\/Lib3.jar Main6.java\");\n+        expectPass(JAVA, \"-classpath .${PS}StarDir\/Lib3.jar Main6\");\n+\n+        expectPass(JAVAC, \"-classpath StarDir\/*\/Lib.jar Main.java\");\n+        expectPass(JAVA, \"-classpath .${PS}StarDir\/*\/Lib.jar Main\");\n+    }\n+\n+    void speJar() throws Exception {\n+        out.println(\"Running tests with jar file names containing special characters\");\n+\n+        expectPass(JAVAC, \"-classpath SpeJar\/* Main2.java\");\n+        expectPass(JAVA, \"-classpath SpeJar\/*${PS}. Main2\");\n+\n+        expectPass(JAVAC, \"-classpath SpeJar\/* Main3.java\");\n+        expectPass(JAVA, \"-classpath SpeJar\/*${PS}. Main3\");\n+\n+        expectPass(JAVAC, \"-classpath SpeJar\/* Main4.java\");\n+        expectPass(JAVA, \"-classpath SpeJar\/*${PS}. Main4\");\n+    }\n+\n+    \/*----------------------------------------------------------------\n+     * Verify these jar files with asterisk in jar file name\n+     *----------------------------------------------------------------*\/\n+    void starJar() throws Exception {\n+        out.println(\"Running tests with jar file names containing \\\"*\\\"\");\n+        expectPass(JAVAC, \"-classpath StarJar\/*jar.jar Main2.java\");\n+        expectPass(JAVA, \"-classpath StarJar\/*jar.jar${PS}. Main2\");\n+\n+        expectPass(JAVAC, \"-classpath StarJar\/jar*.jar Main3.java\");\n+        expectPass(JAVA, \"-classpath StarJar\/jar*.jar${PS}. Main3\");\n+\n+        expectPass(JAVAC, \"-classpath StarJar\/*jar*.jar Main4.java\");\n+        expectPass(JAVA, \"-classpath StarJar\/*jar*.jar${PS}. Main4\");\n+\n+        expectPass(JAVAC, \"-classpath StarJar\/* Main2.java\");\n+        expectPass(JAVA, \"-classpath StarJar\/*${PS}. Main2\");\n+\n+        expectPass(JAVAC, \"-classpath StarJar\/* Main3.java\");\n+        expectPass(JAVA, \"-classpath StarJar\/*${PS}. Main3\");\n+\n+        expectPass(JAVAC, \"-classpath StarJar\/* Main4.java\");\n+        expectPass(JAVA, \"-classpath StarJar\/*${PS}. Main4\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/Paths\/WildcardMineField.java","additions":340,"deletions":0,"binary":false,"changes":340,"status":"added"},{"patch":"@@ -1,296 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2005, 2015, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-# @test\n-# @summary Test classpath wildcards for javac and java -classpath option.\n-# @bug 6268383 8172309\n-# @run shell\/timeout=600 wcMineField.sh\n-\n-# To run this test manually, simply do .\/wcMineField.sh\n-#----------------------------------------------------------------\n-\n-. ${TESTSRC-.}\/Util.sh\n-\n-set -u\n-\n-#----------------------------------------------------------------\n-# Note that, on Windows only, the launcher also includes another\n-# kind of command-line wildcard expansion, via setargv.obj\n-# http:\/\/msdn.microsoft.com\/library\/default.asp?url=\/library\/en-us\/vccelng\/htm\/progs_11.asp\n-# Therefore, on Windows, -classpath \"foo\/*\" is treated differently\n-# from -classpath \".${PS}foo\/*\"\n-#----------------------------------------------------------------\n-\n-#----------------------------------------------------------------\n-# Prepare the \"Minefield\"\n-#----------------------------------------------------------------\n-Cleanup() {\n-    Sys rm -rf GooSrc GooJar GooZip GooClass\n-         Sys rm -rf SpeSrc SpeJar SpeZip SpeClass\n-    Sys rm -rf BadSrc BadJar BadZip BadClass\n-         Sys rm -rf JarNClass StarJar MixJar StarDir\n-    Sys rm -rf OneDir *.class Main*.java MANIFEST.MF\n-}\n-\n-Cleanup\n-Sys mkdir  GooSrc GooJar GooZip GooClass GooJar\/SubDir\n-Sys mkdir  BadSrc BadJar BadZip BadClass\n-Sys mkdir  SpeSrc SpeJar SpeZip SpeClass\n-Sys mkdir  JarNClass StarJar MixJar\n-echo 'public class Lib  {public static void f(){}}' > Lib.java\n-echo 'public class Lib2 {public static void g(){}}' > Lib2.java\n-echo 'public class Lib3 {public static void h(){}}' > Lib3.java\n-Sys \"$javac\" ${TESTTOOLVMOPTS} Lib.java Lib2.java Lib3.java\n-Sys cp Lib.class JarNClass\/.\n-Sys \"$jar\" cf GooJar\/Lib.jar Lib.class\n-Sys \"$jar\" cf GooJar\/SubDir\/Lib2.jar Lib2.class\n-Sys \"$jar\" cf JarNClass\/Lib.jar Lib.class\n-\n-Sys \"$jar\" cf GooZip\/Lib.zip Lib.class\n-Sys mv Lib.class GooClass\/.\n-Sys mv Lib2.class GooClass\/.\n-Sys mv Lib3.class GooClass\/.\n-Sys mv Lib.java GooSrc\/.\n-Sys mv Lib2.java GooSrc\/.\n-Sys mv Lib3.java GooSrc\n-CheckFiles GooZip\/Lib.zip GooJar\/Lib.jar GooSrc\/Lib.java\n-CheckFiles GooSrc\/Lib2.java GooSrc\/Lib3.java GooJar\/SubDir\/Lib2.jar\n-\n-echo 'public class Spe1 {public static void f(){}}' > Spe1.java\n-echo 'public class Spe2 {public static void f(){}}' > Spe2.java\n-echo 'public class Spe3 {public static void f(){}}' > Spe3.java\n-echo 'public class Spe4 {public static void f(){}}' > Spe4.java\n-Sys \"$javac\" ${TESTTOOLVMOPTS} Spe1.java\n-Sys \"$javac\" ${TESTTOOLVMOPTS} Spe2.java\n-Sys \"$javac\" ${TESTTOOLVMOPTS} Spe3.java\n-Sys \"$javac\" ${TESTTOOLVMOPTS} Spe4.java\n-\n-UnixOnly Sys \"$jar\" cf \"SpeJar\/Spe:Colon.jar\" Spe1.class\n-UnixOnly Sys \"$jar\" cf \"SpeJar\/Spe*wc.jar\" Spe4.class\n-UnixOnly CheckFiles \"SpeJar\/Spe*wc.jar\"\n-\n-UnixOnly Sys \"$jar\" cf \"StarJar\/*jar.jar\" Spe2.class\n-UnixOnly Sys \"$jar\" cf \"StarJar\/jar*.jar\" Spe3.class\n-UnixOnly Sys \"$jar\" cf \"StarJar\/*jar*.jar\" Spe4.class\n-UnixOnly CheckFiles \"StarJar\/*jar.jar\" \"StarJar\/jar*.jar\" \"StarJar\/*jar*.jar\"\n-\n-Sys \"$jar\" cf \"SpeJar\/Spe,Comma.jar\" Spe2.class\n-Sys \"$jar\" cf \"SpeJar\/Spe;Semi.jar\" Spe3.class\n-\n-Sys \"$jar\" cf \"MixJar\/mix.jAr\" Spe1.class\n-Sys \"$jar\" cf \"MixJar\/mix2.JAR\" Spe2.class\n-Sys \"$jar\" cf \"MixJar\/mix3.zip\" Spe3.class\n-Sys \"$jar\" cf \"MixJar\/.hiddenjar.jar\" Spe4.class\n-\n-Sys mv Spe*.class SpeClass\/.\n-Sys mv Spe*.java SpeSrc\/.\n-CheckFiles \"SpeJar\/Spe,Comma.jar\" \"SpeJar\/Spe;Semi.jar\" \"SpeSrc\/Spe2.java\" \"SpeSrc\/Spe3.java\" \"SpeSrc\/Spe4.java\"\n-CheckFiles \"MixJar\/mix.jAr\" \"MixJar\/mix2.JAR\" \"MixJar\/mix3.zip\" \"MixJar\/.hiddenjar.jar\"\n-\n-echo 'public class Main {public static void main(String[] a) {Lib.f();}}' > Main.java\n-echo 'public class Main1 {public static void main(String[] a) {Lib2.g();}}' > Main1.java\n-echo 'public class Main1b {public static void main(String[] a) {Spe1.f();}}' > Main1b.java\n-echo 'public class Main2 {public static void main(String[] a) {Spe2.f();}}' > Main2.java\n-echo 'public class Main3 {public static void main(String[] a) {Spe3.f();}}' > Main3.java\n-echo 'public class Main4 {public static void main(String[] a) {Spe4.f();}}' > Main4.java\n-echo 'public class Main5 {public static void main(String[] a) {Spe2.f(); Lib.f();}}' > Main5.java\n-echo 'public class Main6 {public static void main(String[] a) {Lib3.h();}}' > Main6.java\n-\n-\n-#----------------------------------------------------------------\n-# Verify expected behaviour with directory named \"*\"\n-#----------------------------------------------------------------\n-starDir() {\n-    printf \"Running tests with directory named \\\"*\\\"\\n\"\n-    Sys rm -rf .\/StarDir\n-    Sys mkdir -p StarDir\/\"*\"\n-    Sys cp \"GooClass\/Lib2.class\" \"StarDir\/*\/Lib2.class\"\n-    Sys \"$jar\" cf \"StarDir\/Lib3.jar\" -C GooClass \"Lib3.class\"\n-    Sys \"$jar\" cf \"StarDir\/*\/Lib.jar\" -C GooClass \"Lib.class\"\n-    CheckFiles \"StarDir\/*\/Lib.jar\" \"StarDir\/*\/Lib2.class\" \"StarDir\/Lib3.jar\"\n-    Sys cp Main6.java .\/StarDir\/.\n-    Sys cp Main.java  .\/StarDir\/\"*\"\/.\n-    Sys cp Main1.java .\/StarDir\/\"*\"\/.\n-    CPWC_DIR=`pwd`\n-    Sys cd StarDir\n-    Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \"*\" Main6.java\n-    Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \".\/*\" Main6.java\n-    Sys rm -f Main6.*\n-    Sys cd \"*\"\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"*\" Main.java\n-    Success \"$java\" ${TESTVMOPTS} -classpath .${PS}\"*\" Main\n-    Success \"$javac\" ${TESTTOOLVMOPTS} Main1.java\n-    Success \"$java\" ${TESTVMOPTS} -classpath \".\" Main1\n-    Sys cd $CPWC_DIR\n-\n-    Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \"StarDir\/*\" Main6.java\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath StarDir\/\\* Main1.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath StarDir\/\\*:. Main1\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"StarDir\/*\" Main1.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \".${PS}StarDir\/*\" Main1\n-\n-    Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath StarDir\/\"\\*\/*\" Main.java\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath StarDir\/\"*\/*\" Main.java\n-\n-    Success \"$java\" ${TESTVMOPTS}  -classpath .${PS}StarDir\/\"*\/*\" Main\n-    Failure \"$java\" ${TESTVMOPTS}  -classpath .${PS}StarDir\/\"\\*\/*\" Main\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"StarDir\/Lib3.jar\" Main6.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \".${PS}StarDir\/Lib3.jar\" Main6\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath StarDir\/\"*\"\/Lib.jar Main.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath .${PS}StarDir\/\"*\"\/Lib.jar Main\n-}\n-UnixOnly starDir\n-\n-#----------------------------------------------------------------\n-# Verify the basic jar file works\n-#----------------------------------------------------------------\n-#baseline test to verify it works.\n-Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"GooJar\/Lib.jar\" Main.java\n-Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"GooJar\/Lib.jar\" Main.java\n-Success \"$java\" ${TESTVMOPTS}  -classpath \"GooJar\/Lib.jar${PS}.\" Main\n-Success \"$java\" ${TESTVMOPTS}  -cp \"GooJar\/Lib.jar${PS}.\" Main\n-\n-#basic test of one jar to be loaded\n-UnixOnly Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"GooJar\/*\"       Main.java\n-         Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"GooJar\/*${PS}.\" Main.java\n-Success \"$java\" ${TESTVMOPTS}  -classpath \"GooJar\/*${PS}.\" Main\n-#in a subdir. First * should not load jars in subdirectories unless specified\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \"GooJar\/*\" Main1.java\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \"GooJar\/*${PS}.\" Main1.java\n-Success \"$javac\" ${TESTTOOLVMOPTS} -cp \"GooJar\/SubDir\/*\" Main1.java\n-Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"GooJar\/SubDir\/*\" Main1.java\n-Success \"$javac\" ${TESTTOOLVMOPTS} --class-path \"GooJar\/SubDir\/*\" Main1.java\n-Success \"$javac\" ${TESTTOOLVMOPTS} --class-path=\"GooJar\/SubDir\/*\" Main1.java\n-#Same with launcher. Should not load jar in subdirectories unless specified\n-Failure \"$java\" ${TESTVMOPTS}  -classpath \"GooJar\/*${PS}.\" Main1\n-Success \"$java\" ${TESTVMOPTS}  -classpath \"GooJar\/SubDir\/*${PS}.\" Main1\n-Success \"$java\" ${TESTVMOPTS}  -cp \"GooJar\/SubDir\/*${PS}.\" Main1\n-\n-Success env CLASSPATH=\"GooJar\/SubDir\/*\" \"$javac\" ${TESTTOOLVMOPTS} Main1.java\n-Success env CLASSPATH=\"GooJar\/SubDir\/*${PS}.\" \"$java\" ${TESTVMOPTS} Main1\n-#----------------------------------------------------------------\n-# Verify the jar files in 2 directories\n-#----------------------------------------------------------------\n-Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"GooJar\/Lib.jar${PS}SpeJar\/Spe,Comma.jar\" Main5.java\n-Success \"$java\" ${TESTVMOPTS}  -classpath \"GooJar\/Lib.jar${PS}SpeJar\/Spe,Comma.jar${PS}.\" Main5\n-\n-Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"GooJar\/*${PS}SpeJar\/*\" Main5.java\n-Success \"$java\" ${TESTVMOPTS}  -classpath \"GooJar\/*${PS}SpeJar\/*${PS}.\" Main5\n-\n-#----------------------------------------------------------------\n-# Verify jar file and class file in same directory.\n-#----------------------------------------------------------------\n-Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"JarNClass\/*${PS}\" Main.java\n-Success \"$java\" ${TESTVMOPTS}  -classpath \"JarNClass\/*${PS}.\" Main\n-\n-#----------------------------------------------------------------\n-# Verify these odd jar files work explicitly on classpath, kind of\n-# a baseline. Last one is also a test with * in a jar name.\n-#----------------------------------------------------------------\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \"SpeJar\/Spe:Colon.jar\" Main1.java\n-\n-Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"SpeJar\/Spe,Comma.jar\" Main2.java\n-Success \"$java\" ${TESTVMOPTS}  -classpath \"SpeJar\/Spe,Comma.jar${PS}.\" Main2\n-\n-UnixOnly Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"SpeJar\/Spe;Semi.jar\" Main3.java\n-UnixOnly Success \"$java\" ${TESTVMOPTS}  -classpath \"SpeJar\/Spe;Semi.jar${PS}.\" Main3\n-\n-UnixOnly Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"SpeJar\/Spe*wc.jar\" Main4.java\n-UnixOnly Success \"$java\" ${TESTVMOPTS}  -classpath \"SpeJar\/Spe*wc.jar${PS}.\" Main4\n-#----------------------------------------------------------------\n-# Verify these odd jar files work with classpath wildcard.\n-#----------------------------------------------------------------\n-\n-speJar() {\n-    printf \"Running tests with jar file names containing special characters\\n\"\n-#     Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \"SpeJar\/*\" Main1.java\n-#     Success \"$java\" ${TESTVMOPTS}  -classpath \"SpeJar\/*\" Main1\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"SpeJar\/*\" Main2.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \"SpeJar\/*${PS}.\" Main2\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"SpeJar\/*\" Main3.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \"SpeJar\/*${PS}.\" Main3\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"SpeJar\/*\" Main4.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \"SpeJar\/*${PS}.\" Main4\n-}\n-UnixOnly speJar\n-\n-#----------------------------------------------------------------\n-# Verify these jar files with asterisk in jar file name\n-#----------------------------------------------------------------\n-starJar() {\n-    printf \"Running tests with jar file names containing \\\"*\\\"\\n\"\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"StarJar\/*jar.jar\" Main2.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \"StarJar\/*jar.jar${PS}.\" Main2\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"StarJar\/jar*.jar\" Main3.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \"StarJar\/jar*.jar${PS}.\" Main3\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"StarJar\/*jar*.jar\" Main4.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \"StarJar\/*jar*.jar${PS}.\" Main4\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"StarJar\/*\" Main2.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \"StarJar\/*${PS}.\" Main2\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"StarJar\/*\" Main3.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \"StarJar\/*${PS}.\" Main3\n-\n-    Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"StarJar\/*\" Main4.java\n-    Success \"$java\" ${TESTVMOPTS}  -classpath \"StarJar\/*${PS}.\" Main4\n-}\n-UnixOnly starJar\n-\n-#----------------------------------------------------------------\n-# Verify these jar files with varying extensions\n-#----------------------------------------------------------------\n-# Mixed case extensions should not be loaded.\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \"MixJar\/*\" Main1b.java\n-Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"MixJar\/mix.jAr\" Main1b.java\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \"MixJar\/*\" Main1b\n-\n-#upper case, .JAR, extension should be loaded\n-UnixOnly Success \"$javac\" ${TESTTOOLVMOPTS} -classpath       \"MixJar\/*\" Main2.java\n-         Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \".${PS}MixJar\/*\" Main2.java\n-\n-Success \"$java\" ${TESTVMOPTS}  -classpath \"MixJar\/*${PS}.\" Main2\n-# zip extensions should not be loaded\n-Failure \"$javac\" ${TESTTOOLVMOPTS} -classpath \"MixJar\/*\" Main3.java\n-Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"MixJar\/mix3.zip\" Main3.java\n-Failure \"$java\" ${TESTVMOPTS}  -classpath \"MixJar\/*${PS}.\" Main3\n-# unix \"hidden\" file\n-UnixOnly Success \"$javac\" ${TESTTOOLVMOPTS} -classpath \"MixJar\/*\" Main4.java\n-UnixOnly Success \"$java\" ${TESTVMOPTS}  -classpath \"MixJar\/*${PS}.\" Main4\n-\n-Cleanup\n-\n-Bottom Line\n-#----------------------------------------------------------------\n","filename":"test\/langtools\/tools\/javac\/Paths\/wcMineField.sh","additions":0,"deletions":296,"binary":false,"changes":296,"status":"deleted"},{"patch":"@@ -248,1 +248,1 @@\n-        } else {\n+        } else if (to.getParent() != null) {\n","filename":"test\/langtools\/tools\/lib\/toolbox\/ToolBox.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}