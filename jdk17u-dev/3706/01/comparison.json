{"files":[{"patch":"@@ -282,1 +282,1 @@\n-    static void registerPending(PendingRequest pending) {\n+    static <T> CompletableFuture<T> registerPending(PendingRequest pending, CompletableFuture<T> res) {\n@@ -285,1 +285,1 @@\n-        if (pending.cf.isDone()) return;\n+        if (pending.cf.isDone()) return res;\n@@ -292,1 +292,2 @@\n-        pending.ref = cf.whenComplete((r,t) -> client.pendingRequests.remove(pending));\n+        var ref = res.whenComplete((r,t) -> client.pendingRequests.remove(pending));\n+        pending.ref = ref;\n@@ -299,0 +300,1 @@\n+        return ref;\n@@ -878,1 +880,1 @@\n-            if (cf != null )\n+            if (cf != null) {\n@@ -880,0 +882,1 @@\n+            }\n@@ -994,7 +997,0 @@\n-            \/\/ makes sure that any dependent actions happen in the CF default\n-            \/\/ executor. This is only needed for sendAsync(...), when\n-            \/\/ exchangeExecutor is non-null.\n-            if (exchangeExecutor != null) {\n-                res = res.whenCompleteAsync((r, t) -> { \/* do nothing *\/}, ASYNC_POOL);\n-            }\n-\n@@ -1004,3 +1000,14 @@\n-            registerPending(pending);\n-            return res;\n-        } catch(Throwable t) {\n+            res = registerPending(pending, res);\n+\n+            if (exchangeExecutor != null) {\n+                \/\/ makes sure that any dependent actions happen in the CF default\n+                \/\/ executor. This is only needed for sendAsync(...), when\n+                \/\/ exchangeExecutor is non-null.\n+                return res.isDone() ? res\n+                        : res.whenCompleteAsync((r, t) -> { \/* do nothing *\/}, ASYNC_POOL);\n+            } else {\n+                \/\/ make a defensive copy that can be safely canceled\n+                \/\/ by the caller\n+                return res.isDone() ? res : res.copy();\n+            }\n+        } catch (Throwable t) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-    volatile HttpResponse<T> response = null;\n+    volatile HttpResponse<T> response;\n@@ -277,0 +277,1 @@\n+        boolean firstCancel = false;\n@@ -279,1 +280,1 @@\n-                interrupted.compareAndSet(null,\n+                firstCancel = interrupted.compareAndSet(null,\n@@ -282,0 +283,7 @@\n+            if (debug.on()) {\n+                if (firstCancel) {\n+                    debug.log(\"multi exchange recording: \" + interrupted.get());\n+                } else {\n+                    debug.log(\"multi exchange recorded: \" + interrupted.get());\n+                }\n+            }\n@@ -363,0 +371,16 @@\n+    \/\/ returns a CancellationExcpetion that wraps the given cause\n+    \/\/ if cancel(boolean) was called, the given cause otherwise\n+    private Throwable wrapIfCancelled(Throwable cause) {\n+        CancellationException interrupt = interrupted.get();\n+        if (interrupt == null) return cause;\n+\n+        var cancel = new CancellationException(interrupt.getMessage());\n+        \/\/ preserve the stack trace of the original exception to\n+        \/\/ show where the call to cancel(boolean) came from\n+        cancel.setStackTrace(interrupt.getStackTrace());\n+        cancel.initCause(Utils.getCancelCause(cause));\n+        return cancel;\n+    }\n+\n+    \/\/ if the request failed because the multi exchange was cancelled,\n+    \/\/ make sure the reported exception is wrapped in CancellationException\n@@ -364,5 +388,2 @@\n-        CancellationException x = interrupted.get();\n-        if (x != null) {\n-            \/\/ make sure to fail with CancellationException if cancel(true)\n-            \/\/ was called.\n-            t = x.initCause(Utils.getCancelCause(t));\n+        var x = wrapIfCancelled(t);\n+        if (x instanceof CancellationException) {\n@@ -370,1 +391,1 @@\n-                debug.log(\"MultiExchange interrupted with: \" + t.getCause());\n+                debug.log(\"MultiExchange interrupted with: \" + x.getCause());\n@@ -373,1 +394,1 @@\n-        return MinimalFuture.failedFuture(t);\n+        return MinimalFuture.failedFuture(x);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/MultiExchange.java","additions":30,"deletions":9,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -0,0 +1,423 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import jdk.internal.net.http.common.OperationTrackers.Tracker;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8316580\n+ * @library \/test\/lib\n+ * @run junit\/othervm -Djdk.tracePinnedThreads=full\n+ *                   -DuseReferenceTracker=true\n+ *                   HttpGetInCancelledFuture\n+ * @summary This test verifies that cancelling a future that\n+ * does an HTTP request using the HttpClient doesn't cause\n+ * HttpClient::close to block forever.\n+ *\/\n+public class HttpGetInCancelledFuture {\n+\n+    static final boolean useTracker = Boolean.getBoolean(\"useReferenceTracker\");\n+\n+    static final class TestException extends RuntimeException {\n+        public TestException(String message, Throwable cause) {\n+            super(message, cause);\n+        }\n+    }\n+\n+    static ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+\n+    HttpClient makeClient(URI uri, Version version, Executor executor) {\n+        var builder = HttpClient.newBuilder();\n+        if (uri.getScheme().equalsIgnoreCase(\"https\")) {\n+            try {\n+                builder.sslContext(new SimpleSSLContext().get());\n+            } catch (IOException io) {\n+                throw new UncheckedIOException(io);\n+            }\n+        }\n+        return builder.connectTimeout(Duration.ofSeconds(1))\n+                .executor(executor)\n+                .version(version)\n+                .build();\n+    }\n+\n+    record TestCase(String url, int reqCount, Version version) {}\n+    \/\/ A server that doesn't accept\n+    static volatile ServerSocket NOT_ACCEPTING;\n+\n+    static List<TestCase> parameters() {\n+        ServerSocket ss = NOT_ACCEPTING;\n+        if (ss == null) {\n+            synchronized (HttpGetInCancelledFuture.class) {\n+                if ((ss = NOT_ACCEPTING) == null) {\n+                    try {\n+                        ss = new ServerSocket();\n+                        var loopback = InetAddress.getLoopbackAddress();\n+                        ss.bind(new InetSocketAddress(loopback, 0), 10);\n+                        NOT_ACCEPTING = ss;\n+                    } catch (IOException io) {\n+                        throw new UncheckedIOException(io);\n+                    }\n+                }\n+            }\n+        }\n+        URI http = URIBuilder.newBuilder()\n+                .loopback()\n+                .scheme(\"http\")\n+                .port(ss.getLocalPort())\n+                .path(\"\/not-accepting\/\")\n+                .buildUnchecked();\n+        URI https = URIBuilder.newBuilder()\n+                .loopback()\n+                .scheme(\"https\")\n+                .port(ss.getLocalPort())\n+                .path(\"\/not-accepting\/\")\n+                .buildUnchecked();\n+        \/\/ use all HTTP versions, without and with TLS\n+        return List.of(\n+                new TestCase(http.toString(), 200, Version.HTTP_2),\n+                new TestCase(http.toString(), 200, Version.HTTP_1_1),\n+                new TestCase(https.toString(), 200, Version.HTTP_2),\n+                new TestCase(https.toString(), 200, Version.HTTP_1_1)\n+                );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"parameters\")\n+    void runTest(TestCase test) {\n+        System.out.println(\"Testing with: \" + test);\n+        runTest(test.url, test.reqCount, test.version);\n+    }\n+\n+    static class TestTaskScope implements AutoCloseable {\n+        final ExecutorService pool = new ForkJoinPool();\n+        final Map<Task<?>, Future<?>> tasks = new ConcurrentHashMap<>();\n+        final AtomicReference<ExecutionException> failed = new AtomicReference<>();\n+\n+        class Task<T> implements Callable<T> {\n+            final Callable<T> task;\n+            final CompletableFuture<T> cf = new CompletableFuture<>();\n+            Task(Callable<T> task) {\n+                this.task = task;\n+            }\n+            @Override\n+            public T call() throws Exception {\n+                try {\n+                    var res = task.call();\n+                    cf.complete(res);\n+                    return res;\n+                } catch (Throwable t) {\n+                    cf.completeExceptionally(t);\n+                    throw t;\n+                }\n+            }\n+            CompletableFuture<T> cf() {\n+                return cf;\n+            }\n+        }\n+\n+\n+        static class ShutdownOnFailure extends TestTaskScope {\n+            public ShutdownOnFailure() {}\n+\n+            @Override\n+            protected <T> void completed(Task<T> task, T result, Throwable throwable) {\n+                super.completed(task, result, throwable);\n+                if (throwable != null) {\n+                    if (failed.get() == null) {\n+                        ExecutionException ex = throwable instanceof ExecutionException x\n+                                ? x : new ExecutionException(throwable);\n+                        failed.compareAndSet(null, ex);\n+                    }\n+                    tasks.entrySet().forEach(this::cancel);\n+                }\n+            }\n+\n+            void cancel(Map.Entry<Task<?>, Future<?>> entry) {\n+                entry.getValue().cancel(true);\n+                entry.getKey().cf().cancel(true);\n+                tasks.remove(entry.getKey(), entry.getValue());\n+            }\n+\n+            @Override\n+            public <T> CompletableFuture<T> fork(Callable<T> callable) {\n+                var ex = failed.get();\n+                if (ex == null) {\n+                    return super.fork(callable);\n+                } \/\/ otherwise do nothing\n+                return CompletableFuture.failedFuture(new RejectedExecutionException());\n+            }\n+        }\n+\n+        public <T> CompletableFuture<T> fork(Callable<T> callable) {\n+            var task = new Task<>(callable);\n+            var res = pool.submit(task);\n+            tasks.put(task, res);\n+            task.cf.whenComplete((r,t) -> completed(task, r, t));\n+            return task.cf;\n+        }\n+\n+        protected <T> void completed(Task<T> task, T result, Throwable throwable) {\n+            tasks.remove(task);\n+        }\n+\n+        public void join() throws InterruptedException {\n+            try {\n+                var cfs = tasks.keySet().stream()\n+                        .map(Task::cf).toArray(CompletableFuture[]::new);\n+                CompletableFuture.allOf(cfs).get();\n+            } catch (InterruptedException it) {\n+                throw it;\n+            } catch (ExecutionException ex) {\n+                failed.compareAndSet(null, ex);\n+            }\n+        }\n+\n+        public void throwIfFailed() throws ExecutionException {\n+            ExecutionException x = failed.get();\n+            if (x != null) throw x;\n+        }\n+\n+        public void close() {\n+            \/\/ ForkJoinPool does not implement AutoClosable in 17.\n+            \/\/pool.close();\n+            \/\/pool.shutdownNow();\n+            pool.shutdown();\n+            try {\n+                pool.awaitTermination(1, TimeUnit.DAYS);\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+            }\n+        }\n+    }\n+\n+    ExecutorService testExecutor() {\n+        return Executors.newCachedThreadPool();\n+    }\n+\n+    void runTest(String url, int reqCount, Version version) {\n+        final var dest = URI.create(url);\n+        ExecutorService executor = null;\n+        try {\n+            executor = testExecutor();\n+            HttpClient httpClient = makeClient(dest, version, executor);\n+            TRACKER.track(httpClient);\n+            Tracker tracker = TRACKER.getTracker(httpClient);\n+            Throwable failed = null;\n+            try {\n+                try (final var scope = new TestTaskScope.ShutdownOnFailure()) {\n+                    launchAndProcessRequests(scope, httpClient, reqCount, dest);\n+                } finally {\n+                    System.out.printf(\"StructuredTaskScope closed: STARTED=%s, SUCCESS=%s, INTERRUPT=%s, FAILED=%s%n\",\n+                            STARTED.get(), SUCCESS.get(), INTERRUPT.get(), FAILED.get());\n+                }\n+                System.out.println(\"ERROR: Expected TestException not thrown\");\n+                throw new AssertionError(\"Expected TestException not thrown\");\n+            } catch (TestException x) {\n+                System.out.println(\"Got expected exception: \" + x);\n+            } catch (Throwable t) {\n+                System.out.println(\"ERROR: Unexpected exception: \" + t);\n+                failed = t;\n+                throw t;\n+            } finally {\n+                \/\/ we can either use the tracker or call HttpClient::close\n+                if (useTracker) {\n+                    \/\/ using the tracker depends on GC but will give us some diagnostic\n+                    \/\/ if some operations are not properly cancelled and prevent the client\n+                    \/\/ from terminating\n+                    httpClient = null;\n+                    System.gc();\n+                    System.out.println(TRACKER.diagnose(tracker));\n+                    var error = TRACKER.check(tracker, 10000);\n+                    if (error != null) {\n+                        if (failed != null) error.addSuppressed(failed);\n+                        EXCEPTIONS.forEach(x -> {\n+                            System.out.println(\"FAILED: \" + x);\n+                        });\n+                        EXCEPTIONS.forEach(x -> {\n+                            x.printStackTrace(System.out);\n+                        });\n+                        throw error;\n+                    }\n+                } else {\n+                    \/\/ if not all operations terminate, close() will block\n+                    \/\/ forever and the test will fail in jtreg timeout.\n+                    \/\/ there will be no diagnostic.\n+                    \/\/httpClient.close();\n+                    \/\/ HttpClient does not implement AutoClosable in 17.\n+                    \/\/ Omitting this test variant.\n+                }\n+                System.out.println(\"HttpClient closed\");\n+            }\n+        } finally {\n+            \/\/ ExecutorService does not implement AutoClosable in 17.\n+            \/\/ Taken from ExecutorService close() implementation in 21.\n+            if (executor != null) {\n+                boolean terminated = executor.isTerminated();\n+                if (!terminated) {\n+                    executor.shutdown();\n+                    boolean interrupted = false;\n+                    while (!terminated) {\n+                        try {\n+                            terminated = executor.awaitTermination(1L, TimeUnit.DAYS);\n+                        } catch (InterruptedException e) {\n+                            if (!interrupted) {\n+                                executor.shutdownNow();\n+                                interrupted = true;\n+                            }\n+                        }\n+                    }\n+                    if (interrupted) {\n+                        Thread.currentThread().interrupt();\n+                    }\n+                }\n+            }\n+            System.out.println(\"ThreadExecutor closed\");\n+        }\n+        \/\/ not all tasks may have been started before the scope was cancelled\n+        \/\/ due to the first connect\/timeout exception, but all tasks that started\n+        \/\/ must have either succeeded, be interrupted, or failed\n+        assertTrue(STARTED.get() > 0);\n+        assertEquals(STARTED.get(), SUCCESS.get() + INTERRUPT.get() + FAILED.get());\n+        if (SUCCESS.get() > 0) {\n+            \/\/ we don't expect any server to be listening and responding\n+            System.out.println(\"WARNING: got some unexpected successful responses from \"\n+                    + \"\\\"\" + NOT_ACCEPTING.getLocalSocketAddress() + \"\\\": \" + SUCCESS.get());\n+        }\n+    }\n+\n+    private void launchAndProcessRequests(\n+            TestTaskScope.ShutdownOnFailure scope,\n+            HttpClient httpClient,\n+            int reqCount,\n+            URI dest) {\n+        for (int counter = 0; counter < reqCount; counter++) {\n+            scope.fork(() ->\n+                    getAndCheck(httpClient, dest)\n+            );\n+        }\n+        try {\n+            scope.join();\n+        } catch (InterruptedException e) {\n+            throw new AssertionError(\"scope.join() was interrupted\", e);\n+        }\n+        try {\n+            scope.throwIfFailed();\n+        } catch (ExecutionException e) {\n+            throw new TestException(\"something threw an exception in StructuredTaskScope\", e);\n+        }\n+    }\n+\n+    final static AtomicLong ID = new AtomicLong();\n+    final AtomicLong SUCCESS = new AtomicLong();\n+    final AtomicLong INTERRUPT = new AtomicLong();\n+    final AtomicLong FAILED = new AtomicLong();\n+    final AtomicLong STARTED = new AtomicLong();\n+    final CopyOnWriteArrayList<Exception> EXCEPTIONS = new CopyOnWriteArrayList<>();\n+    private String getAndCheck(HttpClient httpClient, URI url) {\n+        STARTED.incrementAndGet();\n+        final var response = sendRequest(httpClient, url);\n+        String res = response.body();\n+        int statusCode = response.statusCode();\n+        assertEquals(200, statusCode);\n+        return res;\n+    }\n+\n+    private HttpResponse<String> sendRequest(HttpClient httpClient, URI url) {\n+        var id = ID.incrementAndGet();\n+        try {\n+            var request = HttpRequest.newBuilder(url).GET().build();\n+            var response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n+            \/\/ System.out.println(\"Got response for \" + id + \": \" + response);\n+            SUCCESS.incrementAndGet();\n+            return response;\n+        } catch (InterruptedException e) {\n+            INTERRUPT.incrementAndGet();\n+            \/\/ System.out.println(\"Got interrupted for \" + id + \": \" + e);\n+            throw new RuntimeException(e);\n+        } catch (Exception e) {\n+            FAILED.incrementAndGet();\n+            EXCEPTIONS.add(e);\n+            \/\/System.out.println(\"Got exception for \" + id + \": \" + e);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @AfterAll\n+    static void tearDown() {\n+        try {\n+            System.gc();\n+            var error = TRACKER.check(5000);\n+            if (error != null) throw error;\n+        } finally {\n+            ServerSocket ss;\n+            synchronized (HttpGetInCancelledFuture.class) {\n+                ss = NOT_ACCEPTING;\n+                NOT_ACCEPTING = null;\n+            }\n+            if (ss != null) {\n+                try {\n+                    ss.close();\n+                } catch (IOException io) {\n+                    throw new UncheckedIOException(io);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpGetInCancelledFuture.java","additions":423,"deletions":0,"binary":false,"changes":423,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,8 @@\n+    public StringBuilder diagnose(Tracker tracker) {\n+        return diagnose(tracker, new StringBuilder(), (t) -> t.getOutstandingHttpOperations() > 0);\n+    }\n+\n+    public StringBuilder diagnose(HttpClient client) {\n+        return diagnose(getTracker(client));\n+    }\n+\n@@ -241,0 +249,5 @@\n+            if (i == 0 && waited == 0) {\n+                \/\/ we found nothing and didn't wait expecting success, but then found\n+                \/\/ something. Respin to make sure we wait.\n+                return check(tracker, graceDelayMs, hasOutstanding, description, printThreads);\n+            }\n@@ -297,0 +310,5 @@\n+            if (i == 0 && waited == 0) {\n+                \/\/ we found nothing and didn't wait expecting success, but then found\n+                \/\/ something. Respin to make sure we wait.\n+                return check(graceDelayMs, hasOutstanding, description, printThreads);\n+            }\n","filename":"test\/jdk\/java\/net\/httpclient\/ReferenceTracker.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"}]}