{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -359,1 +359,4 @@\n-        output.shouldBeEmptyIgnoreVMWarnings();\n+        List<String> stdout = output.asLinesWithoutVMWarnings();\n+        output.reportDiagnosticSummary();\n+        assertEquals(stdout.size(), 1, \"Output should contain one line\");\n+        assertTrue(stdout.get(0).startsWith(\"jstatd started\"), \"List should start with 'jstatd started'\");\n","filename":"test\/jdk\/sun\/tools\/jstatd\/JstatdTest.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Unit test for ProcessTools.startProcess()\n+ * @library \/test\/lib\n+ * @compile ProcessToolsStartProcessTest.java\n+ * @run main ProcessToolsStartProcessTest\n+ *\/\n+\n+import java.util.function.Consumer;\n+import java.io.File;\n+\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class ProcessToolsStartProcessTest {\n+    static String output = \"\";\n+\n+    private static Consumer<String> outputConsumer = s -> {\n+        output += s + \"\\n\";\n+    };\n+\n+    static boolean testStartProcess(int numOfLines, boolean withConsumer) throws Exception {\n+        boolean success = true;\n+        output = \"\";\n+        Process p;\n+        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"java\");\n+        launcher.addToolArg(\"-cp\");\n+        launcher.addToolArg(Utils.TEST_CLASSES);\n+        launcher.addToolArg(\"ProcessToolsStartProcessTest\");\n+        launcher.addToolArg(Integer.toString(numOfLines));\n+        ProcessBuilder pb = new ProcessBuilder();\n+        pb.command(launcher.getCommand());\n+\n+        System.out.println(\"DEBUG: Test with withConsumer=\" + withConsumer);\n+        System.out.println(\"DEBUG: about to start process.\");\n+        if (withConsumer) {\n+            p = ProcessTools.startProcess(\"java\", pb, outputConsumer);\n+        } else {\n+            p = ProcessTools.startProcess(\"java\", pb);\n+        }\n+        OutputAnalyzer out = new OutputAnalyzer(p);\n+\n+        System.out.println(\"DEBUG: process started.\");\n+        p.waitFor();\n+        if (p.exitValue() != 0) {\n+            throw new RuntimeException(\"Bad exit value: \" + p.exitValue());\n+        }\n+\n+        if (withConsumer) {\n+            int numLines = output.split(\"\\n\").length;\n+            if (numLines != numOfLines) {\n+                System.out.print(\"FAILED: wrong number of lines in Consumer output\\n\");\n+                success = false;\n+                System.out.print(output);\n+            }\n+        }\n+\n+        int numLinesOut = out.getStdout().split(\"\\n\").length;\n+        if (numLinesOut != numOfLines) {\n+            System.out.print(\"FAILED: wrong number of lines in OutputAnalyzer output\\n\");\n+            System.out.print(out.getStdout());\n+            success = false;\n+        }\n+\n+        return success;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length > 0) {\n+            int iter = Integer.parseInt(args[0]);\n+            for (int i = 0; i < iter; i++) {\n+                System.out.println(\"A line on stdout: \" + i + \" \" + \".\".repeat(i));\n+            }\n+        } else {\n+            for (int i = 1; i < 5; i++) {\n+                System.out.println(\"ITERATION \" + i);\n+                boolean test1Result = testStartProcess(i * 10 + i, false);\n+                if (!test1Result) {\n+                    throw new RuntimeException(\"First test (no consumer) failed. See output for details.\");\n+                }\n+                boolean test2Result = testStartProcess(i * 10 + i, true);\n+                if (!test2Result) {\n+                    throw new RuntimeException(\"Second test (with consumer) failed. See output for details.\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/process\/ProcessToolsStartProcessTest.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import java.io.ByteArrayOutputStream;\n@@ -47,0 +48,1 @@\n+import java.util.concurrent.CancellationException;\n@@ -71,1 +73,0 @@\n-\n@@ -78,1 +79,5 @@\n-     *\n+     * <p>\n+     * Same as\n+     * {@linkplain #startProcess(String, ProcessBuilder, Consumer, Predicate, long, TimeUnit) startProcess}\n+     * {@code (name, processBuilder, null, null, -1, TimeUnit.NANOSECONDS)}\n+     * <\/p>\n@@ -93,1 +98,5 @@\n-     * <p>It is possible to monitor the in-streams via the provided {@code consumer}\n+     * <p>\n+     * Same as\n+     * {@linkplain #startProcess(String, ProcessBuilder, Consumer, Predicate, long, TimeUnit) startProcess}\n+     * {@code (name, processBuilder, consumer, null, -1, TimeUnit.NANOSECONDS)}\n+     * <\/p>\n@@ -96,1 +105,0 @@\n-     * @param consumer       {@linkplain Consumer} instance to process the in-streams\n@@ -98,0 +106,1 @@\n+     * @param consumer       {@linkplain Consumer} instance to process the in-streams\n@@ -108,1 +117,1 @@\n-        } catch (InterruptedException | TimeoutException e) {\n+        } catch (InterruptedException | TimeoutException | CancellationException e) {\n@@ -118,2 +127,3 @@\n-     * It is possible to wait for the process to get to a warmed-up state\n-     * via {@linkplain Predicate} condition on the STDOUT\/STDERR\n+     * Same as\n+     * {@linkplain #startProcess(String, ProcessBuilder, Consumer, Predicate, long, TimeUnit) startProcess}\n+     * {@code (name, processBuilder, null, linePredicate, timeout, unit)}\n@@ -144,0 +154,67 @@\n+\n+    \/*\n+        BufferOutputStream and BufferInputStream allow to re-use p.getInputStream() amd p.getOutputStream() of\n+        processes started with ProcessTools.startProcess(...).\n+        Implementation cashes ALL process output and allow to read it through InputStream.\n+        The stream uses  Future<Void> task from StreamPumper.process() to check if output is complete.\n+     *\/\n+    private static class BufferOutputStream extends ByteArrayOutputStream {\n+        private int current = 0;\n+        final private Process p;\n+\n+        private Future<Void> task;\n+\n+        public BufferOutputStream(Process p) {\n+            this.p = p;\n+        }\n+\n+        synchronized void setTask(Future<Void> task) {\n+            this.task = task;\n+        }\n+        synchronized int readNext() {\n+            if (current > count) {\n+                throw new RuntimeException(\"Shouldn't ever happen.  start: \"\n+                        + current + \" count: \" + count + \" buffer: \" + this);\n+            }\n+            while (current == count) {\n+                if (!p.isAlive() && (task != null)) {\n+                    try {\n+                        task.get(10, TimeUnit.MILLISECONDS);\n+                        if (current == count) {\n+                            return -1;\n+                        }\n+                    } catch (TimeoutException e) {\n+                        \/\/ continue execution, so wait() give a chance to write\n+                    } catch (InterruptedException | ExecutionException e) {\n+                        return -1;\n+                    }\n+                }\n+                try {\n+                    wait(1);\n+                } catch (InterruptedException ie) {\n+                    return -1;\n+                }\n+            }\n+            return this.buf[current++];\n+        }\n+    }\n+\n+    private static class BufferInputStream extends InputStream {\n+\n+        private final BufferOutputStream buffer;\n+\n+        public BufferInputStream(Process p) {\n+            buffer = new BufferOutputStream(p);\n+        }\n+\n+        BufferOutputStream getOutputStream() {\n+            return buffer;\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            return buffer.readNext();\n+        }\n+    }\n+\n+\n@@ -181,0 +258,8 @@\n+\n+\n+        BufferInputStream stdOut = new BufferInputStream(p);\n+        BufferInputStream stdErr = new BufferInputStream(p);\n+\n+        stdout.addOutputStream(stdOut.getOutputStream());\n+        stderr.addOutputStream(stdErr.getOutputStream());\n+\n@@ -192,1 +277,0 @@\n-\n@@ -215,0 +299,3 @@\n+        stdOut.getOutputStream().setTask(stdoutTask);\n+        stdErr.getOutputStream().setTask(stderrTask);\n+\n@@ -240,1 +327,1 @@\n-        return new ProcessImpl(p, stdoutTask, stderrTask);\n+        return new ProcessImpl(p, stdoutTask, stderrTask, stdOut, stdErr);\n@@ -618,0 +705,2 @@\n+        private final InputStream stdOut;\n+        private final InputStream stdErr;\n@@ -622,1 +711,2 @@\n-        public ProcessImpl(Process p, Future<Void> stdoutTask, Future<Void> stderrTask) {\n+        public ProcessImpl(Process p, Future<Void> stdoutTask, Future<Void> stderrTask,\n+                           InputStream stdOut, InputStream etdErr) {\n@@ -626,0 +716,2 @@\n+            this.stdOut = stdOut;\n+            this.stdErr = etdErr;\n@@ -635,1 +727,1 @@\n-            return p.getInputStream();\n+            return stdOut;\n@@ -640,1 +732,1 @@\n-            return p.getErrorStream();\n+            return stdErr;\n","filename":"test\/lib\/jdk\/test\/lib\/process\/ProcessTools.java","additions":104,"deletions":12,"binary":false,"changes":116,"status":"modified"}]}