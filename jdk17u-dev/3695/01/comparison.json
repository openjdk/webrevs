{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -212,1 +212,1 @@\n-        protected void onSubscribed() {\n+        protected void register() {\n@@ -217,13 +217,1 @@\n-        protected void complete(Throwable t) {\n-            try {\n-                exchange.unregisterResponseSubscriber(this);\n-            } finally {\n-                super.complete(t);\n-            }\n-        }\n-\n-        @Override\n-        protected void onCancel() {\n-            \/\/ If the subscription is cancelled the\n-            \/\/ subscriber may or may not get completed.\n-            \/\/ Therefore we need to unregister it\n+        protected void unregister() {\n@@ -281,1 +269,1 @@\n-    private void registerResponseSubscriber(Http1ResponseBodySubscriber<T> subscriber) {\n+    private boolean registerResponseSubscriber(Http1ResponseBodySubscriber<T> subscriber) {\n@@ -291,0 +279,1 @@\n+            return false;\n@@ -292,1 +281,1 @@\n-            client.registerSubscriber(subscriber);\n+            return client.registerSubscriber(subscriber);\n@@ -296,2 +285,2 @@\n-    private void unregisterResponseSubscriber(Http1ResponseBodySubscriber<T> subscriber) {\n-        client.unregisterSubscriber(subscriber);\n+    private boolean unregisterResponseSubscriber(Http1ResponseBodySubscriber<T> subscriber) {\n+        return client.unregisterSubscriber(subscriber);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Exchange.java","additions":8,"deletions":19,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -545,1 +545,8 @@\n-    public void registerSubscriber(HttpBodySubscriberWrapper<?> subscriber) {\n+    \/**\n+     * Adds the given subscriber to the subscribers list, or call\n+     * its {@linkplain HttpBodySubscriberWrapper#onError onError}\n+     * method if the client is shutting down.\n+     * @param subscriber the subscriber\n+     * @return true if the subscriber was added to the list.\n+     *\/\n+    public boolean registerSubscriber(HttpBodySubscriberWrapper<?> subscriber) {\n@@ -555,1 +562,1 @@\n-                    return;\n+                    return true;\n@@ -560,0 +567,1 @@\n+        return false;\n@@ -562,1 +570,6 @@\n-    public void unregisterSubscriber(HttpBodySubscriberWrapper<?> subscriber) {\n+    \/**\n+     * Remove the given subscriber from the subscribers list.\n+     * @param subscriber the subscriber\n+     * @return true if the subscriber was found and removed from the list.\n+     *\/\n+    public boolean unregisterSubscriber(HttpBodySubscriberWrapper<?> subscriber) {\n@@ -568,0 +581,1 @@\n+            return true;\n@@ -569,0 +583,1 @@\n+        return false;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -543,1 +543,1 @@\n-            if (debug.on()) debug.log(\"onSubscribed called\");\n+            if (debug.on()) debug.log(\"onSubscribe called\");\n@@ -557,2 +557,2 @@\n-                            \/\/ should contain at least 2\n-                            assert buffers.remainingCapacity() > 1\n+                            \/\/ should contain at least 2, unless closed or failed.\n+                            assert buffers.remainingCapacity() > 1 || failed != null\n@@ -560,1 +560,3 @@\n-                                    + \" closed: \" + closed + \" failed: \" + failed;\n+                                    + \", closed: \" + closed + \", terminated: \"\n+                                    + buffers.contains(LAST_LIST)\n+                                    + \", failed: \" + failed;\n@@ -576,1 +578,1 @@\n-                    debug.log(\"onSubscribed failed\", t);\n+                    debug.log(\"onSubscribe failed\", t);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ResponseSubscribers.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -355,2 +355,2 @@\n-    private void registerResponseSubscriber(Http2StreamResponseSubscriber<?> subscriber) {\n-        client().registerSubscriber(subscriber);\n+    private boolean registerResponseSubscriber(Http2StreamResponseSubscriber<?> subscriber) {\n+        return client().registerSubscriber(subscriber);\n@@ -359,2 +359,2 @@\n-    private void unregisterResponseSubscriber(Http2StreamResponseSubscriber<?> subscriber) {\n-        client().unregisterSubscriber(subscriber);\n+    private boolean unregisterResponseSubscriber(Http2StreamResponseSubscriber<?> subscriber) {\n+        return client().unregisterSubscriber(subscriber);\n@@ -1695,1 +1695,1 @@\n-        protected void onSubscribed() {\n+        protected void register() {\n@@ -1700,10 +1700,1 @@\n-        protected void complete(Throwable t) {\n-            try {\n-                unregisterResponseSubscriber(this);\n-            } finally {\n-                super.complete(t);\n-            }\n-        }\n-\n-        @Override\n-        protected void onCancel() {\n+        protected void unregister() {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,6 @@\n+    static final int SUBSCRIBED = 1;\n+    static final int REGISTERED = 2;\n+    static final int COMPLETED = 4;\n+    static final int CANCELLED = 8;\n+    static final int UNREGISTERED = 16;\n+\n@@ -64,2 +70,1 @@\n-    final AtomicBoolean completed = new AtomicBoolean();\n-    final AtomicBoolean subscribed = new AtomicBoolean();\n+    private volatile int state;\n@@ -86,2 +91,7 @@\n-                subscription.cancel();\n-                onCancel();\n+                try {\n+                    subscription.cancel();\n+                } finally {\n+                    if (markCancelled()) {\n+                        onCancel();\n+                    }\n+                }\n@@ -94,0 +104,36 @@\n+    private final boolean markState(final int flag) {\n+        int state = this.state;\n+        if ((state & flag) == flag) {\n+            return false;\n+        }\n+        synchronized (this) {\n+            state = this.state;\n+            if ((state & flag) == flag) {\n+                return false;\n+            }\n+            state = this.state = (state | flag);\n+        }\n+        assert (state & flag) == flag;\n+        return true;\n+    }\n+\n+    private boolean markSubscribed() {\n+        return markState(SUBSCRIBED);\n+    }\n+\n+    private boolean markCancelled() {\n+        return markState(CANCELLED);\n+    }\n+\n+    private boolean markCompleted() {\n+        return markState(COMPLETED);\n+    }\n+\n+    private boolean markRegistered() {\n+        return markState(REGISTERED);\n+    }\n+\n+    private boolean markUnregistered() {\n+        return markState(UNREGISTERED);\n+    }\n+\n@@ -104,0 +150,1 @@\n+        var state = this.state;\n@@ -105,1 +152,1 @@\n-        assert completed.get();\n+        assert (state & COMPLETED) != 0;\n@@ -114,1 +161,1 @@\n-                if (subscribed.compareAndSet(false, true)) {\n+                if (markSubscribed()) {\n@@ -129,1 +176,64 @@\n-     * Called when the subscriber cancels its subscription.\n+     * This method attempts to mark the state of this\n+     * object as registered, and then call the\n+     * {@link #register()} method.\n+     * <p>\n+     * The state will be marked as registered, and the\n+     * {@code register()} method will be called only\n+     * if not already registered or unregistered,\n+     * or cancelled, or completed.\n+     *\n+     * @return {@code true} if {@link #register()} was called,\n+     * false otherwise.\n+     *\/\n+    protected final boolean tryRegister() {\n+        subscriptionLock.lock();\n+        try {\n+            int state = this.state;\n+            if ((state & (REGISTERED | UNREGISTERED | CANCELLED | COMPLETED)) != 0) return false;\n+            if (markRegistered()) {\n+                register();\n+                return true;\n+            }\n+        } finally {\n+            subscriptionLock.unlock();\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * This method attempts to mark the state of this\n+     * object as unregistered, and then call the\n+     * {@link #unregister()} method.\n+     * <p>\n+     * The {@code unregister()} method will be called only\n+     * if already registered and not yet unregistered.\n+     * Whether {@code unregister()} is called or not,\n+     * the state is marked as unregistered, to prevent\n+     * {@link #tryRegister()} from calling {@link #register()}\n+     * after {@link #tryUnregister()} has been called.\n+     *\n+     * @return {@code true} if {@link #unregister()} was called,\n+     * false otherwise.\n+     *\/\n+    protected final boolean tryUnregister() {\n+        subscriptionLock.lock();\n+        try {\n+            int state = this.state;\n+            if ((state & REGISTERED) == 0) {\n+                markUnregistered();\n+                return false;\n+            }\n+            if (markUnregistered()) {\n+                unregister();\n+                return true;\n+            }\n+        } finally {\n+            subscriptionLock.unlock();\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * This method can be implemented by subclasses\n+     * to perform registration actions. It will not be\n+     * called if already registered or unregistered.\n@@ -131,2 +241,16 @@\n-     * This method may be used by subclasses to perform cleanup\n-     * actions after a subscription has been cancelled.\n+     * This method is called while holding a subscription\n+     * lock.\n+     * @see #tryRegister()\n+     *\/\n+    protected void register() {\n+        assert subscriptionLock.isHeldByCurrentThread();\n+    }\n+\n+    \/**\n+     * This method can be implemented by subclasses\n+     * to perform unregistration actions. It will not be\n+     * called if not already registered, or already unregistered.\n+     * @apiNote\n+     * This method is called while holding a subscription\n+     * lock.\n+     * @see #tryUnregister()\n@@ -134,1 +258,3 @@\n-    protected void onCancel() { }\n+    protected void unregister() {\n+        assert subscriptionLock.isHeldByCurrentThread();\n+    }\n@@ -137,1 +263,1 @@\n-     * Called right before the userSubscriber::onSubscribe is called.\n+     * Called when the subscriber cancels its subscription.\n@@ -140,2 +266,3 @@\n-     * related actions after a subscription has been succesfully\n-     * accepted.\n+     * actions after a subscription has been cancelled.\n+     * @implSpec\n+     * This method calls {@link #tryUnregister()}\n@@ -143,1 +270,6 @@\n-    protected void onSubscribed() { }\n+    protected void onCancel() {\n+        \/\/ If the subscription is cancelled the\n+        \/\/ subscriber may or may not get completed.\n+        \/\/ Therefore we need to unregister it\n+        tryUnregister();\n+    }\n@@ -149,0 +281,3 @@\n+     * @implSpec\n+     * If not {@linkplain #completed()} yet, this method\n+     * calls {@link #tryUnregister()}\n@@ -150,2 +285,3 @@\n-    protected void complete(Throwable t) {\n-        if (completed.compareAndSet(false, true)) {\n+    public final void complete(Throwable t) {\n+        if (markCompleted()) {\n+            tryUnregister();\n@@ -155,1 +291,2 @@\n-                    assert subscribed.get();\n+                    var state = this.state;\n+                    assert (state & SUBSCRIBED) != 0;\n@@ -182,2 +319,3 @@\n-    public boolean completed() {\n-        return completed.get();\n+    public final boolean completed() {\n+        int state = this.state;\n+        return (state & COMPLETED) != 0;\n@@ -186,0 +324,34 @@\n+    \/**\n+     * {@return true if this subscriber has already subscribed}\n+     *\/\n+    public final boolean subscribed() {\n+        int state = this.state;\n+        return (state & SUBSCRIBED) != 0;\n+    }\n+\n+    \/**\n+     * {@return true if this subscriber has already been registered}\n+     *\/\n+    public final boolean registered() {\n+        int state = this.state;\n+        return (state & REGISTERED) != 0;\n+    }\n+\n+    \/**\n+     * {@return true if this subscriber has already been unregistered}\n+     *\/\n+    public final boolean unregistered() {\n+        int state = this.state;\n+        return (state & UNREGISTERED) != 0;\n+    }\n+\n+    \/**\n+     * {@return true if this subscriber's subscription has already\n+     * been cancelled}\n+     *\/\n+    public final boolean cancelled() {\n+        int state = this.state;\n+        return (state & CANCELLED) != 0;\n+    }\n+\n+\n@@ -197,2 +369,2 @@\n-            if (subscribed.compareAndSet(false, true)) {\n-                onSubscribed();\n+            tryRegister();\n+            if (markSubscribed()) {\n@@ -211,2 +383,3 @@\n-        assert subscribed.get();\n-        if (completed.get()) {\n+        var state = this.state;\n+        assert (state & SUBSCRIBED) != 0;\n+        if ((state & COMPLETED) != 0) {\n@@ -225,0 +398,1 @@\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/HttpBodySubscriberWrapper.java","additions":198,"deletions":24,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8277969\n+ * @bug 8277969 8299338\n","filename":"test\/jdk\/java\/net\/httpclient\/AsyncExecutorShutdown.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8245462 8229822 8254786 8297075 8297149 8298340\n+ * @bug 8245462 8229822 8254786 8297075 8297149 8298340 8302635\n","filename":"test\/jdk\/java\/net\/httpclient\/CancelRequestTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}