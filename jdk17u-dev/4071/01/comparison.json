{"files":[{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.function.UnaryOperator;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Annotations.Parameters;\n+\n+public class JavaAppDescTest {\n+\n+    public JavaAppDescTest(JavaAppDesc expectedAppDesc, JavaAppDesc actualAppDesc) {\n+        this.expectedAppDesc = expectedAppDesc;\n+        this.actualAppDesc = actualAppDesc;\n+    }\n+\n+    @Test\n+    public void test() {\n+        TKit.assertEquals(expectedAppDesc.toString(), actualAppDesc.toString(), null);\n+        TKit.assertTrue(expectedAppDesc.equals(actualAppDesc), null);\n+    }\n+\n+    @Test\n+    @Parameter({\"Foo\", \"Foo.class\"})\n+    @Parameter({\"com.bar.A\", \"com\/bar\/A.class\"})\n+    @Parameter({\"module\/com.bar.A\", \"com\/bar\/A.class\"})\n+    public static void testClassFilePath(String... args) {\n+        var appDesc = args[0];\n+        var expectedClassFilePath = Path.of(args[1]);\n+        TKit.assertEquals(expectedClassFilePath.toString(), JavaAppDesc.parse(\n+                appDesc).classFilePath().toString(), null);\n+    }\n+\n+    @Parameters\n+    public static List<Object[]> input() {\n+        return List.of(new Object[][] {\n+            createTestCase(\"\", \"hello.jar:Hello\"),\n+            createTestCase(\"foo.jar*\", \"foo.jar*hello.jar:Hello\"),\n+            createTestCase(\"Bye\", \"hello.jar:Bye\"),\n+            createTestCase(\"bye.jar:\", \"bye.jar:Hello\"),\n+            createTestCase(\"duke.jar:com.other\/com.other.foo.bar.Buz!@3.7\", appDesc -> {\n+                return appDesc\n+                        .setBundleFileName(\"duke.jar\")\n+                        .setModuleName(\"com.other\")\n+                        .setClassName(\"com.other.foo.bar.Buz\")\n+                        .setWithMainClass(true)\n+                        .setModuleVersion(\"3.7\");\n+            }),\n+        });\n+    }\n+\n+    private static JavaAppDesc[] createTestCase(String inputAppDesc, String expectedAppDescStr) {\n+        return createTestCase(inputAppDesc, appDesc -> {\n+            return stripDefaultSrcJavaPath(JavaAppDesc.parse(expectedAppDescStr));\n+        });\n+    }\n+\n+    private static JavaAppDesc stripDefaultSrcJavaPath(JavaAppDesc appDesc) {\n+        var defaultAppDesc = HelloApp.createDefaltAppDesc();\n+        if (appDesc.srcJavaPath().equals(defaultAppDesc.srcJavaPath())) {\n+            appDesc.setSrcJavaPath(null);\n+        }\n+        return appDesc;\n+    }\n+\n+    private static JavaAppDesc[] createTestCase(String appDesc, UnaryOperator<JavaAppDesc> config) {\n+        var actualAppDesc = stripDefaultSrcJavaPath(JavaAppDesc.parse(appDesc));\n+\n+        var expectedAppDesc = config.apply(stripDefaultSrcJavaPath(HelloApp.createDefaltAppDesc()));\n+\n+        return new JavaAppDesc[] {expectedAppDesc, actualAppDesc};\n+    }\n+\n+    private final JavaAppDesc expectedAppDesc;\n+    private final JavaAppDesc actualAppDesc;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/JavaAppDescTest.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,244 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.lang.reflect.Method;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+import jdk.jpackage.test.Annotations.Parameters;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Functional.ThrowingRunnable;\n+import static jdk.jpackage.test.Functional.ThrowingRunnable.toRunnable;\n+import static jdk.jpackage.test.Functional.ThrowingSupplier.toSupplier;\n+\n+public class TKitTest {\n+\n+    @Parameters\n+    public static Collection<Object[]> assertTestsData() {\n+        List<MethodCallConfig> data = new ArrayList<>();\n+\n+        var assertFunc = MethodCallConfig.build(\"assertTrue\", boolean.class, String.class);\n+        data.addAll(List.of(assertFunc.args(true).pass().expectLog(\"assertTrue()\").createForMessage(\"Catbird\")));\n+        data.addAll(List.of(assertFunc.args(false).fail().expectLog(\"Failed\").createForMessage(\"Catbird\")));\n+\n+        assertFunc = MethodCallConfig.build(\"assertFalse\", boolean.class, String.class);\n+        data.addAll(List.of(assertFunc.args(false).pass().expectLog(\"assertFalse()\").createForMessage(\"Stork\")));\n+        data.addAll(List.of(assertFunc.args(true).fail().expectLog(\"Failed\").createForMessage(\"Stork\")));\n+\n+        assertFunc = MethodCallConfig.build(\"assertEquals\", String.class, String.class, String.class);\n+        data.addAll(List.of(assertFunc.args(\"a\", \"a\").pass().expectLog(\"assertEquals(a)\").createForMessage(\"Crow\")));\n+        data.addAll(List.of(assertFunc.args(\"a\", \"b\").fail().expectLog(\"Expected [a]. Actual [b]\").createForMessage(\"Crow\")));\n+\n+        assertFunc = MethodCallConfig.build(\"assertEquals\", long.class, long.class, String.class);\n+        data.addAll(List.of(assertFunc.args(7, 7).pass().expectLog(\"assertEquals(7)\").createForMessage(\"Owl\")));\n+        data.addAll(List.of(assertFunc.args(7, 10).fail().expectLog(\"Expected [7]. Actual [10]\").createForMessage(\"Owl\")));\n+\n+        assertFunc = MethodCallConfig.build(\"assertNotEquals\", String.class, String.class, String.class);\n+        data.addAll(List.of(assertFunc.args(\"a\", \"b\").pass().expectLog(\"assertNotEquals(a, b)\").createForMessage(\"Tit\")));\n+        data.addAll(List.of(assertFunc.args(\"a\", \"a\").fail().expectLog(\"Unexpected [a] value\").createForMessage(\"Tit\")));\n+\n+        assertFunc = MethodCallConfig.build(\"assertNotEquals\", long.class, long.class, String.class);\n+        data.addAll(List.of(assertFunc.args(7, 10).pass().expectLog(\"assertNotEquals(7, 10)\").createForMessage(\"Duck\")));\n+        data.addAll(List.of(assertFunc.args(7, 7).fail().expectLog(\"Unexpected [7] value\").createForMessage(\"Duck\")));\n+\n+        assertFunc = MethodCallConfig.build(\"assertNull\", Object.class, String.class);\n+        data.addAll(List.of(assertFunc.args((Object) null).pass().expectLog(\"assertNull()\").createForMessage(\"Ibis\")));\n+        data.addAll(List.of(assertFunc.args(\"v\").fail().expectLog(\"Unexpected not null value [v]\").createForMessage(\"Ibis\")));\n+\n+        assertFunc = MethodCallConfig.build(\"assertNotNull\", Object.class, String.class);\n+        data.addAll(List.of(assertFunc.args(\"v\").pass().expectLog(\"assertNotNull(v)\").createForMessage(\"Pigeon\")));\n+        data.addAll(List.of(assertFunc.args((Object) null).fail().expectLog(\"Unexpected null value\").createForMessage(\"Pigeon\")));\n+\n+        assertFunc = MethodCallConfig.build(\"assertStringListEquals\", List.class, List.class, String.class);\n+        data.addAll(List.of(assertFunc.args(List.of(), List.of()).pass().expectLog(\n+                \"assertStringListEquals()\").createForMessage(\"Gull\")));\n+\n+        data.addAll(List.of(assertFunc.args(List.of(\"a\", \"b\"), List.of(\"a\", \"b\")).pass().expectLog(\n+                \"assertStringListEquals()\",\n+                \"assertStringListEquals(1, a)\",\n+                \"assertStringListEquals(2, b)\").createForMessage(\"Pelican\")));\n+\n+        assertFunc.fail().withAutoExpectLogPrefix(false);\n+        for (var msg : new String[] { \"Raven\", null }) {\n+            data.addAll(List.of(assertFunc.args(List.of(\"a\"), List.of(\"a\", \"b\"), msg).expectLog(\n+                    concatMessages(\"TRACE: assertStringListEquals()\", msg),\n+                    \"TRACE: assertStringListEquals(1, a)\",\n+                    concatMessages(\"ERROR: Actual list is longer than expected by 1 elements\", msg)\n+            ).create()));\n+\n+            data.addAll(List.of(assertFunc.args(List.of(\"n\", \"m\"), List.of(\"n\"), msg).expectLog(\n+                    concatMessages(\"TRACE: assertStringListEquals()\", msg),\n+                    \"TRACE: assertStringListEquals(1, n)\",\n+                    concatMessages(\"ERROR: Actual list is shorter than expected by 1 elements\", msg)\n+            ).create()));\n+\n+            data.addAll(List.of(assertFunc.args(List.of(\"a\", \"b\"), List.of(\"n\", \"m\"), msg).expectLog(\n+                    concatMessages(\"TRACE: assertStringListEquals()\", msg),\n+                    concatMessages(\"ERROR: (1) Expected [a]. Actual [n]\", msg)\n+            ).create()));\n+        }\n+\n+        return data.stream().map(v -> {\n+            return new Object[]{v};\n+        }).toList();\n+    }\n+\n+    public record MethodCallConfig(Method method, Object[] args, boolean expectFail, String[] expectLog) {\n+        @Override\n+        public String toString() {\n+            return String.format(\"%s%s%s\", method.getName(), Arrays.toString(args), expectFail ? \"!\" : \"\");\n+        }\n+\n+        static Builder build(String name, Class<?> ... parameterTypes) {\n+            return new Builder(name, parameterTypes);\n+        }\n+\n+        private static class Builder {\n+            Builder(Method method) {\n+                Objects.requireNonNull(method);\n+                this.method = method;\n+            }\n+\n+            Builder(String name, Class<?> ... parameterTypes) {\n+                method = toSupplier(() -> TKit.class.getMethod(name, parameterTypes)).get();\n+            }\n+\n+            MethodCallConfig create() {\n+                String[] effectiveExpectLog;\n+                if (!withAutoExpectLogPrefix) {\n+                    effectiveExpectLog = expectLog;\n+                } else {\n+                    var prefix = expectFail ? \"ERROR: \" : \"TRACE: \";\n+                    effectiveExpectLog = Stream.of(expectLog).map(line -> {\n+                        return prefix + line;\n+                    }).toArray(String[]::new);\n+                }\n+                return new MethodCallConfig(method, args, expectFail, effectiveExpectLog);\n+            }\n+\n+            MethodCallConfig[] createForMessage(String msg) {\n+                return Arrays.asList(msg, null).stream().map(curMsg -> {\n+                    var builder = new Builder(method);\n+                    builder.expectFail = expectFail;\n+                    builder.withAutoExpectLogPrefix = withAutoExpectLogPrefix;\n+                    builder.args = Stream.concat(Stream.of(args), Stream.of(curMsg)).toArray();\n+                    builder.expectLog = Arrays.copyOf(expectLog, expectLog.length);\n+                    builder.expectLog[0] = concatMessages(builder.expectLog[0], curMsg);\n+                    return builder.create();\n+                }).toArray(MethodCallConfig[]::new);\n+            }\n+\n+            Builder fail() {\n+                expectFail = true;\n+                return this;\n+            }\n+\n+            Builder pass() {\n+                expectFail = false;\n+                return this;\n+            }\n+\n+            Builder args(Object ... v) {\n+                args = v;\n+                return this;\n+            }\n+\n+            Builder expectLog(String expectLogFirstStr, String ... extra) {\n+                expectLog = Stream.concat(Stream.of(expectLogFirstStr), Stream.of(extra)).toArray(String[]::new);\n+                return this;\n+            }\n+\n+            Builder withAutoExpectLogPrefix(boolean v) {\n+                withAutoExpectLogPrefix = v;\n+                return this;\n+            }\n+\n+            private final Method method;\n+            private Object[] args = new Object[0];\n+            private boolean expectFail;\n+            private String[] expectLog;\n+            private boolean withAutoExpectLogPrefix = true;\n+        }\n+    }\n+\n+    public TKitTest(MethodCallConfig methodCall) {\n+        this.methodCall = methodCall;\n+    }\n+\n+    @Test\n+    public void test() {\n+        runAssertWithExpectedLogOutput(() -> {\n+            methodCall.method.invoke(null, methodCall.args);\n+        }, methodCall.expectFail, methodCall.expectLog);\n+    }\n+\n+    private static void runAssertWithExpectedLogOutput(ThrowingRunnable action,\n+            boolean expectFail, String... expectLogStrings) {\n+        runWithExpectedLogOutput(() -> {\n+            TKit.assertAssert(!expectFail, toRunnable(action));\n+        }, expectLogStrings);\n+    }\n+\n+    private static void runWithExpectedLogOutput(ThrowingRunnable action,\n+            String... expectLogStrings) {\n+        final var buf = new ByteArrayOutputStream();\n+        try (PrintStream ps = new PrintStream(buf, true, StandardCharsets.UTF_8)) {\n+            TKit.withExtraLogStream(action, ps);\n+        } finally {\n+            toRunnable(() -> {\n+                var output = new BufferedReader(new InputStreamReader(\n+                        new ByteArrayInputStream(buf.toByteArray()),\n+                        StandardCharsets.UTF_8)).lines().map(line -> {\n+                            \/\/ Skip timestamp\n+                            return line.substring(LOG_MSG_TIMESTAMP_LENGTH);\n+                        }).toList();\n+                if (output.size() == 1 && expectLogStrings.length == 1) {\n+                    TKit.assertEquals(expectLogStrings[0], output.get(0), null);\n+                } else {\n+                    TKit.assertStringListEquals(List.of(expectLogStrings), output, null);\n+                }\n+            }).run();\n+        }\n+    }\n+\n+    private static String concatMessages(String msg, String msg2) {\n+        if (msg2 != null && !msg2.isBlank()) {\n+            return msg + \": \" + msg2;\n+        }\n+        return msg;\n+    }\n+\n+    private final MethodCallConfig methodCall;\n+\n+    private static final int LOG_MSG_TIMESTAMP_LENGTH = \"[HH:mm:ss.SSS] \".length();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/TKitTest.java","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @summary Unit tests for jpackage test library\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers-test\n+ * @build jdk.jpackage.test.*\n+ * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.TestSuite\n+ *\/\n+\n+public final class TestSuite {\n+    public static void main(String args[]) throws Throwable {\n+        final var pkgName = TestSuite.class.getPackageName();\n+        final var javaSuffix = \".java\";\n+        final var testSrcNameSuffix = \"Test\" + javaSuffix;\n+\n+        final var unitTestDir = TKit.TEST_SRC_ROOT.resolve(Path.of(\"helpers-test\", pkgName.split(\"\\\\.\")));\n+\n+        final List<String> runTestArgs = new ArrayList<>();\n+        runTestArgs.addAll(List.of(args));\n+\n+        try (var javaSources = Files.list(unitTestDir)) {\n+            runTestArgs.addAll(javaSources.filter(path -> {\n+                return path.getFileName().toString().endsWith(testSrcNameSuffix);\n+            }).map(path -> {\n+                var filename = path.getFileName().toString();\n+                return String.join(\".\", pkgName, filename.substring(0, filename.length() - javaSuffix.length()));\n+            }).map(testClassName -> {\n+                return \"--jpt-run=\" + testClassName;\n+            }).toList());\n+        }\n+\n+        Main.main(runTestArgs.toArray(String[]::new));\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/TestSuite.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.function.Supplier;\n@@ -253,0 +254,12 @@\n+    private static class BadResultException extends RuntimeException {\n+        BadResultException(Result v) {\n+            value = v;\n+        }\n+\n+        Result getValue() {\n+            return value;\n+        }\n+\n+        private final Result value;\n+    }\n+\n@@ -258,1 +271,19 @@\n-        Result result;\n+        try {\n+            return tryRunMultipleTimes(() -> {\n+                Result result = executeWithoutExitCodeCheck();\n+                if (result.getExitCode() != expectedCode) {\n+                    throw new BadResultException(result);\n+                }\n+                return result;\n+            }, max, wait).assertExitCodeIs(expectedCode);\n+        } catch (BadResultException ex) {\n+            return ex.getValue().assertExitCodeIs(expectedCode);\n+        }\n+    }\n+\n+    \/*\n+     * Repeates a \"task\" \"max\" times and waits for \"wait\" seconds between each\n+     * execution until the \"task\" returns without throwing an exception.\n+     *\/\n+    public static <T> T tryRunMultipleTimes(Supplier<T> task, int max, int wait) {\n+        RuntimeException lastException = null;\n@@ -262,3 +293,4 @@\n-            result = executeWithoutExitCodeCheck();\n-            if (result.getExitCode() == expectedCode) {\n-                return result;\n+            try {\n+                return task.get();\n+            } catch (RuntimeException ex) {\n+                lastException = ex;\n@@ -276,1 +308,8 @@\n-        return result.assertExitCodeIs(expectedCode);\n+        throw lastException;\n+    }\n+\n+    public static void tryRunMultipleTimes(Runnable task, int max, int wait) {\n+        tryRunMultipleTimes(() -> {\n+            task.run();\n+            return null;\n+        }, max, wait);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Executor.java","additions":44,"deletions":5,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,2 +154,2 @@\n-        if (throwable instanceof RuntimeException) {\n-            throw (RuntimeException)throwable;\n+        if (throwable instanceof RuntimeException err) {\n+            throw err;\n@@ -158,2 +158,6 @@\n-        if (throwable instanceof InvocationTargetException) {\n-            throw new ExceptionBox(throwable.getCause());\n+        if (throwable instanceof Error err) {\n+            throw err;\n+        }\n+\n+        if (throwable instanceof InvocationTargetException err) {\n+            throw rethrowUnchecked(err.getCause());\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Functional.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.io.File;\n@@ -60,5 +59,1 @@\n-\n-        final String qualifiedClassName = appDesc.className();\n-\n-        final String className = qualifiedClassName.substring(\n-                qualifiedClassName.lastIndexOf('.') + 1);\n+        final String className = appDesc.shortClassName();\n@@ -67,2 +62,1 @@\n-        final Path srcFile = srcDir.resolve(Path.of(String.join(\n-                File.separator, qualifiedClassName.split(\"\\\\.\")) + \".java\"));\n+        final Path srcFile = srcDir.resolve(appDesc.classNameAsPath(\".java\"));\n@@ -351,1 +345,1 @@\n-    public final static class AppOutputVerifier {\n+    public static final class AppOutputVerifier {\n@@ -482,1 +476,1 @@\n-    final static String OUTPUT_FILENAME = \"appOutput.txt\";\n+    static final String OUTPUT_FILENAME = \"appOutput.txt\";\n@@ -489,1 +483,1 @@\n-    private final static String CLASS_NAME = HELLO_JAVA.getFileName().toString().split(\n+    private static final String CLASS_NAME = HELLO_JAVA.getFileName().toString().split(\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/HelloApp.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.io.File;\n@@ -27,0 +26,2 @@\n+import java.util.Objects;\n+import java.util.stream.Stream;\n@@ -76,0 +77,10 @@\n+    public String shortClassName() {\n+        return qualifiedClassName.substring(qualifiedClassName.lastIndexOf('.') + 1);\n+    }\n+\n+    Path classNameAsPath(String extension) {\n+        final String[] pathComponents = qualifiedClassName.split(\"\\\\.\");\n+        pathComponents[pathComponents.length - 1] = shortClassName() + extension;\n+        return Stream.of(pathComponents).map(Path::of).reduce(Path::resolve).get();\n+    }\n+\n@@ -77,2 +88,1 @@\n-        return Path.of(qualifiedClassName.replace(\".\", File.separator)\n-                + \".class\");\n+        return classNameAsPath(\".class\");\n@@ -127,0 +137,42 @@\n+    @Override\n+    public int hashCode() {\n+        int hash = 5;\n+        hash = 79 * hash + Objects.hashCode(this.srcJavaPath);\n+        hash = 79 * hash + Objects.hashCode(this.qualifiedClassName);\n+        hash = 79 * hash + Objects.hashCode(this.moduleName);\n+        hash = 79 * hash + Objects.hashCode(this.bundleFileName);\n+        hash = 79 * hash + Objects.hashCode(this.moduleVersion);\n+        hash = 79 * hash + (this.withMainClass ? 1 : 0);\n+        return hash;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        final JavaAppDesc other = (JavaAppDesc) obj;\n+        if (this.withMainClass != other.withMainClass) {\n+            return false;\n+        }\n+        if (!Objects.equals(this.qualifiedClassName, other.qualifiedClassName)) {\n+            return false;\n+        }\n+        if (!Objects.equals(this.moduleName, other.moduleName)) {\n+            return false;\n+        }\n+        if (!Objects.equals(this.bundleFileName, other.bundleFileName)) {\n+            return false;\n+        }\n+        if (!Objects.equals(this.moduleVersion, other.moduleVersion)) {\n+            return false;\n+        }\n+        return Objects.equals(this.srcJavaPath, other.srcJavaPath);\n+    }\n+\n@@ -219,1 +271,3 @@\n-            desc.setClassName(components[0]);\n+            if (!components[0].isEmpty()) {\n+                desc.setClassName(components[0]);\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JavaAppDesc.java","additions":58,"deletions":4,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -97,1 +97,3 @@\n-                    setIcon(expectedIcon, iconContainer);\n+                    Executor.tryRunMultipleTimes(() -> {\n+                        setIcon(expectedIcon, iconContainer);\n+                    }, 3, 5);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherIconVerifier.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.io.File;\n@@ -712,1 +711,1 @@\n-    private final static File BUNDLE_OUTPUT_DIR;\n+    private static final Path BUNDLE_OUTPUT_DIR;\n@@ -720,1 +719,1 @@\n-            BUNDLE_OUTPUT_DIR = new File(val).getAbsoluteFile();\n+            BUNDLE_OUTPUT_DIR = Path.of(val).toAbsolutePath();\n@@ -722,1 +721,1 @@\n-            if (!BUNDLE_OUTPUT_DIR.isDirectory()) {\n+            if (!Files.isDirectory(BUNDLE_OUTPUT_DIR)) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.io.File;\n@@ -106,4 +105,1 @@\n-                extraLogStream = logStream;\n-                ThrowingRunnable.toRunnable(action).run();\n-            } finally {\n-                extraLogStream = null;\n+                withExtraLogStream(action, logStream);\n@@ -114,0 +110,10 @@\n+    static void withExtraLogStream(ThrowingRunnable action, PrintStream logStream) {\n+        var oldExtraLogStream = extraLogStream;\n+        try {\n+            extraLogStream = logStream;\n+            ThrowingRunnable.toRunnable(action).run();\n+        } finally {\n+            extraLogStream = oldExtraLogStream;\n+        }\n+    }\n+\n@@ -186,5 +192,1 @@\n-        if (!isLinux()) {\n-            return false;\n-        }\n-        File aptFile = new File(\"\/usr\/bin\/apt-get\");\n-        return aptFile.exists();\n+        return isLinux() && Files.exists(Path.of(\"\/usr\/bin\/apt-get\"));\n@@ -267,0 +269,16 @@\n+    static void assertAssert(boolean expectedSuccess, Runnable runnable) {\n+        try {\n+            runnable.run();\n+        } catch (AssertionError err) {\n+            if (expectedSuccess) {\n+                assertUnexpected(\"Assertion failed\");\n+            } else {\n+                return;\n+            }\n+        }\n+\n+        if (!expectedSuccess) {\n+            assertUnexpected(\"Assertion passed\");\n+        }\n+    }\n+\n@@ -572,1 +590,1 @@\n-        traceAssert(String.format(\"assertEquals(%d): %s\", expected, msg));\n+        traceAssert(concatMessages(String.format(\"assertEquals(%d)\", expected), msg));\n@@ -582,2 +600,2 @@\n-        traceAssert(String.format(\"assertNotEquals(%d, %d): %s\", expected,\n-                actual, msg));\n+        traceAssert(concatMessages(String.format(\"assertNotEquals(%d, %d)\", expected,\n+                actual), msg));\n@@ -595,1 +613,1 @@\n-        traceAssert(String.format(\"assertEquals(%s): %s\", expected, msg));\n+        traceAssert(concatMessages(String.format(\"assertEquals(%s)\", expected), msg));\n@@ -603,2 +621,2 @@\n-            traceAssert(String.format(\"assertNotEquals(%s, %s): %s\", expected,\n-                actual, msg));\n+            traceAssert(concatMessages(String.format(\"assertNotEquals(%s, %s)\", expected,\n+                actual), msg));\n@@ -618,1 +636,1 @@\n-        traceAssert(String.format(\"assertNull(): %s\", msg));\n+        traceAssert(concatMessages(\"assertNull()\", msg));\n@@ -627,1 +645,1 @@\n-        traceAssert(String.format(\"assertNotNull(%s): %s\", value, msg));\n+        traceAssert(concatMessages(String.format(\"assertNotNull(%s)\", value), msg));\n@@ -647,1 +665,1 @@\n-        traceAssert(String.format(\"assertTrue(): %s\", msg));\n+        traceAssert(concatMessages(\"assertTrue()\", msg));\n@@ -659,1 +677,1 @@\n-        traceAssert(String.format(\"assertFalse(): %s\", msg));\n+        traceAssert(concatMessages(\"assertFalse()\", msg));\n@@ -730,1 +748,1 @@\n-        traceAssert(String.format(\"assertStringListEquals(): %s\", msg));\n+        traceAssert(concatMessages(\"assertStringListEquals()\", msg));\n@@ -760,1 +778,1 @@\n-        if (expected.size() < actual.size()) {\n+        if (actual.size() > expected.size()) {\n@@ -770,1 +788,1 @@\n-                    \"Actual list is longer than expected by %d elements\",\n+                    \"Actual list is shorter than expected by %d elements\",\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":41,"deletions":23,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.io.File;\n@@ -230,2 +229,2 @@\n-        TKit.assertTrue(classpath.startsWith(\"$APPDIR\" + File.separator\n-                + nonModularAppDesc.jarFileName()),\n+        TKit.assertTrue(classpath.startsWith(Path.of(\"$APPDIR\",\n+                nonModularAppDesc.jarFileName()).toString()),\n@@ -235,1 +234,1 @@\n-    private final static Path GOLDEN_ICON = TKit.TEST_SRC_ROOT.resolve(Path.of(\n+    private static final Path GOLDEN_ICON = TKit.TEST_SRC_ROOT.resolve(Path.of(\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLauncherTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}