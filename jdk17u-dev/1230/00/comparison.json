{"files":[{"patch":"@@ -654,0 +654,2 @@\n+            cd.onMalformedInput(CodingErrorAction.REPLACE)\n+                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n@@ -661,1 +663,7 @@\n-            int caLen = decodeWithDecoder(cd, ca, bytes, offset, length);\n+            int caLen;\n+            try {\n+                caLen = decodeWithDecoder(cd, ca, bytes, offset, length);\n+            } catch (CharacterCodingException x) {\n+                \/\/ Substitution is enabled, so this shouldn't happen\n+                throw new Error(x);\n+            }\n@@ -782,1 +790,7 @@\n-        int caLen = decodeWithDecoder(cd, ca, src, 0, src.length);\n+        int caLen;\n+        try {\n+            caLen = decodeWithDecoder(cd, ca, src, 0, src.length);\n+        } catch (CharacterCodingException x) {\n+            \/\/ throw via IAE\n+            throw new IllegalArgumentException(x);\n+        }\n@@ -1192,1 +1206,2 @@\n-    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length) {\n+    private static int decodeWithDecoder(CharsetDecoder cd, char[] dst, byte[] src, int offset, int length)\n+                                            throws CharacterCodingException {\n@@ -1195,14 +1210,6 @@\n-        cd.onMalformedInput(CodingErrorAction.REPLACE)\n-            .onUnmappableCharacter(CodingErrorAction.REPLACE);\n-        try {\n-            CoderResult cr = cd.decode(bb, cb, true);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-            cr = cd.flush(cb);\n-            if (!cr.isUnderflow())\n-                cr.throwException();\n-        } catch (CharacterCodingException x) {\n-            \/\/ Substitution is always enabled,\n-            \/\/ so this shouldn't happen\n-            throw new Error(x);\n-        }\n+        CoderResult cr = cd.decode(bb, cb, true);\n+        if (!cr.isUnderflow())\n+            cr.throwException();\n+        cr = cd.flush(cb);\n+        if (!cr.isUnderflow())\n+            cr.throwException();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8286287\n- * @summary Verifies newStringNoRepl() does not throw an Error.\n- *\/\n-\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.util.HexFormat;\n-import static java.nio.charset.StandardCharsets.UTF_16;\n-\n-public class NewStringNoRepl {\n-    private final static byte[] MALFORMED_UTF16 = {(byte)0x00, (byte)0x20, (byte)0x00};\n-\n-    public static void main(String... args) throws IOException {\n-        var f = Files.createTempFile(null, null);\n-        try (var fos = Files.newOutputStream(f)) {\n-            fos.write(MALFORMED_UTF16);\n-        }\n-        System.out.println(\"Returned bytes: \" +\n-            HexFormat.of()\n-                .withPrefix(\"x\")\n-                .withUpperCase()\n-                .formatHex(Files.readString(f, UTF_16).getBytes(UTF_16)));\n-        Files.delete(f);\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/String\/NewStringNoRepl.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8286287 8288589\n+ * @summary Tests for *NoRepl() shared secret methods.\n+ * @run testng NoReplTest\n+ * @modules jdk.charsets\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.util.HexFormat;\n+import static java.nio.charset.StandardCharsets.UTF_16;\n+\n+import org.testng.annotations.Test;\n+\n+@Test\n+public class NoReplTest {\n+    private final static byte[] MALFORMED_UTF16 = {(byte)0x00, (byte)0x20, (byte)0x00};\n+    private final static String MALFORMED_WINDOWS_1252 = \"\\u0080\\u041e\";\n+    private final static Charset WINDOWS_1252 = Charset.forName(\"windows-1252\");\n+\n+    \/**\n+     * Verifies newStringNoRepl() throws a CharacterCodingException.\n+     * The method is invoked by `Files.readString()` method.\n+     *\/\n+    @Test\n+    public void newStringNoReplTest() throws IOException {\n+        var f = Files.createTempFile(null, null);\n+        try (var fos = Files.newOutputStream(f)) {\n+            fos.write(MALFORMED_UTF16);\n+            var read = Files.readString(f, UTF_16);\n+            throw new RuntimeException(\"Exception should be thrown for a malformed input. Bytes read: \" +\n+                    HexFormat.of()\n+                            .withPrefix(\"x\")\n+                            .withUpperCase()\n+                            .formatHex(read.getBytes(UTF_16)));\n+        } catch (CharacterCodingException cce) {\n+            \/\/ success\n+        } finally {\n+            Files.delete(f);\n+        }\n+    }\n+\n+    \/**\n+     * Verifies getBytesNoRepl() throws a CharacterCodingException.\n+     * The method is invoked by `Files.writeString()` method.\n+     *\/\n+    @Test\n+    public void getBytesNoReplTest() throws IOException {\n+        var f = Files.createTempFile(null, null);\n+        try {\n+            Files.writeString(f, MALFORMED_WINDOWS_1252, WINDOWS_1252);\n+            throw new RuntimeException(\"Exception should be thrown\");\n+        } catch (CharacterCodingException cce) {\n+            \/\/ success\n+        } finally {\n+            Files.delete(f);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/NoReplTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import java.nio.charset.CharacterCodingException;\n@@ -29,1 +30,0 @@\n-import static java.nio.charset.StandardCharsets.US_ASCII;\n@@ -31,0 +31,2 @@\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static java.nio.charset.StandardCharsets.UTF_16;\n@@ -49,1 +51,1 @@\n- * @bug 8201276 8205058 8209576 8287541\n+ * @bug 8201276 8205058 8209576 8287541 8288589\n@@ -63,0 +65,2 @@\n+    private static final Charset WINDOWS_1252 = Charset.forName(\"windows-1252\");\n+    private static final Charset WINDOWS_31J = Charset.forName(\"windows-31j\");\n@@ -91,1 +95,1 @@\n-        Path path = Files.createTempFile(\"malformedWrite\", null);\n+        Path path = Files.createFile(Path.of(\"malformedWrite\"));\n@@ -97,2 +101,2 @@\n-            {path, \"\\u041e\", Charset.forName(\"windows-1252\")}, \/\/ cyrillic capital letter O\n-            {path, \"\\u091c\", Charset.forName(\"windows-31j\")}, \/\/ devanagari letter ja\n+            {path, \"\\u041e\", WINDOWS_1252}, \/\/ cyrillic capital letter O\n+            {path, \"\\u091c\", WINDOWS_31J}, \/\/ devanagari letter ja\n@@ -108,1 +112,1 @@\n-        Path path = Files.createTempFile(\"illegalInput\", null);\n+        Path path = Files.createFile(Path.of(\"illegalInput\"));\n@@ -115,0 +119,13 @@\n+    \/*\n+     * DataProvider for illegal input bytes test\n+     *\/\n+    @DataProvider(name = \"illegalInputBytes\")\n+    public Object[][] getIllegalInputBytes() throws IOException {\n+        return new Object[][]{\n+            {new byte[] {(byte)0x00, (byte)0x20, (byte)0x00}, UTF_16, MalformedInputException.class},\n+            {new byte[] {-50}, UTF_16, MalformedInputException.class},\n+            {new byte[] {(byte)0x81}, WINDOWS_1252, UnmappableCharacterException.class}, \/\/ unused in Cp1252\n+            {new byte[] {(byte)0x81, (byte)0xff}, WINDOWS_31J, UnmappableCharacterException.class}, \/\/ invalid trailing byte\n+        };\n+    }\n+\n@@ -146,10 +163,3 @@\n-        testFiles[0] = Files.createTempFile(\"readWriteString\", null);\n-        testFiles[1] = Files.createTempFile(\"writeString_file1\", null);\n-        testFiles[2] = Files.createTempFile(\"writeString_file2\", null);\n-    }\n-\n-    @AfterClass\n-    void cleanup() throws IOException {\n-        for (Path path : testFiles) {\n-            Files.deleteIfExists(path);\n-        }\n+        testFiles[0] = Files.createFile(Path.of(\"readWriteString\"));\n+        testFiles[1] = Files.createFile(Path.of(\"writeString_file1\"));\n+        testFiles[2] = Files.createFile(Path.of(\"writeString_file2\"));\n@@ -244,1 +254,0 @@\n-        path.toFile().deleteOnExit();\n@@ -246,1 +255,1 @@\n-            Files.writeString(path, s, CREATE);\n+            Files.writeString(path, s);\n@@ -248,1 +257,1 @@\n-            Files.writeString(path, s, cs, CREATE);\n+            Files.writeString(path, s, cs);\n@@ -264,1 +273,0 @@\n-        path.toFile().deleteOnExit();\n@@ -266,1 +274,1 @@\n-        Files.writeString(path, temp, csWrite, CREATE);\n+        Files.writeString(path, temp, csWrite);\n@@ -274,0 +282,25 @@\n+    \/**\n+     * Verifies that IOException is thrown when reading a file containing\n+     * illegal bytes\n+     *\n+     * @param data the data used for the test\n+     * @param csRead the Charset to use for reading the file\n+     * @param expected exception class\n+     * @throws IOException when the Charset used for reading the file is incorrect\n+     *\/\n+    @Test(dataProvider = \"illegalInputBytes\")\n+    public void testMalformedReadBytes(byte[] data, Charset csRead, Class<CharacterCodingException> expected)\n+            throws IOException {\n+        Path path = Path.of(\"illegalInputBytes\");\n+        Files.write(path, data);\n+        try {\n+            Files.readString(path, csRead);\n+        } catch (MalformedInputException | UnmappableCharacterException e) {\n+            if (expected.isInstance(e)) {\n+                \/\/ success\n+                return;\n+            }\n+        }\n+        throw new RuntimeException(\"An instance of \" + expected + \" should be thrown\");\n+    }\n+\n","filename":"test\/jdk\/java\/nio\/file\/Files\/ReadWriteString.java","additions":54,"deletions":21,"binary":false,"changes":75,"status":"modified"}]}