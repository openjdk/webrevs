{"files":[{"patch":"@@ -126,1 +126,1 @@\n-    : _klass(klass), _cld(cld) {}\n+    : _next(NULL), _klass(klass), _cld(cld) {}\n@@ -141,1 +141,1 @@\n-  const ClassLoaderData* _cld;\n+  const ClassLoaderData* _cld; \/\/ May be NULL if loader never loaded anything\n@@ -158,2 +158,4 @@\n-  void print_with_childs(outputStream* st, BranchTracker& branchtracker,\n-      bool print_classes, bool verbose) const {\n+  \/\/ Returns Klass of loader; NULL for bootstrap loader\n+  const Klass* loader_klass() const {\n+    return (_loader_oop != NULL) ? _loader_oop->klass() : NULL;\n+  }\n@@ -161,1 +163,5 @@\n-    ResourceMark rm;\n+  \/\/ Returns ResourceArea-allocated class name of loader class; \"\" if there is no klass (bootstrap loader)\n+  const char* loader_class_name() const {\n+    const Klass* klass = loader_klass();\n+    return klass != NULL ? klass->external_name() : \"\";\n+  }\n@@ -163,4 +169,15 @@\n-    if (_cld == NULL) {\n-      \/\/ Not sure how this could happen: we added a preliminary node for a parent but then never encountered\n-      \/\/ its CLD?\n-      return;\n+  \/\/ Returns oop of loader name; NULL for bootstrap; NULL if no name was set\n+  oop loader_name_oop() const {\n+    return (_loader_oop != NULL) ? java_lang_ClassLoader::name(_loader_oop) : NULL;\n+  }\n+\n+  \/\/ Returns ResourceArea-allocated name of loader, \"\" if none is set\n+  const char* loader_name() const {\n+    oop name_oop = loader_name_oop();\n+    return name_oop != NULL ? java_lang_String::as_utf8_string(name_oop) : \"\";\n+  }\n+\n+  bool is_bootstrap() const {\n+    if (_loader_oop == NULL) {\n+      assert(_cld != NULL && _cld->is_boot_class_loader_data(), \"bootstrap loader must have CLD\");\n+      return true;\n@@ -168,0 +185,9 @@\n+    return false;\n+  }\n+\n+  void print_with_child_nodes(outputStream* st, BranchTracker& branchtracker,\n+      bool print_classes, bool verbose) const {\n+\n+    assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n+\n+    ResourceMark rm;\n@@ -170,2 +196,3 @@\n-    const Klass* const loader_klass = _cld->class_loader_klass();\n-    const Symbol* const loader_name = _cld->name();\n+    const Klass* const the_loader_klass = loader_klass();\n+    const char* const the_loader_class_name = loader_class_name();\n+    const char* const the_loader_name = loader_name();\n@@ -177,1 +204,1 @@\n-    if (_cld->is_the_null_class_loader_data()) {\n+    if (is_bootstrap()) {\n@@ -180,3 +207,2 @@\n-      assert(!_cld->has_class_mirror_holder(), \"_cld must be the primary cld\");\n-      if (loader_name != NULL) {\n-        st->print(\" \\\"%s\\\",\", loader_name->as_C_string());\n+      if (the_loader_name[0] != '\\0') {\n+        st->print(\" \\\"%s\\\",\", the_loader_name);\n@@ -184,1 +210,1 @@\n-      st->print(\" %s\", loader_klass != NULL ? loader_klass->external_name() : \"??\");\n+      st->print(\" %s\", the_loader_class_name);\n@@ -214,1 +240,1 @@\n-        st->print_cr(\"%*s \" PTR_FORMAT, indentation, \"Loader Klass:\", p2i(loader_klass));\n+        st->print_cr(\"%*s \" PTR_FORMAT, indentation, \"Loader Klass:\", p2i(the_loader_klass));\n@@ -223,0 +249,1 @@\n+          assert(_cld != NULL, \"we have classes, we should have a CLD\");\n@@ -255,0 +282,1 @@\n+          assert(_cld != NULL, \"we have classes, we should have a CLD\");\n@@ -288,1 +316,1 @@\n-      c->print_with_childs(st, branchtracker, print_classes, verbose);\n+      c->print_with_child_nodes(st, branchtracker, print_classes, verbose);\n@@ -297,1 +325,1 @@\n-  bool can_fold_into(LoaderTreeNode* target_node) const {\n+  bool can_fold_into(const LoaderTreeNode* target_node) const {\n@@ -299,2 +327,13 @@\n-    return _cld->class_loader_klass() == target_node->_cld->class_loader_klass() &&\n-           _cld->name() == target_node->_cld->name();\n+\n+    \/\/ Must have the same non-null klass\n+    const Klass* k = loader_klass();\n+    if (k == NULL || k != target_node->loader_klass()) {\n+      return false;\n+    }\n+\n+    \/\/ Must have the same loader name, or none\n+    if (::strcmp(loader_name(), target_node->loader_name()) != 0) {\n+      return false;\n+    }\n+\n+    return true;\n@@ -312,0 +351,1 @@\n+    assert(_cld == NULL, \"there should be only one primary CLD per loader\");\n@@ -346,8 +386,0 @@\n-  const ClassLoaderData* cld() const {\n-    return _cld;\n-  }\n-\n-  const oop loader_oop() const {\n-    return _loader_oop;\n-  }\n-\n@@ -376,0 +408,1 @@\n+    ResourceMark rm;\n@@ -401,1 +434,1 @@\n-  void print_with_childs(outputStream* st, bool print_classes, bool print_add_info) const {\n+  void print_with_child_nodes(outputStream* st, bool print_classes, bool print_add_info) const {\n@@ -403,1 +436,1 @@\n-    print_with_childs(st, bwt, print_classes, print_add_info);\n+    print_with_child_nodes(st, bwt, print_classes, print_add_info);\n@@ -478,1 +511,1 @@\n-    _root->print_with_childs(st, _print_classes, _verbose);\n+    _root->print_with_child_nodes(st, _print_classes, _verbose);\n@@ -495,1 +528,0 @@\n-      assert(info->cld() == NULL, \"there should be only one primary CLD per loader\");\n","filename":"src\/hotspot\/share\/classfile\/classLoaderHierarchyDCmd.cpp","additions":65,"deletions":33,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -50,0 +50,13 @@\n+    class EmptyDelegatingLoader extends ClassLoader {\n+        EmptyDelegatingLoader(String name, ClassLoader parent) {\n+            super(name, parent);\n+        }\n+    }\n+\n+    static void loadTestClassInLoaderAndCheck(String classname, ClassLoader loader) throws ClassNotFoundException {\n+        Class<?> c = Class.forName(classname, true, loader);\n+        if (c.getClassLoader() != loader) {\n+            Assert.fail(classname + \" defined by wrong classloader: \" + c.getClassLoader());\n+        }\n+    }\n+\n@@ -66,0 +79,1 @@\n+        \/\/ A) one unnamed, two named loaders\n@@ -67,5 +81,0 @@\n-        Class<?> c1 = Class.forName(\"TestClass2\", true, unnamed_cl);\n-        if (c1.getClassLoader() != unnamed_cl) {\n-            Assert.fail(\"TestClass defined by wrong classloader: \" + c1.getClassLoader());\n-        }\n-\n@@ -73,5 +82,0 @@\n-        Class<?> c2 = Class.forName(\"TestClass2\", true, named_cl);\n-        if (c2.getClassLoader() != named_cl) {\n-            Assert.fail(\"TestClass defined by wrong classloader: \" + c2.getClassLoader());\n-        }\n-\n@@ -79,4 +83,35 @@\n-        Class<?> c3 = Class.forName(\"TestClass2\", true, named_child_cl);\n-        if (c3.getClassLoader() != named_child_cl) {\n-            Assert.fail(\"TestClass defined by wrong classloader: \" + c3.getClassLoader());\n-        }\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", unnamed_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_cl);\n+\n+        \/\/ B) A named CL with empty loaders as parents (JDK-8293156)\n+        EmptyDelegatingLoader emptyLoader1 = new EmptyDelegatingLoader(\"EmptyLoader1\", null);\n+        EmptyDelegatingLoader emptyLoader2 = new EmptyDelegatingLoader(\"EmptyLoader2\", emptyLoader1);\n+        ClassLoader named_child_2_cl = new TestClassLoader(\"Child2\", emptyLoader2);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_2_cl);\n+\n+        \/\/ C) Test output for several class loaders, same class, same name, empty parents,\n+        \/\/    and all these should be folded by default.\n+        EmptyDelegatingLoader emptyLoader3 = new EmptyDelegatingLoader(\"EmptyLoader3\", null);\n+        EmptyDelegatingLoader emptyLoader4 = new EmptyDelegatingLoader(\"EmptyLoader4\", emptyLoader3);\n+        ClassLoader named_child_3_cl = new TestClassLoader(\"ChildX\", emptyLoader4); \/\/ Same names\n+        ClassLoader named_child_4_cl = new TestClassLoader(\"ChildX\", emptyLoader4);\n+        ClassLoader named_child_5_cl = new TestClassLoader(\"ChildX\", emptyLoader4);\n+        ClassLoader named_child_6_cl = new TestClassLoader(\"ChildX\", emptyLoader4);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_3_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_4_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_5_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_6_cl);\n+\n+        \/\/ D) Test output for several *unnamed* class loaders, same class, same parents,\n+        \/\/    and all these should be folded by default too.\n+        EmptyDelegatingLoader emptyLoader5 = new EmptyDelegatingLoader(null, null);\n+        EmptyDelegatingLoader emptyLoader6 = new EmptyDelegatingLoader(null, emptyLoader5);\n+        ClassLoader named_child_7_cl = new TestClassLoader(null, emptyLoader6); \/\/ Same names\n+        ClassLoader named_child_8_cl = new TestClassLoader(null, emptyLoader6);\n+        ClassLoader named_child_9_cl = new TestClassLoader(null, emptyLoader6);\n+        ClassLoader named_child_10_cl = new TestClassLoader(null, emptyLoader6);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_7_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_8_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_9_cl);\n+        loadTestClassInLoaderAndCheck(\"TestClass2\", named_child_10_cl);\n@@ -86,4 +121,19 @@\n-        output.shouldContain(\"<bootstrap>\");\n-        output.shouldMatch(\".*TestClassLoader\");\n-        output.shouldMatch(\"Kevin.*TestClassLoader\");\n-        output.shouldMatch(\"Bill.*TestClassLoader\");\n+        \/\/ (A)\n+        output.shouldContain(\"+-- <bootstrap>\");\n+        output.shouldContain(\"      +-- \\\"platform\\\", jdk.internal.loader.ClassLoaders$PlatformClassLoader\");\n+        output.shouldContain(\"      |     +-- \\\"app\\\", jdk.internal.loader.ClassLoaders$AppClassLoader\");\n+        output.shouldContain(\"      +-- \\\"Kevin\\\", ClassLoaderHierarchyTest$TestClassLoader\");\n+        output.shouldContain(\"      +-- ClassLoaderHierarchyTest$TestClassLoader\");\n+        output.shouldContain(\"      |     +-- \\\"Bill\\\", ClassLoaderHierarchyTest$TestClassLoader\");\n+        \/\/ (B)\n+        output.shouldContain(\"      +-- \\\"EmptyLoader1\\\", ClassLoaderHierarchyTest$EmptyDelegatingLoader\");\n+        output.shouldContain(\"      |     +-- \\\"EmptyLoader2\\\", ClassLoaderHierarchyTest$EmptyDelegatingLoader\");\n+        output.shouldContain(\"      |           +-- \\\"Child2\\\", ClassLoaderHierarchyTest$TestClassLoader\");\n+        \/\/ (C)\n+        output.shouldContain(\"      +-- \\\"EmptyLoader3\\\", ClassLoaderHierarchyTest$EmptyDelegatingLoader\");\n+        output.shouldContain(\"      |     +-- \\\"EmptyLoader4\\\", ClassLoaderHierarchyTest$EmptyDelegatingLoader\");\n+        output.shouldContain(\"      |           +-- \\\"ChildX\\\", ClassLoaderHierarchyTest$TestClassLoader (+ 3 more)\");\n+        \/\/ (D)\n+        output.shouldContain(\"      +-- ClassLoaderHierarchyTest$EmptyDelegatingLoader\");\n+        output.shouldContain(\"            +-- ClassLoaderHierarchyTest$EmptyDelegatingLoader\");\n+        output.shouldContain(\"                  +-- ClassLoaderHierarchyTest$TestClassLoader (+ 3 more)\");\n@@ -95,3 +145,2 @@\n-        output.shouldMatch(\".*TestClassLoader\");\n-        output.shouldMatch(\"Kevin.*TestClassLoader\");\n-        output.shouldMatch(\"Bill.*TestClassLoader\");\n+        output.shouldContain(\"java.lang.Enum\");\n+        output.shouldContain(\"java.lang.NullPointerException\");\n@@ -99,0 +148,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/ClassLoaderHierarchyTest.java","additions":71,"deletions":21,"binary":false,"changes":92,"status":"modified"}]}