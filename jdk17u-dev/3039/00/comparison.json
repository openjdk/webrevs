{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -207,1 +207,9 @@\n-            return super.clone();\n+            MessageDigestSpi o = (MessageDigestSpi)super.clone();\n+            if (o.tempArray != null) {\n+                \/\/ New byte arrays are allocated when the ByteBuffer argument\n+                \/\/ to engineUpdate is not backed by a byte array.\n+                \/\/ Here, the newly allocated byte array must also be cloned\n+                \/\/ to prevent threads from sharing the same memory.\n+                o.tempArray = tempArray.clone();\n+            }\n+            return o;\n","filename":"src\/java.base\/share\/classes\/java\/security\/MessageDigestSpi.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8246077\n+ * @bug 8246077 8300416\n@@ -28,1 +28,2 @@\n- * consistent in the impl of Cloneable interface\n+ * consistent in the impl of Cloneable interface, and that clones do not\n+ * share memory.\n@@ -31,0 +32,1 @@\n+import java.nio.ByteBuffer;\n@@ -32,0 +34,2 @@\n+import java.util.Arrays;\n+import java.util.Random;\n@@ -56,1 +60,1 @@\n-            CloneNotSupportedException {\n+            CloneNotSupportedException, InterruptedException {\n@@ -74,0 +78,25 @@\n+\n+        System.out.print(\"Testing \" + algo + \" impl from \" + provName);\n+        final var d1 = MessageDigest.getInstance(algo, provName);\n+        final var buffer = ByteBuffer.allocateDirect(1024);\n+        final var r = new Random(1024);\n+\n+        fillBuffer(r, buffer);\n+        d1.update(buffer); \/\/ this statement triggers tempArray allocation\n+        final var d2 = (MessageDigest) d1.clone();\n+        assert Arrays.equals(d1.digest(), d2.digest());\n+\n+        final var t1 = updateThread(d1);\n+        final var t2 = updateThread(d2);\n+        t1.join();\n+        t2.join();\n+\n+        System.out.println(\": Shared data check\");\n+        \/\/ Random is producing the same sequence of bytes for each thread,\n+        \/\/ and thus each MessageDigest should be equal. When the memory is\n+        \/\/ shared, they inevitably overwrite each other's tempArray and\n+        \/\/ you get different results.\n+        if (!Arrays.equals(d1.digest(), d2.digest())) {\n+            throw new AssertionError(\"digests differ\");\n+        }\n+\n@@ -76,0 +105,21 @@\n+\n+    private static void fillBuffer(final Random r, final ByteBuffer buffer) {\n+        final byte[] bytes = new byte[buffer.capacity()];\n+        r.nextBytes(bytes);\n+        buffer.clear();\n+        buffer.put(bytes);\n+        buffer.flip();\n+    }\n+\n+    public static Thread updateThread(final MessageDigest d) {\n+        final var t = new Thread(() -> {\n+            final var r = new Random(1024);\n+            final ByteBuffer buffer = ByteBuffer.allocateDirect(1024);\n+            for (int i = 0; i < 1024; i++) {\n+                fillBuffer(r, buffer);\n+                d.update(buffer);\n+            }\n+        });\n+        t.start();\n+        return t;\n+    }\n","filename":"test\/jdk\/java\/security\/MessageDigest\/TestCloneable.java","additions":54,"deletions":4,"binary":false,"changes":58,"status":"modified"}]}