{"files":[{"patch":"@@ -1302,1 +1302,0 @@\n-  double predicted_old_time_ms = 0.0;\n@@ -1333,1 +1332,1 @@\n-      predicted_old_time_ms += predicted_time_ms;\n+      predicted_initial_time_ms += predicted_time_ms;\n@@ -1347,1 +1346,1 @@\n-        predicted_old_time_ms += predicted_time_ms;\n+        predicted_initial_time_ms += predicted_time_ms;\n@@ -1371,1 +1370,1 @@\n-                            \"predicted old time: %1.2fms, predicted optional time: %1.2fms, time remaining: %1.2f\",\n+                            \"predicted initial time: %1.2fms, predicted optional time: %1.2fms, time remaining: %1.2f\",\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -223,1 +223,0 @@\n-  _blks = NEW_RESOURCE_ARRAY(Block *, _cfg.number_of_blocks());\n@@ -225,0 +224,1 @@\n+  uint nr_blocks = _cfg.number_of_blocks();\n@@ -229,0 +229,4 @@\n+\n+  \/\/ The space which our buckets point into.\n+  Block** start = NEW_RESOURCE_ARRAY(Block *, nr_blocks*NUMBUCKS);\n+\n@@ -230,1 +234,1 @@\n-    buckets[i] = NEW_RESOURCE_ARRAY(Block *, _cfg.number_of_blocks());\n+    buckets[i] = &start[i*nr_blocks];\n@@ -235,3 +239,0 @@\n-    for (uint j = 0; j < _cfg.number_of_blocks(); j++) {\n-      buckets[i][j] = nullptr;\n-    }\n@@ -239,0 +240,1 @@\n+\n@@ -240,1 +242,1 @@\n-  for (uint i = 0; i < _cfg.number_of_blocks(); i++) {\n+  for (uint i = 0; i < nr_blocks; i++) {\n@@ -242,1 +244,4 @@\n-      if ((j == NUMBUCKS - 1) || (_cfg.get_block(i)->_freq > buckval[j])) {\n+      double bval = buckval[j];\n+      Block* blk = _cfg.get_block(i);\n+      if (j == NUMBUCKS - 1 || blk->_freq > bval) {\n+        uint cnt = buckcnt[j];\n@@ -244,1 +249,2 @@\n-        buckets[j][buckcnt[j]++] = _cfg.get_block(i);\n+        buckets[j][cnt] = blk;\n+        buckcnt[j] = cnt+1;\n@@ -249,1 +255,16 @@\n-  \/\/ Dump buckets into final block array\n+\n+  \/\/ Squash the partially filled buckets together into the first one.\n+  static_assert(NUMBUCKS >= 2, \"must\"); \/\/ If this isn't true then it'll mess up the squashing.\n+  Block** offset = &buckets[0][buckcnt[0]];\n+  for (int i = 1; i < NUMBUCKS; i++) {\n+    ::memmove(offset, buckets[i], buckcnt[i]*sizeof(Block*));\n+    offset += buckcnt[i];\n+  }\n+  assert((&buckets[0][0] + nr_blocks) == offset, \"should be\");\n+\n+  \/\/ Free the now unused memory\n+  FREE_RESOURCE_ARRAY(Block*, buckets[1], (NUMBUCKS-1)*nr_blocks);\n+  \/\/ Finally, point the _blks to our memory\n+  _blks = buckets[0];\n+\n+#ifdef ASSERT\n@@ -252,3 +273,1 @@\n-    for (uint j = 0; j < buckcnt[i]; j++) {\n-      _blks[blkcnt++] = buckets[i][j];\n-    }\n+    blkcnt += buckcnt[i];\n@@ -256,2 +275,2 @@\n-\n-  assert(blkcnt == _cfg.number_of_blocks(), \"Block array not totally filled\");\n+  assert(blkcnt == nr_blocks, \"Block array not totally filled\");\n+#endif\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":33,"deletions":14,"binary":false,"changes":47,"status":"modified"}]}