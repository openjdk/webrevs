{"files":[{"patch":"@@ -0,0 +1,320 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.security.SecurityUtils;\n+\n+import javax.net.ssl.*;\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\/*\n+ * @test\n+ * @bug 8301381\n+ * @library \/test\/lib \/javax\/net\/ssl\/templates\n+ * @summary DTLSv10 is now disabled. This test verifies that the server will\n+ *     not negotiate a connection if the client asks for it.\n+ * @run main\/othervm DTLSWontNegotiateV10 DTLS\n+ * @run main\/othervm DTLSWontNegotiateV10 DTLSv1.0\n+ *\/\n+public class DTLSWontNegotiateV10 {\n+\n+    private static final int MTU = 1024;\n+    private static final String DTLSV_1_0 = \"DTLSv1.0\";\n+    private static final String DTLS = \"DTLS\";\n+    private static final String DTLSV_1_2 = \"DTLSv1.2\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args[0].equals(DTLSV_1_0)) {\n+            SecurityUtils.removeFromDisabledTlsAlgs(DTLSV_1_0);\n+        }\n+\n+        if (args.length > 1) {\n+            \/\/ running in client child process\n+            \/\/ args: protocol server-port\n+            try (DTLSClient client = new DTLSClient(args[0], Integer.parseInt(args[1]))) {\n+                client.run();\n+            }\n+\n+        } else {\n+            \/\/ server process\n+            \/\/ args: protocol\n+            try (DTLSServer server = new DTLSServer(args[0])) {\n+                List<String> command = List.of(\n+                        Path.of(System.getProperty(\"java.home\"), \"bin\", \"java\").toString(),\n+                        \"DTLSWontNegotiateV10\",\n+                        \/\/ if server is \"DTLS\" then the client should be v1.0 and vice versa\n+                        args[0].equals(DTLS) ? DTLSV_1_0 : DTLS,\n+                        Integer.toString(server.getListeningPortNumber())\n+                );\n+\n+                ProcessBuilder builder = new ProcessBuilder(command);\n+                Process p = builder.inheritIO().start();\n+                server.run();\n+                p.destroy();\n+                System.out.println(\"Success: DTLSv1.0 connection was not established.\");\n+            }\n+        }\n+    }\n+\n+    private static class DTLSClient extends DTLSEndpoint {\n+        private final int remotePort;\n+\n+        private final DatagramSocket socket = new DatagramSocket();\n+\n+        public DTLSClient(String protocol, int portNumber) throws Exception {\n+            super(true, protocol);\n+            remotePort = portNumber;\n+            log(\"Enabled protocols: \" + String.join(\" \", engine.getEnabledProtocols()));\n+        }\n+\n+        @Override\n+        public void run() throws Exception {\n+            doHandshake(socket);\n+            log(\"Client done handshaking. Protocol: \" + engine.getSession().getProtocol());\n+        }\n+\n+        @Override\n+        void setRemotePortNumber(int portNumber) {\n+            \/\/ don't do anything; we're using the one we already know\n+        }\n+\n+        @Override\n+        int getRemotePortNumber() {\n+            return remotePort;\n+        }\n+\n+        @Override\n+        public void close () {\n+            socket.close();\n+        }\n+    }\n+\n+    private abstract static class DTLSEndpoint extends SSLContextTemplate implements AutoCloseable {\n+        protected final SSLEngine engine;\n+        protected final SSLContext context;\n+        private final String protocol;\n+        protected final InetAddress LOCALHOST;\n+\n+        private final String tag;\n+\n+        public DTLSEndpoint(boolean useClientMode, String protocol) throws Exception {\n+            this.protocol = protocol;\n+            if (useClientMode) {\n+                tag = \"client\";\n+                context = createClientSSLContext();\n+            } else {\n+                tag = \"server\";\n+                context = createServerSSLContext();\n+            }\n+            engine = context.createSSLEngine();\n+            engine.setUseClientMode(useClientMode);\n+            SSLParameters params = engine.getSSLParameters();\n+            params.setMaximumPacketSize(MTU);\n+            engine.setSSLParameters(params);\n+            if (protocol.equals(DTLS)) {\n+                \/\/ make sure both versions are \"enabled\"; 1.0 should be\n+                \/\/ disabled by policy now and won't be negotiated.\n+                engine.setEnabledProtocols(new String[]{DTLSV_1_0, DTLSV_1_2});\n+            } else {\n+                engine.setEnabledProtocols(new String[]{DTLSV_1_0});\n+            }\n+\n+            LOCALHOST = InetAddress.getByName(\"localhost\");\n+        }\n+\n+        @Override\n+        protected ContextParameters getServerContextParameters() {\n+            return new ContextParameters(protocol, \"PKIX\", \"NewSunX509\");\n+        }\n+\n+        @Override\n+        protected ContextParameters getClientContextParameters() {\n+            return new ContextParameters(protocol, \"PKIX\", \"NewSunX509\");\n+        }\n+\n+\n+        abstract void setRemotePortNumber(int portNumber);\n+\n+        abstract int getRemotePortNumber();\n+\n+        abstract void run() throws Exception;\n+\n+        private boolean runDelegatedTasks() {\n+            log(\"Running delegated tasks.\");\n+            Runnable runnable;\n+            while ((runnable = engine.getDelegatedTask()) != null) {\n+                runnable.run();\n+            }\n+\n+            SSLEngineResult.HandshakeStatus hs = engine.getHandshakeStatus();\n+            if (hs == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n+                throw new RuntimeException(\n+                        \"Handshake shouldn't need additional tasks\");\n+            }\n+\n+            return true;\n+        }\n+\n+        protected void doHandshake(DatagramSocket socket) throws Exception {\n+            boolean handshaking = true;\n+            engine.beginHandshake();\n+            while (handshaking) {\n+                log(\"Handshake status = \" + engine.getHandshakeStatus());\n+                handshaking = switch (engine.getHandshakeStatus()) {\n+                    case NEED_UNWRAP, NEED_UNWRAP_AGAIN -> readFromServer(socket);\n+                    case NEED_WRAP -> sendHandshakePackets(socket);\n+                    case NEED_TASK -> runDelegatedTasks();\n+                    case NOT_HANDSHAKING, FINISHED -> false;\n+                };\n+            }\n+        }\n+\n+        private boolean readFromServer(DatagramSocket socket) throws IOException {\n+            log(\"Reading data from remote endpoint.\");\n+            ByteBuffer iNet, iApp;\n+            if (engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n+                byte[] buffer = new byte[MTU];\n+                DatagramPacket packet = new DatagramPacket(buffer, buffer.length);\n+                socket.receive(packet);\n+                setRemotePortNumber(packet.getPort());\n+                iNet = ByteBuffer.wrap(buffer, 0, packet.getLength());\n+                iApp = ByteBuffer.allocate(MTU);\n+            } else {\n+                iNet = ByteBuffer.allocate(0);\n+                iApp = ByteBuffer.allocate(MTU);\n+            }\n+\n+            SSLEngineResult engineResult;\n+            do {\n+                engineResult = engine.unwrap(iNet, iApp);\n+            } while (iNet.hasRemaining());\n+\n+            return switch (engineResult.getStatus()) {\n+                case CLOSED -> false;\n+                case OK -> true;\n+                case BUFFER_OVERFLOW -> throw new RuntimeException(\"Buffer overflow: \"\n+                        + \"incorrect server maximum fragment size\");\n+                case BUFFER_UNDERFLOW -> throw new RuntimeException(\"Buffer underflow: \"\n+                        + \"incorrect server maximum fragment size\");\n+            };\n+        }\n+\n+        private boolean sendHandshakePackets(DatagramSocket socket) throws Exception {\n+            List<DatagramPacket> packets = generateHandshakePackets();\n+            log(\"Sending handshake packets.\");\n+            packets.forEach((p) -> {\n+                try {\n+                    socket.send(p);\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+\n+            return true;\n+        }\n+\n+        private List<DatagramPacket> generateHandshakePackets() throws SSLException {\n+            log(\"Generating handshake packets.\");\n+            List<DatagramPacket> packets = new ArrayList<>();\n+            ByteBuffer oNet = ByteBuffer.allocate(engine.getSession().getPacketBufferSize());\n+            ByteBuffer oApp = ByteBuffer.allocate(0);\n+\n+            while (engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n+                SSLEngineResult result = engine.wrap(oApp, oNet);\n+                oNet.flip();\n+\n+                switch (result.getStatus()) {\n+                    case BUFFER_UNDERFLOW -> {\n+                        if (engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n+                            throw new RuntimeException(\"Buffer underflow: \"\n+                                    + \"incorrect server maximum fragment size\");\n+                        }\n+                    }\n+                    case BUFFER_OVERFLOW -> throw new RuntimeException(\"Buffer overflow: \"\n+                            + \"incorrect server maximum fragment size\");\n+                    case CLOSED -> throw new RuntimeException(\"SSLEngine has closed\");\n+                }\n+\n+                if (oNet.hasRemaining()) {\n+                    byte[] packetBuffer = new byte[oNet.remaining()];\n+                    oNet.get(packetBuffer);\n+                    packets.add(new DatagramPacket(packetBuffer, packetBuffer.length,\n+                            LOCALHOST, getRemotePortNumber()));\n+                }\n+\n+                runDelegatedTasks();\n+                oNet.clear();\n+            }\n+\n+            log(\"Generated \" + packets.size() + \" packets.\");\n+            return packets;\n+        }\n+\n+        protected void log(String msg) {\n+            System.out.println(tag + \": \" + msg);\n+        }\n+    }\n+\n+    private static class DTLSServer extends DTLSEndpoint implements AutoCloseable {\n+\n+        private final AtomicInteger portNumber = new AtomicInteger(0);\n+        private final DatagramSocket socket = new DatagramSocket(0);\n+\n+        public DTLSServer(String protocol) throws Exception {\n+            super(false, protocol);\n+            log(\"Enabled protocols: \" + String.join(\" \", engine.getEnabledProtocols()));\n+        }\n+\n+        @Override\n+        public void run() throws Exception {\n+            doHandshake(socket);\n+            if (!engine.getSession().getProtocol().equals(\"NONE\")) {\n+                throw new RuntimeException(\"Negotiated protocol: \"\n+                        + engine.getSession().getProtocol() +\n+                        \". No protocol should be negotated.\");\n+            }\n+        }\n+\n+        public int getListeningPortNumber() {\n+            return socket.getLocalPort();\n+        }\n+\n+        void setRemotePortNumber(int portNumber) {\n+            this.portNumber.compareAndSet(0, portNumber);\n+        }\n+\n+        int getRemotePortNumber() {\n+            return portNumber.get();\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+            socket.close();\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/DTLSWontNegotiateV10.java","additions":320,"deletions":0,"binary":false,"changes":320,"status":"added"}]}