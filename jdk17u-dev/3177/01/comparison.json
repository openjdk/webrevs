{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -251,6 +251,0 @@\n-    \/\/ Traverse the monitor chunks\n-    MonitorChunk* chunk = jt->monitor_chunks();\n-    for (; chunk != NULL; chunk = chunk->next()) {\n-      chunk->oops_do(&rcl);\n-    }\n-\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/rootResolver.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1615,1 +1615,1 @@\n-      array->element(i)->free_monitors(thread);\n+      array->element(i)->free_monitors();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-  _next               = NULL;\n","filename":"src\/hotspot\/share\/runtime\/monitorChunk.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-  MonitorChunk*    _next;\n@@ -44,7 +43,0 @@\n-  \/\/ link operations\n-  MonitorChunk* next() const                { return _next; }\n-  void set_next(MonitorChunk* next)         { _next = next; }\n-\n-  \/\/ Tells whether the monitor chunk is linked into the JavaThread\n-  bool is_linked() const                    { return next() != NULL; }\n-\n@@ -57,1 +49,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/monitorChunk.hpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -964,1 +964,2 @@\n-    } else if (current->is_lock_owned((address)mark.locker())) {\n+    } else if (current->is_Java_thread()\n+               && current->as_Java_thread()->is_lock_owned((address)mark.locker())) {\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -702,9 +702,0 @@\n-\/\/ We had to move these methods here, because vm threads get into ObjectSynchronizer::enter\n-\/\/ However, there is a note in JavaThread::is_lock_owned() about the VM threads not being\n-\/\/ used for compilation in the future. If that change is made, the need for these methods\n-\/\/ should be revisited, and they should be removed if possible.\n-\n-bool Thread::is_lock_owned(address adr) const {\n-  return is_in_full_stack(adr);\n-}\n-\n@@ -1038,2 +1029,0 @@\n-  _monitor_chunks(nullptr),\n-\n@@ -1576,7 +1565,1 @@\n-  if (Thread::is_lock_owned(adr)) return true;\n-\n-  for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n-    if (chunk->contains(adr)) return true;\n-  }\n-\n-  return false;\n+  return is_in_full_stack(adr);\n@@ -1593,17 +1576,0 @@\n-void JavaThread::add_monitor_chunk(MonitorChunk* chunk) {\n-  chunk->set_next(monitor_chunks());\n-  set_monitor_chunks(chunk);\n-}\n-\n-void JavaThread::remove_monitor_chunk(MonitorChunk* chunk) {\n-  guarantee(monitor_chunks() != NULL, \"must be non empty\");\n-  if (monitor_chunks() == chunk) {\n-    set_monitor_chunks(chunk->next());\n-  } else {\n-    MonitorChunk* prev = monitor_chunks();\n-    while (prev->next() != chunk) prev = prev->next();\n-    prev->set_next(chunk->next());\n-  }\n-}\n-\n-\n@@ -1997,7 +1963,0 @@\n-  if (has_last_Java_frame()) {\n-    \/\/ Traverse the monitor chunks\n-    for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n-      chunk->oops_do(f);\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":1,"deletions":42,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -500,3 +500,0 @@\n-  \/\/ Used by fast lock support\n-  virtual bool is_lock_owned(address adr) const;\n-\n@@ -806,4 +803,0 @@\n-  MonitorChunk* _monitor_chunks;              \/\/ Contains the off stack monitors\n-                                              \/\/ allocated during deoptimization\n-                                              \/\/ and by JNI_MonitorEnter\/Exit\n-\n@@ -1214,1 +1207,1 @@\n-  \/\/ Fast-locking support\n+  \/\/ Stack-locking support\n@@ -1391,3 +1384,0 @@\n- private:\n-  void set_monitor_chunks(MonitorChunk* monitor_chunks) { _monitor_chunks = monitor_chunks; }\n-\n@@ -1395,3 +1385,0 @@\n-  MonitorChunk* monitor_chunks() const           { return _monitor_chunks; }\n-  void add_monitor_chunk(MonitorChunk* chunk);\n-  void remove_monitor_chunk(MonitorChunk* chunk);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -51,1 +52,1 @@\n-void vframeArrayElement::free_monitors(JavaThread* jt) {\n+void vframeArrayElement::free_monitors() {\n@@ -55,1 +56,0 @@\n-     jt->remove_monitor_chunk(chunk);\n@@ -75,1 +75,1 @@\n-    Thread* current_thread = Thread::current();\n+    JavaThread* current_thread = JavaThread::current();\n@@ -88,1 +88,0 @@\n-      vf->thread()->add_monitor_chunk(_monitors);\n@@ -98,1 +97,2 @@\n-          assert(monitor->owner() == NULL || (!monitor->owner()->is_unlocked() && !monitor->owner()->has_bias_pattern()), \"object must be null or locked, and unbiased\");\n+          assert(monitor->owner() != nullptr, \"monitor owner must not be null\");\n+          assert(!monitor->owner()->is_unlocked() && !monitor->owner()->has_bias_pattern(), \"object must be locked, and unbiased\");\n@@ -100,0 +100,3 @@\n+          assert(ObjectSynchronizer::current_thread_holds_lock(current_thread, Handle(current_thread, dest->obj())),\n+                 \"should be held, before move_to\");\n+\n@@ -101,0 +104,3 @@\n+\n+          assert(ObjectSynchronizer::current_thread_holds_lock(current_thread, Handle(current_thread, dest->obj())),\n+                 \"should be held, after move_to\");\n@@ -311,0 +317,2 @@\n+    assert(src->obj() != nullptr || ObjectSynchronizer::current_thread_holds_lock(thread, Handle(thread, src->obj())),\n+           \"should be held, before move_to\");\n@@ -312,0 +320,2 @@\n+    assert(src->obj() != nullptr || ObjectSynchronizer::current_thread_holds_lock(thread, Handle(thread, src->obj())),\n+           \"should be held, after move_to\");\n@@ -618,1 +628,0 @@\n-  JavaThread* jt = JavaThread::current();\n@@ -620,1 +629,1 @@\n-     element(index)->free_monitors(jt);\n+     element(index)->free_monitors();\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-  void free_monitors(JavaThread* jt);\n+  void free_monitors();\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}