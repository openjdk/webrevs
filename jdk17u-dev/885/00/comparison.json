{"files":[{"patch":"@@ -3,1 +3,1 @@\n- * Copyright 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.\n+ * Copyright (c) 2007, 2021, Red Hat, Inc. All rights reserved.\n@@ -119,2 +119,15 @@\n-  ShouldNotCallThis();\n-  return false;\n+  address sp = (address)_sp;\n+\n+  \/\/ consider stack guards when trying to determine \"safe\" stack pointers\n+  \/\/ sp must be within the usable part of the stack (not in guards)\n+  if (!thread->is_in_usable_stack(sp)) {\n+    return false;\n+  }\n+\n+  \/\/ an fp must be within the stack and above (but not equal) sp\n+  if (!thread->is_in_stack_range_excl((address)fp(), sp)) {\n+    return false;\n+  }\n+\n+  \/\/ All good.\n+  return true;\n@@ -124,2 +137,43 @@\n-  ShouldNotCallThis();\n-  return false;\n+  assert(is_interpreted_frame(), \"Not an interpreted frame\");\n+  \/\/ These are reasonable sanity checks\n+  if (fp() == 0 || (intptr_t(fp()) & (wordSize-1)) != 0) {\n+    return false;\n+  }\n+  if (sp() == 0 || (intptr_t(sp()) & (wordSize-1)) != 0) {\n+    return false;\n+  }\n+  \/\/ These are hacks to keep us out of trouble.\n+  \/\/ The problem with these is that they mask other problems\n+  if (fp() <= sp()) {        \/\/ this attempts to deal with unsigned comparison above\n+    return false;\n+  }\n+\n+  \/\/ do some validation of frame elements\n+  \/\/ first the method\n+\n+  Method* m = *interpreter_frame_method_addr();\n+\n+  \/\/ validate the method we'd find in this potential sender\n+  if (!Method::is_valid_method(m)) {\n+    return false;\n+  }\n+\n+  \/\/ validate bci\/bcp\n+  address bcp = interpreter_frame_bcp();\n+  if (m->validate_bci_from_bcp(bcp) < 0) {\n+    return false;\n+  }\n+\n+  \/\/ validate ConstantPoolCache*\n+  ConstantPoolCache* cp = *interpreter_frame_cache_addr();\n+  if (MetaspaceObj::is_valid(cp) == false) {\n+    return false;\n+  }\n+\n+  \/\/ validate locals\n+  address locals = (address) *interpreter_frame_locals_addr();\n+  if (!thread->is_in_stack_range_incl(locals, (address)fp())) {\n+    return false;\n+  }\n+\n+  return true;\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.cpp","additions":59,"deletions":5,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright 2009, 2010 Red Hat, Inc.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2021, Red Hat, Inc. All rights reserved.\n@@ -38,0 +38,37 @@\n+\n+bool JavaThread::pd_get_top_frame_for_signal_handler(frame* fr_addr,\n+                                         void* ucontext,\n+                                         bool isInJava) {\n+  if (has_last_Java_frame()) {\n+    *fr_addr = pd_last_frame();\n+    return true;\n+  }\n+\n+  if (isInJava) {\n+    \/\/ We know we are in Java, but there is no frame?\n+    \/\/ Try to find the top-most Java frame on Zero stack then.\n+    intptr_t* sp = zero_stack()->sp();\n+    ZeroFrame* zf = top_zero_frame();\n+    while (zf != NULL) {\n+      if (zf->is_interpreter_frame()) {\n+        interpreterState istate = zf->as_interpreter_frame()->interpreter_state();\n+        if (istate->self_link() == istate) {\n+          \/\/ Valid interpreter state found, this is our frame.\n+          *fr_addr = frame(zf, sp);\n+          return true;\n+        }\n+      }\n+      sp = ((intptr_t *) zf) + 1;\n+      zf = zf->next();\n+    }\n+  }\n+\n+  \/\/ No dice.\n+  return false;\n+}\n+\n+bool JavaThread::pd_get_top_frame_for_profiling(frame* fr_addr,\n+                                    void* ucontext,\n+                                    bool isInJava) {\n+  return pd_get_top_frame_for_signal_handler(fr_addr, ucontext, isInJava);\n+}\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/thread_linux_zero.cpp","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright 2007, 2008, 2009, 2010 Red Hat, Inc.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Red Hat, Inc. All rights reserved.\n@@ -99,4 +99,1 @@\n-                                           bool isInJava) {\n-    ShouldNotCallThis();\n-    return false; \/\/ silence compile warning\n-  }\n+                                           bool isInJava);\n@@ -106,4 +103,1 @@\n-                                      bool isInJava) {\n-    ShouldNotCallThis();\n-    return false; \/\/ silence compile warning\n-  }\n+                                      bool isInJava);\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/thread_linux_zero.hpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -317,0 +317,40 @@\n+#ifdef ZERO\n+  \/\/ Zero has no frames with code blobs, so the generic code fails.\n+  \/\/ Instead, try to do Zero-specific search for Java frame.\n+\n+  {\n+    RegisterMap map(thread, false, false);\n+\n+    while (true) {\n+      \/\/ Cannot walk this frame? Cannot do anything anymore.\n+      if (!candidate.safe_for_sender(thread)) {\n+        return false;\n+      }\n+\n+      if (candidate.is_entry_frame()) {\n+        \/\/ jcw is NULL if the java call wrapper could not be found\n+        JavaCallWrapper* jcw = candidate.entry_frame_call_wrapper_if_safe(thread);\n+        \/\/ If initial frame is frame from StubGenerator and there is no\n+        \/\/ previous anchor, there are no java frames associated with a method\n+        if (jcw == NULL || jcw->is_first_frame()) {\n+          return false;\n+        }\n+      }\n+\n+      \/\/ If we find a decipherable interpreted frame, this is our initial frame.\n+      if (candidate.is_interpreted_frame()) {\n+        if (is_decipherable_interpreted_frame(thread, &candidate, method_p, bci_p)) {\n+          *initial_frame_p = candidate;\n+          return true;\n+        }\n+      }\n+\n+      \/\/ Walk some more.\n+      candidate = candidate.sender(&map);\n+    }\n+\n+    \/\/ No dice, report no initial frames.\n+    return false;\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/prims\/forte.cpp","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"}]}