{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,0 +126,19 @@\n+    \/\/ validate the key algorithm\/encoding and then returns the key bytes\n+    \/\/ which callers should erase after use\n+    private static byte[] checkKey(Key key, int fixedKeySize)\n+            throws InvalidKeyException {\n+\n+        byte[] keyBytes = key.getEncoded();\n+        if (keyBytes == null) {\n+            throw new InvalidKeyException(\"Null key\");\n+        }\n+        int keyLen = keyBytes.length;\n+        if (!key.getAlgorithm().equalsIgnoreCase(\"AES\") ||\n+            !AESCrypt.isKeySizeValid(keyLen) ||\n+            (fixedKeySize != -1 && fixedKeySize != keyLen)) {\n+                throw new InvalidKeyException(\"Invalid key length: \" +\n+                        keyLen + \" bytes\");\n+        }\n+        return keyBytes;\n+    }\n+\n@@ -297,4 +316,2 @@\n-        byte[] keyBytes = key.getEncoded();\n-        if (keyBytes == null) {\n-            throw new InvalidKeyException(\"Null key\");\n-        }\n+        byte[] keyBytes = checkKey(key, fixedKeySize);\n+\n@@ -661,4 +678,4 @@\n-        byte[] encoded = key.getEncoded();\n-        if (encoded == null)  {\n-            throw new InvalidKeyException(\"Cannot decide key length\");\n-        }\n+        byte[] keyBytes = checkKey(key, fixedKeySize);\n+        \/\/ only need length; erase immediately\n+        Arrays.fill(keyBytes, (byte) 0);\n+        return Math.multiplyExact(keyBytes.length, 8);\n@@ -666,10 +683,0 @@\n-        \/\/ only need length\n-        Arrays.fill(encoded, (byte) 0);\n-        int keyLen = encoded.length;\n-        if (!key.getAlgorithm().equalsIgnoreCase(\"AES\") ||\n-            !AESCrypt.isKeySizeValid(keyLen) ||\n-            (fixedKeySize != -1 && fixedKeySize != keyLen)) {\n-            throw new InvalidKeyException(\"Invalid key length: \" +\n-                    keyLen + \" bytes\");\n-        }\n-        return Math.multiplyExact(keyLen, 8);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KeyWrapCipher.java","additions":26,"deletions":19,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8248268\n+ * @bug 8248268 8302225\n@@ -46,0 +46,2 @@\n+    private static final int[] AES_KEYSIZES = { 128, 192, 256 };\n+\n@@ -67,1 +69,1 @@\n-            SecretKey key = getKey(ks);\n+            SecretKey key = getKey(ks >> 3);\n@@ -75,2 +77,1 @@\n-                    System.out.println(\" => expected IKE thrown for \"\n-                            + getModeStr(m));\n+                    System.out.println(getModeStr(m) + \" => got expected IKE\");\n@@ -80,0 +81,15 @@\n+\n+        \/\/ now test against the valid key size(s) and make sure they work\n+        int underscoreIdx = algo.indexOf(\"_\");\n+        int[] validKeySizes = (algo.indexOf(\"_\") == -1 ?\n+            AES_KEYSIZES : new int[] { Integer.parseInt(algo.substring\n+                    (underscoreIdx + 1, underscoreIdx + 4)) });\n+        for (int ks : validKeySizes) {\n+            System.out.println(\"keysize: \" + ks);\n+            SecretKey key = getKey(ks >> 3);\n+\n+            for (int m : modes) {\n+                c.init(m, key);\n+                System.out.println(getModeStr(m) + \" => ok\");\n+            }\n+        }\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/KeyWrap\/TestKeySizeCheck.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"}]}