{"files":[{"patch":"@@ -1113,1 +1113,1 @@\n-  G1FullCollector collector(this, explicit_gc, do_clear_all_soft_refs, do_maximum_compaction);\n+  G1FullCollector collector(this, explicit_gc, do_clear_all_soft_refs, do_maximum_compaction, gc_mark.tracer());\n@@ -2984,1 +2984,1 @@\n-    GCTraceCPUTime tcpu;\n+    GCTraceCPUTime tcpu(_gc_tracer_stw);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -598,0 +598,2 @@\n+  G1OldTracer* gc_tracer_cm() const { return _gc_tracer_cm; }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,1 +115,2 @@\n-                                 bool do_maximum_compaction) :\n+                                 bool do_maximum_compaction,\n+                                 G1FullGCTracer* tracer) :\n@@ -117,1 +118,1 @@\n-    _scope(heap->g1mm(), explicit_gc, clear_soft_refs, do_maximum_compaction),\n+    _scope(heap->g1mm(), explicit_gc, clear_soft_refs, do_maximum_compaction, tracer),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+  G1FullGCTracer _tracer;\n@@ -67,1 +68,2 @@\n-  G1FullGCMark() : _gc_id(), _cpu_time() { }\n+  G1FullGCMark() : _gc_id(), _tracer(), _cpu_time(&_tracer) { }\n+  G1FullGCTracer* tracer() { return &_tracer; }\n@@ -96,1 +98,2 @@\n-                  bool do_maximum_compaction);\n+                  bool do_maximum_compaction,\n+                  G1FullGCTracer* tracer);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,1 +41,2 @@\n-                             bool do_maximum_compaction) :\n+                             bool do_maximum_compaction,\n+                             G1FullGCTracer* tracer) :\n@@ -47,1 +48,1 @@\n-    _tracer(),\n+    _tracer(tracer),\n@@ -49,1 +50,1 @@\n-    _tracer_mark(&_timer, &_tracer),\n+    _tracer_mark(&_timer, _tracer),\n@@ -78,1 +79,1 @@\n-  return &_tracer;\n+  return _tracer;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  G1FullGCTracer          _tracer;\n+  G1FullGCTracer*         _tracer;\n@@ -66,1 +66,2 @@\n-                bool do_maximal_compaction);\n+                bool do_maximal_compaction,\n+                G1FullGCTracer* tracer);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1Trace.hpp\"\n@@ -164,1 +165,0 @@\n-  GCTraceCPUTime tcpu;\n@@ -166,0 +166,1 @@\n+  GCTraceCPUTime tcpu(g1h->concurrent_mark()->gc_tracer_cm());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1770,1 +1770,1 @@\n-    GCTraceCPUTime tcpu;\n+    GCTraceCPUTime tcpu(&_gc_tracer);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -420,1 +420,1 @@\n-    GCTraceCPUTime tcpu;\n+    GCTraceCPUTime tcpu(&_gc_tracer);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -185,0 +185,2 @@\n+\n+  _gc_tracer = new (ResourceObj::C_HEAP, mtGC) DefNewTracer();\n@@ -534,2 +536,1 @@\n-  DefNewTracer gc_tracer;\n-  gc_tracer.report_gc_start(heap->gc_cause(), _gc_timer->gc_start());\n+  _gc_tracer->report_gc_start(heap->gc_cause(), _gc_timer->gc_start());\n@@ -553,1 +554,1 @@\n-  heap->trace_heap_before_gc(&gc_tracer);\n+  heap->trace_heap_before_gc(_gc_tracer);\n@@ -597,2 +598,2 @@\n-  gc_tracer.report_gc_reference_stats(stats);\n-  gc_tracer.report_tenuring_threshold(tenuring_threshold());\n+  _gc_tracer->report_gc_reference_stats(stats);\n+  _gc_tracer->report_tenuring_threshold(tenuring_threshold());\n@@ -650,1 +651,1 @@\n-    gc_tracer.report_promotion_failed(_promotion_failed_info);\n+    _gc_tracer->report_promotion_failed(_promotion_failed_info);\n@@ -658,1 +659,1 @@\n-  heap->trace_heap_after_gc(&gc_tracer);\n+  heap->trace_heap_after_gc(_gc_tracer);\n@@ -662,1 +663,1 @@\n-  gc_tracer.report_gc_end(_gc_timer->gc_end(), _gc_timer->time_partitions());\n+  _gc_tracer->report_gc_end(_gc_timer->gc_end(), _gc_timer->time_partitions());\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+class DefNewTracer;\n@@ -142,0 +143,2 @@\n+  DefNewTracer* _gc_tracer;\n+\n@@ -333,0 +336,2 @@\n+  DefNewTracer* gc_tracer() const { return _gc_tracer; }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,4 @@\n+bool GCTracer::should_report_cpu_time_event() const {\n+  return should_send_cpu_time_event();\n+}\n+\n@@ -62,0 +66,4 @@\n+void GCTracer::report_cpu_time_event(double user_time, double system_time, double real_time) const {\n+  send_cpu_time_event(user_time, system_time, real_time);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrace.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,0 +100,1 @@\n+  bool should_report_cpu_time_event() const;\n@@ -106,0 +107,1 @@\n+  void report_cpu_time_event(double user_time, double system_time, double real_time) const;\n@@ -113,0 +115,1 @@\n+  bool should_send_cpu_time_event() const;\n@@ -119,0 +122,1 @@\n+  void send_cpu_time_event(double user_time, double system_time, double real_time) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrace.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,4 @@\n+bool GCTracer::should_send_cpu_time_event() const {\n+  return EventGCCPUTime::is_enabled();\n+}\n+\n@@ -53,0 +57,11 @@\n+void GCTracer::send_cpu_time_event(double user_time, double system_time, double real_time) const {\n+  EventGCCPUTime e;\n+  if (e.should_commit()) {\n+      e.set_gcId(GCId::current());\n+      e.set_userTime((size_t)(user_time * NANOUNITS));\n+      e.set_systemTime((size_t)(system_time * NANOUNITS));\n+      e.set_realTime((size_t)(real_time * NANOUNITS));\n+      e.commit();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTraceSend.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/gcTrace.hpp\"\n@@ -73,2 +74,3 @@\n-GCTraceCPUTime::GCTraceCPUTime() :\n-  _active(log_is_enabled(Info, gc, cpu)),\n+GCTraceCPUTime::GCTraceCPUTime(GCTracer* tracer) :\n+  _active(log_is_enabled(Info, gc, cpu) ||\n+          (tracer != nullptr && tracer->should_report_cpu_time_event())),\n@@ -77,1 +79,2 @@\n-  _starting_real_time(0.0)\n+  _starting_real_time(0.0),\n+  _tracer(tracer)\n@@ -81,2 +84,2 @@\n-                               &_starting_user_time,\n-                               &_starting_system_time);\n+                                  &_starting_user_time,\n+                                  &_starting_system_time);\n@@ -95,4 +98,7 @@\n-      log_info(gc, cpu)(\"User=%3.2fs Sys=%3.2fs Real=%3.2fs\",\n-                        user_time - _starting_user_time,\n-                        system_time - _starting_system_time,\n-                        real_time - _starting_real_time);\n+      user_time -= _starting_user_time;\n+      system_time -= _starting_system_time;\n+      real_time -= _starting_real_time;\n+      log_info(gc, cpu)(\"User=%3.2fs Sys=%3.2fs Real=%3.2fs\", user_time, system_time, real_time);\n+      if (_tracer != nullptr) {\n+        _tracer->report_cpu_time_event(user_time, system_time, real_time);\n+      }\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTraceTime.cpp","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+class GCTracer;\n+\n@@ -40,2 +42,3 @@\n- public:\n-  GCTraceCPUTime();\n+  GCTracer* _tracer;\n+public:\n+  GCTraceCPUTime(GCTracer* tracer);\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTraceTime.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/serial\/genMarkSweep.hpp\"\n@@ -557,1 +558,1 @@\n-    GCTraceCPUTime tcpu;\n+    GCTraceCPUTime tcpu(((DefNewGeneration*)_young_gen)->gc_tracer());\n@@ -608,1 +609,1 @@\n-    GCTraceCPUTime tcpu;\n+    GCTraceCPUTime tcpu(GenMarkSweep::gc_tracer());\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -434,0 +434,8 @@\n+  <Event name=\"GCCPUTime\" category=\"Java Virtual Machine, GC, Detailed\" label=\"GC CPU Time\" description=\"GC CPU Time information. Supported: G1GC, ParallelGC and SerialGC\"\n+    stackTrace=\"false\" startTime=\"false\">\n+    <Field type=\"uint\" name=\"gcId\" label=\"GC Identifier\" relation=\"GcId\" \/>\n+    <Field type=\"ulong\" contentType=\"nanos\" name=\"userTime\" label=\"User Time\" \/>\n+    <Field type=\"ulong\" contentType=\"nanos\" name=\"systemTime\" label=\"System Time\" \/>\n+    <Field type=\"ulong\" contentType=\"nanos\" name=\"realTime\" label=\"Real Time\" \/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -414,0 +414,4 @@\n+    <event name=\"jdk.GCCPUTime\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+    <\/event>\n+\n@@ -867,4 +871,4 @@\n-  <!--                                                                                                        \n-  Contents of the control element is not read by the JVM, it's used                                           \n-  by JDK Mission Control and the 'jfr' tool to change settings that                                           \n-  carry the control attribute.                                                                                \n+  <!--\n+  Contents of the control element is not read by the JVM, it's used\n+  by JDK Mission Control and the 'jfr' tool to change settings that\n+  carry the control attribute.\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -352,1 +352,1 @@\n-      <setting name=\"stackTrace\">true<\/setting> \n+      <setting name=\"stackTrace\">true<\/setting>\n@@ -414,0 +414,4 @@\n+    <event name=\"jdk.GCCPUTime\">\n+      <setting name=\"enabled\" control=\"gc-enabled-normal\">true<\/setting>\n+    <\/event>\n+\n@@ -867,4 +871,4 @@\n-  <!--                                                                                                        \n-  Contents of the control element is not read by the JVM, it's used                                           \n-  by JDK Mission Control and the 'jfr' tool to change settings that                                           \n-  carry the control attribute.                                                                                \n+  <!--\n+  Contents of the control element is not read by the JVM, it's used\n+  by JDK Mission Control and the 'jfr' tool to change settings that\n+  carry the control attribute.\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -270,1 +270,2 @@\n-                    if (event.getEventType().getName().contains(\"AllocationRequiringGC\")) {\n+                    String name = event.getEventType().getName();\n+                    if (name.contains(\"AllocationRequiringGC\")) {\n@@ -276,1 +277,4 @@\n-                    Asserts.assertLessThanOrEqual(event.getEndTime(), batchEndTime, \"endTime in event after batch end event, should be sent before GC end\");\n+                    \/\/ GCCPUTime is generated after GC is completed.\n+                    if (!EventNames.GCCPUTime.equals(name)) {\n+                        Asserts.assertLessThanOrEqual(event.getEndTime(), batchEndTime, \"endTime in event after batch end event, should be sent before GC end\");\n+                    }\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/GCEventAll.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.gc.detailed;\n+\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/**\n+ * @test id=Serial\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @requires vm.gc.Serial\n+ * @library \/test\/lib \/test\/jdk\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -Xmx32m -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseSerialGC jdk.jfr.event.gc.detailed.TestGCCPUTimeEvent\n+ *\/\n+\n+\/**\n+ * @test id=Parallel\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @requires vm.gc.Parallel\n+ * @library \/test\/lib \/test\/jdk\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -Xmx32m -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseParallelGC jdk.jfr.event.gc.detailed.TestGCCPUTimeEvent\n+ *\/\n+\n+\/**\n+ * @test id=G1\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib \/test\/jdk\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -Xmx32m -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC jdk.jfr.event.gc.detailed.TestGCCPUTimeEvent\n+ *\/\n+\n+public class TestGCCPUTimeEvent {\n+    private static final String EVENT_NAME = EventNames.GCCPUTime;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        try (Recording recording = new Recording()) {\n+\n+            \/\/ Activate the event we are interested in and start recording\n+            recording.enable(EVENT_NAME);\n+            recording.start();\n+\n+            \/\/ Guarantee one young GC.\n+            WhiteBox.getWhiteBox().youngGC();\n+            recording.stop();\n+\n+            \/\/ Verify recording\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            Events.hasEvent(events, EVENT_NAME);\n+\n+            recording.close();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/detailed\/TestGCCPUTimeEvent.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -154,0 +154,1 @@\n+    public static final String GCCPUTime = PREFIX + \"GCCPUTime\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}