{"files":[{"patch":"@@ -77,0 +77,10 @@\n+\/\/ The C ABI specifies:\n+\/\/ \"integer scalars narrower than XLEN bits are widened according to the sign\n+\/\/ of their type up to 32 bits, then sign-extended to XLEN bits.\"\n+\/\/ Applies for both passed in register and stack.\n+\/\/\n+\/\/ Java uses 32-bit stack slots; jint, jshort, jchar, jbyte uses one slot.\n+\/\/ Native uses 64-bit stack slots for all integer scalar types.\n+\/\/\n+\/\/ lw loads the Java stack slot, sign-extends and\n+\/\/ sd store this widened integer into a 64 bit native stack slot.\n@@ -85,1 +95,1 @@\n-    __ sw(x10, Address(to(), next_stack_offset()));\n+    __ sd(x10, Address(to(), next_stack_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/interpreterRT_riscv.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -761,4 +761,10 @@\n-\/\/ On 64 bit we will store integer like items to the stack as\n-\/\/ 64 bits items (riscv64 abi) even though java would only store\n-\/\/ 32bits for a parameter. On 32bit it will simply be 32 bits\n-\/\/ So this routine will do 32->32 on 32bit and 32->64 on 64bit\n+\/\/ The C ABI specifies:\n+\/\/ \"integer scalars narrower than XLEN bits are widened according to the sign\n+\/\/ of their type up to 32 bits, then sign-extended to XLEN bits.\"\n+\/\/ Applies for both passed in register and stack.\n+\/\/\n+\/\/ Java uses 32-bit stack slots; jint, jshort, jchar, jbyte uses one slot.\n+\/\/ Native uses 64-bit stack slots for all integer scalar types.\n+\/\/\n+\/\/ lw loads the Java stack slot, sign-extends and\n+\/\/ sd store this widened integer into a 64 bit native stack slot.\n@@ -769,1 +775,1 @@\n-      __ ld(t0, Address(fp, reg2offset_in(src.first())));\n+      __ lw(t0, Address(fp, reg2offset_in(src.first())));\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Pass values on stack.\n+ * @requires os.arch == \"riscv64\"\n+ * @run main\/native compiler.calls.TestManyArgs\n+ *\/\n+\n+package compiler.calls;\n+\n+public class TestManyArgs {\n+    static {\n+        System.loadLibrary(\"TestManyArgs\");\n+    }\n+\n+    native static void scramblestack();\n+\n+    native static int checkargs(int arg0, short arg1, byte arg2,\n+                                int arg3, short arg4, byte arg5,\n+                                int arg6, short arg7, byte arg8,\n+                                int arg9, short arg10, byte arg11);\n+\n+    static int compiledbridge(int arg0, short arg1, byte arg2,\n+                              int arg3, short arg4, byte arg5,\n+                              int arg6, short arg7, byte arg8,\n+                              int arg9, short arg10, byte arg11) {\n+        return checkargs(arg0, arg1, arg2, arg3, arg4, arg5,\n+                         arg6, arg7, arg8, arg9, arg10, arg11);\n+    }\n+\n+    static public void main(String[] args) {\n+        scramblestack();\n+        for (int i = 0; i < 20000; i++) {\n+            int res = compiledbridge((int)0xf, (short)0xf, (byte)0xf,\n+                                     (int)0xf, (short)0xf, (byte)0xf,\n+                                     (int)0xf, (short)0xf, (byte)0xf,\n+                                     (int)0xf, (short)0xf, (byte)0xf);\n+            if (res != 0) {\n+                throw new RuntimeException(\"Test failed\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/TestManyArgs.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+\n+#ifdef riscv64\n+\/* RV64 ABI pass all integers as 64-bit, in registers or on stack\n+ * As compiler may choose to load smaller width than 64-bit if passed on stack,\n+ * this test may not find any bugs.\n+ * Therefore we trick the compiler todo 64-bit loads,\n+ * by saying these args are jlongs.\n+ *\/\n+JNIEXPORT jint JNICALL Java_compiler_calls_TestManyArgs_checkargs(JNIEnv* env, jclass jclazz,\n+                                                                  jlong arg0, jlong arg1, jlong arg2,\n+                                                                  jlong arg3, jlong arg4, jlong arg5,\n+                                                                  jlong arg6, jlong arg7, jlong arg8,\n+                                                                  jlong arg9, jlong arg10, jlong arg11)\n+#else\n+JNIEXPORT jint JNICALL Java_compiler_calls_TestManyArgs_checkargs(JNIEnv* env, jclass jclazz,\n+                                                                  jint arg0, jshort arg1, jbyte arg2,\n+                                                                  jint arg3, jshort arg4, jbyte arg5,\n+                                                                  jint arg6, jshort arg7, jbyte arg8,\n+                                                                  jint arg9, jshort arg10, jbyte arg11)\n+#endif\n+{\n+    if (arg0 != 0xf) return 1;\n+    if (arg1 != 0xf) return 1;\n+    if (arg2 != 0xf) return 1;\n+    if (arg3 != 0xf) return 1;\n+    if (arg4 != 0xf) return 1;\n+    if (arg5 != 0xf) return 1;\n+    if (arg6 != 0xf) return 1;\n+    if (arg7 != 0xf) return 1;\n+    if (arg8 != 0xf) return 1;\n+    if (arg9 != 0xf) return 1;\n+    if (arg10 != 0xf) return 1;\n+    if (arg11 != 0xf) return 1;\n+    return 0;\n+}\n+\n+JNIEXPORT\n+void JNICALL Java_compiler_calls_TestManyArgs_scramblestack(JNIEnv* env, jclass jclazz)\n+{\n+    volatile char stack[12*8];\n+    for (unsigned int i = 0; i < sizeof(stack); i++) {\n+        stack[i] = (char)0xff;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/libTestManyArgs.c","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"}]}