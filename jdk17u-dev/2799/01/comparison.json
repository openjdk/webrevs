{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,0 +138,1 @@\n+    private volatile boolean finalResponseCodeReceived;\n@@ -435,1 +436,1 @@\n-                handleResponse();\n+                handleResponse(hframe);\n@@ -465,1 +466,1 @@\n-    protected void handleResponse() throws IOException {\n+    protected void handleResponse(HeaderFrame hf) throws IOException {\n@@ -467,3 +468,0 @@\n-        responseCode = (int)responseHeaders\n-                .firstValueAsLong(\":status\")\n-                .orElseThrow(() -> new IOException(\"no statuscode in response\"));\n@@ -471,3 +469,23 @@\n-        response = new Response(\n-                request, exchange, responseHeaders, connection(),\n-                responseCode, HttpClient.Version.HTTP_2);\n+        if (!finalResponseCodeReceived) {\n+            responseCode = (int) responseHeaders\n+                    .firstValueAsLong(\":status\")\n+                    .orElseThrow(() -> new IOException(\"no statuscode in response\"));\n+            \/\/ If informational code, response is partially complete\n+            if (responseCode < 100 || responseCode > 199) {\n+                this.finalResponseCodeReceived = true;\n+            } else if (hf.getFlag(HeaderFrame.END_STREAM)) {\n+                \/\/ see RFC 9113 section 8.1:\n+                \/\/ A HEADERS frame with the END_STREAM flag set that carries an\n+                \/\/ informational status code is malformed\n+                String msg = (\"Stream %s PROTOCOL_ERROR: \" +\n+                        \"HEADERS frame with status %s has END_STREAM flag set\")\n+                        .formatted(streamid, responseCode);\n+                if (debug.on()) {\n+                    debug.log(msg);\n+                }\n+                cancelImpl(new IOException(msg), ResetFrame.PROTOCOL_ERROR);\n+            }\n+\n+            response = new Response(\n+                    request, exchange, responseHeaders, connection(),\n+                    responseCode, HttpClient.Version.HTTP_2);\n@@ -479,1 +497,1 @@\n-        responseHeaders.firstValueAsLong(\"content-length\");\n+            responseHeaders.firstValueAsLong(\"content-length\");\n@@ -481,5 +499,5 @@\n-        if (Log.headers()) {\n-            StringBuilder sb = new StringBuilder(\"RESPONSE HEADERS:\\n\");\n-            Log.dumpHeaders(sb, \"    \", responseHeaders);\n-            Log.logHeaders(sb.toString());\n-        }\n+            if (Log.headers()) {\n+                StringBuilder sb = new StringBuilder(\"RESPONSE HEADERS:\\n\");\n+                Log.dumpHeaders(sb, \"    \", responseHeaders);\n+                Log.logHeaders(sb.toString());\n+            }\n@@ -487,2 +505,12 @@\n-        \/\/ this will clear the response headers\n-        rspHeadersConsumer.reset();\n+            \/\/ this will clear the response headers\n+            rspHeadersConsumer.reset();\n+\n+            completeResponse(response);\n+        } else {\n+            if (Log.headers()) {\n+                StringBuilder sb = new StringBuilder(\"TRAILING HEADERS:\\n\");\n+                Log.dumpHeaders(sb, \"    \", responseHeaders);\n+                Log.logHeaders(sb.toString());\n+            }\n+            rspHeadersConsumer.reset();\n+        }\n@@ -490,1 +518,0 @@\n-        completeResponse(response);\n@@ -502,1 +529,1 @@\n-            if (response == null && subscriber == null) {\n+            if ((response == null || !finalResponseCodeReceived) && subscriber == null) {\n@@ -872,0 +899,4 @@\n+                if (debug.on()) {\n+                    debug.log(\"RequestSubscriber: requestBodyCf is done: \" +\n+                            \"cancelling subscription\");\n+                }\n@@ -1306,0 +1337,1 @@\n+        private volatile boolean finalPushResponseCodeReceived;\n@@ -1400,1 +1432,1 @@\n-        protected void handleResponse() {\n+        protected void handleResponse(HeaderFrame hf) {\n@@ -1402,3 +1434,0 @@\n-            responseCode = (int)responseHeaders\n-                .firstValueAsLong(\":status\")\n-                .orElse(-1);\n@@ -1406,3 +1435,4 @@\n-            if (responseCode == -1) {\n-                completeResponseExceptionally(new IOException(\"No status code\"));\n-            }\n+            if (!finalPushResponseCodeReceived) {\n+                responseCode = (int)responseHeaders\n+                    .firstValueAsLong(\":status\")\n+                    .orElse(-1);\n@@ -1410,3 +1440,3 @@\n-            this.response = new Response(\n-                pushReq, exchange, responseHeaders, connection(),\n-                responseCode, HttpClient.Version.HTTP_2);\n+                if (responseCode == -1) {\n+                    completeResponseExceptionally(new IOException(\"No status code\"));\n+                }\n@@ -1414,5 +1444,1 @@\n-            \/* TODO: review if needs to be removed\n-               the value is not used, but in case `content-length` doesn't parse\n-               as long, there will be NumberFormatException. If left as is, make\n-               sure code up the stack handles NFE correctly. *\/\n-            responseHeaders.firstValueAsLong(\"content-length\");\n+                this.finalPushResponseCodeReceived = true;\n@@ -1420,6 +1446,3 @@\n-            if (Log.headers()) {\n-                StringBuilder sb = new StringBuilder(\"RESPONSE HEADERS\");\n-                sb.append(\" (streamid=\").append(streamid).append(\"):\\n\");\n-                Log.dumpHeaders(sb, \"    \", responseHeaders);\n-                Log.logHeaders(sb.toString());\n-            }\n+                this.response = new Response(\n+                        pushReq, exchange, responseHeaders, connection(),\n+                        responseCode, HttpClient.Version.HTTP_2);\n@@ -1427,1 +1450,5 @@\n-            rspHeadersConsumer.reset();\n+                \/* TODO: review if needs to be removed\n+                   the value is not used, but in case `content-length` doesn't parse\n+                   as long, there will be NumberFormatException. If left as is, make\n+                   sure code up the stack handles NFE correctly. *\/\n+                responseHeaders.firstValueAsLong(\"content-length\");\n@@ -1429,2 +1456,20 @@\n-            \/\/ different implementations for normal streams and pushed streams\n-            completeResponse(response);\n+                if (Log.headers()) {\n+                    StringBuilder sb = new StringBuilder(\"RESPONSE HEADERS\");\n+                    sb.append(\" (streamid=\").append(streamid).append(\"):\\n\");\n+                    Log.dumpHeaders(sb, \"    \", responseHeaders);\n+                    Log.logHeaders(sb.toString());\n+                }\n+\n+                rspHeadersConsumer.reset();\n+\n+                \/\/ different implementations for normal streams and pushed streams\n+                completeResponse(response);\n+            } else {\n+                if (Log.headers()) {\n+                    StringBuilder sb = new StringBuilder(\"TRAILING HEADERS\");\n+                    sb.append(\" (streamid=\").append(streamid).append(\"):\\n\");\n+                    Log.dumpHeaders(sb, \"    \", responseHeaders);\n+                    Log.logHeaders(sb.toString());\n+                }\n+                rspHeadersConsumer.reset();\n+            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":88,"deletions":43,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -0,0 +1,325 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ @test\n+ * @summary Trailing headers should be ignored by the client when using HTTP\/2\n+ *          and not affect the rest of the exchange.\n+ * @bug 8296410\n+ * @library \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer\n+ * @run testng\/othervm -Djdk.httpclient.HttpClient.log=all TrailingHeadersTest\n+ *\/\n+\n+import jdk.httpclient.test.lib.http2.OutgoingPushPromise;\n+import jdk.internal.net.http.common.HttpHeadersBuilder;\n+import jdk.internal.net.http.frame.DataFrame;\n+import jdk.internal.net.http.frame.HeaderFrame;\n+import jdk.internal.net.http.frame.HeadersFrame;\n+import org.testng.TestException;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import javax.net.ssl.SSLSession;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.Executors;\n+import java.util.function.BiPredicate;\n+\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import jdk.httpclient.test.lib.http2.Http2TestServerConnection;\n+import jdk.httpclient.test.lib.http2.Http2TestExchangeImpl;\n+import jdk.httpclient.test.lib.http2.Http2TestExchange;\n+import jdk.httpclient.test.lib.http2.Http2Handler;\n+import jdk.httpclient.test.lib.http2.BodyOutputStream;\n+\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TrailingHeadersTest {\n+\n+    Http2TestServer http2TestServer;\n+    URI trailingURI, trailng1xxURI, trailingPushPromiseURI, warmupURI;\n+    static PrintStream testLog = System.err;\n+\n+    \/\/ Set up simple client-side push promise handler\n+    ConcurrentMap<HttpRequest, CompletableFuture<HttpResponse<String>>> pushPromiseMap = new ConcurrentHashMap<>();\n+\n+    @BeforeMethod\n+    public void beforeMethod() {\n+        pushPromiseMap = new ConcurrentHashMap<>();\n+    }\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        Properties props = new Properties();\n+        \/\/ For triggering trailing headers to send after Push Promise Response headers are sent\n+        props.setProperty(\"sendTrailingHeadersAfterPushPromise\", \"1\");\n+\n+        http2TestServer = new Http2TestServer(\"Test_Server\",\n+                                              false,\n+                                              0,\n+                                              null,\n+                                              0,\n+                                              props,\n+                                       null);\n+        http2TestServer.setExchangeSupplier(TrailingHeadersExchange::new);\n+        http2TestServer.addHandler(new ResponseTrailersHandler(), \"\/ResponseTrailingHeaders\");\n+        http2TestServer.addHandler(new InformationalTrailersHandler(), \"\/InfoRespTrailingHeaders\");\n+        http2TestServer.addHandler(new PushPromiseTrailersHandler(), \"\/PushPromiseTrailingHeaders\");\n+        http2TestServer.addHandler(new WarmupHandler(), \"\/WarmupHandler\");\n+\n+        http2TestServer.start();\n+\n+        trailingURI = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/ResponseTrailingHeaders\");\n+        trailng1xxURI = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/InfoRespTrailingHeaders\");\n+        trailingPushPromiseURI = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/PushPromiseTrailingHeaders\");\n+\n+        \/\/ Used to ensure HTTP\/2 upgrade takes place\n+        warmupURI = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/WarmupHandler\");\n+    }\n+\n+    @AfterTest\n+    public void teardown() {\n+        http2TestServer.stop();\n+    }\n+\n+    @Test(dataProvider = \"httpRequests\")\n+    public void testTrailingHeaders(String description, HttpRequest hRequest, HttpResponse.PushPromiseHandler<String> pph) {\n+        testLog.println(\"testTrailingHeaders(): \" + description);\n+        HttpClient httpClient = HttpClient.newBuilder().build();\n+        performWarmupRequest(httpClient);\n+        CompletableFuture<HttpResponse<String>> cf = httpClient.sendAsync(hRequest, BodyHandlers.ofString(UTF_8), pph);\n+\n+        testLog.println(\"testTrailingHeaders(): Performing request: \" + hRequest);\n+        HttpResponse<String> resp = cf.join();\n+\n+        assertEquals(resp.statusCode(), 200, \"Status code of response should be 200\");\n+\n+        \/\/ Verify Push Promise was successful if necessary\n+        if (pph != null)\n+            verifyPushPromise();\n+\n+        testLog.println(\"testTrailingHeaders(): Request successfully completed\");\n+    }\n+\n+    private void verifyPushPromise()  {\n+        assertEquals(pushPromiseMap.size(), 1, \"Push Promise should not be greater than 1\");\n+        \/\/ This will only iterate once\n+        for (HttpRequest r : pushPromiseMap.keySet()) {\n+            CompletableFuture<HttpResponse<String>> serverPushResp = pushPromiseMap.get(r);\n+            \/\/ Get the push promise HttpResponse result if present\n+            HttpResponse<String> resp = serverPushResp.join();\n+            assertEquals(resp.body(), \"Sample_Push_Data\", \"Unexpected Push Promise response body\");\n+            assertEquals(resp.statusCode(), 200, \"Status code of Push Promise response should be 200\");\n+        }\n+    }\n+\n+    private void performWarmupRequest(HttpClient httpClient) {\n+        HttpRequest warmupReq = HttpRequest.newBuilder(warmupURI).version(HTTP_2)\n+                .GET()\n+                .build();\n+        httpClient.sendAsync(warmupReq, BodyHandlers.discarding()).join();\n+    }\n+\n+    @DataProvider(name = \"httpRequests\")\n+    public Object[][] uris() {\n+        HttpResponse.PushPromiseHandler<String> pph = (initial, pushRequest, acceptor) -> {\n+            HttpResponse.BodyHandler<String> s = HttpResponse.BodyHandlers.ofString(UTF_8);\n+            pushPromiseMap.put(pushRequest, acceptor.apply(s));\n+        };\n+\n+        HttpRequest httpGetTrailing = HttpRequest.newBuilder(trailingURI).version(HTTP_2)\n+                .GET()\n+                .build();\n+\n+        HttpRequest httpPost1xxTrailing = HttpRequest.newBuilder(trailng1xxURI).version(HTTP_2)\n+                .POST(HttpRequest.BodyPublishers.ofString(\"Test Post\"))\n+                .expectContinue(true)\n+                .build();\n+\n+        HttpRequest httpGetPushPromiseTrailing = HttpRequest.newBuilder(trailingPushPromiseURI).version(HTTP_2)\n+                .GET()\n+                .build();\n+\n+        return new Object[][] {\n+                { \"Test GET with Trailing Headers\", httpGetTrailing, null },\n+                { \"Test POST with 1xx response & Trailing Headers\", httpPost1xxTrailing, null },\n+                { \"Test Push Promise with Trailing Headers\", httpGetPushPromiseTrailing, pph }\n+        };\n+    }\n+\n+    static class TrailingHeadersExchange extends Http2TestExchangeImpl {\n+\n+        byte[] resp = \"Sample_Data\".getBytes(StandardCharsets.UTF_8);\n+\n+\n+        TrailingHeadersExchange(int streamid, String method, HttpHeaders reqheaders, HttpHeadersBuilder rspheadersBuilder,\n+                                 URI uri, InputStream is, SSLSession sslSession, BodyOutputStream os,\n+                                 Http2TestServerConnection conn, boolean pushAllowed) {\n+            super(streamid, method, reqheaders, rspheadersBuilder, uri, is, sslSession, os, conn, pushAllowed);\n+        }\n+\n+        public void sendResponseThenTrailers() throws IOException {\n+            \/*\n+            HttpHeadersBuilder hb = this.conn.createNewHeadersBuilder();\n+            hb.setHeader(\"x-sample\", \"val\");\n+            HeaderFrame headerFrame = new HeadersFrame(this.streamid, 0, this.conn.encodeHeaders(hb.build()));\n+            *\/\n+            \/\/ TODO: see if there is a safe way to encode headers without interrupting connection thread\n+            HeaderFrame headerFrame = new HeadersFrame(this.streamid, 0, List.of());\n+            headerFrame.setFlag(HeaderFrame.END_HEADERS);\n+            headerFrame.setFlag(HeaderFrame.END_STREAM);\n+\n+            this.sendResponseHeaders(200, resp.length);\n+            DataFrame dataFrame = new DataFrame(this.streamid, 0, ByteBuffer.wrap(resp));\n+            this.conn.addToOutputQ(dataFrame);\n+            this.conn.addToOutputQ(headerFrame);\n+        }\n+\n+        @Override\n+        public void serverPush(URI uri, HttpHeaders headers, InputStream content) {\n+            HttpHeadersBuilder headersBuilder = new HttpHeadersBuilder();\n+            headersBuilder.setHeader(\":method\", \"GET\");\n+            headersBuilder.setHeader(\":scheme\", uri.getScheme());\n+            headersBuilder.setHeader(\":authority\", uri.getAuthority());\n+            headersBuilder.setHeader(\":path\", uri.getPath());\n+            for (Map.Entry<String,List<String>> entry : headers.map().entrySet()) {\n+                for (String value : entry.getValue())\n+                    headersBuilder.addHeader(entry.getKey(), value);\n+            }\n+            HttpHeaders combinedHeaders = headersBuilder.build();\n+            OutgoingPushPromise pp = new OutgoingPushPromise(streamid, uri, combinedHeaders, content);\n+            pp.setFlag(HeaderFrame.END_HEADERS);\n+\n+            try {\n+                this.conn.addToOutputQ(pp);\n+            } catch (IOException ex) {\n+                testLog.println(\"serverPush(): pushPromise exception: \" + ex);\n+            }\n+        }\n+    }\n+\n+    static class WarmupHandler implements Http2Handler {\n+\n+        @Override\n+        public void handle(Http2TestExchange exchange) throws IOException {\n+            exchange.sendResponseHeaders(200, 0);\n+        }\n+    }\n+\n+    static class ResponseTrailersHandler implements Http2Handler {\n+\n+        @Override\n+        public void handle(Http2TestExchange exchange) throws IOException {\n+            if (exchange.getProtocol().equals(\"HTTP\/2\")) {\n+                if (exchange instanceof TrailingHeadersExchange trailingHeadersExchange) {\n+                    trailingHeadersExchange.sendResponseThenTrailers();\n+                }\n+            } else {\n+                testLog.println(\"ResponseTrailersHandler: Incorrect protocol version\");\n+                exchange.sendResponseHeaders(400, 0);\n+            }\n+        }\n+    }\n+\n+    static class InformationalTrailersHandler implements Http2Handler {\n+\n+        @Override\n+        public void handle(Http2TestExchange exchange) throws IOException {\n+            if (exchange.getProtocol().equals(\"HTTP\/2\")) {\n+                if (exchange instanceof TrailingHeadersExchange trailingHeadersExchange) {\n+                    testLog.println(this.getClass().getCanonicalName() + \": Sending status 100\");\n+                    trailingHeadersExchange.sendResponseHeaders(100, 0);\n+\n+                    try (InputStream is = exchange.getRequestBody()) {\n+                        is.readAllBytes();\n+                        trailingHeadersExchange.sendResponseThenTrailers();\n+                    }\n+                }\n+            } else {\n+                testLog.println(\"InformationalTrailersHandler: Incorrect protocol version\");\n+                exchange.sendResponseHeaders(400, 0);\n+            }\n+        }\n+    }\n+\n+    static class PushPromiseTrailersHandler implements Http2Handler {\n+\n+        @Override\n+        public void handle(Http2TestExchange exchange) throws IOException {\n+            if (exchange.getProtocol().equals(\"HTTP\/2\")) {\n+                if (exchange instanceof TrailingHeadersExchange trailingHeadersExchange) {\n+                    try (InputStream is = exchange.getRequestBody()) {\n+                        is.readAllBytes();\n+                    }\n+\n+                    if (exchange.serverPushAllowed()) {\n+                        pushPromise(trailingHeadersExchange);\n+                    }\n+\n+                    try (OutputStream os = trailingHeadersExchange.getResponseBody()) {\n+                        byte[] bytes = \"Sample_Data\".getBytes(UTF_8);\n+                        trailingHeadersExchange.sendResponseHeaders(200, bytes.length);\n+                        os.write(bytes);\n+                    }\n+                }\n+            }\n+        }\n+\n+        static final BiPredicate<String,String> ACCEPT_ALL = (x, y) -> true;\n+\n+        private void pushPromise(Http2TestExchange exchange) {\n+            URI requestURI = exchange.getRequestURI();\n+            URI uri = requestURI.resolve(\"\/promise\");\n+            InputStream is = new ByteArrayInputStream(\"Sample_Push_Data\".getBytes(UTF_8));\n+            Map<String, List<String>> map = new HashMap<>();\n+            map.put(\"x-promise\", List.of(\"promise-header\"));\n+            HttpHeaders headers = HttpHeaders.of(map, ACCEPT_ALL);\n+            exchange.serverPush(uri, headers, is);\n+            testLog.println(\"PushPromiseTrailersHandler: Push Promise complete\");\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/TrailingHeadersTest.java","additions":325,"deletions":0,"binary":false,"changes":325,"status":"added"},{"patch":"@@ -133,1 +133,1 @@\n-            send(EMPTY_BARRAY, 0, 0, DataFrame.END_STREAM);\n+            sendEndStream();\n@@ -139,0 +139,4 @@\n+\n+    protected void sendEndStream() throws IOException {\n+        send(EMPTY_BARRAY, 0, 0, DataFrame.END_STREAM);\n+    }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/BodyOutputStream.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -134,0 +134,3 @@\n+        \/\/ Do not set Content-Length for 100, and do not set END_STREAM\n+        if (rCode == 100) responseLength = 0;\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestExchangeImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-        this.properties = properties;\n+        this.properties = properties == null ? new Properties() : properties;\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -927,1 +927,12 @@\n-                        SettingsFrame.INITIAL_WINDOW_SIZE), this);\n+                        SettingsFrame.INITIAL_WINDOW_SIZE), this) {\n+\n+            @Override\n+            protected void sendEndStream() throws IOException {\n+                if (properties.getProperty(\"sendTrailingHeadersAfterPushPromise\", \"0\").equals(\"1\")) {\n+                    conn.outputQ.put(getTrailingHeadersFrame(promisedStreamid, List.of()));\n+                } else {\n+                    super.sendEndStream();\n+                }\n+            }\n+        };\n+\n@@ -934,0 +945,1 @@\n+\n@@ -946,0 +958,5 @@\n+    private HeadersFrame getTrailingHeadersFrame(int promisedStreamid, List<ByteBuffer> headerBlocks) {\n+        \/\/ TODO: see if there is a safe way to encode headers without interrupting connection thread\n+        return new HeadersFrame(promisedStreamid, (HeaderFrame.END_HEADERS | HeaderFrame.END_STREAM), headerBlocks);\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServerConnection.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"}]}