{"files":[{"patch":"@@ -881,13 +881,12 @@\n-  {\n-    MutexLocker mu(THREAD, Threads_lock);\n-    switch (type) {\n-      case compiler_t:\n-        assert(comp != NULL, \"Compiler instance missing.\");\n-        if (!InjectCompilerCreationFailure || comp->num_compiler_threads() == 0) {\n-          CompilerCounters* counters = new CompilerCounters();\n-          new_thread = new CompilerThread(queue, counters);\n-        }\n-        break;\n-      case sweeper_t:\n-        new_thread = new CodeCacheSweeperThread();\n-        break;\n+\n+  switch (type) {\n+    case compiler_t:\n+      assert(comp != NULL, \"Compiler instance missing.\");\n+      if (!InjectCompilerCreationFailure || comp->num_compiler_threads() == 0) {\n+        CompilerCounters* counters = new CompilerCounters();\n+        new_thread = new CompilerThread(queue, counters);\n+      }\n+      break;\n+    case sweeper_t:\n+      new_thread = new CodeCacheSweeperThread();\n+      break;\n@@ -895,3 +894,3 @@\n-      case deoptimizer_t:\n-        new_thread = new DeoptimizeObjectsALotThread();\n-        break;\n+    case deoptimizer_t:\n+      new_thread = new DeoptimizeObjectsALotThread();\n+      break;\n@@ -899,20 +898,3 @@\n-      default:\n-        ShouldNotReachHere();\n-    }\n-\n-    \/\/ At this point the new CompilerThread data-races with this startup\n-    \/\/ thread (which I believe is the primoridal thread and NOT the VM\n-    \/\/ thread).  This means Java bytecodes being executed at startup can\n-    \/\/ queue compile jobs which will run at whatever default priority the\n-    \/\/ newly created CompilerThread runs at.\n-\n-\n-    \/\/ At this point it may be possible that no osthread was created for the\n-    \/\/ JavaThread due to lack of memory. We would have to throw an exception\n-    \/\/ in that case. However, since this must work and we do not allow\n-    \/\/ exceptions anyway, check and abort if this fails. But first release the\n-    \/\/ lock.\n-\n-    if (new_thread != NULL && new_thread->osthread() != NULL) {\n-\n-      java_lang_Thread::set_thread(JNIHandles::resolve_non_null(thread_handle), new_thread);\n+    default:\n+      ShouldNotReachHere();\n+  }\n@@ -920,3 +902,5 @@\n-      \/\/ Note that this only sets the JavaThread _priority field, which by\n-      \/\/ definition is limited to Java priorities and not OS priorities.\n-      \/\/ The os-priority is set in the CompilerThread startup code itself\n+  \/\/ At this point the new CompilerThread data-races with this startup\n+  \/\/ thread (which is the main thread and NOT the VM thread).\n+  \/\/ This means Java bytecodes being executed at startup can\n+  \/\/ queue compile jobs which will run at whatever default priority the\n+  \/\/ newly created CompilerThread runs at.\n@@ -924,1 +908,0 @@\n-      java_lang_Thread::set_priority(JNIHandles::resolve_non_null(thread_handle), NearMaxPriority);\n@@ -926,4 +909,5 @@\n-      \/\/ Note that we cannot call os::set_priority because it expects Java\n-      \/\/ priorities and we are *explicitly* using OS priorities so that it's\n-      \/\/ possible to set the compiler thread priority higher than any Java\n-      \/\/ thread.\n+  \/\/ At this point it may be possible that no osthread was created for the\n+  \/\/ JavaThread due to lack of resources. We will handle that failure below.\n+  \/\/ Also check new_thread so that static analysis is happy.\n+  if (new_thread != NULL && new_thread->osthread() != NULL) {\n+    Handle thread_oop(THREAD, JNIHandles::resolve_non_null(thread_handle));\n@@ -931,9 +915,3 @@\n-      int native_prio = CompilerThreadPriority;\n-      if (native_prio == -1) {\n-        if (UseCriticalCompilerThreadPriority) {\n-          native_prio = os::java_to_os_priority[CriticalPriority];\n-        } else {\n-          native_prio = os::java_to_os_priority[NearMaxPriority];\n-        }\n-      }\n-      os::set_native_priority(new_thread, native_prio);\n+    if (type == compiler_t) {\n+      CompilerThread::cast(new_thread)->set_compiler(comp);\n+    }\n@@ -941,1 +919,4 @@\n-      java_lang_Thread::set_daemon(JNIHandles::resolve_non_null(thread_handle));\n+    \/\/ Note that we cannot call os::set_priority because it expects Java\n+    \/\/ priorities and we are *explicitly* using OS priorities so that it's\n+    \/\/ possible to set the compiler thread priority higher than any Java\n+    \/\/ thread.\n@@ -943,3 +924,6 @@\n-      new_thread->set_threadObj(JNIHandles::resolve_non_null(thread_handle));\n-      if (type == compiler_t) {\n-        CompilerThread::cast(new_thread)->set_compiler(comp);\n+    int native_prio = CompilerThreadPriority;\n+    if (native_prio == -1) {\n+      if (UseCriticalCompilerThreadPriority) {\n+        native_prio = os::java_to_os_priority[CriticalPriority];\n+      } else {\n+        native_prio = os::java_to_os_priority[NearMaxPriority];\n@@ -947,2 +931,0 @@\n-      Threads::add(new_thread);\n-      Thread::start(new_thread);\n@@ -950,1 +932,1 @@\n-  }\n+    os::set_native_priority(new_thread, native_prio);\n@@ -952,6 +934,9 @@\n-  \/\/ First release lock before aborting VM.\n-  if (new_thread == NULL || new_thread->osthread() == NULL) {\n-    if (UseDynamicNumberOfCompilerThreads && type == compiler_t && comp->num_compiler_threads() > 0) {\n-      if (new_thread != NULL) {\n-        new_thread->smr_delete();\n-      }\n+    \/\/ Note that this only sets the JavaThread _priority field, which by\n+    \/\/ definition is limited to Java priorities and not OS priorities.\n+    JavaThread::start_internal_daemon(THREAD, new_thread, thread_oop, NearMaxPriority);\n+\n+  } else { \/\/ osthread initialization failure\n+    if (UseDynamicNumberOfCompilerThreads && type == compiler_t\n+        && comp->num_compiler_threads() > 0) {\n+      \/\/ The new thread is not known to Thread-SMR yet so we can just delete.\n+      delete new_thread;\n@@ -959,0 +944,3 @@\n+    } else {\n+      vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n+                                    os::native_thread_creation_failed_msg());\n@@ -960,2 +948,0 @@\n-    vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n-                                  os::native_thread_creation_failed_msg());\n@@ -964,1 +950,0 @@\n-  \/\/ Let go of Threads_lock before yielding\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":54,"deletions":69,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -49,20 +49,11 @@\n-  bool allocation_failed = false;\n-  JavaThread* new_thread = NULL;\n-  {\n-    MutexLocker mu(THREAD, Threads_lock);\n-    new_thread = new JavaThread(proc);\n-    \/\/ At this point it may be possible that no\n-    \/\/ osthread was created for the JavaThread due to lack of memory.\n-    if (new_thread == NULL || new_thread->osthread() == NULL) {\n-      delete new_thread;\n-      allocation_failed = true;\n-    } else {\n-      java_lang_Thread::set_thread(thread_oop(), new_thread);\n-      java_lang_Thread::set_priority(thread_oop(), NormPriority);\n-      java_lang_Thread::set_daemon(thread_oop());\n-      new_thread->set_threadObj(thread_oop());\n-      Threads::add(new_thread);\n-    }\n-  }\n-  if (allocation_failed) {\n-    JfrJavaSupport::throw_out_of_memory_error(\"Unable to create native recording thread for JFR\", CHECK_NULL);\n+  JavaThread* new_thread = new JavaThread(proc);\n+\n+  \/\/ At this point it may be possible that no\n+  \/\/ osthread was created for the JavaThread due to lack of resources.\n+  if (new_thread->osthread() == NULL) {\n+    delete new_thread;\n+    JfrJavaSupport::throw_out_of_memory_error(\"Unable to create native recording thread for JFR\", THREAD);\n+    return NULL;\n+  } else {\n+    JavaThread::start_internal_daemon(THREAD, new_thread, thread_oop, NormPriority);\n+    return new_thread;\n@@ -70,2 +61,0 @@\n-  Thread::start(new_thread);\n-  return new_thread;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderThread.cpp","additions":11,"deletions":22,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1329,2 +1329,0 @@\n-  {\n-    MutexLocker mu(current_thread, Threads_lock); \/\/ grab Threads_lock\n@@ -1332,1 +1330,1 @@\n-    JvmtiAgentThread *new_thread = new JvmtiAgentThread(this, proc, arg);\n+  JvmtiAgentThread* new_thread = new JvmtiAgentThread(this, proc, arg);\n@@ -1334,12 +1332,7 @@\n-    \/\/ At this point it may be possible that no osthread was created for the\n-    \/\/ JavaThread due to lack of memory.\n-    if (new_thread == NULL || new_thread->osthread() == NULL) {\n-      if (new_thread != NULL) {\n-        new_thread->smr_delete();\n-      }\n-      return JVMTI_ERROR_OUT_OF_MEMORY;\n-    }\n-\n-    java_lang_Thread::set_thread(thread_hndl(), new_thread);\n-    java_lang_Thread::set_priority(thread_hndl(), (ThreadPriority)priority);\n-    java_lang_Thread::set_daemon(thread_hndl());\n+  \/\/ At this point it may be possible that no osthread was created for the\n+  \/\/ JavaThread due to lack of resources.\n+  if (new_thread->osthread() == NULL) {\n+    \/\/ The new thread is not known to Thread-SMR yet so we can just delete.\n+    delete new_thread;\n+    return JVMTI_ERROR_OUT_OF_MEMORY;\n+  }\n@@ -1347,4 +1340,2 @@\n-    new_thread->set_threadObj(thread_hndl());\n-    Threads::add(new_thread);\n-    Thread::start(new_thread);\n-  } \/\/ unlock Threads_lock\n+  JavaThread::start_internal_daemon(current_thread, new_thread, thread_hndl,\n+                                    (ThreadPriority)priority);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":10,"deletions":19,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-MonitorDeflationThread* MonitorDeflationThread::_instance = NULL;\n-\n@@ -53,12 +51,2 @@\n-  {\n-    MutexLocker mu(THREAD, Threads_lock);\n-    MonitorDeflationThread* thread =  new MonitorDeflationThread(&monitor_deflation_thread_entry);\n-\n-    \/\/ At this point it may be possible that no osthread was created for the\n-    \/\/ JavaThread due to lack of memory. We would have to throw an exception\n-    \/\/ in that case. However, since this must work and we do not allow\n-    \/\/ exceptions anyway, check and abort if this fails.\n-    if (thread == NULL || thread->osthread() == NULL) {\n-      vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n-                                    os::native_thread_creation_failed_msg());\n-    }\n+  MonitorDeflationThread* thread = new MonitorDeflationThread(&monitor_deflation_thread_entry);\n+  JavaThread::vm_exit_on_osthread_failure(thread);\n@@ -66,9 +54,1 @@\n-    java_lang_Thread::set_thread(thread_oop(), thread);\n-    java_lang_Thread::set_priority(thread_oop(), NearMaxPriority);\n-    java_lang_Thread::set_daemon(thread_oop());\n-    thread->set_threadObj(thread_oop());\n-    _instance = thread;\n-\n-    Threads::add(thread);\n-    Thread::start(thread);\n-  }\n+  JavaThread::start_internal_daemon(THREAD, thread, thread_oop, NearMaxPriority);\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.cpp","additions":3,"deletions":23,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-  static MonitorDeflationThread* _instance;\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-NotificationThread* NotificationThread::_instance = NULL;\n-\n@@ -64,12 +62,0 @@\n-  {\n-    MutexLocker mu(THREAD, Threads_lock);\n-    NotificationThread* thread =  new NotificationThread(&notification_thread_entry);\n-\n-    \/\/ At this point it may be possible that no osthread was created for the\n-    \/\/ JavaThread due to lack of memory. We would have to throw an exception\n-    \/\/ in that case. However, since this must work and we do not allow\n-    \/\/ exceptions anyway, check and abort if this fails.\n-    if (thread == NULL || thread->osthread() == NULL) {\n-      vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n-                                    os::native_thread_creation_failed_msg());\n-    }\n@@ -77,5 +63,2 @@\n-    java_lang_Thread::set_thread(thread_oop(), thread);\n-    java_lang_Thread::set_priority(thread_oop(), NearMaxPriority);\n-    java_lang_Thread::set_daemon(thread_oop());\n-    thread->set_threadObj(thread_oop());\n-    _instance = thread;\n+   NotificationThread* thread = new NotificationThread(&notification_thread_entry);\n+   JavaThread::vm_exit_on_osthread_failure(thread);\n@@ -83,3 +66,1 @@\n-    Threads::add(thread);\n-    Thread::start(thread);\n-  }\n+   JavaThread::start_internal_daemon(THREAD, thread, thread_oop, NearMaxPriority);\n@@ -131,1 +112,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/notificationThread.cpp","additions":3,"deletions":23,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,0 @@\n-  static NotificationThread* _instance;\n-\n","filename":"src\/hotspot\/share\/runtime\/notificationThread.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -488,15 +488,2 @@\n-    { MutexLocker mu(THREAD, Threads_lock);\n-      JavaThread* signal_thread = new JavaThread(&signal_thread_entry);\n-\n-      \/\/ At this point it may be possible that no osthread was created for the\n-      \/\/ JavaThread due to lack of memory. We would have to throw an exception\n-      \/\/ in that case. However, since this must work and we do not allow\n-      \/\/ exceptions anyway, check and abort if this fails.\n-      if (signal_thread == NULL || signal_thread->osthread() == NULL) {\n-        vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n-                                      os::native_thread_creation_failed_msg());\n-      }\n-\n-      java_lang_Thread::set_thread(thread_oop(), signal_thread);\n-      java_lang_Thread::set_priority(thread_oop(), NearMaxPriority);\n-      java_lang_Thread::set_daemon(thread_oop());\n+    JavaThread* thread = new JavaThread(&signal_thread_entry);\n+    JavaThread::vm_exit_on_osthread_failure(thread);\n@@ -504,4 +491,1 @@\n-      signal_thread->set_threadObj(thread_oop());\n-      Threads::add(signal_thread);\n-      Thread::start(signal_thread);\n-    }\n+    JavaThread::start_internal_daemon(THREAD, thread, thread_oop, NearMaxPriority);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":3,"deletions":19,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-ServiceThread* ServiceThread::_instance = NULL;\n+DEBUG_ONLY(JavaThread* ServiceThread::_instance = NULL;)\n@@ -106,12 +106,2 @@\n-  {\n-    MutexLocker mu(THREAD, Threads_lock);\n-    ServiceThread* thread =  new ServiceThread(&service_thread_entry);\n-\n-    \/\/ At this point it may be possible that no osthread was created for the\n-    \/\/ JavaThread due to lack of memory. We would have to throw an exception\n-    \/\/ in that case. However, since this must work and we do not allow\n-    \/\/ exceptions anyway, check and abort if this fails.\n-    if (thread == NULL || thread->osthread() == NULL) {\n-      vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n-                                    os::native_thread_creation_failed_msg());\n-    }\n+  ServiceThread* thread = new ServiceThread(&service_thread_entry);\n+  JavaThread::vm_exit_on_osthread_failure(thread);\n@@ -119,9 +109,2 @@\n-    java_lang_Thread::set_thread(thread_oop(), thread);\n-    java_lang_Thread::set_priority(thread_oop(), NearMaxPriority);\n-    java_lang_Thread::set_daemon(thread_oop());\n-    thread->set_threadObj(thread_oop());\n-    _instance = thread;\n-\n-    Threads::add(thread);\n-    Thread::start(thread);\n-  }\n+  JavaThread::start_internal_daemon(THREAD, thread, thread_oop, NearMaxPriority);\n+  DEBUG_ONLY(_instance = thread;)\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":5,"deletions":22,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-  static ServiceThread* _instance;\n+  DEBUG_ONLY(static JavaThread* _instance;)\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3994,0 +3994,41 @@\n+\n+\/\/ Starts the target JavaThread as a daemon of the given priority, and\n+\/\/ bound to the given java.lang.Thread instance.\n+\/\/ The Threads_lock is held for the duration.\n+void JavaThread::start_internal_daemon(JavaThread* current, JavaThread* target,\n+                                       Handle thread_oop, ThreadPriority prio) {\n+\n+  assert(target->osthread()!= NULL, \"target thread is not properly initialized\");\n+\n+  MutexLocker mu(current, Threads_lock);\n+\n+  \/\/ Initialize the fields of the thread_oop first.\n+\n+  java_lang_Thread::set_thread(thread_oop(), target); \/\/ isAlive == true now\n+\n+  if (prio != NoPriority) {\n+    java_lang_Thread::set_priority(thread_oop(), prio);\n+    \/\/ Note: we don't call os::set_priority here. Possibly we should,\n+    \/\/ else all threads should call it themselves when they first run.\n+  }\n+\n+  java_lang_Thread::set_daemon(thread_oop());\n+\n+  \/\/ Now bind the thread_oop to the target JavaThread.\n+  target->set_threadObj(thread_oop());\n+\n+  Threads::add(target); \/\/ target is now visible for safepoint\/handshake\n+  Thread::start(target);\n+}\n+\n+void JavaThread::vm_exit_on_osthread_failure(JavaThread* thread) {\n+  \/\/ At this point it may be possible that no osthread was created for the\n+  \/\/ JavaThread due to lack of resources. However, since this must work\n+  \/\/ for critical system threads just check and abort if this fails.\n+  if (thread->osthread() == nullptr) {\n+    \/\/ This isn't really an OOM condition, but historically this is what\n+    \/\/ we report.\n+    vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n+                                  os::native_thread_creation_failed_msg());\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-\n@@ -1622,0 +1621,9 @@\n+  \/\/ Helper function to start a VM-internal daemon thread.\n+  \/\/ E.g. ServiceThread, NotificationThread, CompilerThread etc.\n+  static void start_internal_daemon(JavaThread* current, JavaThread* target,\n+                                    Handle thread_oop, ThreadPriority prio);\n+\n+  \/\/ Helper function to do vm_exit_on_initialization for osthread\n+  \/\/ resource allocation failure.\n+  static void vm_exit_on_osthread_failure(JavaThread* thread);\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -492,2 +492,2 @@\n-  { MutexLocker mu(THREAD, Threads_lock);\n-    JavaThread* listener_thread = new JavaThread(&attach_listener_thread_entry);\n+  JavaThread* thread = new JavaThread(&attach_listener_thread_entry);\n+  JavaThread::vm_exit_on_osthread_failure(thread);\n@@ -495,13 +495,1 @@\n-    \/\/ Check that thread and osthread were created\n-    if (listener_thread == NULL || listener_thread->osthread() == NULL) {\n-      vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n-                                    os::native_thread_creation_failed_msg());\n-    }\n-\n-    java_lang_Thread::set_thread(thread_oop(), listener_thread);\n-    java_lang_Thread::set_daemon(thread_oop());\n-\n-    listener_thread->set_threadObj(thread_oop());\n-    Threads::add(listener_thread);\n-    Thread::start(listener_thread);\n-  }\n+  JavaThread::start_internal_daemon(THREAD, thread, thread_oop, NoPriority);\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"}]}