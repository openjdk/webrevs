{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.awt.Component;\n@@ -34,0 +33,2 @@\n+import java.util.Arrays;\n+import java.util.Collection;\n@@ -37,1 +38,0 @@\n-import javax.swing.BorderFactory;\n@@ -39,1 +39,1 @@\n-import javax.swing.BoxLayout;\n+import javax.swing.JComponent;\n@@ -44,0 +44,3 @@\n+import static javax.swing.BorderFactory.createEmptyBorder;\n+import static javax.swing.BorderFactory.createEtchedBorder;\n+\n@@ -46,1 +49,1 @@\n- * @bug 8279614\n+ * @bug 8279614 8294921\n@@ -51,1 +54,0 @@\n-\n@@ -54,1 +56,1 @@\n-    public static final Dimension SIZE = new Dimension(120, 20);\n+    private static final Dimension SIZE = new Dimension(125, 25);\n@@ -56,2 +58,5 @@\n-    public static Color highlight = Color.RED;\n-    public static Color shadow = Color.BLUE;\n+    private static final Color OUTER_COLOR = Color.BLACK;\n+    private static final Color INSIDE_COLOR = Color.WHITE;\n+    private static final Color HIGHLIGHT = Color.RED;\n+    private static final Color SHADOW = Color.BLUE;\n+    private static final Color TRANSPARENT_COLOR = new Color(0x00000000, true);\n@@ -69,2 +74,4 @@\n-        boolean showFrame = args.length > 0 && \"-show\".equals(args[0]);\n-        SwingUtilities.invokeAndWait(() -> testScaling(showFrame));\n+        Collection<String> params = Arrays.asList(args);\n+        final boolean showFrame = params.contains(\"-show\");\n+        final boolean saveImages = params.contains(\"-save\");\n+        SwingUtilities.invokeAndWait(() -> testScaling(showFrame, saveImages));\n@@ -73,2 +80,9 @@\n-    private static void testScaling(boolean show) {\n-        createGUI(show);\n+    private static void testScaling(boolean showFrame, boolean saveImages) {\n+        JComponent content = createUI();\n+        if (showFrame) {\n+            showFrame(content);\n+        }\n+\n+        paintToImages(content, saveImages);\n+        verifyBorderRendering(saveImages);\n+    }\n@@ -76,1 +90,4 @@\n-        for (int i = 0; i < scales.length; i++) {\n+    private static void verifyBorderRendering(final boolean saveImages) {\n+        String errorMessage = null;\n+        int errorCount = 0;\n+        for (int i = 0; i < images.size(); i++) {\n@@ -79,2 +96,2 @@\n-            System.out.println(\"Testing scaling: \" + scaling);\n-\n+            try {\n+                int thickness = (int) Math.floor(scaling);\n@@ -82,3 +99,1 @@\n-            \/\/ checking vertical border\n-            int x = SIZE.width \/ 2;\n-            checkVerticalBorder(x, img, scaling);\n+                checkVerticalBorders(SIZE.width \/ 2, thickness, img);\n@@ -86,19 +101,3 @@\n-            for (Point p : panelLocations) {\n-                int y = (int) (p.y * scaling) + SIZE.height \/ 2;\n-                checkHorizontalBorder(y, img, scaling);\n-            }\n-        }\n-    }\n-\n-    private static void checkHorizontalBorder(int y, BufferedImage img, double scaling) {\n-        int thickness = 0;\n-        boolean checkShadow = false;\n-        boolean checkHighlight = false;\n-        for (int x = 0; x < img.getWidth(); x++) {\n-            int color = img.getRGB(x, y);\n-            if (!checkHighlight && !checkShadow) {\n-                if (color == shadow.getRGB()) {\n-                    checkHighlight = true;\n-                    thickness++;\n-                } else if (color == highlight.getRGB()) {\n-                    throw new RuntimeException(\"Horizontal Border was clipped or overdrawn.\");\n+                for (Point p : panelLocations) {\n+                    int y = (int) (p.y * scaling) + SIZE.height \/ 2;\n+                    checkHorizontalBorder(y, thickness, img);\n@@ -106,10 +105,3 @@\n-            } else if (checkHighlight) {\n-                if (color == shadow.getRGB()) {\n-                    thickness++;\n-                } else if (color == highlight.getRGB()) {\n-                    verifyThickness(x, y, thickness, scaling, \"Horizontal\");\n-                    checkHighlight = false;\n-                    checkShadow = true;\n-                    thickness = 1;\n-                } else {\n-                    throw new RuntimeException(\"Horizontal Border has empty space between highlight and shadow.\");\n+            } catch (Error e) {\n+                if (errorMessage == null) {\n+                    errorMessage = e.getMessage();\n@@ -117,9 +109,8 @@\n-            } else {\n-                if (color == shadow.getRGB()) {\n-                    throw new RuntimeException(\"Border colors reversed.\");\n-                } else if (color == highlight.getRGB()) {\n-                    thickness++;\n-                } else {\n-                    verifyThickness(x, y, thickness, scaling, \"Horizontal\");\n-                    checkShadow = false;\n-                    thickness = 0;\n+                errorCount++;\n+\n+                System.err.printf(\"Scaling: %.2f\\n\", scaling);\n+                e.printStackTrace();\n+\n+                \/\/ Save the image if it wasn't already saved\n+                if (!saveImages) {\n+                    saveImage(img, getImageFileName(scaling));\n@@ -129,1 +120,0 @@\n-    }\n@@ -131,5 +121,4 @@\n-    private static void verifyThickness(int x, int y, int thickness, double scaling, String orientation) {\n-        int expected = (int) Math.floor(scaling);\n-        if (thickness != expected) {\n-            throw new RuntimeException(\"Unexpected \" + orientation + \" Border thickness at x:\"\n-                                       + x + \" y: \" + y + \". Expected: \" + expected + \" Actual: \" + thickness);\n+        if (errorCount > 0) {\n+            throw new Error(\"Test failed: \"\n+                            + errorCount + \" error(s) detected - \"\n+                            + errorMessage);\n@@ -139,33 +128,113 @@\n-    private static void checkVerticalBorder(int x, BufferedImage img, double scaling) {\n-        int thickness = 0;\n-        boolean checkShadow = false;\n-        boolean checkHighlight = false;\n-        for (int y = 0; y < img.getHeight(); y++) {\n-            int color = img.getRGB(x, y);\n-            if (!checkHighlight && !checkShadow) {\n-                if (color == shadow.getRGB()) {\n-                    checkHighlight = true;\n-                    thickness++;\n-                } else if (color == highlight.getRGB()) {\n-                    throw new RuntimeException(\"Vertical Border was clipped or overdrawn.\");\n-                }\n-            } else if (checkHighlight) {\n-                if (color == shadow.getRGB()) {\n-                    thickness++;\n-                } else if (color == highlight.getRGB()) {\n-                    verifyThickness(x, y, thickness, scaling, \"Vertical\");\n-                    checkHighlight = false;\n-                    checkShadow = true;\n-                    thickness = 1;\n-                } else {\n-                    throw new RuntimeException(\"Vertical Border has empty space between highlight and shadow.\");\n-                }\n-            } else {\n-                if (color == shadow.getRGB()) {\n-                    throw new RuntimeException(\"Border colors reversed.\");\n-                } else if (color == highlight.getRGB()) {\n-                    thickness++;\n-                } else {\n-                    verifyThickness(x, y, thickness, scaling, \"Vertical\");\n-                    checkShadow = false;\n-                    thickness = 0;\n+    private static void checkVerticalBorders(final int x,\n+                                             final int thickness,\n+                                             final BufferedImage img) {\n+        checkBorder(x, 0,\n+                    0, 1,\n+                    thickness, img);\n+    }\n+\n+    private static void checkHorizontalBorder(final int y,\n+                                              final int thickness,\n+                                              final BufferedImage img) {\n+        checkBorder(0, y,\n+                    1, 0,\n+                    thickness, img);\n+    }\n+\n+    private enum State {\n+        BACKGROUND,\n+        LEFT_SHADOW, LEFT_HIGHLIGHT,\n+        INSIDE,\n+        RIGHT_SHADOW, RIGHT_HIGHLIGHT\n+    }\n+\n+    private static void checkBorder(final int xStart, final int yStart,\n+                                    final int xStep,  final int yStep,\n+                                    final int thickness,\n+                                    final BufferedImage img) {\n+        final int width = img.getWidth();\n+        final int height = img.getHeight();\n+\n+        State state = State.BACKGROUND;\n+        int borderThickness = 0;\n+\n+        int x = xStart;\n+        int y = yStart;\n+        do {\n+            do {\n+                final int color = img.getRGB(x, y);\n+                switch (state) {\n+                    case BACKGROUND:\n+                        if (color == SHADOW.getRGB()) {\n+                            state = State.LEFT_SHADOW;\n+                            borderThickness = 1;\n+                        } else if (color != OUTER_COLOR.getRGB()\n+                                   && color != TRANSPARENT_COLOR.getRGB()) {\n+                            throwUnexpectedColor(x, y, color);\n+                        }\n+                        break;\n+\n+                    case LEFT_SHADOW:\n+                        if (color == SHADOW.getRGB()) {\n+                            borderThickness++;\n+                        } else if (color == HIGHLIGHT.getRGB()) {\n+                            if (borderThickness != thickness) {\n+                                throwWrongThickness(thickness, borderThickness, x, y);\n+                            }\n+                            borderThickness = 1;\n+                            state = State.LEFT_HIGHLIGHT;\n+                        } else {\n+                            throwUnexpectedColor(x, y, color);\n+                        }\n+                        break;\n+\n+                    case LEFT_HIGHLIGHT:\n+                        if (color == HIGHLIGHT.getRGB()) {\n+                            borderThickness++;\n+                        } else if (color == INSIDE_COLOR.getRGB()) {\n+                            if (borderThickness != thickness) {\n+                                throwWrongThickness(thickness, borderThickness, x, y);\n+                            }\n+                            borderThickness = 0;\n+                            state = State.INSIDE;\n+                        } else {\n+                            throwUnexpectedColor(x, y, color);\n+                        }\n+                        break;\n+\n+                    case INSIDE:\n+                        if (color == SHADOW.getRGB()) {\n+                            state = State.RIGHT_SHADOW;\n+                            borderThickness = 1;\n+                        } else if (color != INSIDE_COLOR.getRGB()) {\n+                            throwUnexpectedColor(x, y, color);\n+                        }\n+                        break;\n+\n+                    case RIGHT_SHADOW:\n+                        if (color == SHADOW.getRGB()) {\n+                            borderThickness++;\n+                        } else if (color == HIGHLIGHT.getRGB()) {\n+                            if (borderThickness != thickness) {\n+                                throwWrongThickness(thickness, borderThickness, x, y);\n+                            }\n+                            borderThickness = 1;\n+                            state = State.RIGHT_HIGHLIGHT;\n+                        } else {\n+                            throwUnexpectedColor(x, y, color);\n+                        }\n+                        break;\n+\n+                    case RIGHT_HIGHLIGHT:\n+                        if (color == HIGHLIGHT.getRGB()) {\n+                            borderThickness++;\n+                        } else if (color == OUTER_COLOR.getRGB()) {\n+                            if (borderThickness != thickness) {\n+                                throwWrongThickness(thickness, borderThickness, x, y);\n+                            }\n+                            borderThickness = 0;\n+                            state = State.BACKGROUND;\n+                        } else {\n+                            throwUnexpectedColor(x, y, color);\n+                        }\n+                        break;\n@@ -173,2 +242,9 @@\n-            }\n-        }\n+            } while (yStep > 0 && ((y += yStep) < height));\n+        } while (xStep > 0 && ((x += xStep) < width));\n+    }\n+\n+    private static void throwWrongThickness(int thickness, int borderThickness,\n+                                            int x, int y) {\n+        throw new Error(\n+                String.format(\"Wrong border thickness at %d, %d: %d vs %d\",\n+                              x, y, borderThickness, thickness));\n@@ -177,4 +253,9 @@\n-    private static void createGUI(boolean show) {\n-        \/\/ Render content panel\n-        JPanel contentPanel = new JPanel();\n-        contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));\n+    private static void throwUnexpectedColor(int x, int y, int color) {\n+        throw new Error(\n+                String.format(\"Unexpected color at %d, %d: %08x\",\n+                              x, y, color));\n+    }\n+\n+    private static JComponent createUI() {\n+        Box contentPanel = Box.createVerticalBox();\n+        contentPanel.setBackground(OUTER_COLOR);\n@@ -184,0 +265,6 @@\n+            JComponent filler = new JPanel(null);\n+            filler.setBackground(INSIDE_COLOR);\n+            filler.setPreferredSize(SIZE);\n+            filler.setBounds(i, 0, SIZE.width, SIZE.height);\n+            filler.setBorder(createEtchedBorder(HIGHLIGHT, SHADOW));\n+\n@@ -185,4 +272,3 @@\n-            childPanel.setBorder(BorderFactory.createCompoundBorder(\n-                    BorderFactory.createEmptyBorder(0, i, 4, 4),\n-                    BorderFactory.createEtchedBorder(highlight, shadow)));\n-            childPanel.add(Box.createRigidArea(SIZE), BorderLayout.CENTER);\n+            childPanel.setBorder(createEmptyBorder(0, i, 4, 4));\n+            childPanel.add(filler, BorderLayout.CENTER);\n+            childPanel.setBackground(OUTER_COLOR);\n@@ -194,1 +280,4 @@\n-            childPanel.setBounds(0, childSize.height * i, childSize.width, childSize.height);\n+            childPanel.setBounds(0, childSize.height * i,\n+                                 childSize.width, childSize.height);\n+\n+            panelLocations.add(childPanel.getLocation());\n@@ -199,0 +288,14 @@\n+        return contentPanel;\n+    }\n+\n+    private static void showFrame(final JComponent content) {\n+        JFrame frame = new JFrame(\"Scaled Etched Border Test\");\n+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        frame.getContentPane().add(content, BorderLayout.CENTER);\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    private static void paintToImages(final JComponent content,\n+                                      final boolean saveImages) {\n@@ -200,17 +303,9 @@\n-            \/\/ Create BufferedImage\n-            BufferedImage buff = new BufferedImage((int) Math.ceil(contentPanel.getWidth() * scaling),\n-                    (int) Math.ceil(contentPanel.getHeight() * scaling),\n-                    BufferedImage.TYPE_INT_ARGB);\n-            Graphics2D graph = buff.createGraphics();\n-            graph.scale(scaling, scaling);\n-            \/\/ Painting panel onto BufferedImage\n-            contentPanel.paint(graph);\n-            graph.dispose();\n-            \/\/ Save each image ? -- Here it's useful for debugging\n-            saveImage(buff, String.format(\"test%.2f.png\", scaling));\n-            images.add(buff);\n-        }\n-        \/\/ Save coordinates of the panels\n-        for (Component comp : contentPanel.getComponents()) {\n-            panelLocations.add(comp.getLocation());\n-        }\n+            BufferedImage image =\n+                    new BufferedImage((int) Math.ceil(content.getWidth() * scaling),\n+                                      (int) Math.ceil(content.getHeight() * scaling),\n+                                      BufferedImage.TYPE_INT_ARGB);\n+\n+            Graphics2D g2d = image.createGraphics();\n+            g2d.scale(scaling, scaling);\n+            content.paint(g2d);\n+            g2d.dispose();\n@@ -218,7 +313,4 @@\n-        if (show) {\n-            JFrame frame = new JFrame(\"Swing Test\");\n-            frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n-            frame.getContentPane().add(contentPanel, BorderLayout.CENTER);\n-            frame.pack();\n-            frame.setLocationRelativeTo(null);\n-            frame.setVisible(true);\n+            if (saveImages) {\n+                saveImage(image, getImageFileName(scaling));\n+            }\n+            images.add(image);\n@@ -228,0 +320,4 @@\n+    private static String getImageFileName(final double scaling) {\n+        return String.format(\"test%.2f.png\", scaling);\n+    }\n+\n","filename":"test\/jdk\/javax\/swing\/border\/EtchedBorder\/ScaledEtchedBorderTest.java","additions":227,"deletions":131,"binary":false,"changes":358,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.awt.Component;\n@@ -141,0 +140,4 @@\n+    private enum State {\n+        BACKGROUND, LEFT, INSIDE, RIGHT\n+    }\n+\n@@ -207,4 +210,0 @@\n-    private enum State {\n-        BACKGROUND, LEFT, INSIDE, RIGHT\n-    }\n-\n@@ -246,0 +245,2 @@\n+\n+            panelLocations.add(childPanel.getLocation());\n@@ -250,5 +251,0 @@\n-        \/\/ Save coordinates of the panels\n-        for (Component comp : contentPanel.getComponents()) {\n-            panelLocations.add(comp.getLocation());\n-        }\n-\n","filename":"test\/jdk\/javax\/swing\/border\/LineBorder\/ScaledLineBorderTest.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.awt.Component;\n","filename":"test\/jdk\/javax\/swing\/border\/LineBorder\/ScaledTextFieldBorderTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}