{"files":[{"patch":"@@ -81,0 +81,6 @@\n+\/\/ Parses a subsystem's file, looking for a matching line.\n+\/\/ If key is null, then the first line will be matched with scan_fmt.\n+\/\/ If key isn't null, then each line will be matched, looking for something that matches \"$key $scan_fmt\".\n+\/\/ The matching value will be assigned to returnval.\n+\/\/ scan_fmt uses scanf() syntax.\n+\/\/ Return value: 0 on match, OSCONTAINER_ERROR on error.\n@@ -83,1 +89,1 @@\n-                                              const char *matchline,\n+                                              const char *key,\n@@ -86,6 +92,12 @@\n-  FILE *fp = NULL;\n-  char *p;\n-  char file[MAXPATHLEN+1];\n-  char buf[MAXPATHLEN+1];\n-  char discard[MAXPATHLEN+1];\n-  bool found_match = false;\n+  if (c == nullptr) {\n+    log_debug(os, container)(\"subsystem_file_line_contents: CgroupController* is nullptr\");\n+    return OSCONTAINER_ERROR;\n+  }\n+  if (c->subsystem_path() == nullptr) {\n+    log_debug(os, container)(\"subsystem_file_line_contents: subsystem path is nullptr\");\n+    return OSCONTAINER_ERROR;\n+  }\n+\n+  stringStream file_path;\n+  file_path.print_raw(c->subsystem_path());\n+  file_path.print_raw(filename);\n@@ -93,2 +105,2 @@\n-  if (c == NULL) {\n-    log_debug(os, container)(\"subsystem_file_line_contents: CgroupController* is NULL\");\n+  if (file_path.size() > (MAXPATHLEN-1)) {\n+    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n@@ -97,2 +109,6 @@\n-  if (c->subsystem_path() == NULL) {\n-    log_debug(os, container)(\"subsystem_file_line_contents: subsystem path is NULL\");\n+  const char* absolute_path = file_path.freeze();\n+  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n+\n+  FILE* fp = fopen(absolute_path, \"r\");\n+  if (fp == nullptr) {\n+    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n@@ -102,5 +118,6 @@\n-  strncpy(file, c->subsystem_path(), MAXPATHLEN);\n-  file[MAXPATHLEN-1] = '\\0';\n-  int filelen = strlen(file);\n-  if ((filelen + strlen(filename)) > (MAXPATHLEN-1)) {\n-    log_debug(os, container)(\"File path too long %s, %s\", file, filename);\n+  const int buf_len = MAXPATHLEN+1;\n+  char buf[buf_len];\n+  char* line = fgets(buf, buf_len, fp);\n+  if (line == nullptr) {\n+    log_debug(os, container)(\"Empty file %s\", absolute_path);\n+    fclose(fp);\n@@ -109,19 +126,22 @@\n-  strncat(file, filename, MAXPATHLEN-filelen);\n-  log_trace(os, container)(\"Path to %s is %s\", filename, file);\n-  fp = fopen(file, \"r\");\n-  if (fp != NULL) {\n-    int err = 0;\n-    while ((p = fgets(buf, MAXPATHLEN, fp)) != NULL) {\n-      found_match = false;\n-      if (matchline == NULL) {\n-        \/\/ single-line file case\n-        int matched = sscanf(p, scan_fmt, returnval);\n-        found_match = (matched == 1);\n-      } else {\n-        \/\/ multi-line file case\n-        if (strstr(p, matchline) != NULL) {\n-          \/\/ discard matchline string prefix\n-          int matched = sscanf(p, scan_fmt, discard, returnval);\n-          found_match = (matched == 2);\n-        } else {\n-          continue; \/\/ substring not found\n+\n+  bool found_match = false;\n+  if (key == nullptr) {\n+    \/\/ File consists of a single line according to caller, with only a value\n+    int matched = sscanf(line, scan_fmt, returnval);\n+    found_match = matched == 1;\n+  } else {\n+    \/\/ File consists of multiple lines in a \"key value\"\n+    \/\/ fashion, we have to find the key.\n+    const int key_len = strlen(key);\n+    for (; line != nullptr; line = fgets(buf, buf_len, fp)) {\n+      char* key_substr = strstr(line, key);\n+      char after_key = line[key_len];\n+      if (key_substr == line\n+          && isspace(after_key) != 0\n+          && after_key != '\\n') {\n+        \/\/ Skip key, skip space\n+        const char* value_substr = line + key_len + 1;\n+        int matched = sscanf(value_substr, scan_fmt, returnval);\n+        found_match = matched == 1;\n+        if (found_match) {\n+          break;\n@@ -130,7 +150,0 @@\n-      if (found_match) {\n-        fclose(fp);\n-        return 0;\n-      } else {\n-        err = 1;\n-        log_debug(os, container)(\"Type %s not found in file %s\", scan_fmt, file);\n-      }\n@@ -138,5 +151,0 @@\n-    if (err == 0) {\n-      log_debug(os, container)(\"Empty file %s\", file);\n-    }\n-  } else {\n-    log_debug(os, container)(\"Open of file %s failed, %s\", file, os::strerror(errno));\n@@ -144,2 +152,6 @@\n-  if (fp != NULL)\n-    fclose(fp);\n+  fclose(fp);\n+  if (found_match) {\n+    return 0;\n+  }\n+  log_debug(os, container)(\"Type %s (key == %s) not found in file %s\", scan_fmt,\n+                           (key == nullptr ? \"null\" : key), absolute_path);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":61,"deletions":49,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -99,4 +99,2 @@\n-      const char* matchline = \"hierarchical_memory_limit\";\n-      const char* format = \"%s \" JULONG_FORMAT;\n-      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", matchline,\n-                             \"Hierarchical Memory Limit is: \" JULONG_FORMAT, format, hier_memlimit)\n+      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", \"hierarchical_memory_limit\",\n+                             \"Hierarchical Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, hier_memlimit)\n@@ -126,1 +124,0 @@\n-      const char* format = \"%s \" JULONG_FORMAT;\n@@ -128,1 +125,1 @@\n-                             \"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, format, hier_memswlimit)\n+                             \"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, JULONG_FORMAT, hier_memswlimit)\n@@ -136,1 +133,1 @@\n-                             \"Hierarchical Memory Limit is : \" JULONG_FORMAT, format, hier_memlimit)\n+                             \"Hierarchical Memory Limit is : \" JULONG_FORMAT, JULONG_FORMAT, hier_memlimit)\n@@ -289,1 +286,1 @@\n-                     \"Maximum number of tasks is: %s\", \"%s %*d\", pidsmax, 1024);\n+                     \"Maximum number of tasks is: %s\", \"%1023s\", pidsmax, 1024);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-                     \"Maximum number of tasks is: %s\", \"%1023s %*d\", pidsmax, 1024);\n+                     \"Maximum number of tasks is: %s\", \"%1023s\", pidsmax, 1024);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -357,0 +357,1 @@\n+  assert(_is_frozen == false, \"Modification forbidden\");\n@@ -396,0 +397,1 @@\n+  assert(_is_frozen == false, \"Modification forbidden\");\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -194,0 +195,1 @@\n+  DEBUG_ONLY(bool _is_frozen = false);\n@@ -218,0 +220,2 @@\n+  \/\/ Returns internal buffer containing the accumulated string.\n+  \/\/ Returned buffer is only guaranteed to be valid as long as stream is not modified\n@@ -219,0 +223,7 @@\n+  \/\/ Freezes stringStream (no further modifications possible) and returns pointer to it.\n+  \/\/ No-op if stream is frozen already.\n+  \/\/ Returns the internal buffer containing the accumulated string.\n+  const char* freeze() NOT_DEBUG(const) {\n+    DEBUG_ONLY(_is_frozen = true);\n+    return _buffer;\n+  };\n@@ -220,1 +231,1 @@\n-  \/\/ copy to a resource, or C-heap, array as requested\n+  \/\/ Copy to a resource, or C-heap, array as requested\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef LINUX\n+\n+#include \"runtime\/os.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#include <stdio.h>\n+\n+\n+\/\/ Utilities\n+bool file_exists(const char* filename) {\n+  struct stat st;\n+  return os::stat(filename, &st) == 0;\n+}\n+\n+char* temp_file(const char* prefix) {\n+  const testing::TestInfo* test_info = ::testing::UnitTest::GetInstance()->current_test_info();\n+  stringStream path;\n+  path.print_raw(os::get_temp_directory());\n+  path.print_raw(os::file_separator());\n+  path.print(\"%s-test-jdk.pid%d.%s.%s\", prefix, os::current_process_id(),\n+             test_info->test_case_name(), test_info->name());\n+  return path.as_string(true);\n+}\n+\n+void delete_file(const char* filename) {\n+  if (!file_exists(filename)) {\n+    return;\n+  }\n+  int ret = remove(filename);\n+  EXPECT_TRUE(ret == 0 || errno == ENOENT) << \"failed to remove file '\" << filename << \"': \"\n+      << os::strerror(errno) << \" (\" << errno << \")\";\n+}\n+\n+class TestController : public CgroupController {\n+public:\n+  char* subsystem_path() override {\n+    \/\/ The real subsystem is in \/tmp\/, generaed by temp_file()\n+    return (char*)\"\/\";\n+  };\n+};\n+\n+void fill_file(const char* path, const char* content) {\n+  delete_file(path);\n+  FILE* fp = os::fopen(path, \"w\");\n+  if (fp == nullptr) {\n+    return;\n+  }\n+  if (content != nullptr) {\n+    fprintf(fp, \"%s\", content);\n+  }\n+  fclose(fp);\n+}\n+\n+TEST(cgroupTest, SubSystemFileLineContentsMultipleLinesErrorCases) {\n+  TestController my_controller{};\n+  const char* test_file = temp_file(\"cgroups\");\n+  int x = 0;\n+  char s[1024];\n+  int err = 0;\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"foo \");\n+  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  EXPECT_NE(err, 0) << \"Value must not be missing in key\/value case\";\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"faulty_start foo bar\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  EXPECT_NE(err, 0) << \"Key must be at start\";\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"foof bar\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  EXPECT_NE(err, 0) << \"Key must be exact match\";\n+}\n+\n+TEST(cgroupTest, SubSystemFileLineContentsMultipleLinesSuccessCases) {\n+  TestController my_controller{};\n+  const char* test_file = temp_file(\"cgroups\");\n+  int x = 0;\n+  char s[1024];\n+  int err = 0;\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"foo bar\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"bar\") << \"Incorrect!\";\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"foo\\tbar\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"bar\") << \"Incorrect!\";\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"foof bar\\nfoo car\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"car\");\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"foo\\ttest\\nfoot car\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"test\");\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"foo 1\\nfoo car\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"1\");\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"max 10000\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s %*d\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"max\");\n+\n+  x = -3;\n+  fill_file(test_file, \"max 10001\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%*s %d\", &x);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_EQ(x, 10001);\n+}\n+\n+TEST(cgroupTest, SubSystemFileLineContentsSingleLine) {\n+  TestController my_controller{};\n+  const char* test_file = temp_file(\"cgroups\");\n+  int x = 0;\n+  char s[1024];\n+  int err = 0;\n+\n+  fill_file(test_file, \"foo\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"foo\");\n+\n+  fill_file(test_file, \"1337\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%d\", &x);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_EQ(x, 1337) << \"Wrong value for x\";\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"1337\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"1337\");\n+\n+  x = -1;\n+  fill_file(test_file, nullptr);\n+  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%d\", &x);\n+  EXPECT_NE(err, 0) << \"Empty file should've failed\";\n+  EXPECT_EQ(x, -1) << \"x was altered\";\n+\n+  jlong y;\n+  fill_file(test_file, \"1337\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, JLONG_FORMAT, &y);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_EQ(y, 1337) << \"Wrong value for y\";\n+  julong z;\n+  fill_file(test_file, \"1337\");\n+  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, JULONG_FORMAT, &z);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_EQ(z, (julong)1337) << \"Wrong value for z\";\n+}\n+\n+#endif \/\/ LINUX\n","filename":"test\/hotspot\/gtest\/os\/linux\/test_cgroupSubsystem_linux.cpp","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -39,1 +39,1 @@\n-TEST(os_linux_cgroup, set_cgroupv1_subsystem_path) {\n+TEST(cgroupTest, set_cgroupv1_subsystem_path) {\n@@ -63,1 +63,1 @@\n-TEST(os_linux_cgroup, set_cgroupv2_subsystem_path) {\n+TEST(cgroupTest, set_cgroupv2_subsystem_path) {\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux_cgroups.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}