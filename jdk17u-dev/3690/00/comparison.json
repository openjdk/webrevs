{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -212,1 +212,1 @@\n-        protected void onSubscribed() {\n+        protected void register() {\n@@ -217,13 +217,1 @@\n-        protected void complete(Throwable t) {\n-            try {\n-                exchange.unregisterResponseSubscriber(this);\n-            } finally {\n-                super.complete(t);\n-            }\n-        }\n-\n-        @Override\n-        protected void onCancel() {\n-            \/\/ If the subscription is cancelled the\n-            \/\/ subscriber may or may not get completed.\n-            \/\/ Therefore we need to unregister it\n+        protected void unregister() {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Exchange.java","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1695,1 +1695,1 @@\n-        protected void onSubscribed() {\n+        protected void register() {\n@@ -1700,10 +1700,1 @@\n-        protected void complete(Throwable t) {\n-            try {\n-                unregisterResponseSubscriber(this);\n-            } finally {\n-                super.complete(t);\n-            }\n-        }\n-\n-        @Override\n-        protected void onCancel() {\n+        protected void unregister() {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,6 @@\n+    static final int SUBSCRIBED = 1;\n+    static final int REGISTERED = 2;\n+    static final int COMPLETED = 4;\n+    static final int CANCELLED = 8;\n+    static final int UNREGISTERED = 16;\n+\n@@ -64,2 +70,1 @@\n-    final AtomicBoolean completed = new AtomicBoolean();\n-    final AtomicBoolean subscribed = new AtomicBoolean();\n+    private volatile int state;\n@@ -86,2 +91,7 @@\n-                subscription.cancel();\n-                onCancel();\n+                try {\n+                    subscription.cancel();\n+                } finally {\n+                    if (markCancelled()) {\n+                        onCancel();\n+                    }\n+                }\n@@ -94,0 +104,36 @@\n+    private final boolean markState(final int flag) {\n+        int state = this.state;\n+        if ((state & flag) == flag) {\n+            return false;\n+        }\n+        synchronized (this) {\n+            state = this.state;\n+            if ((state & flag) == flag) {\n+                return false;\n+            }\n+            state = this.state = (state | flag);\n+        }\n+        assert (state & flag) == flag;\n+        return true;\n+    }\n+\n+    private boolean markSubscribed() {\n+        return markState(SUBSCRIBED);\n+    }\n+\n+    private boolean markCancelled() {\n+        return markState(CANCELLED);\n+    }\n+\n+    private boolean markCompleted() {\n+        return markState(COMPLETED);\n+    }\n+\n+    private boolean markRegistered() {\n+        return markState(REGISTERED);\n+    }\n+\n+    private boolean markUnregistered() {\n+        return markState(UNREGISTERED);\n+    }\n+\n@@ -104,0 +150,1 @@\n+        var state = this.state;\n@@ -105,1 +152,1 @@\n-        assert completed.get();\n+        assert (state & COMPLETED) != 0;\n@@ -114,1 +161,1 @@\n-                if (subscribed.compareAndSet(false, true)) {\n+                if (markSubscribed()) {\n@@ -128,0 +175,87 @@\n+    \/**\n+     * This method attempts to mark the state of this\n+     * object as registered, and then call the\n+     * {@link #register()} method.\n+     * <p>\n+     * The state will be marked as registered, and the\n+     * {@code register()} method will be called only\n+     * if not already registered or unregistered,\n+     * or cancelled, or completed.\n+     *\n+     * @return {@code true} if {@link #register()} was called,\n+     * false otherwise.\n+     *\/\n+    protected final boolean tryRegister() {\n+        subscriptionLock.lock();\n+        try {\n+            int state = this.state;\n+            if ((state & (REGISTERED | UNREGISTERED | CANCELLED | COMPLETED)) != 0) return false;\n+            if (markRegistered()) {\n+                register();\n+                return true;\n+            }\n+        } finally {\n+            subscriptionLock.unlock();\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * This method attempts to mark the state of this\n+     * object as unregistered, and then call the\n+     * {@link #unregister()} method.\n+     * <p>\n+     * The {@code unregister()} method will be called only\n+     * if already registered and not yet unregistered.\n+     * Whether {@code unregister()} is called or not,\n+     * the state is marked as unregistered, to prevent\n+     * {@link #tryRegister()} from calling {@link #register()}\n+     * after {@link #tryUnregister()} has been called.\n+     *\n+     * @return {@code true} if {@link #unregister()} was called,\n+     * false otherwise.\n+     *\/\n+    protected final boolean tryUnregister() {\n+        subscriptionLock.lock();\n+        try {\n+            int state = this.state;\n+            if ((state & REGISTERED) == 0) {\n+                markUnregistered();\n+                return false;\n+            }\n+            if (markUnregistered()) {\n+                unregister();\n+                return true;\n+            }\n+        } finally {\n+            subscriptionLock.unlock();\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * This method can be implemented by subclasses\n+     * to perform registration actions. It will not be\n+     * called if already registered or unregistered.\n+     * @apiNote\n+     * This method is called while holding a subscription\n+     * lock.\n+     * @see #tryRegister()\n+     *\/\n+    protected void register() {\n+        assert subscriptionLock.isHeldByCurrentThread();\n+    }\n+\n+    \/**\n+     * This method can be implemented by subclasses\n+     * to perform unregistration actions. It will not be\n+     * called if not already registered, or already unregistered.\n+     * @apiNote\n+     * This method is called while holding a subscription\n+     * lock.\n+     * @see #tryUnregister()\n+     *\/\n+    protected void unregister() {\n+        assert subscriptionLock.isHeldByCurrentThread();\n+    }\n+\n@@ -133,0 +267,2 @@\n+     * @implSpec\n+     * This method calls {@link #tryUnregister()}\n@@ -134,1 +270,6 @@\n-    protected void onCancel() { }\n+    protected void onCancel() {\n+        \/\/ If the subscription is cancelled the\n+        \/\/ subscriber may or may not get completed.\n+        \/\/ Therefore we need to unregister it\n+        tryUnregister();\n+    }\n@@ -140,1 +281,1 @@\n-     * related actions after a subscription has been succesfully\n+     * related actions after a subscription has been successfully\n@@ -142,0 +283,4 @@\n+     * This method is called while holding a subscription\n+     * lock.\n+     * @implSpec\n+     * This method calls {@link #tryRegister()}\n@@ -143,1 +288,3 @@\n-    protected void onSubscribed() { }\n+    protected void onSubscribed() {\n+        tryRegister();\n+    }\n@@ -149,0 +296,3 @@\n+     * @implSpec\n+     * If not {@linkplain #completed()} yet, this method\n+     * calls {@link #tryUnregister()}\n@@ -150,2 +300,3 @@\n-    protected void complete(Throwable t) {\n-        if (completed.compareAndSet(false, true)) {\n+    public final void complete(Throwable t) {\n+        if (markCompleted()) {\n+            tryUnregister();\n@@ -155,1 +306,2 @@\n-                    assert subscribed.get();\n+                    var state = this.state;\n+                    assert (state & SUBSCRIBED) != 0;\n@@ -182,2 +334,3 @@\n-    public boolean completed() {\n-        return completed.get();\n+    public final boolean completed() {\n+        int state = this.state;\n+        return (state & COMPLETED) != 0;\n@@ -186,0 +339,34 @@\n+    \/**\n+     * {@return true if this subscriber has already subscribed}\n+     *\/\n+    public final boolean subscribed() {\n+        int state = this.state;\n+        return (state & SUBSCRIBED) != 0;\n+    }\n+\n+    \/**\n+     * {@return true if this subscriber has already been registered}\n+     *\/\n+    public final boolean registered() {\n+        int state = this.state;\n+        return (state & REGISTERED) != 0;\n+    }\n+\n+    \/**\n+     * {@return true if this subscriber has already been unregistered}\n+     *\/\n+    public final boolean unregistered() {\n+        int state = this.state;\n+        return (state & UNREGISTERED) != 0;\n+    }\n+\n+    \/**\n+     * {@return true if this subscriber's subscription has already\n+     * been cancelled}\n+     *\/\n+    public final boolean cancelled() {\n+        int state = this.state;\n+        return (state & CANCELLED) != 0;\n+    }\n+\n+\n@@ -197,1 +384,1 @@\n-            if (subscribed.compareAndSet(false, true)) {\n+            if (markSubscribed()) {\n@@ -211,2 +398,3 @@\n-        assert subscribed.get();\n-        if (completed.get()) {\n+        var state = this.state;\n+        assert (state & SUBSCRIBED) != 0;\n+        if ((state & COMPLETED) != 0) {\n@@ -225,0 +413,1 @@\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/HttpBodySubscriberWrapper.java","additions":207,"deletions":18,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8245462 8229822 8254786 8297075 8297149 8298340\n+ * @bug 8245462 8229822 8254786 8297075 8297149 8298340 8302635\n","filename":"test\/jdk\/java\/net\/httpclient\/CancelRequestTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}