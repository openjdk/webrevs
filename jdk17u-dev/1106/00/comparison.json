{"files":[{"patch":"@@ -422,0 +422,1 @@\n+  if (_chunk == NULL) return false;\n@@ -425,1 +426,0 @@\n-    if (_chunk == NULL) return false;\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  _caller_jvms(caller_jvms),\n+  _caller_jvms(NULL),\n@@ -58,1 +58,1 @@\n-  if (_caller_jvms != NULL) {\n+  if (caller_jvms != NULL) {\n@@ -63,0 +63,1 @@\n+    assert(_caller_jvms->same_calls_as(caller_jvms), \"consistent JVMS\");\n@@ -64,1 +65,0 @@\n-  assert(_caller_jvms->same_calls_as(caller_jvms), \"consistent JVMS\");\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -733,2 +733,2 @@\n-  int elide_copy( Node *n, int k, Block *current_block, Node_List &value, Node_List &regnd, bool can_change_regs );\n-  int use_prior_register( Node *copy, uint idx, Node *def, Block *current_block, Node_List &value, Node_List &regnd );\n+  int elide_copy( Node *n, int k, Block *current_block, Node_List *value, Node_List *regnd, bool can_change_regs );\n+  int use_prior_register( Node *copy, uint idx, Node *def, Block *current_block, Node_List *value, Node_List *regnd );\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-                                    Node_List& value) {\n+                                    const Node_List &value) {\n@@ -80,1 +80,1 @@\n-int PhaseChaitin::yank( Node *old, Block *current_block, Node_List *value, Node_List *regnd ) {\n+int PhaseChaitin::yank(Node *old, Block *current_block, Node_List *value, Node_List *regnd) {\n@@ -90,3 +90,4 @@\n-  if( regnd && (*regnd)[old_reg]==old ) { \/\/ Instruction is currently available?\n-    value->map(old_reg,NULL);  \/\/ Yank from value\/regnd maps\n-    regnd->map(old_reg,NULL);  \/\/ This register's value is now unknown\n+  assert(value != NULL || regnd == NULL, \"sanity\");\n+  if (value != NULL && regnd != NULL && regnd->at(old_reg) == old) { \/\/ Instruction is currently available?\n+    value->map(old_reg, NULL); \/\/ Yank from value\/regnd maps\n+    regnd->map(old_reg, NULL); \/\/ This register's value is now unknown\n@@ -164,1 +165,1 @@\n-int PhaseChaitin::use_prior_register( Node *n, uint idx, Node *def, Block *current_block, Node_List &value, Node_List &regnd ) {\n+int PhaseChaitin::use_prior_register( Node *n, uint idx, Node *def, Block *current_block, Node_List *value, Node_List *regnd ) {\n@@ -210,1 +211,1 @@\n-  return yank_if_dead(old,current_block,&value,&regnd);\n+  return yank_if_dead(old,current_block,value,regnd);\n@@ -232,1 +233,1 @@\n-int PhaseChaitin::elide_copy( Node *n, int k, Block *current_block, Node_List &value, Node_List &regnd, bool can_change_regs ) {\n+int PhaseChaitin::elide_copy( Node *n, int k, Block *current_block, Node_List *value, Node_List *regnd, bool can_change_regs ) {\n@@ -256,1 +257,1 @@\n-  if( !can_change_regs )\n+  if (!can_change_regs) {\n@@ -258,1 +259,1 @@\n-\n+  }\n@@ -260,1 +261,4 @@\n-  if( &value == NULL ) return blk_adjust;\n+  assert(regnd != NULL || value == NULL, \"sanity\");\n+  if (value == NULL || regnd == NULL) {\n+    return blk_adjust;\n+  }\n@@ -276,4 +280,5 @@\n-  if (register_contains_value(val, val_reg, n_regs, value)) {\n-    blk_adjust += use_prior_register(n,k,regnd[val_reg],current_block,value,regnd);\n-    if( n->in(k) == regnd[val_reg] ) \/\/ Success!  Quit trying\n-      return blk_adjust;\n+  if (register_contains_value(val, val_reg, n_regs, *value)) {\n+    blk_adjust += use_prior_register(n,k,regnd->at(val_reg),current_block,value,regnd);\n+    if (n->in(k) == regnd->at(val_reg)) {\n+      return blk_adjust; \/\/ Success!  Quit trying\n+    }\n@@ -307,1 +312,1 @@\n-    Node *vv = value[reg];\n+    Node *vv = value->at(reg);\n@@ -329,1 +334,1 @@\n-      if (!register_contains_value(vv, reg, n_regs, value)) continue; \/\/ Different value\n+      if (!register_contains_value(vv, reg, n_regs, *value)) continue; \/\/ Different value\n@@ -337,3 +342,3 @@\n-          regnd[reg]->outcnt()==1 ) { \/\/ last use of a spill-load turns into a CISC use\n-        blk_adjust += use_prior_register(n,k,regnd[reg],current_block,value,regnd);\n-        if( n->in(k) == regnd[reg] ) \/\/ Success!  Quit trying\n+          regnd->at(reg)->outcnt()==1 ) { \/\/ last use of a spill-load turns into a CISC use\n+        blk_adjust += use_prior_register(n,k,regnd->at(reg),current_block,value,regnd);\n+        if( n->in(k) == regnd->at(reg) ) \/\/ Success!  Quit trying\n@@ -539,1 +544,1 @@\n-        elide_copy(block->get_node(k), j, block, *blk2value[pb->_pre_order], *blk2regnd[pb->_pre_order], false);\n+        elide_copy(block->get_node(k), j, block, blk2value[pb->_pre_order], blk2regnd[pb->_pre_order], false);\n@@ -695,1 +700,1 @@\n-        j -= elide_copy(n, k, block, value, regnd, two_adr != k);\n+        j -= elide_copy(n, k, block, &value, &regnd, two_adr != k);\n","filename":"src\/hotspot\/share\/opto\/postaloc.cpp","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -191,3 +191,8 @@\n-#define CHECK_NONSTATIC_VM_STRUCT_ENTRY(typeName, fieldName, type)                 \\\n- {typeName *dummyObj = NULL; type* dummy = &dummyObj->fieldName;                   \\\n-  assert(offset_of(typeName, fieldName) < sizeof(typeName), \"Illegal nonstatic struct entry, field offset too large\"); }\n+#define CHECK_NONSTATIC_VM_STRUCT_ENTRY(typeName, fieldName, type) { \\\n+  static_assert( \\\n+    std::is_convertible< \\\n+      std::add_pointer_t<decltype(declval<typeName>().fieldName)>, \\\n+      std::add_pointer_t<type>>::value, \\\n+    \"type mismatch for \" XSTR(fieldName) \" member of \" XSTR(typeName)); \\\n+  assert(offset_of(typeName, fieldName) < sizeof(typeName), \"...\"); \\\n+}\n@@ -196,2 +201,2 @@\n-#define CHECK_VOLATILE_NONSTATIC_VM_STRUCT_ENTRY(typeName, fieldName, type)        \\\n- {typedef type dummyvtype; typeName *dummyObj = NULL; volatile dummyvtype* dummy = &dummyObj->fieldName; }\n+#define CHECK_VOLATILE_NONSTATIC_VM_STRUCT_ENTRY(typeName, fieldName, type) \\\n+  CHECK_NONSTATIC_VM_STRUCT_ENTRY(typeName, fieldName, std::add_volatile_t<type>)\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.hpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include <type_traits>\n@@ -1213,0 +1214,4 @@\n+\/\/ Converts any type T to a reference type.\n+template<typename T>\n+std::add_rvalue_reference_t<T> declval() noexcept;\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -147,4 +147,15 @@\n-\/\/ offset directly when base address is NULL. Use 16 to get around the\n-\/\/ warning. The -Wno-invalid-offsetof option could be used to suppress\n-\/\/ this warning, but we instead just avoid the use of offsetof().\n-#define offset_of(klass,field) (size_t)((intx)&(((klass*)16)->field) - 16)\n+\/\/ offset directly when base address is NULL. The -Wno-invalid-offsetof\n+\/\/ option could be used to suppress this warning, but we instead just\n+\/\/ avoid the use of offsetof().\n+\/\/\n+\/\/ FIXME: This macro is complex and rather arcane. Perhaps we should\n+\/\/ use offsetof() instead, with the invalid-offsetof warning\n+\/\/ temporarily disabled.\n+#define offset_of(klass,field)                          \\\n+[]() {                                                  \\\n+  char space[sizeof (klass)] ATTRIBUTE_ALIGNED(16);     \\\n+  klass* dummyObj = (klass*)space;                      \\\n+  char* c = (char*)(void*)&dummyObj->field;             \\\n+  return (size_t)(c - space);                           \\\n+}()\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_gcc.hpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"}]}