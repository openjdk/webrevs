{"files":[{"patch":"@@ -1506,1 +1506,4 @@\n-        public RecordComponent getRecordComponent(JCVariableDecl var, boolean addIfMissing, List<JCAnnotation> annotations) {\n+        \/* creates a record component if non is related to the given variable and recreates a brand new one\n+         * in other case\n+         *\/\n+        public RecordComponent createRecordComponent(JCVariableDecl var, List<JCAnnotation> annotations) {\n@@ -1513,9 +1516,1 @@\n-                    if (rc.type.hasTag(TypeTag.ERROR) && !var.sym.type.hasTag(TypeTag.ERROR)) {\n-                        \/\/ Found a record component with an erroneous type: save it so that it can be removed later.\n-                        \/\/ If the class type of the record component is generated by annotation processor, it should\n-                        \/\/ use the new actual class type and symbol instead of the old dummy ErrorType.\n-                        toRemove = rc;\n-                    } else {\n-                        \/\/ Found a good record component: just return.\n-                        return rc;\n-                    }\n+                    toRemove = rc;\n@@ -1528,2 +1523,2 @@\n-                recordComponents = recordComponents.append(rc = new RecordComponent(var.sym, annotations));\n-            } else if (addIfMissing) {\n+                recordComponents = recordComponents.append(rc = new RecordComponent(var.sym, toRemove.originalAnnos, toRemove.isVarargs));\n+            } else {\n@@ -1812,0 +1807,4 @@\n+            this(field, annotations, field.type.hasTag(TypeTag.ARRAY) && ((ArrayType)field.type).isVarargs());\n+        }\n+\n+        public RecordComponent(VarSymbol field, List<JCAnnotation> annotations, boolean isVarargs) {\n@@ -1820,1 +1819,1 @@\n-            this.isVarargs = type.hasTag(TypeTag.ARRAY) && ((ArrayType)type).isVarargs();\n+            this.isVarargs = isVarargs;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2934,0 +2934,3 @@\n+        \/** NOTE: if annotation processors are present, annotation processing rounds can happen after this method,\n+         *  this can impact in particular records for which annotations are forcibly propagated.\n+         *\/\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -968,1 +968,1 @@\n-                    sym.getRecordComponent(field, true,\n+                    sym.createRecordComponent(field,\n@@ -1214,1 +1214,18 @@\n-            \/\/ fields can't be varargs, lets remove the flag\n+            \/** Some notes regarding the code below. Annotations applied to elements of a record header are propagated\n+             *  to other elements which, when applicable, not explicitly declared by the user: the canonical constructor,\n+             *  accessors, fields and record components. Of all these the only ones that can't be explicitly declared are\n+             *  the fields and the record components.\n+             *\n+             *  Now given that annotations are propagated to all possible targets  regardless of applicability,\n+             *  annotations not applicable to a given element should be removed. See Check::validateAnnotation. Once\n+             *  annotations are removed we could lose the whole picture, that's why original annotations are stored in\n+             *  the record component, see RecordComponent::originalAnnos, but there is no real AST representing a record\n+             *  component so if there is an annotation processing round it could be that we need to reenter a record for\n+             *  which we need to re-attribute its annotations. This is why one of the things the code below is doing is\n+             *  copying the original annotations from the record component to the corresponding field, again this applies\n+             *  only if APs are present.\n+             *\n+             *  We need to copy the annotations to the field so that annotations applicable only to the record component\n+             *  can be attributed as if declared in the field and then stored in the metadata associated to the record\n+             *  component.\n+             *\/\n@@ -1217,0 +1234,4 @@\n+                RecordComponent rec = tree.sym.getRecordComponent(field.sym);\n+                TreeCopier<JCTree> tc = new TreeCopier<>(make.at(field.pos));\n+                List<JCAnnotation> originalAnnos = tc.copy(rec.getOriginalAnnos());\n+\n@@ -1218,0 +1239,6 @@\n+                if (originalAnnos.length() != field.mods.annotations.length()) {\n+                    field.mods.annotations = originalAnnos;\n+                    annotate.annotateLater(originalAnnos, env, field.sym, field.pos());\n+                }\n+\n+                \/\/ also here\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -68,2 +68,2 @@\n-        if (trees == null)\n-            return null;\n+        if (trees == null || trees.isEmpty())\n+            return trees;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @bug 8250629 8252307 8247352 8241151 8246774 8259025\n+ * @bug 8250629 8252307 8247352 8241151 8246774 8259025 8288130\n@@ -180,0 +180,17 @@\n+        assertOK(\n+                \"\"\"\n+                record R<T>(T x) {\n+                    public T x() {\n+                        return this.x;\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                import java.util.List;\n+                record R<T>(List<T> x) {\n+                    public List<T> x() {\n+                        return this.x;\n+                    }\n+                }\n+                \"\"\");\n@@ -1264,3 +1281,2 @@\n-    \/*  check that fields are initialized in a canonical constructor in the same declaration order as the corresponding\n-     *  record component\n-     *\/\n+    \/\/  check that fields are initialized in a canonical constructor in the same declaration order as the corresponding\n+    \/\/  record component\n@@ -1307,10 +1323,13 @@\n-        String[] testOptions = {\/* no options *\/};\n-        setCompileOptions(testOptions);\n-        assertFail(\"compiler.err.illegal.start.of.type\",\n-                \"class R {\\n\" +\n-                \"    record RR(int i) {\\n\" +\n-                \"        return null;\\n\" +\n-                \"    }\\n\" +\n-                \"    class record {}\\n\" +\n-                \"}\");\n-        setCompileOptions(previousOptions);\n+        try {\n+            String[] testOptions = {};\n+            setCompileOptions(testOptions);\n+            assertFail(\"compiler.err.illegal.start.of.type\",\n+                    \"class R {\\n\" +\n+                            \"    record RR(int i) {\\n\" +\n+                            \"        return null;\\n\" +\n+                            \"    }\\n\" +\n+                            \"    class record {}\\n\" +\n+                            \"}\");\n+        } finally {\n+            setCompileOptions(previousOptions);\n+        }\n@@ -1321,2 +1340,3 @@\n-        String srcTemplate =\n-                \"\"\"\n+        try {\n+            String srcTemplate =\n+                    \"\"\"\n@@ -1327,1 +1347,0 @@\n-\n@@ -1329,72 +1348,30 @@\n-                \"\"\";\n-\n-        \/\/ testing several combinations, adding even more combinations won't add too much value\n-        List<String> annoApplicableTargets = List.of(\n-                \"ElementType.FIELD\",\n-                \"ElementType.METHOD\",\n-                \"ElementType.PARAMETER\",\n-                \"ElementType.RECORD_COMPONENT\",\n-                \"ElementType.TYPE_USE\",\n-                \"ElementType.TYPE_USE,ElementType.FIELD\",\n-                \"ElementType.TYPE_USE,ElementType.METHOD\",\n-                \"ElementType.TYPE_USE,ElementType.PARAMETER\",\n-                \"ElementType.TYPE_USE,ElementType.RECORD_COMPONENT\",\n-                \"ElementType.TYPE_USE,ElementType.FIELD,ElementType.METHOD\",\n-                \"ElementType.TYPE_USE,ElementType.FIELD,ElementType.PARAMETER\",\n-                \"ElementType.TYPE_USE,ElementType.FIELD,ElementType.RECORD_COMPONENT\",\n-                \"ElementType.FIELD,ElementType.TYPE_USE\",\n-                \"ElementType.FIELD,ElementType.CONSTRUCTOR\",\n-                \"ElementType.FIELD,ElementType.LOCAL_VARIABLE\",\n-                \"ElementType.FIELD,ElementType.ANNOTATION_TYPE\",\n-                \"ElementType.FIELD,ElementType.PACKAGE\",\n-                \"ElementType.FIELD,ElementType.TYPE_PARAMETER\",\n-                \"ElementType.FIELD,ElementType.MODULE\",\n-                \"ElementType.METHOD,ElementType.TYPE_USE\",\n-                \"ElementType.PARAMETER,ElementType.TYPE_USE\",\n-                \"ElementType.RECORD_COMPONENT,ElementType.TYPE_USE\",\n-                \"ElementType.FIELD,ElementType.METHOD,ElementType.TYPE_USE\",\n-                \"ElementType.FIELD,ElementType.PARAMETER,ElementType.TYPE_USE\",\n-                \"ElementType.FIELD,ElementType.RECORD_COMPONENT,ElementType.TYPE_USE\"\n-        );\n-\n-        String[] generalOptions = {\n-                \"-processor\", Processor.class.getName(),\n-                \"-Atargets=\"\n-        };\n-\n-        for (String target : annoApplicableTargets) {\n-            String code = srcTemplate.replaceFirst(\"#TARGET\", target);\n-            String[] testOptions = generalOptions.clone();\n-            testOptions[testOptions.length - 1] = testOptions[testOptions.length - 1] + target;\n-            setCompileOptions(testOptions);\n-\n-            File dir = assertOK(true, code);\n-\n-            ClassFile classFile = ClassFile.read(findClassFileOrFail(dir, \"R.class\"));\n-\n-            \/\/ field first\n-            Assert.check(classFile.fields.length == 1);\n-            Field field = classFile.fields[0];\n-            \/* if FIELD is one of the targets then there must be a declaration annotation applied to the field, apart from\n-             * the type annotation\n-             *\/\n-            if (target.contains(\"ElementType.FIELD\")) {\n-                checkAnno(classFile,\n-                        (RuntimeAnnotations_attribute)findAttributeOrFail(\n-                                field.attributes,\n-                                RuntimeVisibleAnnotations_attribute.class),\n-                        \"Anno\");\n-            } else {\n-                assertAttributeNotPresent(field.attributes, RuntimeVisibleAnnotations_attribute.class);\n-            }\n-\n-            \/\/ lets check now for the type annotation\n-            if (target.contains(\"ElementType.TYPE_USE\")) {\n-                checkTypeAnno(\n-                        classFile,\n-                        (RuntimeVisibleTypeAnnotations_attribute)findAttributeOrFail(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class),\n-                        \"FIELD\",\n-                        \"Anno\");\n-            } else {\n-                assertAttributeNotPresent(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class);\n-            }\n+                    \"\"\";\n+\n+            \/\/ testing several combinations, adding even more combinations won't add too much value\n+            List<String> annoApplicableTargets = List.of(\n+                    \"ElementType.FIELD\",\n+                    \"ElementType.METHOD\",\n+                    \"ElementType.PARAMETER\",\n+                    \"ElementType.RECORD_COMPONENT\",\n+                    \"ElementType.TYPE_USE\",\n+                    \"ElementType.TYPE_USE,ElementType.FIELD\",\n+                    \"ElementType.TYPE_USE,ElementType.METHOD\",\n+                    \"ElementType.TYPE_USE,ElementType.PARAMETER\",\n+                    \"ElementType.TYPE_USE,ElementType.RECORD_COMPONENT\",\n+                    \"ElementType.TYPE_USE,ElementType.FIELD,ElementType.METHOD\",\n+                    \"ElementType.TYPE_USE,ElementType.FIELD,ElementType.PARAMETER\",\n+                    \"ElementType.TYPE_USE,ElementType.FIELD,ElementType.RECORD_COMPONENT\",\n+                    \"ElementType.FIELD,ElementType.TYPE_USE\",\n+                    \"ElementType.FIELD,ElementType.CONSTRUCTOR\",\n+                    \"ElementType.FIELD,ElementType.LOCAL_VARIABLE\",\n+                    \"ElementType.FIELD,ElementType.ANNOTATION_TYPE\",\n+                    \"ElementType.FIELD,ElementType.PACKAGE\",\n+                    \"ElementType.FIELD,ElementType.TYPE_PARAMETER\",\n+                    \"ElementType.FIELD,ElementType.MODULE\",\n+                    \"ElementType.METHOD,ElementType.TYPE_USE\",\n+                    \"ElementType.PARAMETER,ElementType.TYPE_USE\",\n+                    \"ElementType.RECORD_COMPONENT,ElementType.TYPE_USE\",\n+                    \"ElementType.FIELD,ElementType.METHOD,ElementType.TYPE_USE\",\n+                    \"ElementType.FIELD,ElementType.PARAMETER,ElementType.TYPE_USE\",\n+                    \"ElementType.FIELD,ElementType.RECORD_COMPONENT,ElementType.TYPE_USE\"\n+            );\n@@ -1402,23 +1379,29 @@\n-            \/\/ checking for the annotation on the corresponding parameter of the canonical constructor\n-            Method init = findMethodOrFail(classFile, \"<init>\");\n-            \/* if PARAMETER is one of the targets then there must be a declaration annotation applied to the parameter, apart from\n-             * the type annotation\n-             *\/\n-            if (target.contains(\"ElementType.PARAMETER\")) {\n-                checkParameterAnno(classFile,\n-                        (RuntimeVisibleParameterAnnotations_attribute)findAttributeOrFail(\n-                                init.attributes,\n-                                RuntimeVisibleParameterAnnotations_attribute.class),\n-                        \"Anno\");\n-            } else {\n-                assertAttributeNotPresent(init.attributes, RuntimeVisibleAnnotations_attribute.class);\n-            }\n-            \/\/ let's check now for the type annotation\n-            if (target.contains(\"ElementType.TYPE_USE\")) {\n-                checkTypeAnno(\n-                        classFile,\n-                        (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class),\n-                        \"METHOD_FORMAL_PARAMETER\", \"Anno\");\n-            } else {\n-                assertAttributeNotPresent(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class);\n-            }\n+            String[] generalOptions = {\n+                    \"-processor\", Processor.class.getName(),\n+                    \"-Atargets=\"\n+            };\n+\n+            for (String target : annoApplicableTargets) {\n+                String code = srcTemplate.replaceFirst(\"#TARGET\", target);\n+                String[] testOptions = generalOptions.clone();\n+                testOptions[testOptions.length - 1] = testOptions[testOptions.length - 1] + target;\n+                setCompileOptions(testOptions);\n+\n+                File dir = assertOK(true, code);\n+\n+                ClassFile classFile = ClassFile.read(findClassFileOrFail(dir, \"R.class\"));\n+\n+                \/\/ field first\n+                Assert.check(classFile.fields.length == 1);\n+                Field field = classFile.fields[0];\n+                \/\/ if FIELD is one of the targets then there must be a declaration annotation applied to the field, apart from\n+                \/\/ the type annotation\n+                if (target.contains(\"ElementType.FIELD\")) {\n+                    checkAnno(classFile,\n+                            (RuntimeAnnotations_attribute) findAttributeOrFail(\n+                                    field.attributes,\n+                                    RuntimeVisibleAnnotations_attribute.class),\n+                            \"Anno\");\n+                } else {\n+                    assertAttributeNotPresent(field.attributes, RuntimeVisibleAnnotations_attribute.class);\n+                }\n@@ -1426,22 +1409,82 @@\n-            \/\/ checking for the annotation in the accessor\n-            Method accessor = findMethodOrFail(classFile, \"s\");\n-            \/* if METHOD is one of the targets then there must be a declaration annotation applied to the accessor, apart from\n-             * the type annotation\n-             *\/\n-            if (target.contains(\"ElementType.METHOD\")) {\n-                checkAnno(classFile,\n-                        (RuntimeAnnotations_attribute)findAttributeOrFail(\n-                                accessor.attributes,\n-                                RuntimeVisibleAnnotations_attribute.class),\n-                        \"Anno\");\n-            } else {\n-                assertAttributeNotPresent(accessor.attributes, RuntimeVisibleAnnotations_attribute.class);\n-            }\n-            \/\/ let's check now for the type annotation\n-            if (target.contains(\"ElementType.TYPE_USE\")) {\n-                checkTypeAnno(\n-                        classFile,\n-                        (RuntimeVisibleTypeAnnotations_attribute)findAttributeOrFail(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class),\n-                        \"METHOD_RETURN\", \"Anno\");\n-            } else {\n-                assertAttributeNotPresent(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class);\n+                \/\/ lets check now for the type annotation\n+                if (target.contains(\"ElementType.TYPE_USE\")) {\n+                    checkTypeAnno(\n+                            classFile,\n+                            (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class),\n+                            \"FIELD\",\n+                            \"Anno\");\n+                } else {\n+                    assertAttributeNotPresent(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class);\n+                }\n+\n+                \/\/ checking for the annotation on the corresponding parameter of the canonical constructor\n+                Method init = findMethodOrFail(classFile, \"<init>\");\n+                \/\/ if PARAMETER is one of the targets then there must be a declaration annotation applied to the parameter, apart from\n+                \/\/ the type annotation\n+                if (target.contains(\"ElementType.PARAMETER\")) {\n+                    checkParameterAnno(classFile,\n+                            (RuntimeVisibleParameterAnnotations_attribute) findAttributeOrFail(\n+                                    init.attributes,\n+                                    RuntimeVisibleParameterAnnotations_attribute.class),\n+                            \"Anno\");\n+                } else {\n+                    assertAttributeNotPresent(init.attributes, RuntimeVisibleAnnotations_attribute.class);\n+                }\n+                \/\/ let's check now for the type annotation\n+                if (target.contains(\"ElementType.TYPE_USE\")) {\n+                    checkTypeAnno(\n+                            classFile,\n+                            (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class),\n+                            \"METHOD_FORMAL_PARAMETER\", \"Anno\");\n+                } else {\n+                    assertAttributeNotPresent(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class);\n+                }\n+\n+                \/\/ checking for the annotation in the accessor\n+                Method accessor = findMethodOrFail(classFile, \"s\");\n+                \/\/ if METHOD is one of the targets then there must be a declaration annotation applied to the accessor, apart from\n+                \/\/ the type annotation\n+                if (target.contains(\"ElementType.METHOD\")) {\n+                    checkAnno(classFile,\n+                            (RuntimeAnnotations_attribute) findAttributeOrFail(\n+                                    accessor.attributes,\n+                                    RuntimeVisibleAnnotations_attribute.class),\n+                            \"Anno\");\n+                } else {\n+                    assertAttributeNotPresent(accessor.attributes, RuntimeVisibleAnnotations_attribute.class);\n+                }\n+                \/\/ let's check now for the type annotation\n+                if (target.contains(\"ElementType.TYPE_USE\")) {\n+                    checkTypeAnno(\n+                            classFile,\n+                            (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class),\n+                            \"METHOD_RETURN\", \"Anno\");\n+                } else {\n+                    assertAttributeNotPresent(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class);\n+                }\n+\n+                \/\/ checking for the annotation in the Record attribute\n+                Record_attribute record = (Record_attribute) findAttributeOrFail(classFile.attributes, Record_attribute.class);\n+                Assert.check(record.component_count == 1);\n+                \/\/ if RECORD_COMPONENT is one of the targets then there must be a declaration annotation applied to the\n+                \/\/ field, apart from the type annotation\n+                if (target.contains(\"ElementType.RECORD_COMPONENT\")) {\n+                    checkAnno(classFile,\n+                            (RuntimeAnnotations_attribute) findAttributeOrFail(\n+                                    record.component_info_arr[0].attributes,\n+                                    RuntimeVisibleAnnotations_attribute.class),\n+                            \"Anno\");\n+                } else {\n+                    assertAttributeNotPresent(record.component_info_arr[0].attributes, RuntimeVisibleAnnotations_attribute.class);\n+                }\n+                \/\/ lets check now for the type annotation\n+                if (target.contains(\"ElementType.TYPE_USE\")) {\n+                    checkTypeAnno(\n+                            classFile,\n+                            (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(\n+                                    record.component_info_arr[0].attributes,\n+                                    RuntimeVisibleTypeAnnotations_attribute.class),\n+                            \"FIELD\", \"Anno\");\n+                } else {\n+                    assertAttributeNotPresent(record.component_info_arr[0].attributes, RuntimeVisibleTypeAnnotations_attribute.class);\n+                }\n@@ -1450,26 +1493,3 @@\n-            \/\/ checking for the annotation in the Record attribute\n-            Record_attribute record = (Record_attribute)findAttributeOrFail(classFile.attributes, Record_attribute.class);\n-            Assert.check(record.component_count == 1);\n-            \/* if RECORD_COMPONENT is one of the targets then there must be a declaration annotation applied to the\n-             * field, apart from the type annotation\n-             *\/\n-            if (target.contains(\"ElementType.RECORD_COMPONENT\")) {\n-                checkAnno(classFile,\n-                        (RuntimeAnnotations_attribute)findAttributeOrFail(\n-                                record.component_info_arr[0].attributes,\n-                                RuntimeVisibleAnnotations_attribute.class),\n-                        \"Anno\");\n-            } else {\n-                assertAttributeNotPresent(record.component_info_arr[0].attributes, RuntimeVisibleAnnotations_attribute.class);\n-            }\n-            \/\/ lets check now for the type annotation\n-            if (target.contains(\"ElementType.TYPE_USE\")) {\n-                checkTypeAnno(\n-                        classFile,\n-                        (RuntimeVisibleTypeAnnotations_attribute)findAttributeOrFail(\n-                                record.component_info_arr[0].attributes,\n-                                RuntimeVisibleTypeAnnotations_attribute.class),\n-                        \"FIELD\", \"Anno\");\n-            } else {\n-                assertAttributeNotPresent(record.component_info_arr[0].attributes, RuntimeVisibleTypeAnnotations_attribute.class);\n-            }\n+            \/\/ let's reset the default compiler options for other tests\n+        } finally {\n+            setCompileOptions(previousOptions);\n@@ -1477,3 +1497,0 @@\n-\n-        \/\/ let's reset the default compiler options for other tests\n-        setCompileOptions(previousOptions);\n@@ -1658,1 +1675,1 @@\n-                        default -> { \/* do nothing *\/ }\n+                        default -> {}\n@@ -1966,3 +1983,2 @@\n-            \/* dont execute this test when the default annotation processor is on as it will fail due to\n-             * spurious warnings\n-             *\/\n+            \/\/ dont execute this test when the default annotation processor is on as it will fail due to\n+            \/\/ spurious warnings\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":183,"deletions":167,"binary":false,"changes":350,"status":"modified"}]}