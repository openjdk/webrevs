{"files":[{"patch":"@@ -31,1 +31,0 @@\n-import java.nio.file.StandardOpenOption;\n@@ -96,8 +95,12 @@\n-            cleanupFiles(files);\n-        }\n-    }\n-\n-    private static void cleanupFiles(ResultFiles files) throws IOException {\n-        try {\n-            if (files.memory() != null) {\n-                Files.delete(files.memory());\n+            try {\n+                if (files.memory() != null) {\n+                    Files.delete(files.memory());\n+                }\n+                if (files.cpu() != null) {\n+                    Files.delete(files.cpu());\n+                }\n+                if (files.sliceDotDDir() != null) {\n+                    FileUtils.deleteFileTreeUnchecked(files.sliceDotDDir());\n+                }\n+            } catch (NoSuchFileException e) {\n+                \/\/ ignore\n@@ -105,8 +108,0 @@\n-            if (files.cpu() != null) {\n-                Files.delete(files.cpu());\n-            }\n-            if (files.sliceDotDDir() != null) {\n-                FileUtils.deleteFileTreeUnchecked(files.sliceDotDDir());\n-            }\n-        } catch (NoSuchFileException e) {\n-            \/\/ ignore\n@@ -143,3 +138,1 @@\n-            \/\/ Using createDirectories since we only need to ensure the directory\n-            \/\/ exists. Ignore it if already existent.\n-            Files.createDirectories(sliceDotDDir);\n+            Files.createDirectory(sliceDotDDir);\n@@ -149,4 +142,1 @@\n-                Files.writeString(memoryConfig,\n-                                  getMemoryDSliceContent(runOpts),\n-                                  StandardOpenOption.TRUNCATE_EXISTING,\n-                                  StandardOpenOption.CREATE);\n+                Files.writeString(memoryConfig, getMemoryDSliceContent(runOpts));\n@@ -156,4 +146,1 @@\n-                Files.writeString(cpuConfig,\n-                                  getCPUDSliceContent(runOpts),\n-                                  StandardOpenOption.TRUNCATE_EXISTING,\n-                                  StandardOpenOption.CREATE);\n+                Files.writeString(cpuConfig, getCPUDSliceContent(runOpts));\n@@ -175,1 +162,1 @@\n-        systemdDaemonReload(cpu, memory, sliceDotDDir);\n+        systemdDaemonReload(cpu);\n@@ -191,1 +178,1 @@\n-    private static void systemdDaemonReload(Path cpu, Path memory, Path sliceDdir) throws Exception {\n+    private static void systemdDaemonReload(Path cpu) throws Exception {\n@@ -196,14 +183,1 @@\n-            if (RUN_AS_USER) {\n-                cleanupFiles(new ResultFiles(cpu, memory, sliceDdir));\n-                \/\/ When run as user the systemd user manager needs to be\n-                \/\/ accessible and working. This is usually the case when\n-                \/\/ connected via SSH or user login, but may not work for\n-                \/\/ sessions set up via 'su <user>' or similar.\n-                \/\/ In that case, 'systemctl --user status' usually doesn't\n-                \/\/ work. There is no other option than skip the test.\n-                String msg = \"Service user@.service not properly configured. \" +\n-                             \"Skipping the test!\";\n-                throw new SkippedException(msg);\n-            } else {\n-                throw new AssertionError(\"Failed to reload systemd daemon\");\n-            }\n+            throw new AssertionError(\"Failed to reload systemd daemon\");\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/systemd\/SystemdTestUtils.java","additions":18,"deletions":44,"binary":false,"changes":62,"status":"modified"}]}