{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -43,1 +45,1 @@\n- *      -XX:-UseGCOverheadLimit\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -55,0 +57,2 @@\n+\n+import jdk.test.whitebox.WhiteBox;\n@@ -59,1 +63,0 @@\n-import nsk.share.gc.gp.GarbageUtils;\n@@ -155,1 +158,1 @@\n-            GarbageUtils.eatMemory(stresser);\n+            WhiteBox.getWhiteBox().fullGC();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/PhantomReference\/PhantomReferenceEvilTest\/PhantomReferenceEvilTest.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -40,1 +42,1 @@\n- *      -XX:-UseGCOverheadLimit\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -52,0 +54,2 @@\n+\n+import jdk.test.whitebox.WhiteBox;\n@@ -112,1 +116,1 @@\n-        GarbageUtils.eatMemory(stresser);\n+        WhiteBox.getWhiteBox().fullGC();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/PhantomReference\/PhantomReferenceTest\/PhantomReferenceTest.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,2 +43,1 @@\n- *         1. The reference is in queue after GC is provoked with\n- *            Algorithms.eatMemory() method (a single thread eats the memory).\n+ *         1. The reference is in queue after GC is provoked with WB.fullGC()\n@@ -50,1 +49,0 @@\n- *         6. reference.clear() does not throw any exception.\n@@ -57,1 +55,3 @@\n- * @run main\/othervm gc.gctests.PhantomReference.phantom001.phantom001 -ms low\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.PhantomReference.phantom001.phantom001\n@@ -64,0 +64,2 @@\n+\n+import jdk.test.whitebox.WhiteBox;\n@@ -65,1 +67,0 @@\n-import nsk.share.gc.gp.*;\n@@ -69,1 +70,1 @@\n-public class phantom001 extends ThreadedGCTest implements GarbageProducerAware, MemoryStrategyAware {\n+public class phantom001 extends ThreadedGCTest {\n@@ -71,2 +72,0 @@\n-    private GarbageProducer garbageProducer;\n-    private MemoryStrategy memoryStrategy;\n@@ -84,8 +83,0 @@\n-    public void setGarbageProducer(GarbageProducer garbageProducer) {\n-        this.garbageProducer = garbageProducer;\n-    }\n-\n-    public void setMemoryStrategy(MemoryStrategy memoryStrategy) {\n-        this.memoryStrategy = memoryStrategy;\n-    }\n-\n@@ -97,1 +88,1 @@\n-    class Test implements Runnable, OOMStress {\n+    class Test implements Runnable {\n@@ -127,6 +118,0 @@\n-        private void eatMemory(int initialFactor) {\n-            GarbageUtils.eatMemory(getExecutionController(),\n-                                   garbageProducer,\n-                                   initialFactor, 10, 0);\n-        }\n-\n@@ -134,59 +119,0 @@\n-            try {\n-                int code = iteration % TYPES_COUNT;\n-                info(\"start code \" + code);\n-                ReferenceQueue queue = new ReferenceQueue();\n-                PhantomReference reference;\n-                String type;\n-                \/\/ Define a specific type for each thread to test\n-                switch (code) {\n-                    case 0:\n-                        reference = new PhantomReference(new byte[SIZE], queue);\n-                        type = \"byte\";\n-                        break;\n-                    case 1:\n-                        reference = new PhantomReference(new short[SIZE], queue);\n-                        type = \"short\";\n-                        break;\n-                    case 2:\n-                        reference = new PhantomReference(new int[SIZE], queue);\n-                        type = \"int\";\n-                        break;\n-                    case 3:\n-                        reference = new PhantomReference(new long[SIZE], queue);\n-                        type = \"long\";\n-                        break;\n-                    case 4:\n-                        reference = new PhantomReference(new char[SIZE], queue);\n-                        type = \"char\";\n-                        break;\n-                    case 5:\n-                        reference = new PhantomReference(new boolean[SIZE], queue);\n-                        type = \"boolean\";\n-                        break;\n-                    case 6:\n-                        reference = new PhantomReference(new double[SIZE], queue);\n-                        type = \"double\";\n-                        break;\n-                    case 7:\n-                        reference = new PhantomReference(new float[SIZE], queue);\n-                        type = \"float\";\n-                        break;\n-                    case 8:\n-                        reference = new PhantomReference(new Object[SIZE], queue);\n-                        type = \"Object\";\n-                        break;\n-                    case 9:\n-                        reference = new PhantomReference(new NonbranchyTree(SIZE, 0.3f, SIZE),\n-                                queue);\n-                        type = \"NonbranchyTree\";\n-                        break;\n-                    case 10:\n-                        reference = new PhantomReference(internedStringProducer.create(SIZE), queue);\n-                        type = \"InternedString\";\n-                        break;\n-                    default:\n-                        reference = new PhantomReference(new Referent(), queue);\n-                        type = \"class\";\n-                }\n-\n-                int initialFactor = memoryStrategy.equals(MemoryStrategy.HIGH) ? 1 : (memoryStrategy.equals(MemoryStrategy.LOW) ? 10 : 2);\n@@ -194,17 +120,56 @@\n-                \/\/ If referent is finalizable, provoke GCs and wait for finalization.\n-                if (type.equals(\"class\")) {\n-                    progress(\"Waiting for finalization: \" + type);\n-                    for (int checks = 0; !finalized && !shouldTerminate(); ++checks) {\n-                        \/\/ There are scenarios where one eatMemory() isn't enough,\n-                        \/\/ but 10 iterations really ought to be sufficient.\n-                        if (checks > 10) {\n-                            fail(\"Waiting for finalization: \" + type);\n-                            return;\n-                        }\n-                        eatMemory(initialFactor);\n-                        \/\/ Give some time for finalizer to run.\n-                        try {\n-                            Thread.sleep(100);\n-                        } catch (InterruptedException e) {}\n-                    }\n-                }\n+            int code = iteration % TYPES_COUNT;\n+            info(\"start code \" + code);\n+            ReferenceQueue queue = new ReferenceQueue();\n+            PhantomReference reference;\n+            String type;\n+            \/\/ Define a specific type for each thread to test\n+            switch (code) {\n+                case 0:\n+                    reference = new PhantomReference(new byte[SIZE], queue);\n+                    type = \"byte\";\n+                    break;\n+                case 1:\n+                    reference = new PhantomReference(new short[SIZE], queue);\n+                    type = \"short\";\n+                    break;\n+                case 2:\n+                    reference = new PhantomReference(new int[SIZE], queue);\n+                    type = \"int\";\n+                    break;\n+                case 3:\n+                    reference = new PhantomReference(new long[SIZE], queue);\n+                    type = \"long\";\n+                    break;\n+                case 4:\n+                    reference = new PhantomReference(new char[SIZE], queue);\n+                    type = \"char\";\n+                    break;\n+                case 5:\n+                    reference = new PhantomReference(new boolean[SIZE], queue);\n+                    type = \"boolean\";\n+                    break;\n+                case 6:\n+                    reference = new PhantomReference(new double[SIZE], queue);\n+                    type = \"double\";\n+                    break;\n+                case 7:\n+                    reference = new PhantomReference(new float[SIZE], queue);\n+                    type = \"float\";\n+                    break;\n+                case 8:\n+                    reference = new PhantomReference(new Object[SIZE], queue);\n+                    type = \"Object\";\n+                    break;\n+                case 9:\n+                    reference = new PhantomReference(new NonbranchyTree(SIZE, 0.3f, SIZE),\n+                            queue);\n+                    type = \"NonbranchyTree\";\n+                    break;\n+                case 10:\n+                    reference = new PhantomReference(internedStringProducer.create(SIZE), queue);\n+                    type = \"InternedString\";\n+                    break;\n+                default:\n+                    reference = new PhantomReference(new Referent(), queue);\n+                    type = \"class\";\n+            }\n@@ -212,5 +177,5 @@\n-                \/\/ Provoke GCs and wait for reference to be enqueued.\n-                progress(\"Waiting for enqueue: \" + type);\n-                Reference polled = queue.poll();\n-                for (int checks = 0; polled == null && !shouldTerminate(); ++checks) {\n-                    \/\/ There are scenarios where one eatMemory() isn't enough,\n+            \/\/ If referent is finalizable, provoke GCs and wait for finalization.\n+            if (type.equals(\"class\")) {\n+                progress(\"Waiting for finalization: \" + type);\n+                for (int checks = 0; !finalized && !shouldTerminate(); ++checks) {\n+                    \/\/ There are scenarios where one WB.fillGC() isn't enough,\n@@ -219,1 +184,1 @@\n-                        fail(\"Waiting for enqueue: \" + type);\n+                        fail(\"Waiting for finalization: \" + type);\n@@ -222,2 +187,2 @@\n-                    eatMemory(initialFactor);\n-                    \/\/ Give some time for reference to be enqueued.\n+                    WhiteBox.getWhiteBox().fullGC();\n+                    \/\/ Give some time for finalizer to run.\n@@ -225,1 +190,1 @@\n-                        polled = queue.remove(100);\n+                        Thread.sleep(checks * 100);\n@@ -228,0 +193,1 @@\n+            }\n@@ -229,2 +195,8 @@\n-                if (polled == null && shouldTerminate()) {\n-                    info(\"Terminated: \" + type);\n+            \/\/ Provoke GCs and wait for reference to be enqueued.\n+            progress(\"Waiting for enqueue: \" + type);\n+            Reference polled = queue.poll();\n+            for (int checks = 0; polled == null && !shouldTerminate(); ++checks) {\n+                \/\/ There are scenarios where one WB.fillGC() isn't enough,\n+                \/\/ but 10 iterations really ought to be sufficient.\n+                if (checks > 10) {\n+                    fail(\"Waiting for enqueue: \" + type);\n@@ -233,0 +205,6 @@\n+                WhiteBox.getWhiteBox().fullGC();\n+                \/\/ Give some time for reference to be enqueued.\n+                try {\n+                    polled = queue.remove(checks * 100);\n+                } catch (InterruptedException e) {}\n+            }\n@@ -234,6 +212,4 @@\n-                \/\/ The polled reference must be equal to the one enqueued to\n-                \/\/ the queue\n-                if (polled != reference) {\n-                    fail(\"The original reference is not equal to polled reference.\");\n-                    return;\n-                }\n+            if (polled == null && shouldTerminate()) {\n+                info(\"Terminated: \" + type);\n+                return;\n+            }\n@@ -241,10 +217,12 @@\n-                \/\/ queue.poll() once again must return null now, since there is\n-                \/\/ only one reference in the queue\n-                if (queue.poll() != null) {\n-                    fail(\"There are more than one reference in the queue.\");\n-                    return;\n-                }\n-                progress(\"Finished: \" + type);\n-            } catch (OutOfMemoryError e) {\n-            } finally {\n-                iteration++;\n+            \/\/ The polled reference must be equal to the one enqueued to\n+            \/\/ the queue\n+            if (polled != reference) {\n+                fail(\"The original reference is not equal to polled reference.\");\n+                return;\n+            }\n+\n+            \/\/ queue.poll() once again must return null now, since there is\n+            \/\/ only one reference in the queue\n+            if (queue.poll() != null) {\n+                fail(\"There are more than one reference in the queue.\");\n+                return;\n@@ -252,0 +230,2 @@\n+            progress(\"Finished: \" + type);\n+            iteration++;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/PhantomReference\/phantom001\/phantom001.java","additions":107,"deletions":127,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/PhantomReference\/phantom002\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/gctests\/PhantomReference\/phantom002.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test checks that Garbage Collector correctly works with\n- *     PhantomReferences. It also checks that no unexpected exceptions and errors\n- *     are thrown or the JVM is not crashed.\n- *     The test starts a number of threads. Each thread run tests for some time\n- *     or serveral iterations.  See javadoc StressOptions for configuration.\n- *     First of all each thread defines what type to check (there are 11 types\n- *     totally). As soon as the type is defined, a PhantomRefence is created that\n- *     refers to an array of tested type and is registered with in a queue. A\n- *     PhantomRefence for NonbranchyTree and Referent calsses does not refer to\n- *     arrays, but to instances of the classes.\n- *     After that a thread performs next checks for the reference:\n- *         1. The reference is in queue after GC is provoked with\n- *            Algorithms.eatMemory() method (a single thread eats the memory).\n- *         2. reference.get() returns null.\n- *         3. queue.poll() returns the reference that was created.\n- *         4. queue.poll() again returns null.\n- *         5. If the checked type is class (Referent), then it must be finalized,\n- *            since the reference is already enqueued.\n- *         6. reference.clear() does not throw any exception.\n- *     The test extends ThreadedGCTest and implements GarbageProducerAware and\n- *     MemoryStrategyAware interfaces. The corresponding javadoc documentation\n- *     for additional test configuration.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm gc.gctests.PhantomReference.phantom001.phantom001 -ms high\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/PhantomReference\/phantom002\/TestDescription.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,2 +43,1 @@\n- *         1. The reference is in queue after GC is provoked with\n- *            Algorithms.eatMemory() method (a single thread eats the memory).\n+ *         1. The reference is in queue after GC is provoked with WB.fullGC()\n@@ -54,1 +53,3 @@\n- * @run main\/othervm gc.gctests.SoftReference.soft001.soft001 -ms low\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.SoftReference.soft001.soft001\n@@ -63,0 +64,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -65,1 +67,0 @@\n-import nsk.share.gc.OOMStress;\n@@ -67,5 +68,0 @@\n-import nsk.share.gc.gp.GarbageProducer;\n-import nsk.share.gc.gp.GarbageProducerAware;\n-import nsk.share.gc.gp.GarbageUtils;\n-import nsk.share.gc.gp.MemoryStrategy;\n-import nsk.share.gc.gp.MemoryStrategyAware;\n@@ -75,1 +71,1 @@\n-public class soft001 extends ThreadedGCTest implements GarbageProducerAware, MemoryStrategyAware {\n+public class soft001 extends ThreadedGCTest {\n@@ -77,1 +73,0 @@\n-    private GarbageProducer garbageProducer;\n@@ -79,1 +74,0 @@\n-    private MemoryStrategy memoryStrategy;\n@@ -90,7 +84,0 @@\n-    public void setGarbageProducer(GarbageProducer garbageProducer) {\n-        this.garbageProducer = garbageProducer;\n-    }\n-\n-    public void setMemoryStrategy(MemoryStrategy memoryStrategy) {\n-        this.memoryStrategy = memoryStrategy;\n-    }\n@@ -103,1 +90,1 @@\n-    class Test implements Runnable, OOMStress {\n+    class Test implements Runnable {\n@@ -108,59 +95,56 @@\n-            \/\/ Pre-allocated OOME message to avoid OOME when logging it\n-            String oomMsg = \"Ignored OOME in run()\";\n-            try {\n-\n-                log.info(\"iteration \" + iteration);\n-                ReferenceQueue queue = new ReferenceQueue();\n-                SoftReference reference;\n-                int code = iteration % TYPES_COUNT;\n-                String type;\n-                \/\/ Define a specific type for each thread to test\n-                switch (code) {\n-                    case 0:\n-                        reference = new SoftReference(new byte[SIZE], queue);\n-                        type = \"byte\";\n-                        break;\n-                    case 1:\n-                        reference = new SoftReference(new short[SIZE], queue);\n-                        type = \"short\";\n-                        break;\n-                    case 2:\n-                        reference = new SoftReference(new int[SIZE], queue);\n-                        type = \"int\";\n-                        break;\n-                    case 3:\n-                        reference = new SoftReference(new long[SIZE], queue);\n-                        type = \"long\";\n-                        break;\n-                    case 4:\n-                        reference = new SoftReference(new char[SIZE], queue);\n-                        type = \"char\";\n-                        break;\n-                    case 5:\n-                        reference = new SoftReference(new boolean[SIZE], queue);\n-                        type = \"boolean\";\n-                        break;\n-                    case 6:\n-                        reference = new SoftReference(new double[SIZE], queue);\n-                        type = \"double\";\n-                        break;\n-                    case 7:\n-                        reference = new SoftReference(new float[SIZE], queue);\n-                        type = \"float\";\n-                        break;\n-                    case 8:\n-                        reference = new SoftReference(new Object[SIZE], queue);\n-                        type = \"Object\";\n-                        break;\n-                    case 9:\n-                        reference = new SoftReference(internedStringProducer.create(SIZE), queue);\n-                        type = \"InternedString\";\n-                        break;\n-                    default:\n-                        reference = new SoftReference(new NonbranchyTree(SIZE, 0.3f, SIZE),\n-                                queue);\n-                        type = \"NonbranchyTree\";\n-                        break;\n-                }\n-                int initialFactor = memoryStrategy.equals(MemoryStrategy.HIGH) ? 1 : (memoryStrategy.equals(MemoryStrategy.LOW) ? 10 : 2);\n-                GarbageUtils.eatMemory(getExecutionController(), garbageProducer, initialFactor , 10, 0);\n+            log.info(\"iteration \" + iteration);\n+            ReferenceQueue queue = new ReferenceQueue();\n+            SoftReference reference;\n+            int code = iteration % TYPES_COUNT;\n+            String type;\n+            \/\/ Define a specific type for each thread to test\n+            switch (code) {\n+                case 0:\n+                    reference = new SoftReference(new byte[SIZE], queue);\n+                    type = \"byte\";\n+                    break;\n+                case 1:\n+                    reference = new SoftReference(new short[SIZE], queue);\n+                    type = \"short\";\n+                    break;\n+                case 2:\n+                    reference = new SoftReference(new int[SIZE], queue);\n+                    type = \"int\";\n+                    break;\n+                case 3:\n+                    reference = new SoftReference(new long[SIZE], queue);\n+                    type = \"long\";\n+                    break;\n+                case 4:\n+                    reference = new SoftReference(new char[SIZE], queue);\n+                    type = \"char\";\n+                    break;\n+                case 5:\n+                    reference = new SoftReference(new boolean[SIZE], queue);\n+                    type = \"boolean\";\n+                    break;\n+                case 6:\n+                    reference = new SoftReference(new double[SIZE], queue);\n+                    type = \"double\";\n+                    break;\n+                case 7:\n+                    reference = new SoftReference(new float[SIZE], queue);\n+                    type = \"float\";\n+                    break;\n+                case 8:\n+                    reference = new SoftReference(new Object[SIZE], queue);\n+                    type = \"Object\";\n+                    break;\n+                case 9:\n+                    reference = new SoftReference(internedStringProducer.create(SIZE), queue);\n+                    type = \"InternedString\";\n+                    break;\n+                default:\n+                    reference = new SoftReference(new NonbranchyTree(SIZE, 0.3f, SIZE),\n+                            queue);\n+                    type = \"NonbranchyTree\";\n+                    break;\n+            }\n+            Reference polledReference = null;\n+            for (int i = 0; i < 10 && polledReference == null; i++) {\n+                WhiteBox.getWhiteBox().fullGC();\n@@ -171,1 +155,0 @@\n-                Reference polledReference = null;\n@@ -173,1 +156,1 @@\n-                    polledReference = queue.remove();\n+                    polledReference = queue.remove(i * 100);\n@@ -178,3 +161,1 @@\n-                \/\/ Check the reference and the queue\n-                \/\/ The polled reference must be equal to the one enqueued to\n-                \/\/ the queue\n+            }\n@@ -182,4 +163,4 @@\n-                if (polledReference != reference) {\n-                    log.error(\"The original reference is not equal to polled reference.\");\n-                    setFailed(true);\n-                }\n+            if (polledReference == null) {\n+                log.error(\"Haven't polled reference after 10 GC.\");\n+                setFailed(true);\n+            }\n@@ -187,10 +168,15 @@\n-                \/\/ queue.poll() once again must return null now, since there is\n-                \/\/ only one reference in the queue\n-                polledReference = queue.poll();\n-                if (polledReference != null) {\n-                    log.error(\"There are more  than one references in the queue.\");\n-                    setFailed(true);\n-                }\n-                reference.clear();\n-            } catch (OutOfMemoryError e) {\n-                log.info(oomMsg);\n+            \/\/ Check the reference and the queue\n+            \/\/ The polled reference must be equal to the one enqueued to\n+            \/\/ the queue\n+\n+            if (polledReference != reference) {\n+                log.error(\"The original reference is not equal to polled reference.\");\n+                setFailed(true);\n+            }\n+\n+            \/\/ queue.poll() once again must return null now, since there is\n+            \/\/ only one reference in the queue\n+            polledReference = queue.poll();\n+            if (polledReference != null) {\n+                log.error(\"There are more  than one references in the queue.\");\n+                setFailed(true);\n@@ -198,0 +184,1 @@\n+            reference.clear();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/SoftReference\/soft001\/soft001.java","additions":86,"deletions":99,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/SoftReference\/soft002\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/gctests\/SoftReference\/soft002.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test checks that Garbage Collector correctly works with\n- *     SoftReferences. It also checks that no unexpected exceptions and errors\n- *     are thrown or the JVM is not crashed.\n- *     The test starts a number of threads. Each thread run tests for some time\n- *     or serveral iterations.  See javadoc StressOptions for configuration.\n- *     First of all each thread defines what type to check (there are 10 types\n- *     totally). As soon as the type is defined, a SoftRefence is created that\n- *     refers to an array of tested type and is registered with in a queue. A\n- *     SoftRefence for NonbranchyTree class does not refer to an array, but to\n- *     instances of the class.\n- *     After that a thread performs next checks for the reference:\n- *         1. The reference is in queue after GC is provoked with\n- *            Algorithms.eatMemory() method (a single thread eats the memory).\n- *         2. queue.remove() returns reference from the queue.\n- *         3. queue.poll() returns null.\n- *         4. reference.clear() does not throw any exception.\n- *     The test extends ThreadedGCTest and implements GarbageProducerAware and\n- *     MemoryStrategyAware interfaces. The corresponding javadoc documentation\n- *     for additional test configuration.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm gc.gctests.SoftReference.soft001.soft001 -ms high\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/SoftReference\/soft002\/TestDescription.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/SoftReference\/soft003\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,3 @@\n- * @run main\/othervm -XX:-UseGCOverheadLimit gc.gctests.SoftReference.soft003.soft003 -t 1\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.SoftReference.soft003.soft003 -t 1\n@@ -39,0 +41,2 @@\n+\n+import jdk.test.whitebox.WhiteBox;\n@@ -48,1 +52,1 @@\n- * GC with Algorithms.eatMemory() and checks that all references\n+ * GC with WB.fullGC() and checks that all references\n@@ -53,1 +57,1 @@\n-    class Worker implements Runnable, OOMStress {\n+    class Worker implements Runnable {\n@@ -63,1 +67,1 @@\n-            Algorithms.eatMemory(getExecutionController());\n+            WhiteBox.getWhiteBox().fullGC();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/SoftReference\/soft003\/soft003.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/SoftReference\/soft004\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,3 @@\n- * @run main\/othervm -XX:-UseGCOverheadLimit gc.gctests.SoftReference.soft004.soft004 -t 1\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.SoftReference.soft004.soft004 -t 1\n@@ -38,0 +40,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -51,1 +54,1 @@\n-    class Worker implements Runnable, OOMStress {\n+    class Worker implements Runnable {\n@@ -69,1 +72,1 @@\n-            Algorithms.eatMemory(getExecutionController());\n+            WhiteBox.getWhiteBox().fullGC();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/SoftReference\/soft004\/soft004.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/SoftReference\/soft005\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,3 @@\n- * @run main\/othervm -XX:-UseGCOverheadLimit gc.gctests.SoftReference.soft005.soft005 -t 1\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.SoftReference.soft005.soft005 -t 1\n@@ -38,0 +40,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -46,1 +49,1 @@\n- * then provokes GC with Algorithms.eatMemory(). Then\n+ * then provokes GC with WB.fullGC(). Then\n@@ -51,1 +54,1 @@\n-    class Worker implements Runnable, OOMStress {\n+    class Worker implements Runnable {\n@@ -77,1 +80,1 @@\n-            Algorithms.eatMemory(getExecutionController());\n+            WhiteBox.getWhiteBox().fullGC();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/SoftReference\/soft005\/soft005.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- *     or serveral iterations.  See javadoc StressOptions for configuration.\n+ *     or serveral iterations.\n@@ -43,2 +43,1 @@\n- *         1. The reference is in queue after GC is provoked with\n- *            Algorithms.eatMemory() method (a single thread eats the memory).\n+ *         1. The reference is in queue after GC is provoked with WB.fullGC()\n@@ -54,1 +53,3 @@\n- * @run main\/othervm gc.gctests.WeakReference.weak001.weak001 -ms low\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.WeakReference.weak001.weak001\n@@ -57,0 +58,1 @@\n+\n@@ -63,0 +65,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -65,1 +68,0 @@\n-import nsk.share.gc.OOMStress;\n@@ -67,5 +69,0 @@\n-import nsk.share.gc.gp.GarbageProducer;\n-import nsk.share.gc.gp.GarbageProducerAware;\n-import nsk.share.gc.gp.GarbageUtils;\n-import nsk.share.gc.gp.MemoryStrategy;\n-import nsk.share.gc.gp.MemoryStrategyAware;\n@@ -75,1 +72,1 @@\n-public class weak001 extends ThreadedGCTest implements GarbageProducerAware, MemoryStrategyAware {\n+public class weak001 extends ThreadedGCTest {\n@@ -77,2 +74,0 @@\n-    private GarbageProducer garbageProducer;\n-    private MemoryStrategy memoryStrategy;\n@@ -90,8 +85,0 @@\n-    public void setGarbageProducer(GarbageProducer garbageProducer) {\n-        this.garbageProducer = garbageProducer;\n-    }\n-\n-    public void setMemoryStrategy(MemoryStrategy memoryStrategy) {\n-        this.memoryStrategy = memoryStrategy;\n-    }\n-\n@@ -103,1 +90,1 @@\n-    class Test implements Runnable, OOMStress {\n+    class Test implements Runnable {\n@@ -108,59 +95,56 @@\n-            \/\/ Pre-allocated OOME message to avoid OOME when logging it\n-            String oomMsg = \"Ignored OOME in run()\";\n-            try {\n-\n-                log.info(\"iteration \" + iteration);\n-                ReferenceQueue queue = new ReferenceQueue();\n-                WeakReference reference;\n-                int code = iteration % TYPES_COUNT;\n-                String type;\n-                \/\/ Define a specific type for each thread to test\n-                switch (code) {\n-                    case 0:\n-                        reference = new WeakReference(new byte[SIZE], queue);\n-                        type = \"byte\";\n-                        break;\n-                    case 1:\n-                        reference = new WeakReference(new short[SIZE], queue);\n-                        type = \"short\";\n-                        break;\n-                    case 2:\n-                        reference = new WeakReference(new int[SIZE], queue);\n-                        type = \"int\";\n-                        break;\n-                    case 3:\n-                        reference = new WeakReference(new long[SIZE], queue);\n-                        type = \"long\";\n-                        break;\n-                    case 4:\n-                        reference = new WeakReference(new char[SIZE], queue);\n-                        type = \"char\";\n-                        break;\n-                    case 5:\n-                        reference = new WeakReference(new boolean[SIZE], queue);\n-                        type = \"boolean\";\n-                        break;\n-                    case 6:\n-                        reference = new WeakReference(new double[SIZE], queue);\n-                        type = \"double\";\n-                        break;\n-                    case 7:\n-                        reference = new WeakReference(new float[SIZE], queue);\n-                        type = \"float\";\n-                        break;\n-                    case 8:\n-                        reference = new WeakReference(new Object[SIZE], queue);\n-                        type = \"Object\";\n-                        break;\n-                    case 9:\n-                        reference = new WeakReference(internedStringProducer.create(SIZE), queue);\n-                        type = \"InternedString\";\n-                        break;\n-                    default:\n-                        reference = new WeakReference(new NonbranchyTree(SIZE, 0.3f, SIZE),\n-                                queue);\n-                        type = \"NonbranchyTree\";\n-                        break;\n-                }\n-                int initialFactor = memoryStrategy.equals(MemoryStrategy.HIGH) ? 1 : (memoryStrategy.equals(MemoryStrategy.LOW) ? 10 : 2);\n-                GarbageUtils.eatMemory(getExecutionController(), garbageProducer, initialFactor , 10, 0);\n+            log.info(\"iteration \" + iteration);\n+            ReferenceQueue queue = new ReferenceQueue();\n+            WeakReference reference;\n+            int code = iteration % TYPES_COUNT;\n+            String type;\n+            \/\/ Define a specific type for each thread to test\n+            switch (code) {\n+                case 0:\n+                    reference = new WeakReference(new byte[SIZE], queue);\n+                    type = \"byte\";\n+                    break;\n+                case 1:\n+                    reference = new WeakReference(new short[SIZE], queue);\n+                    type = \"short\";\n+                    break;\n+                case 2:\n+                    reference = new WeakReference(new int[SIZE], queue);\n+                    type = \"int\";\n+                    break;\n+                case 3:\n+                    reference = new WeakReference(new long[SIZE], queue);\n+                    type = \"long\";\n+                    break;\n+                case 4:\n+                    reference = new WeakReference(new char[SIZE], queue);\n+                    type = \"char\";\n+                    break;\n+                case 5:\n+                    reference = new WeakReference(new boolean[SIZE], queue);\n+                    type = \"boolean\";\n+                    break;\n+                case 6:\n+                    reference = new WeakReference(new double[SIZE], queue);\n+                    type = \"double\";\n+                    break;\n+                case 7:\n+                    reference = new WeakReference(new float[SIZE], queue);\n+                    type = \"float\";\n+                    break;\n+                case 8:\n+                    reference = new WeakReference(new Object[SIZE], queue);\n+                    type = \"Object\";\n+                    break;\n+                case 9:\n+                    reference = new WeakReference(internedStringProducer.create(SIZE), queue);\n+                    type = \"InternedString\";\n+                    break;\n+                default:\n+                    reference = new WeakReference(new NonbranchyTree(SIZE, 0.3f, SIZE),\n+                            queue);\n+                    type = \"NonbranchyTree\";\n+                    break;\n+            }\n+            Reference polledReference = null;\n+            for (int i = 0; i < 10 && polledReference == null; i++) {\n+                WhiteBox.getWhiteBox().fullGC();\n@@ -171,1 +155,0 @@\n-                Reference polledReference = null;\n@@ -173,1 +156,1 @@\n-                    polledReference = queue.remove();\n+                    polledReference = queue.remove(i * 100);\n@@ -178,3 +161,1 @@\n-                \/\/ Check the reference and the queue\n-                \/\/ The polled reference must be equal to the one enqueued to\n-                \/\/ the queue\n+            }\n@@ -182,4 +163,4 @@\n-                if (polledReference != reference) {\n-                    log.error(\"The original reference is not equal to polled reference.\");\n-                    setFailed(true);\n-                }\n+            if (polledReference == null) {\n+                log.error(\"Haven't polled reference after 10 GC.\");\n+                setFailed(true);\n+            }\n@@ -187,10 +168,14 @@\n-                \/\/ queue.poll() once again must return null now, since there is\n-                \/\/ only one reference in the queue\n-                polledReference = queue.poll();\n-                if (polledReference != null) {\n-                    log.error(\"There are more  than one references in the queue.\");\n-                    setFailed(true);\n-                }\n-                reference.clear();\n-            } catch (OutOfMemoryError e) {\n-                log.info(oomMsg);\n+            \/\/ Check the reference and the queue\n+            \/\/ The polled reference must be equal to the one enqueued to\n+            \/\/ the queue\n+            if (polledReference != reference) {\n+                log.error(\"The original reference is not equal to polled reference.\");\n+                setFailed(true);\n+            }\n+\n+            \/\/ queue.poll() once again must return null now, since there is\n+            \/\/ only one reference in the queue\n+            polledReference = queue.poll();\n+            if (polledReference != null) {\n+                log.error(\"There are more  than one references in the queue.\");\n+                setFailed(true);\n@@ -198,0 +183,1 @@\n+            reference.clear();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak001\/weak001.java","additions":87,"deletions":101,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak002\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress randomness\n- *\n- * @summary converted from VM Testbase gc\/gctests\/WeakReference\/weak002.\n- * VM Testbase keywords: [gc, stress, stressopt, nonconcurrent]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test checks that Garbage Collector correctly works with\n- *     WeakReferences. It also checks that no unexpected exceptions and errors\n- *     are thrown or the JVM is not crashed.\n- *     The test starts a number of threads. Each thread run tests for some time\n- *     or serveral iterations.  See javadoc StressOptions for configuration.\n- *     First of all each test defines what type to check (there are 10 types\n- *     totally). As soon as the type is defined, a WeakReference is created that\n- *     refers to an array of tested type and is registered with in a queue. A\n- *     WeakReference for NonbranchyTree class does not refer to an array, but to\n- *     instances of the class.\n- *     After that a thread performs next checks for the reference:\n- *         1. The reference is in queue after GC is provoked with\n- *            Algorithms.eatMemory() method (a single thread eats the memory).\n- *         2. queue.remove() returns reference from the queue.\n- *         3. queue.poll() returns null.\n- *         4. reference.clear() does not throw any exception.\n- *     The test extends ThreadedGCTest and implements GarbageProducerAware and\n- *     MemoryStrategyAware interfaces. The corresponding javadoc documentation\n- *     for additional test configuration.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm gc.gctests.WeakReference.weak001.weak001 -ms high\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak002\/TestDescription.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak003\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,3 @@\n- * @run main\/othervm -XX:-UseGCOverheadLimit gc.gctests.WeakReference.weak003.weak003 -t 1\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.WeakReference.weak003.weak003 -t 1\n@@ -39,0 +41,2 @@\n+\n+import jdk.test.whitebox.WhiteBox;\n@@ -40,1 +44,0 @@\n-import nsk.share.TestFailure;\n@@ -48,1 +51,1 @@\n- * GC with Algorithms.eatMemory and checks that all references\n+ * GC with WB.fullGC() and checks that all references\n@@ -57,1 +60,1 @@\n-    class Worker implements Runnable, OOMStress {\n+    class Worker implements Runnable {\n@@ -67,1 +70,1 @@\n-            Algorithms.eatMemory(getExecutionController());\n+            WhiteBox.getWhiteBox().fullGC();\n@@ -80,1 +83,1 @@\n-                throw new TestFailure(\"Some of the references have been not cleared: \" + n);\n+                throw new RuntimeException(\"Some of the references have been not cleared: \" + n);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak003\/weak003.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak004\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,3 @@\n- * @run main\/othervm -XX:-UseGCOverheadLimit gc.gctests.WeakReference.weak004.weak004 -t 1\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.WeakReference.weak004.weak004 -t 1\n@@ -38,0 +40,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -49,1 +52,1 @@\n-    class Worker implements Runnable, OOMStress {\n+    class Worker implements Runnable {\n@@ -67,1 +70,1 @@\n-            Algorithms.eatMemory(getExecutionController());\n+            WhiteBox.getWhiteBox().fullGC();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak004\/weak004.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak005\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,3 @@\n- * @run main\/othervm -XX:-UseGCOverheadLimit gc.gctests.WeakReference.weak005.weak005 -t 1\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.WeakReference.weak005.weak005 -t 1\n@@ -38,0 +40,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -46,1 +49,1 @@\n- * GC with Algorithms.eatMemory(). The test succeeds\n+ * GC with WB.fullGC(). The test succeeds\n@@ -51,1 +54,1 @@\n-    class Worker implements Runnable, OOMStress {\n+    class Worker implements Runnable {\n@@ -77,1 +80,1 @@\n-            Algorithms.eatMemory(getExecutionController());\n+            WhiteBox.getWhiteBox().fullGC();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak005\/weak005.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak006\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,3 @@\n- * @run main\/othervm -XX:-UseGCOverheadLimit gc.gctests.WeakReference.weak006.weak006 -t 1\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.WeakReference.weak006.weak006 -t 1\n@@ -38,0 +40,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -51,1 +54,1 @@\n- * to the next, then provokes GC with Algorithms.eatMemory().\n+ * to the next, then provokes GC with WB.fullGC().\n@@ -56,1 +59,1 @@\n-    class Worker implements Runnable, OOMStress {\n+    class Worker implements Runnable {\n@@ -125,1 +128,1 @@\n-            Algorithms.eatMemory(stresser);\n+            WhiteBox.getWhiteBox().fullGC();\n@@ -134,1 +137,1 @@\n-            Algorithms.eatMemory(stresser);\n+            WhiteBox.getWhiteBox().fullGC();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak006\/weak006.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,23 +0,0 @@\n-#\n-# Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak007\/TEST.properties","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,3 @@\n- * @run main\/othervm -XX:-UseGCOverheadLimit gc.gctests.WeakReference.weak007.weak007 -t 1\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.WeakReference.weak007.weak007 -t 1\n@@ -38,0 +40,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -48,1 +51,1 @@\n- * GC with Algorithms.eatMemory(). The test succeeds\n+ * GC with WB.fullGC(). The test succeeds\n@@ -54,1 +57,1 @@\n-    class Worker implements Runnable, OOMStress {\n+    class Worker implements Runnable {\n@@ -74,1 +77,1 @@\n-            Algorithms.eatMemory(getExecutionController());\n+            WhiteBox.getWhiteBox().fullGC();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak007\/weak007.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -86,0 +88,1 @@\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -97,0 +100,2 @@\n+\n+import jdk.test.whitebox.WhiteBox;\n@@ -100,1 +105,0 @@\n-import nsk.share.gc.gp.GarbageUtils;\n@@ -201,3 +205,1 @@\n-                        if (GarbageUtils.eatMemory(getExecutionController()) == 0) {\n-                                return; \/\/ We were unable to provoke OOME before timeout is over\n-                        }\n+                        WhiteBox.getWhiteBox().fullGC();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReferenceGC\/WeakReferenceGC.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"}]}