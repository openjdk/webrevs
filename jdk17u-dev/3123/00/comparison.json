{"files":[{"patch":"@@ -3933,17 +3933,0 @@\n-#ifdef ASSERT\n-\/\/ Goes over all children of the root of the loop tree. Check if any of them have a path\n-\/\/ down to Root, that does not go via a NeverBranch exit.\n-bool PhaseIdealLoop::only_has_infinite_loops() {\n-  ResourceMark rm;\n-  Unique_Node_List worklist;\n-  \/\/ start traversal at all loop heads of first-level loops\n-  for (IdealLoopTree* l = _ltree_root->_child; l != nullptr; l = l->_next) {\n-    Node* head = l->_head;\n-    assert(head->is_Region(), \"\");\n-    worklist.push(head);\n-  }\n-  return RegionNode::are_all_nodes_in_infinite_subgraph(worklist);\n-}\n-#endif\n-\n-\n@@ -4008,5 +3991,1 @@\n-  \/\/ Verify that the has_loops() flag set at parse time is consistent\n-  \/\/ with the just built loop tree. With infinite loops, it could be\n-  \/\/ that one pass of loop opts only finds infinite loops, clears the\n-  \/\/ has_loops() flag but adds NeverBranch nodes so the next loop opts\n-  \/\/ verification pass finds a non empty loop tree. When the back edge\n+  \/\/ Verify that the has_loops() flag set at parse time is consistent with the just built loop tree. When the back edge\n@@ -4014,1 +3993,1 @@\n-  assert(_ltree_root->_child == nullptr || C->has_loops() || only_has_infinite_loops() || C->has_exception_backedge(), \"parsing found no loops but there are some\");\n+  assert(_ltree_root->_child == nullptr || C->has_loops() || C->has_exception_backedge(), \"parsing found no loops but there are some\");\n@@ -4762,1 +4741,1 @@\n-        pre_order = build_loop_tree_impl( n, pre_order );\n+        pre_order = build_loop_tree_impl(n, pre_order);\n@@ -4779,1 +4758,1 @@\n-int PhaseIdealLoop::build_loop_tree_impl( Node *n, int pre_order ) {\n+int PhaseIdealLoop::build_loop_tree_impl(Node* n, int pre_order) {\n@@ -4790,2 +4769,2 @@\n-    if( n == m ) continue;      \/\/ Ignore control self-cycles\n-    if( !m->is_CFG() ) continue;\/\/ Ignore non-CFG edges\n+    if (n == m) continue;      \/\/ Ignore control self-cycles\n+    if (!m->is_CFG()) continue;\/\/ Ignore non-CFG edges\n@@ -4794,1 +4773,1 @@\n-    if( !is_postvisited(m) ) {  \/\/ Child visited but not post-visited?\n+    if (!is_postvisited(m)) {  \/\/ Child visited but not post-visited?\n@@ -4796,1 +4775,1 @@\n-      assert( get_preorder(m) < pre_order, \"should be backedge\" );\n+      assert(get_preorder(m) < pre_order, \"should be backedge\");\n@@ -4799,1 +4778,1 @@\n-      if( m == C->root()) {     \/\/ Found the root?\n+      if (m == C->root()) {     \/\/ Found the root?\n@@ -4805,1 +4784,1 @@\n-      if( !has_loop(m) )        \/\/ If 'm' does not already have a loop set\n+      if (!has_loop(m)) {        \/\/ If 'm' does not already have a loop set\n@@ -4807,1 +4786,1 @@\n-\n+      }\n@@ -4816,1 +4795,1 @@\n-      while( l && l->_head == m ) \/\/ Successor heads loop?\n+      while (l && l->_head == m) { \/\/ Successor heads loop?\n@@ -4818,0 +4797,1 @@\n+      }\n@@ -4820,1 +4800,1 @@\n-      if( !l ) {\n+      if (!l) {\n@@ -4826,7 +4806,0 @@\n-        \/\/ Here I set the loop to be the root loop.  I could have, after\n-        \/\/ inserting a bogus loop exit, restarted the recursion and found my\n-        \/\/ new loop exit.  This would make the infinite loop a first-class\n-        \/\/ loop and it would then get properly optimized.  What's the use of\n-        \/\/ optimizing an infinite loop?\n-        l = _ltree_root;        \/\/ Oops, found infinite loop\n-\n@@ -4857,1 +4830,1 @@\n-          set_loop(if_f, l);\n+          set_loop(if_f, _ltree_root);\n@@ -4866,1 +4839,1 @@\n-          set_loop(halt, l);\n+          set_loop(halt, _ltree_root);\n@@ -4870,0 +4843,17 @@\n+        \/\/ move to outer most loop with same header\n+        l = m_loop;\n+        while (true) {\n+          IdealLoopTree* next = l->_parent;\n+          if (next == nullptr || next->_head != m) {\n+            break;\n+          }\n+          l = next;\n+        }\n+        \/\/ properly insert infinite loop in loop tree\n+        sort(_ltree_root, l);\n+        \/\/ fix child link from parent\n+        IdealLoopTree* p = l->_parent;\n+        l->_next = p->_child;\n+        p->_child = l;\n+        \/\/ code below needs enclosing loop\n+        l = l->_parent;\n@@ -4909,1 +4899,1 @@\n-    while( p && l->_head == n ) {\n+    while (p && l->_head == n) {\n@@ -4923,1 +4913,1 @@\n-    if( innermost ) {\n+    if (innermost) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -930,3 +930,0 @@\n-#ifdef ASSERT\n-  bool only_has_infinite_loops();\n-#endif\n@@ -1039,1 +1036,1 @@\n-  int build_loop_tree_impl( Node *n, int pre_order );\n+  int build_loop_tree_impl(Node* n, int pre_order);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1624,1 +1624,1 @@\n-  if (target_bci < bci()) {\n+  if (target_bci <= bci()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}