{"files":[{"patch":"@@ -3933,17 +3933,0 @@\n-#ifdef ASSERT\n-\/\/ Goes over all children of the root of the loop tree. Check if any of them have a path\n-\/\/ down to Root, that does not go via a NeverBranch exit.\n-bool PhaseIdealLoop::only_has_infinite_loops() {\n-  ResourceMark rm;\n-  Unique_Node_List worklist;\n-  \/\/ start traversal at all loop heads of first-level loops\n-  for (IdealLoopTree* l = _ltree_root->_child; l != nullptr; l = l->_next) {\n-    Node* head = l->_head;\n-    assert(head->is_Region(), \"\");\n-    worklist.push(head);\n-  }\n-  return RegionNode::are_all_nodes_in_infinite_subgraph(worklist);\n-}\n-#endif\n-\n-\n@@ -4008,5 +3991,1 @@\n-  \/\/ Verify that the has_loops() flag set at parse time is consistent\n-  \/\/ with the just built loop tree. With infinite loops, it could be\n-  \/\/ that one pass of loop opts only finds infinite loops, clears the\n-  \/\/ has_loops() flag but adds NeverBranch nodes so the next loop opts\n-  \/\/ verification pass finds a non empty loop tree. When the back edge\n+  \/\/ Verify that the has_loops() flag set at parse time is consistent with the just built loop tree. When the back edge\n@@ -4014,1 +3993,1 @@\n-  assert(_ltree_root->_child == nullptr || C->has_loops() || only_has_infinite_loops() || C->has_exception_backedge(), \"parsing found no loops but there are some\");\n+  assert(_ltree_root->_child == nullptr || C->has_loops() || C->has_exception_backedge(), \"parsing found no loops but there are some\");\n@@ -4762,1 +4741,1 @@\n-        pre_order = build_loop_tree_impl( n, pre_order );\n+        pre_order = build_loop_tree_impl(n, pre_order);\n@@ -4779,1 +4758,1 @@\n-int PhaseIdealLoop::build_loop_tree_impl( Node *n, int pre_order ) {\n+int PhaseIdealLoop::build_loop_tree_impl(Node* n, int pre_order) {\n@@ -4790,2 +4769,2 @@\n-    if( n == m ) continue;      \/\/ Ignore control self-cycles\n-    if( !m->is_CFG() ) continue;\/\/ Ignore non-CFG edges\n+    if (n == m) continue;      \/\/ Ignore control self-cycles\n+    if (!m->is_CFG()) continue;\/\/ Ignore non-CFG edges\n@@ -4794,1 +4773,1 @@\n-    if( !is_postvisited(m) ) {  \/\/ Child visited but not post-visited?\n+    if (!is_postvisited(m)) {  \/\/ Child visited but not post-visited?\n@@ -4796,1 +4775,1 @@\n-      assert( get_preorder(m) < pre_order, \"should be backedge\" );\n+      assert(get_preorder(m) < pre_order, \"should be backedge\");\n@@ -4799,1 +4778,1 @@\n-      if( m == C->root()) {     \/\/ Found the root?\n+      if (m == C->root()) {     \/\/ Found the root?\n@@ -4805,1 +4784,1 @@\n-      if( !has_loop(m) )        \/\/ If 'm' does not already have a loop set\n+      if (!has_loop(m)) {        \/\/ If 'm' does not already have a loop set\n@@ -4807,1 +4786,1 @@\n-\n+      }\n@@ -4816,1 +4795,1 @@\n-      while( l && l->_head == m ) \/\/ Successor heads loop?\n+      while (l && l->_head == m) { \/\/ Successor heads loop?\n@@ -4818,0 +4797,1 @@\n+      }\n@@ -4820,1 +4800,1 @@\n-      if( !l ) {\n+      if (!l) {\n@@ -4826,7 +4806,0 @@\n-        \/\/ Here I set the loop to be the root loop.  I could have, after\n-        \/\/ inserting a bogus loop exit, restarted the recursion and found my\n-        \/\/ new loop exit.  This would make the infinite loop a first-class\n-        \/\/ loop and it would then get properly optimized.  What's the use of\n-        \/\/ optimizing an infinite loop?\n-        l = _ltree_root;        \/\/ Oops, found infinite loop\n-\n@@ -4857,1 +4830,1 @@\n-          set_loop(if_f, l);\n+          set_loop(if_f, _ltree_root);\n@@ -4866,1 +4839,1 @@\n-          set_loop(halt, l);\n+          set_loop(halt, _ltree_root);\n@@ -4870,0 +4843,17 @@\n+        \/\/ move to outer most loop with same header\n+        l = m_loop;\n+        while (true) {\n+          IdealLoopTree* next = l->_parent;\n+          if (next == nullptr || next->_head != m) {\n+            break;\n+          }\n+          l = next;\n+        }\n+        \/\/ properly insert infinite loop in loop tree\n+        sort(_ltree_root, l);\n+        \/\/ fix child link from parent\n+        IdealLoopTree* p = l->_parent;\n+        l->_next = p->_child;\n+        p->_child = l;\n+        \/\/ code below needs enclosing loop\n+        l = l->_parent;\n@@ -4909,1 +4899,1 @@\n-    while( p && l->_head == n ) {\n+    while (p && l->_head == n) {\n@@ -4923,1 +4913,1 @@\n-    if( innermost ) {\n+    if (innermost) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -930,3 +930,0 @@\n-#ifdef ASSERT\n-  bool only_has_infinite_loops();\n-#endif\n@@ -1039,1 +1036,1 @@\n-  int build_loop_tree_impl( Node *n, int pre_order );\n+  int build_loop_tree_impl(Node* n, int pre_order);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1624,1 +1624,1 @@\n-  if (target_bci < bci()) {\n+  if (target_bci <= bci()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+super public class LongCountedLoopInInfiniteLoop\n+{\n+  public Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+  {\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+  }\n+  Method test:\"()V\"\n+    stack 3 locals 3\n+  {\n+        \/\/ #1 = 0;\n+        iconst_0;\n+        istore_1;\n+\n+    LOOPa:\n+        \/\/ if #1 >= 10: goto END\n+        iload_1;\n+        bipush    10;\n+        if_icmpge    END;\n+\n+        \/\/ if #1 > 1: goto LOOPc\n+        iload_1;\n+        iconst_1;\n+        if_icmpgt    LOOPc;\n+\n+        \/\/ #2 = 0;\n+        iconst_0;\n+        istore_2;\n+\n+    LOOPb:\n+        \/\/ if #2 > 2: goto LOOPa\n+        iload_2;\n+        iconst_2;\n+        if_icmpgt    LOOPa;\n+\n+        \/\/ #2 ++\n+        iinc    2, 1;\n+\n+        goto    LOOPb;\n+\n+    LOOPc:\n+        \/\/ #1 ++\n+        iinc    1, 1;\n+\n+        goto    LOOPa;\n+\n+    END:\n+        return;\n+    \n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/LongCountedLoopInInfiniteLoop.jasm","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+super public class MoveStoreAfterInfiniteLoop\n+{\n+  static Field a:I;\n+  static Field b:I;\n+  static Field c:S;\n+\n+  public Method \"<init>\":\"()V\"\n+\tstack 1 locals 1\n+  {\n+\t\taload_0;\n+\t\tinvokespecial\tMethod java\/lang\/Object.\"<init>\":\"()V\";\n+\t\treturn;\n+  }\n+\n+public static Method test:\"()V\"\n+    stack 3 locals 3\n+  {\n+    LTOP:\n+        iconst_0;\n+        istore_1;\n+\n+    LOUTER:\n+        iload_1;\n+        bipush    10;\n+        if_icmpge    LTOP;\n+\n+        getstatic    Field c:\"S\";\n+        putstatic    Field a:\"I\";\n+\n+        iconst_0;\n+        istore_2;\n+\n+    LINNER:\n+        iload_2;\n+        iconst_2;\n+        if_icmpge    LBOTTOM;\n+\n+        getstatic    Field b:\"I\";\n+        i2s;\n+        putstatic    Field c:\"S\";\n+\n+        iinc    2, 1;\n+\n+        goto    LINNER;\n+\n+    LBOTTOM:\n+        iinc    1, 1;\n+\n+        goto    LOUTER;\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/MoveStoreAfterInfiniteLoop.jasm","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8336478\n+ * @summary C2: assert(!n->as_Loop()->is_loop_nest_inner_loop() || _loop_opts_cnt == 0) failed: should have been turned into a counted loop\n+ * @compile LongCountedLoopInInfiniteLoop.jasm\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -Xcomp -XX:PerMethodTrapLimit=0 -XX:PerMethodSpecTrapLimit=0\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:StressLongCountedLoop=2000000\n+ *                   -XX:CompileCommand=compileonly,TestLongCountedLoopInInfiniteLoop::test TestLongCountedLoopInInfiniteLoop\n+ *\/\n+\n+public class TestLongCountedLoopInInfiniteLoop {\n+    public static void main(String[] args) {\n+        LongCountedLoopInInfiniteLoop obj = new LongCountedLoopInInfiniteLoop();\n+        test(false, obj);\n+    }\n+\n+    private static void test(boolean flag, LongCountedLoopInInfiniteLoop obj) {\n+        if (flag) {\n+            obj.test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestLongCountedLoopInInfiniteLoop.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8338100\n+ * @summary C2: assert(!n_loop->is_member(get_loop(lca))) failed: control must not be back in the loop\n+ * @compile MoveStoreAfterInfiniteLoop.jasm\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=TestMoveStoreAfterInfiniteLoop::test\n+ *                   -XX:CompileCommand=inline,MoveStoreAfterInfiniteLoop::test TestMoveStoreAfterInfiniteLoop\n+ *\/\n+\n+public class TestMoveStoreAfterInfiniteLoop {\n+    public static void main(String[] args) {\n+        new MoveStoreAfterInfiniteLoop();\n+        test(false);\n+    }\n+\n+    private static void test(boolean flag) {\n+        if (flag) {\n+            MoveStoreAfterInfiniteLoop.test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestMoveStoreAfterInfiniteLoop.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"}]}