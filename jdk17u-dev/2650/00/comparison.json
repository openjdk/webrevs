{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ *        jdk.test.lib.util.ForceGC\n@@ -37,3 +38,1 @@\n-import java.lang.ref.PhantomReference;\n-import java.lang.ref.Reference;\n-import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.WeakReference;\n@@ -54,0 +53,1 @@\n+import jdk.test.lib.util.ForceGC;\n@@ -63,1 +63,0 @@\n-    private static final ReferenceQueue<ClassLoader> rq = new ReferenceQueue<>();\n@@ -65,9 +64,2 @@\n-    static class TestLoader {\n-        private final PhantomReference<ClassLoader> ref;\n-        TestLoader() {\n-            this.ref = loadAndRun();\n-        }\n-\n-        \/\/ Use a new classloader to load the ClassForName class, then run its\n-        \/\/ Runnable.\n-        PhantomReference<ClassLoader> loadAndRun() {\n+    static class TestLoader extends URLClassLoader {\n+        static URL[] toURLs() {\n@@ -75,10 +67,2 @@\n-                ClassLoader classLoader =\n-                    new URLClassLoader(\"LeakedClassLoader\",\n-                        new URL[]{jarFilePath.toUri().toURL()},\n-                        ClassLoader.getPlatformClassLoader());\n-\n-                Class<?> loadClass = Class.forName(\"ClassForName\", true, classLoader);\n-                ((Runnable) loadClass.newInstance()).run();\n-\n-                return new PhantomReference<>(classLoader, rq);\n-            } catch (MalformedURLException|ReflectiveOperationException e) {\n+                return new URL[]{jarFilePath.toUri().toURL()};\n+            } catch (MalformedURLException e) {\n@@ -89,2 +73,14 @@\n-        PhantomReference<ClassLoader> getRef() {\n-            return ref;\n+        TestLoader() {\n+            super(\"LeakedClassLoader\", toURLs(), ClassLoader.getPlatformClassLoader());\n+        }\n+    }\n+\n+    \/\/ Use a new classloader to load the ClassForName class, then run its\n+    \/\/ Runnable.\n+    static WeakReference<TestLoader> loadAndRun() {\n+        TestLoader classLoader = new TestLoader();\n+        try {\n+            Class<?> loadClass = Class.forName(\"ClassForName\", true, classLoader);\n+            ((Runnable) loadClass.newInstance()).run();\n+        } catch (ReflectiveOperationException ex) {\n+            throw new RuntimeException(ex);\n@@ -92,0 +88,1 @@\n+        return new WeakReference<>(classLoader);\n@@ -101,1 +98,1 @@\n-        List<Callable<TestLoader>> callables =\n+        List<Callable<WeakReference<TestLoader>>> callables =\n@@ -103,1 +100,1 @@\n-                    Callable<TestLoader> cprcl = TestLoader::new;\n+                    Callable<WeakReference<TestLoader>> cprcl = ClassForNameLeak::loadAndRun;\n@@ -107,14 +104,4 @@\n-        List<Future<TestLoader>> futures = es.invokeAll(callables);\n-\n-        \/\/ Give the GC a chance to enqueue the PhantomReferences\n-        for (int i = 0; i < 10; i++) {\n-            System.gc();\n-        }\n-\n-        \/\/ Make sure all PhantomReferences to the leaked classloader are enqueued\n-        for (int j = 0; j < futures.size(); j++) {\n-            Reference rmRef = rq.remove(TIMEOUT);\n-            if (rmRef == null) {\n-                throw new RuntimeException(\"ClassLoader was never enqueued!\");\n-            } else {\n-                System.out.println(\"Enqueued \" + rmRef);\n+        for (Future<WeakReference<TestLoader>> future : es.invokeAll(callables)) {\n+            WeakReference<TestLoader> ref = future.get();\n+            if (!ForceGC.wait(() -> ref.refersTo(null))) {\n+                throw new RuntimeException(ref.get() + \" not unloaded\");\n@@ -124,1 +111,0 @@\n-        System.out.println(\"All ClassLoaders successfully enqueued\");\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/forNameLeak\/ClassForNameLeak.java","additions":29,"deletions":43,"binary":false,"changes":72,"status":"modified"}]}