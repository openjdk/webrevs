{"files":[{"patch":"@@ -31,0 +31,3 @@\n+\n+import jdk.internal.access.JavaLangReflectAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -33,1 +36,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -187,2 +189,0 @@\n-        final ConcurrentHashMap<Method, MethodHandle> defaultMethodMap =\n-                hasDefaultMethods(intfc) ? new ConcurrentHashMap<>() : null;\n@@ -205,1 +205,2 @@\n-                        return callDefaultMethod(defaultMethodMap, proxy, intfc, method, args);\n+                        \/\/ no additional access check is performed\n+                        return JLRA.invokeDefault(proxy, method, args, null);\n@@ -323,33 +324,1 @@\n-    private static boolean hasDefaultMethods(Class<?> intfc) {\n-        for (Method m : intfc.getMethods()) {\n-            if (!isObjectMethod(m) &&\n-                !Modifier.isAbstract(m.getModifiers())) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private static Object callDefaultMethod(ConcurrentHashMap<Method, MethodHandle> defaultMethodMap,\n-                             Object self, Class<?> intfc, Method m, Object[] args) throws Throwable {\n-        assert(isDefaultMethod(m) && !isObjectMethod(m)) : m;\n-\n-        \/\/ Lazily compute the associated method handle from the method\n-        MethodHandle dmh = defaultMethodMap.computeIfAbsent(m, mk -> {\n-            try {\n-                \/\/ Look up the default method for special invocation thereby\n-                \/\/ avoiding recursive invocation back to the proxy\n-                MethodHandle mh = MethodHandles.Lookup.IMPL_LOOKUP.findSpecial(\n-                        intfc, mk.getName(),\n-                        MethodType.methodType(mk.getReturnType(), mk.getParameterTypes()),\n-                        self.getClass());\n-                return mh.asSpreader(Object[].class, mk.getParameterCount());\n-            } catch (NoSuchMethodException | IllegalAccessException e) {\n-                \/\/ The method is known to exist and should be accessible, this\n-                \/\/ method would not be called unless the invokeinterface to the\n-                \/\/ default (public) method passed access control checks\n-                throw new InternalError(e);\n-            }\n-        });\n-        return dmh.invoke(self, args);\n-    }\n+    private static final JavaLangReflectAccess JLRA = SharedSecrets.getJavaLangReflectAccess();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":6,"deletions":37,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.invoke.MethodHandle;\n@@ -265,28 +264,1 @@\n-\n-        \/\/ verify that the object is actually a proxy instance\n-        if (!Proxy.isProxyClass(proxy.getClass())) {\n-            throw new IllegalArgumentException(\"'proxy' is not a proxy instance\");\n-        }\n-        if (!method.isDefault()) {\n-            throw new IllegalArgumentException(\"\\\"\" + method + \"\\\" is not a default method\");\n-        }\n-        @SuppressWarnings(\"unchecked\")\n-        Class<? extends Proxy> proxyClass = (Class<? extends Proxy>)proxy.getClass();\n-\n-        Class<?> intf = method.getDeclaringClass();\n-        \/\/ access check on the default method\n-        method.checkAccess(Reflection.getCallerClass(), intf, proxyClass, method.getModifiers());\n-\n-        MethodHandle mh = Proxy.defaultMethodHandle(proxyClass, method);\n-        \/\/ invoke the super method\n-        try {\n-            \/\/ the args array can be null if the number of formal parameters required by\n-            \/\/ the method is zero (consistent with Method::invoke)\n-            Object[] params = args != null ? args : Proxy.EMPTY_ARGS;\n-            return mh.invokeExact(proxy, params);\n-        } catch (ClassCastException | NullPointerException e) {\n-            throw new IllegalArgumentException(e.getMessage(), e);\n-        } catch (Proxy.InvocationException e) {\n-            \/\/ unwrap and throw the exception thrown by the default method\n-            throw e.getCause();\n-        }\n+        return Proxy.invokeDefault(proxy, method, args, Reflection.getCallerClass());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/InvocationHandler.java","additions":1,"deletions":29,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1317,0 +1317,40 @@\n+    \/*\n+     * Invoke the default method of the given proxy with an explicit caller class.\n+     *\n+     * @throws IllegalAccessException if the proxy interface is inaccessible to the caller\n+     *         if caller is non-null\n+     *\/\n+    static Object invokeDefault(Object proxy, Method method, Object[] args, Class<?> caller)\n+            throws Throwable {\n+        \/\/ verify that the object is actually a proxy instance\n+        if (!Proxy.isProxyClass(proxy.getClass())) {\n+            throw new IllegalArgumentException(\"'proxy' is not a proxy instance\");\n+        }\n+        if (!method.isDefault()) {\n+            throw new IllegalArgumentException(\"\\\"\" + method + \"\\\" is not a default method\");\n+        }\n+        @SuppressWarnings(\"unchecked\")\n+        Class<? extends Proxy> proxyClass = (Class<? extends Proxy>)proxy.getClass();\n+\n+        \/\/ skip access check if caller is null\n+        if (caller != null) {\n+            Class<?> intf = method.getDeclaringClass();\n+            \/\/ access check on the default method\n+            method.checkAccess(caller, intf, proxyClass, method.getModifiers());\n+        }\n+\n+        MethodHandle mh = Proxy.defaultMethodHandle(proxyClass, method);\n+        \/\/ invoke the super method\n+        try {\n+            \/\/ the args array can be null if the number of formal parameters required by\n+            \/\/ the method is zero (consistent with Method::invoke)\n+            Object[] params = args != null ? args : Proxy.EMPTY_ARGS;\n+            return mh.invokeExact(proxy, params);\n+        } catch (ClassCastException | NullPointerException e) {\n+            throw new IllegalArgumentException(e.getMessage(), e);\n+        } catch (Proxy.InvocationException e) {\n+            \/\/ unwrap and throw the exception thrown by the default method\n+            throw e.getCause();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -130,0 +130,5 @@\n+\n+    public Object invokeDefault(Object proxy, Method method, Object[] args, Class<?> caller)\n+            throws Throwable {\n+        return Proxy.invokeDefault(proxy, method, args, caller);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ReflectAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -105,0 +105,7 @@\n+\n+    \/** Invokes the given default method if the method's declaring interface is\n+     *  accessible to the given caller.  Otherwise, IllegalAccessException will\n+     *  be thrown.  If the caller is null, no access check is performed.\n+     *\/\n+    public Object invokeDefault(Object proxy, Method method, Object[] args, Class<?> caller)\n+        throws Throwable;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangReflectAccess.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8280377\n+ * @build m1\/* m2\/* Unnamed\n+ * @run testng\/othervm m1\/p1.Main\n+ * @run testng\/othervm Unnamed\n+ * @summary Test MethodHandleProxies::asInterfaceInstance with a default\n+ *          method with varargs\n+ *\/\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/Driver.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/MethodHandlesProxiesTest.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/lang\/invoke\/MethodHandlesProxiesTest.java","status":"renamed"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * Test MethodHandleProxies::asInterfaceInstance with an inaccessible interface\n+ *\/\n+public class Unnamed {\n+    public static void main(String... args) throws Throwable {\n+        MethodHandle target = MethodHandles.constant(String.class, \"test\");\n+        Class<?> intf = Class.forName(\"p2.TestIntf\");\n+        Object t = MethodHandleProxies.asInterfaceInstance(intf, target);\n+\n+        \/\/ verify that the caller has no access to the proxy created on an\n+        \/\/ inaccessible interface\n+        Method m = intf.getMethod(\"test\", Object[].class);\n+        assertFalse(m.canAccess(null));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/Unnamed.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -23,1 +23,0 @@\n-\n@@ -25,1 +24,2 @@\n-    requires transitive m2;\n+    requires m2;\n+    requires org.testng;\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/m1\/module-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/langtools\/tools\/jdeps\/optionalDependency\/src\/m1\/module-info.java","status":"copied"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p1;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+\n+import p2.TestIntf;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+public class Main {\n+    public interface A {\n+        default String aConcat(Object... objs) { return Arrays.deepToString(objs); }\n+    }\n+\n+    public interface B {\n+        default String bConcat(Object[] objs) { return Arrays.deepToString(objs); }\n+    }\n+\n+    public interface C extends A, B {\n+        String c(Object... objs);\n+    }\n+\n+    private static String concat(Object... objs) {\n+        return Arrays.stream(objs).map(Object::toString).collect(Collectors.joining());\n+    }\n+\n+    \/*\n+     * Test the invocation of default methods with varargs\n+     *\/\n+    @Test\n+    public static void testVarargsMethods() throws Throwable {\n+        MethodHandle target = MethodHandles.lookup().findStatic(Main.class,\n+                \"concat\", MethodType.methodType(String.class, Object[].class));\n+        C proxy = MethodHandleProxies.asInterfaceInstance(C.class, target);\n+\n+        assertEquals(proxy.c(\"a\", \"b\", \"c\"), \"abc\");\n+        assertEquals(proxy.aConcat(\"a\", \"b\", \"c\"), \"[a, b, c]\");\n+        assertEquals(proxy.aConcat(new Object[] { \"a\", \"b\", \"c\" }), \"[a, b, c]\");\n+        assertEquals(proxy.bConcat(new Object[] { \"a\", \"b\", \"c\" }), \"[a, b, c]\");\n+    }\n+\n+    \/*\n+     * Test the invocation of a default method of an accessible interface\n+     *\/\n+    @Test\n+    public static void modulePrivateInterface() {\n+        MethodHandle target = MethodHandles.constant(String.class, \"test\");\n+        TestIntf t = MethodHandleProxies.asInterfaceInstance(TestIntf.class, target);\n+        assertEquals(t.test(), \"test\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/m1\/p1\/Main.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -23,3 +23,2 @@\n-\n-module m3 {\n-    exports p3;\n+module m2 {\n+    exports p2 to m1;\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/m2\/module-info.java","additions":2,"deletions":3,"binary":false,"changes":5,"previous_filename":"test\/langtools\/tools\/jdeps\/optionalDependency\/src\/m3\/module-info.java","status":"copied"},{"patch":"@@ -23,1 +23,0 @@\n-\n@@ -25,3 +24,3 @@\n-public class Q {\n-    @p3.R\n-    public void m() {}\n+\n+public interface TestIntf {\n+    String test();\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/m2\/p2\/TestIntf.java","additions":3,"deletions":4,"binary":false,"changes":7,"previous_filename":"test\/langtools\/tools\/jdeps\/optionalDependency\/src\/m2\/p2\/Q.java","status":"copied"}]}