{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.ArrayList;\n@@ -29,1 +30,1 @@\n-import java.util.HashMap;\n+import java.util.List;\n@@ -35,0 +36,1 @@\n+import java.util.stream.Stream;\n@@ -38,3 +40,4 @@\n-    public String getValue(String section, String key) {\n-        Objects.requireNonNull(section);\n-        Objects.requireNonNull(key);\n+    public String getValue(String sectionName, String key) {\n+        var section = getSection(sectionName);\n+        TKit.assertTrue(section != null, String.format(\n+                \"Check section [%s] is found in [%s] cfg file\", sectionName, id));\n@@ -42,5 +45,1 @@\n-        Map<String, String> entries = data.get(section);\n-        TKit.assertTrue(entries != null, String.format(\n-                \"Check section [%s] is found in [%s] cfg file\", section, id));\n-\n-        String value = entries.get(key);\n+        String value = section.getValue(key);\n@@ -49,1 +48,1 @@\n-                section, id));\n+                sectionName, id));\n@@ -54,1 +53,35 @@\n-    private CfgFile(Map<String, Map<String, String>> data, String id) {\n+    public String getValueUnchecked(String sectionName, String key) {\n+        var section = getSection(sectionName);\n+        if (section != null) {\n+            return section.getValue(key);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public void addValue(String sectionName, String key, String value) {\n+        var section = getSection(sectionName);\n+        if (section == null) {\n+            section = new Section(sectionName, new ArrayList<>());\n+            data.add(section);\n+        }\n+        section.data.add(Map.entry(key, value));\n+    }\n+\n+    public CfgFile() {\n+        this(new ArrayList<>(), \"*\");\n+    }\n+\n+    public static CfgFile combine(CfgFile base, CfgFile mods) {\n+        var cfgFile = new CfgFile(new ArrayList<>(), \"*\");\n+        for (var src : List.of(base, mods)) {\n+            for (var section : src.data) {\n+                for (var kvp : section.data) {\n+                    cfgFile.addValue(section.name, kvp.getKey(), kvp.getValue());\n+                }\n+            }\n+        }\n+        return cfgFile;\n+    }\n+\n+    private CfgFile(List<Section> data, String id) {\n@@ -59,1 +92,23 @@\n-    public static CfgFile readFromFile(Path path) throws IOException {\n+    public void save(Path path) {\n+        var lines = data.stream().flatMap(section -> {\n+            return Stream.concat(\n+                    Stream.of(String.format(\"[%s]\", section.name)),\n+                    section.data.stream().map(kvp -> {\n+                        return String.format(\"%s=%s\", kvp.getKey(), kvp.getValue());\n+                    }));\n+        });\n+        TKit.createTextFile(path, lines);\n+    }\n+\n+    private Section getSection(String name) {\n+        Objects.requireNonNull(name);\n+        for (int i = data.size()-1; i >=0; i--) {\n+            var section = data.get(i);\n+            if (name.equals(section.name)) {\n+                return section;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public static CfgFile load(Path path) throws IOException {\n@@ -65,1 +120,1 @@\n-        Map<String, Map<String, String>> result = new HashMap<>();\n+        List<Section> sections = new ArrayList<>();\n@@ -68,1 +123,1 @@\n-        Map<String, String> currentSection = new HashMap<>();\n+        List<Map.Entry<String, String>> currentSection = new ArrayList<>();\n@@ -73,2 +128,3 @@\n-                    result.put(currentSectionName, Collections.unmodifiableMap(\n-                            new HashMap<>(currentSection)));\n+                    sections.add(new Section(currentSectionName,\n+                            Collections.unmodifiableList(new ArrayList<>(\n+                                    currentSection))));\n@@ -83,2 +139,1 @@\n-                currentSection.put(matcher.group(1), matcher.group(2));\n-                continue;\n+                currentSection.add(Map.entry(matcher.group(1), matcher.group(2)));\n@@ -89,2 +144,3 @@\n-            result.put(Optional.ofNullable(currentSectionName).orElse(\"\"),\n-                    Collections.unmodifiableMap(currentSection));\n+            sections.add(new Section(\n+                    Optional.ofNullable(currentSectionName).orElse(\"\"),\n+                    Collections.unmodifiableList(currentSection)));\n@@ -93,1 +149,14 @@\n-        return new CfgFile(Collections.unmodifiableMap(result), path.toString());\n+        return new CfgFile(sections, path.toString());\n+    }\n+\n+    private static record Section(String name, List<Map.Entry<String, String>> data) {\n+        String getValue(String key) {\n+            Objects.requireNonNull(key);\n+            for (int i = data.size()-1; i >= 0; i--) {\n+                var kvp = data.get(i);\n+                if (key.equals(kvp.getKey())) {\n+                    return kvp.getValue();\n+                }\n+            }\n+            return null;\n+        }\n@@ -96,1 +165,1 @@\n-    private final Map<String, Map<String, String>> data;\n+    private final List<Section> data;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/CfgFile.java","additions":92,"deletions":23,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+record Comm<T>(Set<T> common, Set<T> unique1, Set<T> unique2) {\n+\n+    static <T> Comm<T> compare(Set<T> a, Set<T> b) {\n+        Set<T> common = new HashSet<>(a);\n+        common.retainAll(b);\n+        Set<T> unique1 = new HashSet<>(a);\n+        unique1.removeAll(common);\n+        Set<T> unique2 = new HashSet<>(b);\n+        unique2.removeAll(common);\n+        return new Comm(common, unique1, unique2);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Comm.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,0 @@\n-        removePath = false;\n@@ -94,2 +93,2 @@\n-    public Executor setRemovePath(boolean value) {\n-        removePath = value;\n+    public Executor removeEnvVar(String envVarName) {\n+        removeEnvVars.add(Objects.requireNonNull(envVarName));\n@@ -373,4 +372,6 @@\n-        if (removePath) {\n-            \/\/ run this with cleared Path in Environment\n-            TKit.trace(\"Clearing PATH in environment\");\n-            builder.environment().remove(\"PATH\");\n+       if (!removeEnvVars.isEmpty()) {\n+            final var envComm = Comm.compare(builder.environment().keySet(), removeEnvVars);\n+            builder.environment().keySet().removeAll(envComm.common());\n+            envComm.common().forEach(envVar -> {\n+                TKit.trace(String.format(\"Clearing %s in environment\", envVar));\n+            });\n@@ -515,1 +516,1 @@\n-    private boolean removePath;\n+    private Set<String> removeEnvVars = new HashSet<>();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Executor.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -467,1 +467,1 @@\n-            return new Executor()\n+            final var executor = new Executor()\n@@ -471,1 +471,0 @@\n-                    .setRemovePath(removePath)\n@@ -473,1 +472,3 @@\n-                    .addArguments(launcherArgs);\n+                    .addArguments(List.of(args));\n+\n+            return configureEnvironment(executor);\n@@ -490,0 +491,8 @@\n+    public static Executor configureEnvironment(Executor executor) {\n+        if (CLEAR_JAVA_ENV_VARS) {\n+            executor.removeEnvVar(\"JAVA_TOOL_OPTIONS\");\n+            executor.removeEnvVar(\"_JAVA_OPTIONS\");\n+        }\n+        return executor;\n+    }\n+\n@@ -499,0 +508,3 @@\n+\n+    private static final boolean CLEAR_JAVA_ENV_VARS = Optional.ofNullable(\n+            TKit.getConfigProperty(\"clear-app-launcher-java-env-vars\")).map(Boolean::parseBoolean).orElse(false);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/HelloApp.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -573,1 +573,10 @@\n-        Path runtimeDir = appRuntimeDirectory();\n+        if (isFakeRuntime()) {\n+            \/\/ Fake runtime\n+            Path runtimeDir = appRuntimeDirectory();\n+            TKit.trace(String.format(\n+                    \"%s because application runtime directory [%s] is incomplete\",\n+                    msg, runtimeDir));\n+            return true;\n+        }\n+        return false;\n+    }\n@@ -575,0 +584,1 @@\n+    private boolean isFakeRuntime() {\n@@ -586,10 +596,3 @@\n-        if (!criticalRuntimeFiles.stream().anyMatch(v -> {\n-            return runtimeDir.resolve(v).toFile().exists();\n-        })) {\n-            \/\/ Fake runtime\n-            TKit.trace(String.format(\n-                    \"%s because application runtime directory [%s] is incomplete\",\n-                    msg, runtimeDir));\n-            return true;\n-        }\n-        return false;\n+        Path runtimeDir = appRuntimeDirectory();\n+        return !criticalRuntimeFiles.stream().map(runtimeDir::resolve).allMatch(\n+                Files::exists);\n@@ -660,0 +663,7 @@\n+    public JPackageCommand ignoreFakeRuntime() {\n+        if (isFakeRuntime()) {\n+            ignoreDefaultRuntime(true);\n+        }\n+        return this;\n+    }\n+\n@@ -879,1 +889,1 @@\n-        return ThrowingFunction.toFunction(CfgFile::readFromFile).apply(\n+        return ThrowingFunction.toFunction(CfgFile::load).apply(\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":22,"deletions":12,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -764,1 +764,1 @@\n-            if (!comm.unique1.isEmpty() && !comm.unique2.isEmpty()) {\n+            if (!comm.unique1().isEmpty() && !comm.unique2().isEmpty()) {\n@@ -767,2 +767,2 @@\n-                        baseDir, format(comm.common), format(comm.unique1), format(comm.unique2)));\n-            } else if (!comm.unique1.isEmpty()) {\n+                        baseDir, format(comm.common()), format(comm.unique1()), format(comm.unique2())));\n+            } else if (!comm.unique1().isEmpty()) {\n@@ -771,2 +771,2 @@\n-                        baseDir, format(comm.common), format(comm.unique1)));\n-            } else if (!comm.unique2.isEmpty()) {\n+                        baseDir, format(comm.common()), format(comm.unique1())));\n+            } else if (!comm.unique2().isEmpty()) {\n@@ -775,1 +775,1 @@\n-                        baseDir, format(comm.common), format(comm.unique2)));\n+                        baseDir, format(comm.common()), format(comm.unique2())));\n@@ -788,1 +788,1 @@\n-            if (!comm.unique2.isEmpty()) {\n+            if (!comm.unique2().isEmpty()) {\n@@ -791,1 +791,1 @@\n-                        baseDir, format(comm.common), format(comm.unique2)));\n+                        baseDir, format(comm.common()), format(comm.unique2())));\n@@ -807,11 +807,0 @@\n-        private static record Comm(Set<Path> common, Set<Path> unique1, Set<Path> unique2) {\n-            static Comm compare(Set<Path> a, Set<Path> b) {\n-                Set<Path> common = new HashSet<>(a);\n-                common.retainAll(b);\n-                Set<Path> unique1 = new HashSet<>(a);\n-                unique1.removeAll(common);\n-                Set<Path> unique2 = new HashSet<>(b);\n-                unique2.removeAll(common);\n-                return new Comm(common, unique1, unique2);\n-            }\n-        }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":8,"deletions":19,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -34,0 +35,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -168,0 +171,84 @@\n+    public static void killProcess(long pid) {\n+        Executor.of(\"taskkill\", \"\/F\", \"\/PID\", Long.toString(pid)).dumpOutput(true).execute();\n+    }\n+\n+    public static void killAppLauncherProcess(JPackageCommand cmd,\n+            String launcherName, int expectedCount) {\n+        var pids = findAppLauncherPIDs(cmd, launcherName);\n+        try {\n+            TKit.assertEquals(expectedCount, pids.length, String.format(\n+                    \"Check [%d] %s app launcher processes found running\",\n+                    expectedCount, Optional.ofNullable(launcherName).map(\n+                            str -> \"[\" + str + \"]\").orElse(\"<main>\")));\n+        } finally {\n+            if (pids.length != 0) {\n+                killProcess(pids[0]);\n+            }\n+        }\n+    }\n+\n+    private static long[] findAppLauncherPIDs(JPackageCommand cmd, String launcherName) {\n+        \/\/ Get the list of PIDs and PPIDs of app launcher processes.\n+        \/\/ wmic process where (name = \"foo.exe\") get ProcessID,ParentProcessID\n+        List<String> output = Executor.of(\"wmic\", \"process\", \"where\", \"(name\",\n+                \"=\",\n+                \"\\\"\" + cmd.appLauncherPath(launcherName).getFileName().toString() + \"\\\"\",\n+                \")\", \"get\", \"ProcessID,ParentProcessID\").dumpOutput(true).\n+                saveOutput().executeAndGetOutput();\n+\n+        if (\"No Instance(s) Available.\".equals(output.get(0).trim())) {\n+            return new long[0];\n+        }\n+\n+        String[] headers = Stream.of(output.get(0).split(\"\\\\s+\", 2)).map(\n+                String::trim).map(String::toLowerCase).toArray(String[]::new);\n+        Pattern pattern;\n+        if (headers[0].equals(\"parentprocessid\") && headers[1].equals(\n+                \"processid\")) {\n+            pattern = Pattern.compile(\"^(?<ppid>\\\\d+)\\\\s+(?<pid>\\\\d+)\\\\s+$\");\n+        } else if (headers[1].equals(\"parentprocessid\") && headers[0].equals(\n+                \"processid\")) {\n+            pattern = Pattern.compile(\"^(?<pid>\\\\d+)\\\\s+(?<ppid>\\\\d+)\\\\s+$\");\n+        } else {\n+            throw new RuntimeException(\n+                    \"Unrecognizable output of \\'wmic process\\' command\");\n+        }\n+\n+        List<long[]> processes = output.stream().skip(1).map(line -> {\n+            Matcher m = pattern.matcher(line);\n+            long[] pids = null;\n+            if (m.matches()) {\n+                pids = new long[]{Long.parseLong(m.group(\"pid\")), Long.\n+                    parseLong(m.group(\"ppid\"))};\n+            }\n+            return pids;\n+        }).filter(Objects::nonNull).toList();\n+\n+        switch (processes.size()) {\n+            case 2 -> {\n+                final long parentPID;\n+                final long childPID;\n+                if (processes.get(0)[0] == processes.get(1)[1]) {\n+                    parentPID = processes.get(0)[0];\n+                    childPID = processes.get(1)[0];\n+                } else if (processes.get(1)[0] == processes.get(0)[1]) {\n+                    parentPID = processes.get(1)[0];\n+                    childPID = processes.get(0)[0];\n+                } else {\n+                    TKit.assertUnexpected(\"App launcher processes unrelated\");\n+                    return null; \/\/ Unreachable\n+                }\n+                return new long[]{parentPID, childPID};\n+            }\n+            case 1 -> {\n+                return new long[]{processes.get(0)[0]};\n+            }\n+            default -> {\n+                TKit.assertUnexpected(String.format(\n+                        \"Unexpected number of running processes [%d]\",\n+                        processes.size()));\n+                return null; \/\/ Unreachable\n+            }\n+        }\n+    }\n+\n@@ -381,1 +468,1 @@\n-    private final static Path PROGRAM_FILES = Path.of(Optional.ofNullable(\n+    private static final Path PROGRAM_FILES = Path.of(Optional.ofNullable(\n@@ -384,1 +471,1 @@\n-    private final static Path USER_LOCAL = Path.of(System.getProperty(\n+    private static final Path USER_LOCAL = Path.of(System.getProperty(\n@@ -388,2 +475,2 @@\n-    private final static String SYSTEM_SHELL_FOLDERS_REGKEY = \"HKLM\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\";\n-    private final static String USER_SHELL_FOLDERS_REGKEY = \"HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\";\n+    private static final String SYSTEM_SHELL_FOLDERS_REGKEY = \"HKLM\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\";\n+    private static final String USER_SHELL_FOLDERS_REGKEY = \"HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\";\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WindowsHelper.java","additions":91,"deletions":4,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import static jdk.jpackage.test.HelloApp.configureEnvironment;\n@@ -56,0 +57,1 @@\n+                .ignoreFakeRuntime()\n@@ -65,1 +67,1 @@\n-        List<String> output = new Executor()\n+        List<String> output = configureEnvironment(new Executor())\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppLauncherEnvTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-                .ignoreDefaultRuntime(true);\n+                .ignoreFakeRuntime();\n","filename":"test\/jdk\/tools\/jpackage\/share\/BasicTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @build WinChildProcessTest\n@@ -44,0 +43,1 @@\n+import static jdk.jpackage.test.HelloApp.configureEnvironment;\n@@ -47,0 +47,1 @@\n+import static jdk.jpackage.test.WindowsHelper.killProcess;\n@@ -53,1 +54,1 @@\n-    public static void test() throws Throwable {\n+    public static void test() {\n@@ -57,1 +58,2 @@\n-                    .helloAppImage(TEST_APP_JAVA + \"*Hello\");\n+                    .helloAppImage(TEST_APP_JAVA + \"*Hello\")\n+                    .ignoreFakeRuntime();\n@@ -64,1 +66,1 @@\n-            List<String> output = new Executor().saveOutput().dumpOutput()\n+            List<String> output = configureEnvironment(new Executor()).saveOutput().dumpOutput()\n@@ -79,1 +81,1 @@\n-            TKit.assertTrue(isAlive, \"Check is child process is alive\");\n+            TKit.assertTrue(isAlive, \"Check child process is alive\");\n@@ -81,2 +83,4 @@\n-            \/\/ Kill only a specific child instance\n-            Runtime.getRuntime().exec(\"taskkill \/F \/PID \" + childPid);\n+            if (childPid != 0) {\n+                \/\/ Kill only a specific child instance\n+                killProcess(childPid);\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinChildProcessTest.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"}]}