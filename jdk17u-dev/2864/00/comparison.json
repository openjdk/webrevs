{"files":[{"patch":"@@ -145,19 +145,0 @@\n-    \/**\n-     * If the type is not accessible from current context, try to figure out the\n-     * sharpest accessible supertype.\n-     *\n-     * @param originalType type to sharpen\n-     * @return sharped type\n-     *\/\n-    Type sharpestAccessible(Type originalType) {\n-        if (originalType.hasTag(ARRAY)) {\n-            return types.makeArrayType(sharpestAccessible(types.elemtype(originalType)));\n-        }\n-\n-        Type type = originalType;\n-        while (!rs.isAccessible(gen.getAttrEnv(), type.asElement())) {\n-            type = types.supertype(type);\n-        }\n-        return type;\n-    }\n-\n@@ -308,0 +289,8 @@\n+\n+        \/**\n+         * Returns true if the argument should be converted to a string eagerly, to preserve\n+         * possible side-effects.\n+         *\/\n+        protected boolean shouldConvertToStringEagerly(Type argType) {\n+            return !types.unboxedTypeOrType(argType).isPrimitive() && argType.tsym != syms.stringType.tsym;\n+        }\n@@ -336,4 +325,3 @@\n-                    if (arg.type == syms.botType) {\n-                        dynamicArgs.add(types.boxedClass(syms.voidType).type);\n-                    } else {\n-                        dynamicArgs.add(sharpestAccessible(arg.type));\n+                    Type argType = arg.type;\n+                    if (argType == syms.botType) {\n+                        argType = types.boxedClass(syms.voidType).type;\n@@ -344,0 +332,5 @@\n+                    if (shouldConvertToStringEagerly(argType)) {\n+                        gen.callMethod(pos, syms.stringType, names.valueOf, List.of(syms.objectType), true);\n+                        argType = syms.stringType;\n+                    }\n+                    dynamicArgs.add(argType);\n@@ -442,1 +435,1 @@\n-                        dynamicArgs.add(sharpestAccessible(arg.type));\n+                        Type argType = arg.type;\n@@ -446,0 +439,5 @@\n+                        if (shouldConvertToStringEagerly(argType)) {\n+                            gen.callMethod(pos, syms.stringType, names.valueOf, List.of(syms.objectType), true);\n+                            argType = syms.stringType;\n+                        }\n+                        dynamicArgs.add(argType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/StringConcat.java","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n- *          p5\/c5.java\n- *          p7\/c7.java\n+ *          p5\/c5.jasm\n+ *          p7\/c7.jasm\n","filename":"test\/hotspot\/jtreg\/runtime\/modules\/AccessCheck\/MethodAccessReadTwice.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2021, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * Test input for the fix for JDK-8174954, which checks for an expected\n+ * IllegalAccessError when the parameter type of an invokedynamic is\n+ * inaccessible.\n+ *\n+ * The test assumes that given the string concatenation expression \"\" + param,\n+ * javac generates an invokedynamic that uses the specific type of param. The\n+ * fix for JDK-8273914 make javac eagerly convert param to a String before\n+ * passing it to the invokedynamic call, which avoids the accessibility issue\n+ * the test is trying to exercise.\n+ *\n+ * This jasm file contains the bytecode javac generated before the fix for\n+ * JDK-8273914, to continue to exercise the invokedynamic behaviour that\n+ * JDK-8174954 is testing.\n+ *\/\n+\n+package  p5;\n+\n+super public class c5\n+\tversion 61:0\n+{\n+  public Method \"<init>\":\"()V\"\n+\tstack 1 locals 1\n+  {\n+\t\taload_0;\n+\t\tinvokespecial\tMethod java\/lang\/Object.\"<init>\":\"()V\";\n+\t\treturn;\n+  }\n+  public Method method5:\"(Lp2\/c2;)V\"\n+\tstack 2 locals 2\n+  {\n+\t\tgetstatic\tField java\/lang\/System.out:\"Ljava\/io\/PrintStream;\";\n+\t\taload_1;\n+\t\tinvokedynamic\tInvokeDynamic REF_invokeStatic:Method java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\":makeConcatWithConstants:\"(Lp2\/c2;)Ljava\/lang\/String;\" {\n+\t\t\tString \"In c5\\'s method5 with param = \"\n+\t\t};\n+\t\tinvokevirtual\tMethod java\/io\/PrintStream.println:\"(Ljava\/lang\/String;)V\";\n+\t\treturn;\n+  }\n+  public Method methodAddReadEdge:\"(Ljava\/lang\/Module;)V\"\n+\tstack 2 locals 2\n+  {\n+\t\tldc\tclass c5;\n+\t\tinvokevirtual\tMethod java\/lang\/Class.getModule:\"()Ljava\/lang\/Module;\";\n+\t\taload_1;\n+\t\tinvokevirtual\tMethod java\/lang\/Module.addReads:\"(Ljava\/lang\/Module;)Ljava\/lang\/Module;\";\n+\t\tpop;\n+\t\treturn;\n+  }\n+\n+  public static final InnerClass Lookup=class java\/lang\/invoke\/MethodHandles$Lookup of class java\/lang\/invoke\/MethodHandles;\n+\n+} \/\/ end Class c5\n","filename":"test\/hotspot\/jtreg\/runtime\/modules\/AccessCheck\/p5\/c5.jasm","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2021, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * Test input for the fix for JDK-8174954, which checks for an expected\n+ * IllegalAccessError when the parameter type of an invokedynamic is\n+ * inaccessible.\n+ *\n+ * The test assumes that given the string concatenation expression \"\" + param,\n+ * javac generates an invokedynamic that uses the specific type of param. The\n+ * fix for JDK-8273914 make javac eagerly convert param to a String before\n+ * passing it to the invokedynamic call, which avoids the accessibility issue\n+ * the test is trying to exercise.\n+ *\n+ * This jasm file contains the bytecode javac generated before the fix for\n+ * JDK-8273914, to continue to exercise the invokedynamic behaviour that\n+ * JDK-8174954 is testing.\n+ *\/\n+\n+package  p7;\n+\n+super public class c7\n+\tversion 61:0\n+{\n+  public Method \"<init>\":\"()V\"\n+\tstack 1 locals 1\n+  {\n+\t\taload_0;\n+\t\tinvokespecial\tMethod java\/lang\/Object.\"<init>\":\"()V\";\n+\t\treturn;\n+  }\n+  public Method method7:\"(Lp2\/c2;Ljava\/lang\/Module;)V\"\n+\tstack 3 locals 4\n+  {\n+\t\ttry t0;\n+\t\tgetstatic\tField java\/lang\/System.out:\"Ljava\/io\/PrintStream;\";\n+\t\taload_1;\n+\t\tinvokedynamic\tInvokeDynamic REF_invokeStatic:Method java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\":makeConcatWithConstants:\"(Lp2\/c2;)Ljava\/lang\/String;\" {\n+\t\t\tString \"In c7\\'s method7 with param = \"\n+\t\t};\n+\t\tinvokevirtual\tMethod java\/io\/PrintStream.println:\"(Ljava\/lang\/String;)V\";\n+\t\tnew\tclass java\/lang\/RuntimeException;\n+\t\tdup;\n+\t\tldc\tString \"c7 failed to throw expected IllegalAccessError\";\n+\t\tinvokespecial\tMethod java\/lang\/RuntimeException.\"<init>\":\"(Ljava\/lang\/String;)V\";\n+\t\tathrow;\n+\t\tendtry t0;\n+\t\tcatch t0 java\/lang\/IllegalAccessError;\n+\t\tstack_frame_type stack1;\n+\t\tstack_map class java\/lang\/IllegalAccessError;\n+\t\tastore_3;\n+\t\taload_0;\n+\t\taload_2;\n+\t\tinvokevirtual\tMethod methodAddReadEdge:\"(Ljava\/lang\/Module;)V\";\n+\t\ttry t1;\n+\t\tgetstatic\tField java\/lang\/System.out:\"Ljava\/io\/PrintStream;\";\n+\t\taload_1;\n+\t\tinvokedynamic\tInvokeDynamic REF_invokeStatic:Method java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\":makeConcatWithConstants:\"(Lp2\/c2;)Ljava\/lang\/String;\" {\n+\t\t\tString \"In c7\\'s method7 with param = \"\n+\t\t};\n+\t\tinvokevirtual\tMethod java\/io\/PrintStream.println:\"(Ljava\/lang\/String;)V\";\n+\t\tendtry t1;\n+\t\tgoto\tL61;\n+\t\tcatch t1 java\/lang\/IllegalAccessError;\n+\t\tstack_frame_type stack1;\n+\t\tstack_map class java\/lang\/IllegalAccessError;\n+\t\tastore_3;\n+\t\tnew\tclass java\/lang\/RuntimeException;\n+\t\tdup;\n+\t\taload_3;\n+\t\tinvokevirtual\tMethod java\/lang\/IllegalAccessError.getMessage:\"()Ljava\/lang\/String;\";\n+\t\tinvokedynamic\tInvokeDynamic REF_invokeStatic:Method java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\":makeConcatWithConstants:\"(Ljava\/lang\/String;)Ljava\/lang\/String;\" {\n+\t\t\tString \"Unexpected IllegalAccessError: \"\n+\t\t};\n+\t\tinvokespecial\tMethod java\/lang\/RuntimeException.\"<init>\":\"(Ljava\/lang\/String;)V\";\n+\t\tathrow;\n+\tL61:\tstack_frame_type same;\n+\t\treturn;\n+  }\n+  public Method methodAddReadEdge:\"(Ljava\/lang\/Module;)V\"\n+\tstack 2 locals 2\n+  {\n+\t\tldc\tclass c7;\n+\t\tinvokevirtual\tMethod java\/lang\/Class.getModule:\"()Ljava\/lang\/Module;\";\n+\t\taload_1;\n+\t\tinvokevirtual\tMethod java\/lang\/Module.addReads:\"(Ljava\/lang\/Module;)Ljava\/lang\/Module;\";\n+\t\tpop;\n+\t\treturn;\n+  }\n+\n+  public static final InnerClass Lookup=class java\/lang\/invoke\/MethodHandles$Lookup of class java\/lang\/invoke\/MethodHandles;\n+\n+} \/\/ end Class c7\n","filename":"test\/hotspot\/jtreg\/runtime\/modules\/AccessCheck\/p7\/c7.jasm","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2021, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8273914\n+ * @summary Indy string concat changes order of operations\n+ *\n+ * @clean *\n+ * @compile -XDstringConcat=indy              StringAppendEvaluatesInOrder.java\n+ * @run main StringAppendEvaluatesInOrder\n+ *\n+ * @clean *\n+ * @compile -XDstringConcat=indyWithConstants StringAppendEvaluatesInOrder.java\n+ * @run main StringAppendEvaluatesInOrder\n+ *\n+ * @clean *\n+ * @compile -XDstringConcat=inline            StringAppendEvaluatesInOrder.java\n+ * @run main StringAppendEvaluatesInOrder\n+ *\/\n+\n+public class StringAppendEvaluatesInOrder {\n+    static String test() {\n+        StringBuilder builder = new StringBuilder(\"foo\");\n+        int i = 15;\n+        return \"Test: \" + i + \" \" + (++i) + builder + builder.append(\"bar\");\n+    }\n+\n+    static String compoundAssignment() {\n+        StringBuilder builder2 = new StringBuilder(\"foo\");\n+        Object oo = builder2;\n+        oo += \"\" + builder2.append(\"bar\");\n+        return oo.toString();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        assertEquals(test(), \"Test: 15 16foofoobar\");\n+        assertEquals(compoundAssignment(), \"foofoobar\");\n+    }\n+\n+    private static void assertEquals(String actual, String expected) {\n+      if (!actual.equals(expected)) {\n+        throw new AssertionError(\"expected: \" + expected + \", actual: \" + actual);\n+      }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/StringConcat\/StringAppendEvaluatesInOrder.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2021, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.classfile.ConstantPool.*;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @bug     8273914\n+ * @summary Indy string concat changes order of operations\n+ * @modules jdk.jdeps\/com.sun.tools.classfile\n+ *\n+ * @clean *\n+ * @compile -XDstringConcat=indy              WellKnownTypeSignatures.java\n+ * @run main WellKnownTypeSignatures\n+ *\n+ * @clean *\n+ * @compile -XDstringConcat=indyWithConstants WellKnownTypeSignatures.java\n+ * @run main WellKnownTypeSignatures\n+ *\/\n+\n+public class WellKnownTypeSignatures {\n+    static List<String> actualTypes;\n+\n+    static int idx = 0;\n+\n+    static boolean z = true;\n+    static char c = (char) 42;\n+    static short s = (short) 42;\n+    static byte b = (byte) 42;\n+    static int i = 42;\n+    static long l = 42L;\n+    static float f = 42.0f;\n+    static double d = 42.0;\n+\n+    public static void main(String[] argv) throws Exception {\n+        readIndyTypes();\n+\n+        test(\"\" + WellKnownTypeSignatures.class, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n+        test(\"\" + Boolean.valueOf(z), idx++, \"(Ljava\/lang\/Boolean;)Ljava\/lang\/String;\");\n+        test(\"\" + Character.valueOf(c), idx++, \"(Ljava\/lang\/Character;)Ljava\/lang\/String;\");\n+        test(\"\" + Byte.valueOf(b), idx++, \"(Ljava\/lang\/Byte;)Ljava\/lang\/String;\");\n+        test(\"\" + Short.valueOf(s), idx++, \"(Ljava\/lang\/Short;)Ljava\/lang\/String;\");\n+        test(\"\" + Integer.valueOf(i), idx++, \"(Ljava\/lang\/Integer;)Ljava\/lang\/String;\");\n+        test(\"\" + Long.valueOf(l), idx++, \"(Ljava\/lang\/Long;)Ljava\/lang\/String;\");\n+        test(\"\" + Double.valueOf(d), idx++, \"(Ljava\/lang\/Double;)Ljava\/lang\/String;\");\n+        test(\"\" + Float.valueOf(f), idx++, \"(Ljava\/lang\/Float;)Ljava\/lang\/String;\");\n+        test(\"\" + z, idx++, \"(Z)Ljava\/lang\/String;\");\n+        test(\"\" + c, idx++, \"(C)Ljava\/lang\/String;\");\n+        test(\"\" + b, idx++, \"(B)Ljava\/lang\/String;\");\n+        test(\"\" + s, idx++, \"(S)Ljava\/lang\/String;\");\n+        test(\"\" + i, idx++, \"(I)Ljava\/lang\/String;\");\n+        test(\"\" + l, idx++, \"(J)Ljava\/lang\/String;\");\n+        test(\"\" + d, idx++, \"(D)Ljava\/lang\/String;\");\n+        test(\"\" + f, idx++, \"(F)Ljava\/lang\/String;\");\n+    }\n+\n+    public static void test(String actual, int index, String expectedType) {\n+        String actualType = actualTypes.get(index);\n+        if (!actualType.equals(expectedType)) {\n+            throw new IllegalStateException(\n+                    index\n+                            + \" Unexpected type: expected = \"\n+                            + expectedType\n+                            + \", actual = \"\n+                            + actualType);\n+        }\n+    }\n+\n+    public static void readIndyTypes() throws Exception {\n+        actualTypes = new ArrayList<String>();\n+\n+        ClassFile classFile =\n+                ClassFile.read(\n+                        new File(\n+                                System.getProperty(\"test.classes\", \".\"),\n+                                WellKnownTypeSignatures.class.getName() + \".class\"));\n+        ConstantPool constantPool = classFile.constant_pool;\n+\n+        for (Method method : classFile.methods) {\n+            if (method.getName(constantPool).equals(\"main\")) {\n+                Code_attribute code = (Code_attribute) method.attributes.get(Attribute.Code);\n+                for (Instruction i : code.getInstructions()) {\n+                    if (i.getOpcode() == Opcode.INVOKEDYNAMIC) {\n+                        CONSTANT_InvokeDynamic_info indyInfo =\n+                                (CONSTANT_InvokeDynamic_info)\n+                                        constantPool.get(i.getUnsignedShort(1));\n+                        CONSTANT_NameAndType_info natInfo = indyInfo.getNameAndTypeInfo();\n+                        actualTypes.add(natInfo.getType());\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/StringConcat\/WellKnownTypeSignatures.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2021, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.classfile.ConstantPool.*;\n+\n+\/*\n+ * @test\n+ * @bug     8273914\n+ * @summary Indy string concat changes order of operations\n+ * @modules jdk.jdeps\/com.sun.tools.classfile\n+ *\n+ * @compile -XDstringConcat=indy              WellKnownTypes.java\n+ * @run main WellKnownTypes\n+ *\n+ * @compile -XDstringConcat=indyWithConstants WellKnownTypes.java\n+ * @run main WellKnownTypes\n+ *\n+ * @compile -XDstringConcat=inline            WellKnownTypes.java\n+ * @run main WellKnownTypes\n+ *\/\n+\n+public class WellKnownTypes {\n+    static int idx = 0;\n+\n+    static boolean z = true;\n+    static char c = (char) 42;\n+    static byte b = (byte) 43;\n+    static short s = (short) 44;\n+    static int i = 45;\n+    static long l = 46L;\n+    static float f = 47.0f;\n+    static double d = 48.0;\n+\n+    public static void main(String[] argv) throws Exception {\n+        test(\"\" + WellKnownTypes.class, idx++, \"class WellKnownTypes\");\n+        test(\"\" + Boolean.valueOf(z), idx++, \"true\");\n+        test(\"\" + Character.valueOf(c), idx++, \"*\");\n+        test(\"\" + Byte.valueOf(b), idx++, \"43\");\n+        test(\"\" + Short.valueOf(s), idx++, \"44\");\n+        test(\"\" + Integer.valueOf(i), idx++, \"45\");\n+        test(\"\" + Long.valueOf(l), idx++, \"46\");\n+        test(\"\" + Float.valueOf(f), idx++, \"47.0\");\n+        test(\"\" + Double.valueOf(d), idx++, \"48.0\");\n+        test(\"\" + z, idx++, \"true\");\n+        test(\"\" + c, idx++, \"*\");\n+        test(\"\" + b, idx++, \"43\");\n+        test(\"\" + s, idx++, \"44\");\n+        test(\"\" + i, idx++, \"45\");\n+        test(\"\" + l, idx++, \"46\");\n+        test(\"\" + f, idx++, \"47.0\");\n+        test(\"\" + d, idx++, \"48.0\");\n+    }\n+\n+    public static void test(String actual, int index, String expected) {\n+        if (!actual.equals(expected)) {\n+      throw new IllegalStateException(\n+          index + \" Unexpected: expected = \" + expected + \", actual = \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/StringConcat\/WellKnownTypes.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -59,1 +59,1 @@\n-        test(\"\" + holder.c1, idx++, \"(Lp1\/PublicClass;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.c1, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -62,1 +62,1 @@\n-        test(\"\" + holder.c2, idx++, \"(Ljava\/lang\/Object;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.c2, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -65,1 +65,1 @@\n-        test(\"\" + holder.c3, idx++, \"(Ljava\/lang\/Object;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.c3, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -68,1 +68,1 @@\n-        test(\"\" + holder.c4, idx++, \"(Ljava\/lang\/Object;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.c4, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -71,1 +71,1 @@\n-        test(\"\" + holder.c5, idx++, \"(Lp1\/Public_PublicClass;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.c5, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -74,1 +74,1 @@\n-        test(\"\" + holder.c6, idx++, \"(Lp1\/Public_PublicInterface;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.c6, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -77,1 +77,1 @@\n-        test(\"\" + holder.c7, idx++, \"(Lp1\/Public_PrivateInterface1;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.c7, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -80,1 +80,1 @@\n-        test(\"\" + holder.c8, idx++, \"(Lp1\/Public_PrivateInterface2;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.c8, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -85,1 +85,1 @@\n-        test(\"\" + holder.ac1, idx++, \"([Lp1\/PublicClass;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.ac1, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -88,1 +88,1 @@\n-        test(\"\" + holder.ac2, idx++, \"([Ljava\/lang\/Object;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.ac2, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -91,1 +91,1 @@\n-        test(\"\" + holder.ac3, idx++, \"([Ljava\/lang\/Object;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.ac3, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -94,1 +94,1 @@\n-        test(\"\" + holder.ac4, idx++, \"([Ljava\/lang\/Object;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.ac4, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -97,1 +97,1 @@\n-        test(\"\" + holder.ac5, idx++, \"([Lp1\/Public_PublicClass;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.ac5, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -100,1 +100,1 @@\n-        test(\"\" + holder.ac6, idx++, \"([Lp1\/Public_PublicInterface;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.ac6, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -103,1 +103,1 @@\n-        test(\"\" + holder.ac7, idx++, \"([Lp1\/Public_PrivateInterface1;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.ac7, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -106,1 +106,1 @@\n-        test(\"\" + holder.ac8, idx++, \"([Lp1\/Public_PrivateInterface2;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.ac8, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -111,1 +111,1 @@\n-        test(\"\" + holder.aac1, idx++, \"([[Lp1\/PublicClass;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.aac1, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -114,1 +114,1 @@\n-        test(\"\" + holder.aac2, idx++, \"([[Ljava\/lang\/Object;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.aac2, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -117,1 +117,1 @@\n-        test(\"\" + holder.aac3, idx++, \"([[Ljava\/lang\/Object;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.aac3, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -120,1 +120,1 @@\n-        test(\"\" + holder.aac4, idx++, \"([[Ljava\/lang\/Object;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.aac4, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -123,1 +123,1 @@\n-        test(\"\" + holder.aac5, idx++, \"([[Lp1\/Public_PublicClass;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.aac5, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -126,1 +126,1 @@\n-        test(\"\" + holder.aac6, idx++, \"([[Lp1\/Public_PublicInterface;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.aac6, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -129,1 +129,1 @@\n-        test(\"\" + holder.aac7, idx++, \"([[Lp1\/Public_PrivateInterface1;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.aac7, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -132,1 +132,1 @@\n-        test(\"\" + holder.aac8, idx++, \"([[Lp1\/Public_PrivateInterface2;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.aac8, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -137,1 +137,1 @@\n-        test(\"\" + holder.i1, idx++, \"(Lp1\/PublicInterface;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.i1, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -140,1 +140,1 @@\n-        test(\"\" + holder.i2, idx++, \"(Ljava\/lang\/Object;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.i2, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -143,1 +143,1 @@\n-        test(\"\" + holder.i3, idx++, \"(Ljava\/lang\/Object;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.i3, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -146,1 +146,1 @@\n-        test(\"\" + holder.ai1, idx++, \"([Lp1\/PublicInterface;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.ai1, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -149,1 +149,1 @@\n-        test(\"\" + holder.ai2, idx++, \"([Ljava\/lang\/Object;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.ai2, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -152,1 +152,1 @@\n-        test(\"\" + holder.ai3, idx++, \"([Ljava\/lang\/Object;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.ai3, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -155,1 +155,1 @@\n-        test(\"\" + holder.aai1, idx++, \"([[Lp1\/PublicInterface;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.aai1, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -158,1 +158,1 @@\n-        test(\"\" + holder.aai2, idx++, \"([[Ljava\/lang\/Object;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.aai2, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n@@ -161,1 +161,1 @@\n-        test(\"\" + holder.aai3, idx++, \"([[Ljava\/lang\/Object;)Ljava\/lang\/String;\");\n+        test(\"\" + holder.aai3, idx++, \"(Ljava\/lang\/String;)Ljava\/lang\/String;\");\n","filename":"test\/langtools\/tools\/javac\/StringConcat\/access\/Test.java","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"}]}