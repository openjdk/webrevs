{"files":[{"patch":"@@ -30,1 +30,2 @@\n-void* GuardedMemory::wrap_copy(const void* ptr, const size_t len, const void* tag) {\n+void* GuardedMemory::wrap_copy(const void* ptr, const size_t len,\n+                               const void* tag, const void* tag2) {\n@@ -34,1 +35,1 @@\n-    GuardedMemory guarded(outerp, len, tag);\n+    GuardedMemory guarded(outerp, len, tag, tag2);\n@@ -63,2 +64,2 @@\n-      \" tag=\" PTR_FORMAT \" user_size=\" SIZE_FORMAT \" user_data=\" PTR_FORMAT,\n-      p2i(this), p2i(_base_addr), p2i(get_tag()), get_user_size(), p2i(get_user_ptr()));\n+      \" tag=\" PTR_FORMAT \"tag2=\" PTR_FORMAT \" user_size=\" SIZE_FORMAT \" user_data=\" PTR_FORMAT,\n+      p2i(this), p2i(_base_addr), p2i(get_tag()), p2i(get_tag2()), get_user_size(), p2i(get_user_ptr()));\n","filename":"src\/hotspot\/share\/memory\/guardedMemory.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -46,0 +47,1 @@\n+ * |+sizeof(uintptr_t) | <tag2>               | Tag word       |\n@@ -52,1 +54,1 @@\n- *  - tag word is general purpose\n+ *  - tag word and tag2 word are general purpose\n@@ -114,0 +116,4 @@\n+      \/\/ We may not be able to dereference directly.\n+      if (!os::is_readable_range((const void*) _guard, (const void*) (_guard + GUARD_SIZE))) {\n+        return false;\n+      }\n@@ -140,0 +146,1 @@\n+    void* _tag2;\n@@ -147,0 +154,2 @@\n+    void set_tag2(const void* tag2) { _tag2 = (void*) tag2; }\n+    void* get_tag2() const { return _tag2; }\n@@ -165,0 +174,1 @@\n+   * @param tag2      optional second general purpose tag.\n@@ -166,2 +176,3 @@\n-  GuardedMemory(void* base_ptr, const size_t user_size, const void* tag = NULL) {\n-    wrap_with_guards(base_ptr, user_size, tag);\n+  GuardedMemory(void* base_ptr, const size_t user_size,\n+                const void* tag = nullptr, const void* tag2 = nullptr) {\n+    wrap_with_guards(base_ptr, user_size, tag, tag2);\n@@ -192,0 +203,1 @@\n+   * @param tag2      optional second general purpose tag.\n@@ -195,1 +207,2 @@\n-  void* wrap_with_guards(void* base_ptr, size_t user_size, const void* tag = NULL) {\n+  void* wrap_with_guards(void* base_ptr, size_t user_size,\n+                         const void* tag = nullptr, const void* tag2 = nullptr) {\n@@ -202,0 +215,1 @@\n+    set_tag2(tag2);\n@@ -233,0 +247,14 @@\n+  \/**\n+   * Set the second general purpose tag.\n+   *\n+   * @param tag general purpose tag.\n+   *\/\n+  void set_tag2(const void* tag) { get_head_guard()->set_tag2(tag); }\n+\n+  \/**\n+   * Return the second general purpose tag.\n+   *\n+   * @return the second general purpose tag, defaults to null.\n+   *\/\n+  void* get_tag2() const { return get_head_guard()->get_tag2(); }\n+\n@@ -308,1 +336,2 @@\n-  static void* wrap_copy(const void* p, const size_t len, const void* tag = NULL);\n+  static void* wrap_copy(const void* p, const size_t len,\n+                         const void* tag = nullptr, const void* tag2 = nullptr);\n","filename":"src\/hotspot\/share\/memory\/guardedMemory.hpp","additions":35,"deletions":6,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -354,0 +354,9 @@\n+\/\/ Arbitrary (but well-known) tag for GetStringChars\n+const void* STRING_TAG = (void*)0x47114711;\n+\n+\/\/ Arbitrary (but well-known) tag for GetStringUTFChars\n+const void* STRING_UTF_TAG = (void*) 0x48124812;\n+\n+\/\/ Arbitrary (but well-known) tag for GetPrimitiveArrayCritical\n+const void* CRITICAL_TAG = (void*)0x49134913;\n+\n@@ -359,1 +368,1 @@\n-    void* orig_elements) {\n+                                       void* orig_elements, jboolean is_critical = JNI_FALSE) {\n@@ -365,1 +374,1 @@\n-    result = GuardedMemory::wrap_copy(orig_elements, len, orig_elements);\n+    result = GuardedMemory::wrap_copy(orig_elements, len, orig_elements, is_critical ? CRITICAL_TAG : nullptr);\n@@ -371,1 +380,1 @@\n-    void* obj, void* carray, size_t* rsz) {\n+                                 void* obj, void* carray, size_t* rsz, jboolean is_critical) {\n@@ -390,0 +399,23 @@\n+  if (orig_result == STRING_TAG || orig_result == STRING_UTF_TAG) {\n+    bool was_utf = orig_result == STRING_UTF_TAG;\n+    tty->print_cr(\"%s: called on something allocated by %s\",\n+                  fn_name, was_utf ? \"GetStringUTFChars\" : \"GetStringChars\");\n+    DEBUG_ONLY(guarded.print_on(tty);) \/\/ This may crash.\n+    NativeReportJNIFatalError(thr, err_msg(\"%s called on something allocated by %s\",\n+                                           fn_name, was_utf ? \"GetStringUTFChars\" : \"GetStringChars\"));\n+  }\n+\n+  if (is_critical && (guarded.get_tag2() != CRITICAL_TAG)) {\n+    tty->print_cr(\"%s: called on something not allocated by GetPrimitiveArrayCritical\", fn_name);\n+    DEBUG_ONLY(guarded.print_on(tty);) \/\/ This may crash.\n+    NativeReportJNIFatalError(thr, err_msg(\"%s called on something not allocated by GetPrimitiveArrayCritical\",\n+                                           fn_name));\n+  }\n+\n+  if (!is_critical && (guarded.get_tag2() == CRITICAL_TAG)) {\n+    tty->print_cr(\"%s: called on something allocated by GetPrimitiveArrayCritical\", fn_name);\n+    DEBUG_ONLY(guarded.print_on(tty);) \/\/ This may crash.\n+    NativeReportJNIFatalError(thr, err_msg(\"%s called on something allocated by GetPrimitiveArrayCritical\",\n+                                           fn_name));\n+  }\n+\n@@ -399,1 +431,1 @@\n-  void* orig_result = check_wrapped_array(thr, fn_name, obj, carray, &sz);\n+  void* orig_result = check_wrapped_array(thr, fn_name, obj, carray, &sz, is_critical);\n@@ -1434,3 +1466,0 @@\n-\/\/ Arbitrary (but well-known) tag\n-const void* STRING_TAG = (void*)0x47114711;\n-\n@@ -1518,3 +1547,0 @@\n-\/\/ Arbitrary (but well-known) tag - different than GetStringChars\n-const void* STRING_UTF_TAG = (void*) 0x48124812;\n-\n@@ -1842,1 +1868,1 @@\n-      result = check_jni_wrap_copy_array(thr, array, result);\n+      result = check_jni_wrap_copy_array(thr, array, result, JNI_TRUE);\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":37,"deletions":11,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-TEST(GuardedMemory, basic) {\n+TEST_VM(GuardedMemory, basic) {\n@@ -83,1 +83,1 @@\n-TEST(GuardedMemory, odd_sizes) {\n+TEST_VM(GuardedMemory, odd_sizes) {\n@@ -104,1 +104,1 @@\n-TEST(GuardedMemory, buffer_overrun_head) {\n+TEST_VM(GuardedMemory, buffer_overrun_head) {\n@@ -116,1 +116,1 @@\n-TEST(GuardedMemory, buffer_overrun_tail) {\n+TEST_VM(GuardedMemory, buffer_overrun_tail) {\n@@ -133,1 +133,1 @@\n-TEST(GuardedMemory, wrap) {\n+TEST_VM(GuardedMemory, wrap) {\n@@ -151,0 +151,7 @@\n+\n+\/\/ Test passing back a bogus GuardedMemory region\n+TEST_VM(GuardedMemory, unmapped) {\n+  char* unmapped_base = (char*) (GuardedMemoryTest::get_guard_header_size() + 0x1000 + 1); \/\/ Avoids assert in constructor\n+  GuardedMemory guarded(unmapped_base);\n+  EXPECT_FALSE(guarded.verify_guards()) << \"Guard was not broken as expected\";\n+}\n","filename":"test\/hotspot\/gtest\/memory\/test_guardedMemory.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8357601\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native TestCharArrayReleasing 0 0\n+ * @run main\/othervm\/native TestCharArrayReleasing 1 0\n+ * @run main\/othervm\/native TestCharArrayReleasing 2 0\n+ * @run main\/othervm\/native TestCharArrayReleasing 3 0\n+ * @run main\/othervm\/native TestCharArrayReleasing 4 0\n+ * @run main\/othervm\/native TestCharArrayReleasing 0 1\n+ * @run main\/othervm\/native TestCharArrayReleasing 1 1\n+ * @run main\/othervm\/native TestCharArrayReleasing 2 1\n+ * @run main\/othervm\/native TestCharArrayReleasing 3 1\n+ * @run main\/othervm\/native TestCharArrayReleasing 4 1\n+ * @run main\/othervm\/native TestCharArrayReleasing 0 2\n+ * @run main\/othervm\/native TestCharArrayReleasing 1 2\n+ * @run main\/othervm\/native TestCharArrayReleasing 2 2\n+ * @run main\/othervm\/native TestCharArrayReleasing 3 2\n+ * @run main\/othervm\/native TestCharArrayReleasing 4 2\n+ * @run main\/othervm\/native TestCharArrayReleasing 0 3\n+ * @run main\/othervm\/native TestCharArrayReleasing 1 3\n+ * @run main\/othervm\/native TestCharArrayReleasing 2 3\n+ * @run main\/othervm\/native TestCharArrayReleasing 3 3\n+ * @run main\/othervm\/native TestCharArrayReleasing 4 3\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/\/ Test the behaviour of the JNI \"char\" releasing functions, under Xcheck:jni,\n+\/\/ when they are passed \"char\" arrays obtained from different sources:\n+\/\/ - source_mode indicates which array to use\n+\/\/   - 0: use a raw malloc'd array\n+\/\/   - 1: use an array from GetCharArrayElements\n+\/\/   - 2: use an array from GetStringChars\n+\/\/   - 3: use an array from GetStringUTFChars\n+\/\/   - 4: use an array from GetPrimitiveArrayCritical\n+\/\/ - release_mode indicates which releasing function to use\n+\/\/   - 0: ReleaseCharArrayElements\n+\/\/   - 1: ReleaseStringChars\n+\/\/   - 2: ReleaseStringUTFChars\n+\/\/   - 3: ReleasePrimitiveArrayCritical\n+\n+public class TestCharArrayReleasing {\n+\n+    static native void testIt(int srcMode, int releaseMode);\n+\n+    static class Driver {\n+\n+        static {\n+            System.loadLibrary(\"CharArrayReleasing\");\n+        }\n+\n+        public static void main(String[] args) {\n+            int srcMode = Integer.parseInt(args[0]);\n+            int relMode = Integer.parseInt(args[1]);\n+            testIt(srcMode, relMode);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        int ABRT = Platform.isWindows() ? 1 : 134;\n+        int[][] errorCodes = new int[][] {\n+            { ABRT, 0, ABRT, ABRT, ABRT },\n+            { ABRT, ABRT, 0, ABRT, ABRT },\n+            { ABRT, ABRT, ABRT, 0, ABRT },\n+            { ABRT, ABRT, ABRT, ABRT, 0 },\n+        };\n+\n+        String rcae = \"ReleaseCharArrayElements called on something allocated by GetStringChars\";\n+        String rcaeUTF = \"ReleaseCharArrayElements called on something allocated by GetStringUTFChars\";\n+        String rcaeCrit = \"ReleaseCharArrayElements called on something allocated by GetPrimitiveArrayCritical\";\n+        String rcaeBounds = \"ReleaseCharArrayElements: release array failed bounds check\";\n+        String rsc = \"ReleaseStringChars called on something not allocated by GetStringChars\";\n+        String rscBounds = \"ReleaseStringChars: release chars failed bounds check\";\n+        String rsuc = \"ReleaseStringUTFChars called on something not allocated by GetStringUTFChars\";\n+        String rsucBounds = \"ReleaseStringUTFChars: release chars failed bounds check\";\n+        String rpac = \"ReleasePrimitiveArrayCritical called on something not allocated by GetPrimitiveArrayCritical\";\n+        String rpacBounds = \"ReleasePrimitiveArrayCritical: release array failed bounds check\";\n+        String rpacStr = \"ReleasePrimitiveArrayCritical called on something allocated by GetStringChars\";\n+        String rpacStrUTF = \"ReleasePrimitiveArrayCritical called on something allocated by GetStringUTFChars\";\n+\n+        String[][] errorMsgs = new String[][] {\n+            { rcaeBounds, \"\", rcae, rcaeUTF, rcaeCrit },\n+            { rscBounds, rsc, \"\", rsc, rsc },\n+            { rsucBounds, rsuc, rsuc, \"\", rsuc },\n+            { rpacBounds, rpac, rpacStr, rpacStrUTF, \"\" },\n+        };\n+\n+        int srcMode = Integer.parseInt(args[0]);\n+        int relMode = Integer.parseInt(args[1]);\n+\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+             \"-Djava.library.path=\" + System.getProperty(\"test.nativepath\"),\n+             \"--enable-native-access=ALL-UNNAMED\",\n+             \"-Xcheck:jni\",\n+             \"TestCharArrayReleasing$Driver\",\n+             args[0], args[1]);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(errorCodes[relMode][srcMode]);\n+        output.shouldContain(errorMsgs[relMode][srcMode]);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/TestCharArrayReleasing.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+\n+\/\/ Test the behaviour of the JNI \"char\" releasing functions, under Xcheck:jni,\n+\/\/ when they are passed \"char\" arrays obtained from different sources:\n+\/\/ - source_mode indicates which array to use\n+\/\/   - 0: use a raw malloc'd array\n+\/\/   - 1: use an array from GetCharArrayElements\n+\/\/   - 2: use an array from GetStringChars\n+\/\/   - 3: use an array from GetStringUTFChars\n+\/\/   - 4: use an array from GetPrimitiveArrayCritical\n+\/\/ - release_mode indicates which releasing function to use\n+\/\/   - 0: ReleaseCharArrayElements\n+\/\/   - 1: ReleaseStringChars\n+\/\/   - 2: ReleaseStringUTFChars\n+\/\/   - 3: ReleasePrimitiveArrayCritical\n+\/\/\n+\n+static char* source[] = {\n+  \"malloc\",\n+  \"GetCharArrayElements\",\n+  \"GetStringChars\",\n+  \"GetStringUTFChars\",\n+  \"GetPrimitiveArrayCritical\"\n+};\n+\n+static char* release_func[] = {\n+  \"ReleaseCharArrayElements\",\n+  \"ReleaseStringChars\",\n+  \"ReleaseStringUTFChars\",\n+  \"ReleasePrimitiveArrayCritical\"\n+};\n+\n+JNIEXPORT void JNICALL\n+Java_TestCharArrayReleasing_testIt(JNIEnv *env, jclass cls, jint source_mode,\n+                               jint release_mode) {\n+\n+  \/\/ First create some Java objects to be used as the sources for jchar[]\n+  \/\/ extraction.\n+  const int len = 10;\n+  jcharArray ca = (*env)->NewCharArray(env, len);\n+  jstring str = (*env)->NewStringUTF(env, \"A_String\");\n+\n+  jthrowable exc = (*env)->ExceptionOccurred(env);\n+  if (exc != NULL) {\n+    fprintf(stderr, \"ERROR: Unexpected exception during test set up:\\n\");\n+    (*env)->ExceptionDescribe(env);\n+    exit(2);\n+  }\n+\n+  fprintf(stdout, \"Testing release function %s with array from %s\\n\",\n+          release_func[release_mode], source[source_mode]);\n+  fflush(stdout);\n+\n+  jboolean is_copy = JNI_FALSE;\n+  jchar* to_release;\n+  switch(source_mode) {\n+  case 0: {\n+    to_release = malloc(10 * sizeof(jchar));\n+    break;\n+  }\n+  case 1: {\n+    to_release = (*env)->GetCharArrayElements(env, ca, &is_copy);\n+    break;\n+  }\n+  case 2: {\n+    to_release = (jchar*) (*env)->GetStringChars(env, str, &is_copy);\n+    break;\n+  }\n+  case 3: {\n+    to_release = (jchar*) (*env)->GetStringUTFChars(env, str, &is_copy);\n+    break;\n+  }\n+  case 4: {\n+    to_release = (jchar*) (*env)->GetPrimitiveArrayCritical(env, ca, &is_copy);\n+    break;\n+  }\n+  default: fprintf(stderr, \"Unexpected source_mode %d\\n\", source_mode);\n+    exit(1);\n+  }\n+\n+  switch (release_mode) {\n+  case 0:\n+    (*env)->ReleaseCharArrayElements(env, ca, to_release, 0);\n+    break;\n+  case 1:\n+    (*env)->ReleaseStringChars(env, str, to_release);\n+    break;\n+  case 2:\n+    (*env)->ReleaseStringUTFChars(env, str, (const char*)to_release);\n+    break;\n+  case 3:\n+    (*env)->ReleasePrimitiveArrayCritical(env, ca, to_release, 0);\n+    break;\n+  default: fprintf(stderr, \"Unexpected release_mode %d\\n\", source_mode);\n+    exit(1);\n+  }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/libCharArrayReleasing.c","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"}]}