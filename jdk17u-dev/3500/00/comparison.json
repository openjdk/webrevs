{"files":[{"patch":"@@ -114,1 +114,13 @@\n-jlong CgroupV1Subsystem::memory_and_swap_limit_in_bytes() {\n+\/* read_mem_swap\n+ *\n+ * Determine the memory and swap limit metric. Returns a positive limit value strictly\n+ * lower than the physical memory and swap limit iff there is a limit. Otherwise a\n+ * negative value is returned indicating the determined status.\n+ *\n+ * returns:\n+ *    * A number > 0 if the limit is available and lower than a physical upper bound.\n+ *    * OSCONTAINER_ERROR if the limit cannot be retrieved (i.e. not supported) or\n+ *    * -1 if there isn't any limit in place (note: includes values which exceed a physical\n+ *      upper bound)\n+ *\/\n+jlong CgroupV1Subsystem::read_mem_swap() {\n@@ -129,8 +141,0 @@\n-        jlong swappiness = read_mem_swappiness();\n-        if (swappiness == 0) {\n-            const char* matchmemline = \"hierarchical_memory_limit\";\n-            GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", matchmemline,\n-                             \"Hierarchical Memory Limit is : \" JULONG_FORMAT, JULONG_FORMAT, hier_memlimit)\n-            log_trace(os, container)(\"Memory and Swap Limit has been reset to \" JULONG_FORMAT \" because swappiness is 0\", hier_memlimit);\n-            return (jlong)hier_memlimit;\n-        }\n@@ -142,6 +146,0 @@\n-    jlong swappiness = read_mem_swappiness();\n-    if (swappiness == 0) {\n-      jlong memlimit = read_memory_limit_in_bytes();\n-      log_trace(os, container)(\"Memory and Swap Limit has been reset to \" JULONG_FORMAT \" because swappiness is 0\", memlimit);\n-      return memlimit;\n-    }\n@@ -152,0 +150,21 @@\n+jlong CgroupV1Subsystem::memory_and_swap_limit_in_bytes() {\n+  jlong memory_swap = read_mem_swap();\n+  if (memory_swap == -1) {\n+    return memory_swap;\n+  }\n+  \/\/ If there is a swap limit, but swappiness == 0, reset the limit\n+  \/\/ to the memory limit. Do the same for cases where swap isn't\n+  \/\/ supported.\n+  jlong swappiness = read_mem_swappiness();\n+  if (swappiness == 0 || memory_swap == OSCONTAINER_ERROR) {\n+    jlong memlimit = read_memory_limit_in_bytes();\n+    if (memory_swap == OSCONTAINER_ERROR) {\n+      log_trace(os, container)(\"Memory and Swap Limit has been reset to \" JLONG_FORMAT \" because swap is not supported\", memlimit);\n+    } else {\n+      log_trace(os, container)(\"Memory and Swap Limit has been reset to \" JLONG_FORMAT \" because swappiness is 0\", memlimit);\n+    }\n+    return memlimit;\n+  }\n+  return memory_swap;\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":34,"deletions":15,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+    jlong read_mem_swap();\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -155,0 +155,6 @@\n+  if (mem_swp_limit_str == nullptr) {\n+    \/\/ Some container tests rely on this trace logging to happen.\n+    log_trace(os, container)(\"Memory and Swap Limit is: %d\", OSCONTAINER_ERROR);\n+    \/\/ swap disabled at kernel level, treat it as no swap\n+    return read_memory_limit_in_bytes();\n+  }\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,0 +80,2 @@\n+            testMemorySwapNotSupported(\"500m\", \"520m\", \"512000 k\", \"532480 k\");\n+\n@@ -157,0 +159,23 @@\n+    \/*\n+     * Verifies that PrintContainerInfo prints the memory\n+     * limit - without swap - iff swap is disabled (e.g. via swapaccount=0). It must\n+     * not print 'not supported' for that value in that case. It'll always pass\n+     * on systems with swap accounting enabled.\n+     *\/\n+    private static void testMemorySwapNotSupported(String valueToSet, String swapToSet, String expectedMem, String expectedSwap)\n+            throws Exception {\n+        Common.logNewTestCase(\"memory swap not supported: \" + valueToSet);\n+\n+        DockerRunOptions opts = Common.newOpts(imageName, \"PrintContainerInfo\");\n+        Common.addWhiteBoxOpts(opts);\n+        opts.addDockerOpts(\"--memory=\" + valueToSet);\n+        opts.addDockerOpts(\"--memory-swap=\" + swapToSet);\n+\n+        Common.run(opts)\n+            .shouldMatch(\"memory_limit_in_bytes:.*\" + expectedMem)\n+            .shouldNotMatch(\"memory_and_swap_limit_in_bytes:.*not supported\")\n+            \/\/ On systems with swapaccount=0 this returns the memory limit.\n+            \/\/ On systems with swapaccount=1 this returns the set memory+swap value.\n+            .shouldMatch(\"memory_and_swap_limit_in_bytes:.*(\" + expectedMem + \"|\" + expectedSwap + \")\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMemoryAwareness.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-            if (out.getOutput().contains(\"memory_and_swap_limit_in_bytes: not supported\")) {\n-                System.out.println(\"memory_and_swap_limit_in_bytes not supported, avoiding Memory and Swap Limit check\");\n+            if (out.getOutput().contains(\"Memory and Swap Limit is: -2\")) {\n+                System.out.println(\"System doesn't seem to allow swap, avoiding Memory and Swap Limit check\");\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMemoryWithCgroupV1.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}