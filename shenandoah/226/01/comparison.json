{"files":[{"patch":"@@ -39,3 +39,0 @@\n-#ifdef ASSERT\n-  _start_candidate(0),\n-#endif\n@@ -125,6 +122,9 @@\n-  \/\/ Find the leftmost unpinned region. The region in this slot will have been\n-  \/\/ added to the cset, so we can use it to hold pointers to regions that were\n-  \/\/ pinned when the cset was chosen.\n-  \/\/ [ r p r p p p r ]\n-  \/\/          ^\n-  \/\/          | first r to the left should be in the collection set now.\n+  \/\/ Find the first unpinned region to the left of the next region that\n+  \/\/ will be added to the collection set. These regions will have been\n+  \/\/ added to the cset, so we can use them to hold pointers to regions\n+  \/\/ that were pinned when the cset was chosen.\n+  \/\/ [ r p r p p p r r ]\n+  \/\/     ^         ^ ^\n+  \/\/     |         | | pointer to next region to add to a mixed collection is here.\n+  \/\/     |         | first r to the left should be in the collection set now.\n+  \/\/     | first pinned region, we don't need to look past this\n@@ -141,0 +141,5 @@\n+  \/\/ If we could not find an unpinned region, it means there are no slots available\n+  \/\/ to move up the pinned regions. In this case, we just reset our next index in the\n+  \/\/ hopes that some of these regions will become unpinned before the next mixed\n+  \/\/ collection. We may want to bailout of here instead, as it should be quite\n+  \/\/ rare to have so many pinned regions and may indicate something is wrong.\n@@ -142,3 +147,2 @@\n-    if (_first_pinned_candidate > 0) {\n-      _next_old_collection_candidate = _first_pinned_candidate;\n-    }\n+    assert(_first_pinned_candidate != NOT_FOUND, \"Should only be here if there are pinned regions.\");\n+    _next_old_collection_candidate = _first_pinned_candidate;\n@@ -149,6 +153,9 @@\n-  \/\/ that was pointing at a region that has been added to the cset.\n-  \/\/ [ r p r p p p r ]\n-  \/\/       ^\n-  \/\/       | Write pointer is here. We know this region is already in the cset\n-  \/\/       | so we can clobber it with the next pinned region we find.\n-  for (size_t search = write_index - 1; search > _first_pinned_candidate; --search) {\n+  \/\/ that was pointing at a region that has been added to the cset (or was pointing\n+  \/\/ to a pinned region that we've already moved up). We are done when the leftmost\n+  \/\/ pinned region has been slid up.\n+  \/\/ [ r p r x p p p r ]\n+  \/\/         ^       ^\n+  \/\/         |       | next region for mixed collections\n+  \/\/         | Write pointer is here. We know this region is already in the cset\n+  \/\/         | so we can clobber it with the next pinned region we find.\n+  for (int32_t search = write_index - 1; search >= (int32_t)_first_pinned_candidate; --search) {\n@@ -157,4 +164,3 @@\n-      RegionData& added_to_cset = _region_data[write_index];\n-      assert(added_to_cset._region->is_cset(), \"Can only overwrite slots used by regions added to the collection set.\");\n-      added_to_cset._region = skipped._region;\n-      added_to_cset._garbage = skipped._garbage;\n+      RegionData& available_slot = _region_data[write_index];\n+      available_slot._region = skipped._region;\n+      available_slot._garbage = skipped._garbage;\n@@ -165,15 +171,4 @@\n-  \/\/ Everything left should already be in the cset\n-  \/\/ [ r x p p p p r ]\n-  \/\/       ^\n-  \/\/       | next pointer points at the first region which was not added\n-  \/\/       | to the collection set.\n-#ifdef ASSERT\n-  for (size_t check = write_index - 1; check > _start_candidate; --check) {\n-    ShenandoahHeapRegion* region = _region_data[check]._region;\n-    assert(region->is_cset(), \"All regions here should be in the collection set.\");\n-  }\n-  _start_candidate = write_index;\n-#endif\n-\n-  \/\/ Update to read from the leftmost pinned region.\n-  _next_old_collection_candidate = write_index;\n+  \/\/ Update to read from the leftmost pinned region. Plus one here because we decremented\n+  \/\/ the write index to hold the next found pinned region. We are just moving it back now\n+  \/\/ to point to the first pinned region.\n+  _next_old_collection_candidate = write_index + 1;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":32,"deletions":37,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -51,4 +51,0 @@\n-  \/\/ This points to the first candidate of the current mixed collection. This\n-  \/\/ is only used for an assertion when handling pinned regions.\n-  debug_only(uint _start_candidate);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,0 +8,1 @@\n+#include <cstdarg>\n@@ -13,1 +14,1 @@\n-\/\/ % _JAVA_OPTIONS=\"-XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\" make exploded-test TEST=\"gtest:Shenandoah*\"\n+\/\/ % make exploded-test TEST=\"gtest:ShenandoahOld*\" CONF=release TEST_OPTS=\"JAVA_OPTIONS=-XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\"\n@@ -113,0 +114,20 @@\n+\n+  bool collection_set_is(size_t r1) { return _collection_set_is(1, r1); }\n+  bool collection_set_is(size_t r1, size_t r2) { return _collection_set_is(2, r1, r2); }\n+  bool collection_set_is(size_t r1, size_t r2, size_t r3) { return _collection_set_is(3, r1, r2, r3); }\n+\n+  bool _collection_set_is(size_t count, ...) {\n+    va_list args;\n+    va_start(args, count);\n+    EXPECT_EQ(count, _collection_set->count());\n+    bool result = true;\n+    for (size_t i = 0; i < count; ++i) {\n+      size_t index = va_arg(args, size_t);\n+      if (!_collection_set->is_in(index)) {\n+        result = false;\n+        break;\n+      }\n+    }\n+    va_end(args);\n+    return result;\n+  }\n@@ -153,0 +174,1 @@\n+  EXPECT_TRUE(collection_set_is(10UL));\n@@ -165,0 +187,1 @@\n+  EXPECT_TRUE(collection_set_is(100UL, 101UL));\n@@ -184,3 +207,3 @@\n-  size_t g1 = make_garbage_above_threshold(1);\n-  size_t g2 = make_garbage_above_threshold(2);\n-  size_t g3 = make_garbage_above_threshold(3);\n+  size_t g1 = make_garbage_above_threshold(0);\n+  size_t g2 = make_garbage_above_threshold(1);\n+  size_t g3 = make_garbage_above_threshold(2);\n@@ -189,1 +212,1 @@\n-  make_pinned(2);\n+  make_pinned(1);\n@@ -192,1 +215,1 @@\n-  \/\/ We only excluded pinned regions when we actually add regions to the collection set.\n+  \/\/ We only exclude pinned regions when we actually add regions to the collection set.\n@@ -201,0 +224,1 @@\n+  EXPECT_TRUE(collection_set_is(0UL, 2UL));\n@@ -204,1 +228,1 @@\n-  \/\/ Simulate another mixed collection after making region 2 unpinned. This time,\n+  \/\/ Simulate another mixed collection after making region 1 unpinned. This time,\n@@ -206,1 +230,1 @@\n-  make_unpinned(2);\n+  make_unpinned(1);\n@@ -211,0 +235,1 @@\n+  EXPECT_TRUE(collection_set_is(1UL));\n@@ -218,3 +243,3 @@\n-  size_t g1 = make_garbage_above_threshold(1);\n-  size_t g2 = make_garbage_above_threshold(2);\n-  size_t g3 = make_garbage_above_threshold(3);\n+  size_t g1 = make_garbage_above_threshold(0);\n+  size_t g2 = make_garbage_above_threshold(1);\n+  size_t g3 = make_garbage_above_threshold(2);\n@@ -222,1 +247,1 @@\n-  make_pinned(1);\n+  make_pinned(0);\n@@ -226,1 +251,1 @@\n-  EXPECT_EQ(_collection_set->get_old_garbage(), g2 + g3);\n+  EXPECT_TRUE(collection_set_is(1UL, 2UL));\n@@ -229,1 +254,1 @@\n-  make_unpinned(1);\n+  make_unpinned(0);\n@@ -233,1 +258,1 @@\n-  EXPECT_EQ(_collection_set->get_old_garbage(), g1);\n+  EXPECT_TRUE(collection_set_is(0UL));\n@@ -241,3 +266,3 @@\n-  size_t g1 = make_garbage_above_threshold(1);\n-  size_t g2 = make_garbage_above_threshold(2);\n-  size_t g3 = make_garbage_above_threshold(3);\n+  size_t g1 = make_garbage_above_threshold(0);\n+  size_t g2 = make_garbage_above_threshold(1);\n+  size_t g3 = make_garbage_above_threshold(2);\n@@ -245,1 +270,1 @@\n-  make_pinned(3);\n+  make_pinned(2);\n@@ -249,0 +274,1 @@\n+  EXPECT_TRUE(collection_set_is(0UL, 1UL));\n@@ -252,1 +278,1 @@\n-  make_unpinned(3);\n+  make_unpinned(2);\n@@ -256,0 +282,1 @@\n+  EXPECT_TRUE(collection_set_is(2UL));\n@@ -264,3 +291,3 @@\n-  size_t g1 = make_garbage_above_threshold(1);\n-  size_t g2 = make_garbage_above_threshold(2);\n-  size_t g3 = make_garbage_above_threshold(3);\n+  size_t g1 = make_garbage_above_threshold(0);\n+  size_t g2 = make_garbage_above_threshold(1);\n+  size_t g3 = make_garbage_above_threshold(2);\n@@ -268,2 +295,2 @@\n-  make_pinned(1);\n-  make_pinned(3);\n+  make_pinned(0);\n+  make_pinned(2);\n@@ -273,0 +300,1 @@\n+  EXPECT_TRUE(collection_set_is(1UL));\n@@ -276,2 +304,2 @@\n-  make_unpinned(1);\n-  make_unpinned(3);\n+  make_unpinned(0);\n+  make_unpinned(2);\n@@ -281,0 +309,1 @@\n+  EXPECT_TRUE(collection_set_is(0UL, 2UL));\n@@ -285,1 +314,1 @@\n-#undef SKIP_IF_NOT_SHENANDOAH\n\\ No newline at end of file\n+#undef SKIP_IF_NOT_SHENANDOAH\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahOldHeuristic.cpp","additions":57,"deletions":28,"binary":false,"changes":85,"status":"modified"}]}