{"files":[{"patch":"@@ -125,6 +125,9 @@\n-  \/\/ Find the leftmost unpinned region. The region in this slot will have been\n-  \/\/ added to the cset, so we can use it to hold pointers to regions that were\n-  \/\/ pinned when the cset was chosen.\n-  \/\/ [ r p r p p p r ]\n-  \/\/          ^\n-  \/\/          | first r to the left should be in the collection set now.\n+  \/\/ Find the first unpinned region to the left of the next region that\n+  \/\/ will be added to the collection set. These regions will have been\n+  \/\/ added to the cset, so we can use them to hold pointers to regions\n+  \/\/ that were pinned when the cset was chosen.\n+  \/\/ [ r p r p p p r r ]\n+  \/\/     ^         ^ ^\n+  \/\/     |         | | pointer to next region to add to a mixed collection is here.\n+  \/\/     |         | first r to the left should be in the collection set now.\n+  \/\/     | first pinned region, we don't need to look past this\n@@ -141,0 +144,5 @@\n+  \/\/ If we could not find an unpinned region, it means there are no slots available\n+  \/\/ to move up the pinned regions. In this case, we just reset our next index in the\n+  \/\/ hopes that some of these regions will become unpinned before the next mixed\n+  \/\/ collection. We may want to bailout of here instead, as it should be quite\n+  \/\/ rare to have so many pinned regions and may indicate something is wrong.\n@@ -142,3 +150,2 @@\n-    if (_first_pinned_candidate > 0) {\n-      _next_old_collection_candidate = _first_pinned_candidate;\n-    }\n+    assert(_first_pinned_candidate != NOT_FOUND, \"Should only be here if there are pinned regions.\");\n+    _next_old_collection_candidate = _first_pinned_candidate;\n@@ -149,6 +156,8 @@\n-  \/\/ that was pointing at a region that has been added to the cset.\n-  \/\/ [ r p r p p p r ]\n-  \/\/       ^\n-  \/\/       | Write pointer is here. We know this region is already in the cset\n-  \/\/       | so we can clobber it with the next pinned region we find.\n-  for (size_t search = write_index - 1; search > _first_pinned_candidate; --search) {\n+  \/\/ that was pointing at a region that has been added to the cset. We\n+  \/\/ are done when the leftmost pinned region has been slid up.\n+  \/\/ [ r p r x p p p r ]\n+  \/\/         ^       ^\n+  \/\/         |       | next region for mixed collections\n+  \/\/         | Write pointer is here. We know this region is already in the cset\n+  \/\/         | so we can clobber it with the next pinned region we find.\n+  for (int32_t search = write_index - 1; search >= (int32_t)_first_pinned_candidate; --search) {\n@@ -165,0 +174,5 @@\n+  \/\/ Update to read from the leftmost pinned region. Plus one here because we decremented\n+  \/\/ the write index to hold the next found pinned region. We are just moving it back now\n+  \/\/ to point to the first pinned region.\n+  _next_old_collection_candidate = write_index + 1;\n+\n@@ -166,4 +180,5 @@\n-  \/\/ [ r x p p p p r ]\n-  \/\/       ^\n-  \/\/       | next pointer points at the first region which was not added\n-  \/\/       | to the collection set.\n+  \/\/ [ r x x p p p p r ]\n+  \/\/   ^   ^         ^\n+  \/\/   |   |         | next pointer points at the first region which was not added to the collection set.\n+  \/\/   |   | After the above loop, the write pointer is just left of the start of the pinned regions\n+  \/\/   | Start index maintains the pointer to the beginning of the regions we scanned on this cycle.\n@@ -171,1 +186,1 @@\n-  for (size_t check = write_index - 1; check > _start_candidate; --check) {\n+  for (size_t check = write_index; check != _start_candidate; --check) {\n@@ -175,1 +190,1 @@\n-  _start_candidate = write_index;\n+  _start_candidate = _next_old_collection_candidate;\n@@ -177,3 +192,0 @@\n-\n-  \/\/ Update to read from the leftmost pinned region.\n-  _next_old_collection_candidate = write_index;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":36,"deletions":24,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -8,0 +8,1 @@\n+#include <cstdarg>\n@@ -13,1 +14,1 @@\n-\/\/ % _JAVA_OPTIONS=\"-XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\" make exploded-test TEST=\"gtest:Shenandoah*\"\n+\/\/ % make exploded-test TEST=\"gtest:ShenandoahOld*\" CONF=release TEST_OPTS=\"JAVA_OPTIONS=-XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational\"\n@@ -113,0 +114,20 @@\n+\n+  bool collection_set_is(size_t r1) { return _collection_set_is(1, r1); }\n+  bool collection_set_is(size_t r1, size_t r2) { return _collection_set_is(2, r1, r2); }\n+  bool collection_set_is(size_t r1, size_t r2, size_t r3) { return _collection_set_is(3, r1, r2, r3); }\n+\n+  bool _collection_set_is(size_t count, ...) {\n+    va_list args;\n+    va_start(args, count);\n+    EXPECT_EQ(count, _collection_set->count());\n+    bool result = true;\n+    for (size_t i = 0; i < count; ++i) {\n+      size_t index = va_arg(args, size_t);\n+      if (!_collection_set->is_in(index)) {\n+        result = false;\n+        break;\n+      }\n+    }\n+    va_end(args);\n+    return result;\n+  }\n@@ -153,0 +174,1 @@\n+  EXPECT_TRUE(collection_set_is(10UL));\n@@ -165,0 +187,1 @@\n+  EXPECT_TRUE(collection_set_is(100UL, 101UL));\n@@ -184,3 +207,3 @@\n-  size_t g1 = make_garbage_above_threshold(1);\n-  size_t g2 = make_garbage_above_threshold(2);\n-  size_t g3 = make_garbage_above_threshold(3);\n+  size_t g1 = make_garbage_above_threshold(0);\n+  size_t g2 = make_garbage_above_threshold(1);\n+  size_t g3 = make_garbage_above_threshold(2);\n@@ -189,1 +212,1 @@\n-  make_pinned(2);\n+  make_pinned(1);\n@@ -192,1 +215,1 @@\n-  \/\/ We only excluded pinned regions when we actually add regions to the collection set.\n+  \/\/ We only exclude pinned regions when we actually add regions to the collection set.\n@@ -201,0 +224,1 @@\n+  EXPECT_TRUE(collection_set_is(0UL, 2UL));\n@@ -204,1 +228,1 @@\n-  \/\/ Simulate another mixed collection after making region 2 unpinned. This time,\n+  \/\/ Simulate another mixed collection after making region 1 unpinned. This time,\n@@ -206,1 +230,1 @@\n-  make_unpinned(2);\n+  make_unpinned(1);\n@@ -211,0 +235,1 @@\n+  EXPECT_TRUE(collection_set_is(1UL));\n@@ -218,3 +243,3 @@\n-  size_t g1 = make_garbage_above_threshold(1);\n-  size_t g2 = make_garbage_above_threshold(2);\n-  size_t g3 = make_garbage_above_threshold(3);\n+  size_t g1 = make_garbage_above_threshold(0);\n+  size_t g2 = make_garbage_above_threshold(1);\n+  size_t g3 = make_garbage_above_threshold(2);\n@@ -222,1 +247,1 @@\n-  make_pinned(1);\n+  make_pinned(0);\n@@ -226,1 +251,1 @@\n-  EXPECT_EQ(_collection_set->get_old_garbage(), g2 + g3);\n+  EXPECT_TRUE(collection_set_is(1UL, 2UL));\n@@ -229,1 +254,1 @@\n-  make_unpinned(1);\n+  make_unpinned(0);\n@@ -233,1 +258,1 @@\n-  EXPECT_EQ(_collection_set->get_old_garbage(), g1);\n+  EXPECT_TRUE(collection_set_is(0UL));\n@@ -241,3 +266,3 @@\n-  size_t g1 = make_garbage_above_threshold(1);\n-  size_t g2 = make_garbage_above_threshold(2);\n-  size_t g3 = make_garbage_above_threshold(3);\n+  size_t g1 = make_garbage_above_threshold(0);\n+  size_t g2 = make_garbage_above_threshold(1);\n+  size_t g3 = make_garbage_above_threshold(2);\n@@ -245,1 +270,1 @@\n-  make_pinned(3);\n+  make_pinned(2);\n@@ -249,0 +274,1 @@\n+  EXPECT_TRUE(collection_set_is(0UL, 1UL));\n@@ -252,1 +278,1 @@\n-  make_unpinned(3);\n+  make_unpinned(2);\n@@ -256,0 +282,1 @@\n+  EXPECT_TRUE(collection_set_is(2UL));\n@@ -264,3 +291,3 @@\n-  size_t g1 = make_garbage_above_threshold(1);\n-  size_t g2 = make_garbage_above_threshold(2);\n-  size_t g3 = make_garbage_above_threshold(3);\n+  size_t g1 = make_garbage_above_threshold(0);\n+  size_t g2 = make_garbage_above_threshold(1);\n+  size_t g3 = make_garbage_above_threshold(2);\n@@ -268,2 +295,2 @@\n-  make_pinned(1);\n-  make_pinned(3);\n+  make_pinned(0);\n+  make_pinned(2);\n@@ -273,0 +300,1 @@\n+  EXPECT_TRUE(collection_set_is(1UL));\n@@ -276,2 +304,2 @@\n-  make_unpinned(1);\n-  make_unpinned(3);\n+  make_unpinned(0);\n+  make_unpinned(2);\n@@ -281,0 +309,1 @@\n+  EXPECT_TRUE(collection_set_is(0UL, 2UL));\n@@ -285,1 +314,1 @@\n-#undef SKIP_IF_NOT_SHENANDOAH\n\\ No newline at end of file\n+#undef SKIP_IF_NOT_SHENANDOAH\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahOldHeuristic.cpp","additions":57,"deletions":28,"binary":false,"changes":85,"status":"modified"}]}