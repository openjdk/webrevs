{"files":[{"patch":"@@ -191,0 +191,1 @@\n+\n@@ -195,0 +196,3 @@\n+    \/\/ Evacuation is complete, retire gc labs\n+    heap->concurrent_prepare_for_update_refs();\n+\n@@ -1060,1 +1064,0 @@\n-  heap->prepare_update_heap_references(true \/*concurrent*\/);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -641,0 +641,3 @@\n+\n+  \/\/ Note that the safepoint workers may require gclabs if the threads are used to create a heap dump\n+  \/\/ during a concurrent evacuation phase.\n@@ -1213,0 +1216,41 @@\n+class ShenandoahRetireGCLABClosure : public ThreadClosure {\n+private:\n+  bool const _resize;\n+public:\n+  explicit ShenandoahRetireGCLABClosure(bool resize) : _resize(resize) {}\n+  void do_thread(Thread* thread) override {\n+    PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);\n+    assert(gclab != nullptr, \"GCLAB should be initialized for %s\", thread->name());\n+    gclab->retire();\n+    if (_resize && ShenandoahThreadLocalData::gclab_size(thread) > 0) {\n+      ShenandoahThreadLocalData::set_gclab_size(thread, 0);\n+    }\n+\n+    if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+      PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n+      assert(plab != nullptr, \"PLAB should be initialized for %s\", thread->name());\n+\n+      \/\/ There are two reasons to retire all plabs between old-gen evacuation passes.\n+      \/\/  1. We need to make the plab memory parsable by remembered-set scanning.\n+      \/\/  2. We need to establish a trustworthy UpdateWaterMark value within each old-gen heap region\n+      ShenandoahGenerationalHeap::heap()->retire_plab(plab, thread);\n+      if (_resize && ShenandoahThreadLocalData::plab_size(thread) > 0) {\n+        ShenandoahThreadLocalData::set_plab_size(thread, 0);\n+      }\n+    }\n+  }\n+};\n+\n+class ShenandoahPrepareForUpdateRefs : public HandshakeClosure {\n+private:\n+  ShenandoahRetireGCLABClosure _retire;\n+public:\n+  explicit ShenandoahPrepareForUpdateRefs() :\n+    HandshakeClosure(\"Shenandoah Retire Java GC LABs\"),\n+    _retire(ResizeTLAB) {}\n+\n+  void do_thread(Thread* thread) override {\n+    _retire.do_thread(thread);\n+  }\n+};\n+\n@@ -1218,0 +1262,19 @@\n+void ShenandoahHeap::concurrent_prepare_for_update_refs() {\n+  \/\/ It is possible that the GC has been cancelled after the last cancellation check after evacuation.\n+  \/\/ However, it will not have been cancelled for an evacuation failure so the degenerated cycle will\n+  \/\/ resume from update refs.\n+  ShenandoahPrepareForUpdateRefs prepare_for_update_refs;\n+  workers()->threads_do(&prepare_for_update_refs);\n+\n+  \/\/ Safepoint workers may be asked to evacuate objects if they are visiting oops to create a heap dump\n+  \/\/ during a concurrent evacuation phase. These threads will _not_ be used during a degenerated cycle.\n+  if (safepoint_workers() != nullptr) {\n+    safepoint_workers()->threads_do(&prepare_for_update_refs);\n+  }\n+\n+  \/\/ A degenerated cycle won't attempt to use LABs from the mutator threads\n+  Handshake::execute(&prepare_for_update_refs);\n+\n+  _update_refs_iterator.reset();\n+}\n+\n@@ -1372,28 +1435,0 @@\n-class ShenandoahRetireGCLABClosure : public ThreadClosure {\n-private:\n-  bool const _resize;\n-public:\n-  ShenandoahRetireGCLABClosure(bool resize) : _resize(resize) {}\n-  void do_thread(Thread* thread) {\n-    PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);\n-    assert(gclab != nullptr, \"GCLAB should be initialized for %s\", thread->name());\n-    gclab->retire();\n-    if (_resize && ShenandoahThreadLocalData::gclab_size(thread) > 0) {\n-      ShenandoahThreadLocalData::set_gclab_size(thread, 0);\n-    }\n-\n-    if (ShenandoahHeap::heap()->mode()->is_generational()) {\n-      PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n-      assert(plab != nullptr, \"PLAB should be initialized for %s\", thread->name());\n-\n-      \/\/ There are two reasons to retire all plabs between old-gen evacuation passes.\n-      \/\/  1. We need to make the plab memory parsable by remembered-set scanning.\n-      \/\/  2. We need to establish a trustworthy UpdateWaterMark value within each old-gen heap region\n-      ShenandoahGenerationalHeap::heap()->retire_plab(plab, thread);\n-      if (_resize && ShenandoahThreadLocalData::plab_size(thread) > 0) {\n-        ShenandoahThreadLocalData::set_plab_size(thread, 0);\n-      }\n-    }\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":63,"deletions":28,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -480,0 +480,4 @@\n+\n+  \/\/ Retires LABs used for evacuation\n+  void concurrent_prepare_for_update_refs();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}