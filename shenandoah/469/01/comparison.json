{"files":[{"patch":"@@ -77,1 +77,0 @@\n-  \/\/ TODO: can we directly test if bit is set?\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -114,4 +114,0 @@\n-  \/\/ TODO: We need to enhance this API to give visibility to accompanying old-gen evacuation effort.\n-  \/\/ In the case that the old-gen evacuation effort is small or zero, the young-gen heuristics\n-  \/\/ should feel free to dedicate increased efforts to young-gen evacuation.\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -370,4 +370,0 @@\n-  \/\/ TODO: Consider not running mixed collects if we recovered some threshold percentage of memory from immediate garbage.\n-  \/\/ This would be similar to young and global collections shortcutting evacuation, though we'd probably want a separate\n-  \/\/ threshold for the old generation.\n-\n@@ -381,5 +377,0 @@\n-  \/\/ Any old-gen region that contains (ShenandoahOldGarbageThreshold (default value 25)% garbage or more is to be\n-  \/\/ added to the list of candidates for subsequent mixed evacuations.\n-  \/\/\n-  \/\/ TODO: allow ShenandoahOldGarbageThreshold to be determined adaptively, by heuristics.\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -212,9 +212,0 @@\n-\n-  \/\/ TODO: Consider making conservative adjustments to avg_cycle_time, such as: (avg_cycle_time *= 2) in cases where\n-  \/\/ we expect a longer-than-normal GC duration.  This includes mixed evacuations, evacuation that perform promotion\n-  \/\/ including promotion in place, and OLD GC bootstrap cycles.  It has been observed that these cycles sometimes\n-  \/\/ require twice or more the duration of \"normal\" GC cycles.  We have experimented with this approach.  While it\n-  \/\/ does appear to reduce the frequency of degenerated cycles due to late triggers, it also has the effect of reducing\n-  \/\/ evacuation slack so that there is less memory available to be transferred to OLD.  The result is that we\n-  \/\/ throttle promotion and it takes too long to move old objects out of the young generation.\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -443,17 +443,0 @@\n-  if (ShenandoahSafepoint::is_at_shenandoah_safepoint() && Thread::current()->is_VM_thread()) {\n-    return;\n-  }\n-\n-  ShenandoahMessageBuffer msg(\"Heap lock must be owned by current thread, or be at safepoint\");\n-  report_vm_error(file, line, msg.buffer());\n-}\n-\n-\/\/ Unlike assert_heaplocked_or_safepoint(), this does not require current thread in safepoint to be a VM thread\n-\/\/ TODO: This should be more aptly named. Nothing in this method checks we are actually in Full GC.\n-void ShenandoahAsserts::assert_heaplocked_or_fullgc_safepoint(const char* file, int line) {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n-  if (heap->lock()->owned_by_self()) {\n-    return;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -76,1 +76,0 @@\n-  static void assert_heaplocked_or_fullgc_safepoint(const char* file, int line);\n@@ -169,2 +168,0 @@\n-#define shenandoah_assert_heaplocked_or_fullgc_safepoint() \\\n-                    ShenandoahAsserts::assert_heaplocked_or_fullgc_safepoint(__FILE__, __LINE__)\n@@ -241,1 +238,0 @@\n-#define shenandoah_assert_heaplocked_or_fullgc_safepoint()\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -429,1 +429,0 @@\n-    \/\/ TODO: Could we optimize here by checking that dst is in an old region?\n@@ -482,8 +481,0 @@\n-  } else {\n-    \/\/ Incremental Update mode, marking\n-    T* array = src;\n-    HeapWord* array_addr = reinterpret_cast<HeapWord*>(array);\n-    ShenandoahHeapRegion* r = _heap->heap_region_containing(array_addr);\n-    if (array_addr < _heap->marking_context()->top_at_mark_start(r)) {\n-      arraycopy_work<T, false, false, true>(array, count);\n-    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -636,4 +636,0 @@\n-    \/\/ TODO: We should be able to pull this out of the safepoint for the bootstrap\n-    \/\/ cycle. The top of an old region will only move when a GC cycle evacuates\n-    \/\/ objects into it. When we start an old cycle, we know that nothing can touch\n-    \/\/ the top of old regions.\n@@ -870,5 +866,3 @@\n-        \/\/ TODO: This worries me. Here we are asserting that an unmarked from-space object is 'correct'.\n-        \/\/ Normally, I would call this a bogus assert, but there seems to be a legitimate use-case for\n-        \/\/ accessing from-space objects during class unloading. However, the from-space object may have\n-        \/\/ been \"filled\". We've made no effort to prevent old generation classes being unloaded by young\n-        \/\/ gen (and vice-versa).\n+        \/\/ Here we are asserting that an unmarked from-space object is 'correct'. There seems to be a legitimate\n+        \/\/ use-case for accessing from-space objects during concurrent class unloading. In all modes of Shenandoah,\n+        \/\/ concurrent class unloading only happens during a global collection.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"gc\/shenandoah\/shenandoahHeapRegionClosures.hpp\"\n@@ -184,1 +185,0 @@\n-      \/\/ TODO: Send cancel_concurrent_mark upstream? Does it really not have it already?\n@@ -217,1 +217,1 @@\n-    \/\/ TODO: Do we need to explicitly retire PLABs?\n+    \/\/ Note: PLABs are also retired with GCLABs in generational mode.\n@@ -292,6 +292,3 @@\n-  void heap_region_do(ShenandoahHeapRegion *r) {\n-    \/\/ TODO: Add API to heap to skip free regions\n-    if (r->is_affiliated()) {\n-      _ctx->capture_top_at_mark_start(r);\n-      r->clear_live_data();\n-    }\n+  void heap_region_do(ShenandoahHeapRegion *r) override {\n+    _ctx->capture_top_at_mark_start(r);\n+    r->clear_live_data();\n@@ -300,1 +297,1 @@\n-  bool is_thread_safe() { return true; }\n+  bool is_thread_safe() override { return true; }\n@@ -309,1 +306,2 @@\n-  ShenandoahPrepareForMarkClosure cl;\n+  ShenandoahPrepareForMarkClosure prepare_for_mark;\n+  ShenandoahExcludeRegionClosure<FREE> cl(&prepare_for_mark);\n@@ -573,7 +571,1 @@\n-  void heap_region_do(ShenandoahHeapRegion* r) {\n-    if (!r->is_affiliated()) {\n-      \/\/ Ignore free regions\n-      \/\/ TODO: change iterators so they do not process FREE regions.\n-      return;\n-    }\n-\n+  void heap_region_do(ShenandoahHeapRegion* r) override {\n@@ -583,2 +575,1 @@\n-        assert(!r->has_live(),\n-               \"Region \" SIZE_FORMAT \" is not marked, should not have live\", r->index());\n+        assert(!r->has_live(), \"Region \" SIZE_FORMAT \" is not marked, should not have live\", r->index());\n@@ -587,2 +578,1 @@\n-        assert(r->has_live(),\n-               \"Region \" SIZE_FORMAT \" should have live\", r->index());\n+        assert(r->has_live(), \"Region \" SIZE_FORMAT \" should have live\", r->index());\n@@ -592,2 +582,1 @@\n-      assert(r->humongous_start_region()->has_live(),\n-             \"Region \" SIZE_FORMAT \" should have live\", r->index());\n+      assert(r->humongous_start_region()->has_live(), \"Region \" SIZE_FORMAT \" should have live\", r->index());\n@@ -761,2 +750,3 @@\n-    ShenandoahTrashImmediateGarbageClosure tigcl;\n-    heap->heap_region_iterate(&tigcl);\n+    ShenandoahTrashImmediateGarbageClosure trash_immediate_garbage;\n+    ShenandoahExcludeRegionClosure<FREE> cl(&trash_immediate_garbage);\n+    heap->heap_region_iterate(&cl);\n@@ -776,2 +766,0 @@\n-    \/\/ TODO: This is ResourceMark is missing upstream.\n-    ResourceMark rm;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":15,"deletions":27,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -860,1 +860,1 @@\n-  shenandoah_assert_heaplocked_or_fullgc_safepoint();\n+  shenandoah_assert_heaplocked_or_safepoint();\n@@ -869,1 +869,1 @@\n-  shenandoah_assert_heaplocked_or_fullgc_safepoint();\n+  shenandoah_assert_heaplocked_or_safepoint();\n@@ -874,2 +874,1 @@\n-  \/\/ TODO: REMOVE IS_GLOBAL() QUALIFIER AFTER WE FIX GLOBAL AFFILIATED REGION ACCOUNTING\n-  assert(is_global() || ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n@@ -882,1 +881,1 @@\n-  shenandoah_assert_heaplocked_or_fullgc_safepoint();\n+  shenandoah_assert_heaplocked_or_safepoint();\n@@ -888,1 +887,1 @@\n-  shenandoah_assert_heaplocked_or_fullgc_safepoint();\n+  shenandoah_assert_heaplocked_or_safepoint();\n@@ -892,2 +891,1 @@\n-  \/\/ TODO: REMOVE IS_GLOBAL() QUALIFIER AFTER WE FIX GLOBAL AFFILIATED REGION ACCOUNTING\n-  assert(is_global() || ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n@@ -925,2 +923,1 @@\n-  \/\/ TODO: REMOVE IS_GLOBAL() QUALIFIER AFTER WE FIX GLOBAL AFFILIATED REGION ACCOUNTING\n-  assert(is_global() || ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n@@ -973,2 +970,1 @@\n-  \/\/ TODO: REMOVE IS_GLOBAL() QUALIFIER AFTER WE FIX GLOBAL AFFILIATED REGION ACCOUNTING\n-  assert(is_global() || ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n@@ -980,2 +976,1 @@\n-  \/\/ TODO: REMOVE IS_GLOBAL() QUALIFIER AFTER WE FIX GLOBAL AFFILIATED REGION ACCOUNTING\n-  assert(is_global() || ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n@@ -1005,2 +1000,1 @@\n-  \/\/ TODO: REMOVE IS_GLOBAL() QUALIFIER AFTER WE FIX GLOBAL AFFILIATED REGION ACCOUNTING\n-  assert(is_global() || ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n@@ -1009,2 +1003,1 @@\n-  \/\/ TODO: REMOVE IS_GLOBAL() QUALIFIER AFTER WE FIX GLOBAL AFFILIATED REGION ACCOUNTING\n-  assert(is_global() || ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n@@ -1012,2 +1005,1 @@\n-  \/\/ TODO: REMOVE IS_GLOBAL() QUALIFIER AFTER WE FIX GLOBAL AFFILIATED REGION ACCOUNTING\n-  assert(is_global() || ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+  assert(ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":12,"deletions":20,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1263,1 +1263,0 @@\n-        \/\/ TODO: is this right? using PLAB::min_size() here for gc lab size?\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -427,1 +427,1 @@\n-    shenandoah_assert_heaplocked_or_fullgc_safepoint();\n+    shenandoah_assert_heaplocked_or_safepoint();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}