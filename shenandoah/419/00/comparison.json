{"files":[{"patch":"@@ -1083,1 +1083,1 @@\n-Node* MaxNode::build_min_max_int(Node* a, Node* b, bool is_max) {\n+static Node* build_min_max_int(Node* a, Node* b, bool is_max) {\n@@ -1091,8 +1091,0 @@\n-Node* MaxNode::build_min_max_long(PhaseGVN* phase, Node* a, Node* b, bool is_max) {\n-  if (is_max) {\n-    return new MaxLNode(phase->C, a, b);\n-  } else {\n-    return new MinLNode(phase->C, a, b);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -298,3 +298,0 @@\n-\n-  static Node* build_min_max_int(Node* a, Node* b, bool is_max);\n-  static Node* build_min_max_long(PhaseGVN* phase, Node* a, Node* b, bool is_max);\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,6 +99,0 @@\n-\n-  Node* minmax = Ideal_minmax(phase, this);\n-  if (minmax != nullptr) {\n-    return minmax;\n-  }\n-\n@@ -194,59 +188,0 @@\n-\/\/ Try to identify min\/max patterns in CMoves\n-Node* CMoveNode::Ideal_minmax(PhaseGVN* phase, CMoveNode* cmove) {\n-  \/\/ If we're post loop opts then don't attempt to match the min\/max pattern, as this node might have been a\n-  \/\/ MinL or MaxL that was already expanded during macro expansion.\n-  if (phase->C->post_loop_opts_phase()) {\n-    return nullptr;\n-  }\n-\n-  \/\/ The BoolNode may have been idealized into a constant. If that's the case, then Identity should take care of it instead.\n-  BoolNode* bol = cmove->in(CMoveNode::Condition)->isa_Bool();\n-  if (bol == nullptr) {\n-    return nullptr;\n-  }\n-\n-  Node* cmp = bol->in(1);\n-  int cmove_op = cmove->Opcode();\n-  int cmp_op = cmp->Opcode();\n-\n-  \/\/ Ensure comparison is an integral type, and that the cmove is of the same type.\n-  if (!((cmp_op == Op_CmpI && cmove_op == Op_CMoveI) || (cmp_op == Op_CmpL && cmove_op == Op_CMoveL))) {\n-    return nullptr;\n-  }\n-\n-  \/\/ Only accept canonicalized le and lt comparisons\n-  int test = bol->_test._test;\n-  if (test != BoolTest::le && test != BoolTest::lt) {\n-    return nullptr;\n-  }\n-\n-  \/\/ The values being compared\n-  Node* cmp_l = cmp->in(1);\n-  Node* cmp_r = cmp->in(2);\n-\n-  \/\/ The values being selected\n-  Node* cmove_l = cmove->in(CMoveNode::IfTrue);\n-  Node* cmove_r = cmove->in(CMoveNode::IfFalse);\n-\n-  \/\/ For this transformation to be valid, the values being compared must be the same as the values being selected.\n-  \/\/ We accept two different forms, \"a < b ? a : b\" and \"a < b ? b : a\". For the first form, the lhs and rhs of the\n-  \/\/ comparison and cmove are the same, resulting in a minimum. For the second form, the lhs and rhs of both are flipped,\n-  \/\/ resulting in a maximum. If neither form is found, bail out.\n-\n-  bool is_max;\n-  if (cmp_l == cmove_l && cmp_r == cmove_r) {\n-    is_max = false;\n-  } else if (cmp_l == cmove_r && cmp_r == cmove_l) {\n-    is_max = true;\n-  } else {\n-    return nullptr;\n-  }\n-\n-  \/\/ Create the Min\/Max node based on the type and kind\n-  if (cmp_op == Op_CmpL) {\n-    return MaxNode::build_min_max_long(phase, cmp_l, cmp_r, is_max);\n-  } else {\n-    return MaxNode::build_min_max_int(cmp_l, cmp_r, is_max);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":1,"deletions":66,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,2 +52,1 @@\n-  static Node* is_cmove_id(PhaseTransform* phase, Node* cmp, Node* t, Node* f, BoolNode* b);\n-  static Node* Ideal_minmax(PhaseGVN* phase, CMoveNode* cmov);\n+  static Node *is_cmove_id( PhaseTransform *phase, Node *cmp, Node *t, Node *f, BoolNode *b );\n","filename":"src\/hotspot\/share\/opto\/movenode.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,489 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.c2.irTests;\n-\n-import jdk.test.lib.Asserts;\n-import compiler.lib.ir_framework.*;\n-import java.util.Random;\n-import jdk.test.lib.Utils;\n-\n-\/*\n- * @test\n- * @bug 8324655\n- * @summary Test that if expressions are properly folded into min\/max nodes\n- * @library \/test\/lib \/\n- * @run main compiler.c2.irTests.TestIfMinMax\n- *\/\n-public class TestIfMinMax {\n-    private static final Random RANDOM = Utils.getRandomInstance();\n-\n-    public static void main(String[] args) {\n-        TestFramework.run();\n-    }\n-\n-    @Test\n-    @IR(failOn = { IRNode.IF }, counts = { IRNode.MIN_I, \"1\" })\n-    public int testMinI1(int a, int b) {\n-        return a < b ? a : b;\n-    }\n-\n-    @Test\n-    @IR(failOn = { IRNode.IF }, counts = { IRNode.MIN_I, \"1\" })\n-    public int testMinI2(int a, int b) {\n-        return a > b ? b : a;\n-    }\n-\n-    @Test\n-    @IR(failOn = { IRNode.IF }, counts = { IRNode.MAX_I, \"1\" })\n-    public int testMaxI1(int a, int b) {\n-        return a > b ? a : b;\n-    }\n-\n-    @Test\n-    @IR(failOn = { IRNode.IF }, counts = { IRNode.MAX_I, \"1\" })\n-    public int testMaxI2(int a, int b) {\n-        return a < b ? b : a;\n-    }\n-\n-    @Test\n-    @IR(failOn = { IRNode.IF }, counts = { IRNode.MIN_I, \"1\" })\n-    public int testMinI1E(int a, int b) {\n-        return a <= b ? a : b;\n-    }\n-\n-    @Test\n-    @IR(failOn = { IRNode.IF }, counts = { IRNode.MIN_I, \"1\" })\n-    public int testMinI2E(int a, int b) {\n-        return a >= b ? b : a;\n-    }\n-\n-    @Test\n-    @IR(failOn = { IRNode.IF }, counts = { IRNode.MAX_I, \"1\" })\n-    public int testMaxI1E(int a, int b) {\n-        return a >= b ? a : b;\n-    }\n-\n-    @Test\n-    @IR(failOn = { IRNode.IF }, counts = { IRNode.MAX_I, \"1\" })\n-    public int testMaxI2E(int a, int b) {\n-        return a <= b ? b : a;\n-    }\n-\n-    @Test\n-    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MIN_L, \"1\" })\n-    public long testMinL1(long a, long b) {\n-        return a < b ? a : b;\n-    }\n-\n-    @Test\n-    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MIN_L, \"1\" })\n-    public long testMinL2(long a, long b) {\n-        return a > b ? b : a;\n-    }\n-\n-    @Test\n-    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MAX_L, \"1\" })\n-    public long testMaxL1(long a, long b) {\n-        return a > b ? a : b;\n-    }\n-\n-    @Test\n-    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MAX_L, \"1\" })\n-    public long testMaxL2(long a, long b) {\n-        return a < b ? b : a;\n-    }\n-\n-    @Test\n-    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MIN_L, \"1\" })\n-    public long testMinL1E(long a, long b) {\n-        return a <= b ? a : b;\n-    }\n-\n-    @Test\n-    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MIN_L, \"1\" })\n-    public long testMinL2E(long a, long b) {\n-        return a >= b ? b : a;\n-    }\n-\n-    @Test\n-    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MAX_L, \"1\" })\n-    public long testMaxL1E(long a, long b) {\n-        return a >= b ? a : b;\n-    }\n-\n-    @Test\n-    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MAX_L, \"1\" })\n-    public long testMaxL2E(long a, long b) {\n-        return a <= b ? b : a;\n-    }\n-\n-    @Setup\n-    static Object[] setupIntArrays() {\n-        int[] a = new int[512];\n-        int[] b = new int[512];\n-\n-        for (int i = 0; i < 512; i++) {\n-            a[i] = RANDOM.nextInt();\n-            b[i] = RANDOM.nextInt();\n-        }\n-\n-        return new Object[] { a, b };\n-    }\n-\n-    @Setup\n-    static Object[] setupLongArrays() {\n-        long[] a = new long[512];\n-        long[] b = new long[512];\n-\n-        for (int i = 0; i < 512; i++) {\n-            a[i] = RANDOM.nextLong();\n-            b[i] = RANDOM.nextLong();\n-        }\n-\n-        return new Object[] { a, b };\n-    }\n-\n-    @Test\n-    @IR(applyIf = { \"SuperWordReductions\", \"true\" },\n-        applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n-        counts = { IRNode.MAX_REDUCTION_V, \"> 0\" })\n-    @Arguments(setup = \"setupIntArrays\")\n-    public Object[] testMaxIntReduction(int[] a, int[] b) {\n-        int r = 0;\n-        for (int i = 0; i < a.length; i++) {\n-            int aI = a[i] * 2;\n-\n-            r = aI > r ? aI : r;\n-        }\n-\n-        return new Object[] { a, r };\n-    }\n-\n-    @Check(test = \"testMaxIntReduction\")\n-    public void checkTestMaxIntReduction(Object[] vals) {\n-        int[] a = (int[]) vals[0];\n-        int testRet = (int) vals[1];\n-\n-        int r = 0;\n-        for (int i = 0; i < a.length; i++) {\n-            int aI = a[i] * 2;\n-\n-            r = aI > r ? aI : r;\n-        }\n-\n-        if (r != testRet) {\n-            throw new IllegalStateException(\"Int max reduction test failed: expected \" + testRet + \" but got \" + r);\n-        }\n-    }\n-\n-    @Test\n-    @IR(applyIf = { \"SuperWordReductions\", \"true\" },\n-        applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n-        counts = { IRNode.MIN_REDUCTION_V, \"> 0\" })\n-    @Arguments(setup = \"setupIntArrays\")\n-    public Object[] testMinIntReduction(int[] a, int[] b) {\n-        int r = 0;\n-\n-        for (int i = 0; i < a.length; i++) {\n-            int aI = a[i] * 2;\n-\n-            r = aI < r ? aI : r;\n-        }\n-\n-        return new Object[] { a, r };\n-    }\n-\n-    @Check(test = \"testMinIntReduction\")\n-    public void checkTestMinIntReduction(Object[] vals) {\n-        int[] a = (int[]) vals[0];\n-        int testRet = (int) vals[1];\n-\n-        int r = 0;\n-        for (int i = 0; i < a.length; i++) {\n-            int aI = a[i] * 2;\n-\n-            r = aI < r ? aI : r;\n-        }\n-\n-        if (r != testRet) {\n-            throw new IllegalStateException(\"Int min reduction test failed: expected \" + testRet + \" but got \" + r);\n-        }\n-    }\n-\n-    @Test\n-    @IR(applyIf = { \"SuperWordReductions\", \"true\" },\n-        applyIfCPUFeatureOr = { \"avx512\", \"true\" },\n-        counts = { IRNode.MAX_REDUCTION_V, \"> 0\" })\n-    @Arguments(setup = \"setupLongArrays\")\n-    public Object[] testMaxLongReduction(long[] a, long[] b) {\n-        long r = 0;\n-\n-        for (int i = 0; i < a.length; i++) {\n-            long aI = a[i] * 2;\n-\n-            r = aI > r ? aI : r;\n-        }\n-\n-        return new Object[] { a, r };\n-    }\n-\n-    @Check(test = \"testMaxLongReduction\")\n-    public void checkTestMaxLongReduction(Object[] vals) {\n-        long[] a = (long[]) vals[0];\n-        long testRet = (long) vals[1];\n-\n-        long r = 0;\n-        for (int i = 0; i < a.length; i++) {\n-            long aI = a[i] * 2;\n-\n-            r = aI > r ? aI : r;\n-        }\n-\n-        if (r != testRet) {\n-            throw new IllegalStateException(\"Long max reduction test failed: expected \" + testRet + \" but got \" + r);\n-        }\n-    }\n-\n-    @Test\n-    @IR(applyIf = { \"SuperWordReductions\", \"true\" },\n-        applyIfCPUFeatureOr = { \"avx512\", \"true\" },\n-        counts = { IRNode.MIN_REDUCTION_V, \"> 0\" })\n-    @Arguments(setup = \"setupLongArrays\")\n-    public Object[] testMinLongReduction(long[] a, long[] b) {\n-        long r = 0;\n-\n-        for (int i = 0; i < a.length; i++) {\n-            long aI = a[i] * 2;\n-\n-            r = aI < r ? aI : r;\n-        }\n-\n-        return new Object[] { a, r };\n-    }\n-\n-    @Check(test = \"testMinLongReduction\")\n-    public void checkTestMinLongReduction(Object[] vals) {\n-        long[] a = (long[]) vals[0];\n-        long testRet = (long) vals[1];\n-\n-        long r = 0;\n-        for (int i = 0; i < a.length; i++) {\n-            long aI = a[i] * 2;\n-\n-            r = aI < r ? aI : r;\n-        }\n-\n-        if (r != testRet) {\n-            throw new IllegalStateException(\"Long min reduction test failed: expected \" + testRet + \" but got \" + r);\n-        }\n-    }\n-\n-    @Test\n-    @IR(applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n-        counts = { IRNode.MAX_VI, \"> 0\" })\n-    @Arguments(setup = \"setupIntArrays\")\n-    public Object[] testMaxIntVector(int[] a, int[] b) {\n-        int[] r = new int[a.length];\n-\n-        for (int i = 0; i < a.length; i++) {\n-            int aI = a[i];\n-            int bI = b[i];\n-\n-            r[i] = aI > bI ? aI : bI;\n-        }\n-\n-        return new Object[] { a, b, r };\n-    }\n-\n-    @Check(test = \"testMaxIntVector\")\n-    public void checkTestMaxIntVector(Object[] vals) {\n-        int[] a = (int[]) vals[0];\n-        int[] b = (int[]) vals[1];\n-        int[] testRet = (int[]) vals[2];\n-\n-        for (int i = 0; i < a.length; i++) {\n-            int aI = a[i];\n-            int bI = b[i];\n-\n-            int r = aI > bI ? aI : bI;\n-\n-            if (r != testRet[i]) {\n-                throw new IllegalStateException(\"Int max vectorization test failed: expected \" + testRet + \" but got \" + r);\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n-        counts = { IRNode.MIN_VI, \"> 0\" })\n-    @Arguments(setup = \"setupIntArrays\")\n-    public Object[] testMinIntVector(int[] a, int[] b) {\n-        int[] r = new int[a.length];\n-\n-        for (int i = 0; i < a.length; i++) {\n-            int aI = a[i];\n-            int bI = b[i];\n-\n-            r[i] = aI < bI ? aI : bI;\n-        }\n-\n-        return new Object[] { a, b, r };\n-    }\n-\n-    @Check(test = \"testMinIntVector\")\n-    public void checkTestMinIntVector(Object[] vals) {\n-        int[] a = (int[]) vals[0];\n-        int[] b = (int[]) vals[1];\n-        int[] testRet = (int[]) vals[2];\n-\n-        for (int i = 0; i < a.length; i++) {\n-            int aI = a[i];\n-            int bI = b[i];\n-\n-            int r = aI < bI ? aI : bI;\n-\n-            if (r != testRet[i]) {\n-                throw new IllegalStateException(\"Int min vectorization test failed: expected \" + testRet + \" but got \" + r);\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n-        counts = { IRNode.MAX_VL, \"> 0\" })\n-    @Arguments(setup = \"setupLongArrays\")\n-    public Object[] testMaxLongVector(long[] a, long[] b) {\n-        long[] r = new long[a.length];\n-\n-        for (int i = 0; i < a.length; i++) {\n-            long aI = a[i];\n-            long bI = b[i];\n-\n-            r[i] = aI > bI ? aI : bI;\n-        }\n-\n-        return new Object[] { a, b, r };\n-    }\n-\n-    @Check(test = \"testMaxLongVector\")\n-    public void checkTestMaxLongVector(Object[] vals) {\n-        long[] a = (long[]) vals[0];\n-        long[] b = (long[]) vals[1];\n-        long[] testRet = (long[]) vals[2];\n-\n-        for (int i = 0; i < a.length; i++) {\n-            long aI = a[i];\n-            long bI = b[i];\n-\n-            long r = aI > bI ? aI : bI;\n-\n-            if (r != testRet[i]) {\n-                throw new IllegalStateException(\"Long max vectorization test failed: expected \" + testRet + \" but got \" + r);\n-            }\n-        }\n-    }\n-\n-    @Test\n-    @IR(applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n-        counts = { IRNode.MIN_VL, \"> 0\" })\n-    @Arguments(setup = \"setupLongArrays\")\n-    public Object[] testMinLongVector(long[] a, long[] b) {\n-        long[] r = new long[a.length];\n-\n-        for (int i = 0; i < a.length; i++) {\n-            long aI = a[i];\n-            long bI = b[i];\n-\n-            r[i] = aI < bI ? aI : bI;\n-        }\n-\n-        return new Object[] { a, b, r };\n-    }\n-\n-    @Check(test = \"testMinLongVector\")\n-    public void checkTestMinLongVector(Object[] vals) {\n-        long[] a = (long[]) vals[0];\n-        long[] b = (long[]) vals[1];\n-        long[] testRet = (long[]) vals[2];\n-\n-        for (int i = 0; i < a.length; i++) {\n-            long aI = a[i];\n-            long bI = b[i];\n-\n-            long r = aI < bI ? aI : bI;\n-\n-            if (r != testRet[i]) {\n-                throw new IllegalStateException(\"Long min vectorization test failed: expected \" + testRet + \" but got \" + r);\n-            }\n-        }\n-    }\n-\n-    @Run(test = { \"testMinI1\", \"testMinI2\", \"testMaxI1\", \"testMaxI2\", \"testMinI1E\", \"testMinI2E\", \"testMaxI1E\", \"testMaxI2E\" })\n-    public void runTestIntegers() {\n-        testIntegers(10, 20);\n-        testIntegers(20, 10);\n-        testIntegers(10, 10);\n-        testIntegers(Integer.MAX_VALUE, Integer.MIN_VALUE);\n-        testIntegers(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-        testIntegers(RANDOM.nextInt(), RANDOM.nextInt());\n-    }\n-\n-    @DontCompile\n-    public void testIntegers(int a, int b) {\n-        Asserts.assertEQ(a < b ? a : b, testMinI1(a, b));\n-        Asserts.assertEQ(a > b ? b : a, testMinI2(a, b));\n-        Asserts.assertEQ(a > b ? a : b, testMaxI1(a, b));\n-        Asserts.assertEQ(a < b ? b : a, testMaxI2(a, b));\n-\n-        Asserts.assertEQ(a <= b ? a : b, testMinI1E(a, b));\n-        Asserts.assertEQ(a >= b ? b : a, testMinI2E(a, b));\n-        Asserts.assertEQ(a >= b ? a : b, testMaxI1E(a, b));\n-        Asserts.assertEQ(a <= b ? b : a, testMaxI2E(a, b));\n-    }\n-\n-    @Run(test = { \"testMinL1\", \"testMinL2\", \"testMaxL1\", \"testMaxL2\", \"testMinL1E\", \"testMinL2E\", \"testMaxL1E\", \"testMaxL2E\" })\n-    public void runTestLongs() {\n-        testLongs(10, 20);\n-        testLongs(20, 10);\n-        testLongs(10, 10);\n-        testLongs(Integer.MAX_VALUE, Integer.MIN_VALUE);\n-        testLongs(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-        testLongs(Long.MAX_VALUE, Long.MIN_VALUE);\n-        testLongs(Long.MIN_VALUE, Long.MAX_VALUE);\n-        testLongs(RANDOM.nextLong(), RANDOM.nextLong());\n-    }\n-\n-    @DontCompile\n-    public void testLongs(long a, long b) {\n-        Asserts.assertEQ(a < b ? a : b, testMinL1(a, b));\n-        Asserts.assertEQ(a > b ? b : a, testMinL2(a, b));\n-        Asserts.assertEQ(a > b ? a : b, testMaxL1(a, b));\n-        Asserts.assertEQ(a < b ? b : a, testMaxL2(a, b));\n-\n-        Asserts.assertEQ(a <= b ? a : b, testMinL1E(a, b));\n-        Asserts.assertEQ(a >= b ? b : a, testMinL2E(a, b));\n-        Asserts.assertEQ(a >= b ? a : b, testMaxL1E(a, b));\n-        Asserts.assertEQ(a <= b ? b : a, testMaxL2E(a, b));\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestIfMinMax.java","additions":0,"deletions":489,"binary":false,"changes":489,"status":"deleted"},{"patch":"@@ -870,5 +870,0 @@\n-    public static final String MAX_VL = VECTOR_PREFIX + \"MAX_VL\" + POSTFIX;\n-    static {\n-        vectorNode(MAX_VL, \"MaxV\", TYPE_LONG);\n-    }\n-\n@@ -935,5 +930,0 @@\n-    public static final String MIN_VL = VECTOR_PREFIX + \"MIN_VL\" + POSTFIX;\n-    static {\n-        vectorNode(MIN_VL, \"MinV\", TYPE_LONG);\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,128 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.vm.compiler;\n-\n-import org.openjdk.jmh.annotations.*;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n-@Warmup(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n-@Fork(3)\n-public class IfMinMax {\n-    private static final int SIZE = 10_000;\n-\n-    @Benchmark\n-    public void testSingleInt(Blackhole blackhole, BenchState state) {\n-        int a = state.i1[state.random.nextInt(SIZE)];\n-        int b = state.i2[state.random.nextInt(SIZE)];\n-        blackhole.consume(a > b ? a : b);\n-    }\n-\n-    @Benchmark\n-    public void testVectorInt(Blackhole blackhole, BenchState state) {\n-        for (int i = 0; i < SIZE; i++) {\n-            state.i3[i] = state.i1[i] > state.i2[i] ? state.i1[i] : state.i2[i];\n-        }\n-\n-        blackhole.consume(state.i3);\n-    }\n-\n-    @Benchmark\n-    public void testReductionInt(Blackhole blackhole, BenchState state) {\n-        int a = 0;\n-\n-        for (int i = 0; i < SIZE; i++) {\n-            if (state.i1[i] > a) {\n-                a = state.i1[i];\n-            }\n-        }\n-\n-        blackhole.consume(a);\n-    }\n-\n-    @Benchmark\n-    public void testSingleLong(Blackhole blackhole, BenchState state) {\n-        long a = state.l1[state.random.nextInt(SIZE)];\n-        long b = state.l2[state.random.nextInt(SIZE)];\n-        blackhole.consume(a > b ? a : b);\n-    }\n-\n-    @Benchmark\n-    public void testVectorLong(Blackhole blackhole, BenchState state) {\n-        for (int i = 0; i < SIZE; i++) {\n-            state.l3[i] = state.l1[i] > state.l2[i] ? state.l1[i] : state.l2[i];\n-        }\n-\n-        blackhole.consume(state.l3);\n-    }\n-\n-    @Benchmark\n-    public void testReductionLong(Blackhole blackhole, BenchState state) {\n-        long a = 0;\n-\n-        for (int i = 0; i < SIZE; i++) {\n-            if (state.l1[i] > a) {\n-                a = state.l1[i];\n-            }\n-        }\n-\n-        blackhole.consume(a);\n-    }\n-\n-    @State(Scope.Benchmark)\n-    public static class BenchState {\n-        private final int[] i1 = new int[SIZE];\n-        private final int[] i2 = new int[SIZE];\n-        private final int[] i3 = new int[SIZE];\n-\n-        private final long[] l1 = new long[SIZE];\n-        private final long[] l2 = new long[SIZE];\n-        private final long[] l3 = new long[SIZE];\n-\n-        private Random random;\n-\n-        public BenchState() {\n-        }\n-\n-        @Setup\n-        public void setup() {\n-            this.random = new Random(1000);\n-\n-            for (int i = 0; i < SIZE; i++) {\n-                i1[i] = this.random.nextInt();\n-                i2[i] = this.random.nextInt();\n-                i3[i] = this.random.nextInt();\n-\n-                l1[i] = this.random.nextLong();\n-                l2[i] = this.random.nextLong();\n-                l3[i] = this.random.nextLong();\n-            }\n-        }\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/IfMinMax.java","additions":0,"deletions":128,"binary":false,"changes":128,"status":"deleted"}]}