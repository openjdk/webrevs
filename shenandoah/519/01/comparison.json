{"files":[{"patch":"@@ -482,0 +482,16 @@\n+################################################################################\n+# Filter the unsupported feature combinations.\n+# This is called after JVM_FEATURES_ACTIVE are fully populated.\n+#\n+AC_DEFUN([JVM_FEATURES_FILTER_UNSUPPORTED],\n+[\n+  # G1 late barrier expansion in C2 is not implemented for some platforms.\n+  # Choose not to support G1 in this configuration.\n+  if JVM_FEATURES_IS_ACTIVE(compiler2); then\n+    if test \"x$OPENJDK_TARGET_CPU\" = \"xx86\"; then\n+      AC_MSG_NOTICE([G1 cannot be used with C2 on this platform, disabling G1])\n+      UTIL_GET_NON_MATCHING_VALUES(JVM_FEATURES_ACTIVE, $JVM_FEATURES_ACTIVE, \"g1gc\")\n+    fi\n+  fi\n+])\n+\n@@ -557,0 +573,3 @@\n+    # Filter unsupported feature combinations from JVM_FEATURES_ACTIVE.\n+    JVM_FEATURES_FILTER_UNSUPPORTED\n+\n","filename":"make\/autoconf\/jvm-features.m4","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -310,1 +310,1 @@\n-  # some siutations in later configure checks.\n+  # some situations in later configure checks.\n@@ -319,4 +319,0 @@\n-\n-  # filter out some unwanted additions autoconf may add to CXX; we saw this on macOS with autoconf 2.72\n-  UTIL_GET_NON_MATCHING_VALUES(cxx_filtered, $CXX, -std=c++11 -std=gnu++11)\n-  CXX=\"$cxx_filtered\"\n@@ -361,0 +357,5 @@\n+    # or look like\n+    #     gcc (GCC) 10.2.1 20200825 (Alibaba 10.2.1-3.8 2.32)\n+    #     Copyright (C) 2020 Free Software Foundation, Inc.\n+    #     This is free software; see the source for copying conditions.  There is NO\n+    #     warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n@@ -374,1 +375,2 @@\n-        $SED -e 's\/^.* \\(@<:@1-9@:>@<:@0-9@:>@*\\.@<:@0-9.@:>@*\\)@<:@^0-9.@:>@.*$\/\\1\/'`\n+        $AWK -F ')' '{print [$]2}' | \\\n+        $AWK '{print [$]1}'`\n","filename":"make\/autoconf\/toolchain.m4","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,64 @@\n+###############################################################################\n+# Overwrite the existing version of AC_PROG_CC with our own custom variant.\n+# Unlike the regular AC_PROG_CC, the compiler list must always be passed.\n+AC_DEFUN([AC_PROG_CC],\n+[\n+  AC_LANG_PUSH(C)\n+  AC_ARG_VAR([CC], [C compiler command])\n+  AC_ARG_VAR([CFLAGS], [C compiler flags])\n+\n+  _AC_ARG_VAR_LDFLAGS()\n+  _AC_ARG_VAR_LIBS()\n+  _AC_ARG_VAR_CPPFLAGS()\n+\n+  AC_CHECK_TOOLS(CC, [$1])\n+\n+  test -z \"$CC\" && AC_MSG_FAILURE([no acceptable C compiler found in \\$PATH])\n+\n+  # Provide some information about the compiler.\n+  _AS_ECHO_LOG([checking for _AC_LANG compiler version])\n+  set X $ac_compile\n+  ac_compiler=$[2]\n+  for ac_option in --version -v -V -qversion -version; do\n+    _AC_DO_LIMIT([$ac_compiler $ac_option >&AS_MESSAGE_LOG_FD])\n+  done\n+\n+  m4_expand_once([_AC_COMPILER_EXEEXT])\n+  m4_expand_once([_AC_COMPILER_OBJEXT])\n+\n+  _AC_PROG_CC_G\n+\n+  AC_LANG_POP(C)\n+])\n+\n+###############################################################################\n+# Overwrite the existing version of AC_PROG_CXX with our own custom variant.\n+# Unlike the regular AC_PROG_CXX, the compiler list must always be passed.\n+AC_DEFUN([AC_PROG_CXX],\n+[\n+  AC_LANG_PUSH(C++)\n+  AC_ARG_VAR([CXX], [C++ compiler command])\n+  AC_ARG_VAR([CXXFLAGS], [C++ compiler flags])\n+\n+  _AC_ARG_VAR_LDFLAGS()\n+  _AC_ARG_VAR_LIBS()\n+  _AC_ARG_VAR_CPPFLAGS()\n+\n+  AC_CHECK_TOOLS(CXX, [$1])\n+\n+  # Provide some information about the compiler.\n+  _AS_ECHO_LOG([checking for _AC_LANG compiler version])\n+  set X $ac_compile\n+  ac_compiler=$[2]\n+  for ac_option in --version -v -V -qversion; do\n+    _AC_DO_LIMIT([$ac_compiler $ac_option >&AS_MESSAGE_LOG_FD])\n+  done\n+\n+  m4_expand_once([_AC_COMPILER_EXEEXT])\n+  m4_expand_once([_AC_COMPILER_OBJEXT])\n+\n+  _AC_PROG_CXX_G\n+\n+  AC_LANG_POP(C++)\n+])\n+\n","filename":"make\/autoconf\/util.m4","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -118,0 +118,2 @@\n+  # nio tests' libCreationTimeHelper native needs -ldl linker flag\n+  BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libCreationTimeHelper := -ldl\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2310,4 +2310,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return new TypeVectMask(elemTy, length);\n-}\n-\n@@ -6895,30 +6891,0 @@\n-\/\/ Store CMS card-mark Immediate\n-instruct storeimmCM0(immI0 zero, memory1 mem)\n-%{\n-  match(Set mem (StoreCM mem zero));\n-\n-  ins_cost(INSN_COST);\n-  format %{ \"storestore (elided)\\n\\t\"\n-            \"strb zr, $mem\\t# byte\" %}\n-\n-  ins_encode(aarch64_enc_strb0(mem));\n-\n-  ins_pipe(istore_mem);\n-%}\n-\n-\/\/ Store CMS card-mark Immediate with intervening StoreStore\n-\/\/ needed when using CMS with no conditional card marking\n-instruct storeimmCM0_ordered(immI0 zero, memory1 mem)\n-%{\n-  match(Set mem (StoreCM mem zero));\n-\n-  ins_cost(INSN_COST * 2);\n-  format %{ \"storestore\\n\\t\"\n-            \"dmb ishst\"\n-            \"\\n\\tstrb zr, $mem\\t# byte\" %}\n-\n-  ins_encode(aarch64_enc_strb0_ordered(mem));\n-\n-  ins_pipe(istore_mem);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":34,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1192,0 +1192,2 @@\n+    } else if (stub->is_nokeepalive()) {\n+      __ lea(rscratch1, RuntimeAddress(ZBarrierSetRuntime::no_keepalive_store_barrier_on_oop_field_without_healing_addr()));\n@@ -1310,2 +1312,2 @@\n-ZStoreBarrierStubC2Aarch64::ZStoreBarrierStubC2Aarch64(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic)\n-  : ZStoreBarrierStubC2(node, ref_addr, new_zaddress, new_zpointer, is_native, is_atomic), _deferred_emit(false) {}\n+ZStoreBarrierStubC2Aarch64::ZStoreBarrierStubC2Aarch64(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic, bool is_nokeepalive)\n+  : ZStoreBarrierStubC2(node, ref_addr, new_zaddress, new_zpointer, is_native, is_atomic, is_nokeepalive), _deferred_emit(false) {}\n@@ -1313,2 +1315,2 @@\n-ZStoreBarrierStubC2Aarch64* ZStoreBarrierStubC2Aarch64::create(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic) {\n-  ZStoreBarrierStubC2Aarch64* const stub = new (Compile::current()->comp_arena()) ZStoreBarrierStubC2Aarch64(node, ref_addr, new_zaddress, new_zpointer, is_native, is_atomic);\n+ZStoreBarrierStubC2Aarch64* ZStoreBarrierStubC2Aarch64::create(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic, bool is_nokeepalive) {\n+  ZStoreBarrierStubC2Aarch64* const stub = new (Compile::current()->comp_arena()) ZStoreBarrierStubC2Aarch64(node, ref_addr, new_zaddress, new_zpointer, is_native, is_atomic, is_nokeepalive);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -283,1 +283,1 @@\n-  ZStoreBarrierStubC2Aarch64(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic);\n+  ZStoreBarrierStubC2Aarch64(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic, bool is_nokeepalive);\n@@ -286,1 +286,1 @@\n-  static ZStoreBarrierStubC2Aarch64* create(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic);\n+  static ZStoreBarrierStubC2Aarch64* create(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic, bool is_nokeepalive);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,1 +94,2 @@\n-    ZStoreBarrierStubC2Aarch64* const stub = ZStoreBarrierStubC2Aarch64::create(node, ref_addr, rnew_zaddress, rnew_zpointer, is_native, is_atomic);\n+    bool is_nokeepalive = (node->barrier_data() & ZBarrierNoKeepalive) != 0;\n+    ZStoreBarrierStubC2Aarch64* const stub = ZStoreBarrierStubC2Aarch64::create(node, ref_addr, rnew_zaddress, rnew_zpointer, is_native, is_atomic, is_nokeepalive);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/z_aarch64.ad","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5014,1 +5014,1 @@\n-    if (CompressedOops::shift() != 0 || d != s) {\n+    if (CompressedOops::shift() != 0) {\n@@ -5016,0 +5016,2 @@\n+    } else if (d != s) {\n+      mov(d, s);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  assert((Patching_lock->is_locked() || SafepointSynchronize::is_at_safepoint()) ||\n+  assert((CodeCache_lock->is_locked() || SafepointSynchronize::is_at_safepoint()) ||\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1006,4 +1006,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return nullptr;\n-}\n-\n@@ -4229,12 +4225,0 @@\n-instruct storeCM(memoryB mem, store_RegI src) %{\n-  match(Set mem (StoreCM mem src));\n-  ins_cost(MEMORY_REF_COST);\n-\n-  size(4);\n-  format %{ \"STRB    $src,$mem\\t! CMS card-mark byte\" %}\n-  ins_encode %{\n-    __ strb($src$$Register, $mem$$Address);\n-  %}\n-  ins_pipe(istore_mem_reg);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -216,1 +216,5 @@\n-    __ unlock_object(R5, R6, R4, *stub->entry());\n+    if (LockingMode == LM_MONITOR) {\n+      __ b(*stub->entry());\n+    } else {\n+      __ unlock_object(R5, R6, R4, *stub->entry());\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -117,0 +117,2 @@\n+  } else {\n+    assert(false, \"Unhandled LockingMode:%d\", LockingMode);\n@@ -171,0 +173,2 @@\n+  } else {\n+    assert(false, \"Unhandled LockingMode:%d\", LockingMode);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -946,0 +946,2 @@\n+    } else if (stub->is_nokeepalive()) {\n+      __ call_VM_leaf(ZBarrierSetRuntime::no_keepalive_store_barrier_on_oop_field_without_healing_addr(), R3_ARG1);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/zBarrierSetAssembler_ppc.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,1 +86,2 @@\n-    ZStoreBarrierStubC2* const stub = ZStoreBarrierStubC2::create(node, Address(ref_base, disp), rnew_zaddress, rnew_zpointer, is_native, is_atomic);\n+    bool is_nokeepalive = (node->barrier_data() & ZBarrierNoKeepalive) != 0;\n+    ZStoreBarrierStubC2* const stub = ZStoreBarrierStubC2::create(node, Address(ref_base, disp), rnew_zaddress, rnew_zpointer, is_native, is_atomic, is_nokeepalive);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/z_ppc.ad","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2654,0 +2654,6 @@\n+#ifdef ASSERT\n+  \/\/ Check that unlocked label is reached with flag == EQ.\n+  Label flag_correct;\n+  beq(flag, flag_correct);\n+  stop(\"compiler_fast_lock_object: Flag != EQ\");\n+#endif\n@@ -2655,0 +2661,6 @@\n+#ifdef ASSERT\n+  \/\/ Check that slow_path label is reached with flag == NE.\n+  bne(flag, flag_correct);\n+  stop(\"compiler_fast_lock_object: Flag != NE\");\n+  bind(flag_correct);\n+#endif\n@@ -2704,6 +2716,0 @@\n-  ld(temp,             in_bytes(ObjectMonitor::owner_offset()), current_header);\n-\n-  \/\/ In case of LM_LIGHTWEIGHT, we may reach here with (temp & ObjectMonitor::ANONYMOUS_OWNER) != 0.\n-  \/\/ This is handled like owner thread mismatches: We take the slow path.\n-  cmpd(flag, temp, R16_thread);\n-  bne(flag, failure);\n@@ -2712,1 +2718,0 @@\n-\n@@ -2715,0 +2720,2 @@\n+\n+  \/\/ Recursive unlock\n@@ -2742,1 +2749,3 @@\n-  bne(flag, success);  \/\/ If so we are done.\n+  \/\/ Invert equal bit\n+  crnand(flag, Assembler::equal, flag, Assembler::equal);\n+  beq(flag, success);  \/\/ If there is a successor we are done.\n@@ -2747,3 +2756,1 @@\n-\n-  crxor(flag, Assembler::equal, flag, Assembler::equal); \/\/ Set flag = NE => slow path\n-  b(failure);\n+  b(failure); \/\/ flag == NE\n@@ -2755,0 +2762,6 @@\n+#ifdef ASSERT\n+  \/\/ Check that unlocked label is reached with flag == EQ.\n+  Label flag_correct;\n+  beq(flag, flag_correct);\n+  stop(\"compiler_fast_unlock_object: Flag != EQ\");\n+#endif\n@@ -2756,0 +2769,6 @@\n+#ifdef ASSERT\n+  \/\/ Check that slow_path label is reached with flag == NE.\n+  bne(flag, flag_correct);\n+  stop(\"compiler_fast_unlock_object: Flag != NE\");\n+  bind(flag_correct);\n+#endif\n@@ -3056,1 +3075,0 @@\n-    Label set_eq_unlocked;\n@@ -3078,1 +3096,3 @@\n-    bne(CCR0, set_eq_unlocked); \/\/ If so we are done.\n+    \/\/ Invert equal bit\n+    crnand(flag, Assembler::equal, flag, Assembler::equal);\n+    beq(CCR0, unlocked); \/\/ If there is a successor we are done.\n@@ -3083,6 +3103,1 @@\n-\n-    crxor(CCR0, Assembler::equal, CCR0, Assembler::equal); \/\/ Set flag = NE => slow path\n-    b(slow_path);\n-\n-    bind(set_eq_unlocked);\n-    crorc(CCR0, Assembler::equal, CCR0, Assembler::equal); \/\/ Set flag = EQ => fast path\n+    b(slow_path); \/\/ flag == NE\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-\/\/ during code generation, where no patching lock is needed.\n+\/\/ during code generation, where no lock is needed.\n@@ -98,1 +98,1 @@\n-         (Patching_lock->is_locked() || SafepointSynchronize::is_at_safepoint()) ||\n+         (CodeCache_lock->is_locked() || SafepointSynchronize::is_at_safepoint()) ||\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2157,4 +2157,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return nullptr;\n-}\n-\n@@ -6485,17 +6481,0 @@\n-\/\/----------Store Instructions With Zeros--------------------------------------\n-\n-instruct storeCM(memory mem, immI_0 zero) %{\n-  match(Set mem (StoreCM mem zero));\n-  ins_cost(MEMORY_REF_COST);\n-\n-  format %{ \"STB     #0, $mem \\t\/\/ CMS card-mark byte store\" %}\n-  size(8);\n-  ins_encode %{\n-    __ li(R0, 0);\n-    \/\/ No release barrier: Oops are allowed to get visible after marking.\n-    guarantee($mem$$base$$Register != R1_SP, \"use frame_slots_bias\");\n-    __ stb(R0, $mem$$disp, $mem$$base$$Register);\n-  %}\n-  ins_pipe(pipe_class_memory);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-instruct g1StoreP(indirect mem, iRegP src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+instruct g1StoreP(indirect mem, iRegP src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n@@ -81,1 +81,1 @@\n-  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n@@ -102,1 +102,1 @@\n-instruct g1StoreN(indirect mem, iRegN src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+instruct g1StoreN(indirect mem, iRegN src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n@@ -106,1 +106,1 @@\n-  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n@@ -134,1 +134,1 @@\n-instruct g1EncodePAndStoreN(indirect mem, iRegP src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+instruct g1EncodePAndStoreN(indirect mem, iRegP src, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n@@ -138,1 +138,1 @@\n-  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n@@ -165,1 +165,1 @@\n-instruct g1CompareAndExchangeP(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2)\n+instruct g1CompareAndExchangeP(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)\n@@ -169,1 +169,1 @@\n-  effect(TEMP res, TEMP tmp1, TEMP tmp2);\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, KILL cr);\n@@ -197,1 +197,1 @@\n-instruct g1CompareAndExchangePAcq(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2)\n+instruct g1CompareAndExchangePAcq(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)\n@@ -201,1 +201,1 @@\n-  effect(TEMP res, TEMP tmp1, TEMP tmp2);\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, KILL cr);\n@@ -229,1 +229,1 @@\n-instruct g1CompareAndExchangeN(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+instruct g1CompareAndExchangeN(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n@@ -233,1 +233,1 @@\n-  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n@@ -259,1 +259,1 @@\n-instruct g1CompareAndExchangeNAcq(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+instruct g1CompareAndExchangeNAcq(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n@@ -263,1 +263,1 @@\n-  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n@@ -289,1 +289,1 @@\n-instruct g1CompareAndSwapP(iRegINoSp res, indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegP oldval)\n+instruct g1CompareAndSwapP(iRegINoSp res, indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegP oldval, rFlagsReg cr)\n@@ -294,1 +294,1 @@\n-  effect(TEMP res, TEMP tmp1, TEMP tmp2);\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, KILL cr);\n@@ -321,1 +321,1 @@\n-instruct g1CompareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegP oldval)\n+instruct g1CompareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegP oldval, rFlagsReg cr)\n@@ -326,1 +326,1 @@\n-  effect(TEMP res, TEMP tmp1, TEMP tmp2);\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, KILL cr);\n@@ -353,1 +353,1 @@\n-instruct g1CompareAndSwapN(iRegINoSp res, indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegN oldval)\n+instruct g1CompareAndSwapN(iRegINoSp res, indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegN oldval, rFlagsReg cr)\n@@ -358,1 +358,1 @@\n-  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n@@ -386,1 +386,1 @@\n-instruct g1CompareAndSwapNAcq(iRegINoSp res, indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegN oldval)\n+instruct g1CompareAndSwapNAcq(iRegINoSp res, indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegN oldval, rFlagsReg cr)\n@@ -391,1 +391,1 @@\n-  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  effect(TEMP res, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n@@ -419,1 +419,1 @@\n-instruct g1GetAndSetP(indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp preval)\n+instruct g1GetAndSetP(indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp preval, rFlagsReg cr)\n@@ -423,1 +423,1 @@\n-  effect(TEMP preval, TEMP tmp1, TEMP tmp2);\n+  effect(TEMP preval, TEMP tmp1, TEMP tmp2, KILL cr);\n@@ -445,1 +445,1 @@\n-instruct g1GetAndSetPAcq(indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp preval)\n+instruct g1GetAndSetPAcq(indirect mem, iRegP newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp preval, rFlagsReg cr)\n@@ -449,1 +449,1 @@\n-  effect(TEMP preval, TEMP tmp1, TEMP tmp2);\n+  effect(TEMP preval, TEMP tmp1, TEMP tmp2, KILL cr);\n@@ -471,1 +471,1 @@\n-instruct g1GetAndSetN(indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegNNoSp preval)\n+instruct g1GetAndSetN(indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegNNoSp preval, rFlagsReg cr)\n@@ -475,1 +475,1 @@\n-  effect(TEMP preval, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  effect(TEMP preval, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n@@ -498,1 +498,1 @@\n-instruct g1GetAndSetNAcq(indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegNNoSp preval)\n+instruct g1GetAndSetNAcq(indirect mem, iRegN newval, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegNNoSp preval, rFlagsReg cr)\n@@ -502,1 +502,1 @@\n-  effect(TEMP preval, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  effect(TEMP preval, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n@@ -525,1 +525,1 @@\n-instruct g1LoadP(iRegPNoSp dst, indirect mem, iRegPNoSp tmp1, iRegPNoSp tmp2)\n+instruct g1LoadP(iRegPNoSp dst, indirect mem, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)\n@@ -529,1 +529,1 @@\n-  effect(TEMP dst, TEMP tmp1, TEMP tmp2);\n+  effect(TEMP dst, TEMP tmp1, TEMP tmp2, KILL cr);\n@@ -544,1 +544,1 @@\n-instruct g1LoadN(iRegNNoSp dst, indirect mem, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+instruct g1LoadN(iRegNNoSp dst, indirect mem, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, rFlagsReg cr)\n@@ -548,1 +548,1 @@\n-  effect(TEMP dst, TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  effect(TEMP dst, TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/g1\/g1_riscv.ad","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-instruct xLoadP(iRegPNoSp dst, memory mem, iRegPNoSp tmp)\n+instruct xLoadP(iRegPNoSp dst, memory mem, iRegPNoSp tmp, rFlagsReg cr)\n@@ -59,1 +59,1 @@\n-  effect(TEMP dst, TEMP tmp);\n+  effect(TEMP dst, TEMP tmp, KILL cr);\n@@ -74,1 +74,1 @@\n-instruct xCompareAndSwapP(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp) %{\n+instruct xCompareAndSwapP(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp, rFlagsReg cr) %{\n@@ -78,1 +78,1 @@\n-  effect(TEMP_DEF res, TEMP tmp);\n+  effect(TEMP_DEF res, TEMP tmp, KILL cr);\n@@ -108,1 +108,1 @@\n-instruct xCompareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp) %{\n+instruct xCompareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp, rFlagsReg cr) %{\n@@ -112,1 +112,1 @@\n-  effect(TEMP_DEF res, TEMP tmp);\n+  effect(TEMP_DEF res, TEMP tmp, KILL cr);\n@@ -142,1 +142,1 @@\n-instruct xCompareAndExchangeP(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp) %{\n+instruct xCompareAndExchangeP(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp, rFlagsReg cr) %{\n@@ -145,1 +145,1 @@\n-  effect(TEMP_DEF res, TEMP tmp);\n+  effect(TEMP_DEF res, TEMP tmp, KILL cr);\n@@ -170,1 +170,1 @@\n-instruct xCompareAndExchangePAcq(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp) %{\n+instruct xCompareAndExchangePAcq(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp, rFlagsReg cr) %{\n@@ -173,1 +173,1 @@\n-  effect(TEMP_DEF res, TEMP tmp);\n+  effect(TEMP_DEF res, TEMP tmp, KILL cr);\n@@ -198,1 +198,1 @@\n-instruct xGetAndSetP(indirect mem, iRegP newv, iRegPNoSp prev, iRegPNoSp tmp) %{\n+instruct xGetAndSetP(indirect mem, iRegP newv, iRegPNoSp prev, iRegPNoSp tmp, rFlagsReg cr) %{\n@@ -201,1 +201,1 @@\n-  effect(TEMP_DEF prev, TEMP tmp);\n+  effect(TEMP_DEF prev, TEMP tmp, KILL cr);\n@@ -215,1 +215,1 @@\n-instruct xGetAndSetPAcq(indirect mem, iRegP newv, iRegPNoSp prev, iRegPNoSp tmp) %{\n+instruct xGetAndSetPAcq(indirect mem, iRegP newv, iRegPNoSp prev, iRegPNoSp tmp, rFlagsReg cr) %{\n@@ -218,1 +218,1 @@\n-  effect(TEMP_DEF prev, TEMP tmp);\n+  effect(TEMP_DEF prev, TEMP tmp, KILL cr);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/x\/x_riscv.ad","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -764,0 +764,2 @@\n+    } else if (stub->is_nokeepalive()) {\n+      __ la(t0, RuntimeAddress(ZBarrierSetRuntime::no_keepalive_store_barrier_on_oop_field_without_healing_addr()));\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/zBarrierSetAssembler_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,2 @@\n-    ZStoreBarrierStubC2* const stub = ZStoreBarrierStubC2::create(node, ref_addr, rnew_zaddress, rnew_zpointer, is_native, is_atomic);\n+    bool is_nokeepalive = (node->barrier_data() & ZBarrierNoKeepalive) != 0;\n+    ZStoreBarrierStubC2* const stub = ZStoreBarrierStubC2::create(node, ref_addr, rnew_zaddress, rnew_zpointer, is_native, is_atomic, is_nokeepalive);\n@@ -93,1 +94,1 @@\n-instruct zLoadP(iRegPNoSp dst, memory mem, iRegPNoSp tmp)\n+instruct zLoadP(iRegPNoSp dst, memory mem, iRegPNoSp tmp, rFlagsReg cr)\n@@ -97,1 +98,1 @@\n-  effect(TEMP dst, TEMP tmp);\n+  effect(TEMP dst, TEMP tmp, KILL cr);\n@@ -113,1 +114,1 @@\n-instruct zStoreP(memory mem, iRegP src, iRegPNoSp tmp1, iRegPNoSp tmp2)\n+instruct zStoreP(memory mem, iRegP src, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)\n@@ -117,1 +118,1 @@\n-  effect(TEMP tmp1, TEMP tmp2);\n+  effect(TEMP tmp1, TEMP tmp2, KILL cr);\n@@ -130,1 +131,1 @@\n-                          iRegPNoSp oldval_tmp, iRegPNoSp newval_tmp, iRegPNoSp tmp1) %{\n+                          iRegPNoSp oldval_tmp, iRegPNoSp newval_tmp, iRegPNoSp tmp1, rFlagsReg cr) %{\n@@ -134,1 +135,1 @@\n-  effect(TEMP oldval_tmp, TEMP newval_tmp, TEMP tmp1, TEMP_DEF res);\n+  effect(TEMP oldval_tmp, TEMP newval_tmp, TEMP tmp1, TEMP_DEF res, KILL cr);\n@@ -153,1 +154,1 @@\n-                             iRegPNoSp oldval_tmp, iRegPNoSp newval_tmp, iRegPNoSp tmp1) %{\n+                             iRegPNoSp oldval_tmp, iRegPNoSp newval_tmp, iRegPNoSp tmp1, rFlagsReg cr) %{\n@@ -157,1 +158,1 @@\n-  effect(TEMP oldval_tmp, TEMP newval_tmp, TEMP tmp1, TEMP_DEF res);\n+  effect(TEMP oldval_tmp, TEMP newval_tmp, TEMP tmp1, TEMP_DEF res, KILL cr);\n@@ -176,1 +177,1 @@\n-                              iRegPNoSp oldval_tmp, iRegPNoSp newval_tmp, iRegPNoSp tmp1) %{\n+                              iRegPNoSp oldval_tmp, iRegPNoSp newval_tmp, iRegPNoSp tmp1, rFlagsReg cr) %{\n@@ -179,1 +180,1 @@\n-  effect(TEMP oldval_tmp, TEMP newval_tmp, TEMP tmp1, TEMP_DEF res);\n+  effect(TEMP oldval_tmp, TEMP newval_tmp, TEMP tmp1, TEMP_DEF res, KILL cr);\n@@ -198,1 +199,1 @@\n-                                 iRegPNoSp oldval_tmp, iRegPNoSp newval_tmp, iRegPNoSp tmp1) %{\n+                                 iRegPNoSp oldval_tmp, iRegPNoSp newval_tmp, iRegPNoSp tmp1, rFlagsReg cr) %{\n@@ -201,1 +202,1 @@\n-  effect(TEMP oldval_tmp, TEMP newval_tmp, TEMP tmp1, TEMP_DEF res);\n+  effect(TEMP oldval_tmp, TEMP newval_tmp, TEMP tmp1, TEMP_DEF res, KILL cr);\n@@ -219,1 +220,1 @@\n-instruct zGetAndSetP(indirect mem, iRegP newv, iRegPNoSp prev, iRegPNoSp tmp) %{\n+instruct zGetAndSetP(indirect mem, iRegP newv, iRegPNoSp prev, iRegPNoSp tmp, rFlagsReg cr) %{\n@@ -222,1 +223,1 @@\n-  effect(TEMP_DEF prev, TEMP tmp);\n+  effect(TEMP_DEF prev, TEMP tmp, KILL cr);\n@@ -237,1 +238,1 @@\n-instruct zGetAndSetPAcq(indirect mem, iRegP newv, iRegPNoSp prev, iRegPNoSp tmp) %{\n+instruct zGetAndSetPAcq(indirect mem, iRegP newv, iRegPNoSp prev, iRegPNoSp tmp, rFlagsReg cr) %{\n@@ -240,1 +241,1 @@\n-  effect(TEMP_DEF prev, TEMP tmp);\n+  effect(TEMP_DEF prev, TEMP tmp, KILL cr);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/z_riscv.ad","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-\/\/ during code generation, where no patching lock is needed.\n+\/\/ during code generation, where no lock is needed.\n@@ -221,1 +221,1 @@\n-         (Patching_lock->is_locked() || SafepointSynchronize::is_at_safepoint()) ||\n+         (CodeCache_lock->is_locked() || SafepointSynchronize::is_at_safepoint()) ||\n@@ -389,1 +389,1 @@\n-         (Patching_lock->is_locked() || SafepointSynchronize::is_at_safepoint()) ||\n+         (CodeCache_lock->is_locked() || SafepointSynchronize::is_at_safepoint()) ||\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1969,4 +1969,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return new TypeVectMask(elemTy, length);\n-}\n-\n@@ -5042,35 +5038,0 @@\n-\/\/ Store Instructions\n-\/\/ Store CMS card-mark Immediate\n-instruct storeimmCM0(immI0 zero, memory mem)\n-%{\n-  match(Set mem (StoreCM mem zero));\n-\n-  ins_cost(STORE_COST);\n-  format %{ \"storestore (elided)\\n\\t\"\n-            \"sb zr, $mem\\t# byte, #@storeimmCM0\" %}\n-\n-  ins_encode %{\n-    __ sb(zr, Address(as_Register($mem$$base), $mem$$disp));\n-  %}\n-\n-  ins_pipe(istore_mem);\n-%}\n-\n-\/\/ Store CMS card-mark Immediate with intervening StoreStore\n-\/\/ needed when using CMS with no conditional card marking\n-instruct storeimmCM0_ordered(immI0 zero, memory mem)\n-%{\n-  match(Set mem (StoreCM mem zero));\n-\n-  ins_cost(ALU_COST + STORE_COST);\n-  format %{ \"membar(StoreStore)\\n\\t\"\n-            \"sb zr, $mem\\t# byte, #@storeimmCM0_ordered\" %}\n-\n-  ins_encode %{\n-    __ membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n-    __ sb(zr, Address(as_Register($mem$$base), $mem$$disp));\n-  %}\n-\n-  ins_pipe(istore_mem);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":0,"deletions":39,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -661,2 +661,2 @@\n-  \/\/ Bytes_after_jump cannot change, because we own the Patching_lock.\n-  assert(Patching_lock->owned_by_self(), \"must hold lock to patch instruction\");\n+  \/\/ Bytes_after_jump cannot change, because we own the CodeCache_lock.\n+  assert(CodeCache_lock->owned_by_self(), \"must hold lock to patch instruction\");\n","filename":"src\/hotspot\/cpu\/s390\/nativeInst_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1480,4 +1480,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return nullptr;\n-}\n-\n@@ -4229,22 +4225,0 @@\n-instruct storeCM(memory mem, immI_0 src) %{\n-  match(Set mem (StoreCM mem src));\n-  ins_cost(MEMORY_REF_COST);\n-  \/\/ TODO: s390 port size(VARIABLE_SIZE);\n-  format %{ \"STC(Y)  $src,$mem\\t # CMS card-mark byte (must be 0!)\" %}\n-  ins_encode %{\n-    guarantee($mem$$index$$Register != Z_R0, \"content will not be used.\");\n-    if ($mem$$index$$Register != noreg) {\n-      \/\/ Can't use clear_mem --> load const zero and store character.\n-      __ load_const_optimized(Z_R0_scratch, (long)0);\n-      if (Immediate::is_uimm12($mem$$disp)) {\n-        __ z_stc(Z_R0_scratch, $mem$$Address);\n-      } else {\n-        __ z_stcy(Z_R0_scratch, $mem$$Address);\n-      }\n-    } else {\n-      __ clear_mem(Address($mem$$Address), 1);\n-    }\n-  %}\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -4741,16 +4741,0 @@\n-void Assembler::evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-  assert(VM_Version::supports_evex(), \"\");\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  attributes.set_is_evex_instruction();\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n-  emit_int16(0x76, (0xC0 | encode));\n-}\n-\n-void Assembler::evpermt2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n-  assert(VM_Version::supports_avx512_vbmi(), \"\");\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n-  attributes.set_is_evex_instruction();\n-  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n-  emit_int16(0x7D, (0xC0 | encode));\n-}\n-\n@@ -16106,0 +16090,56 @@\n+\n+void Assembler::evpermi2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x75, (0xC0 | encode));\n+}\n+\n+void Assembler::evpermi2w(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512bw() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x75, (0xC0 | encode));\n+}\n+\n+void Assembler::evpermi2d(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x76, (0xC0 | encode));\n+}\n+\n+void Assembler::evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x76, (0xC0 | encode));\n+}\n+\n+void Assembler::evpermi2ps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x77, (0xC0 | encode));\n+}\n+\n+void Assembler::evpermi2pd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x77, (0xC0 | encode));\n+}\n+\n+void Assembler::evpermt2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x7D, (0xC0 | encode));\n+}\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":56,"deletions":16,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -1965,0 +1965,4 @@\n+  void evpmultishiftqb(XMMRegister dst, XMMRegister ctl, XMMRegister src, int vector_len);\n+  void evpermi2b(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evpermi2w(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evpermi2d(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -1966,0 +1970,2 @@\n+  void evpermi2ps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+  void evpermi2pd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -1967,1 +1973,0 @@\n-  void evpmultishiftqb(XMMRegister dst, XMMRegister ctl, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -6478,0 +6478,27 @@\n+\n+void C2_MacroAssembler::select_from_two_vectors_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src1,\n+                                                     XMMRegister src2, int vlen_enc) {\n+  switch(elem_bt) {\n+    case T_BYTE:\n+      evpermi2b(dst, src1, src2, vlen_enc);\n+      break;\n+    case T_SHORT:\n+      evpermi2w(dst, src1, src2, vlen_enc);\n+      break;\n+    case T_INT:\n+      evpermi2d(dst, src1, src2, vlen_enc);\n+      break;\n+    case T_LONG:\n+      evpermi2q(dst, src1, src2, vlen_enc);\n+      break;\n+    case T_FLOAT:\n+      evpermi2ps(dst, src1, src2, vlen_enc);\n+      break;\n+    case T_DOUBLE:\n+      evpermi2pd(dst, src1, src2, vlen_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported type %s\", type2name(elem_bt));\n+      break;\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -508,0 +508,2 @@\n+  void select_from_two_vectors_evex(BasicType elem_bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vlen_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1263,0 +1263,2 @@\n+    } else if (stub->is_nokeepalive()) {\n+      __ call(RuntimeAddress(ZBarrierSetRuntime::no_keepalive_store_barrier_on_oop_field_without_healing_addr()));\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,1 +94,2 @@\n-    ZStoreBarrierStubC2* const stub = ZStoreBarrierStubC2::create(node, ref_addr, rnew_zaddress, rnew_zpointer, is_native, is_atomic);\n+    bool is_nokeepalive = (node->barrier_data() & ZBarrierNoKeepalive) != 0;\n+    ZStoreBarrierStubC2* const stub = ZStoreBarrierStubC2::create(node, ref_addr, rnew_zaddress, rnew_zpointer, is_native, is_atomic, is_nokeepalive);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/z_x86_64.ad","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-  assert(Patching_lock->is_locked() ||\n+  assert(CodeCache_lock->is_locked() ||\n@@ -147,1 +147,1 @@\n-  assert(Patching_lock->is_locked() || SafepointSynchronize::is_at_safepoint() ||\n+  assert(CodeCache_lock->is_locked() || SafepointSynchronize::is_at_safepoint() ||\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1938,0 +1938,14 @@\n+    case Op_SelectFromTwoVector:\n+       if (size_in_bits < 128 || (size_in_bits < 512 && !VM_Version::supports_avx512vl())) {\n+         return false;\n+       }\n+       if (bt == T_SHORT && !VM_Version::supports_avx512bw()) {\n+         return false;\n+       }\n+       if (bt == T_BYTE && !VM_Version::supports_avx512_vbmi()) {\n+         return false;\n+       }\n+       if ((bt == T_INT || bt == T_FLOAT || bt == T_DOUBLE) && !VM_Version::supports_evex()) {\n+         return false;\n+       }\n+       break;\n@@ -2234,4 +2248,0 @@\n-const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n-  return new TypeVectMask(elemTy, length);\n-}\n-\n@@ -10475,0 +10485,13 @@\n+\n+\n+instruct vector_selectfrom_twovectors_reg_evex(vec index, vec src1, vec src2)\n+%{\n+  match(Set index (SelectFromTwoVector (Binary index src1) src2));\n+  format %{ \"select_from_two_vector $index, $src1, $src2 \\t!\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ select_from_two_vectors_evex(bt, $index$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -6325,11 +6325,0 @@\n-\/\/ Store CMS card-mark Immediate\n-instruct storeImmCM(memory mem, immI8 src) %{\n-  match(Set mem (StoreCM mem src));\n-\n-  ins_cost(150);\n-  format %{ \"MOV8   $mem,$src\\t! CMS card-mark imm0\" %}\n-  opcode(0xC6);               \/* C6 \/0 *\/\n-  ins_encode( SetInstMark, OpcP, RMopc_Mem(0x00,mem), Con8or32(src), ClearInstMark);\n-  ins_pipe( ialu_mem_imm );\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -5301,26 +5301,0 @@\n-\/\/ Store CMS card-mark Immediate\n-instruct storeImmCM0_reg(memory mem, immI_0 zero)\n-%{\n-  predicate(UseCompressedOops && (CompressedOops::base() == nullptr));\n-  match(Set mem (StoreCM mem zero));\n-\n-  ins_cost(125); \/\/ XXX\n-  format %{ \"movb    $mem, R12\\t# CMS card-mark byte 0 (R12_heapbase==0)\" %}\n-  ins_encode %{\n-    __ movb($mem$$Address, r12);\n-  %}\n-  ins_pipe(ialu_mem_reg);\n-%}\n-\n-instruct storeImmCM0(memory mem, immI_0 src)\n-%{\n-  match(Set mem (StoreCM mem src));\n-\n-  ins_cost(150); \/\/ XXX\n-  format %{ \"movb    $mem, $src\\t# CMS card-mark byte 0\" %}\n-  ins_encode %{\n-    __ movb($mem$$Address, $src$$constant);\n-  %}\n-  ins_pipe(ialu_mem_imm);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1296,1 +1296,1 @@\n-  char* rp = os::Posix::realpath((char *)dlinfo.dli_fname, buf, buflen);\n+  char* rp = os::realpath((char *)dlinfo.dli_fname, buf, buflen);\n@@ -1327,1 +1327,1 @@\n-        rp = os::Posix::realpath(java_home_var, buf, buflen);\n+        rp = os::realpath(java_home_var, buf, buflen);\n@@ -1348,1 +1348,1 @@\n-          rp = os::Posix::realpath((char *)dlinfo.dli_fname, buf, buflen);\n+          rp = os::realpath((char *)dlinfo.dli_fname, buf, buflen);\n@@ -2486,10 +2486,0 @@\n-\/\/ return current position of file pointer\n-jlong os::current_file_offset(int fd) {\n-  return (jlong)::lseek(fd, (off_t)0, SEEK_CUR);\n-}\n-\n-\/\/ move file pointer to the specified offset\n-jlong os::seek_to_file_offset(int fd, jlong offset) {\n-  return (jlong)::lseek(fd, (off_t)offset, SEEK_SET);\n-}\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1512,1 +1512,1 @@\n-    rp = os::Posix::realpath(dli_fname, buf, buflen);\n+    rp = os::realpath(dli_fname, buf, buflen);\n@@ -1544,1 +1544,1 @@\n-        rp = os::Posix::realpath(java_home_var, buf, buflen);\n+        rp = os::realpath(java_home_var, buf, buflen);\n@@ -1578,1 +1578,1 @@\n-          rp = os::Posix::realpath(dli_fname, buf, buflen);\n+          rp = os::realpath(dli_fname, buf, buflen);\n@@ -2403,10 +2403,0 @@\n-\/\/ return current position of file pointer\n-jlong os::current_file_offset(int fd) {\n-  return (jlong)::lseek(fd, (off_t)0, SEEK_CUR);\n-}\n-\n-\/\/ move file pointer to the specified offset\n-jlong os::seek_to_file_offset(int fd, jlong offset) {\n-  return (jlong)::lseek(fd, (off_t)offset, SEEK_SET);\n-}\n-\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2766,1 +2766,1 @@\n-    rp = os::Posix::realpath(dli_fname, buf, buflen);\n+    rp = os::realpath(dli_fname, buf, buflen);\n@@ -2800,1 +2800,1 @@\n-        rp = os::Posix::realpath(java_home_var, buf, buflen);\n+        rp = os::realpath(java_home_var, buf, buflen);\n@@ -2821,1 +2821,1 @@\n-          rp = os::Posix::realpath(dli_fname, buf, buflen);\n+          rp = os::realpath(dli_fname, buf, buflen);\n@@ -5056,10 +5056,0 @@\n-\/\/ return current position of file pointer\n-jlong os::current_file_offset(int fd) {\n-  return (jlong)::lseek(fd, (off_t)0, SEEK_CUR);\n-}\n-\n-\/\/ move file pointer to the specified offset\n-jlong os::seek_to_file_offset(int fd, jlong offset) {\n-  return (jlong)::lseek(fd, (off_t)offset, SEEK_SET);\n-}\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -792,1 +792,1 @@\n-  return os::Posix::realpath(buffer, _exePath, PATH_MAX);\n+  return os::realpath(buffer, _exePath, PATH_MAX);\n","filename":"src\/hotspot\/os\/linux\/os_perf_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-void os::check_dump_limit(char* buffer, size_t bufferSize) {\n+void os::check_core_dump_prerequisites(char* buffer, size_t bufferSize, bool check_only) {\n@@ -111,13 +111,7 @@\n-    return;\n-  }\n-\n-  int n;\n-  struct rlimit rlim;\n-  bool success;\n-\n-  char core_path[PATH_MAX];\n-  n = get_core_path(core_path, PATH_MAX);\n-\n-  if (n <= 0) {\n-    jio_snprintf(buffer, bufferSize, \"core.%d (may not exist)\", current_process_id());\n-    success = true;\n+  } else {\n+    struct rlimit rlim;\n+    bool success = true;\n+    bool warn = true;\n+    char core_path[PATH_MAX];\n+    if (get_core_path(core_path, PATH_MAX) <= 0) {\n+      jio_snprintf(buffer, bufferSize, \"core.%d (may not exist)\", current_process_id());\n@@ -125,3 +119,2 @@\n-  } else if (core_path[0] == '\"') { \/\/ redirect to user process\n-    jio_snprintf(buffer, bufferSize, \"Core dumps may be processed with %s\", core_path);\n-    success = true;\n+    } else if (core_path[0] == '\"') { \/\/ redirect to user process\n+      jio_snprintf(buffer, bufferSize, \"Core dumps may be processed with %s\", core_path);\n@@ -129,17 +122,21 @@\n-  } else if (getrlimit(RLIMIT_CORE, &rlim) != 0) {\n-    jio_snprintf(buffer, bufferSize, \"%s (may not exist)\", core_path);\n-    success = true;\n-  } else {\n-    switch(rlim.rlim_cur) {\n-      case RLIM_INFINITY:\n-        jio_snprintf(buffer, bufferSize, \"%s\", core_path);\n-        success = true;\n-        break;\n-      case 0:\n-        jio_snprintf(buffer, bufferSize, \"Core dumps have been disabled. To enable core dumping, try \\\"ulimit -c unlimited\\\" before starting Java again\");\n-        success = false;\n-        break;\n-      default:\n-        jio_snprintf(buffer, bufferSize, \"%s (max size \" UINT64_FORMAT \" k). To ensure a full core dump, try \\\"ulimit -c unlimited\\\" before starting Java again\", core_path, uint64_t(rlim.rlim_cur) \/ K);\n-        success = true;\n-        break;\n+    } else if (getrlimit(RLIMIT_CORE, &rlim) != 0) {\n+      jio_snprintf(buffer, bufferSize, \"%s (may not exist)\", core_path);\n+    } else {\n+      switch(rlim.rlim_cur) {\n+        case RLIM_INFINITY:\n+          jio_snprintf(buffer, bufferSize, \"%s\", core_path);\n+          warn = false;\n+          break;\n+        case 0:\n+          jio_snprintf(buffer, bufferSize, \"Core dumps have been disabled. To enable core dumping, try \\\"ulimit -c unlimited\\\" before starting Java again\");\n+          success = false;\n+          break;\n+        default:\n+          jio_snprintf(buffer, bufferSize, \"%s (max size \" UINT64_FORMAT \" k). To ensure a full core dump, try \\\"ulimit -c unlimited\\\" before starting Java again\", core_path, uint64_t(rlim.rlim_cur) \/ K);\n+          break;\n+      }\n+    }\n+    if (!check_only) {\n+      VMError::record_coredump_status(buffer, success);\n+    } else if (warn) {\n+      warning(\"CreateCoredumpOnCrash specified, but %s\", buffer);\n@@ -148,2 +145,0 @@\n-\n-  VMError::record_coredump_status(buffer, success);\n@@ -351,0 +346,10 @@\n+\/\/ return current position of file pointer\n+jlong os::current_file_offset(int fd) {\n+  return (jlong)::lseek(fd, (off_t)0, SEEK_CUR);\n+}\n+\n+\/\/ move file pointer to the specified offset\n+jlong os::seek_to_file_offset(int fd, jlong offset) {\n+  return (jlong)::lseek(fd, (off_t)offset, SEEK_SET);\n+}\n+\n@@ -1027,1 +1032,1 @@\n-char* os::Posix::realpath(const char* filename, char* outbuf, size_t outbuflen) {\n+char* os::realpath(const char* filename, char* outbuf, size_t outbuflen) {\n@@ -1030,1 +1035,1 @@\n-    assert(false, \"os::Posix::realpath: invalid arguments.\");\n+    assert(false, \"os::realpath: invalid arguments.\");\n@@ -1065,1 +1070,0 @@\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":43,"deletions":39,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -76,7 +76,0 @@\n-  \/\/ A safe implementation of realpath which will not cause a buffer overflow if the resolved path\n-  \/\/   is longer than PATH_MAX.\n-  \/\/ On success, returns 'outbuf', which now contains the path.\n-  \/\/ On error, it will return null and set errno. The content of 'outbuf' is undefined.\n-  \/\/ On truncation error ('outbuf' too small), it will return null and set errno to ENAMETOOLONG.\n-  static char* realpath(const char* filename, char* outbuf, size_t outbuflen);\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1290,3 +1290,2 @@\n-\/\/ Check if dump file can be created.\n-void os::check_dump_limit(char* buffer, size_t buffsz) {\n-  bool status = true;\n+\/\/ Check if core dump is active and if a core dump file can be created\n+void os::check_core_dump_prerequisites(char* buffer, size_t bufferSize, bool check_only) {\n@@ -1294,4 +1293,5 @@\n-    jio_snprintf(buffer, buffsz, \"CreateCoredumpOnCrash is disabled from command line\");\n-    status = false;\n-  }\n-\n+    jio_snprintf(buffer, bufferSize, \"CreateCoredumpOnCrash is disabled from command line\");\n+    VMError::record_coredump_status(buffer, false);\n+  } else {\n+    bool success = true;\n+    bool warn = true;\n@@ -1299,4 +1299,5 @@\n-  if (!os::win32::is_windows_server() && FLAG_IS_DEFAULT(CreateCoredumpOnCrash)) {\n-    jio_snprintf(buffer, buffsz, \"Minidumps are not enabled by default on client versions of Windows\");\n-    status = false;\n-  }\n+    if (!os::win32::is_windows_server() && FLAG_IS_DEFAULT(CreateCoredumpOnCrash)) {\n+      jio_snprintf(buffer, bufferSize, \"Minidumps are not enabled by default on client versions of Windows\");\n+      success = false;\n+      warn = true;\n+    }\n@@ -1305,7 +1306,20 @@\n-  if (status) {\n-    const char* cwd = get_current_directory(nullptr, 0);\n-    int pid = current_process_id();\n-    if (cwd != nullptr) {\n-      jio_snprintf(buffer, buffsz, \"%s\\\\hs_err_pid%u.mdmp\", cwd, pid);\n-    } else {\n-      jio_snprintf(buffer, buffsz, \".\\\\hs_err_pid%u.mdmp\", pid);\n+    if (success) {\n+      if (!check_only) {\n+        const char* cwd = get_current_directory(nullptr, 0);\n+        int pid = current_process_id();\n+        if (cwd != nullptr) {\n+          jio_snprintf(buffer, bufferSize, \"%s\\\\hs_err_pid%u.mdmp\", cwd, pid);\n+        } else {\n+          jio_snprintf(buffer, bufferSize, \".\\\\hs_err_pid%u.mdmp\", pid);\n+        }\n+\n+        if (dumpFile == nullptr &&\n+            (dumpFile = CreateFile(buffer, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr))\n+            == INVALID_HANDLE_VALUE) {\n+          jio_snprintf(buffer, bufferSize, \"Failed to create minidump file (0x%x).\", GetLastError());\n+          success = false;\n+        }\n+      } else {\n+        \/\/ For now on Windows, there are no more checks that we can do\n+        warn = false;\n+      }\n@@ -1314,5 +1328,4 @@\n-    if (dumpFile == nullptr &&\n-       (dumpFile = CreateFile(buffer, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr))\n-                 == INVALID_HANDLE_VALUE) {\n-      jio_snprintf(buffer, buffsz, \"Failed to create minidump file (0x%x).\", GetLastError());\n-      status = false;\n+    if (!check_only) {\n+      VMError::record_coredump_status(buffer, success);\n+    } else if (warn) {\n+      warning(\"CreateCoredumpOnCrash specified, but %s\", buffer);\n@@ -1321,1 +1334,0 @@\n-  VMError::record_coredump_status(buffer, status);\n@@ -5388,0 +5400,22 @@\n+char* os::realpath(const char* filename, char* outbuf, size_t outbuflen) {\n+\n+  if (filename == nullptr || outbuf == nullptr || outbuflen < 1) {\n+    assert(false, \"os::realpath: invalid arguments.\");\n+    errno = EINVAL;\n+    return nullptr;\n+  }\n+\n+  char* result = nullptr;\n+  ALLOW_C_FUNCTION(::_fullpath, char* p = ::_fullpath(nullptr, filename, 0);)\n+  if (p != nullptr) {\n+    if (strlen(p) < outbuflen) {\n+      strcpy(outbuf, p);\n+      result = outbuf;\n+    } else {\n+      errno = ENAMETOOLONG;\n+    }\n+    ALLOW_C_FUNCTION(::free, ::free(p);) \/\/ *not* os::free\n+  }\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":58,"deletions":24,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -279,1 +279,0 @@\n-  if( strcmp(opType,\"StoreCM\")==0) return Form::idealB;\n","filename":"src\/hotspot\/share\/adlc\/forms.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3657,1 +3657,0 @@\n-    \"StoreCM\",\n@@ -4359,1 +4358,1 @@\n-    \"VectorTest\", \"VectorLoadMask\", \"VectorStoreMask\", \"VectorBlend\", \"VectorInsert\",\n+    \"SelectFromTwoVector\", \"VectorTest\", \"VectorLoadMask\", \"VectorStoreMask\", \"VectorBlend\", \"VectorInsert\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -890,1 +890,1 @@\n-\/\/ patch_stub: jmp Runtim1::patch_code (through a runtime stub)\n+\/\/ patch_stub: jmp Runtime1::patch_code (through a runtime stub)\n@@ -1106,1 +1106,1 @@\n-    MutexLocker ml_patch (current, Patching_lock, Mutex::_no_safepoint_check_flag);\n+    MutexLocker ml_code (current, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -1271,6 +1271,2 @@\n-  }\n-\n-  \/\/ If we are patching in a non-perm oop, make sure the nmethod\n-  \/\/ is on the right list.\n-  {\n-    MutexLocker ml_code (current, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    \/\/ If we are patching in a non-perm oop, make sure the nmethod\n+    \/\/ is on the right list.\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1252,1 +1252,0 @@\n-bool ciMethod::is_initializer () const {         FETCH_FLAG_FROM_VM(is_initializer); }\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -355,1 +355,0 @@\n-  bool is_initializer () const;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,3 +104,0 @@\n-#ifdef _WINDOWS\n-    \/\/ qsort() on Windows reverse the order of fields with the same size\n-    \/\/ the extension of the comparison function below preserves this order\n@@ -108,0 +105,2 @@\n+    \/\/ qsort() may reverse the order of fields with the same size.\n+    \/\/ The extension is to ensure stable sort.\n@@ -112,3 +111,0 @@\n-#else\n-    return (*y)->size() - (*x)->size();\n-#endif \/\/ _WINDOWS\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"classfile\/systemDictionaryShared.hpp\"\n@@ -215,0 +216,5 @@\n+      \/\/ Exclude any classes that fail over during dynamic dumping\n+      if (CDSConfig::is_dumping_dynamic_archive()) {\n+        SystemDictionaryShared::warn_excluded(klass, \"Failed over class verification while dynamic dumping\");\n+        SystemDictionaryShared::set_excluded(klass);\n+      }\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -472,0 +472,2 @@\n+  do_intrinsic(_Reference_clear0,           java_lang_ref_Reference, clear0_name,    void_method_signature, F_RN)       \\\n+  do_intrinsic(_PhantomReference_clear0,    java_lang_ref_PhantomReference, clear0_name, void_method_signature, F_RN)   \\\n@@ -982,0 +984,11 @@\n+  do_intrinsic(_VectorSelectFromTwoVectorOp, jdk_internal_vm_vector_VectorSupport, vector_select_from_op_name, vector_select_from_op_sig, F_S) \\\n+   do_signature(vector_select_from_op_sig, \"(Ljava\/lang\/Class;\"                                                                                \\\n+                                            \"Ljava\/lang\/Class;\"                                                                                \\\n+                                            \"I\"                                                                                                \\\n+                                            \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                    \\\n+                                            \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                    \\\n+                                            \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                    \\\n+                                            \"Ljdk\/internal\/vm\/vector\/VectorSupport$SelectFromTwoVector;)\"                                      \\\n+                                            \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                   \\\n+   do_name(vector_select_from_op_name,     \"selectFromTwoVectorOp\")                                                                            \\\n+                                                                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -429,0 +429,1 @@\n+  template(clear0_name,                               \"clear0\")                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2051,1 +2051,1 @@\n-  \/\/ Invalidate can't occur while holding the Patching lock\n+  \/\/ Invalidate can't occur while holding the NMethodState_lock\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -330,0 +330,1 @@\n+  bool no_keepalive = (decorators & AS_NO_KEEPALIVE) != 0;\n@@ -339,0 +340,4 @@\n+  if (no_keepalive) {\n+    \/\/ No keep-alive means no need for the pre-barrier.\n+    access.set_barrier_data(access.barrier_data() & ~G1C2BarrierPre);\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n-    log_trace(gc, region)(\"G1HR %s(%s) [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \"]\",\n-                          action, hr->get_type_str(), p2i(hr->bottom()), p2i(hr->top()), p2i(hr->end()));\n+    log_trace(gc, region)(\"G1HR %4u %s(%s) [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \"]\",\n+                          hr->hrm_index(), action, hr->get_type_str(), p2i(hr->bottom()), p2i(hr->top()), p2i(hr->end()));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionPrinter.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  _predictor(G1ConfidencePercent \/ 100.0),\n+  _predictor((100 - G1ConfidencePercent) \/ 100.0),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,2 +32,3 @@\n- private:\n-  double _sigma;\n+private:\n+  \/\/ Scale factor indicating to which degree stddev should be taking into account in predictions.\n+  double _stddev_scale;\n@@ -49,4 +50,0 @@\n- public:\n-  G1Predictions(double sigma) : _sigma(sigma) {\n-    assert(sigma >= 0.0, \"Confidence must be larger than or equal to zero\");\n-  }\n@@ -54,2 +51,4 @@\n-  \/\/ Confidence factor.\n-  double sigma() const { return _sigma; }\n+public:\n+  G1Predictions(double stddev_scale) : _stddev_scale(stddev_scale) {\n+    assert(stddev_scale >= 0.0, \"must be\");\n+  }\n@@ -58,1 +57,1 @@\n-    return seq->davg() + _sigma * stddev_estimate(seq);\n+    return seq->davg() + _stddev_scale * stddev_estimate(seq);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Predictions.hpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -114,1 +114,2 @@\n-          \"Confidence level for MMU\/pause predictions\")                     \\\n+          \"Confidence level for MMU\/pause predictions. A higher value \"     \\\n+          \"means that G1 will use less safety margin for its predictions.\") \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -169,0 +170,7 @@\n+  if (checked_cast<uint>(ObjectAlignmentInBytes) > GCCardSizeInBytes) {\n+    err_msg message(\"ObjectAlignmentInBytes %u is larger than GCCardSizeInBytes %u\",\n+                    ObjectAlignmentInBytes, GCCardSizeInBytes);\n+    vm_exit_during_initialization(\"Invalid combination of GCCardSizeInBytes and ObjectAlignmentInBytes\",\n+                                  message);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/gcArguments.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -569,0 +569,2 @@\n+  bool no_keepalive = (decorators & AS_NO_KEEPALIVE) != 0;\n+\n@@ -573,0 +575,5 @@\n+  if (no_keepalive) {\n+    \/\/ No keep-alive means no need for the pre-barrier.\n+    return BarrierSetC2::store_at_resolved(access, val);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -66,2 +66,3 @@\n-class ShenandoahMarkUpdateRefsSuperClosure : public ShenandoahMarkRefsSuperClosure {\n-protected:\n+template <ShenandoahGenerationType GENERATION>\n+class ShenandoahMarkUpdateRefsClosure : public ShenandoahMarkRefsSuperClosure {\n+private:\n@@ -70,1 +71,1 @@\n-  template <class T, ShenandoahGenerationType GENERATION>\n+  template <class T>\n@@ -74,1 +75,1 @@\n-  ShenandoahMarkUpdateRefsSuperClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp, ShenandoahObjToScanQueue* old_q) :\n+  ShenandoahMarkUpdateRefsClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp, ShenandoahObjToScanQueue* old_q) :\n@@ -78,12 +79,1 @@\n-  };\n-};\n-\n-template <ShenandoahGenerationType GENERATION>\n-class ShenandoahMarkUpdateRefsClosure : public ShenandoahMarkUpdateRefsSuperClosure {\n-private:\n-  template <class T>\n-  inline void do_oop_work(T* p)     { work<T, GENERATION>(p); }\n-\n-public:\n-  ShenandoahMarkUpdateRefsClosure(ShenandoahObjToScanQueue* q, ShenandoahReferenceProcessor* rp, ShenandoahObjToScanQueue* old_q) :\n-    ShenandoahMarkUpdateRefsSuperClosure(q, rp, old_q) {}\n+  }\n@@ -91,2 +81,2 @@\n-  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n-  virtual void do_oop(oop* p)       { do_oop_work(p); }\n+  virtual void do_oop(narrowOop* p) { work(p); }\n+  virtual void do_oop(oop* p)       { work(p); }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.hpp","additions":8,"deletions":18,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -39,2 +39,3 @@\n-template<class T, ShenandoahGenerationType GENERATION>\n-inline void ShenandoahMarkUpdateRefsSuperClosure::work(T* p) {\n+template<ShenandoahGenerationType GENERATION>\n+template<class T>\n+inline void ShenandoahMarkUpdateRefsClosure<GENERATION>::work(T* p) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOopClosures.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+  taxable = MAX2<size_t>(1, taxable);\n@@ -91,0 +92,1 @@\n+  taxable = MAX2<size_t>(1, taxable);\n@@ -115,0 +117,1 @@\n+  taxable = MAX2<size_t>(1, taxable);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-ZStoreBarrierStubC2* ZStoreBarrierStubC2::create(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic) {\n+ZStoreBarrierStubC2* ZStoreBarrierStubC2::create(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic, bool is_nokeepalive) {\n@@ -244,1 +244,1 @@\n-  ZStoreBarrierStubC2* const stub = new (Compile::current()->comp_arena()) ZStoreBarrierStubC2(node, ref_addr, new_zaddress, new_zpointer, is_native, is_atomic);\n+  ZStoreBarrierStubC2* const stub = new (Compile::current()->comp_arena()) ZStoreBarrierStubC2(node, ref_addr, new_zaddress, new_zpointer, is_native, is_atomic, is_nokeepalive);\n@@ -250,1 +250,2 @@\n-ZStoreBarrierStubC2::ZStoreBarrierStubC2(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic)\n+ZStoreBarrierStubC2::ZStoreBarrierStubC2(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer,\n+                                         bool is_native, bool is_atomic, bool is_nokeepalive)\n@@ -256,1 +257,2 @@\n-    _is_atomic(is_atomic) {}\n+    _is_atomic(is_atomic),\n+    _is_nokeepalive(is_nokeepalive) {}\n@@ -278,0 +280,4 @@\n+bool ZStoreBarrierStubC2::is_nokeepalive() const {\n+  return _is_nokeepalive;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+  const bool     _is_nokeepalive;\n@@ -84,1 +85,1 @@\n-  ZStoreBarrierStubC2(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic);\n+  ZStoreBarrierStubC2(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic, bool is_nokeepalive);\n@@ -87,1 +88,1 @@\n-  static ZStoreBarrierStubC2* create(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic);\n+  static ZStoreBarrierStubC2* create(const MachNode* node, Address ref_addr, Register new_zaddress, Register new_zpointer, bool is_native, bool is_atomic, bool is_nokeepalive);\n@@ -94,0 +95,1 @@\n+  bool is_nokeepalive() const;\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,0 +62,4 @@\n+JRT_LEAF(void, ZBarrierSetRuntime::no_keepalive_store_barrier_on_oop_field_without_healing(oop* p))\n+  ZBarrier::no_keep_alive_store_barrier_on_heap_oop_field((zpointer*)p);\n+JRT_END\n+\n@@ -129,0 +133,4 @@\n+address ZBarrierSetRuntime::no_keepalive_store_barrier_on_oop_field_without_healing_addr() {\n+  return reinterpret_cast<address>(no_keepalive_store_barrier_on_oop_field_without_healing);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetRuntime.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+  static void no_keepalive_store_barrier_on_oop_field_without_healing(oop* p);\n@@ -57,0 +58,1 @@\n+  static address no_keepalive_store_barrier_on_oop_field_without_healing_addr();\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetRuntime.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -538,0 +538,13 @@\n+\n+  if (current_young_bytes_freed_per_gc_time == 0.0) {\n+    if (current_old_bytes_freed_per_gc_time == 0.0) {\n+      \/\/ Neither young nor old collections have reclaimed any memory.\n+      \/\/ Give them equal priority.\n+      return 1.0;\n+    }\n+\n+    \/\/ Only old collections have reclaimed memory.\n+    \/\/ Prioritize old.\n+    return ZOldGCThreads;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zDirector.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-    if (!mh->is_native() && !mh->is_static() && !mh->is_initializer()) {\n+    if (!mh->is_native() && !mh->is_static() && !mh->is_object_initializer() && !mh->is_static_initializer()) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2181,1 +2181,1 @@\n-    if (m->is_initializer() && !m->is_static()) {\n+    if (m->is_object_initializer()) {\n@@ -2208,1 +2208,1 @@\n-    if (!m->is_initializer() && !m->is_overpass()) {\n+    if (!m->is_object_initializer() && !m->is_static_initializer() && !m->is_overpass()) {\n@@ -2924,5 +2924,1 @@\n-  if (m->is_initializer()) {\n-    if (m->is_static_initializer()) {\n-      JVMCI_THROW_MSG_NULL(IllegalArgumentException,\n-          \"Cannot create java.lang.reflect.Method for class initializer\");\n-    }\n+  if (m->is_object_initializer()) {\n@@ -2930,0 +2926,3 @@\n+  } else if (m->is_static_initializer()) {\n+    JVMCI_THROW_MSG_NULL(IllegalArgumentException,\n+        \"Cannot create java.lang.reflect.Method for class initializer\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -135,0 +135,1 @@\n+  static_field(CompilerToVM::Data,             dtanh,                                  address)                                      \\\n@@ -244,1 +245,0 @@\n-  nonstatic_field(JavaThread,                  _poll_data,                                    SafepointMechanism::ThreadData)        \\\n@@ -412,0 +412,1 @@\n+  nonstatic_field(Thread,                   _poll_data,                                       SafepointMechanism::ThreadData)        \\\n@@ -850,0 +851,1 @@\n+  ZGC_ONLY(DECLARE_FUNCTION_FROM_ADDR(declare_function_with_value, ZBarrierSetRuntime::no_keepalive_store_barrier_on_oop_field_without_healing))  \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"logging\/log.hpp\"\n@@ -37,1 +38,3 @@\n-                                               const RegionData& metadata) {\n+                                               const RegionData& metadata, bool use_tag_inplace) {\n+  assert(!use_tag_inplace || metadata.mem_tag == mtNone,\n+         \"If using use_tag_inplace, then the supplied tag should be mtNone, was instead: %s\", NMTUtil::tag_to_name(metadata.mem_tag));\n@@ -58,0 +61,4 @@\n+    assert(!use_tag_inplace, \"Cannot use the tag inplace if no pre-existing tag exists. From: \" PTR_FORMAT \" To: \" PTR_FORMAT, A, B);\n+    if (use_tag_inplace) {\n+      log_debug(nmt)(\"Cannot use the tag inplace if no pre-existing tag exists. From: \" PTR_FORMAT \" To: \" PTR_FORMAT, A, B);\n+    }\n@@ -65,0 +72,11 @@\n+    StateType leqA_state = leqA_n->val().out.type();\n+    StateType new_state = stA.out.type();\n+    \/\/ If we specify use_tag_inplace then the new region takes over the current tag instead of the tag in metadata.\n+    \/\/ This is important because the VirtualMemoryTracker API doesn't require supplying the tag for some operations.\n+    if (use_tag_inplace) {\n+      assert(leqA_n->val().out.type() != StateType::Released, \"Should not use inplace the tag of a released region\");\n+      MemTag tag = leqA_n->val().out.mem_tag();\n+      stA.out.set_tag(tag);\n+      stB.in.set_tag(tag);\n+    }\n+\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-  \/\/ Each point has some stack and a flag associated with it.\n+  \/\/ Each point has some stack and a tag associated with it.\n@@ -91,1 +91,1 @@\n-    uint8_t type_flag[2];\n+    uint8_t type_tag[2];\n@@ -95,1 +95,1 @@\n-    IntervalState() : type_flag{0,0}, sidx() {}\n+    IntervalState() : type_tag{0,0}, sidx() {}\n@@ -98,2 +98,2 @@\n-      type_flag[0] = static_cast<uint8_t>(type);\n-      type_flag[1] = static_cast<uint8_t>(data.mem_tag);\n+      type_tag[0] = static_cast<uint8_t>(type);\n+      type_tag[1] = static_cast<uint8_t>(data.mem_tag);\n@@ -104,1 +104,1 @@\n-      return static_cast<StateType>(type_flag[0]);\n+      return static_cast<StateType>(type_tag[0]);\n@@ -108,1 +108,1 @@\n-      return static_cast<MemTag>(type_flag[1]);\n+      return static_cast<MemTag>(type_tag[1]);\n@@ -115,0 +115,4 @@\n+    void set_tag(MemTag tag) {\n+      type_tag[1] = static_cast<uint8_t>(tag);\n+    }\n+\n@@ -170,1 +174,2 @@\n-  SummaryDiff register_mapping(position A, position B, StateType state, const RegionData& metadata);\n+ private:\n+  SummaryDiff register_mapping(position A, position B, StateType state, const RegionData& metadata, bool use_tag_inplace = false);\n@@ -172,0 +177,1 @@\n+ public:\n@@ -173,1 +179,5 @@\n-    return register_mapping(from, from + sz, StateType::Reserved, metadata);\n+    return register_mapping(from, from + sz, StateType::Reserved, metadata, false);\n+  }\n+\n+  SummaryDiff commit_mapping(position from, position sz, const RegionData& metadata, bool use_tag_inplace = false) {\n+    return register_mapping(from, from + sz, StateType::Committed, metadata, use_tag_inplace);\n@@ -176,2 +186,2 @@\n-  SummaryDiff commit_mapping(position from, position sz, const RegionData& metadata) {\n-    return register_mapping(from, from + sz, StateType::Committed, metadata);\n+  SummaryDiff uncommit_mapping(position from, position sz, const RegionData& metadata) {\n+    return register_mapping(from, from + sz, StateType::Reserved, metadata, true);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1233,3 +1233,4 @@\n-  if (m->is_static())           return false;   \/\/ e.g., Stream.empty\n-  if (m->is_initializer())      return false;   \/\/ <init> or <clinit>\n-  if (m->is_private())          return false;   \/\/ uses direct call\n+  if (m->is_static())             return false; \/\/ e.g., Stream.empty\n+  if (m->is_object_initializer()) return false; \/\/ <init>\n+  if (m->is_static_initializer()) return false; \/\/ <clinit>\n+  if (m->is_private())            return false; \/\/ uses direct call\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -849,4 +849,0 @@\n-bool Method::is_initializer() const {\n-  return is_object_initializer() || is_static_initializer();\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -579,3 +579,0 @@\n-  \/\/ returns true if the method is an initializer (<init> or <clinit>).\n-  bool is_initializer() const;\n-\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -769,0 +769,2 @@\n+  case vmIntrinsics::_Reference_clear0:\n+  case vmIntrinsics::_PhantomReference_clear0:\n@@ -819,0 +821,1 @@\n+  case vmIntrinsics::_VectorSelectFromTwoVectorOp:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -626,1 +626,4 @@\n-  call->extract_projections(&callprojs, true);\n+  \/\/ Similar to incremental inlining, don't assert that all call\n+  \/\/ projections are still there for post-parse call devirtualization.\n+  bool do_asserts = !is_mh_late_inline() && !is_virtual_late_inline();\n+  call->extract_projections(&callprojs, true, do_asserts);\n@@ -650,1 +653,1 @@\n-    kit.replace_call(call, C->top(), true);\n+    kit.replace_call(call, C->top(), true, do_asserts);\n@@ -732,1 +735,1 @@\n-    kit.replace_call(call, result, true);\n+    kit.replace_call(call, result, true, do_asserts);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -344,1 +344,0 @@\n-macro(StoreCM)\n@@ -486,0 +485,1 @@\n+macro(SelectFromTwoVector)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3064,46 +3064,0 @@\n-\/\/ Eliminate trivially redundant StoreCMs and accumulate their\n-\/\/ precedence edges.\n-void Compile::eliminate_redundant_card_marks(Node* n) {\n-  assert(n->Opcode() == Op_StoreCM, \"expected StoreCM\");\n-  if (n->in(MemNode::Address)->outcnt() > 1) {\n-    \/\/ There are multiple users of the same address so it might be\n-    \/\/ possible to eliminate some of the StoreCMs\n-    Node* mem = n->in(MemNode::Memory);\n-    Node* adr = n->in(MemNode::Address);\n-    Node* val = n->in(MemNode::ValueIn);\n-    Node* prev = n;\n-    bool done = false;\n-    \/\/ Walk the chain of StoreCMs eliminating ones that match.  As\n-    \/\/ long as it's a chain of single users then the optimization is\n-    \/\/ safe.  Eliminating partially redundant StoreCMs would require\n-    \/\/ cloning copies down the other paths.\n-    while (mem->Opcode() == Op_StoreCM && mem->outcnt() == 1 && !done) {\n-      if (adr == mem->in(MemNode::Address) &&\n-          val == mem->in(MemNode::ValueIn)) {\n-        \/\/ redundant StoreCM\n-        if (mem->req() > MemNode::OopStore) {\n-          \/\/ Hasn't been processed by this code yet.\n-          n->add_prec(mem->in(MemNode::OopStore));\n-        } else {\n-          \/\/ Already converted to precedence edge\n-          for (uint i = mem->req(); i < mem->len(); i++) {\n-            \/\/ Accumulate any precedence edges\n-            if (mem->in(i) != nullptr) {\n-              n->add_prec(mem->in(i));\n-            }\n-          }\n-          \/\/ Everything above this point has been processed.\n-          done = true;\n-        }\n-        \/\/ Eliminate the previous StoreCM\n-        prev->set_req(MemNode::Memory, mem->in(MemNode::Memory));\n-        assert(mem->outcnt() == 0, \"should be dead\");\n-        mem->disconnect_inputs(this);\n-      } else {\n-        prev = mem;\n-      }\n-      mem = prev->in(MemNode::Memory);\n-    }\n-  }\n-}\n-\n@@ -3279,12 +3233,0 @@\n-\n-  case Op_StoreCM:\n-    {\n-      \/\/ Convert OopStore dependence into precedence edge\n-      Node* prec = n->in(MemNode::OopStore);\n-      n->del_req(MemNode::OopStore);\n-      n->add_prec(prec);\n-      eliminate_redundant_card_marks(n);\n-    }\n-\n-    \/\/ fall through\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":58,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1247,1 +1247,0 @@\n-  void eliminate_redundant_card_marks(Node* n);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4012,4 +4012,0 @@\n-      if (use->Opcode() == Op_StoreCM && use->in(MemNode::OopStore) == n) {\n-        \/\/ Don't move related cardmark.\n-        continue;\n-      }\n@@ -4567,1 +4563,1 @@\n-              op == Op_CastP2X || op == Op_StoreCM ||\n+              op == Op_CastP2X ||\n@@ -4706,3 +4702,0 @@\n-        if (use->Opcode() == Op_StoreCM) { \/\/ Ignore cardmark stores\n-          continue;\n-        }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -219,10 +219,4 @@\n-\n-        \/\/ Only process precedence edges that are CFG nodes. Safepoints and control projections can be in the middle of a block\n-        if (is_CFG(m)) {\n-          node->rm_prec(i);\n-          if (n == nullptr) {\n-            n = m;\n-          } else {\n-            assert(is_dominator(n, m) || is_dominator(m, n), \"one must dominate the other\");\n-            n = is_dominator(n, m) ? m : n;\n-          }\n+        assert(is_CFG(m), \"must be a CFG node\");\n+        node->rm_prec(i);\n+        if (n == nullptr) {\n+          n = m;\n@@ -230,2 +224,2 @@\n-          assert(node->is_Mach(), \"sanity\");\n-          assert(node->as_Mach()->ideal_Opcode() == Op_StoreCM, \"must be StoreCM node\");\n+          assert(is_dominator(n, m) || is_dominator(m, n), \"one must dominate the other\");\n+          n = is_dominator(n, m) ? m : n;\n@@ -772,1 +766,11 @@\n-    assert(!use_mem_state->needs_anti_dependence_check(), \"no loads\");\n+\n+#ifdef ASSERT\n+    \/\/ CacheWB nodes are peculiar in a sense that they both are anti-dependent and produce memory.\n+    \/\/ Allow them to be treated as a store.\n+    bool is_cache_wb = false;\n+    if (use_mem_state->is_Mach()) {\n+      int ideal_op = use_mem_state->as_Mach()->ideal_Opcode();\n+      is_cache_wb = (ideal_op == Op_CacheWB);\n+    }\n+    assert(!use_mem_state->needs_anti_dependence_check() || is_cache_wb, \"no loads\");\n+#endif\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1933,1 +1933,1 @@\n-void GraphKit::replace_call(CallNode* call, Node* result, bool do_replaced_nodes) {\n+void GraphKit::replace_call(CallNode* call, Node* result, bool do_replaced_nodes, bool do_asserts) {\n@@ -1947,1 +1947,1 @@\n-  call->extract_projections(&callprojs, true);\n+  call->extract_projections(&callprojs, true, do_asserts);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -734,1 +734,1 @@\n-  void replace_call(CallNode* call, Node* result, bool do_replaced_nodes = false);\n+  void replace_call(CallNode* call, Node* result, bool do_replaced_nodes = false, bool do_asserts = true);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -381,20 +381,0 @@\n-  return st;\n-}\n-\n-\/\/ Card mark store. Must be ordered so that it will come after the store of\n-\/\/ the oop.\n-Node* IdealKit::storeCM(Node* ctl, Node* adr, Node *val, Node* oop_store, int oop_adr_idx,\n-                        BasicType bt,\n-                        int adr_idx) {\n-  assert(adr_idx != Compile::AliasIdxTop, \"use other store_to_memory factory\" );\n-  const TypePtr* adr_type = nullptr;\n-  debug_only(adr_type = C->get_adr_type(adr_idx));\n-  Node *mem = memory(adr_idx);\n-\n-  \/\/ Add required edge to oop_store, optimizer does not support precedence edges.\n-  \/\/ Convert required edge to precedence edge before allocation.\n-  Node* st = new StoreCMNode(ctl, mem, adr, adr_type, val, oop_store, oop_adr_idx);\n-\n-  st = transform(st);\n-  set_memory(st, adr_idx);\n-\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -237,9 +237,0 @@\n-  \/\/ Store a card mark ordered after store_oop\n-  Node* storeCM(Node* ctl,\n-                Node* adr,\n-                Node* val,\n-                Node* oop_store,\n-                int oop_adr_idx,\n-                BasicType bt,\n-                int adr_idx);\n-\n","filename":"src\/hotspot\/share\/opto\/idealKit.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1851,0 +1851,3 @@\n+      break;\n+    case AssertionPredicateType::FinalIv:\n+      st->print(\"#Final IV Assertion Predicate  \");\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -194,1 +194,0 @@\n-    case Op_StoreCM:\n@@ -726,1 +725,0 @@\n-        case Op_StoreCM:\n@@ -1007,15 +1005,0 @@\n-\n-#ifdef ASSERT\n-      if (UseG1GC) {\n-        if( n->is_Mach() && n->as_Mach()->ideal_Opcode() == Op_StoreCM ) {\n-          \/\/ Check the precedence edges\n-          for (uint prec = n->req(); prec < n->len(); prec++) {\n-            Node* oop_store = n->in(prec);\n-            if (oop_store != nullptr) {\n-              assert(get_block_for_node(oop_store)->_dom_depth <= block->_dom_depth, \"oop_store must dominate card-mark\");\n-            }\n-          }\n-        }\n-      }\n-#endif\n-\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -583,0 +583,2 @@\n+  case vmIntrinsics::_Reference_clear0:         return inline_reference_clear0(false);\n+  case vmIntrinsics::_PhantomReference_clear0:  return inline_reference_clear0(true);\n@@ -756,0 +758,2 @@\n+  case vmIntrinsics::_VectorSelectFromTwoVectorOp:\n+    return inline_vector_select_from_two_vectors();\n@@ -6965,0 +6969,42 @@\n+\/\/----------------------------inline_reference_clear0----------------------------\n+\/\/ void java.lang.ref.Reference.clear0();\n+\/\/ void java.lang.ref.PhantomReference.clear0();\n+bool LibraryCallKit::inline_reference_clear0(bool is_phantom) {\n+  \/\/ This matches the implementation in JVM_ReferenceClear, see the comments there.\n+\n+  \/\/ Get arguments\n+  Node* reference_obj = null_check_receiver();\n+  if (stopped()) return true;\n+\n+  \/\/ Common access parameters\n+  DecoratorSet decorators = IN_HEAP | AS_NO_KEEPALIVE;\n+  decorators |= (is_phantom ? ON_PHANTOM_OOP_REF : ON_WEAK_OOP_REF);\n+  Node* referent_field_addr = basic_plus_adr(reference_obj, java_lang_ref_Reference::referent_offset());\n+  const TypePtr* referent_field_addr_type = _gvn.type(referent_field_addr)->isa_ptr();\n+  const Type* val_type = TypeOopPtr::make_from_klass(env()->Object_klass());\n+\n+  Node* referent = access_load_at(reference_obj,\n+                                  referent_field_addr,\n+                                  referent_field_addr_type,\n+                                  val_type,\n+                                  T_OBJECT,\n+                                  decorators);\n+\n+  IdealKit ideal(this);\n+#define __ ideal.\n+  __ if_then(referent, BoolTest::ne, null());\n+    sync_kit(ideal);\n+    access_store_at(reference_obj,\n+                    referent_field_addr,\n+                    referent_field_addr_type,\n+                    null(),\n+                    val_type,\n+                    T_OBJECT,\n+                    decorators);\n+    __ sync_kit(this);\n+  __ end_if();\n+  final_sync(ideal);\n+#undef __\n+\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -300,0 +300,1 @@\n+  bool inline_reference_clear0(bool is_phantom);\n@@ -376,0 +377,1 @@\n+  bool inline_vector_select_from_two_vectors();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1156,1 +1156,2 @@\n-                                                  ConNode* zero, Invariance& invar, Deoptimization::DeoptReason reason) {\n+                                                  ConNode* zero, Invariance& invar,\n+                                                  Deoptimization::DeoptReason deopt_reason) {\n@@ -1168,1 +1169,1 @@\n-    IfProjNode* hoisted_check_predicate_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason,\n+    IfProjNode* hoisted_check_predicate_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, deopt_reason,\n@@ -1209,3 +1210,3 @@\n-    Node* rng = cmp->in(2);\n-    assert(rng->Opcode() == Op_LoadRange || iff->is_RangeCheck() || _igvn.type(rng)->is_int()->_lo >= 0, \"must be\");\n-    assert(invar.is_invariant(rng), \"range must be invariant\");\n+    Node* range = cmp->in(2);\n+    assert(range->Opcode() == Op_LoadRange || iff->is_RangeCheck() || _igvn.type(range)->is_int()->_lo >= 0, \"must be\");\n+    assert(invar.is_invariant(range), \"range must be invariant\");\n@@ -1240,1 +1241,1 @@\n-    rng = invar.clone(rng, ctrl);\n+    range = invar.clone(range, ctrl);\n@@ -1248,1 +1249,1 @@\n-    BoolNode* lower_bound_bol = rc_predicate(ctrl, scale, offset, init, limit, stride, rng, false, overflow);\n+    BoolNode* lower_bound_bol = rc_predicate(ctrl, scale, offset, init, limit, stride, range, false, overflow);\n@@ -1251,1 +1252,1 @@\n-    IfProjNode* lower_bound_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : if_opcode);\n+    IfProjNode* lower_bound_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, deopt_reason, overflow ? Op_If : if_opcode);\n@@ -1260,1 +1261,1 @@\n-    BoolNode* upper_bound_bol = rc_predicate(lower_bound_proj, scale, offset, init, limit, stride, rng, true, overflow);\n+    BoolNode* upper_bound_bol = rc_predicate(lower_bound_proj, scale, offset, init, limit, stride, range, true, overflow);\n@@ -1262,1 +1263,1 @@\n-    IfProjNode* upper_bound_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : if_opcode);\n+    IfProjNode* upper_bound_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, deopt_reason, overflow ? Op_If : if_opcode);\n@@ -1275,2 +1276,2 @@\n-        add_template_assertion_predicate(iff, loop, hoisted_check_proj, parse_predicate_proj, upper_bound_proj, scale,\n-                                         offset, init, limit, stride, rng, overflow, reason);\n+        create_template_assertion_predicate(if_opcode, cl, parse_predicate_proj, upper_bound_proj, scale, offset, range,\n+                                            deopt_reason);\n@@ -1312,47 +1313,9 @@\n-IfTrueNode* PhaseIdealLoop::add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj,\n-                                                             ParsePredicateSuccessProj* parse_predicate_proj,\n-                                                             IfProjNode* upper_bound_proj, const int scale, Node* offset,\n-                                                             Node* init, Node* limit, const jint stride,\n-                                                             Node* rng, bool& overflow, Deoptimization::DeoptReason reason) {\n-  \/\/ First predicate for the initial value on first loop iteration\n-  Node* opaque_init = new OpaqueLoopInitNode(C, init);\n-  register_new_node(opaque_init, upper_bound_proj);\n-  bool negate = (if_proj->_con != parse_predicate_proj->_con);\n-  BoolNode* bol = rc_predicate(upper_bound_proj, scale, offset, opaque_init, limit, stride, rng,\n-                               (stride > 0) != (scale > 0), overflow);\n-  Node* opaque_bol = new Opaque4Node(C, bol, _igvn.intcon(1)); \/\/ This will go away once loop opts are over\n-  C->add_template_assertion_predicate_opaq(opaque_bol);\n-  register_new_node(opaque_bol, upper_bound_proj);\n-  IfTrueNode* new_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode(),\n-                                                     false NOT_PRODUCT(COMMA AssertionPredicateType::InitValue));\n-  _igvn.replace_input_of(new_proj->in(0), 1, opaque_bol);\n-  assert(opaque_init->outcnt() > 0, \"should be used\");\n-\n-  \/\/ Second predicate for init + (current stride - initial stride)\n-  \/\/ This is identical to the previous predicate initially but as\n-  \/\/ unrolling proceeds current stride is updated.\n-  Node* init_stride = loop->_head->as_CountedLoop()->stride();\n-  Node* opaque_stride = new OpaqueLoopStrideNode(C, init_stride);\n-  register_new_node(opaque_stride, new_proj);\n-  Node* max_value = new SubINode(opaque_stride, init_stride);\n-  register_new_node(max_value, new_proj);\n-  max_value = new AddINode(opaque_init, max_value);\n-  register_new_node(max_value, new_proj);\n-  \/\/ init + (current stride - initial stride) is within the loop so narrow its type by leveraging the type of the iv Phi\n-  const Type* type_iv = loop->_head->as_CountedLoop()->phi()->bottom_type();\n-  assert(!type_iv->is_int()->is_con(), \"constant indicates one loop iteration for which we bailed out earlier\");\n-  max_value = new CastIINode(new_proj, max_value, type_iv);\n-  register_new_node(max_value, new_proj);\n-\n-  bol = rc_predicate(new_proj, scale, offset, max_value, limit, stride, rng, (stride > 0) != (scale > 0),\n-                     overflow);\n-  opaque_bol = new Opaque4Node(C, bol, _igvn.intcon(1));\n-  C->add_template_assertion_predicate_opaq(opaque_bol);\n-  register_new_node(opaque_bol, new_proj);\n-  new_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode(),\n-                                         false NOT_PRODUCT(COMMA AssertionPredicateType::LastValue));\n-  _igvn.replace_input_of(new_proj->in(0), 1, opaque_bol);\n-  assert(max_value->outcnt() > 0, \"should be used\");\n-  assert(assertion_predicate_has_loop_opaque_node(new_proj->in(0)->as_If()), \"unexpected\");\n-\n-  return new_proj;\n+IfTrueNode* PhaseIdealLoop::create_template_assertion_predicate(const int if_opcode, CountedLoopNode* loop_head,\n+                                                                ParsePredicateSuccessProj* parse_predicate_proj,\n+                                                                IfProjNode* new_control, const int scale, Node* offset,\n+                                                                Node* range, Deoptimization::DeoptReason deopt_reason) {\n+\n+  TemplateAssertionPredicateCreator template_assertion_predicate_creator(loop_head, scale, offset, range, this);\n+  return template_assertion_predicate_creator.create_with_uncommon_trap(new_control, parse_predicate_proj, deopt_reason,\n+                                                                        if_opcode);\n+\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":22,"deletions":59,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -1464,1 +1464,1 @@\n-                                                                   Node* new_stride, Node* control) {\n+                                                                   Node* new_stride, Node* new_control) {\n@@ -1467,3 +1467,4 @@\n-  InitializedAssertionPredicateCreator initialized_assertion_predicate(template_assertion_predicate, new_init,\n-                                                                       new_stride, this);\n-  IfTrueNode* success_proj = initialized_assertion_predicate.create(control);\n+  InitializedAssertionPredicateCreator initialized_assertion_predicate(this);\n+  IfTrueNode* success_proj = initialized_assertion_predicate.create_from_template(template_assertion_predicate,\n+                                                                                  new_control, new_init, new_stride);\n+\n@@ -1480,1 +1481,1 @@\n-                                                         Node* control, IdealLoopTree* outer_loop, Node* input_proj) {\n+                                                         Node* control, IdealLoopTree* outer_loop, Node* new_control) {\n@@ -1485,17 +1486,5 @@\n-  Node* proj = predicate->clone();\n-  Node* other_proj = uncommon_proj->clone();\n-  Node* new_iff = iff->clone();\n-  new_iff->set_req(1, new_opaque_node);\n-  proj->set_req(0, new_iff);\n-  other_proj->set_req(0, new_iff);\n-  Node* frame = new ParmNode(C->start(), TypeFunc::FramePtr);\n-  register_new_node(frame, C->start());\n-  Node* halt = new HaltNode(other_proj, frame, \"Template Assertion Predicates are always removed before code generation\");\n-  _igvn.add_input_to(C->root(), halt);\n-  new_iff->set_req(0, input_proj);\n-\n-  register_control(new_iff, outer_loop == _ltree_root ? _ltree_root : outer_loop->_parent, input_proj);\n-  register_control(proj, outer_loop == _ltree_root ? _ltree_root : outer_loop->_parent, new_iff);\n-  register_control(other_proj, _ltree_root, new_iff);\n-  register_control(halt, _ltree_root, other_proj);\n-  assert(assertion_predicate_has_loop_opaque_node(proj->in(0)->as_If()),\n+  AssertionPredicateIfCreator assertion_predicate_if_creator(this);\n+  IfTrueNode* success_proj =\n+      assertion_predicate_if_creator.create_for_template(new_control, iff->Opcode(), new_opaque_node\n+                                                         NOT_PRODUCT(COMMA iff->assertion_predicate_type()));\n+  assert(assertion_predicate_has_loop_opaque_node(success_proj->in(0)->as_If()),\n@@ -1503,1 +1492,1 @@\n-  return proj;\n+  return success_proj;\n@@ -2735,34 +2724,0 @@\n-\/\/ Same as PhaseIdealLoop::duplicate_predicates() but for range checks\n-\/\/ eliminated by iteration splitting.\n-Node* PhaseIdealLoop::add_range_check_elimination_assertion_predicate(\n-    IdealLoopTree* loop, Node* ctrl, const int scale_con, Node* offset, Node* limit, jint stride_con, Node* value,\n-    const bool is_template NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type)) {\n-  bool overflow = false;\n-  BoolNode* bol = rc_predicate(ctrl, scale_con, offset, value, nullptr, stride_con,\n-                               limit, (stride_con > 0) != (scale_con > 0), overflow);\n-  Node* opaque_assertion_predicate;\n-  if (is_template) {\n-    opaque_assertion_predicate = new Opaque4Node(C, bol, _igvn.intcon(1));\n-  } else {\n-    opaque_assertion_predicate = new OpaqueInitializedAssertionPredicateNode(bol, C);\n-  }\n-  register_new_node(opaque_assertion_predicate, ctrl);\n-  IfNode* new_iff = nullptr;\n-  if (overflow) {\n-    new_iff = new IfNode(ctrl, opaque_assertion_predicate, PROB_MAX, COUNT_UNKNOWN);\n-  } else {\n-    new_iff = new RangeCheckNode(ctrl, opaque_assertion_predicate, PROB_MAX, COUNT_UNKNOWN);\n-  }\n-  register_control(new_iff, loop->_parent, ctrl);\n-  Node* iffalse = new IfFalseNode(new_iff);\n-  register_control(iffalse, _ltree_root, new_iff);\n-  ProjNode* iftrue = new IfTrueNode(new_iff);\n-  register_control(iftrue, loop->_parent, new_iff);\n-  Node *frame = new ParmNode(C->start(), TypeFunc::FramePtr);\n-  register_new_node(frame, C->start());\n-  Node* halt = new HaltNode(iffalse, frame, \"range check predicate failed which is impossible\");\n-  register_control(halt, _ltree_root, iffalse);\n-  _igvn.add_input_to(C->root(), halt);\n-  return iftrue;\n-}\n-\n@@ -2977,0 +2932,1 @@\n+          InitializedAssertionPredicateCreator initialized_assertion_predicate_creator(this);\n@@ -2980,4 +2936,4 @@\n-            \/\/ Add an Assertion Predicate for that corner case. The final iv is computed from LoopLimit which is the\n-            \/\/ LoopNode::limit() only if abs(stride) == 1 otherwise the computation depends on LoopNode::init_trip() as\n-            \/\/ well. When LoopLimit only depends on LoopNode::limit(), there are cases where the zero trip guard for the\n-            \/\/ main loop doesn't constant fold after range check elimination but, the array access for the final\n+            \/\/ Add an Initialized Assertion Predicate for that corner case. The final iv is computed from LoopLimit which\n+            \/\/ is the LoopNode::limit() only if abs(stride) == 1 otherwise the computation depends on LoopNode::init_trip()\n+            \/\/ as well. When LoopLimit only depends on LoopNode::limit(), there are cases where the zero trip guard for\n+            \/\/ the main loop doesn't constant fold after range check elimination but, the array access for the final\n@@ -2986,2 +2942,8 @@\n-            loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n-                                                                         int_limit, stride_con, final_iv_placeholder, false);\n+            \/\/ Note that we do not need to emit a Template Assertion Predicate to update this predicate. When further\n+            \/\/ splitting this loop, the final IV will still be the same. When unrolling the loop, we will remove a\n+            \/\/ previously added Initialized Assertion Predicate here. But then abs(stride) is greater than 1, and we\n+            \/\/ cannot remove an empty loop with a constant limit when init is not a constant as well. We will use\n+            \/\/ a LoopLimitCheck node that can only be folded if the zero grip guard is also foldable.\n+            loop_entry = initialized_assertion_predicate_creator.create(final_iv_placeholder, loop_entry, stride_con,\n+                                                                        scale_con, int_offset, int_limit NOT_PRODUCT(\n+                                                                        COMMA AssertionPredicateType::FinalIv));\n@@ -2991,5 +2953,0 @@\n-          \/\/ Initialized Assertion Predicate for the value of the initial main-loop.\n-          loop_entry = add_range_check_elimination_assertion_predicate(loop, loop_entry, scale_con, int_offset,\n-                                                                       int_limit, stride_con, init, false);\n-          assert(!assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n-\n@@ -2998,3 +2955,3 @@\n-          loop_entry = add_range_check_elimination_assertion_predicate(\n-              loop, loop_entry, scale_con, int_offset, int_limit, stride_con, opaque_init, true\n-              NOT_PRODUCT(COMMA AssertionPredicateType::InitValue));\n+          TemplateAssertionPredicateCreator template_assertion_predicate_creator(cl, scale_con , int_offset, int_limit,\n+                                                                                 this);\n+          loop_entry = template_assertion_predicate_creator.create_with_halt(loop_entry);\n@@ -3003,13 +2960,5 @@\n-          Node* opaque_stride = new OpaqueLoopStrideNode(C, cl->stride());\n-          register_new_node(opaque_stride, loop_entry);\n-          Node* max_value = new SubINode(opaque_stride, cl->stride());\n-          register_new_node(max_value, loop_entry);\n-          max_value = new AddINode(opaque_init, max_value);\n-          register_new_node(max_value, loop_entry);\n-          \/\/ init + (current stride - initial stride) is within the loop so narrow its type by leveraging the type of the iv Phi\n-          max_value = new CastIINode(loop_entry, max_value, loop->_head->as_CountedLoop()->phi()->bottom_type());\n-          register_new_node(max_value, loop_entry);\n-          loop_entry = add_range_check_elimination_assertion_predicate(\n-              loop, loop_entry, scale_con, int_offset, int_limit, stride_con, max_value, true\n-              NOT_PRODUCT(COMMA AssertionPredicateType::LastValue));\n-          assert(assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n+          \/\/ Initialized Assertion Predicate for the value of the initial main-loop.\n+          loop_entry = initialized_assertion_predicate_creator.create(init, loop_entry, stride_con, scale_con,\n+                                                                      int_offset, int_limit NOT_PRODUCT(COMMA\n+                                                                      AssertionPredicateType::InitValue));\n+          assert(!assertion_predicate_has_loop_opaque_node(loop_entry->in(0)->as_If()), \"unexpected\");\n@@ -3075,3 +3024,0 @@\n-\n-      C->print_method(PHASE_AFTER_RANGE_CHECK_ELIMINATION, 4, cl);\n-\n@@ -3141,0 +3087,2 @@\n+\n+  C->print_method(PHASE_AFTER_RANGE_CHECK_ELIMINATION, 4, cl);\n@@ -3820,1 +3768,1 @@\n-      if (opc == Op_StoreP || opc == Op_StoreN || opc == Op_StoreNKlass || opc == Op_StoreCM) {\n+      if (opc == Op_StoreP || opc == Op_StoreN || opc == Op_StoreNKlass) {\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":36,"deletions":88,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -2604,1 +2604,1 @@\n-  int stride_p;\n+  jlong stride_p;\n@@ -2613,1 +2613,1 @@\n-    stride_p = -stride_con;\n+    stride_p = -(jlong)stride_con;\n@@ -2616,1 +2616,1 @@\n-    max = (julong)min_jint;\n+    max = (julong)(juint)min_jint; \/\/ double cast to get 0x0000000080000000, not 0xffffffff80000000\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -954,1 +954,1 @@\n-                                           IdealLoopTree* outer_loop, Node* input_proj);\n+                                           IdealLoopTree* outer_loop, Node* new_control);\n@@ -1387,1 +1387,1 @@\n-                                    Invariance& invar, Deoptimization::DeoptReason reason);\n+                                    Invariance& invar, Deoptimization::DeoptReason deopt_reason);\n@@ -1393,4 +1393,4 @@\n-  IfTrueNode* add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj,\n-                                               ParsePredicateSuccessProj* parse_predicate_proj,\n-                                               IfProjNode* upper_bound_proj, int scale, Node* offset, Node* init, Node* limit,\n-                                               jint stride, Node* rng, bool& overflow, Deoptimization::DeoptReason reason);\n+  IfTrueNode* create_template_assertion_predicate(int if_opcode, CountedLoopNode* loop_head,\n+                                                  ParsePredicateSuccessProj* parse_predicate_proj,\n+                                                  IfProjNode* new_control, int scale, Node* offset,\n+                                                  Node* range, Deoptimization::DeoptReason deopt_reason);\n@@ -1398,3 +1398,0 @@\n-  Node* add_range_check_elimination_assertion_predicate(\n-      IdealLoopTree* loop, Node* predicate_proj, int scale_con, Node* offset, Node* limit, int stride_con, Node* value,\n-      bool is_template NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type = AssertionPredicateType::None));\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -4551,1 +4551,0 @@\n-    const Type* bt_t      = Type::get_const_basic_type(bt);\n@@ -4631,1 +4630,1 @@\n-    VectorNode* identity_vector = VectorNode::scalar2vector(identity_scalar, vector_length, bt_t);\n+    VectorNode* identity_vector = VectorNode::scalar2vector(identity_scalar, vector_length, bt);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2439,0 +2439,1 @@\n+    case Op_SelectFromTwoVector:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -345,1 +345,0 @@\n-  static const TypeVectMask* predicate_reg_type(const Type* elemTy, int length);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3465,3 +3465,1 @@\n-  \/\/ unsafe if I have intervening uses...  Also disallowed for StoreCM\n-  \/\/ since they must follow each StoreP operation.  Redundant StoreCMs\n-  \/\/ are eliminated just before matching in final_graph_reshape.\n+  \/\/ unsafe if I have intervening uses.\n@@ -3477,1 +3475,1 @@\n-    while (st->is_Store() && st->outcnt() == 1 && st->Opcode() != Op_StoreCM) {\n+    while (st->is_Store() && st->outcnt() == 1) {\n@@ -3784,42 +3782,0 @@\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-Node* StoreCMNode::Identity(PhaseGVN* phase) {\n-  \/\/ No need to card mark when storing a null ptr\n-  Node* my_store = in(MemNode::OopStore);\n-  if (my_store->is_Store()) {\n-    const Type *t1 = phase->type( my_store->in(MemNode::ValueIn) );\n-    if( t1 == TypePtr::NULL_PTR ) {\n-      return in(MemNode::Memory);\n-    }\n-  }\n-  return this;\n-}\n-\n-\/\/=============================================================================\n-\/\/------------------------------Ideal---------------------------------------\n-Node *StoreCMNode::Ideal(PhaseGVN *phase, bool can_reshape){\n-  Node* progress = StoreNode::Ideal(phase, can_reshape);\n-  if (progress != nullptr) return progress;\n-\n-  Node* my_store = in(MemNode::OopStore);\n-  if (my_store->is_MergeMem()) {\n-    Node* mem = my_store->as_MergeMem()->memory_at(oop_alias_idx());\n-    set_req_X(MemNode::OopStore, mem, phase);\n-    return this;\n-  }\n-\n-  return nullptr;\n-}\n-\n-\/\/------------------------------Value-----------------------------------------\n-const Type* StoreCMNode::Value(PhaseGVN* phase) const {\n-  \/\/ Either input is TOP ==> the result is TOP (checked in StoreNode::Value).\n-  \/\/ If extra input is TOP ==> the result is TOP\n-  const Type* t = phase->type(in(MemNode::OopStore));\n-  if (t == Type::TOP) {\n-    return Type::TOP;\n-  }\n-  return StoreNode::Value(phase);\n-}\n-\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":2,"deletions":46,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n-         ValueIn,               \/\/ Value to store\n-         OopStore               \/\/ Preceding oop store, only in StoreCM\n+         ValueIn                \/\/ Value to store\n@@ -780,30 +779,0 @@\n-\/\/------------------------------StoreCMNode-----------------------------------\n-\/\/ Store card-mark byte to memory for CM\n-\/\/ The last StoreCM before a SafePoint must be preserved and occur after its \"oop\" store\n-\/\/ Preceding equivalent StoreCMs may be eliminated.\n-class StoreCMNode : public StoreNode {\n- private:\n-  virtual uint hash() const { return StoreNode::hash() + _oop_alias_idx; }\n-  virtual bool cmp( const Node &n ) const {\n-    return _oop_alias_idx == ((StoreCMNode&)n)._oop_alias_idx\n-      && StoreNode::cmp(n);\n-  }\n-  virtual uint size_of() const { return sizeof(*this); }\n-  int _oop_alias_idx;   \/\/ The alias_idx of OopStore\n-\n-public:\n-  StoreCMNode( Node *c, Node *mem, Node *adr, const TypePtr* at, Node *val, Node *oop_store, int oop_alias_idx ) :\n-    StoreNode(c, mem, adr, at, val, oop_store, MemNode::release),\n-    _oop_alias_idx(oop_alias_idx) {\n-    assert(_oop_alias_idx >= Compile::AliasIdxRaw ||\n-           (_oop_alias_idx == Compile::AliasIdxBot && !Compile::current()->do_aliasing()),\n-           \"bad oop alias idx\");\n-  }\n-  virtual int Opcode() const;\n-  virtual Node* Identity(PhaseGVN* phase);\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual const Type* Value(PhaseGVN* phase) const;\n-  virtual BasicType memory_type() const { return T_VOID; } \/\/ unspecific\n-  int oop_alias_idx() const { return _oop_alias_idx; }\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1668,24 +1668,1 @@\n-        }\n-#ifdef ASSERT\n-          \/\/ Check that oop-store precedes the card-mark\n-        else if (mach->ideal_Opcode() == Op_StoreCM) {\n-          uint storeCM_idx = j;\n-          int count = 0;\n-          for (uint prec = mach->req(); prec < mach->len(); prec++) {\n-            Node *oop_store = mach->in(prec);  \/\/ Precedence edge\n-            if (oop_store == nullptr) continue;\n-            count++;\n-            uint i4;\n-            for (i4 = 0; i4 < last_inst; ++i4) {\n-              if (block->get_node(i4) == oop_store) {\n-                break;\n-              }\n-            }\n-            \/\/ Note: This test can provide a false failure if other precedence\n-            \/\/ edges have been added to the storeCMNode.\n-            assert(i4 == last_inst || i4 < storeCM_idx, \"CM card-mark executes before oop-store\");\n-          }\n-          assert(count > 0, \"storeCM expects at least one precedence edge\");\n-        }\n-#endif\n-        else if (!n->is_Proj()) {\n+        } else if (!n->is_Proj()) {\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"opto\/addnode.hpp\"\n@@ -27,0 +28,1 @@\n+#include \"opto\/castnode.hpp\"\n@@ -250,2 +252,2 @@\n-Opaque4Node* TemplateAssertionExpression::clone_and_replace_init_and_stride(Node* new_init, Node* new_stride,\n-                                                                            Node* new_ctrl,\n+Opaque4Node* TemplateAssertionExpression::clone_and_replace_init_and_stride(Node* new_control, Node* new_init,\n+                                                                            Node* new_stride,\n@@ -254,1 +256,1 @@\n-  return clone(replace_init_and_stride_strategy, new_ctrl, phase);\n+  return clone(replace_init_and_stride_strategy, new_control, phase);\n@@ -373,6 +375,120 @@\n-InitializedAssertionPredicateCreator::InitializedAssertionPredicateCreator(IfNode* template_assertion_predicate, Node* new_init,\n-                                                                           Node* new_stride, PhaseIdealLoop* phase)\n-    : _template_assertion_predicate(template_assertion_predicate),\n-      _new_init(new_init),\n-      _new_stride(new_stride),\n-      _phase(phase) {}\n+\/\/ This class creates the Assertion Predicate expression to be used for a Template or Initialized Assertion Predicate.\n+class AssertionPredicateExpressionCreator : public StackObj {\n+  PhaseIdealLoop* const _phase;\n+  const jint _stride;\n+  const int _scale;\n+  Node* const _offset;\n+  Node* const _range;\n+  const bool _upper;\n+\n+ public:\n+  AssertionPredicateExpressionCreator(const int stride, const int scale, Node* offset, Node* range,\n+                                      PhaseIdealLoop* phase)\n+      : _phase(phase),\n+        _stride(stride),\n+        _scale(scale),\n+        _offset(offset),\n+        _range(range),\n+        _upper((_stride > 0) != (_scale > 0)) {} \/\/ Make sure rc_predicate() chooses the \"scale*init + offset\" case.\n+\n+  \/\/ Create the expression for a Template Assertion Predicate with an Opaque4 node.\n+  Opaque4Node* create_for_template(Node* new_control, Node* operand, bool& does_overflow) const {\n+    BoolNode* bool_for_expression =  _phase->rc_predicate(new_control, _scale, _offset, operand, nullptr,\n+                                                          _stride, _range, _upper, does_overflow);\n+    return create_opaque4_node(new_control, bool_for_expression);\n+  }\n+\n+ private:\n+  Opaque4Node* create_opaque4_node(Node* new_control, BoolNode* bool_for_expression) const {\n+    Compile* C = _phase->C;\n+    Opaque4Node* new_expression = new Opaque4Node(C, bool_for_expression, _phase->igvn().intcon(1));\n+    C->add_template_assertion_predicate_opaq(new_expression);\n+    _phase->register_new_node(new_expression, new_control);\n+    return new_expression;\n+  }\n+\n+ public:\n+  \/\/ Create the expression for an Initialized Assertion Predicate with an OpaqueInitializedAssertionPredicate node.\n+  OpaqueInitializedAssertionPredicateNode* create_for_initialized(Node* new_control, Node* operand,\n+                                                                  bool& does_overflow) const {\n+    BoolNode* bool_for_expression = _phase->rc_predicate(new_control, _scale, _offset, operand, nullptr,\n+                                                         _stride, _range, _upper, does_overflow);\n+    return create_opaque_initialized_assertion_predicate_node(new_control, bool_for_expression);\n+  }\n+\n+ private:\n+  OpaqueInitializedAssertionPredicateNode* create_opaque_initialized_assertion_predicate_node(\n+      Node* new_control, BoolNode* bool_for_expression) const {\n+    OpaqueInitializedAssertionPredicateNode* new_expression =\n+        new OpaqueInitializedAssertionPredicateNode(bool_for_expression, _phase->C);\n+    _phase->register_new_node(new_expression, new_control);\n+    return new_expression;\n+  }\n+};\n+\n+\/\/ Creates an If with a success and a fail path with the given assertion_expression. The only difference to\n+\/\/ create_for_initialized() is that we use a template specific Halt message on the fail path.\n+IfTrueNode* AssertionPredicateIfCreator::create_for_template(Node* new_control, const int if_opcode,\n+                                                             Node* assertion_expression NOT_PRODUCT(COMMA\n+                                                             const AssertionPredicateType assertion_predicate_type)) {\n+  const char* halt_message = \"Template Assertion Predicates are always removed before code generation\";\n+  return create(new_control, if_opcode, assertion_expression, halt_message NOT_PRODUCT(COMMA assertion_predicate_type));\n+}\n+\n+\/\/ Creates an If with a success and a fail path with the given assertion_expression. The only difference to\n+\/\/ create_for_template() is that we use a initialized specific Halt message on the fail path.\n+IfTrueNode* AssertionPredicateIfCreator::create_for_initialized(Node* new_control, const int if_opcode,\n+                                                                Node* assertion_expression NOT_PRODUCT(COMMA\n+                                                                const AssertionPredicateType assertion_predicate_type)) {\n+  const char* halt_message = \"Initialized Assertion Predicate cannot fail\";\n+  return create(new_control, if_opcode, assertion_expression, halt_message NOT_PRODUCT(COMMA assertion_predicate_type));\n+}\n+\n+\/\/ Creates the If node for an Assertion Predicate with a success path and a fail path having a Halt node:\n+\/\/\n+\/\/      new_control   assertion_expression\n+\/\/                \\   \/\n+\/\/                 If\n+\/\/               \/    \\\n+\/\/        success     fail path\n+\/\/           proj      with Halt\n+\/\/\n+IfTrueNode* AssertionPredicateIfCreator::create(Node* new_control, const int if_opcode, Node* assertion_expression,\n+                                                const char* halt_message NOT_PRODUCT(COMMA\n+                                                const AssertionPredicateType assertion_predicate_type)) {\n+  assert(assertion_expression->is_Opaque4() || assertion_expression->is_OpaqueInitializedAssertionPredicate(),\n+         \"not a valid assertion expression\");\n+  IdealLoopTree* loop = _phase->get_loop(new_control);\n+  IfNode* if_node = create_if_node(new_control, if_opcode, assertion_expression, loop\n+                                   NOT_PRODUCT(COMMA assertion_predicate_type));\n+  create_fail_path(if_node, loop, halt_message);\n+  return create_success_path(if_node, loop);\n+}\n+\n+IfNode* AssertionPredicateIfCreator::create_if_node(Node* new_control, const int if_opcode, Node* assertion_expression,\n+                                                    IdealLoopTree* loop NOT_PRODUCT(COMMA\n+                                                    const AssertionPredicateType assertion_predicate_type)) {\n+  IfNode* if_node;\n+  if (if_opcode == Op_If) {\n+    if_node = new IfNode(new_control, assertion_expression, PROB_MAX, COUNT_UNKNOWN\n+                         NOT_PRODUCT(COMMA assertion_predicate_type));\n+  } else {\n+    assert(if_opcode == Op_RangeCheck, \"must be range check\");\n+    if_node = new RangeCheckNode(new_control, assertion_expression, PROB_MAX, COUNT_UNKNOWN\n+                                 NOT_PRODUCT(COMMA assertion_predicate_type));\n+  }\n+  _phase->register_control(if_node, loop, new_control);\n+  return if_node;\n+}\n+\n+IfTrueNode* AssertionPredicateIfCreator::create_success_path(IfNode* if_node, IdealLoopTree* loop) {\n+  IfTrueNode* success_proj = new IfTrueNode(if_node);\n+  _phase->register_control(success_proj, loop, if_node);\n+  return success_proj;\n+}\n+\n+void AssertionPredicateIfCreator::create_fail_path(IfNode* if_node, IdealLoopTree* loop, const char* halt_message) {\n+  IfFalseNode* fail_proj = new IfFalseNode(if_node);\n+  _phase->register_control(fail_proj, loop, if_node);\n+  create_halt_node(fail_proj, loop, halt_message);\n+}\n@@ -380,1 +496,103 @@\n-\/\/ Create an Initialized Assertion Predicate at the provided control from the _template_assertion_predicate.\n+void AssertionPredicateIfCreator::create_halt_node(IfFalseNode* fail_proj, IdealLoopTree* loop,\n+                                                   const char* halt_message) {\n+  StartNode* start_node = _phase->C->start();\n+  Node* frame = new ParmNode(start_node, TypeFunc::FramePtr);\n+  _phase->register_new_node(frame, start_node);\n+  Node* halt = new HaltNode(fail_proj, frame, halt_message);\n+  _phase->igvn().add_input_to(_phase->C->root(), halt);\n+  _phase->register_control(halt, loop, fail_proj);\n+}\n+\n+\/\/ Creates an init and last value Template Assertion Predicate connected together from a Parse Predicate with an UCT on\n+\/\/ the failing path. Returns the success projection of the last value Template Assertion Predicate.\n+IfTrueNode* TemplateAssertionPredicateCreator::create_with_uncommon_trap(\n+    Node* new_control, ParsePredicateSuccessProj* parse_predicate_success_proj,\n+    const Deoptimization::DeoptReason deopt_reason, const int if_opcode) {\n+  OpaqueLoopInitNode* opaque_init = create_opaque_init(new_control);\n+  bool does_overflow;\n+  Opaque4Node* template_assertion_predicate_expression = create_for_init_value(new_control, opaque_init,\n+                                                                               does_overflow);\n+  IfTrueNode* template_predicate_success_proj =\n+      create_if_node_with_uncommon_trap(template_assertion_predicate_expression, parse_predicate_success_proj,\n+                                        deopt_reason, if_opcode, does_overflow\n+                                        NOT_PRODUCT(COMMA AssertionPredicateType::InitValue));\n+  template_assertion_predicate_expression = create_for_last_value(template_predicate_success_proj, opaque_init,\n+                                                                  does_overflow);\n+  return create_if_node_with_uncommon_trap(template_assertion_predicate_expression, parse_predicate_success_proj,\n+                                           deopt_reason, if_opcode, does_overflow\n+                                           NOT_PRODUCT(COMMA AssertionPredicateType::LastValue));\n+}\n+\n+OpaqueLoopInitNode* TemplateAssertionPredicateCreator::create_opaque_init(Node* new_control) {\n+  OpaqueLoopInitNode* opaque_init = new OpaqueLoopInitNode(_phase->C, _loop_head->init_trip());\n+  _phase->register_new_node(opaque_init, new_control);\n+  return opaque_init;\n+}\n+\n+Opaque4Node* TemplateAssertionPredicateCreator::create_for_init_value(Node* new_control, OpaqueLoopInitNode* opaque_init,\n+                                                                      bool& does_overflow) const {\n+  AssertionPredicateExpressionCreator expression_creator(_loop_head->stride_con(), _scale, _offset, _range, _phase);\n+  return expression_creator.create_for_template(new_control, opaque_init, does_overflow);\n+}\n+\n+IfTrueNode* TemplateAssertionPredicateCreator::create_if_node_with_uncommon_trap(\n+    Opaque4Node* template_assertion_predicate_expression, ParsePredicateSuccessProj* parse_predicate_success_proj,\n+    const Deoptimization::DeoptReason deopt_reason, const int if_opcode, const bool does_overflow\n+    NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type)) {\n+  IfTrueNode* success_proj = _phase->create_new_if_for_predicate(parse_predicate_success_proj, nullptr, deopt_reason,\n+                                                                 does_overflow ? Op_If : if_opcode, false\n+                                                                 NOT_PRODUCT(COMMA assertion_predicate_type));\n+  _phase->igvn().replace_input_of(success_proj->in(0), 1, template_assertion_predicate_expression);\n+  return success_proj;\n+}\n+\n+Opaque4Node* TemplateAssertionPredicateCreator::create_for_last_value(Node* new_control, OpaqueLoopInitNode* opaque_init,\n+                                                                      bool& does_overflow) const {\n+  Node* last_value = create_last_value(new_control, opaque_init);\n+  AssertionPredicateExpressionCreator expression_creator(_loop_head->stride_con(), _scale, _offset, _range, _phase);\n+  return expression_creator.create_for_template(new_control, last_value, does_overflow);\n+}\n+\n+Node* TemplateAssertionPredicateCreator::create_last_value(Node* new_control, OpaqueLoopInitNode* opaque_init) const {\n+  Node* init_stride = _loop_head->stride();\n+  Node* opaque_stride = new OpaqueLoopStrideNode(_phase->C, init_stride);\n+  _phase->register_new_node(opaque_stride, new_control);\n+  Node* last_value = new SubINode(opaque_stride, init_stride);\n+  _phase->register_new_node(last_value, new_control);\n+  last_value = new AddINode(opaque_init, last_value);\n+  _phase->register_new_node(last_value, new_control);\n+  \/\/ init + (current stride - initial stride) is within the loop so narrow its type by leveraging the type of the iv phi\n+  last_value = new CastIINode(new_control, last_value, _loop_head->phi()->bottom_type());\n+  _phase->register_new_node(last_value, new_control);\n+  return last_value;\n+}\n+\n+IfTrueNode* TemplateAssertionPredicateCreator::create_if_node_with_halt(\n+    Node* new_control, Opaque4Node* template_assertion_predicate_expression, bool does_overflow\n+    NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type)) {\n+  AssertionPredicateIfCreator assertion_predicate_if_creator(_phase);\n+  return assertion_predicate_if_creator.create_for_template(new_control, does_overflow ? Op_If : Op_RangeCheck,\n+                                                            template_assertion_predicate_expression\n+                                                            NOT_PRODUCT(COMMA assertion_predicate_type));\n+}\n+\n+\/\/ Creates an init and last value Template Assertion Predicate connected together with a Halt node on the failing path.\n+\/\/ Returns the success projection of the last value Template Assertion Predicate latter.\n+IfTrueNode* TemplateAssertionPredicateCreator::create_with_halt(Node* new_control) {\n+  OpaqueLoopInitNode* opaque_init = create_opaque_init(new_control);\n+  bool does_overflow;\n+  Opaque4Node* template_assertion_predicate_expression = create_for_init_value(new_control, opaque_init,\n+                                                                               does_overflow);\n+  IfTrueNode* template_predicate_success_proj =\n+      create_if_node_with_halt(new_control, template_assertion_predicate_expression, does_overflow\n+                               NOT_PRODUCT(COMMA AssertionPredicateType::InitValue));\n+  template_assertion_predicate_expression = create_for_last_value(template_predicate_success_proj, opaque_init,\n+                                                                  does_overflow);\n+  return create_if_node_with_halt(template_predicate_success_proj, template_assertion_predicate_expression,\n+                                  does_overflow NOT_PRODUCT(COMMA AssertionPredicateType::LastValue));\n+}\n+\n+InitializedAssertionPredicateCreator::InitializedAssertionPredicateCreator(PhaseIdealLoop* phase)\n+    : _phase(phase) {}\n+\n+\/\/ Create an Initialized Assertion Predicate from the provided template_assertion_predicate at 'new_control'.\n@@ -383,1 +601,1 @@\n-\/\/ - OpaqueLoop*Nodes with _new_init and _new_stride, respectively.\n+\/\/ - OpaqueLoop*Nodes with new_init and _ew_stride, respectively.\n@@ -387,1 +605,1 @@\n-\/\/             |  OpaqueLoopInitNode  OpaqueLoopStrideNode                      \/       _new_init    _new_stride\n+\/\/             |  OpaqueLoopInitNode  OpaqueLoopStrideNode                      \/        new_init    new_stride\n@@ -393,1 +611,1 @@\n-\/\/             \\                 Opaque4           ======>          control     \\  OpaqueInitializedAssertionPredicate\n+\/\/             \\                 Opaque4           ======>      new_control     \\  OpaqueInitializedAssertionPredicate\n@@ -400,14 +618,3 @@\n-IfTrueNode* InitializedAssertionPredicateCreator::create(Node* control) {\n-  IdealLoopTree* loop = _phase->get_loop(control);\n-  OpaqueInitializedAssertionPredicateNode* assertion_expression = create_assertion_expression(control);\n-  IfNode* if_node = create_if_node(control, assertion_expression, loop);\n-  create_fail_path(if_node, loop);\n-  return create_success_path(if_node, loop);\n-}\n-\n-\/\/ Create a new Assertion Expression to be used as bool input for the Initialized Assertion Predicate IfNode.\n-OpaqueInitializedAssertionPredicateNode* InitializedAssertionPredicateCreator::create_assertion_expression(Node* control) {\n-  Opaque4Node* template_opaque = _template_assertion_predicate->in(1)->as_Opaque4();\n-  TemplateAssertionExpression template_assertion_expression(template_opaque);\n-  Opaque4Node* tmp_opaque = template_assertion_expression.clone_and_replace_init_and_stride(_new_init, _new_stride,\n-                                                                                            control, _phase);\n+IfTrueNode* InitializedAssertionPredicateCreator::create_from_template(IfNode* template_assertion_predicate,\n+                                                                       Node* new_control, Node* new_init,\n+                                                                       Node* new_stride) {\n@@ -415,3 +622,3 @@\n-      new OpaqueInitializedAssertionPredicateNode(tmp_opaque->in(1)->as_Bool(), _phase->C);\n-  _phase->register_new_node(assertion_expression, control);\n-  return assertion_expression;\n+      create_assertion_expression_from_template(template_assertion_predicate, new_control, new_init, new_stride);\n+  return create_control_nodes(new_control, template_assertion_predicate->Opcode(), assertion_expression\n+                              NOT_PRODUCT(COMMA template_assertion_predicate->assertion_predicate_type()));\n@@ -420,10 +627,10 @@\n-IfNode* InitializedAssertionPredicateCreator::create_if_node(Node* control,\n-                                                             OpaqueInitializedAssertionPredicateNode* assertion_expression,\n-                                                             IdealLoopTree* loop) {\n-  const int if_opcode = _template_assertion_predicate->Opcode();\n-  NOT_PRODUCT(const AssertionPredicateType assertion_predicate_type = _template_assertion_predicate->assertion_predicate_type();)\n-  IfNode* if_node = if_opcode == Op_If ?\n-      new IfNode(control, assertion_expression, PROB_MAX, COUNT_UNKNOWN NOT_PRODUCT(COMMA assertion_predicate_type)) :\n-      new RangeCheckNode(control, assertion_expression, PROB_MAX, COUNT_UNKNOWN NOT_PRODUCT(COMMA assertion_predicate_type));\n-  _phase->register_control(if_node, loop, control);\n-  return if_node;\n+\/\/ Create a new Initialized Assertion Predicate directly without a template.\n+IfTrueNode* InitializedAssertionPredicateCreator::create(Node* operand, Node* new_control, const jint stride,\n+                                                         const int scale, Node* offset, Node* range NOT_PRODUCT(COMMA\n+                                                         AssertionPredicateType assertion_predicate_type)) {\n+  AssertionPredicateExpressionCreator expression_creator(stride, scale, offset, range, _phase);\n+  bool does_overflow;\n+  OpaqueInitializedAssertionPredicateNode* assertion_expression =\n+      expression_creator.create_for_initialized(new_control, operand, does_overflow);\n+  return create_control_nodes(new_control, does_overflow ? Op_If : Op_RangeCheck, assertion_expression\n+                              NOT_PRODUCT(COMMA assertion_predicate_type));\n@@ -432,4 +639,7 @@\n-IfTrueNode* InitializedAssertionPredicateCreator::create_success_path(IfNode* if_node, IdealLoopTree* loop) {\n-  IfTrueNode* success_proj = new IfTrueNode(if_node);\n-  _phase->register_control(success_proj, loop, if_node);\n-  return success_proj;\n+\/\/ Creates the CFG nodes for the Initialized Assertion Predicate.\n+IfTrueNode* InitializedAssertionPredicateCreator::create_control_nodes(\n+    Node* new_control, const int if_opcode, OpaqueInitializedAssertionPredicateNode* assertion_expression\n+    NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type)) {\n+  AssertionPredicateIfCreator assertion_predicate_if_creator(_phase);\n+  return assertion_predicate_if_creator.create_for_initialized(new_control, if_opcode, assertion_expression\n+                                                               NOT_PRODUCT(COMMA assertion_predicate_type));\n@@ -438,13 +648,15 @@\n-void InitializedAssertionPredicateCreator::create_fail_path(IfNode* if_node, IdealLoopTree* loop) {\n-  IfFalseNode* fail_proj = new IfFalseNode(if_node);\n-  _phase->register_control(fail_proj, loop, if_node);\n-  create_halt_node(fail_proj, loop);\n-}\n-\n-void InitializedAssertionPredicateCreator::create_halt_node(IfFalseNode* fail_proj, IdealLoopTree* loop) {\n-  StartNode* start_node = _phase->C->start();\n-  Node* frame = new ParmNode(start_node, TypeFunc::FramePtr);\n-  _phase->register_new_node(frame, start_node);\n-  Node* halt = new HaltNode(fail_proj, frame, \"Initialized Assertion Predicate cannot fail\");\n-  _phase->igvn().add_input_to(_phase->C->root(), halt);\n-  _phase->register_control(halt, loop, fail_proj);\n+\/\/ Create a new Assertion Expression based from the given template to be used as bool input for the Initialized\n+\/\/ Assertion Predicate IfNode.\n+OpaqueInitializedAssertionPredicateNode*\n+InitializedAssertionPredicateCreator::create_assertion_expression_from_template(IfNode* template_assertion_predicate,\n+                                                                                Node* new_control, Node* new_init,\n+                                                                                Node* new_stride) {\n+  Opaque4Node* template_opaque = template_assertion_predicate->in(1)->as_Opaque4();\n+  TemplateAssertionExpression template_assertion_expression(template_opaque);\n+  Opaque4Node* tmp_opaque = template_assertion_expression.clone_and_replace_init_and_stride(new_control, new_init,\n+                                                                                            new_stride,\n+                                                                                            _phase);\n+  OpaqueInitializedAssertionPredicateNode* assertion_expression =\n+      new OpaqueInitializedAssertionPredicateNode(tmp_opaque->in(1)->as_Bool(), _phase->C);\n+  _phase->register_new_node(assertion_expression, new_control);\n+  return assertion_expression;\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":269,"deletions":57,"binary":false,"changes":326,"status":"modified"},{"patch":"@@ -210,1 +210,3 @@\n-  LastValue\n+  LastValue,\n+  \/\/ Used for the Initialized Assertion Predicate emitted during Range Check Elimination for the final IV value.\n+  FinalIv\n@@ -445,2 +447,3 @@\n-  Opaque4Node* clone_and_replace_init(Node* new_init, Node* new_ctrl,PhaseIdealLoop* phase);\n-  Opaque4Node* clone_and_replace_init_and_stride(Node* new_init, Node* new_stride, Node* new_ctrl, PhaseIdealLoop* phase);\n+  Opaque4Node* clone_and_replace_init(Node* new_init, Node* new_ctrl, PhaseIdealLoop* phase);\n+  Opaque4Node* clone_and_replace_init_and_stride(Node* new_control, Node* new_init, Node* new_stride,\n+                                                 PhaseIdealLoop* phase);\n@@ -523,1 +526,59 @@\n-\/\/ This class creates a new Initialized Assertion Predicate.\n+\/\/ This class is used to create the actual If node with a success path and a fail path with a Halt node.\n+class AssertionPredicateIfCreator : public StackObj {\n+  PhaseIdealLoop* const _phase;\n+\n+ public:\n+  explicit AssertionPredicateIfCreator(PhaseIdealLoop* const phase) : _phase(phase) {}\n+  NONCOPYABLE(AssertionPredicateIfCreator);\n+\n+  IfTrueNode* create_for_initialized(Node* new_control, int if_opcode, Node* assertion_expression\n+                                     NOT_PRODUCT(COMMA const AssertionPredicateType assertion_predicate_type));\n+  IfTrueNode* create_for_template(Node* new_control, int if_opcode, Node* assertion_expression\n+                                  NOT_PRODUCT(COMMA const AssertionPredicateType assertion_predicate_type));\n+ private:\n+  IfTrueNode* create(Node* new_control, int if_opcode, Node* assertion_expression, const char* halt_message\n+                     NOT_PRODUCT(COMMA const AssertionPredicateType assertion_predicate_type));\n+  IfNode* create_if_node(Node* new_control, int if_opcode, Node* assertion_expression, IdealLoopTree* loop\n+                         NOT_PRODUCT(COMMA const AssertionPredicateType assertion_predicate_type));\n+  IfTrueNode* create_success_path(IfNode* if_node, IdealLoopTree* loop);\n+  void create_fail_path(IfNode* if_node, IdealLoopTree* loop, const char* halt_message);\n+  void create_halt_node(IfFalseNode* fail_proj, IdealLoopTree* loop, const char* halt_message);\n+};\n+\n+\/\/ This class is used to create a Template Assertion Predicate either with an UCT or a Halt Node from scratch.\n+class TemplateAssertionPredicateCreator : public StackObj {\n+  CountedLoopNode* const _loop_head;\n+  const int _scale;\n+  Node* const _offset;\n+  Node* const _range;\n+  PhaseIdealLoop* const _phase;\n+\n+  OpaqueLoopInitNode* create_opaque_init(Node* new_control);\n+  Opaque4Node* create_for_init_value(Node* new_control, OpaqueLoopInitNode* opaque_init, bool& does_overflow) const;\n+  Opaque4Node* create_for_last_value(Node* new_control, OpaqueLoopInitNode* opaque_init, bool& does_overflow) const;\n+  Node* create_last_value(Node* new_control, OpaqueLoopInitNode* opaque_init) const;\n+  IfTrueNode* create_if_node_with_uncommon_trap(Opaque4Node* template_assertion_predicate_expression,\n+                                                ParsePredicateSuccessProj* parse_predicate_success_proj,\n+                                                Deoptimization::DeoptReason deopt_reason, int if_opcode,\n+                                                bool does_overflow\n+                                                NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type));\n+  IfTrueNode* create_if_node_with_halt(Node* new_control, Opaque4Node* template_assertion_predicate_expression,\n+                                       bool does_overflow\n+                                       NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type));\n+\n+ public:\n+  TemplateAssertionPredicateCreator(CountedLoopNode* loop_head, int scale, Node* offset, Node* range,\n+                                    PhaseIdealLoop* phase)\n+      : _loop_head(loop_head),\n+        _scale(scale),\n+        _offset(offset),\n+        _range(range),\n+        _phase(phase) {}\n+  NONCOPYABLE(TemplateAssertionPredicateCreator);\n+\n+  IfTrueNode* create_with_uncommon_trap(Node* new_control, ParsePredicateSuccessProj* parse_predicate_success_proj,\n+                                        Deoptimization::DeoptReason deopt_reason, int if_opcode);\n+  IfTrueNode* create_with_halt(Node* new_control);\n+};\n+\n+\/\/ This class creates a new Initialized Assertion Predicate either from a template or from scratch.\n@@ -525,3 +586,0 @@\n-  IfNode* const _template_assertion_predicate;\n-  Node* const _new_init;\n-  Node* const _new_stride;\n@@ -531,2 +589,1 @@\n-  InitializedAssertionPredicateCreator(IfNode* template_assertion_predicate, Node* new_init, Node* new_stride,\n-                                       PhaseIdealLoop* phase);\n+  explicit InitializedAssertionPredicateCreator(PhaseIdealLoop* phase);\n@@ -535,1 +592,4 @@\n-  IfTrueNode* create(Node* control);\n+  IfTrueNode* create_from_template(IfNode* template_assertion_predicate, Node* new_control, Node* new_init,\n+                                   Node* new_stride);\n+  IfTrueNode* create(Node* operand, Node* new_control, jint stride, int scale, Node* offset, Node* range\n+                     NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type));\n@@ -538,5 +598,6 @@\n-  OpaqueInitializedAssertionPredicateNode* create_assertion_expression(Node* control);\n-  IfNode* create_if_node(Node* control, OpaqueInitializedAssertionPredicateNode* assertion_expression, IdealLoopTree* loop);\n-  void create_fail_path(IfNode* if_node, IdealLoopTree* loop);\n-  void create_halt_node(IfFalseNode* fail_proj, IdealLoopTree* loop);\n-  IfTrueNode* create_success_path(IfNode* if_node, IdealLoopTree* loop);\n+  OpaqueInitializedAssertionPredicateNode* create_assertion_expression_from_template(IfNode* template_assertion_predicate,\n+                                                                                     Node* new_control, Node* new_init,\n+                                                                                     Node* new_stride);\n+  IfTrueNode* create_control_nodes(Node* new_control, int if_opcode,\n+                                   OpaqueInitializedAssertionPredicateNode* assertion_expression\n+                                   NOT_PRODUCT(COMMA AssertionPredicateType assertion_predicate_type));\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":76,"deletions":15,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -660,3 +660,0 @@\n-        } else if (out->Opcode() == Op_StoreCM && out->in(MemNode::OopStore) == n) {\n-          \/\/ StoreCM has an input edge used as a precedence edge.\n-          \/\/ Maybe an issue when oop stores are vectorized.\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -231,2 +231,2 @@\n-      const Type* element_type = _vloop_analyzer.types().velt_type(p0);\n-      if (index == 2 && VectorNode::is_scalar_rotate(p0) && element_type->isa_long()) {\n+      BasicType element_type = _vloop_analyzer.types().velt_basic_type(p0);\n+      if (index == 2 && VectorNode::is_scalar_rotate(p0) && element_type == T_LONG) {\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -682,1 +682,1 @@\n-  TypeVect::VECTMASK = (TypeVect*)(new TypeVectMask(TypeInt::BOOL, MaxVectorSize))->hashcons();\n+  TypeVect::VECTMASK = (TypeVect*)(new TypeVectMask(T_BOOLEAN, MaxVectorSize))->hashcons();\n@@ -690,2 +690,2 @@\n-  if (Matcher::vector_size_supported(T_BYTE,4)) {\n-    TypeVect::VECTS = TypeVect::make(T_BYTE,4);\n+  if (Matcher::vector_size_supported(T_BYTE, 4)) {\n+    TypeVect::VECTS = TypeVect::make(T_BYTE, 4);\n@@ -693,2 +693,2 @@\n-  if (Matcher::vector_size_supported(T_FLOAT,2)) {\n-    TypeVect::VECTD = TypeVect::make(T_FLOAT,2);\n+  if (Matcher::vector_size_supported(T_FLOAT, 2)) {\n+    TypeVect::VECTD = TypeVect::make(T_FLOAT, 2);\n@@ -696,2 +696,2 @@\n-  if (Matcher::vector_size_supported(T_FLOAT,4)) {\n-    TypeVect::VECTX = TypeVect::make(T_FLOAT,4);\n+  if (Matcher::vector_size_supported(T_FLOAT, 4)) {\n+    TypeVect::VECTX = TypeVect::make(T_FLOAT, 4);\n@@ -699,2 +699,2 @@\n-  if (Matcher::vector_size_supported(T_FLOAT,8)) {\n-    TypeVect::VECTY = TypeVect::make(T_FLOAT,8);\n+  if (Matcher::vector_size_supported(T_FLOAT, 8)) {\n+    TypeVect::VECTY = TypeVect::make(T_FLOAT, 8);\n@@ -702,2 +702,2 @@\n-  if (Matcher::vector_size_supported(T_FLOAT,16)) {\n-    TypeVect::VECTZ = TypeVect::make(T_FLOAT,16);\n+  if (Matcher::vector_size_supported(T_FLOAT, 16)) {\n+    TypeVect::VECTZ = TypeVect::make(T_FLOAT, 16);\n@@ -2485,7 +2485,7 @@\n-const TypeVect *TypeVect::VECTA = nullptr; \/\/ vector length agnostic\n-const TypeVect *TypeVect::VECTS = nullptr; \/\/  32-bit vectors\n-const TypeVect *TypeVect::VECTD = nullptr; \/\/  64-bit vectors\n-const TypeVect *TypeVect::VECTX = nullptr; \/\/ 128-bit vectors\n-const TypeVect *TypeVect::VECTY = nullptr; \/\/ 256-bit vectors\n-const TypeVect *TypeVect::VECTZ = nullptr; \/\/ 512-bit vectors\n-const TypeVect *TypeVect::VECTMASK = nullptr; \/\/ predicate\/mask vector\n+const TypeVect* TypeVect::VECTA = nullptr; \/\/ vector length agnostic\n+const TypeVect* TypeVect::VECTS = nullptr; \/\/  32-bit vectors\n+const TypeVect* TypeVect::VECTD = nullptr; \/\/  64-bit vectors\n+const TypeVect* TypeVect::VECTX = nullptr; \/\/ 128-bit vectors\n+const TypeVect* TypeVect::VECTY = nullptr; \/\/ 256-bit vectors\n+const TypeVect* TypeVect::VECTZ = nullptr; \/\/ 512-bit vectors\n+const TypeVect* TypeVect::VECTMASK = nullptr; \/\/ predicate\/mask vector\n@@ -2494,1 +2494,1 @@\n-const TypeVect* TypeVect::make(const Type *elem, uint length, bool is_mask) {\n+const TypeVect* TypeVect::make(BasicType elem_bt, uint length, bool is_mask) {\n@@ -2496,1 +2496,1 @@\n-    return makemask(elem, length);\n+    return makemask(elem_bt, length);\n@@ -2498,1 +2498,0 @@\n-  BasicType elem_bt = elem->array_element_basic_type();\n@@ -2504,1 +2503,1 @@\n-    return (TypeVect*)(new TypeVectA(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectA(elem_bt, length))->hashcons();\n@@ -2506,1 +2505,1 @@\n-    return (TypeVect*)(new TypeVectS(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectS(elem_bt, length))->hashcons();\n@@ -2510,1 +2509,1 @@\n-    return (TypeVect*)(new TypeVectD(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectD(elem_bt, length))->hashcons();\n@@ -2512,1 +2511,1 @@\n-    return (TypeVect*)(new TypeVectX(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectX(elem_bt, length))->hashcons();\n@@ -2514,1 +2513,1 @@\n-    return (TypeVect*)(new TypeVectY(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectY(elem_bt, length))->hashcons();\n@@ -2516,1 +2515,1 @@\n-    return (TypeVect*)(new TypeVectZ(elem, length))->hashcons();\n+    return (TypeVect*)(new TypeVectZ(elem_bt, length))->hashcons();\n@@ -2522,2 +2521,1 @@\n-const TypeVect *TypeVect::makemask(const Type* elem, uint length) {\n-  BasicType elem_bt = elem->array_element_basic_type();\n+const TypeVect* TypeVect::makemask(BasicType elem_bt, uint length) {\n@@ -2526,1 +2524,1 @@\n-    return TypeVectMask::make(elem, length);\n+    return TypeVectMask::make(elem_bt, length);\n@@ -2528,1 +2526,1 @@\n-    return make(elem, length);\n+    return make(elem_bt, length);\n@@ -2533,2 +2531,3 @@\n-\/\/ Compute the MEET of two types.  It returns a new Type object.\n-const Type *TypeVect::xmeet( const Type *t ) const {\n+\/\/ Compute the MEET of two types. Since each TypeVect is the only instance of\n+\/\/ its species, meeting often returns itself\n+const Type* TypeVect::xmeet(const Type* t) const {\n@@ -2536,1 +2535,3 @@\n-  if( this == t ) return this;  \/\/ Meeting same type-rep?\n+  if (this == t) {\n+    return this;\n+  }\n@@ -2546,7 +2547,1 @@\n-  case VectorMask: {\n-    const TypeVectMask* v = t->is_vectmask();\n-    assert(  base() == v->base(), \"\");\n-    assert(length() == v->length(), \"\");\n-    assert(element_basic_type() == v->element_basic_type(), \"\");\n-    return TypeVect::makemask(_elem->xmeet(v->_elem), _length);\n-  }\n+  case VectorMask:\n@@ -2560,1 +2555,1 @@\n-    assert(  base() == v->base(), \"\");\n+    assert(base() == v->base(), \"\");\n@@ -2563,1 +2558,1 @@\n-    return TypeVect::make(_elem->xmeet(v->_elem), _length);\n+    return this;\n@@ -2572,3 +2567,3 @@\n-\/\/ Dual: compute field-by-field dual\n-const Type *TypeVect::xdual() const {\n-  return new TypeVect(base(), _elem->dual(), _length);\n+\/\/ Since each TypeVect is the only instance of its species, it is self-dual\n+const Type* TypeVect::xdual() const {\n+  return this;\n@@ -2579,3 +2574,3 @@\n-bool TypeVect::eq(const Type *t) const {\n-  const TypeVect *v = t->is_vect();\n-  return (_elem == v->_elem) && (_length == v->_length);\n+bool TypeVect::eq(const Type* t) const {\n+  const TypeVect* v = t->is_vect();\n+  return (element_basic_type() == v->element_basic_type()) && (length() == v->length());\n@@ -2587,1 +2582,1 @@\n-  return (uint)(uintptr_t)_elem + (uint)(uintptr_t)_length;\n+  return (uint)base() + (uint)(uintptr_t)_elem_bt + (uint)(uintptr_t)_length;\n@@ -2591,1 +2586,1 @@\n-\/\/ TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple\n+\/\/ TRUE if Type is a singleton type, FALSE otherwise. Singletons are simple\n@@ -2601,1 +2596,1 @@\n-  return _elem->empty();\n+  return false;\n@@ -2606,1 +2601,1 @@\n-void TypeVect::dump2(Dict &d, uint depth, outputStream *st) const {\n+void TypeVect::dump2(Dict& d, uint depth, outputStream* st) const {\n@@ -2609,1 +2604,1 @@\n-    st->print(\"vectora[\"); break;\n+    st->print(\"vectora\"); break;\n@@ -2611,1 +2606,1 @@\n-    st->print(\"vectors[\"); break;\n+    st->print(\"vectors\"); break;\n@@ -2613,1 +2608,1 @@\n-    st->print(\"vectord[\"); break;\n+    st->print(\"vectord\"); break;\n@@ -2615,1 +2610,1 @@\n-    st->print(\"vectorx[\"); break;\n+    st->print(\"vectorx\"); break;\n@@ -2617,1 +2612,1 @@\n-    st->print(\"vectory[\"); break;\n+    st->print(\"vectory\"); break;\n@@ -2619,1 +2614,1 @@\n-    st->print(\"vectorz[\"); break;\n+    st->print(\"vectorz\"); break;\n@@ -2621,1 +2616,1 @@\n-    st->print(\"vectormask[\"); break;\n+    st->print(\"vectormask\"); break;\n@@ -2625,3 +2620,1 @@\n-  st->print(\"%d]:{\", _length);\n-  _elem->dump2(d, depth, st);\n-  st->print(\"}\");\n+  st->print(\"<%c,%u>\", type2char(element_basic_type()), length());\n@@ -2631,16 +2624,2 @@\n-bool TypeVectMask::eq(const Type *t) const {\n-  const TypeVectMask *v = t->is_vectmask();\n-  return (element_type() == v->element_type()) && (length() == v->length());\n-}\n-\n-const Type *TypeVectMask::xdual() const {\n-  return new TypeVectMask(element_type()->dual(), length());\n-}\n-\n-const TypeVectMask *TypeVectMask::make(const BasicType elem_bt, uint length) {\n-  return make(get_const_basic_type(elem_bt), length);\n-}\n-\n-const TypeVectMask *TypeVectMask::make(const Type* elem, uint length) {\n-  const TypeVectMask* mtype = Matcher::predicate_reg_type(elem, length);\n-  return (TypeVectMask*) const_cast<TypeVectMask*>(mtype)->hashcons();\n+const TypeVectMask* TypeVectMask::make(const BasicType elem_bt, uint length) {\n+  return (TypeVectMask*) (new TypeVectMask(elem_bt, length))->hashcons();\n@@ -3135,2 +3114,2 @@\n-const TypeRawPtr *TypeRawPtr::make( address bits ) {\n-  assert( bits, \"Use TypePtr for null\" );\n+const TypeRawPtr *TypeRawPtr::make(address bits) {\n+  assert(bits != nullptr, \"Use TypePtr for null\");\n@@ -3225,1 +3204,0 @@\n-  case TypePtr::Null:\n@@ -3227,3 +3205,11 @@\n-    address bits = _bits+offset;\n-    if ( bits == 0 ) return TypePtr::NULL_PTR;\n-    return make( bits );\n+    uintptr_t bits = (uintptr_t)_bits;\n+    uintptr_t sum = bits + offset;\n+    if (( offset < 0 )\n+        ? ( sum > bits )        \/\/ Underflow?\n+        : ( sum < bits )) {     \/\/ Overflow?\n+      return BOTTOM;\n+    } else if ( sum == 0 ) {\n+      return TypePtr::NULL_PTR;\n+    } else {\n+      return make( (address)sum );\n+    }\n@@ -3233,1 +3219,0 @@\n-  return nullptr;                  \/\/ Lint noise\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":71,"deletions":86,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -787,2 +787,2 @@\n-  const Type*   _elem;  \/\/ Vector's element type\n-  const uint  _length;  \/\/ Elements in vector (power of 2)\n+  const BasicType _elem_bt;  \/\/ Vector's element type\n+  const uint _length;  \/\/ Elements in vector (power of 2)\n@@ -791,2 +791,2 @@\n-  TypeVect(TYPES t, const Type* elem, uint length) : Type(t),\n-    _elem(elem), _length(length) {}\n+  TypeVect(TYPES t, BasicType elem_bt, uint length) : Type(t),\n+    _elem_bt(elem_bt), _length(length) {}\n@@ -795,2 +795,1 @@\n-  const Type* element_type() const { return _elem; }\n-  BasicType element_basic_type() const { return _elem->array_element_basic_type(); }\n+  BasicType element_basic_type() const { return _elem_bt; }\n@@ -799,1 +798,1 @@\n-   return _length * type2aelembytes(element_basic_type());\n+    return _length * type2aelembytes(element_basic_type());\n@@ -802,1 +801,1 @@\n-  virtual bool eq(const Type *t) const;\n+  virtual bool eq(const Type* t) const;\n@@ -807,13 +806,2 @@\n-  static const TypeVect *make(const BasicType elem_bt, uint length, bool is_mask = false) {\n-    \/\/ Use bottom primitive type.\n-    return make(get_const_basic_type(elem_bt), length, is_mask);\n-  }\n-  \/\/ Used directly by Replicate nodes to construct singleton vector.\n-  static const TypeVect *make(const Type* elem, uint length, bool is_mask = false);\n-\n-  static const TypeVect *makemask(const BasicType elem_bt, uint length) {\n-    \/\/ Use bottom primitive type.\n-    return makemask(get_const_basic_type(elem_bt), length);\n-  }\n-  static const TypeVect *makemask(const Type* elem, uint length);\n-\n+  static const TypeVect* make(const BasicType elem_bt, uint length, bool is_mask = false);\n+  static const TypeVect* makemask(const BasicType elem_bt, uint length);\n@@ -821,2 +809,2 @@\n-  virtual const Type *xmeet( const Type *t) const;\n-  virtual const Type *xdual() const;     \/\/ Compute dual right now.\n+  virtual const Type* xmeet( const Type *t) const;\n+  virtual const Type* xdual() const;     \/\/ Compute dual right now.\n@@ -824,7 +812,7 @@\n-  static const TypeVect *VECTA;\n-  static const TypeVect *VECTS;\n-  static const TypeVect *VECTD;\n-  static const TypeVect *VECTX;\n-  static const TypeVect *VECTY;\n-  static const TypeVect *VECTZ;\n-  static const TypeVect *VECTMASK;\n+  static const TypeVect* VECTA;\n+  static const TypeVect* VECTS;\n+  static const TypeVect* VECTD;\n+  static const TypeVect* VECTX;\n+  static const TypeVect* VECTY;\n+  static const TypeVect* VECTZ;\n+  static const TypeVect* VECTMASK;\n@@ -833,1 +821,1 @@\n-  virtual void dump2(Dict &d, uint, outputStream *st) const; \/\/ Specialized per-Type dumping\n+  virtual void dump2(Dict& d, uint, outputStream* st) const; \/\/ Specialized per-Type dumping\n@@ -839,1 +827,1 @@\n-  TypeVectA(const Type* elem, uint length) : TypeVect(VectorA, elem, length) {}\n+  TypeVectA(BasicType elem_bt, uint length) : TypeVect(VectorA, elem_bt, length) {}\n@@ -844,1 +832,1 @@\n-  TypeVectS(const Type* elem, uint length) : TypeVect(VectorS, elem, length) {}\n+  TypeVectS(BasicType elem_bt, uint length) : TypeVect(VectorS, elem_bt, length) {}\n@@ -849,1 +837,1 @@\n-  TypeVectD(const Type* elem, uint length) : TypeVect(VectorD, elem, length) {}\n+  TypeVectD(BasicType elem_bt, uint length) : TypeVect(VectorD, elem_bt, length) {}\n@@ -854,1 +842,1 @@\n-  TypeVectX(const Type* elem, uint length) : TypeVect(VectorX, elem, length) {}\n+  TypeVectX(BasicType elem_bt, uint length) : TypeVect(VectorX, elem_bt, length) {}\n@@ -859,1 +847,1 @@\n-  TypeVectY(const Type* elem, uint length) : TypeVect(VectorY, elem, length) {}\n+  TypeVectY(BasicType elem_bt, uint length) : TypeVect(VectorY, elem_bt, length) {}\n@@ -864,1 +852,1 @@\n-  TypeVectZ(const Type* elem, uint length) : TypeVect(VectorZ, elem, length) {}\n+  TypeVectZ(BasicType elem_bt, uint length) : TypeVect(VectorZ, elem_bt, length) {}\n@@ -870,3 +858,1 @@\n-  TypeVectMask(const Type* elem, uint length) : TypeVect(VectorMask, elem, length) {}\n-  virtual bool eq(const Type *t) const;\n-  virtual const Type *xdual() const;\n+  TypeVectMask(BasicType elem_bt, uint length) : TypeVect(VectorMask, elem_bt, length) {}\n@@ -874,1 +860,0 @@\n-  static const TypeVectMask* make(const Type* elem, uint length);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":26,"deletions":41,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -527,1 +527,0 @@\n-  const Type* type_bt = Type::get_const_basic_type(elem_bt);\n@@ -530,1 +529,1 @@\n-  Node* bcast_mod_mask  = gvn().transform(VectorNode::scalar2vector(mod_mask, num_elem, type_bt));\n+  Node* bcast_mod_mask = gvn().transform(VectorNode::scalar2vector(mod_mask, num_elem, elem_bt));\n@@ -535,3 +534,3 @@\n-  Node* bcast_lane_cnt = gvn().transform(VectorNode::scalar2vector(lane_cnt, num_elem, type_bt));\n-  const TypeVect* vmask_type = TypeVect::makemask(type_bt, num_elem);\n-  Node*  mask = gvn().transform(new VectorMaskCmpNode(pred, bcast_lane_cnt, index_vec, pred_node, vmask_type));\n+  Node* bcast_lane_cnt = gvn().transform(VectorNode::scalar2vector(lane_cnt, num_elem, elem_bt));\n+  const TypeVect* vmask_type = TypeVect::makemask(elem_bt, num_elem);\n+  Node* mask = gvn().transform(new VectorMaskCmpNode(pred, bcast_lane_cnt, index_vec, pred_node, vmask_type));\n@@ -603,2 +602,1 @@\n-  const Type * type_bt = Type::get_const_basic_type(elem_bt);\n-  const TypeVect * vt  = TypeVect::make(type_bt, num_elem);\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n@@ -612,1 +610,1 @@\n-    Node* bcast_step     = gvn().transform(VectorNode::scalar2vector(step, num_elem, type_bt));\n+    Node* bcast_step = gvn().transform(VectorNode::scalar2vector(step, num_elem, elem_bt));\n@@ -621,1 +619,1 @@\n-    Node* bcast_start    = gvn().transform(VectorNode::scalar2vector(start, num_elem, type_bt));\n+    Node* bcast_start = gvn().transform(VectorNode::scalar2vector(start, num_elem, elem_bt));\n@@ -625,2 +623,2 @@\n-  Node * mod_val = gvn().makecon(TypeInt::make(num_elem-1));\n-  Node * bcast_mod  = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, type_bt));\n+  Node* mod_val = gvn().makecon(TypeInt::make(num_elem-1));\n+  Node* bcast_mod = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, elem_bt));\n@@ -805,3 +803,2 @@\n-  const Type* shuffle_type_bt = Type::get_const_basic_type(shuffle_bt);\n-  Node* mod_mask = gvn().makecon(TypeInt::make(num_elem-1));\n-  Node* bcast_mod_mask  = gvn().transform(VectorNode::scalar2vector(mod_mask, num_elem, shuffle_type_bt));\n+  Node* mod_mask = gvn().makecon(TypeInt::make(num_elem - 1));\n+  Node* bcast_mod_mask  = gvn().transform(VectorNode::scalar2vector(mod_mask, num_elem, shuffle_bt));\n@@ -911,1 +908,1 @@\n-    broadcast = VectorNode::scalar2vector(elem, num_elem, Type::get_const_basic_type(elem_bt), is_mask);\n+    broadcast = VectorNode::scalar2vector(elem, num_elem, elem_bt, is_mask);\n@@ -1355,1 +1352,1 @@\n-      zero = gvn().transform(VectorNode::scalar2vector(zero, mem_num_elem, Type::get_const_basic_type(mem_elem_bt)));\n+      zero = gvn().transform(VectorNode::scalar2vector(zero, mem_num_elem, mem_elem_bt));\n@@ -1681,1 +1678,1 @@\n-    Node* reduce_identity = gvn().transform(VectorNode::scalar2vector(init, num_elem, Type::get_const_basic_type(elem_bt)));\n+    Node* reduce_identity = gvn().transform(VectorNode::scalar2vector(init, num_elem, elem_bt));\n@@ -2062,1 +2059,1 @@\n-      Node* zerovec = gvn().transform(VectorNode::scalar2vector(zero, num_elem, Type::get_const_basic_type(elem_bt)));\n+      Node* zerovec = gvn().transform(VectorNode::scalar2vector(zero, num_elem, elem_bt));\n@@ -2218,2 +2215,1 @@\n-  const Type * byte_bt = Type::get_const_basic_type(T_BYTE);\n-  const TypeVect * byte_vt  = TypeVect::make(byte_bt, num_elem);\n+  const TypeVect* byte_vt = TypeVect::make(T_BYTE, num_elem);\n@@ -2225,1 +2221,1 @@\n-  Node* bcast_mod  = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, byte_bt));\n+  Node* bcast_mod = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, T_BYTE));\n@@ -2229,1 +2225,1 @@\n-  const TypeVect * shuffle_vt  = TypeVect::make(elem_bt, num_elem);\n+  const TypeVect* shuffle_vt = TypeVect::make(elem_bt, num_elem);\n@@ -2246,1 +2242,1 @@\n-      Node* zerovec = gvn().transform(VectorNode::scalar2vector(zero, num_elem, Type::get_const_basic_type(elem_bt)));\n+      Node* zerovec = gvn().transform(VectorNode::scalar2vector(zero, num_elem, elem_bt));\n@@ -2363,0 +2359,2 @@\n+  const TypeInt* cnt_type = cnt->bottom_type()->isa_int();\n+\n@@ -2365,1 +2363,0 @@\n-  const TypeInt* cnt_type = cnt->bottom_type()->isa_int();\n@@ -2394,1 +2391,0 @@\n-      const Type * type_bt = Type::get_const_basic_type(elem_bt);\n@@ -2396,1 +2392,1 @@\n-      opd2 = gvn().transform(VectorNode::scalar2vector(cnt, num_elem, type_bt));\n+      opd2 = gvn().transform(VectorNode::scalar2vector(cnt, num_elem, elem_bt));\n@@ -2849,0 +2845,182 @@\n+static Node* LowerSelectFromTwoVectorOperation(PhaseGVN& phase, Node* index_vec, Node* src1, Node* src2, const TypeVect* vt) {\n+  int num_elem = vt->length();\n+  BasicType elem_bt = vt->element_basic_type();\n+\n+  \/\/ Lower selectFrom operation into its constituent operations.\n+  \/\/   SelectFromTwoVectorNode =\n+  \/\/     (VectorBlend\n+  \/\/         (VectorRearrange SRC1 (WRAPED_INDEX AND (VLEN-1))\n+  \/\/         (VectorRearrange SRC2 (WRAPED_INDEX AND (VLEN-1))\n+  \/\/      MASK)\n+  \/\/ Where\n+  \/\/   WRAPED_INDEX are computed by wrapping incoming indexes\n+  \/\/   to two vector index range [0, VLEN*2) and\n+  \/\/   MASK = WRAPED_INDEX < VLEN\n+  \/\/\n+  \/\/ IR lowering prevents intrinsification failure and associated argument\n+  \/\/ boxing penalties.\n+  \/\/\n+\n+  const TypeVect* index_vect_type = index_vec->bottom_type()->is_vect();\n+  BasicType index_elem_bt = index_vect_type->element_basic_type();\n+\n+  \/\/ Downcast index vector to a type agnostic shuffle representation, shuffle\n+  \/\/ indices are held in a byte vector which are later transformed to target\n+  \/\/ specific permutation index format by subsequent VectorLoadShuffle.\n+  int cast_vopc = VectorCastNode::opcode(0, index_elem_bt, true);\n+  Node* index_byte_vec = phase.transform(VectorCastNode::make(cast_vopc, index_vec, T_BYTE, num_elem));\n+\n+  \/\/ Wrap indexes into two vector index range [0, VLEN * 2)\n+  Node* two_vect_lane_cnt_m1 = phase.makecon(TypeInt::make(2 * num_elem - 1));\n+  Node* bcast_two_vect_lane_cnt_m1_vec = phase.transform(VectorNode::scalar2vector(two_vect_lane_cnt_m1, num_elem,\n+                                                                                   T_BYTE, false));\n+  index_byte_vec = phase.transform(VectorNode::make(Op_AndV, index_byte_vec, bcast_two_vect_lane_cnt_m1_vec,\n+                                                    index_byte_vec->bottom_type()->is_vect()));\n+\n+  \/\/ Compute the blend mask for merging two independently permitted vectors\n+  \/\/ using shuffle index in two vector index range [0, VLEN * 2).\n+  BoolTest::mask pred = BoolTest::le;\n+  ConINode* pred_node = phase.makecon(TypeInt::make(pred))->as_ConI();\n+  const TypeVect* vmask_type = TypeVect::makemask(T_BYTE, num_elem);\n+  Node* lane_cnt_m1 = phase.makecon(TypeInt::make(num_elem - 1));\n+  Node* bcast_lane_cnt_m1_vec = phase.transform(VectorNode::scalar2vector(lane_cnt_m1, num_elem,\n+                                                                          T_BYTE, false));\n+  Node* mask = phase.transform(new VectorMaskCmpNode(pred, index_byte_vec, bcast_lane_cnt_m1_vec, pred_node, vmask_type));\n+\n+  \/\/ Rearrange expects the indexes to lie within single vector index range [0, VLEN).\n+  index_byte_vec = phase.transform(VectorNode::make(Op_AndV, index_byte_vec, bcast_lane_cnt_m1_vec,\n+                       index_byte_vec->bottom_type()->is_vect()));\n+\n+  \/\/ Load indexes from byte vector and appropriately transform them to target\n+  \/\/ specific permutation index format.\n+  index_vec = phase.transform(new VectorLoadShuffleNode(index_byte_vec, index_vect_type));\n+\n+  vmask_type = TypeVect::makemask(elem_bt, num_elem);\n+  mask = phase.transform(new VectorMaskCastNode(mask, vmask_type));\n+\n+  Node* p1 = phase.transform(new VectorRearrangeNode(src1, index_vec));\n+  Node* p2 = phase.transform(new VectorRearrangeNode(src2, index_vec));\n+\n+  return new VectorBlendNode(p2, p1, mask);\n+}\n+\n+\/\/  public static\n+\/\/  <V extends Vector<E>,\n+\/\/   E>\n+\/\/  V selectFromTwoVectorOp(Class<? extends V> vClass, Class<E> eClass, int length,\n+\/\/                          V v1, V v2, V v3,\n+\/\/                          SelectFromTwoVector<V> defaultImpl)\n+bool LibraryCallKit::inline_vector_select_from_two_vectors() {\n+  const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();\n+  const TypeInstPtr* elem_klass = gvn().type(argument(1))->isa_instptr();\n+  const TypeInt* vlen = gvn().type(argument(2))->isa_int();\n+\n+  if (vector_klass == nullptr || elem_klass == nullptr || vlen == nullptr || vector_klass->const_oop() == nullptr ||\n+      elem_klass->const_oop() == nullptr ||!vlen->is_con()) {\n+    log_if_needed(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n+                    NodeClassNames[argument(0)->Opcode()],\n+                    NodeClassNames[argument(1)->Opcode()],\n+                    NodeClassNames[argument(2)->Opcode()]);\n+    return false; \/\/ not enough info for intrinsification\n+  }\n+\n+  if (!is_klass_initialized(vector_klass)) {\n+    log_if_needed(\"  ** klass argument not initialized\");\n+    return false;\n+  }\n+\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  if (!elem_type->is_primitive_type()) {\n+    log_if_needed(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n+    return false; \/\/ should be primitive type\n+  }\n+\n+  int num_elem = vlen->get_con();\n+  if (!is_power_of_2(num_elem)) {\n+    log_if_needed(\"  ** vlen is not power of two=%d\", num_elem);\n+    return false;\n+  }\n+\n+  BasicType elem_bt = elem_type->basic_type();\n+  BasicType index_elem_bt = elem_bt;\n+  if (elem_bt == T_FLOAT) {\n+    index_elem_bt = T_INT;\n+  } else if (elem_bt == T_DOUBLE) {\n+    index_elem_bt = T_LONG;\n+  }\n+\n+  bool lowerSelectFromOp = false;\n+  if (!arch_supports_vector(Op_SelectFromTwoVector, num_elem, elem_bt, VecMaskNotUsed)) {\n+    int cast_vopc = VectorCastNode::opcode(-1, elem_bt, true);\n+    if (!arch_supports_vector(Op_VectorMaskCmp, num_elem, T_BYTE, VecMaskNotUsed)            ||\n+        !arch_supports_vector(Op_AndV, num_elem, T_BYTE, VecMaskNotUsed)                     ||\n+        !arch_supports_vector(Op_VectorMaskCast, num_elem, elem_bt, VecMaskNotUsed)          ||\n+        !arch_supports_vector(Op_VectorBlend, num_elem, elem_bt, VecMaskUseLoad)             ||\n+        !arch_supports_vector(Op_VectorRearrange, num_elem, elem_bt, VecMaskNotUsed)         ||\n+        !arch_supports_vector(cast_vopc, num_elem, T_BYTE, VecMaskNotUsed)                   ||\n+        !arch_supports_vector(Op_VectorLoadShuffle, num_elem, index_elem_bt, VecMaskNotUsed) ||\n+        !arch_supports_vector(Op_Replicate, num_elem, T_BYTE, VecMaskNotUsed)) {\n+      log_if_needed(\"  ** not supported: opc=%d vlen=%d etype=%s ismask=useload\",\n+                    Op_SelectFromTwoVector, num_elem, type2name(elem_bt));\n+      return false; \/\/ not supported\n+    }\n+    lowerSelectFromOp = true;\n+  }\n+\n+  int cast_vopc = VectorCastNode::opcode(-1, elem_bt, true);\n+  if (!lowerSelectFromOp) {\n+    if (!arch_supports_vector(Op_AndV, num_elem, index_elem_bt, VecMaskNotUsed)      ||\n+        !arch_supports_vector(Op_Replicate, num_elem, index_elem_bt, VecMaskNotUsed) ||\n+        (is_floating_point_type(elem_bt) &&\n+         !arch_supports_vector(cast_vopc, num_elem, index_elem_bt, VecMaskNotUsed))) {\n+      log_if_needed(\"  ** index wrapping not supported: vlen=%d etype=%s\" ,\n+                     num_elem, type2name(elem_bt));\n+      return false; \/\/ not supported\n+    }\n+  }\n+\n+  ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);\n+\n+  Node* opd1 = unbox_vector(argument(3), vbox_type, elem_bt, num_elem);\n+  if (opd1 == nullptr) {\n+    log_if_needed(\"  ** unbox failed v1=%s\",\n+                  NodeClassNames[argument(3)->Opcode()]);\n+    return false;\n+  }\n+  Node* opd2 = unbox_vector(argument(4), vbox_type, elem_bt, num_elem);\n+  if (opd2 == nullptr) {\n+    log_if_needed(\"  ** unbox failed v2=%s\",\n+                  NodeClassNames[argument(4)->Opcode()]);\n+    return false;\n+  }\n+  Node* opd3 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+  if (opd3 == nullptr) {\n+    log_if_needed(\"  ** unbox failed v3=%s\",\n+                  NodeClassNames[argument(5)->Opcode()]);\n+    return false;\n+  }\n+\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+\n+  Node* operation = nullptr;\n+  if (lowerSelectFromOp) {\n+    operation = gvn().transform(LowerSelectFromTwoVectorOperation(gvn(), opd1, opd2, opd3, vt));\n+  } else {\n+    if (index_elem_bt != elem_bt) {\n+      opd1 = gvn().transform(VectorCastNode::make(cast_vopc, opd1, index_elem_bt, num_elem));\n+    }\n+    int indexRangeMask = 2 * num_elem - 1;\n+    Node* wrap_mask = gvn().makecon(TypeInteger::make(indexRangeMask, indexRangeMask, Type::WidenMin, index_elem_bt != T_LONG ? T_INT : index_elem_bt));\n+    Node* wrap_mask_vec = gvn().transform(VectorNode::scalar2vector(wrap_mask, num_elem, index_elem_bt, false));\n+    opd1 = gvn().transform(VectorNode::make(Op_AndV, opd1, wrap_mask_vec, opd1->bottom_type()->is_vect()));\n+    operation = gvn().transform(VectorNode::make(Op_SelectFromTwoVector, opd1, opd2, opd3, vt));\n+  }\n+\n+  \/\/ Wrap it up in VectorBox to keep object type information.\n+  Node* vbox = box_vector(operation, vbox_type, elem_bt, num_elem);\n+  set_result(vbox);\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n+\n@@ -3054,1 +3232,1 @@\n-    scale = gvn().transform(VectorNode::scalar2vector(scale, num_elem, Type::get_const_basic_type(elem_bt)));\n+    scale = gvn().transform(VectorNode::scalar2vector(scale, num_elem, elem_bt));\n@@ -3167,1 +3345,1 @@\n-    indexLimit = gvn().transform(VectorNode::scalar2vector(indexLimit, num_elem, Type::get_const_basic_type(elem_bt)));\n+    indexLimit = gvn().transform(VectorNode::scalar2vector(indexLimit, num_elem, elem_bt));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":206,"deletions":28,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -419,0 +419,4 @@\n+  _has_int_index_after_convI2L(false),\n+  _int_index_after_convI2L_offset(0),\n+  _int_index_after_convI2L_invar(nullptr),\n+  _int_index_after_convI2L_scale(0),\n@@ -498,0 +502,5 @@\n+  if (!is_safe_to_use_as_simple_form(base, adr)) {\n+    assert(!valid(), \"does not have simple form\");\n+    return;\n+  }\n+\n@@ -511,0 +520,4 @@\n+  _has_int_index_after_convI2L(false),\n+  _int_index_after_convI2L_offset(0),\n+  _int_index_after_convI2L_invar(nullptr),\n+  _int_index_after_convI2L_scale(0),\n@@ -533,0 +546,348 @@\n+\/\/ We would like to make decisions about aliasing (i.e. removing memory edges) and adjacency\n+\/\/ (i.e. which loads\/stores can be packed) based on the simple form:\n+\/\/\n+\/\/   s_pointer = adr + offset + invar + scale * ConvI2L(iv)\n+\/\/\n+\/\/ However, we parse the compound-long-int form:\n+\/\/\n+\/\/   c_pointer = adr + long_offset + long_invar + long_scale * ConvI2L(int_index)\n+\/\/   int_index =       int_offset  + int_invar  + int_scale  * iv\n+\/\/\n+\/\/ In general, the simple and the compound-long-int form do not always compute the same pointer\n+\/\/ at runtime. For example, the simple form would give a different result due to an overflow\n+\/\/ in the int_index.\n+\/\/\n+\/\/ Example:\n+\/\/   For both forms, we have:\n+\/\/     iv = 0\n+\/\/     scale = 1\n+\/\/\n+\/\/   We now account the offset and invar once to the long part and once to the int part:\n+\/\/     Pointer 1 (long offset and long invar):\n+\/\/       long_offset = min_int\n+\/\/       long_invar  = min_int\n+\/\/       int_offset  = 0\n+\/\/       int_invar   = 0\n+\/\/\n+\/\/     Pointer 2 (int offset and int invar):\n+\/\/       long_offset = 0\n+\/\/       long_invar  = 0\n+\/\/       int_offset  = min_int\n+\/\/       int_invar   = min_int\n+\/\/\n+\/\/   This gives us the following pointers:\n+\/\/     Compound-long-int form pointers:\n+\/\/       Form:\n+\/\/         c_pointer   = adr + long_offset + long_invar + long_scale * ConvI2L(int_offset + int_invar + int_scale * iv)\n+\/\/\n+\/\/       Pointers:\n+\/\/         c_pointer1  = adr + min_int     + min_int    + 1          * ConvI2L(0          + 0         + 1         * 0)\n+\/\/                     = adr + min_int + min_int\n+\/\/                     = adr - 2^32\n+\/\/\n+\/\/         c_pointer2  = adr + 0           + 0          + 1          * ConvI2L(min_int    + min_int   + 1         * 0)\n+\/\/                     = adr + ConvI2L(min_int + min_int)\n+\/\/                     = adr + 0\n+\/\/                     = adr\n+\/\/\n+\/\/     Simple form pointers:\n+\/\/       Form:\n+\/\/         s_pointer  = adr + offset                     + invar                     + scale                    * ConvI2L(iv)\n+\/\/         s_pointer  = adr + (long_offset + int_offset) + (long_invar  + int_invar) + (long_scale * int_scale) * ConvI2L(iv)\n+\/\/\n+\/\/       Pointers:\n+\/\/         s_pointer1 = adr + (min_int     + 0         ) + (min_int     + 0        ) + 1                        * 0\n+\/\/                    = adr + min_int + min_int\n+\/\/                    = adr - 2^32\n+\/\/         s_pointer2 = adr + (0           + min_int   ) + (0           + min_int  ) + 1                        * 0\n+\/\/                    = adr + min_int + min_int\n+\/\/                    = adr - 2^32\n+\/\/\n+\/\/   We see that the two addresses are actually 2^32 bytes apart (derived from the c_pointers), but their simple form look identical.\n+\/\/\n+\/\/ Hence, we need to determine in which cases it is safe to make decisions based on the simple\n+\/\/ form, rather than the compound-long-int form. If we cannot prove that using the simple form\n+\/\/ is safe (i.e. equivalent to the compound-long-int form), then we do not get a valid VPointer,\n+\/\/ and the associated memop cannot be vectorized.\n+bool VPointer::is_safe_to_use_as_simple_form(Node* base, Node* adr) const {\n+#ifndef _LP64\n+  \/\/ On 32-bit platforms, there is never an explicit int_index with ConvI2L for the iv. Thus, the\n+  \/\/ parsed pointer form is always the simple form, with int operations:\n+  \/\/\n+  \/\/   pointer = adr + offset + invar + scale * iv\n+  \/\/\n+  assert(!_has_int_index_after_convI2L, \"32-bit never has an int_index with ConvI2L for the iv\");\n+  return true;\n+#else\n+\n+  \/\/ Array accesses that are not Unsafe always have a RangeCheck which ensures that there is no\n+  \/\/ int_index overflow. This implies that the conversion to long can be done separately:\n+  \/\/\n+  \/\/   ConvI2L(int_index) = ConvI2L(int_offset) + ConvI2L(int_invar) + ConvI2L(scale) * ConvI2L(iv)\n+  \/\/\n+  \/\/ And hence, the simple form is guaranteed to be identical to the compound-long-int form at\n+  \/\/ runtime and the VPointer is safe\/valid to be used.\n+  const TypeAryPtr* ary_ptr_t = _mem->adr_type()->isa_aryptr();\n+  if (ary_ptr_t != nullptr) {\n+    if (!_mem->is_unsafe_access()) {\n+      return true;\n+    }\n+  }\n+\n+  \/\/ We did not find the int_index. Just to be safe, reject this VPointer.\n+  if (!_has_int_index_after_convI2L) {\n+    return false;\n+  }\n+\n+  int int_offset  = _int_index_after_convI2L_offset;\n+  Node* int_invar = _int_index_after_convI2L_invar;\n+  int int_scale   = _int_index_after_convI2L_scale;\n+  int long_scale  = _scale \/ int_scale;\n+\n+  \/\/ If \"int_index = iv\", then the simple form is identical to the compound-long-int form.\n+  \/\/\n+  \/\/   int_index = int_offset + int_invar + int_scale * iv\n+  \/\/             = 0            0           1         * iv\n+  \/\/             =                                      iv\n+  if (int_offset == 0 && int_invar == nullptr && int_scale == 1) {\n+    return true;\n+  }\n+\n+  \/\/ Intuition: What happens if the int_index overflows? Let us look at two pointers on the \"overflow edge\":\n+  \/\/\n+  \/\/              pointer1 = adr + ConvI2L(int_index1)\n+  \/\/              pointer2 = adr + ConvI2L(int_index2)\n+  \/\/\n+  \/\/              int_index1 = max_int + 0 = max_int  -> very close to but before the overflow\n+  \/\/              int_index2 = max_int + 1 = min_int  -> just enough to get the overflow\n+  \/\/\n+  \/\/            When looking at the difference of pointer1 and pointer2, we notice that it is very large\n+  \/\/            (almost 2^32). Since arrays have at most 2^31 elements, chances are high that pointer2 is\n+  \/\/            an actual out-of-bounds access at runtime. These would normally be prevented by range checks\n+  \/\/            at runtime. However, if the access was done by using Unsafe, where range checks are omitted,\n+  \/\/            then an out-of-bounds access constitutes undefined behavior. This means that we are allowed to\n+  \/\/            do anything, including changing the behavior.\n+  \/\/\n+  \/\/            If we can set the right conditions, we have a guarantee that an overflow is either impossible\n+  \/\/            (no overflow or range checks preventing that) or undefined behavior. In both cases, we are\n+  \/\/            safe to do a vectorization.\n+  \/\/\n+  \/\/ Approach:  We want to prove a lower bound for the distance between these two pointers, and an\n+  \/\/            upper bound for the size of a memory object. We can derive such an upper bound for\n+  \/\/            arrays. We know they have at most 2^31 elements. If we know the size of the elements\n+  \/\/            in bytes, we have:\n+  \/\/\n+  \/\/              array_element_size_in_bytes * 2^31 >= max_possible_array_size_in_bytes\n+  \/\/                                                 >= array_size_in_bytes                      (ARR)\n+  \/\/\n+  \/\/            If some small difference \"delta\" leads to an int_index overflow, we know that the\n+  \/\/            int_index1 before overflow must have been close to max_int, and the int_index2 after\n+  \/\/            the overflow must be close to min_int:\n+  \/\/\n+  \/\/              pointer1 =        adr + long_offset + long_invar + long_scale * ConvI2L(int_index1)\n+  \/\/                       =approx  adr + long_offset + long_invar + long_scale * max_int\n+  \/\/\n+  \/\/              pointer2 =        adr + long_offset + long_invar + long_scale * ConvI2L(int_index2)\n+  \/\/                       =approx  adr + long_offset + long_invar + long_scale * min_int\n+  \/\/\n+  \/\/            We realize that the pointer difference is very large:\n+  \/\/\n+  \/\/              difference =approx  long_scale * 2^32\n+  \/\/\n+  \/\/            Hence, if we set the right condition for long_scale and array_element_size_in_bytes,\n+  \/\/            we can prove that an overflow is impossible (or would imply undefined behaviour).\n+  \/\/\n+  \/\/ We must now take this intuition, and develop a rigorous proof. We start by stating the problem\n+  \/\/ more precisely, with the help of some definitions and the Statement we are going to prove.\n+  \/\/\n+  \/\/ Definition:\n+  \/\/   Two VPointers are \"comparable\" (i.e. VPointer::comparable is true, set with VPointer::cmp()),\n+  \/\/   iff all of these conditions apply for the simple form:\n+  \/\/     1) Both VPointers are valid.\n+  \/\/     2) The adr are identical, or both are array bases of different arrays.\n+  \/\/     3) They have identical scale.\n+  \/\/     4) They have identical invar.\n+  \/\/     5) The difference in offsets is limited: abs(offset1 - offset2) < 2^31.                 (DIFF)\n+  \/\/\n+  \/\/ For the Vectorization Optimization, we pair-wise compare VPointers and determine if they are:\n+  \/\/   1) \"not comparable\":\n+  \/\/        We do not optimize them (assume they alias, not assume adjacency).\n+  \/\/\n+  \/\/        Whenever we chose this option based on the simple form, it is also correct based on the\n+  \/\/        compound-long-int form, since we make no optimizations based on it.\n+  \/\/\n+  \/\/   2) \"comparable\" with different array bases at runtime:\n+  \/\/        We assume they do not alias (remove memory edges), but not assume adjacency.\n+  \/\/\n+  \/\/        Whenever we have two different array bases for the simple form, we also have different\n+  \/\/        array bases for the compound-long-form. Since VPointers provably point to different\n+  \/\/        memory objects, they can never alias.\n+  \/\/\n+  \/\/   3) \"comparable\" with the same base address:\n+  \/\/        We compute the relative pointer difference, and based on the load\/store size we can\n+  \/\/        compute aliasing and adjacency.\n+  \/\/\n+  \/\/        We must find a condition under which the pointer difference of the simple form is\n+  \/\/        identical to the pointer difference of the compound-long-form. We do this with the\n+  \/\/        Statement below, which we then proceed to prove.\n+  \/\/\n+  \/\/ Statement:\n+  \/\/   If two VPointers satisfy these 3 conditions:\n+  \/\/     1) They are \"comparable\".\n+  \/\/     2) They have the same base address.\n+  \/\/     3) Their long_scale is a multiple of the array element size in bytes:\n+  \/\/\n+  \/\/          abs(long_scale) % array_element_size_in_bytes = 0                                     (A)\n+  \/\/\n+  \/\/   Then their pointer difference of the simple form is identical to the pointer difference\n+  \/\/   of the compound-long-int form.\n+  \/\/\n+  \/\/   More precisely:\n+  \/\/     Such two VPointers by definition have identical adr, invar, and scale.\n+  \/\/     Their simple form is:\n+  \/\/\n+  \/\/       s_pointer1 = adr + offset1 + invar + scale * ConvI2L(iv)                                 (B1)\n+  \/\/       s_pointer2 = adr + offset2 + invar + scale * ConvI2L(iv)                                 (B2)\n+  \/\/\n+  \/\/     Thus, the pointer difference of the simple forms collapses to the difference in offsets:\n+  \/\/\n+  \/\/       s_difference = s_pointer1 - s_pointer2 = offset1 - offset2                               (C)\n+  \/\/\n+  \/\/     Their compound-long-int form for these VPointer is:\n+  \/\/\n+  \/\/       c_pointer1 = adr + long_offset1 + long_invar1 + long_scale1 * ConvI2L(int_index1)        (D1)\n+  \/\/       int_index1 = int_offset1 + int_invar1 + int_scale1 * iv                                  (D2)\n+  \/\/\n+  \/\/       c_pointer2 = adr + long_offset2 + long_invar2 + long_scale2 * ConvI2L(int_index2)        (D3)\n+  \/\/       int_index2 = int_offset2 + int_invar2 + int_scale2 * iv                                  (D4)\n+  \/\/\n+  \/\/     And these are the offset1, offset2, invar and scale from the simple form (B1) and (B2):\n+  \/\/\n+  \/\/       offset1 = long_offset1 + long_scale1 * ConvI2L(int_offset1)                              (D5)\n+  \/\/       offset2 = long_offset2 + long_scale2 * ConvI2L(int_offset2)                              (D6)\n+  \/\/\n+  \/\/       invar   = long_invar1 + long_scale1 * ConvI2L(int_invar1)\n+  \/\/               = long_invar2 + long_scale2 * ConvI2L(int_invar2)                                (D7)\n+  \/\/\n+  \/\/       scale   = long_scale1 * ConvI2L(int_scale1)\n+  \/\/               = long_scale2 * ConvI2L(int_scale2)                                              (D8)\n+  \/\/\n+  \/\/     The pointer difference of the compound-long-int form is defined as:\n+  \/\/\n+  \/\/       c_difference = c_pointer1 - c_pointer2\n+  \/\/\n+  \/\/   Thus, the statement claims that for the two VPointer we have:\n+  \/\/\n+  \/\/     s_difference = c_difference                                                                (Statement)\n+  \/\/\n+  \/\/ We prove the Statement with the help of a Lemma:\n+  \/\/\n+  \/\/ Lemma:\n+  \/\/   There is some integer x, such that:\n+  \/\/\n+  \/\/     c_difference = s_difference + array_element_size_in_bytes * x * 2^32                       (Lemma)\n+  \/\/\n+  \/\/ From condition (DIFF), we can derive:\n+  \/\/\n+  \/\/   abs(s_difference) < 2^31                                                                     (E)\n+  \/\/\n+  \/\/ Assuming the Lemma, we prove the Statement:\n+  \/\/   If \"x = 0\" (intuitively: the int_index does not overflow), then:\n+  \/\/     c_difference = s_difference\n+  \/\/     and hence the simple form computes the same pointer difference as the compound-long-int form.\n+  \/\/   If \"x != 0\" (intuitively: the int_index overflows), then:\n+  \/\/     abs(c_difference) >= abs(s_difference + array_element_size_in_bytes * x * 2^32)\n+  \/\/                       >= array_element_size_in_bytes * 2^32 - abs(s_difference)\n+  \/\/                                                               --  apply (E)  --\n+  \/\/                       >  array_element_size_in_bytes * 2^32 - 2^31\n+  \/\/                       >= array_element_size_in_bytes * 2^31\n+  \/\/                              --  apply (ARR)  --\n+  \/\/                       >= max_possible_array_size_in_bytes\n+  \/\/                       >= array_size_in_bytes\n+  \/\/\n+  \/\/     This shows that c_pointer1 and c_pointer2 have a distance that exceeds the maximum array size.\n+  \/\/     Thus, at least one of the two pointers must be outside of the array bounds. But we can assume\n+  \/\/     that out-of-bounds accesses do not happen. If they still do, it is undefined behavior. Hence,\n+  \/\/     we are allowed to do anything. We can also \"safely\" use the simple form in this case even though\n+  \/\/     it might not match the compound-long-int form at runtime.\n+  \/\/ QED Statement.\n+  \/\/\n+  \/\/ We must now prove the Lemma.\n+  \/\/\n+  \/\/ ConvI2L always truncates by some power of 2^32, i.e. there is some integer y such that:\n+  \/\/\n+  \/\/   ConvI2L(y1 + y2) = ConvI2L(y1) + ConvI2L(y2) + 2^32 * y                                  (F)\n+  \/\/\n+  \/\/ It follows, that there is an integer y1 such that:\n+  \/\/\n+  \/\/   ConvI2L(int_index1) =  ConvI2L(int_offset1 + int_invar1 + int_scale1 * iv)\n+  \/\/                          -- apply (F) --\n+  \/\/                       =  ConvI2L(int_offset1)\n+  \/\/                        + ConvI2L(int_invar1)\n+  \/\/                        + ConvI2L(int_scale1) * ConvI2L(iv)\n+  \/\/                        + y1 * 2^32                                                         (G)\n+  \/\/\n+  \/\/ Thus, we can write the compound-long-int form (D1) as:\n+  \/\/\n+  \/\/   c_pointer1 =   adr + long_offset1 + long_invar1 + long_scale1 * ConvI2L(int_index1)\n+  \/\/                  -- apply (G) --\n+  \/\/              =   adr\n+  \/\/                + long_offset1\n+  \/\/                + long_invar1\n+  \/\/                + long_scale1 * ConvI2L(int_offset1)\n+  \/\/                + long_scale1 * ConvI2L(int_invar1)\n+  \/\/                + long_scale1 * ConvI2L(int_scale1) * ConvI2L(iv)\n+  \/\/                + long_scale1 * y1 * 2^32                                                    (H)\n+  \/\/\n+  \/\/ And we can write the simple form as:\n+  \/\/\n+  \/\/   s_pointer1 =   adr + offset1 + invar + scale * ConvI2L(iv)\n+  \/\/                  -- apply (D5, D7, D8) --\n+  \/\/              =   adr\n+  \/\/                + long_offset1\n+  \/\/                + long_scale1 * ConvI2L(int_offset1)\n+  \/\/                + long_invar1\n+  \/\/                + long_scale1 * ConvI2L(int_invar1)\n+  \/\/                + long_scale1 * ConvI2L(int_scale1) * ConvI2L(iv)                            (K)\n+  \/\/\n+  \/\/ We now compute the pointer difference between the simple (K) and compound-long-int form (H).\n+  \/\/ Most terms cancel out immediately:\n+  \/\/\n+  \/\/   sc_difference1 = c_pointer1 - s_pointer1 = long_scale1 * y1 * 2^32                        (L)\n+  \/\/\n+  \/\/ Rearranging the equation (L), we get:\n+  \/\/\n+  \/\/   c_pointer1 = s_pointer1 + long_scale1 * y1 * 2^32                                         (M)\n+  \/\/\n+  \/\/ And since long_scale1 is a multiple of array_element_size_in_bytes, there is some integer\n+  \/\/ x1, such that (M) implies:\n+  \/\/\n+  \/\/   c_pointer1 = s_pointer1 + array_element_size_in_bytes * x1 * 2^32                         (N)\n+  \/\/\n+  \/\/ With an analogue equation for c_pointer2, we can now compute the pointer difference for\n+  \/\/ the compound-long-int form:\n+  \/\/\n+  \/\/   c_difference =  c_pointer1 - c_pointer2\n+  \/\/                   -- apply (N) --\n+  \/\/                =  s_pointer1 + array_element_size_in_bytes * x1 * 2^32\n+  \/\/                 -(s_pointer2 + array_element_size_in_bytes * x2 * 2^32)\n+  \/\/                   -- where \"x = x1 - x2\" --\n+  \/\/                =  s_pointer1 - s_pointer2 + array_element_size_in_bytes * x * 2^32\n+  \/\/                   -- apply (C) --\n+  \/\/                =  s_difference            + array_element_size_in_bytes * x * 2^32\n+  \/\/ QED Lemma.\n+  if (ary_ptr_t != nullptr) {\n+    BasicType array_element_bt = ary_ptr_t->elem()->array_element_basic_type();\n+    if (is_java_primitive(array_element_bt)) {\n+      int array_element_size_in_bytes = type2aelembytes(array_element_bt);\n+      if (abs(long_scale) % array_element_size_in_bytes == 0) {\n+        return true;\n+      }\n+    }\n+  }\n+\n+  \/\/ General case: we do not know if it is safe to use the simple form.\n+  return false;\n+#endif\n+}\n+\n@@ -585,0 +946,2 @@\n+      \/\/ (offset1 + invar1 + scale * iv) - (offset2 + invar2)\n+      \/\/ Subtraction handled via \"negate\" flag of \"offset_plus_k\".\n@@ -588,2 +951,29 @@\n-    if (offset_plus_k(n->in(1)) && scaled_iv_plus_offset(n->in(2))) {\n-      _scale *= -1;\n+    VPointer tmp(this);\n+    if (offset_plus_k(n->in(1)) && tmp.scaled_iv_plus_offset(n->in(2))) {\n+      \/\/ (offset1 + invar1) - (offset2 + invar2 + scale * iv)\n+      \/\/ Subtraction handled explicitly below.\n+      assert(_scale == 0, \"shouldn't be set yet\");\n+      \/\/ _scale = -tmp._scale\n+      if (!try_MulI_no_overflow(-1, tmp._scale, _scale)) {\n+        return false; \/\/ mul overflow.\n+      }\n+      \/\/ _offset -= tmp._offset\n+      if (!try_SubI_no_overflow(_offset, tmp._offset, _offset)) {\n+        return false; \/\/ sub overflow.\n+      }\n+      \/\/ _invar -= tmp._invar\n+      if (tmp._invar != nullptr) {\n+        maybe_add_to_invar(tmp._invar, true);\n+#ifdef ASSERT\n+        _debug_invar_scale = tmp._debug_invar_scale;\n+        _debug_negate_invar = !tmp._debug_negate_invar;\n+#endif\n+      }\n+\n+      \/\/ Forward info about the int_index:\n+      assert(!_has_int_index_after_convI2L, \"no previous int_index discovered\");\n+      _has_int_index_after_convI2L = tmp._has_int_index_after_convI2L;\n+      _int_index_after_convI2L_offset = tmp._int_index_after_convI2L_offset;\n+      _int_index_after_convI2L_invar  = tmp._int_index_after_convI2L_invar;\n+      _int_index_after_convI2L_scale  = tmp._int_index_after_convI2L_scale;\n+\n@@ -631,1 +1021,3 @@\n-      _scale = 1 << n->in(2)->get_int();\n+      if (!try_LShiftI_no_overflow(1, n->in(2)->get_int(), _scale)) {\n+        return false; \/\/ shift overflow.\n+      }\n@@ -635,0 +1027,40 @@\n+  } else if (opc == Op_ConvI2L && !has_iv()) {\n+    \/\/ So far we have not found the iv yet, and are about to enter a ConvI2L subgraph,\n+    \/\/ which may be the int index (that might overflow) for the memory access, of the form:\n+    \/\/\n+    \/\/   int_index = int_offset + int_invar + int_scale * iv\n+    \/\/\n+    \/\/ If we simply continue parsing with the current VPointer, then the int_offset and\n+    \/\/ int_invar simply get added to the long offset and invar. But for the checks in\n+    \/\/ VPointer::is_safe_to_use_as_simple_form() we need to have explicit access to the\n+    \/\/ int_index. Thus, we must parse it explicitly here. For this, we use a temporary\n+    \/\/ VPointer, to pattern match the int_index sub-expression of the address.\n+\n+    NOT_PRODUCT(Tracer::Depth dddd;)\n+    VPointer tmp(this);\n+    NOT_PRODUCT(_tracer.scaled_iv_8(n, &tmp);)\n+\n+    if (tmp.scaled_iv_plus_offset(n->in(1)) && tmp.has_iv()) {\n+      \/\/ We successfully matched an integer index, of the form:\n+      \/\/   int_index = int_offset + int_invar + int_scale * iv\n+      \/\/ Forward scale.\n+      assert(_scale == 0 && tmp._scale != 0, \"iv only found just now\");\n+      _scale = tmp._scale;\n+      \/\/ Accumulate offset.\n+      if (!try_AddI_no_overflow(_offset, tmp._offset, _offset)) {\n+        return false; \/\/ add overflow.\n+      }\n+      \/\/ Accumulate invar.\n+      if (tmp._invar != nullptr) {\n+        maybe_add_to_invar(tmp._invar, false);\n+      }\n+      \/\/ Set info about the int_index:\n+      assert(!_has_int_index_after_convI2L, \"no previous int_index discovered\");\n+      _has_int_index_after_convI2L = true;\n+      _int_index_after_convI2L_offset = tmp._offset;\n+      _int_index_after_convI2L_invar  = tmp._invar;\n+      _int_index_after_convI2L_scale  = tmp._scale;\n+\n+      NOT_PRODUCT(_tracer.scaled_iv_7(n);)\n+      return true;\n+    }\n@@ -650,3 +1082,14 @@\n-        int scale = n->in(2)->get_int();\n-        _scale   = tmp._scale  << scale;\n-        _offset += tmp._offset << scale;\n+        int shift = n->in(2)->get_int();\n+        \/\/ Accumulate scale.\n+        if (!try_LShiftI_no_overflow(tmp._scale, shift, _scale)) {\n+          return false; \/\/ shift overflow.\n+        }\n+        \/\/ Accumulate offset.\n+        int shifted_offset = 0;\n+        if (!try_LShiftI_no_overflow(tmp._offset, shift, shifted_offset)) {\n+          return false; \/\/ shift overflow.\n+        }\n+        if (!try_AddI_no_overflow(_offset, shifted_offset, _offset)) {\n+          return false; \/\/ add overflow.\n+        }\n+        \/\/ Accumulate invar.\n@@ -661,0 +1104,8 @@\n+\n+        \/\/ Forward info about the int_index:\n+        assert(!_has_int_index_after_convI2L, \"no previous int_index discovered\");\n+        _has_int_index_after_convI2L = tmp._has_int_index_after_convI2L;\n+        _int_index_after_convI2L_offset = tmp._int_index_after_convI2L_offset;\n+        _int_index_after_convI2L_invar  = tmp._int_index_after_convI2L_invar;\n+        _int_index_after_convI2L_scale  = tmp._int_index_after_convI2L_scale;\n+\n@@ -678,1 +1129,3 @@\n-    _offset += negate ? -(n->get_int()) : n->get_int();\n+    if (!try_AddSubI_no_overflow(_offset, n->get_int(), negate, _offset)) {\n+      return false; \/\/ add\/sub overflow.\n+    }\n@@ -687,1 +1140,3 @@\n-      _offset += negate ? -off : loff;\n+      if (!try_AddSubI_no_overflow(_offset, off, negate, _offset)) {\n+        return false; \/\/ add\/sub overflow.\n+      }\n@@ -702,1 +1157,3 @@\n-      _offset += negate ? -(n->in(2)->get_int()) : n->in(2)->get_int();\n+      if (!try_AddSubI_no_overflow(_offset, n->in(2)->get_int(), negate, _offset)) {\n+        return false; \/\/ add\/sub overflow.\n+      }\n@@ -706,1 +1163,3 @@\n-      _offset += negate ? -(n->in(1)->get_int()) : n->in(1)->get_int();\n+      if (!try_AddSubI_no_overflow(_offset, n->in(1)->get_int(), negate, _offset)) {\n+        return false; \/\/ add\/sub overflow.\n+      }\n@@ -715,1 +1174,3 @@\n-      _offset += !negate ? -(n->in(2)->get_int()) : n->in(2)->get_int();\n+      if (!try_AddSubI_no_overflow(_offset, n->in(2)->get_int(), !negate, _offset)) {\n+        return false; \/\/ add\/sub overflow.\n+      }\n@@ -719,1 +1180,3 @@\n-      _offset += negate ? -(n->in(1)->get_int()) : n->in(1)->get_int();\n+      if (!try_AddSubI_no_overflow(_offset, n->in(1)->get_int(), negate, _offset)) {\n+        return false; \/\/ add\/sub overflow.\n+      }\n@@ -809,0 +1272,51 @@\n+bool VPointer::try_AddI_no_overflow(int offset1, int offset2, int& result) {\n+  jlong long_offset = java_add((jlong)(offset1), (jlong)(offset2));\n+  jint  int_offset  = java_add(        offset1,          offset2);\n+  if (long_offset != int_offset) {\n+    return false;\n+  }\n+  result = int_offset;\n+  return true;\n+}\n+\n+bool VPointer::try_SubI_no_overflow(int offset1, int offset2, int& result) {\n+  jlong long_offset = java_subtract((jlong)(offset1), (jlong)(offset2));\n+  jint  int_offset  = java_subtract(        offset1,          offset2);\n+  if (long_offset != int_offset) {\n+    return false;\n+  }\n+  result = int_offset;\n+  return true;\n+}\n+\n+bool VPointer::try_AddSubI_no_overflow(int offset1, int offset2, bool is_sub, int& result) {\n+  if (is_sub) {\n+    return try_SubI_no_overflow(offset1, offset2, result);\n+  } else {\n+    return try_AddI_no_overflow(offset1, offset2, result);\n+  }\n+}\n+\n+bool VPointer::try_LShiftI_no_overflow(int offset, int shift, int& result) {\n+  if (shift < 0 || shift > 31) {\n+    return false;\n+  }\n+  jlong long_offset = java_shift_left((jlong)(offset), shift);\n+  jint  int_offset  = java_shift_left(        offset,  shift);\n+  if (long_offset != int_offset) {\n+    return false;\n+  }\n+  result = int_offset;\n+  return true;\n+}\n+\n+bool VPointer::try_MulI_no_overflow(int offset1, int offset2, int& result) {\n+  jlong long_offset = java_multiply((jlong)(offset1), (jlong)(offset2));\n+  jint  int_offset  = java_multiply(        offset1,          offset2);\n+  if (long_offset != int_offset) {\n+    return false;\n+  }\n+  result = int_offset;\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":526,"deletions":12,"binary":false,"changes":538,"status":"modified"},{"patch":"@@ -673,0 +673,37 @@\n+\/\/\n+\/\/ We parse and represent pointers of the simple form:\n+\/\/\n+\/\/   pointer   = adr + offset + invar + scale * ConvI2L(iv)\n+\/\/\n+\/\/ Where:\n+\/\/\n+\/\/   adr: the base address of an array (base = adr)\n+\/\/        OR\n+\/\/        some address to off-heap memory (base = TOP)\n+\/\/\n+\/\/   offset: a constant offset\n+\/\/   invar:  a runtime variable, which is invariant during the loop\n+\/\/   scale:  scaling factor\n+\/\/   iv:     loop induction variable\n+\/\/\n+\/\/ But more precisely, we parse the composite-long-int form:\n+\/\/\n+\/\/   pointer   = adr + long_offset + long_invar + long_scale * ConvI2L(int_offset + inv_invar + int_scale * iv)\n+\/\/\n+\/\/   pointer   = adr + long_offset + long_invar + long_scale * ConvI2L(int_index)\n+\/\/   int_index =       int_offset  + int_invar  + int_scale  * iv\n+\/\/\n+\/\/ However, for aliasing and adjacency checks (e.g. VPointer::cmp()) we always use the simple form to make\n+\/\/ decisions. Hence, we must make sure to only create a \"valid\" VPointer if the optimisations based on the\n+\/\/ simple form produce the same result as the compound-long-int form would. Intuitively, this depends on\n+\/\/ if the int_index overflows, but the precise conditions are given in VPointer::is_safe_to_use_as_simple_form().\n+\/\/\n+\/\/   ConvI2L(int_index) = ConvI2L(int_offset  + int_invar  + int_scale  * iv)\n+\/\/                      = Convi2L(int_offset) + ConvI2L(int_invar) + ConvI2L(int_scale) * ConvI2L(iv)\n+\/\/\n+\/\/   scale  = long_scale * ConvI2L(int_scale)\n+\/\/   offset = long_offset + long_scale * ConvI2L(int_offset)\n+\/\/   invar  = long_invar  + long_scale * ConvI2L(int_invar)\n+\/\/\n+\/\/   pointer   = adr + offset + invar + scale * ConvI2L(iv)\n+\/\/\n@@ -678,2 +715,3 @@\n-  Node* _base;               \/\/ null if unsafe nonheap reference\n-  Node* _adr;                \/\/ address pointer\n+  \/\/ Components of the simple form:\n+  Node* _base;               \/\/ Base address of an array OR null if some off-heap memory.\n+  Node* _adr;                \/\/ Same as _base if an array pointer OR some off-heap memory pointer.\n@@ -690,0 +728,7 @@\n+  \/\/ The int_index components of the compound-long-int form. Used to decide if it is safe to use the\n+  \/\/ simple form rather than the compound-long-int form that was parsed.\n+  bool  _has_int_index_after_convI2L;\n+  int   _int_index_after_convI2L_offset;\n+  Node* _int_index_after_convI2L_invar;\n+  int   _int_index_after_convI2L_scale;\n+\n@@ -729,0 +774,2 @@\n+  bool is_safe_to_use_as_simple_form(Node* base, Node* adr) const;\n+\n@@ -754,0 +801,28 @@\n+  \/\/ We compute if and how two VPointers can alias at runtime, i.e. if the two addressed regions of memory can\n+  \/\/ ever overlap. There are essentially 3 relevant return states:\n+  \/\/  - NotComparable:  Synonymous to \"unknown aliasing\".\n+  \/\/                    We have no information about how the two VPointers can alias. They could overlap, refer\n+  \/\/                    to another location in the same memory object, or point to a completely different object.\n+  \/\/                    -> Memory edge required. Aliasing unlikely but possible.\n+  \/\/\n+  \/\/  - Less \/ Greater: Synonymous to \"never aliasing\".\n+  \/\/                    The two VPointers may point into the same memory object, but be non-aliasing (i.e. we\n+  \/\/                    know both address regions inside the same memory object, but these regions are non-\n+  \/\/                    overlapping), or the VPointers point to entirely different objects.\n+  \/\/                    -> No memory edge required. Aliasing impossible.\n+  \/\/\n+  \/\/  - Equal:          Synonymous to \"overlap, or point to different memory objects\".\n+  \/\/                    The two VPointers either overlap on the same memory object, or point to two different\n+  \/\/                    memory objects.\n+  \/\/                    -> Memory edge required. Aliasing likely.\n+  \/\/\n+  \/\/ In a future refactoring, we can simplify to two states:\n+  \/\/  - NeverAlias:     instead of Less \/ Greater\n+  \/\/  - MayAlias:       instead of Equal \/ NotComparable\n+  \/\/\n+  \/\/ Two VPointer are \"comparable\" (Less \/ Greater \/ Equal), iff all of these conditions apply:\n+  \/\/   1) Both are valid, i.e. expressible in the compound-long-int or simple form.\n+  \/\/   2) The adr are identical, or both are array bases of different arrays.\n+  \/\/   3) They have identical scale.\n+  \/\/   4) They have identical invar.\n+  \/\/   5) The difference in offsets is limited: abs(offset0 - offset1) < 2^31.\n@@ -758,0 +833,5 @@\n+      jlong difference = abs(java_subtract((jlong)_offset, (jlong)q._offset));\n+      jlong max_diff = (jlong)1 << 31;\n+      if (difference >= max_diff) {\n+        return NotComparable;\n+      }\n@@ -862,0 +942,6 @@\n+  static bool try_AddI_no_overflow(int offset1, int offset2, int& result);\n+  static bool try_SubI_no_overflow(int offset1, int offset2, int& result);\n+  static bool try_AddSubI_no_overflow(int offset1, int offset2, bool is_sub, int& result);\n+  static bool try_LShiftI_no_overflow(int offset1, int offset2, int& result);\n+  static bool try_MulI_no_overflow(int offset1, int offset2, int& result);\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":88,"deletions":2,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -784,0 +784,1 @@\n+  case Op_SelectFromTwoVector: return new SelectFromTwoVectorNode(n1, n2, n3, vt);\n@@ -802,2 +803,1 @@\n-VectorNode* VectorNode::scalar2vector(Node* s, uint vlen, const Type* opd_t, bool is_mask) {\n-  BasicType bt = opd_t->array_element_basic_type();\n+VectorNode* VectorNode::scalar2vector(Node* s, uint vlen, BasicType bt, bool is_mask) {\n@@ -805,1 +805,1 @@\n-    const TypeVect* vt = TypeVect::make(opd_t, vlen, true);\n+    const TypeVect* vt = TypeVect::make(bt, vlen, true);\n@@ -809,2 +809,1 @@\n-  const TypeVect* vt = opd_t->singleton() ? TypeVect::make(opd_t, vlen)\n-                                          : TypeVect::make(bt, vlen);\n+  const TypeVect* vt = TypeVect::make(bt, vlen);\n@@ -1629,2 +1628,0 @@\n-    const Type* elem_ty = Type::get_const_basic_type(bt);\n-\n@@ -1642,2 +1639,2 @@\n-    Node* vector_mask = phase->transform(VectorNode::scalar2vector(shift_mask_node, vlen, elem_ty));\n-    Node* vector_one = phase->transform(VectorNode::scalar2vector(const_one_node, vlen, elem_ty));\n+    Node* vector_mask = phase->transform(VectorNode::scalar2vector(shift_mask_node, vlen, bt));\n+    Node* vector_one = phase->transform(VectorNode::scalar2vector(const_one_node, vlen, bt));\n@@ -1885,1 +1882,1 @@\n-      const_minus_one = phase->transform(VectorNode::scalar2vector(const_minus_one, vlen, Type::get_const_basic_type(bt)));\n+      const_minus_one = phase->transform(VectorNode::scalar2vector(const_minus_one, vlen, bt));\n@@ -1890,1 +1887,1 @@\n-      const_one = phase->transform(VectorNode::scalar2vector(const_one, vlen, Type::get_const_basic_type(bt)));\n+      const_one = phase->transform(VectorNode::scalar2vector(const_one, vlen, bt));\n@@ -1907,1 +1904,1 @@\n-  const_zero = phase->transform(VectorNode::scalar2vector(const_zero, vlen, Type::get_const_basic_type(bt)));\n+  const_zero = phase->transform(VectorNode::scalar2vector(const_zero, vlen, bt));\n@@ -2072,2 +2069,1 @@\n-    return VectorNode::scalar2vector(zero, length(), Type::get_const_basic_type(bt),\n-                                     bottom_type()->isa_vectmask() != nullptr);\n+    return VectorNode::scalar2vector(zero, length(), bt, bottom_type()->isa_vectmask() != nullptr);\n@@ -2086,0 +2082,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-  static VectorNode* scalar2vector(Node* s, uint vlen, const Type* opd_t, bool is_mask = false);\n+  static VectorNode* scalar2vector(Node* s, uint vlen, BasicType bt, bool is_mask = false);\n@@ -1615,0 +1615,15 @@\n+\n+\/\/ Select elements from two source vectors based on the wrapped indexes held in\n+\/\/ the first vector.\n+class SelectFromTwoVectorNode : public VectorNode {\n+public:\n+  SelectFromTwoVectorNode(Node* indexes, Node* src1, Node* src2, const TypeVect* vt)\n+  : VectorNode(indexes, src1, src2, vt) {\n+      assert(is_integral_type(indexes->bottom_type()->is_vect()->element_basic_type()),\n+             \"indexes must be an integral vector\");\n+  }\n+\n+  virtual int Opcode() const;\n+};\n+\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -425,2 +425,1 @@\n-  tty->print(\"vlen=%d element_type=\", _vlen);\n-  _element_type->dump();\n+  tty->print(\"vlen=%d element_type=%s\", _vlen, type2name(_element_type));\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -357,1 +357,1 @@\n-  const Type* _element_type;\n+  BasicType _element_type;\n@@ -359,1 +359,1 @@\n-  VTransformReplicateNode(VTransform& vtransform, int vlen, const Type* element_type) :\n+  VTransformReplicateNode(VTransform& vtransform, int vlen, BasicType element_type) :\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -241,2 +241,0 @@\n- private:\n-  SafepointMechanism::ThreadData _poll_data;\n@@ -601,0 +599,16 @@\n+  static ByteSize polling_word_offset() {\n+    ByteSize offset = byte_offset_of(Thread, _poll_data) +\n+                      byte_offset_of(SafepointMechanism::ThreadData, _polling_word);\n+    \/\/ At least on x86_64, safepoint polls encode the offset as disp8 imm.\n+    assert(in_bytes(offset) < 128, \"Offset >= 128\");\n+    return offset;\n+  }\n+\n+  static ByteSize polling_page_offset() {\n+    ByteSize offset = byte_offset_of(Thread, _poll_data) +\n+                      byte_offset_of(SafepointMechanism::ThreadData, _polling_page);\n+    \/\/ At least on x86_64, safepoint polls encode the offset as disp8 imm.\n+    assert(in_bytes(offset) < 128, \"Offset >= 128\");\n+    return offset;\n+  }\n+\n@@ -790,2 +804,0 @@\n-  static ByteSize polling_word_offset()          { return byte_offset_of(JavaThread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_word);}\n-  static ByteSize polling_page_offset()          { return byte_offset_of(JavaThread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_page);}\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -638,2 +638,5 @@\n-    \/\/ It is assumed that enter_for must enter on an object without contention.\n-    monitor = inflate_and_enter(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, locking_thread, current);\n+    do {\n+      \/\/ It is assumed that enter_for must enter on an object without contention.\n+      monitor = inflate_and_enter(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, locking_thread, current);\n+      \/\/ But there may still be a race with deflation.\n+    } while (monitor == nullptr);\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-Mutex*   Patching_lock                = nullptr;\n@@ -236,1 +235,0 @@\n-  MUTEX_DEFN(Patching_lock                   , PaddedMutex  , nosafepoint);      \/\/ used for safepointing and code patching.\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-extern Mutex*   Patching_lock;                   \/\/ a lock used to guard code patching of compiled code\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -671,0 +671,7 @@\n+  \/\/ A safe implementation of realpath which will not cause a buffer overflow if the resolved path\n+  \/\/ is longer than PATH_MAX.\n+  \/\/ On success, returns 'outbuf', which now contains the path.\n+  \/\/ On error, it will return null and set errno. The content of 'outbuf' is undefined.\n+  \/\/ On truncation error ('outbuf' too small), it will return null and set errno to ENAMETOOLONG.\n+  static char* realpath(const char* filename, char* outbuf, size_t outbuflen);\n+\n@@ -942,1 +949,1 @@\n-  static void check_dump_limit(char* buffer, size_t bufferSize);\n+  static void check_core_dump_prerequisites(char* buffer, size_t bufferSize, bool check_only = false);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/safepointMechanism.hpp\"\n@@ -112,0 +113,1 @@\n+  friend class JavaThread;\n@@ -138,0 +140,5 @@\n+  \/\/ Poll data is used in generated code for safepoint polls.\n+  \/\/ It is important for performance to put this at lower offset\n+  \/\/ in Thread. The accessors are in JavaThread.\n+  SafepointMechanism::ThreadData _poll_data;\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -668,0 +669,5 @@\n+  if (!FLAG_IS_DEFAULT(CreateCoredumpOnCrash) && CreateCoredumpOnCrash) {\n+    char buffer[2*JVM_MAXPATHLEN];\n+    os::check_core_dump_prerequisites(buffer, sizeof(buffer), true);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1593,1 +1593,0 @@\n-  declare_c2_type(StoreCMNode, StoreNode)                                 \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1205,1 +1205,0 @@\n-#ifndef _WIN64\n@@ -1208,1 +1207,1 @@\n-    const char* absname = os::Posix::realpath(name, tmp, sizeof(tmp));\n+    const char* absname = os::realpath(name, tmp, sizeof(tmp));\n@@ -1210,1 +1209,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-FORBID_C_FUNCTION(char* realpath(const char* path, char* resolved_path), \"use os::Posix::realpath\");\n+FORBID_C_FUNCTION(char* realpath(const char* path, char* resolved_path), \"use os::realpath\");\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1699,1 +1699,1 @@\n-    os::check_dump_limit(buffer, sizeof(buffer));\n+    os::check_core_dump_prerequisites(buffer, sizeof(buffer));\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,1 @@\n+    \/\/ cannot be final as it's re-assigned for deserialization\n@@ -73,34 +74,15 @@\n-    \/**\n-     * Make a DH private key out of a private value <code>x<\/code>, a prime\n-     * modulus <code>p<\/code>, and a base generator <code>g<\/code>.\n-     *\n-     * @param x the private value\n-     * @param p the prime modulus\n-     * @param g the base generator\n-     *\/\n-    DHPrivateKey(BigInteger x, BigInteger p, BigInteger g)\n-        throws InvalidKeyException {\n-        this(x, p, g, 0);\n-    }\n-\n-    \/**\n-     * Make a DH private key out of a private value <code>x<\/code>, a prime\n-     * modulus <code>p<\/code>, a base generator <code>g<\/code>, and a\n-     * private-value length <code>l<\/code>.\n-     *\n-     * @param x the private value\n-     * @param p the prime modulus\n-     * @param g the base generator\n-     * @param l the private-value length\n-     *\/\n-    DHPrivateKey(BigInteger x, BigInteger p, BigInteger g, int l) {\n-        this.x = x;\n-        this.p = p;\n-        this.g = g;\n-        this.l = l;\n-        byte[] xbytes = x.toByteArray();\n-        DerValue val = new DerValue(DerValue.tag_Integer, xbytes);\n-        this.key = val.toByteArray();\n-        val.clear();\n-        Arrays.fill(xbytes, (byte) 0);\n-        encode();\n+    private static class DHComponents {\n+        final BigInteger x;\n+        final BigInteger p;\n+        final BigInteger g;\n+        final int l;\n+        final byte[] key;\n+\n+        DHComponents(BigInteger x, BigInteger p, BigInteger g, int l,\n+                byte[] key) {\n+            this.x = x;\n+            this.p = p;\n+            this.g = g;\n+            this.l = l;\n+            this.key = key;\n+        }\n@@ -109,9 +91,3 @@\n-    \/**\n-     * Make a DH private key from its DER encoding (PKCS #8).\n-     *\n-     * @param encodedKey the encoded key\n-     *\n-     * @throws InvalidKeyException if the encoded key does not represent\n-     * a Diffie-Hellman private key\n-     *\/\n-    DHPrivateKey(byte[] encodedKey) throws InvalidKeyException {\n+    \/\/ parses the specified encoding into a DHComponents object\n+    private static DHComponents decode(byte[] encodedKey)\n+            throws IOException {\n@@ -119,0 +95,1 @@\n+\n@@ -122,1 +99,1 @@\n-                throw new InvalidKeyException (\"Key not a SEQUENCE\");\n+                throw new IOException(\"Key not a SEQUENCE\");\n@@ -125,1 +102,0 @@\n-            \/\/\n@@ -127,1 +103,0 @@\n-            \/\/\n@@ -131,2 +106,1 @@\n-                                      PKCS8_VERSION + \", parsed: \" +\n-                                      parsedVersion);\n+                        PKCS8_VERSION + \", parsed: \" + parsedVersion);\n@@ -135,1 +109,0 @@\n-            \/\/\n@@ -137,1 +110,0 @@\n-            \/\/\n@@ -140,1 +112,1 @@\n-                throw new InvalidKeyException(\"AlgId is not a SEQUENCE\");\n+                throw new IOException(\"AlgId is not a SEQUENCE\");\n@@ -145,1 +117,1 @@\n-                throw new InvalidKeyException(\"Null OID\");\n+                throw new IOException(\"Null OID\");\n@@ -148,1 +120,1 @@\n-                throw new InvalidKeyException(\"Parameters missing\");\n+                throw new IOException(\"Parameters missing\");\n@@ -153,1 +125,1 @@\n-                throw new InvalidKeyException(\"Null parameters\");\n+                throw new IOException(\"Null parameters\");\n@@ -156,1 +128,1 @@\n-                throw new InvalidKeyException(\"Parameters not a SEQUENCE\");\n+                throw new IOException(\"Parameters not a SEQUENCE\");\n@@ -159,2 +131,2 @@\n-            this.p = params.data.getBigInteger();\n-            this.g = params.data.getBigInteger();\n+            BigInteger p = params.data.getBigInteger();\n+            BigInteger g = params.data.getBigInteger();\n@@ -162,0 +134,3 @@\n+            int l = (params.data.available() != 0 ?\n+                    params.data.getInteger() : 0);\n+            \/\/ should have no trailing data\n@@ -163,6 +138,1 @@\n-                this.l = params.data.getInteger();\n-            } else {\n-                this.l = 0;\n-            }\n-            if (params.data.available() != 0) {\n-                throw new InvalidKeyException(\"Extra parameter data\");\n+                throw new IOException(\"Extra parameter data\");\n@@ -171,1 +141,0 @@\n-            \/\/\n@@ -173,5 +142,3 @@\n-            \/\/\n-            this.key = val.data.getOctetString();\n-\n-            DerInputStream in = new DerInputStream(this.key);\n-            this.x = in.getBigInteger();\n+            byte[] key = val.data.getOctetString();\n+            DerInputStream in = new DerInputStream(key);\n+            BigInteger x = in.getBigInteger();\n@@ -179,3 +146,7 @@\n-            this.encodedKey = encodedKey.clone();\n-        } catch (IOException | NumberFormatException e) {\n-            throw new InvalidKeyException(\"Error parsing key encoding\", e);\n+            \/\/ should have no trailing data\n+            if (val.data.available() != 0) {\n+                throw new IOException(\"Excess trailing data\");\n+            }\n+            return new DHComponents(x, p, g, l, key);\n+        } catch (NumberFormatException e) {\n+            throw new IOException(\"Error parsing key encoding\", e);\n@@ -189,0 +160,102 @@\n+    \/\/ Generates the ASN.1 encoding\n+    private static byte[] encode(BigInteger p, BigInteger g, int l,\n+            byte[] key) {\n+        DerOutputStream tmp = new DerOutputStream();\n+\n+        \/\/ version\n+        tmp.putInteger(PKCS8_VERSION);\n+\n+        \/\/ privateKeyAlgorithm\n+        DerOutputStream algid = new DerOutputStream();\n+\n+        \/\/ store OID\n+        algid.putOID(DHPublicKey.DH_OID);\n+        \/\/ encode parameters\n+        DerOutputStream params = new DerOutputStream();\n+        params.putInteger(p);\n+        params.putInteger(g);\n+        if (l != 0) {\n+            params.putInteger(l);\n+        }\n+        \/\/ wrap parameters into SEQUENCE\n+        DerValue paramSequence = new DerValue(DerValue.tag_Sequence,\n+                params.toByteArray());\n+        \/\/ store parameter SEQUENCE in algid\n+        algid.putDerValue(paramSequence);\n+        \/\/ wrap algid into SEQUENCE\n+        tmp.write(DerValue.tag_Sequence, algid);\n+\n+        \/\/ privateKey\n+        tmp.putOctetString(key);\n+\n+        \/\/ make it a SEQUENCE\n+        DerValue val = DerValue.wrap(DerValue.tag_Sequence, tmp);\n+        byte[] encoded = val.toByteArray();\n+        val.clear();\n+\n+        return encoded;\n+    }\n+\n+    \/**\n+     * Make a DH private key out of a private value <code>x<\/code>, a prime\n+     * modulus <code>p<\/code>, and a base generator <code>g<\/code>.\n+     *\n+     * @param x the private value\n+     * @param p the prime modulus\n+     * @param g the base generator\n+     *\/\n+    DHPrivateKey(BigInteger x, BigInteger p, BigInteger g)\n+            throws InvalidKeyException {\n+        this(x, p, g, 0);\n+    }\n+\n+    \/**\n+     * Make a DH private key out of a private value <code>x<\/code>, a prime\n+     * modulus <code>p<\/code>, a base generator <code>g<\/code>, and a\n+     * private-value length <code>l<\/code>.\n+     *\n+     * @param x the private value\n+     * @param p the prime modulus\n+     * @param g the base generator\n+     * @param l the private-value length\n+     *\/\n+    DHPrivateKey(BigInteger x, BigInteger p, BigInteger g, int l) {\n+        this.x = x;\n+        this.p = p;\n+        this.g = g;\n+        this.l = l;\n+\n+        byte[] xbytes = x.toByteArray();\n+        DerValue val = new DerValue(DerValue.tag_Integer, xbytes);\n+        try {\n+            this.key = val.toByteArray();\n+        } finally {\n+            val.clear();\n+            Arrays.fill(xbytes, (byte) 0);\n+        }\n+        this.encodedKey = encode(p, g, l, key);\n+    }\n+\n+    \/**\n+     * Make a DH private key from its DER encoding (PKCS #8).\n+     *\n+     * @param encodedKey the encoded key\n+     *\n+     * @throws InvalidKeyException if the encoded key does not represent\n+     * a Diffie-Hellman private key\n+     *\/\n+    DHPrivateKey(byte[] encodedKey) throws InvalidKeyException {\n+        this.encodedKey = encodedKey.clone();\n+        DHComponents dc;\n+        try {\n+            dc = decode(this.encodedKey);\n+        } catch (IOException e) {\n+            throw new InvalidKeyException(\"Invalid encoding\", e);\n+        }\n+        this.x = dc.x;\n+        this.p = dc.p;\n+        this.g = dc.g;\n+        this.l = dc.l;\n+        this.key = dc.key;\n+    }\n+\n@@ -207,1 +280,0 @@\n-        encode();\n@@ -211,45 +283,0 @@\n-    \/**\n-     * Generate the encodedKey field if it has not been calculated.\n-     * Could generate null.\n-     *\/\n-    private void encode() {\n-        if (this.encodedKey == null) {\n-            DerOutputStream tmp = new DerOutputStream();\n-\n-            \/\/\n-            \/\/ version\n-            \/\/\n-            tmp.putInteger(PKCS8_VERSION);\n-\n-            \/\/\n-            \/\/ privateKeyAlgorithm\n-            \/\/\n-            DerOutputStream algid = new DerOutputStream();\n-\n-            \/\/ store OID\n-            algid.putOID(DHPublicKey.DH_OID);\n-            \/\/ encode parameters\n-            DerOutputStream params = new DerOutputStream();\n-            params.putInteger(this.p);\n-            params.putInteger(this.g);\n-            if (this.l != 0) {\n-                params.putInteger(this.l);\n-            }\n-            \/\/ wrap parameters into SEQUENCE\n-            DerValue paramSequence = new DerValue(DerValue.tag_Sequence,\n-                    params.toByteArray());\n-            \/\/ store parameter SEQUENCE in algid\n-            algid.putDerValue(paramSequence);\n-            \/\/ wrap algid into SEQUENCE\n-            tmp.write(DerValue.tag_Sequence, algid);\n-\n-            \/\/ privateKey\n-            tmp.putOctetString(this.key);\n-\n-            \/\/ make it a SEQUENCE\n-            DerValue val = DerValue.wrap(DerValue.tag_Sequence, tmp);\n-            this.encodedKey = val.toByteArray();\n-            val.clear();\n-        }\n-    }\n-\n@@ -310,4 +337,1 @@\n-        encode();\n-        return new KeyRep(KeyRep.Type.PRIVATE,\n-                getAlgorithm(),\n-                getFormat(),\n+        return new KeyRep(KeyRep.Type.PRIVATE, getAlgorithm(), getFormat(),\n@@ -333,1 +357,0 @@\n-        this.key = key.clone();\n@@ -338,1 +361,19 @@\n-        this.encodedKey = encodedKey.clone();\n+        \/\/ check if the \"encodedKey\" value matches the deserialized fields\n+        DHComponents c;\n+        byte[] encodedKeyIntern = encodedKey.clone();\n+        try {\n+            c = decode(encodedKeyIntern);\n+        } catch (IOException e) {\n+            throw new InvalidObjectException(\"Invalid encoding\", e);\n+        }\n+        if (!Arrays.equals(c.key, key) || !c.x.equals(x) || !c.p.equals(p)\n+                || !c.g.equals(g) || c.l != l) {\n+            throw new InvalidObjectException(\n+                    \"encoded key not matching internal fields\");\n+        }\n+        \/\/ zero out external arrays\n+        Arrays.fill(key, (byte)0x00);\n+        Arrays.fill(encodedKey, (byte)0x00);\n+        \/\/ use self-created internal copies\n+        this.key = c.key;\n+        this.encodedKey = encodedKeyIntern;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHPrivateKey.java","additions":166,"deletions":125,"binary":false,"changes":291,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.Arrays;\n@@ -73,0 +74,110 @@\n+    private static class DHComponents {\n+        final BigInteger y;\n+        final BigInteger p;\n+        final BigInteger g;\n+        final int l;\n+        final byte[] key;\n+\n+        DHComponents(BigInteger y, BigInteger p, BigInteger g, int l,\n+                byte[] key) {\n+            this.y = y;\n+            this.p = p;\n+            this.g = g;\n+            this.l = l;\n+            this.key = key;\n+        }\n+    }\n+\n+    \/\/ parses the specified encoding into a DHComponents object\n+    private static DHComponents decode(byte[] encodedKey)\n+            throws IOException {\n+        DerValue val = null;\n+\n+        try {\n+            val = new DerValue(encodedKey);\n+            if (val.tag != DerValue.tag_Sequence) {\n+                throw new IOException(\"Invalid key format\");\n+            }\n+\n+            \/\/ algorithm identifier\n+            DerValue algid = val.data.getDerValue();\n+            if (algid.tag != DerValue.tag_Sequence) {\n+                throw new IOException(\"AlgId is not a SEQUENCE\");\n+            }\n+            DerInputStream derInStream = algid.toDerInputStream();\n+            ObjectIdentifier oid = derInStream.getOID();\n+            if (oid == null) {\n+                throw new IOException(\"Null OID\");\n+            }\n+            if (derInStream.available() == 0) {\n+                throw new IOException(\"Parameters missing\");\n+            }\n+\n+            \/\/ parse the parameters\n+            DerValue params = derInStream.getDerValue();\n+            if (params.tag == DerValue.tag_Null) {\n+                throw new IOException(\"Null parameters\");\n+            }\n+            if (params.tag != DerValue.tag_Sequence) {\n+                throw new IOException(\"Parameters not a SEQUENCE\");\n+            }\n+            params.data.reset();\n+\n+            BigInteger p = params.data.getBigInteger();\n+            BigInteger g = params.data.getBigInteger();\n+            \/\/ Private-value length is OPTIONAL\n+            int l = (params.data.available() != 0 ? params.data.getInteger() :\n+                    0);\n+            if (params.data.available() != 0) {\n+                throw new IOException(\"Extra parameter data\");\n+            }\n+\n+            \/\/ publickey\n+            byte[] key = val.data.getBitString();\n+            DerInputStream in = new DerInputStream(key);\n+            BigInteger y = in.getBigInteger();\n+\n+            if (val.data.available() != 0) {\n+                throw new IOException(\"Excess key data\");\n+            }\n+            return new DHComponents(y, p, g, l, key);\n+        } catch (NumberFormatException e) {\n+            throw new IOException(\"Error parsing key encoding\", e);\n+        }\n+    }\n+\n+    \/\/ generates the ASN.1 encoding\n+    private static byte[] encode(BigInteger p, BigInteger g, int l,\n+            byte[] key) {\n+        DerOutputStream algid = new DerOutputStream();\n+\n+        \/\/ store oid in algid\n+        algid.putOID(DH_OID);\n+\n+        \/\/ encode parameters\n+        DerOutputStream params = new DerOutputStream();\n+        params.putInteger(p);\n+        params.putInteger(g);\n+        if (l != 0) {\n+            params.putInteger(l);\n+        }\n+\n+        \/\/ wrap parameters into SEQUENCE\n+        DerValue paramSequence = new DerValue(DerValue.tag_Sequence,\n+                params.toByteArray());\n+        \/\/ store parameter SEQUENCE in algid\n+        algid.putDerValue(paramSequence);\n+\n+        \/\/ wrap algid into SEQUENCE, and store it in key encoding\n+        DerOutputStream tmpDerKey = new DerOutputStream();\n+        tmpDerKey.write(DerValue.tag_Sequence, algid);\n+\n+        \/\/ store key data\n+        tmpDerKey.putBitString(key);\n+\n+        \/\/ wrap algid and key into SEQUENCE\n+        DerOutputStream derKey = new DerOutputStream();\n+        derKey.write(DerValue.tag_Sequence, tmpDerKey);\n+        return derKey.toByteArray();\n+    }\n+\n@@ -105,1 +216,1 @@\n-        this.encodedKey = getEncoded();\n+        this.encodedKey = encode(p, g, l, key);\n@@ -117,57 +228,1 @@\n-        InputStream inStream = new ByteArrayInputStream(encodedKey);\n-        try {\n-            DerValue derKeyVal = new DerValue(inStream);\n-            if (derKeyVal.tag != DerValue.tag_Sequence) {\n-                throw new InvalidKeyException (\"Invalid key format\");\n-            }\n-\n-            \/*\n-             * Parse the algorithm identifier\n-             *\/\n-            DerValue algid = derKeyVal.data.getDerValue();\n-            if (algid.tag != DerValue.tag_Sequence) {\n-                throw new InvalidKeyException(\"AlgId is not a SEQUENCE\");\n-            }\n-            DerInputStream derInStream = algid.toDerInputStream();\n-            ObjectIdentifier oid = derInStream.getOID();\n-            if (oid == null) {\n-                throw new InvalidKeyException(\"Null OID\");\n-            }\n-            if (derInStream.available() == 0) {\n-                throw new InvalidKeyException(\"Parameters missing\");\n-            }\n-\n-            \/*\n-             * Parse the parameters\n-             *\/\n-            DerValue params = derInStream.getDerValue();\n-            if (params.tag == DerValue.tag_Null) {\n-                throw new InvalidKeyException(\"Null parameters\");\n-            }\n-            if (params.tag != DerValue.tag_Sequence) {\n-                throw new InvalidKeyException(\"Parameters not a SEQUENCE\");\n-            }\n-            params.data.reset();\n-            this.p = params.data.getBigInteger();\n-            this.g = params.data.getBigInteger();\n-            \/\/ Private-value length is OPTIONAL\n-            if (params.data.available() != 0) {\n-                this.l = params.data.getInteger();\n-            } else {\n-                this.l = 0;\n-            }\n-            if (params.data.available() != 0) {\n-                throw new InvalidKeyException(\"Extra parameter data\");\n-            }\n-\n-            \/*\n-             * Parse the key\n-             *\/\n-            this.key = derKeyVal.data.getBitString();\n-\n-            DerInputStream in = new DerInputStream(this.key);\n-            this.y = in.getBigInteger();\n-\n-            if (derKeyVal.data.available() != 0) {\n-                throw new InvalidKeyException(\"Excess key data\");\n-            }\n+        this.encodedKey = encodedKey.clone();\n@@ -175,3 +230,5 @@\n-            this.encodedKey = encodedKey.clone();\n-        } catch (IOException | NumberFormatException e) {\n-            throw new InvalidKeyException(\"Error parsing key encoding\", e);\n+        DHComponents dc;\n+        try {\n+            dc = decode(this.encodedKey);\n+        } catch (IOException e) {\n+            throw new InvalidKeyException(\"Invalid encoding\", e);\n@@ -179,0 +236,5 @@\n+        this.y = dc.y;\n+        this.p = dc.p;\n+        this.g = dc.g;\n+        this.l = dc.l;\n+        this.key = dc.key;\n@@ -199,31 +261,0 @@\n-        if (this.encodedKey == null) {\n-            DerOutputStream algid = new DerOutputStream();\n-\n-            \/\/ store oid in algid\n-            algid.putOID(DH_OID);\n-\n-            \/\/ encode parameters\n-            DerOutputStream params = new DerOutputStream();\n-            params.putInteger(this.p);\n-            params.putInteger(this.g);\n-            if (this.l != 0) {\n-                params.putInteger(this.l);\n-            }\n-            \/\/ wrap parameters into SEQUENCE\n-            DerValue paramSequence = new DerValue(DerValue.tag_Sequence,\n-                    params.toByteArray());\n-            \/\/ store parameter SEQUENCE in algid\n-            algid.putDerValue(paramSequence);\n-\n-            \/\/ wrap algid into SEQUENCE, and store it in key encoding\n-            DerOutputStream tmpDerKey = new DerOutputStream();\n-            tmpDerKey.write(DerValue.tag_Sequence, algid);\n-\n-            \/\/ store key data\n-            tmpDerKey.putBitString(this.key);\n-\n-            \/\/ wrap algid and key into SEQUENCE\n-            DerOutputStream derKey = new DerOutputStream();\n-            derKey.write(DerValue.tag_Sequence, tmpDerKey);\n-            this.encodedKey = derKey.toByteArray();\n-        }\n@@ -266,1 +297,1 @@\n-        if (this.l != 0)\n+        if (this.l != 0) {\n@@ -268,0 +299,1 @@\n+        }\n@@ -307,1 +339,1 @@\n-                        getEncoded());\n+                        encodedKey);\n@@ -326,1 +358,0 @@\n-        this.key = key.clone();\n@@ -331,1 +362,19 @@\n-        this.encodedKey = encodedKey.clone();\n+        \/\/ check if the \"encodedKey\" value matches the deserialized fields\n+        DHComponents c;\n+        byte[] encodedKeyIntern = encodedKey.clone();\n+        try {\n+            c = decode(encodedKeyIntern);\n+        } catch (IOException e) {\n+            throw new InvalidObjectException(\"Invalid encoding\", e);\n+        }\n+        if (!Arrays.equals(c.key, key) || !c.y.equals(y) || !c.p.equals(p)\n+                || !c.g.equals(g) || c.l != l) {\n+            throw new InvalidObjectException(\n+                    \"encoded key not matching internal fields\");\n+        }\n+        \/\/ zero out external arrays\n+        Arrays.fill(key, (byte)0x00);\n+        Arrays.fill(encodedKey, (byte)0x00);\n+        \/\/ use self-created internal copies\n+        this.key = c.key;\n+        this.encodedKey = encodedKeyIntern;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHPublicKey.java","additions":146,"deletions":97,"binary":false,"changes":243,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,17 +197,19 @@\n-       \/**\n-        * Restores the state of this object from the stream.\n-        *\n-        * @param  stream the {@code ObjectInputStream} from which data is read\n-        * @throws IOException if an I\/O error occurs\n-        * @throws ClassNotFoundException if a serialized class cannot be loaded\n-        *\/\n-       @java.io.Serial\n-       private void readObject(ObjectInputStream stream)\n-               throws IOException, ClassNotFoundException {\n-           stream.defaultReadObject();\n-           if ((key == null) || (key.length == 0)) {\n-               throw new InvalidObjectException(\"TlsMasterSecretKey is null\");\n-           }\n-           key = key.clone();\n-       }\n-   }\n+        \/**\n+         * Restores the state of this object from the stream.\n+         *\n+         * @param  stream the {@code ObjectInputStream} from which data is read\n+         * @throws IOException if an I\/O error occurs\n+         * @throws ClassNotFoundException if a serialized class cannot be loaded\n+         *\/\n+        @java.io.Serial\n+        private void readObject(ObjectInputStream stream)\n+                throws IOException, ClassNotFoundException {\n+            stream.defaultReadObject();\n+            if (key == null || key.length == 0) {\n+                throw new InvalidObjectException(\"TlsMasterSecretKey is null\");\n+            }\n+            byte[] temp = key;\n+            this.key = temp.clone();\n+            Arrays.fill(temp, (byte)0);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/TlsMasterSecretGenerator.java","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -491,0 +493,2 @@\n+        requireNonNull(className);\n+        requireNonNull(constantName);\n@@ -509,0 +513,1 @@\n+        requireNonNull(className);\n@@ -525,0 +530,1 @@\n+        requireNonNull(value);\n@@ -541,0 +547,1 @@\n+        requireNonNull(value);\n@@ -557,0 +564,1 @@\n+        requireNonNull(value);\n@@ -573,0 +581,1 @@\n+        requireNonNull(value);\n@@ -589,0 +598,1 @@\n+        requireNonNull(value);\n@@ -605,0 +615,1 @@\n+        requireNonNull(value);\n@@ -621,0 +632,1 @@\n+        requireNonNull(value);\n@@ -637,0 +649,1 @@\n+        requireNonNull(value);\n@@ -653,0 +666,1 @@\n+        requireNonNull(value);\n@@ -670,0 +684,1 @@\n+        requireNonNull(value);\n@@ -787,1 +802,1 @@\n-        throw new IllegalArgumentException(\"Illegal annotation constant value type \" + (value == null ? null : value.getClass()));\n+        throw new IllegalArgumentException(\"Illegal annotation constant value type \" + requireNonNull(value).getClass());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationValue.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -61,0 +63,1 @@\n+        requireNonNull(attr);\n@@ -79,0 +82,1 @@\n+        requireNonNull(attr);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AttributedElement.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -109,0 +111,1 @@\n+        requireNonNull(other);\n@@ -173,1 +176,1 @@\n-        return new ClassHierarchyImpl.ResourceParsingClassHierarchyResolver(classStreamResolver);\n+        return new ClassHierarchyImpl.ResourceParsingClassHierarchyResolver(requireNonNull(classStreamResolver));\n@@ -184,0 +187,1 @@\n+        requireNonNull(loader);\n@@ -213,0 +217,1 @@\n+        requireNonNull(loader);\n@@ -235,0 +240,1 @@\n+        requireNonNull(lookup);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassHierarchyResolver.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -66,1 +68,1 @@\n-        return new TransformImpl.SupplierClassTransform(supplier);\n+        return new TransformImpl.SupplierClassTransform(requireNonNull(supplier));\n@@ -77,0 +79,1 @@\n+        requireNonNull(finisher);\n@@ -98,0 +101,1 @@\n+        requireNonNull(filter);\n@@ -114,1 +118,1 @@\n-        return new TransformImpl.ClassMethodTransform(xform, filter);\n+        return new TransformImpl.ClassMethodTransform(requireNonNull(xform), requireNonNull(filter));\n@@ -125,1 +129,1 @@\n-        return transformingMethods(mm -> true, xform);\n+        return transformingMethods(_ -> true, xform);\n@@ -160,1 +164,1 @@\n-        return new TransformImpl.ClassFieldTransform(xform, f -> true);\n+        return new TransformImpl.ClassFieldTransform(requireNonNull(xform), _ -> true);\n@@ -172,1 +176,1 @@\n-        return new TransformImpl.ChainedClassTransform(this, t);\n+        return new TransformImpl.ChainedClassTransform(this, requireNonNull(t));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassTransform.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -64,1 +66,1 @@\n-        return new TransformImpl.SupplierCodeTransform(supplier);\n+        return new TransformImpl.SupplierCodeTransform(requireNonNull(supplier));\n@@ -75,0 +77,1 @@\n+        requireNonNull(finisher);\n@@ -97,1 +100,1 @@\n-        return new TransformImpl.ChainedCodeTransform(this, t);\n+        return new TransformImpl.ChainedCodeTransform(this, requireNonNull(t));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeTransform.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -65,1 +67,1 @@\n-        return new TransformImpl.SupplierFieldTransform(supplier);\n+        return new TransformImpl.SupplierFieldTransform(requireNonNull(supplier));\n@@ -76,0 +78,1 @@\n+        requireNonNull(finisher);\n@@ -97,0 +100,1 @@\n+        requireNonNull(filter);\n@@ -112,1 +116,1 @@\n-        return new TransformImpl.ChainedFieldTransform(this, t);\n+        return new TransformImpl.ChainedFieldTransform(this, requireNonNull(t));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/FieldTransform.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -65,0 +67,1 @@\n+        requireNonNull(supplier);\n@@ -76,0 +79,1 @@\n+        requireNonNull(finisher);\n@@ -97,0 +101,1 @@\n+        requireNonNull(filter);\n@@ -111,1 +116,1 @@\n-        return new TransformImpl.MethodCodeTransform(xform);\n+        return new TransformImpl.MethodCodeTransform(requireNonNull(xform));\n@@ -123,1 +128,1 @@\n-        return new TransformImpl.ChainedMethodTransform(this, t);\n+        return new TransformImpl.ChainedMethodTransform(this, requireNonNull(t));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodTransform.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -67,0 +69,1 @@\n+        requireNonNull(classMap);\n@@ -78,1 +81,1 @@\n-        return new ClassRemapperImpl(mapFunction);\n+        return new ClassRemapperImpl(requireNonNull(mapFunction));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/ClassRemapper.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -65,0 +67,1 @@\n+        requireNonNull(map);\n@@ -75,1 +78,1 @@\n-        return new CodeRelabelerImpl(mapFunction);\n+        return new CodeRelabelerImpl(requireNonNull(mapFunction));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/CodeRelabeler.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/DiscontinuedInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+<!doctype html>\n+<!--\n+ Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+ This code is free software; you can redistribute it and\/or modify it\n+ under the terms of the GNU General Public License version 2 only, as\n+ published by the Free Software Foundation.  Oracle designates this\n+ particular file as subject to the \"Classpath\" exception as provided\n+ by Oracle in the LICENSE file that accompanied this code.\n+\n+ This code is distributed in the hope that it will be useful, but WITHOUT\n+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ version 2 for more details (a copy is included in the LICENSE file that\n+ accompanied this code).\n+\n+ You should have received a copy of the GNU General Public License version\n+ 2 along with this work; if not, write to the Free Software Foundation,\n+ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ or visit www.oracle.com if you need additional information or have any\n+ questions.\n+-->\n+<html lang=\"en\">\n+<head>\n+    <title>Restricted methods<\/title>\n+<\/head>\n+<body>\n+<h1 id=\"restricted\">Restricted methods<\/h1>\n+<p>Various methods in the Java SE API allow Java code to interoperate with resources outside the Java runtime\n+    in such a way that the runtime cannot prove correct or safe use of the resources. These methods can,\n+    when used incorrectly, violate the integrity of the Java Virtual Machine, but are conditionally made available\n+    to users, as they provide essential functionality. They are known as <em>restricted methods<\/em>.<\/p>\n+<p>Given the potential danger of restricted methods, the Java runtime issues a warning on\n+    the standard error stream every time a restricted method is invoked. Such warnings can\n+    be disabled by granting access to restricted methods to selected modules. This can be\n+    done either via implementation-specific command line options or programmatically, e.g.\n+    by calling <a href=\"{@docRoot}\/java.base\/java\/lang\/ModuleLayer.Controller.html#enableNativeAccess(java.lang.Module)\"><code>ModuleLayer.Controller.enableNativeAccess(java.lang.Module)<\/code><\/a>.<\/p>\n+<p>When a restricted method is invoked by <a href=\"{@docRoot}\/..\/specs\/jni\/index.html\">JNI code<\/a>,\n+    or from an <a href=\"{@docRoot}\/java.base\/java\/lang\/foreign\/Linker.html#upcallStub(java.lang.invoke.MethodHandle,java.lang.foreign.FunctionDescriptor,java.lang.foreign.Arena,java.lang.foreign.Linker.Option...)\">upcall stub<\/a>\n+    and there is no caller class on the stack, it is as if the restricted method call occurred in an <em>unnamed module<\/em>.<\/p>\n+<p>In the reference implementation, access to restricted methods can be granted to\n+    specific modules using the command line option <code>--enable-native-access=M1,M2, ... Mn<\/code>,\n+    where <code>M1<\/code>, <code>M2<\/code>, <code>... Mn<\/code> are module names (for the unnamed module,\n+    the special value <code>ALL-UNNAMED<\/code> can be used).  Access to restricted methods\n+    from modules not listed by that option is deemed <em>illegal<\/em>. Clients can\n+    control how access to restricted methods is handled, using the command line\n+    option <code>--illegal-native-access<\/code>. If this option is not specified,\n+    illegal access to restricted methods will result in runtime warnings.<\/p>\n+<\/body>\n+<\/html>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/doc-files\/RestrictedMethods.html","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -131,30 +131,0 @@\n- * <h2 id=\"restricted\">Restricted methods<\/h2>\n- *\n- * Some methods in this package are considered <em>restricted<\/em>. Restricted methods\n- * are typically used to bind native foreign data and\/or functions to first-class\n- * Java API elements which can then be used directly by clients. For instance the\n- * restricted method {@link java.lang.foreign.MemorySegment#reinterpret(long)} can be\n- * used to create a fresh segment with the same address and temporal bounds, but with\n- * the provided size. This can be useful to resize memory segments obtained when\n- * interacting with native functions.\n- * <p>\n- * Binding foreign data and\/or functions is generally unsafe and, if done incorrectly,\n- * can result in VM crashes, or memory corruption when the bound Java API element\n- * is accessed. For instance, incorrectly resizing a native memory segment using\n- * {@link java.lang.foreign.MemorySegment#reinterpret(long)} can lead to a JVM crash, or,\n- * worse, lead to silent memory corruption when attempting to access the resized segment.\n- * For these reasons, it is crucial for code that calls a restricted method to never pass\n- * arguments that might cause incorrect binding of foreign data and\/or functions to\n- * a Java API.\n- * <p>\n- * Given the potential danger of restricted methods, the Java runtime issues a warning on\n- * the standard error stream every time a restricted method is invoked. Such warnings can\n- * be disabled by granting access to restricted methods to selected modules. This can be\n- * done either via implementation-specific command line options or programmatically, e.g.\n- * by calling {@link java.lang.ModuleLayer.Controller#enableNativeAccess(java.lang.Module)}.\n- * <p>\n- * For every class in this package, unless specified otherwise, any method arguments of\n- * reference type must not be {@code null}, and any null argument will elicit a\n- * {@code NullPointerException}. This fact is not individually documented for methods of\n- * this API.\n- *\n@@ -164,10 +134,0 @@\n- * @implNote\n- * In the reference implementation, access to restricted methods can be granted to\n- * specific modules using the command line option {@code --enable-native-access=M1,M2, ... Mn},\n- * where {@code M1}, {@code M2}, {@code ... Mn} are module names (for the unnamed module,\n- * the special value {@code ALL-UNNAMED} can be used). Access to restricted methods\n- * from modules not listed by that option is deemed <em>illegal<\/em>. Clients can\n- * control how access to restricted methods is handled, using the command line\n- * option {@code --illegal-native-access}. If this option is not specified,\n- * illegal access to restricted methods will result in runtime warnings.\n- *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import jdk.internal.loader.ClassLoaders;\n@@ -374,1 +375,2 @@\n-        return ClassFile.of(ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofClassLoading(loader)))\n+        return ClassFile.of(ClassHierarchyResolverOption.of(ClassHierarchyResolver.ofClassLoading(loader == null ?\n+                        ClassLoaders.platformClassLoader() : loader)))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,0 +80,13 @@\n+    \/* Override the implementation of Reference.clear.\n+     * Phantom references are weaker than finalization, so the referent\n+     * access needs to be handled differently for garbage collectors that\n+     * do reference processing concurrently.\n+     *\/\n+    @Override\n+    void clearImpl() {\n+        clear0();\n+    }\n+\n+    @IntrinsicCandidate\n+    private native void clear0();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/PhantomReference.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -406,1 +406,1 @@\n-        clear0();\n+        clearImpl();\n@@ -409,3 +409,8 @@\n-    \/* Implementation of clear(), also used by enqueue().  A simple\n-     * assignment of the referent field won't do for some garbage\n-     * collectors.\n+    \/* Implementation of clear(). A simple assignment of the referent field\n+     * won't do for some garbage collectors. There is the override for phantom\n+     * references, which requires different semantics. This method is also\n+     * used by enqueue().\n+     *\n+     * <p>This method exists only to avoid making clear0() virtual. Making\n+     * clear0() virtual has the undesirable effect of C2 often preferring\n+     * to call the native implementation over the intrinsic.\n@@ -413,0 +418,5 @@\n+    void clearImpl() {\n+        clear0();\n+    }\n+\n+    @IntrinsicCandidate\n@@ -514,1 +524,1 @@\n-        clear0();               \/\/ Intentionally clear0() rather than clear()\n+        clearImpl(); \/\/ Intentionally clearImpl() to dispatch to overridden method, if needed\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -256,0 +256,9 @@\n+\n+\t<LI><P><B>{@systemProperty jdk.http.maxHeaderSize}<\/B> (default: 393216 or 384kB)<BR>\n+\tThis is the maximum header field section size that a client is prepared to accept.\n+\tThis is computed as the sum of the size of the uncompressed header name, plus\n+\tthe size of the uncompressed header value, plus an overhead of 32 bytes for\n+\teach field section line. If a peer sends a field section that exceeds this\n+\tsize a {@link java.net.ProtocolException ProtocolException} will be raised.\n+\tThis applies to all versions of the HTTP protocol. A value of zero or a negative\n+\tvalue means no limit. If left unspecified, the default value is 393216 bytes.\n","filename":"src\/java.base\/share\/classes\/java\/net\/doc-files\/net-properties.html","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -410,0 +410,5 @@\n+\n+        if (perms == null) {\n+            throw new InvalidObjectException(\"perms can't be null\");\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/security\/Permissions.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,4 +155,4 @@\n-        throws IOException, InvalidKeyException, SignatureException {\n-            \/\/ creating a stream pipe-line, from a to b\n-            ByteArrayOutputStream b = new ByteArrayOutputStream();\n-            ObjectOutput a = new ObjectOutputStream(b);\n+            throws IOException, InvalidKeyException, SignatureException {\n+        \/\/ creating a stream pipe-line, from a to b\n+        ByteArrayOutputStream b = new ByteArrayOutputStream();\n+        ObjectOutput a = new ObjectOutputStream(b);\n@@ -160,6 +160,6 @@\n-            \/\/ write and flush the object content to byte array\n-            a.writeObject(object);\n-            a.flush();\n-            a.close();\n-            this.content = b.toByteArray();\n-            b.close();\n+        \/\/ write and flush the object content to byte array\n+        a.writeObject(object);\n+        a.flush();\n+        a.close();\n+        this.content = b.toByteArray();\n+        b.close();\n@@ -167,2 +167,2 @@\n-            \/\/ now sign the encapsulated object\n-            this.sign(signingKey, signingEngine);\n+        \/\/ now sign the encapsulated object\n+        this.sign(signingKey, signingEngine);\n@@ -248,6 +248,6 @@\n-        throws InvalidKeyException, SignatureException {\n-            \/\/ initialize the signing engine\n-            signingEngine.initSign(signingKey);\n-            signingEngine.update(this.content.clone());\n-            this.signature = signingEngine.sign().clone();\n-            this.thealgorithm = signingEngine.getAlgorithm();\n+            throws InvalidKeyException, SignatureException {\n+        \/\/ initialize the signing engine\n+        signingEngine.initSign(signingKey);\n+        signingEngine.update(this.content.clone());\n+        this.signature = signingEngine.sign();\n+        this.thealgorithm = signingEngine.getAlgorithm();\n@@ -266,5 +266,11 @@\n-        throws IOException, ClassNotFoundException {\n-            ObjectInputStream.GetField fields = s.readFields();\n-            content = ((byte[])fields.get(\"content\", null)).clone();\n-            signature = ((byte[])fields.get(\"signature\", null)).clone();\n-            thealgorithm = (String)fields.get(\"thealgorithm\", null);\n+            throws IOException, ClassNotFoundException {\n+       ObjectInputStream.GetField fields = s.readFields();\n+       byte[] c = (byte[]) fields.get(\"content\", null);\n+       byte[] sig = (byte[]) fields.get(\"signature\", null);\n+       String a = (String) fields.get(\"thealgorithm\", null);\n+       if (c == null || sig == null || a == null) {\n+           throw new InvalidObjectException(\"One or more null fields\");\n+       }\n+       content = c.clone();\n+       signature = sig.clone();\n+       thealgorithm = a;\n","filename":"src\/java.base\/share\/classes\/java\/security\/SignedObject.java","additions":30,"deletions":24,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.io.InvalidObjectException;\n@@ -81,1 +82,1 @@\n-        if (timestamp == null || signerCertPath == null) {\n+        if (isNull(timestamp, signerCertPath)) {\n@@ -169,1 +170,1 @@\n-        throws IOException, ClassNotFoundException {\n+            throws IOException, ClassNotFoundException {\n@@ -171,0 +172,3 @@\n+        if (isNull(timestamp, signerCertPath)) {\n+            throw new InvalidObjectException(\"Invalid null field(s)\");\n+        }\n@@ -174,0 +178,4 @@\n+\n+    private static boolean isNull(Date d, CertPath c) {\n+        return (d == null || c == null);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/security\/Timestamp.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.io.InvalidObjectException;\n@@ -199,1 +200,0 @@\n-        @SuppressWarnings(\"unchecked\")\n@@ -202,4 +202,9 @@\n-        Hashtable<String, Vector<UnresolvedPermission>> permissions =\n-                (Hashtable<String, Vector<UnresolvedPermission>>)\n-                gfields.get(\"permissions\", null);\n-        perms = new ConcurrentHashMap<>(permissions.size()*2);\n+        try {\n+            @SuppressWarnings(\"unchecked\")\n+            Hashtable<String, Vector<UnresolvedPermission>> permissions =\n+                    (Hashtable<String, Vector<UnresolvedPermission>>)\n+                    gfields.get(\"permissions\", null);\n+\n+            if (permissions == null) {\n+                throw new InvalidObjectException(\"Invalid null permissions\");\n+            }\n@@ -207,6 +212,1 @@\n-        \/\/ Convert each entry (Vector) into a List\n-        Set<Map.Entry<String, Vector<UnresolvedPermission>>> set = permissions.entrySet();\n-        for (Map.Entry<String, Vector<UnresolvedPermission>> e : set) {\n-            \/\/ Convert Vector into ArrayList\n-            Vector<UnresolvedPermission> vec = e.getValue();\n-            List<UnresolvedPermission> list = new CopyOnWriteArrayList<>(vec);\n+            perms = new ConcurrentHashMap<>(permissions.size()*2);\n@@ -214,2 +214,12 @@\n-            \/\/ Add to Hashtable being serialized\n-            perms.put(e.getKey(), list);\n+            \/\/ Convert each entry (Vector) into a List\n+            Set<Map.Entry<String, Vector<UnresolvedPermission>>> set = permissions.entrySet();\n+            for (Map.Entry<String, Vector<UnresolvedPermission>> e : set) {\n+                \/\/ Convert Vector into ArrayList\n+                Vector<UnresolvedPermission> vec = e.getValue();\n+                List<UnresolvedPermission> list = new CopyOnWriteArrayList<>(vec);\n+\n+                \/\/ Add to Hashtable being serialized\n+                perms.put(e.getKey(), list);\n+            }\n+        } catch (ClassCastException cce) {\n+            throw new InvalidObjectException(\"Invalid type for permissions\");\n","filename":"src\/java.base\/share\/classes\/java\/security\/UnresolvedPermissionCollection.java","additions":24,"deletions":14,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.io.InvalidObjectException;\n@@ -73,0 +74,7 @@\n+    private static boolean isNull(Date revocationDate,\n+            CRLReason reason, X500Principal authority,\n+            Map<String, Extension> extensions) {\n+        return (revocationDate == null || reason == null || authority == null\n+                || extensions == null);\n+    }\n+\n@@ -95,2 +103,1 @@\n-        if (revocationDate == null || reason == null || authority == null ||\n-            extensions == null) {\n+        if (isNull(revocationDate, reason, authority, extensions)) {\n@@ -237,3 +244,0 @@\n-        \/\/ Defensively copy the revocation date\n-        revocationDate = new Date(revocationDate.getTime());\n-\n@@ -250,0 +254,7 @@\n+        \/\/ make sure all fields are set before checking\n+        if (isNull(revocationDate, reason, authority, extensions)) {\n+            throw new InvalidObjectException(\"Invalid null field(s)\");\n+        }\n+\n+        \/\/ Defensively copy the revocation date\n+        revocationDate = new Date(revocationDate.getTime());\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/CertificateRevokedException.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import java.io.ObjectStreamException;\n@@ -1184,0 +1185,2 @@\n+\n+        \/\/ Constructors\/applyPattern ensure that resultArray.length < MAX_ARGUMENT_INDEX\n@@ -1462,0 +1465,3 @@\n+    \/\/ Implementation limit for ArgumentIndex pattern element. Valid indices must\n+    \/\/ be less than this value\n+    private static final int MAX_ARGUMENT_INDEX = 10000;\n@@ -1642,0 +1648,5 @@\n+        if (argumentNumber >= MAX_ARGUMENT_INDEX) {\n+            throw new IllegalArgumentException(\n+                    argumentNumber + \" exceeds the ArgumentIndex implementation limit\");\n+        }\n+\n@@ -2009,5 +2020,19 @@\n-        in.defaultReadObject();\n-        boolean isValid = maxOffset >= -1\n-                && formats.length > maxOffset\n-                && offsets.length > maxOffset\n-                && argumentNumbers.length > maxOffset;\n+        ObjectInputStream.GetField fields = in.readFields();\n+        if (fields.defaulted(\"argumentNumbers\") || fields.defaulted(\"offsets\")\n+                || fields.defaulted(\"formats\") || fields.defaulted(\"locale\")\n+                || fields.defaulted(\"pattern\") || fields.defaulted(\"maxOffset\")){\n+            throw new InvalidObjectException(\"Stream has missing data\");\n+        }\n+\n+        locale = (Locale) fields.get(\"locale\", null);\n+        String patt = (String) fields.get(\"pattern\", null);\n+        int maxOff = fields.get(\"maxOffset\", -2);\n+        int[] argNums = ((int[]) fields.get(\"argumentNumbers\", null)).clone();\n+        int[] offs = ((int[]) fields.get(\"offsets\", null)).clone();\n+        Format[] fmts = ((Format[]) fields.get(\"formats\", null)).clone();\n+\n+        \/\/ Check arrays\/maxOffset have correct value\/length\n+        boolean isValid = maxOff >= -1 && argNums.length > maxOff\n+                && offs.length > maxOff && fmts.length > maxOff;\n+\n+        \/\/ Check the correctness of arguments and offsets\n@@ -2015,3 +2040,4 @@\n-            int lastOffset = pattern.length() + 1;\n-            for (int i = maxOffset; i >= 0; --i) {\n-                if ((offsets[i] < 0) || (offsets[i] > lastOffset)) {\n+            int lastOffset = patt.length() + 1;\n+            for (int i = maxOff; i >= 0; --i) {\n+                if (argNums[i] < 0 || argNums[i] >= MAX_ARGUMENT_INDEX\n+                        || offs[i] < 0 || offs[i] > lastOffset) {\n@@ -2021,1 +2047,1 @@\n-                    lastOffset = offsets[i];\n+                    lastOffset = offs[i];\n@@ -2025,0 +2051,1 @@\n+\n@@ -2026,1 +2053,1 @@\n-            throw new InvalidObjectException(\"Could not reconstruct MessageFormat from corrupt stream.\");\n+            throw new InvalidObjectException(\"Stream has invalid data\");\n@@ -2028,0 +2055,13 @@\n+        maxOffset = maxOff;\n+        pattern = patt;\n+        offsets = offs;\n+        formats = fmts;\n+        argumentNumbers = argNums;\n+    }\n+\n+    \/**\n+     * Serialization without data not supported for this class.\n+     *\/\n+    @java.io.Serial\n+    private void readObjectNoData() throws ObjectStreamException {\n+        throw new InvalidObjectException(\"Deserialized MessageFormat objects need data\");\n","filename":"src\/java.base\/share\/classes\/java\/text\/MessageFormat.java","additions":50,"deletions":10,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -189,1 +189,1 @@\n-     * This map contains a mapping of the IDs that is in line with TZDB 2005r and\n+     * This map contains a mapping of the IDs that is in line with TZDB 2024b and\n@@ -191,1 +191,1 @@\n-     * savings.\n+     * savings since 1970. This mapping may change in update releases in support of new versions of TZDB.\n@@ -195,3 +195,0 @@\n-     * <li>EST - -05:00<\/li>\n-     * <li>HST - -10:00<\/li>\n-     * <li>MST - -07:00<\/li>\n@@ -211,0 +208,2 @@\n+     * <li>EST - America\/Panama<\/li>\n+     * <li>HST - Pacific\/Honolulu<\/li>\n@@ -215,0 +214,1 @@\n+     * <li>MST - America\/Phoenix<\/li>\n@@ -252,3 +252,3 @@\n-        entry(\"EST\", \"-05:00\"),\n-        entry(\"MST\", \"-07:00\"),\n-        entry(\"HST\", \"-10:00\")\n+        entry(\"EST\", \"America\/Panama\"),\n+        entry(\"MST\", \"America\/Phoenix\"),\n+        entry(\"HST\", \"Pacific\/Honolulu\")\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZoneId.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,5 +103,3 @@\n-        if (key == null || algorithm == null) {\n-            throw new IllegalArgumentException(\"Missing argument\");\n-        }\n-        if (key.length == 0) {\n-            throw new IllegalArgumentException(\"Empty key\");\n+        String errMsg = doSanityCheck(key, algorithm);\n+        if (errMsg != null) {\n+            throw new IllegalArgumentException(errMsg);\n@@ -269,3 +267,3 @@\n-\n-        if (key == null || algorithm == null) {\n-            throw new InvalidObjectException(\"Missing argument\");\n+        String errMsg = doSanityCheck(key, algorithm);\n+        if (errMsg != null) {\n+            throw new InvalidObjectException(errMsg);\n@@ -273,0 +271,4 @@\n+        byte[] temp = key;\n+        this.key = temp.clone();\n+        Arrays.fill(temp, (byte) 0);\n+    }\n@@ -274,3 +276,6 @@\n-        this.key = key.clone();\n-        if (key.length == 0) {\n-            throw new InvalidObjectException(\"Invalid key length\");\n+    private static String doSanityCheck(byte[] key, String algorithm) {\n+        String errMsg = null;\n+        if (key == null || algorithm == null) {\n+            errMsg = \"Missing argument\";\n+        } else if (key.length == 0) {\n+            errMsg = \"Empty key\";\n@@ -278,0 +283,1 @@\n+        return errMsg;\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/SecretKeySpec.java","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,5 +105,7 @@\n-        if (prompt == null || prompt.isEmpty() ||\n-            choices == null || choices.length == 0 ||\n-            defaultChoice < 0 || defaultChoice >= choices.length)\n-            throw new IllegalArgumentException();\n-\n+        choices = (choices == null || choices.length == 0 ? choices :\n+                choices.clone());\n+        String errMsg = doSanityCheck(prompt, choices, defaultChoice,\n+                multipleSelectionsAllowed);\n+        if (errMsg != null) {\n+            throw new IllegalArgumentException(errMsg);\n+        }\n@@ -114,5 +116,1 @@\n-        this.choices = choices.clone();\n-        for (int i = 0; i < choices.length; i++) {\n-            if (choices[i] == null || choices[i].isEmpty())\n-                throw new IllegalArgumentException();\n-        }\n+        this.choices = choices;\n@@ -186,1 +184,1 @@\n-        if (!multipleSelectionsAllowed)\n+        if (!multipleSelectionsAllowed) {\n@@ -188,1 +186,3 @@\n-        this.selections = selections == null ? null : selections.clone();\n+        }\n+        this.selections = ((selections == null || selections.length == 0) ?\n+                selections : selections.clone());\n@@ -214,0 +214,7 @@\n+        choices = (choices == null || choices.length == 0 ?\n+                choices :  choices.clone());\n+        String errMsg = doSanityCheck(prompt, choices, defaultChoice,\n+                multipleSelectionsAllowed);\n+        if (errMsg != null) {\n+            throw new InvalidObjectException(errMsg);\n+        }\n@@ -215,0 +222,10 @@\n+        selections = (selections == null || selections.length == 0 ?\n+                selections :  selections.clone());\n+        if (selections != null && selections.length > 1 &&\n+                !multipleSelectionsAllowed) {\n+            throw new InvalidObjectException(\"Multiple selections not allowed\");\n+        }\n+    }\n+\n+    private static String doSanityCheck(String prompt, String[] choices,\n+            int defaultChoice, boolean allowMultiple) {\n@@ -218,2 +235,1 @@\n-            throw new InvalidObjectException(\n-                    \"Missing\/invalid prompt\/choices\");\n+            return \"Missing\/invalid prompt\/choices\";\n@@ -222,1 +238,0 @@\n-        choices = choices.clone();\n@@ -224,9 +239,2 @@\n-            if ((choices[i] == null) || choices[i].isEmpty())\n-                throw new InvalidObjectException(\"Null\/empty choices\");\n-        }\n-\n-        if (selections != null) {\n-            selections = selections.clone();\n-            if (!multipleSelectionsAllowed && (selections.length != 1)) {\n-                throw new InvalidObjectException(\n-                        \"Multiple selections not allowed\");\n+            if ((choices[i] == null) || choices[i].isEmpty()) {\n+                return \"Null\/empty choices value\";\n@@ -235,0 +243,1 @@\n+        return null;\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/callback\/ChoiceCallback.java","additions":34,"deletions":25,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.InvalidObjectException;\n@@ -192,19 +193,4 @@\n-\n-        if (messageType < INFORMATION || messageType > ERROR ||\n-            optionType < YES_NO_OPTION || optionType > OK_CANCEL_OPTION)\n-            throw new IllegalArgumentException();\n-\n-        switch (optionType) {\n-        case YES_NO_OPTION:\n-            if (defaultOption != YES && defaultOption != NO)\n-                throw new IllegalArgumentException();\n-            break;\n-        case YES_NO_CANCEL_OPTION:\n-            if (defaultOption != YES && defaultOption != NO &&\n-                defaultOption != CANCEL)\n-                throw new IllegalArgumentException();\n-            break;\n-        case OK_CANCEL_OPTION:\n-            if (defaultOption != OK && defaultOption != CANCEL)\n-                throw new IllegalArgumentException();\n-            break;\n+        String errMsg = doSanityCheck(messageType, optionType, false, null,\n+                defaultOption, null, false);\n+        if (errMsg != null) {\n+            throw new IllegalArgumentException(errMsg);\n@@ -253,4 +239,8 @@\n-        if (messageType < INFORMATION || messageType > ERROR ||\n-            options == null || options.length == 0 ||\n-            defaultOption < 0 || defaultOption >= options.length)\n-            throw new IllegalArgumentException();\n+        if (options != null) {\n+            options = options.clone();\n+        }\n+        String errMsg = doSanityCheck(messageType, UNSPECIFIED_OPTION, true,\n+                options, defaultOption, null, false);\n+        if (errMsg != null) {\n+            throw new IllegalArgumentException(errMsg);\n+        }\n@@ -262,6 +252,1 @@\n-\n-        this.options = options.clone();\n-        for (int i = 0; i < options.length; i++) {\n-            if (options[i] == null || options[i].isEmpty())\n-                throw new IllegalArgumentException();\n-        }\n+        this.options = options;\n@@ -307,19 +292,4 @@\n-        if (prompt == null || prompt.isEmpty() ||\n-            messageType < INFORMATION || messageType > ERROR ||\n-            optionType < YES_NO_OPTION || optionType > OK_CANCEL_OPTION)\n-            throw new IllegalArgumentException();\n-\n-        switch (optionType) {\n-        case YES_NO_OPTION:\n-            if (defaultOption != YES && defaultOption != NO)\n-                throw new IllegalArgumentException();\n-            break;\n-        case YES_NO_CANCEL_OPTION:\n-            if (defaultOption != YES && defaultOption != NO &&\n-                defaultOption != CANCEL)\n-                throw new IllegalArgumentException();\n-            break;\n-        case OK_CANCEL_OPTION:\n-            if (defaultOption != OK && defaultOption != CANCEL)\n-                throw new IllegalArgumentException();\n-            break;\n+        String errMsg = doSanityCheck(messageType, optionType, false, null,\n+                defaultOption, prompt, true);\n+        if (errMsg != null) {\n+            throw new IllegalArgumentException(errMsg);\n@@ -327,1 +297,0 @@\n-\n@@ -372,5 +341,8 @@\n-        if (prompt == null || prompt.isEmpty() ||\n-            messageType < INFORMATION || messageType > ERROR ||\n-            options == null || options.length == 0 ||\n-            defaultOption < 0 || defaultOption >= options.length)\n-            throw new IllegalArgumentException();\n+        if (options != null) {\n+            options = options.clone();\n+        }\n+        String errMsg = doSanityCheck(messageType, UNSPECIFIED_OPTION, true,\n+                options, defaultOption, prompt, true);\n+        if (errMsg != null) {\n+            throw new IllegalArgumentException(errMsg);\n+        }\n@@ -382,6 +354,1 @@\n-\n-        this.options = options.clone();\n-        for (int i = 0; i < options.length; i++) {\n-            if (options[i] == null || options[i].isEmpty())\n-                throw new IllegalArgumentException();\n-        }\n+        this.options = options;\n@@ -494,0 +461,43 @@\n+    private static String doSanityCheck(int msgType, int optionType,\n+            boolean isUnspecifiedOption, String[] options, int defOption,\n+            String prompt, boolean checkPrompt) {\n+        \/\/ validate msgType\n+        if (msgType < INFORMATION || msgType > ERROR) {\n+            return \"Invalid msgType\";\n+        }\n+        \/\/ validate prompt if checkPrompt == true\n+        if (checkPrompt && (prompt == null || prompt.isEmpty())) {\n+            return \"Invalid prompt\";\n+        }\n+        \/\/ validate optionType\n+        if (isUnspecifiedOption) {\n+            if (optionType != UNSPECIFIED_OPTION) {\n+                return \"Invalid optionType\";\n+            }\n+            \/\/ check options\n+            if (options == null || options.length == 0 ||\n+                    defOption < 0 || defOption >= options.length) {\n+                return \"Invalid options and\/or default option\";\n+            }\n+            for (String ov : options) {\n+                if (ov == null || ov.isEmpty()) {\n+                    return \"Invalid option value\";\n+                }\n+            }\n+        } else {\n+            if (optionType < YES_NO_OPTION || optionType > OK_CANCEL_OPTION) {\n+                return \"Invalid optionType\";\n+            }\n+            \/\/ validate defOption based on optionType\n+            if ((optionType == YES_NO_OPTION && (defOption != YES &&\n+                    defOption != NO)) ||\n+                    (optionType == YES_NO_CANCEL_OPTION && (defOption != YES &&\n+                    defOption != NO && defOption != CANCEL)) ||\n+                    (optionType == OK_CANCEL_OPTION && (defOption != OK &&\n+                    defOption != CANCEL))) {\n+                return \"Invalid default option\";\n+            }\n+        }\n+        return null;\n+    }\n+\n@@ -505,0 +515,1 @@\n+\n@@ -508,0 +519,6 @@\n+        String errMsg = doSanityCheck(messageType, optionType,\n+                (optionType == UNSPECIFIED_OPTION), options, defaultOption,\n+                prompt, false);\n+        if (errMsg != null) {\n+            throw new InvalidObjectException(errMsg);\n+        }\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/callback\/ConfirmationCallback.java","additions":78,"deletions":61,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,1 +181,3 @@\n-            inputPassword = inputPassword.clone();\n+            char[] temp = inputPassword;\n+            inputPassword = temp.clone();\n+            Arrays.fill(temp, '0');\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/callback\/PasswordCallback.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-        protected void writeBody(BufWriter buf, CharacterRangeTableAttribute attr) {\n+        protected void writeBody(BufWriter bufWriter, CharacterRangeTableAttribute attr) {\n@@ -145,0 +145,1 @@\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n@@ -147,4 +148,2 @@\n-                buf.writeU2(info.startPc());\n-                buf.writeU2(info.endPc());\n-                buf.writeInt(info.characterRangeStart());\n-                buf.writeInt(info.characterRangeEnd());\n+                buf.writeU2U2(info.startPc(), info.endPc());\n+                buf.writeIntInt(info.characterRangeStart(), info.characterRangeEnd());\n@@ -241,3 +240,4 @@\n-        protected void writeBody(BufWriter buf, EnclosingMethodAttribute attr) {\n-            buf.writeIndex(attr.enclosingClass());\n-            buf.writeIndexOrZero(attr.enclosingMethod().orElse(null));\n+        protected void writeBody(BufWriter bufWriter, EnclosingMethodAttribute attr) {\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n+            buf.writeU2U2(buf.cpIndex(attr.enclosingClass()),\n+                    buf.cpIndexOrZero(attr.enclosingMethod().orElse(null)));\n@@ -278,1 +278,1 @@\n-        protected void writeBody(BufWriter buf, InnerClassesAttribute attr) {\n+        protected void writeBody(BufWriter bufWriter, InnerClassesAttribute attr) {\n@@ -280,0 +280,1 @@\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n@@ -282,3 +283,3 @@\n-                buf.writeIndex(ic.innerClass());\n-                buf.writeIndexOrZero(ic.outerClass().orElse(null));\n-                buf.writeIndexOrZero(ic.innerName().orElse(null));\n+                buf.writeU2U2U2(buf.cpIndex(ic.innerClass()),\n+                        buf.cpIndexOrZero(ic.outerClass().orElse(null)),\n+                        buf.cpIndexOrZero(ic.innerName().orElse(null)));\n@@ -303,1 +304,1 @@\n-        protected void writeBody(BufWriter buf, LineNumberTableAttribute attr) {\n+        protected void writeBody(BufWriter bufWriter, LineNumberTableAttribute attr) {\n@@ -305,0 +306,1 @@\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n@@ -307,2 +309,1 @@\n-                buf.writeU2(line.startPc());\n-                buf.writeU2(line.lineNumber());\n+                buf.writeU2U2(line.startPc(), line.lineNumber());\n@@ -326,1 +327,1 @@\n-        protected void writeBody(BufWriter buf, LocalVariableTableAttribute attr) {\n+        protected void writeBody(BufWriter bufWriter, LocalVariableTableAttribute attr) {\n@@ -328,0 +329,1 @@\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n@@ -330,5 +332,2 @@\n-                buf.writeU2(info.startPc());\n-                buf.writeU2(info.length());\n-                buf.writeIndex(info.name());\n-                buf.writeIndex(info.type());\n-                buf.writeU2(info.slot());\n+                buf.writeU2U2(info.startPc(), info.length());\n+                buf.writeU2U2U2(buf.cpIndex(info.name()), buf.cpIndex(info.type()), info.slot());\n@@ -352,1 +351,1 @@\n-        protected void writeBody(BufWriter buf, LocalVariableTypeTableAttribute attr) {\n+        protected void writeBody(BufWriter bufWriter, LocalVariableTypeTableAttribute attr) {\n@@ -354,0 +353,1 @@\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n@@ -356,5 +356,2 @@\n-                buf.writeU2(info.startPc());\n-                buf.writeU2(info.length());\n-                buf.writeIndex(info.name());\n-                buf.writeIndex(info.signature());\n-                buf.writeU2(info.slot());\n+                buf.writeU2U2(info.startPc(), info.length());\n+                buf.writeU2U2U2(buf.cpIndex(info.name()), buf.cpIndex(info.signature()), info.slot());\n@@ -378,1 +375,1 @@\n-        protected void writeBody(BufWriter buf, MethodParametersAttribute attr) {\n+        protected void writeBody(BufWriter bufWriter, MethodParametersAttribute attr) {\n@@ -380,0 +377,1 @@\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n@@ -382,2 +380,2 @@\n-                buf.writeIndexOrZero(info.name().orElse(null));\n-                buf.writeU2(info.flagsMask());\n+                buf.writeU2U2(buf.cpIndexOrZero(info.name().orElse(null)),\n+                        info.flagsMask());\n@@ -401,4 +399,5 @@\n-        protected void writeBody(BufWriter buf, ModuleAttribute attr) {\n-            buf.writeIndex(attr.moduleName());\n-            buf.writeU2(attr.moduleFlagsMask());\n-            buf.writeIndexOrZero(attr.moduleVersion().orElse(null));\n+        protected void writeBody(BufWriter bufWriter, ModuleAttribute attr) {\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n+            buf.writeU2U2U2(buf.cpIndex(attr.moduleName()),\n+                    attr.moduleFlagsMask(),\n+                    buf.cpIndexOrZero(attr.moduleVersion().orElse(null)));\n@@ -407,3 +406,3 @@\n-                buf.writeIndex(require.requires());\n-                buf.writeU2(require.requiresFlagsMask());\n-                buf.writeIndexOrZero(require.requiresVersion().orElse(null));\n+                buf.writeU2U2U2(buf.cpIndex(require.requires()),\n+                        require.requiresFlagsMask(),\n+                        buf.cpIndexOrZero(require.requiresVersion().orElse(null)));\n@@ -413,2 +412,2 @@\n-                buf.writeIndex(export.exportedPackage());\n-                buf.writeU2(export.exportsFlagsMask());\n+                buf.writeU2U2(buf.cpIndex(export.exportedPackage()),\n+                        export.exportsFlagsMask());\n@@ -419,2 +418,2 @@\n-                buf.writeIndex(open.openedPackage());\n-                buf.writeU2(open.opensFlagsMask());\n+                buf.writeU2U2(buf.cpIndex(open.openedPackage()),\n+                        open.opensFlagsMask());\n@@ -445,2 +444,1 @@\n-        protected void writeBody(BufWriter buf, ModuleHashesAttribute attr) {\n-            buf.writeIndex(attr.algorithm());\n+        protected void writeBody(BufWriter bufWriter, ModuleHashesAttribute attr) {\n@@ -448,1 +446,2 @@\n-            buf.writeU2(hashes.size());\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n+            buf.writeU2U2(buf.cpIndex(attr.algorithm()), hashes.size());\n@@ -450,2 +449,2 @@\n-                buf.writeIndex(hash.moduleName());\n-                buf.writeU2(hash.hash().length);\n+                buf.writeU2U2(buf.cpIndex(hash.moduleName()),\n+                        hash.hash().length);\n@@ -596,1 +595,1 @@\n-        protected void writeBody(BufWriter buf, RecordAttribute attr) {\n+        protected void writeBody(BufWriter bufWriter, RecordAttribute attr) {\n@@ -598,0 +597,1 @@\n+            BufWriterImpl buf = (BufWriterImpl) bufWriter;\n@@ -600,3 +600,3 @@\n-                buf.writeIndex(info.name());\n-                buf.writeIndex(info.descriptor());\n-                Util.writeAttributes((BufWriterImpl) buf, info.attributes());\n+                buf.writeU2U2(buf.cpIndex(info.name()),\n+                        buf.cpIndex(info.descriptor()));\n+                Util.writeAttributes(buf, info.attributes());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper.java","additions":50,"deletions":50,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -91,2 +91,1 @@\n-        b.writeU2(startBci);\n-        b.writeU2(length);\n+        b.writeU2U2(startBci, length);\n@@ -94,2 +93,1 @@\n-            b.writeU2(nameIndex());\n-            b.writeU2(secondaryIndex());\n+            b.writeU2U2(nameIndex(), secondaryIndex());\n@@ -98,2 +96,1 @@\n-            b.writeIndex(name());\n-            b.writeIndex(secondaryEntry());\n+            b.writeU2U2(b.cpIndex(name()), b.cpIndex(secondaryEntry()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractBoundLocalVariable.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -250,0 +252,3 @@\n+        public SwitchCaseImpl {\n+            requireNonNull(target);\n+        }\n@@ -895,1 +900,1 @@\n-            this.target = target;\n+            this.target = requireNonNull(target);\n@@ -922,1 +927,1 @@\n-            this.defaultTarget = defaultTarget;\n+            this.defaultTarget = requireNonNull(defaultTarget);\n@@ -958,1 +963,1 @@\n-            this.defaultTarget = defaultTarget;\n+            this.defaultTarget = requireNonNull(defaultTarget);\n@@ -1033,1 +1038,1 @@\n-            this.fieldEntry = fieldEntry;\n+            this.fieldEntry = requireNonNull(fieldEntry);\n@@ -1058,1 +1063,1 @@\n-            this.methodEntry = methodEntry;\n+            this.methodEntry = requireNonNull(methodEntry);\n@@ -1098,1 +1103,1 @@\n-            this.indyEntry = indyEntry;\n+            this.indyEntry = requireNonNull(indyEntry);\n@@ -1123,1 +1128,1 @@\n-            this.classEntry = classEntry;\n+            this.classEntry = requireNonNull(classEntry);\n@@ -1148,1 +1153,1 @@\n-            this.typeKind = typeKind;\n+            this.typeKind = requireNonNull(typeKind);\n@@ -1173,1 +1178,1 @@\n-            this.componentTypeEntry = componentTypeEntry;\n+            this.componentTypeEntry = requireNonNull(componentTypeEntry);\n@@ -1200,1 +1205,1 @@\n-            this.arrayTypeEntry = arrayTypeEntry;\n+            this.arrayTypeEntry = requireNonNull(arrayTypeEntry);\n@@ -1258,1 +1263,1 @@\n-            this.typeEntry = typeEntry;\n+            this.typeEntry = requireNonNull(typeEntry);\n@@ -1360,1 +1365,1 @@\n-            this.constant = constant;\n+            this.constant = requireNonNull(constant);\n@@ -1408,1 +1413,1 @@\n-            this.target = target;\n+            this.target = requireNonNull(target);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -442,1 +444,1 @@\n-                    return stringValue.equals(s);\n+                    return stringValue.equals(requireNonNull(s));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -58,3 +60,3 @@\n-            this.handler = handler;\n-            this.tryStart = tryStart;\n-            this.tryEnd = tryEnd;\n+            this.handler = requireNonNull(handler);\n+            this.tryStart = requireNonNull(tryStart);\n+            this.tryEnd = requireNonNull(tryEnd);\n@@ -65,4 +67,1 @@\n-            this.catchTypeEntry = catchTypeEntry.orElse(null);\n-            this.handler = handler;\n-            this.tryStart = tryStart;\n-            this.tryEnd = tryEnd;\n+            this(handler, tryStart, tryEnd, catchTypeEntry.orElse(null));\n@@ -118,2 +117,2 @@\n-            this.startScope = startScope;\n-            this.endScope = endScope;\n+            this.startScope = requireNonNull(startScope);\n+            this.endScope = requireNonNull(endScope);\n@@ -168,4 +167,4 @@\n-            this.name = name;\n-            this.descriptor = descriptor;\n-            this.startScope = startScope;\n-            this.endScope = endScope;\n+            this.name = requireNonNull(name);\n+            this.descriptor = requireNonNull(descriptor);\n+            this.startScope = requireNonNull(startScope);\n+            this.endScope = requireNonNull(endScope);\n@@ -203,5 +202,2 @@\n-            b.writeU2(startBci);\n-            b.writeU2(length);\n-            b.writeIndex(name);\n-            b.writeIndex(descriptor);\n-            b.writeU2(slot());\n+            b.writeU2U2(startBci, length);\n+            b.writeU2U2U2(b.cpIndex(name), b.cpIndex(descriptor), slot());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPseudoInstruction.java","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -35,0 +37,1 @@\n+        requireNonNull(className);\n@@ -53,0 +56,5 @@\n+        public AnnotationElementImpl {\n+            requireNonNull(name);\n+            requireNonNull(value);\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationImpl.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -285,1 +285,0 @@\n-        buf.writeIndex(annotation.className());\n@@ -287,1 +286,1 @@\n-        buf.writeU2(elements.size());\n+        buf.writeU2U2(buf.cpIndex(annotation.className()), elements.size());\n@@ -335,2 +334,2 @@\n-                buf.writeU2(labelToBci(lr, tat.target(), ta));\n-                buf.writeU1(tat.typeArgumentIndex());\n+                buf.writeU2U1(labelToBci(lr, tat.target(), ta),\n+                        tat.typeArgumentIndex());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationReader.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -83,1 +85,1 @@\n-        parent.with(element);\n+        parent.with(requireNonNull(element));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BlockCodeBuilderImpl.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -171,0 +171,10 @@\n+    public void writeU2U1(int x1, int x2) {\n+        reserveSpace(3);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x1 >> 8);\n+        elems[offset + 1] = (byte) x1;\n+        elems[offset + 2] = (byte) x2;\n+        this.offset = offset + 3;\n+    }\n+\n@@ -207,0 +217,15 @@\n+    public void writeIntInt(int x1, int x2) {\n+        reserveSpace(8);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x1 >> 24);\n+        elems[offset + 1] = (byte) (x1 >> 16);\n+        elems[offset + 2] = (byte) (x1 >> 8);\n+        elems[offset + 3] = (byte)  x1;\n+        elems[offset + 4] = (byte) (x2 >> 24);\n+        elems[offset + 5] = (byte) (x2 >> 16);\n+        elems[offset + 6] = (byte) (x2 >> 8);\n+        elems[offset + 7] = (byte)  x2;\n+        this.offset = offset + 8;\n+    }\n+\n@@ -358,0 +383,6 @@\n+    public int cpIndexOrZero(PoolEntry entry) {\n+        if (entry == null || entry.index() == 0)\n+            return 0;\n+        return cpIndex(entry);\n+    }\n+\n@@ -374,4 +405,1 @@\n-        if (entry == null || entry.index() == 0)\n-            writeU2(0);\n-        else\n-            writeIndex(entry);\n+        writeU2(cpIndexOrZero(entry));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":32,"deletions":4,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -124,1 +126,1 @@\n-        elements.add(element);\n+        elements.add(requireNonNull(element));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedCodeBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -52,2 +54,2 @@\n-        this.name = name;\n-        this.desc = type;\n+        this.name = requireNonNull(name);\n+        this.desc = requireNonNull(type);\n@@ -64,1 +66,1 @@\n-        elements.add(element);\n+        elements.add(requireNonNull(element));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedFieldBuilder.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -66,2 +68,2 @@\n-        this.name = nameInfo;\n-        this.desc = typeInfo;\n+        this.name = requireNonNull(nameInfo);\n+        this.desc = requireNonNull(typeInfo);\n@@ -74,1 +76,1 @@\n-        elements.add(element);\n+        elements.add(requireNonNull(element));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedMethodBuilder.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -466,1 +467,1 @@\n-        Objects.requireNonNull(opcode);\n+        requireNonNull(opcode);\n@@ -554,1 +555,1 @@\n-        throw new UnsupportedOperationException(\"not yet: \" + constantValue);\n+        throw new UnsupportedOperationException(\"not yet: \" + requireNonNull(constantValue));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -50,1 +52,1 @@\n-        consumer.accept(element);\n+        consumer.accept(requireNonNull(element));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedClassBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -62,1 +64,1 @@\n-        consumer.accept(element);\n+        consumer.accept(requireNonNull(element));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedCodeBuilder.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -53,1 +55,1 @@\n-        consumer.accept(element);\n+        consumer.accept(requireNonNull(element));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedFieldBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -51,1 +53,1 @@\n-        consumer.accept(element);\n+        consumer.accept(requireNonNull(element));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedMethodBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -126,1 +128,1 @@\n-                throw new IllegalArgumentException(\"Invalid option: \" + o);\n+                throw new IllegalArgumentException(\"Invalid option: \" + requireNonNull(o));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassFileImpl.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-                map.put(e.getKey(), ClassHierarchyInfo.ofClass(e.getValue()));\n+                map.put(requireNonNull(e.getKey()), ClassHierarchyInfo.ofClass(e.getValue()));\n@@ -210,1 +210,1 @@\n-                map.put(i, ClassHierarchyInfo.ofInterface());\n+                map.put(requireNonNull(i), ClassHierarchyInfo.ofInterface());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -567,0 +568,1 @@\n+        requireNonNull(verbosity); \/\/ we are using == checks in implementations\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.constant.ClassDesc;\n@@ -31,3 +30,0 @@\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.reflect.AccessFlag;\n-import java.util.ArrayList;\n@@ -53,0 +49,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -90,1 +88,1 @@\n-            writeAttribute((CustomAttribute<?>) element);\n+            writeAttribute((CustomAttribute<?>) requireNonNull(element));\n@@ -222,3 +220,2 @@\n-        head.writeLong((((long) ClassFile.MAGIC_NUMBER) << 32)\n-                | ((minorVersion & 0xFFFFL) << 16)\n-                | (majorVersion & 0xFFFFL));\n+        head.writeInt(ClassFile.MAGIC_NUMBER);\n+        head.writeU2U2(minorVersion, majorVersion);\n@@ -226,2 +223,1 @@\n-        head.writeU2U2(flags, head.cpIndex(thisClassEntry));\n-        head.writeIndexOrZero(superclass);\n+        head.writeU2U2U2(flags, head.cpIndex(thisClassEntry), head.cpIndexOrZero(superclass));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -150,1 +151,1 @@\n-            writeAttribute((CustomAttribute<?>) element);\n+            writeAttribute((CustomAttribute<?>) requireNonNull(element));\n@@ -260,2 +261,1 @@\n-                                b.writeInt(cr.characterRangeStart());\n-                                b.writeInt(cr.characterRangeEnd());\n+                                b.writeIntInt(cr.characterRangeStart(), cr.characterRangeEnd());\n@@ -377,0 +377,1 @@\n+                boolean codeMatch = dcb.original != null && codeAndExceptionsMatch(codeLength);\n@@ -378,2 +379,2 @@\n-                if (dcb.original != null && codeAndExceptionsMatch(codeLength)) {\n-                    if (context.stackMapsWhenRequired()) {\n+                if (context.stackMapsWhenRequired()) {\n+                    if (codeMatch) {\n@@ -382,7 +383,1 @@\n-                    } else if (context.generateStackMaps()) {\n-                        generateStackMaps(buf);\n-                    } else if (context.dropStackMaps()) {\n-                        writeCounters(true, buf);\n-                    }\n-                } else {\n-                    if (context.stackMapsWhenRequired()) {\n+                    } else {\n@@ -390,4 +385,0 @@\n-                    } else if (context.generateStackMaps()) {\n-                        generateStackMaps(buf);\n-                    } else if (context.dropStackMaps()) {\n-                        writeCounters(false, buf);\n@@ -395,0 +386,4 @@\n+                } else if (context.generateStackMaps()) {\n+                    generateStackMaps(buf);\n+                } else if (context.dropStackMaps()) {\n+                    writeCounters(codeMatch, buf);\n@@ -643,2 +638,1 @@\n-        bytecodesBufWriter.writeInt(low);\n-        bytecodesBufWriter.writeInt(high);\n+        bytecodesBufWriter.writeIntInt(low, high);\n@@ -671,2 +665,1 @@\n-        bytecodesBufWriter.writeIndex(INVOKEDYNAMIC, ref);\n-        bytecodesBufWriter.writeU2(0);\n+        bytecodesBufWriter.writeU1U2U2(INVOKEDYNAMIC, bytecodesBufWriter.cpIndex(ref), 0);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -51,2 +53,2 @@\n-        this.name = name;\n-        this.desc = type;\n+        this.name = requireNonNull(name);\n+        this.desc = requireNonNull(type);\n@@ -61,1 +63,1 @@\n-            writeAttribute((CustomAttribute<?>) element);\n+            writeAttribute((CustomAttribute<?>) requireNonNull(element));\n@@ -83,3 +85,1 @@\n-        buf.writeU2(flags);\n-        buf.writeIndex(name);\n-        buf.writeIndex(desc);\n+        buf.writeU2U2U2(flags, buf.cpIndex(name), buf.cpIndex(desc));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectFieldBuilder.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -58,2 +60,2 @@\n-        this.name = nameInfo;\n-        this.desc = typeInfo;\n+        this.name = requireNonNull(nameInfo);\n+        this.desc = requireNonNull(typeInfo);\n@@ -117,1 +119,1 @@\n-            writeAttribute((CustomAttribute<?>) element);\n+            writeAttribute((CustomAttribute<?>) requireNonNull(element));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectMethodBuilder.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -87,3 +87,3 @@\n-            buf.writeU2(flags().flagsMask());\n-            buf.writeIndex(fieldName());\n-            buf.writeIndex(fieldType());\n+            buf.writeU2U2U2(flags().flagsMask(),\n+                    buf.cpIndex(fieldName()),\n+                    buf.cpIndex(fieldType()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/FieldImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -106,3 +106,3 @@\n-            buf.writeU2(flags().flagsMask());\n-            buf.writeIndex(methodName());\n-            buf.writeIndex(methodType());\n+            buf.writeU2U2U2(flags().flagsMask(),\n+                    buf.cpIndex(methodName()),\n+                    buf.cpIndex(methodType()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/MethodImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -125,0 +126,1 @@\n+        requireNonNull(other);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -138,2 +139,1 @@\n-                    out.writeU1(251 + diffLocalsSize);\n-                    out.writeU2(offsetDelta);\n+                    out.writeU1U2(251 + diffLocalsSize, offsetDelta);\n@@ -148,2 +148,1 @@\n-                out.writeU1(247);\n-                out.writeU2(offsetDelta);\n+                out.writeU1U2(247, offsetDelta);\n@@ -155,3 +154,1 @@\n-        out.writeU1(255);\n-        out.writeU2(offsetDelta);\n-        out.writeU2(fr.locals().size());\n+        out.writeU1U2U2(255, offsetDelta, fr.locals().size());\n@@ -171,2 +168,2 @@\n-        bw.writeU1(vti.tag());\n-        switch (vti.tag()) {\n+        int tag = vti.tag();\n+        switch (tag) {\n@@ -175,1 +172,1 @@\n-                {}\n+                bw.writeU1(tag);\n@@ -177,1 +174,1 @@\n-                bw.writeIndex(((ObjectVerificationTypeInfo)vti).className());\n+                bw.writeU1U2(tag, bw.cpIndex(((ObjectVerificationTypeInfo)vti).className()));\n@@ -179,1 +176,1 @@\n-                bw.writeU2(bw.labelContext().labelToBci(((UninitializedVerificationTypeInfo)vti).newTarget()));\n+                bw.writeU1U2(tag, bw.labelContext().labelToBci(((UninitializedVerificationTypeInfo)vti).newTarget()));\n@@ -252,0 +249,3 @@\n+        public ObjectVerificationTypeInfoImpl {\n+            requireNonNull(className);\n+        }\n@@ -277,0 +277,3 @@\n+        public UninitializedVerificationTypeInfoImpl {\n+            requireNonNull(newTarget);\n+        }\n@@ -299,0 +302,1 @@\n+            requireNonNull(target);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import jdk.internal.constant.PrimitiveClassDescImpl;\n@@ -352,0 +353,1 @@\n+            var labelContext = this.labelContext;\n@@ -393,3 +395,4 @@\n-                b.writeU2(framesCount);\n-                Frame prevFrame =  new Frame(classHierarchy);\n-                prevFrame.setLocalsFromArg(methodName, methodDesc, isStatic, thisType);\n+                var gen = StackMapGenerator.this;\n+                b.writeU2(gen.framesCount);\n+                Frame prevFrame = gen.new Frame(gen.classHierarchy);\n+                prevFrame.setLocalsFromArg(gen.methodName, gen.methodDesc, gen.isStatic, gen.thisType);\n@@ -397,2 +400,2 @@\n-                for (int i = 0; i < framesCount; i++) {\n-                    var fr = frames[i];\n+                for (int i = 0; i < gen.framesCount; i++) {\n+                    var fr = gen.frames[i];\n@@ -400,1 +403,1 @@\n-                    fr.writeTo(b, prevFrame, cp);\n+                    fr.writeTo(b, prevFrame, gen.cp);\n@@ -463,0 +466,1 @@\n+        var currentFrame = this.currentFrame;\n@@ -503,1 +507,1 @@\n-                currentFrame.decStack(2).pushStack(Type.INTEGER_TYPE);\n+                currentFrame.decStack2PushStack(Type.INTEGER_TYPE);\n@@ -505,1 +509,1 @@\n-                currentFrame.decStack(2).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+                currentFrame.decStack2PushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n@@ -507,1 +511,1 @@\n-                currentFrame.decStack(2).pushStack(Type.FLOAT_TYPE);\n+                currentFrame.decStack2PushStack(Type.FLOAT_TYPE);\n@@ -509,1 +513,1 @@\n-                currentFrame.decStack(2).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+                currentFrame.decStack2PushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n@@ -511,1 +515,1 @@\n-                currentFrame.pushStack((type1 = currentFrame.decStack(1).popStack()) == Type.NULL_TYPE ? Type.NULL_TYPE : type1.getComponent());\n+                currentFrame.pushStack((type1 = currentFrame.decStack().popStack()) == Type.NULL_TYPE ? Type.NULL_TYPE : type1.getComponent());\n@@ -513,1 +517,1 @@\n-                currentFrame.decStack(1).setLocal(bcs.getIndex(), Type.INTEGER_TYPE);\n+                currentFrame.decStack().setLocal(bcs.getIndex(), Type.INTEGER_TYPE);\n@@ -515,1 +519,1 @@\n-                currentFrame.decStack(1).setLocal(opcode - ISTORE_0, Type.INTEGER_TYPE);\n+                currentFrame.decStack().setLocal(opcode - ISTORE_0, Type.INTEGER_TYPE);\n@@ -521,1 +525,1 @@\n-                currentFrame.decStack(1).setLocal(bcs.getIndex(), Type.FLOAT_TYPE);\n+                currentFrame.decStack().setLocal(bcs.getIndex(), Type.FLOAT_TYPE);\n@@ -523,1 +527,1 @@\n-                currentFrame.decStack(1).setLocal(opcode - FSTORE_0, Type.FLOAT_TYPE);\n+                currentFrame.decStack().setLocal(opcode - FSTORE_0, Type.FLOAT_TYPE);\n@@ -537,1 +541,1 @@\n-                currentFrame.decStack(1);\n+                currentFrame.decStack();\n@@ -541,36 +545,13 @@\n-                currentFrame.pushStack(type1 = currentFrame.popStack()).pushStack(type1);\n-            case DUP_X1 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                currentFrame.pushStack(type1).pushStack(type2).pushStack(type1);\n-            }\n-            case DUP_X2 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                type3 = currentFrame.popStack();\n-                currentFrame.pushStack(type1).pushStack(type3).pushStack(type2).pushStack(type1);\n-            }\n-            case DUP2 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                currentFrame.pushStack(type2).pushStack(type1).pushStack(type2).pushStack(type1);\n-            }\n-            case DUP2_X1 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                type3 = currentFrame.popStack();\n-                currentFrame.pushStack(type2).pushStack(type1).pushStack(type3).pushStack(type2).pushStack(type1);\n-            }\n-            case DUP2_X2 -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                type3 = currentFrame.popStack();\n-                type4 = currentFrame.popStack();\n-                currentFrame.pushStack(type2).pushStack(type1).pushStack(type4).pushStack(type3).pushStack(type2).pushStack(type1);\n-            }\n-            case SWAP -> {\n-                type1 = currentFrame.popStack();\n-                type2 = currentFrame.popStack();\n-                currentFrame.pushStack(type1);\n-                currentFrame.pushStack(type2);\n-            }\n+                currentFrame.dup();\n+            case DUP_X1 ->\n+                currentFrame.dup_x1();\n+            case DUP_X2 ->\n+                currentFrame.dup_x2();\n+            case DUP2 ->\n+                currentFrame.dup2();\n+            case DUP2_X1 ->\n+                currentFrame.dup2_x1();\n+            case DUP2_X2 ->\n+                currentFrame.dup2_x2();\n+            case SWAP ->\n+                currentFrame.swap();\n@@ -578,1 +559,1 @@\n-                currentFrame.decStack(2).pushStack(Type.INTEGER_TYPE);\n+                currentFrame.decStack2PushStack(Type.INTEGER_TYPE);\n@@ -580,1 +561,1 @@\n-                currentFrame.decStack(1).pushStack(Type.INTEGER_TYPE);\n+                currentFrame.decStack1PushStack(Type.INTEGER_TYPE);\n@@ -582,1 +563,1 @@\n-                currentFrame.decStack(4).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+                currentFrame.decStack4PushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n@@ -584,1 +565,1 @@\n-                currentFrame.decStack(2).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+                currentFrame.decStack2PushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n@@ -586,1 +567,1 @@\n-                currentFrame.decStack(3).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+                currentFrame.decStack3PushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n@@ -588,1 +569,1 @@\n-                currentFrame.decStack(2).pushStack(Type.FLOAT_TYPE);\n+                currentFrame.decStack2PushStack(Type.FLOAT_TYPE);\n@@ -590,1 +571,1 @@\n-                currentFrame.decStack(1).pushStack(Type.FLOAT_TYPE);\n+                currentFrame.decStack1PushStack(Type.FLOAT_TYPE);\n@@ -592,1 +573,1 @@\n-                currentFrame.decStack(4).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+                currentFrame.decStack4PushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n@@ -594,1 +575,1 @@\n-                currentFrame.decStack(2).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+                currentFrame.decStack2PushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n@@ -598,1 +579,1 @@\n-                currentFrame.decStack(1).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+                currentFrame.decStack1PushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n@@ -600,1 +581,1 @@\n-                currentFrame.decStack(2).pushStack(Type.INTEGER_TYPE);\n+                currentFrame.decStack2PushStack(Type.INTEGER_TYPE);\n@@ -602,1 +583,1 @@\n-                currentFrame.decStack(1).pushStack(Type.FLOAT_TYPE);\n+                currentFrame.decStack1PushStack(Type.FLOAT_TYPE);\n@@ -604,1 +585,1 @@\n-                currentFrame.decStack(1).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+                currentFrame.decStack1PushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n@@ -606,1 +587,1 @@\n-                currentFrame.decStack(2).pushStack(Type.FLOAT_TYPE);\n+                currentFrame.decStack2PushStack(Type.FLOAT_TYPE);\n@@ -608,1 +589,1 @@\n-                currentFrame.decStack(2).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+                currentFrame.decStack2PushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n@@ -610,1 +591,1 @@\n-                currentFrame.decStack(1).pushStack(Type.INTEGER_TYPE);\n+                currentFrame.decStack1PushStack(Type.INTEGER_TYPE);\n@@ -612,1 +593,1 @@\n-                currentFrame.decStack(1).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+                currentFrame.decStack1PushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n@@ -614,1 +595,1 @@\n-                currentFrame.decStack(1).pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+                currentFrame.decStack1PushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n@@ -616,1 +597,1 @@\n-                currentFrame.decStack(2).pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+                currentFrame.decStack2PushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n@@ -618,1 +599,1 @@\n-                currentFrame.decStack(2).pushStack(Type.FLOAT_TYPE);\n+                currentFrame.decStack2PushStack(Type.FLOAT_TYPE);\n@@ -620,1 +601,1 @@\n-                currentFrame.decStack(1).pushStack(Type.INTEGER_TYPE);\n+                currentFrame.decStack1PushStack(Type.INTEGER_TYPE);\n@@ -622,1 +603,1 @@\n-                currentFrame.decStack(4).pushStack(Type.INTEGER_TYPE);\n+                currentFrame.decStack4PushStack(Type.INTEGER_TYPE);\n@@ -624,1 +605,1 @@\n-                currentFrame.decStack(2).pushStack(Type.INTEGER_TYPE);\n+                currentFrame.decStack2PushStack(Type.INTEGER_TYPE);\n@@ -628,1 +609,1 @@\n-                checkJumpTarget(currentFrame.decStack(1), bcs.dest());\n+                checkJumpTarget(currentFrame.decStack(), bcs.dest());\n@@ -646,1 +627,1 @@\n-                currentFrame.decStack(1);\n+                currentFrame.decStack();\n@@ -656,1 +637,1 @@\n-                currentFrame.decStack(1).pushStack(getNewarrayType(bcs.getIndex()));\n+                currentFrame.decStack1PushStack(getNewarrayType(bcs.getIndex()));\n@@ -660,1 +641,1 @@\n-                currentFrame.decStack(1).pushStack(cpIndexToType(bcs.getIndexU2(), cp));\n+                currentFrame.decStack1PushStack(cpIndexToType(bcs.getIndexU2(), cp));\n@@ -663,4 +644,3 @@\n-                int dim = bcs.getU1Unchecked(bcs.bci() + 3);\n-                for (int i = 0; i < dim; i++) {\n-                    currentFrame.popStack();\n-                }\n+                currentFrame.decStack(\n+                        bcs.getU1Unchecked(bcs.bci() + 3) \/* dim *\/\n+                );\n@@ -681,0 +661,1 @@\n+        var currentFrame = this.currentFrame;\n@@ -693,1 +674,4 @@\n-        switch (cp.entryByIndex(index).tag()) {\n+        var e = cp.entryByIndex(index);\n+        byte tag = e.tag();\n+        var currentFrame = this.currentFrame;\n+        switch (tag) {\n@@ -713,1 +697,1 @@\n-                currentFrame.pushStack(cp.entryByIndex(index, ConstantDynamicEntry.class).asSymbol().constantType());\n+                currentFrame.pushStack(ClassReaderImpl.checkType(e, index, ConstantDynamicEntry.class).asSymbol().constantType());\n@@ -715,1 +699,1 @@\n-                throw generatorError(\"CP entry #%d %s is not loadable constant\".formatted(index, cp.entryByIndex(index).tag()));\n+                throw generatorError(\"CP entry #%d %s is not loadable constant\".formatted(index, tag));\n@@ -724,1 +708,1 @@\n-        currentFrame.popStack();\n+        currentFrame.decStack();\n@@ -768,2 +752,1 @@\n-                currentFrame.decStack(1);\n-                currentFrame.pushStack(desc);\n+                currentFrame.dec1PushStack(desc);\n@@ -807,1 +790,1 @@\n-                currentFrame.decStack(1);\n+                currentFrame.decStack();\n@@ -820,1 +803,1 @@\n-        currentFrame.popStack();\n+        currentFrame.decStack();\n@@ -824,0 +807,7 @@\n+    \/**\n+     * {@return the generator error with stack underflow}\n+     *\/\n+    private IllegalArgumentException stackUnderflow() {\n+        return generatorError(\"Operand stack underflow\");\n+    }\n+\n@@ -903,0 +893,1 @@\n+\n@@ -971,0 +962,95 @@\n+        Frame dup() {\n+            int stackSize = this.stackSize;\n+            if (stackSize < 1) throw stackUnderflow();\n+            checkStack(stackSize + 1);\n+            stack[stackSize] = stack[stackSize - 1];\n+            this.stackSize = stackSize + 1;\n+            return this;\n+        }\n+\n+        Frame dup_x1() {\n+            int stackSize = this.stackSize;\n+            if (stackSize < 2) throw stackUnderflow();\n+            checkStack(stackSize + 1);\n+            var stack = this.stack;\n+            Type type0 = stack[stackSize - 2];\n+            Type type1 = stack[stackSize - 1];\n+            stack[stackSize - 2] = type1;\n+            stack[stackSize - 1] = type0;\n+            stack[stackSize    ] = type1;\n+            this.stackSize = stackSize + 1;\n+            return this;\n+        }\n+\n+        Frame dup_x2() {\n+            int stackSize = this.stackSize;\n+            if (stackSize < 3) throw stackUnderflow();\n+            checkStack(stackSize + 1);\n+            var stack = this.stack;\n+            Type type0 = stack[stackSize - 3];\n+            Type type1 = stack[stackSize - 2];\n+            Type type2 = stack[stackSize - 1];\n+            stack[stackSize - 3] = type2;\n+            stack[stackSize - 2] = type0;\n+            stack[stackSize - 1] = type1;\n+            stack[stackSize    ] = type2;\n+            this.stackSize = stackSize + 1;\n+            return this;\n+        }\n+\n+        Frame dup2() {\n+            int stackSize = this.stackSize;\n+            if (stackSize < 2) throw stackUnderflow();\n+            checkStack(stackSize + 2);\n+            stack[stackSize    ] = stack[stackSize - 2];\n+            stack[stackSize + 1] = stack[stackSize - 1];\n+            this.stackSize = stackSize + 2;\n+            return this;\n+        }\n+\n+        Frame dup2_x1() {\n+            int stackSize = this.stackSize;\n+            if (stackSize < 3) throw stackUnderflow();\n+            checkStack(stackSize + 2);\n+            var stack = this.stack;\n+            Type type0 = stack[stackSize - 3];\n+            Type type1 = stack[stackSize - 2];\n+            Type type2 = stack[stackSize - 1];\n+            stack[stackSize - 3] = type1;\n+            stack[stackSize - 2] = type2;\n+            stack[stackSize - 1] = type0;\n+            stack[stackSize    ] = type1;\n+            stack[stackSize + 1] = type2;\n+            this.stackSize = stackSize + 2;\n+            return this;\n+        }\n+\n+        Frame dup2_x2() {\n+            int stackSize = this.stackSize;\n+            if (stackSize < 4) throw stackUnderflow();\n+            checkStack(stackSize + 2);\n+            var stack = this.stack;\n+            Type type0 = stack[stackSize - 4];\n+            Type type1 = stack[stackSize - 3];\n+            Type type2 = stack[stackSize - 2];\n+            Type type3 = stack[stackSize - 1];\n+            stack[stackSize - 4] = type2;\n+            stack[stackSize - 3] = type3;\n+            stack[stackSize - 2] = type0;\n+            stack[stackSize - 1] = type1;\n+            stack[stackSize    ] = type2;\n+            stack[stackSize + 1] = type3;\n+            this.stackSize = stackSize + 4;\n+            return this;\n+        }\n+\n+        Frame swap() {\n+            int stackSize = this.stackSize - 2;\n+            if (stackSize < 0) throw stackUnderflow();\n+            var stack = this.stack;\n+            Type type = stack[stackSize];\n+            stack[stackSize] = stack[stackSize + 1];\n+            stack[stackSize + 1] = type;\n+            return this;\n+        }\n+\n@@ -972,14 +1058,17 @@\n-            return switch (desc.descriptorString().charAt(0)) {\n-                case 'J' ->\n-                    pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n-                case 'D' ->\n-                    pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n-                case 'I', 'Z', 'B', 'C', 'S' ->\n-                    pushStack(Type.INTEGER_TYPE);\n-                case 'F' ->\n-                    pushStack(Type.FLOAT_TYPE);\n-                case 'V' ->\n-                    this;\n-                default ->\n-                    pushStack(Type.referenceType(desc));\n-            };\n+            if (desc == CD_long)   return pushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+            if (desc == CD_double) return pushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+            return desc == CD_void ? this\n+                    : pushStack(\n+                    desc instanceof PrimitiveClassDescImpl\n+                            ? (desc == CD_float ? Type.FLOAT_TYPE : Type.INTEGER_TYPE)\n+                            : Type.referenceType(desc));\n+        }\n+\n+        Frame dec1PushStack(ClassDesc desc) {\n+            if (desc == CD_long)   return decStack1PushStack(Type.LONG_TYPE, Type.LONG2_TYPE);\n+            if (desc == CD_double) return decStack1PushStack(Type.DOUBLE_TYPE, Type.DOUBLE2_TYPE);\n+            return desc == CD_void ? this\n+                    : decStack1PushStack(\n+                    desc instanceof PrimitiveClassDescImpl\n+                            ? (desc == CD_float ? Type.FLOAT_TYPE : Type.INTEGER_TYPE)\n+                            : Type.referenceType(desc));\n@@ -989,0 +1078,1 @@\n+            int stackSize = this.stackSize;\n@@ -990,1 +1080,2 @@\n-            stack[stackSize++] = type;\n+            stack[stackSize] = type;\n+            this.stackSize = stackSize + 1;\n@@ -995,0 +1086,1 @@\n+            int stackSize = this.stackSize;\n@@ -996,2 +1088,3 @@\n-            stack[stackSize++] = type1;\n-            stack[stackSize++] = type2;\n+            stack[stackSize] = type1;\n+            stack[stackSize + 1] = type2;\n+            this.stackSize = stackSize + 2;\n@@ -1002,2 +1095,9 @@\n-            if (stackSize < 1) throw generatorError(\"Operand stack underflow\");\n-            return stack[--stackSize];\n+            int stackSize = this.stackSize - 1;\n+            if (stackSize < 0) throw stackUnderflow();\n+            this.stackSize = stackSize;\n+            return stack[stackSize];\n+        }\n+\n+        Frame decStack() {\n+            if (--stackSize < 0) throw stackUnderflow();\n+            return this;\n@@ -1008,1 +1108,62 @@\n-            if (stackSize < 0) throw generatorError(\"Operand stack underflow\");\n+            if (stackSize < 0) throw stackUnderflow();\n+            return this;\n+        }\n+\n+        Frame decStack1PushStack(Type type1, Type type2) {\n+            int stackSize = this.stackSize - 1;\n+            if (stackSize < 0) throw stackUnderflow();\n+            checkStack(stackSize + 2);\n+            stack[stackSize    ] = type1;\n+            stack[stackSize + 1] = type2;\n+            this.stackSize = stackSize + 2;\n+            return this;\n+        }\n+\n+        Frame decStack1PushStack(Type type) {\n+            int stackSize = this.stackSize - 1;\n+            if (stackSize < 0) throw stackUnderflow();\n+            stack[stackSize] = type;\n+            return this;\n+        }\n+\n+        Frame decStack2PushStack(Type type) {\n+            int stackSize = this.stackSize - 2;\n+            if (stackSize < 0) throw stackUnderflow();\n+            stack[stackSize] = type;\n+            this.stackSize = stackSize + 1;\n+            return this;\n+        }\n+\n+        Frame decStack2PushStack(Type type1, Type type2) {\n+            int stackSize = this.stackSize - 2;\n+            if (stackSize < 0) throw stackUnderflow();\n+            var stack = this.stack;\n+            stack[stackSize   ] = type1;\n+            stack[stackSize + 1] = type2;\n+            return this;\n+        }\n+\n+        Frame decStack3PushStack(Type type1, Type type2) {\n+            int stackSize = this.stackSize - 3;\n+            if (stackSize < 0) throw stackUnderflow();\n+            stack[stackSize   ] = type1;\n+            stack[stackSize + 1] = type2;\n+            this.stackSize = stackSize + 2;\n+            return this;\n+        }\n+\n+        Frame decStack4PushStack(Type type) {\n+            int stackSize = this.stackSize - 4;\n+            if (stackSize < 0) throw stackUnderflow();\n+            stack[stackSize] = type;\n+            this.stackSize = stackSize + 1;\n+            return this;\n+        }\n+\n+        Frame decStack4PushStack(Type type1, Type type2) {\n+            int stackSize = this.stackSize - 4;\n+            if (stackSize < 0) throw stackUnderflow();\n+            var stack = this.stack;\n+            stack[stackSize   ] = type1;\n+            stack[stackSize + 1] = type2;\n+            this.stackSize = stackSize + 2;\n@@ -1037,2 +1198,1 @@\n-                locals = new Type[index + FRAME_DEFAULT_CAPACITY];\n-                Arrays.fill(locals, Type.TOP_TYPE);\n+                initLocals(index);\n@@ -1040,3 +1200,1 @@\n-                int current = locals.length;\n-                locals = Arrays.copyOf(locals, index + FRAME_DEFAULT_CAPACITY);\n-                Arrays.fill(locals, current, locals.length, Type.TOP_TYPE);\n+                growLocals(index);\n@@ -1047,0 +1205,11 @@\n+        private void initLocals(int index) {\n+            locals = new Type[index + FRAME_DEFAULT_CAPACITY];\n+            Arrays.fill(locals, Type.TOP_TYPE);\n+        }\n+\n+        private void growLocals(int index) {\n+            int current = locals.length;\n+            locals = Arrays.copyOf(locals, index + FRAME_DEFAULT_CAPACITY);\n+            Arrays.fill(locals, current, locals.length, Type.TOP_TYPE);\n+        }\n+\n@@ -1050,2 +1219,1 @@\n-                stack = new Type[index + FRAME_DEFAULT_CAPACITY];\n-                Arrays.fill(stack, Type.TOP_TYPE);\n+                initStack(index);\n@@ -1053,3 +1221,1 @@\n-                int current = stack.length;\n-                stack = Arrays.copyOf(stack, index + FRAME_DEFAULT_CAPACITY);\n-                Arrays.fill(stack, current, stack.length, Type.TOP_TYPE);\n+                growStack(index);\n@@ -1059,0 +1225,11 @@\n+        private void initStack(int index) {\n+            stack = new Type[index + FRAME_DEFAULT_CAPACITY];\n+            Arrays.fill(stack, Type.TOP_TYPE);\n+        }\n+\n+        private void growStack(int index) {\n+            int current = stack.length;\n+            stack = Arrays.copyOf(stack, index + FRAME_DEFAULT_CAPACITY);\n+            Arrays.fill(stack, current, stack.length, Type.TOP_TYPE);\n+        }\n+\n@@ -1061,0 +1238,1 @@\n+            var locals = this.locals;\n@@ -1065,0 +1243,8 @@\n+        private void setLocalRawInternal(int index, Type type1, Type type2) {\n+            checkLocal(index + 1);\n+            var locals = this.locals;\n+            localsChanged |= !type1.equals(locals[index]) || !type2.equals(locals[index + 1]);\n+            locals[index    ] = type1;\n+            locals[index + 1] = type2;\n+        }\n+\n@@ -1165,2 +1351,1 @@\n-            }\n-            if (old == Type.DOUBLE2_TYPE || old == Type.LONG2_TYPE) {\n+            } else if (old == Type.DOUBLE2_TYPE || old == Type.LONG2_TYPE) {\n@@ -1184,2 +1369,1 @@\n-            setLocalRawInternal(index, type1);\n-            setLocalRawInternal(index + 1, type2);\n+            setLocalRawInternal(index, type1, type2);\n@@ -1206,1 +1390,4 @@\n-                    types[compressed++] = types[i];\n+                    if (compressed != i) {\n+                        types[compressed] = types[i];\n+                    }\n+                    compressed++;\n@@ -1248,2 +1435,1 @@\n-            out.writeU1U2(255, offsetDelta);\n-            out.writeU2(localsSize);\n+            out.writeU1U2U2(255, offsetDelta, localsSize);\n@@ -1416,2 +1602,1 @@\n-        void writeTo(BufWriter bw, ConstantPoolBuilder cp) {\n-            bw.writeU1(tag);\n+        void writeTo(BufWriterImpl bw, ConstantPoolBuilder cp) {\n@@ -1420,1 +1605,1 @@\n-                    bw.writeU2(cp.classEntry(sym).index());\n+                    bw.writeU1U2(tag, cp.classEntry(sym).index());\n@@ -1422,1 +1607,3 @@\n-                    bw.writeU2(bci);\n+                    bw.writeU1U2(tag, bci);\n+                default ->\n+                    bw.writeU1(tag);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":319,"deletions":132,"binary":false,"changes":451,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.util.Objects;\n@@ -40,1 +39,0 @@\n-        Objects.requireNonNull(targetType);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TargetInfoImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import java.util.Objects;\n@@ -190,0 +191,1 @@\n+        Objects.requireNonNull(constantPool);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TemporaryConstantPool.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,0 +95,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -152,1 +154,1 @@\n-            this.entry = entry;\n+            this.entry = requireNonNull(entry);\n@@ -185,1 +187,1 @@\n-            this.signature = signature;\n+            this.signature = requireNonNull(signature);\n@@ -217,1 +219,1 @@\n-            this.annotationDefault = annotationDefault;\n+            this.annotationDefault = requireNonNull(annotationDefault);\n@@ -232,1 +234,1 @@\n-            this.sourceFile = sourceFile;\n+            this.sourceFile = requireNonNull(sourceFile);\n@@ -297,1 +299,1 @@\n-            this.classEntry = classEntry;\n+            this.classEntry = requireNonNull(classEntry);\n@@ -335,1 +337,1 @@\n-            this.moduleTarget = moduleTarget;\n+            this.moduleTarget = requireNonNull(moduleTarget);\n@@ -351,1 +353,1 @@\n-            this.mainClass = mainClass;\n+            this.mainClass = requireNonNull(mainClass);\n@@ -368,1 +370,1 @@\n-            this.algorithm = algorithm;\n+            this.algorithm = requireNonNull(algorithm);\n@@ -454,1 +456,1 @@\n-            this.hostEntry = hostEntry;\n+            this.hostEntry = requireNonNull(hostEntry);\n@@ -470,1 +472,1 @@\n-            this.idEntry = idEntry;\n+            this.idEntry = requireNonNull(idEntry);\n@@ -486,1 +488,1 @@\n-            this.idEntry = idEntry;\n+            this.idEntry = requireNonNull(idEntry);\n@@ -502,1 +504,1 @@\n-            this.contents = contents;\n+            this.contents = requireNonNull(contents);\n@@ -614,1 +616,7 @@\n-            this.elements = List.copyOf(elements);\n+            \/\/ deep copy\n+            var array = elements.toArray().clone();\n+            for (int i = 0; i < array.length; i++) {\n+                array[i] = List.copyOf((List<?>) array[i]);\n+            }\n+\n+            this.elements = SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(array);\n@@ -687,1 +695,7 @@\n-            implements InnerClassInfo {}\n+            implements InnerClassInfo {\n+        public UnboundInnerClassInfo {\n+            requireNonNull(innerClass);\n+            requireNonNull(outerClass);\n+            requireNonNull(innerName);\n+        }\n+    }\n@@ -696,1 +710,6 @@\n-            implements LocalVariableInfo { }\n+            implements LocalVariableInfo {\n+        public UnboundLocalVariableInfo {\n+            requireNonNull(name);\n+            requireNonNull(type);\n+        }\n+    }\n@@ -702,1 +721,6 @@\n-            implements LocalVariableTypeInfo { }\n+            implements LocalVariableTypeInfo {\n+        public UnboundLocalVariableTypeInfo {\n+            requireNonNull(name);\n+            requireNonNull(signature);\n+        }\n+    }\n@@ -705,1 +729,5 @@\n-            implements MethodParameterInfo {}\n+            implements MethodParameterInfo {\n+        public UnboundMethodParameterInfo {\n+            requireNonNull(name);\n+        }\n+    }\n@@ -711,5 +739,3 @@\n-        public UnboundModuleExportInfo(PackageEntry exportedPackage, int exportsFlagsMask,\n-                                       List<ModuleEntry> exportsTo) {\n-            this.exportedPackage = exportedPackage;\n-            this.exportsFlagsMask = exportsFlagsMask;\n-            this.exportsTo = List.copyOf(exportsTo);\n+        public UnboundModuleExportInfo {\n+            requireNonNull(exportedPackage);\n+            exportsTo = List.copyOf(exportsTo);\n@@ -720,1 +746,6 @@\n-                                        byte[] hash) implements ModuleHashInfo { }\n+                                        byte[] hash) implements ModuleHashInfo {\n+        public UnboundModuleHashInfo {\n+            requireNonNull(moduleName);\n+            requireNonNull(hash);\n+        }\n+    }\n@@ -725,5 +756,3 @@\n-        public UnboundModuleOpenInfo(PackageEntry openedPackage, int opensFlagsMask,\n-                                     List<ModuleEntry> opensTo) {\n-            this.openedPackage = openedPackage;\n-            this.opensFlagsMask = opensFlagsMask;\n-            this.opensTo = List.copyOf(opensTo);\n+        public UnboundModuleOpenInfo {\n+            requireNonNull(openedPackage);\n+            opensTo = List.copyOf(opensTo);\n@@ -736,3 +765,3 @@\n-        public UnboundModuleProvideInfo(ClassEntry provides, List<ClassEntry> providesWith) {\n-            this.provides = provides;\n-            this.providesWith = List.copyOf(providesWith);\n+        public UnboundModuleProvideInfo {\n+            requireNonNull(provides);\n+            providesWith = List.copyOf(providesWith);\n@@ -744,1 +773,6 @@\n-            implements ModuleRequireInfo {}\n+            implements ModuleRequireInfo {\n+        public UnboundModuleRequiresInfo {\n+            requireNonNull(requires);\n+            requireNonNull(requiresVersion);\n+        }\n+    }\n@@ -750,4 +784,4 @@\n-        public UnboundRecordComponentInfo(Utf8Entry name, Utf8Entry descriptor, List<Attribute<?>> attributes) {\n-            this.name = name;\n-            this.descriptor = descriptor;\n-            this.attributes = List.copyOf(attributes);\n+        public UnboundRecordComponentInfo {\n+            requireNonNull(name);\n+            requireNonNull(descriptor);\n+            attributes = List.copyOf(attributes);\n@@ -762,0 +796,1 @@\n+            requireNonNull(targetInfo);\n@@ -763,0 +798,1 @@\n+            requireNonNull(annotation);\n@@ -789,1 +825,1 @@\n-            this.moduleName = moduleName;\n+            this.moduleName = requireNonNull(moduleName);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":73,"deletions":37,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -290,2 +290,1 @@\n-                                    b.writeU2(-1);\/\/max stack\n-                                    b.writeU2(-1);\/\/max locals\n+                                    b.writeU2U2(-1, -1);\/\/max stack & locals\n@@ -294,2 +293,1 @@\n-                                    b.writeU2(0);\/\/exception handlers\n-                                    b.writeU2(0);\/\/attributes\n+                                    b.writeU2U2(0, 0);\/\/exception handlers & attributes\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -203,2 +203,2 @@\n-            final long s = SCOPED_MEMORY_ACCESS.getLongUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset, !Architecture.isLittleEndian());\n-            final long d = SCOPED_MEMORY_ACCESS.getLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset, !Architecture.isLittleEndian());\n+            final long s = SCOPED_MEMORY_ACCESS.getLongUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset, false);\n+            final long d = SCOPED_MEMORY_ACCESS.getLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset, false);\n@@ -213,2 +213,2 @@\n-            final int s = SCOPED_MEMORY_ACCESS.getIntUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset, !Architecture.isLittleEndian());\n-            final int d = SCOPED_MEMORY_ACCESS.getIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset, !Architecture.isLittleEndian());\n+            final int s = SCOPED_MEMORY_ACCESS.getIntUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset, false);\n+            final int d = SCOPED_MEMORY_ACCESS.getIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset, false);\n@@ -223,2 +223,2 @@\n-            final short s = SCOPED_MEMORY_ACCESS.getShortUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset, !Architecture.isLittleEndian());\n-            final short d = SCOPED_MEMORY_ACCESS.getShortUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset, !Architecture.isLittleEndian());\n+            final short s = SCOPED_MEMORY_ACCESS.getShortUnaligned(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcFromOffset + offset, false);\n+            final short d = SCOPED_MEMORY_ACCESS.getShortUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstFromOffset + offset, false);\n@@ -246,3 +246,1 @@\n-        return (Architecture.isLittleEndian()\n-                ? Long.numberOfTrailingZeros(x)\n-                : Long.numberOfLeadingZeros(x)) \/ 8;\n+        return Long.numberOfTrailingZeros(x) \/ 8;\n@@ -254,3 +252,1 @@\n-        return (Architecture.isLittleEndian()\n-                ? Integer.numberOfTrailingZeros(x)\n-                : Integer.numberOfLeadingZeros(x)) \/ 8;\n+        return Integer.numberOfTrailingZeros(x) \/ 8;\n@@ -261,5 +257,1 @@\n-        if (Architecture.isLittleEndian()) {\n-            return ((0xff & first) == (0xff & second)) ? 1 : 0;\n-        } else {\n-            return ((0xff & first) == (0xff & second)) ? 0 : 1;\n-        }\n+        return ((0xff & first) == (0xff & second)) ? 1 : 0;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":9,"deletions":17,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -398,0 +398,18 @@\n+    \/* ============================================================================ *\/\n+\n+    public interface SelectFromTwoVector<V extends Vector<?>> {\n+        V apply(V v1, V v2, V v3);\n+    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <V extends Vector<E>,\n+     E>\n+    V selectFromTwoVectorOp(Class<? extends V> vClass, Class<E> eClass, int length,\n+                            V v1, V v2, V v3,\n+                            SelectFromTwoVector<V> defaultImpl) {\n+        assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+        return defaultImpl.apply(v1, v2, v3);\n+    }\n+\n+    \/* ============================================================================ *\/\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import java.lang.reflect.Array;\n+import java.net.ProtocolException;\n@@ -48,0 +50,15 @@\n+    \/\/ max number of bytes for headers, <=0 means unlimited;\n+    \/\/ this corresponds to the length of the names, plus the length\n+    \/\/ of the values, plus an overhead of 32 bytes per name: value\n+    \/\/ pair.\n+    \/\/ Note: we use the same definition as HTTP\/2 SETTINGS_MAX_HEADER_LIST_SIZE\n+    \/\/ see RFC 9113, section 6.5.2.\n+    \/\/ https:\/\/www.rfc-editor.org\/rfc\/rfc9113.html#SETTINGS_MAX_HEADER_LIST_SIZE\n+    private final int maxHeaderSize;\n+\n+    \/\/ Aggregate size of the field lines (name + value + 32) x N\n+    \/\/ that have been parsed and accepted so far.\n+    \/\/ This is defined as a long to force promotion to long\n+    \/\/ and avoid overflows; see checkNewSize;\n+    private long size;\n+\n@@ -49,0 +66,5 @@\n+       this(0);\n+    }\n+\n+    public MessageHeader (int maxHeaderSize) {\n+        this.maxHeaderSize = maxHeaderSize;\n@@ -53,0 +75,1 @@\n+        maxHeaderSize = 0;\n@@ -479,0 +502,1 @@\n+            size = 0;\n@@ -483,0 +507,17 @@\n+    private void checkMaxHeaderSize(int sz) throws ProtocolException {\n+        if (maxHeaderSize > 0) checkNewSize(size, sz, 0);\n+    }\n+\n+    private long checkNewSize(long size, int name, int value) throws ProtocolException {\n+        \/\/ See SETTINGS_MAX_HEADER_LIST_SIZE, RFC 9113, section 6.5.2.\n+        long newSize = size + name + value + 32;\n+        if (maxHeaderSize > 0 && newSize > maxHeaderSize) {\n+            Arrays.fill(keys, 0, nkeys, null);\n+            Arrays.fill(values,0, nkeys, null);\n+            nkeys = 0;\n+            throw new ProtocolException(String.format(\"Header size too big: %s > %s\",\n+                    newSize, maxHeaderSize));\n+        }\n+        return newSize;\n+    }\n+\n@@ -496,0 +537,1 @@\n+            checkMaxHeaderSize(len);\n@@ -497,0 +539,7 @@\n+                \/\/ We start parsing for a new name value pair here.\n+                \/\/ The max header size includes an overhead of 32 bytes per\n+                \/\/ name value pair.\n+                \/\/ See SETTINGS_MAX_HEADER_LIST_SIZE, RFC 9113, section 6.5.2.\n+                long maxRemaining = maxHeaderSize > 0\n+                        ? maxHeaderSize - size - 32\n+                        : Long.MAX_VALUE;\n@@ -530,0 +579,3 @@\n+                    if (maxHeaderSize > 0 && len > maxRemaining) {\n+                        checkMaxHeaderSize(len);\n+                    }\n@@ -551,0 +603,3 @@\n+            int klen = k == null ? 0 : k.length();\n+\n+            size = checkNewSize(size, klen, v.length());\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/MessageHeader.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -175,0 +175,2 @@\n+    private static final int maxHeaderSize;\n+\n@@ -291,0 +293,13 @@\n+\n+        int defMaxHeaderSize = 384 * 1024;\n+        String maxHeaderSizeStr = getNetProperty(\"jdk.http.maxHeaderSize\");\n+        int maxHeaderSizeVal = defMaxHeaderSize;\n+        if (maxHeaderSizeStr != null) {\n+            try {\n+                maxHeaderSizeVal = Integer.parseInt(maxHeaderSizeStr);\n+            } catch (NumberFormatException n) {\n+                maxHeaderSizeVal = defMaxHeaderSize;\n+            }\n+        }\n+        if (maxHeaderSizeVal < 0) maxHeaderSizeVal = 0;\n+        maxHeaderSize = maxHeaderSizeVal;\n@@ -757,1 +772,1 @@\n-                responses = new MessageHeader();\n+                responses = new MessageHeader(maxHeaderSize);\n@@ -915,1 +930,1 @@\n-        responses = new MessageHeader();\n+        responses = new MessageHeader(maxHeaderSize);\n@@ -2813,1 +2828,1 @@\n-        responses = new MessageHeader();\n+        responses = new MessageHeader(maxHeaderSize);\n@@ -3003,1 +3018,1 @@\n-        responses = new MessageHeader();\n+        responses = new MessageHeader(maxHeaderSize);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpURLConnection.java","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+\n+import jdk.internal.util.OperatingSystem;\n@@ -151,0 +153,5 @@\n+        \/\/ for systems other than Windows we don't\n+        \/\/ do any special conversion\n+        if (!OperatingSystem.isWindows()) {\n+            return url;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","additions":8,"deletions":1,"binary":false,"changes":9,"previous_filename":"src\/java.base\/windows\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","status":"renamed"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.pkcs;\n+\n+import sun.security.util.DerInputStream;\n+import sun.security.util.DerValue;\n+import sun.security.x509.AlgorithmId;\n+\n+import javax.security.auth.DestroyFailedException;\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+import java.io.Serial;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.ProviderException;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Arrays;\n+\n+\/\/\/ Represents a private key from an algorithm family that is specialized\n+\/\/\/ with a named parameter set.\n+\/\/\/\n+\/\/\/ This key is generated by either a [sun.security.provider.NamedKeyPairGenerator]\n+\/\/\/ or [sun.security.provider.NamedKeyFactory]. Its [#getAlgorithm] method\n+\/\/\/ returns the algorithm family name, while its [#getParams()] method returns\n+\/\/\/ the parameter set name as a [NamedParameterSpec] object. The algorithm\n+\/\/\/ identifier in the PKCS #8 encoding of the key is always a single OID derived\n+\/\/\/ from the parameter set name.\n+\/\/\/\n+\/\/\/ @see sun.security.provider.NamedKeyPairGenerator\n+public final class NamedPKCS8Key extends PKCS8Key {\n+    @Serial\n+    private static final long serialVersionUID = 1L;\n+\n+    private final String fname;\n+    private final transient NamedParameterSpec paramSpec;\n+    private final byte[] rawBytes;\n+\n+    private transient boolean destroyed = false;\n+\n+    \/\/\/ Ctor from family name, parameter set name, raw key bytes.\n+    \/\/\/ Key bytes won't be cloned, caller must relinquish ownership\n+    public NamedPKCS8Key(String fname, String pname, byte[] rawBytes) {\n+        this.fname = fname;\n+        this.paramSpec = new NamedParameterSpec(pname);\n+        try {\n+            this.algid = AlgorithmId.get(pname);\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new ProviderException(e);\n+        }\n+        this.rawBytes = rawBytes;\n+\n+        DerValue val = new DerValue(DerValue.tag_OctetString, rawBytes);\n+        try {\n+            this.key = val.toByteArray();\n+        } finally {\n+            val.clear();\n+        }\n+    }\n+\n+    \/\/\/ Ctor from family name, and PKCS #8 bytes\n+    public NamedPKCS8Key(String fname, byte[] encoded) throws InvalidKeyException {\n+        super(encoded);\n+        this.fname = fname;\n+        try {\n+            paramSpec = new NamedParameterSpec(algid.getName());\n+            if (algid.getEncodedParams() != null) {\n+                throw new InvalidKeyException(\"algorithm identifier has params\");\n+            }\n+            rawBytes = new DerInputStream(key).getOctetString();\n+        } catch (IOException e) {\n+            throw new InvalidKeyException(\"Cannot parse input\", e);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        \/\/ Do not modify: this can be used by earlier JDKs that\n+        \/\/ do not have the getParams() method\n+        return paramSpec.getName() + \" private key\";\n+    }\n+\n+    \/\/\/ Returns the reference to the internal key. Caller must not modify\n+    \/\/\/ the content or keep a reference.\n+    public byte[] getRawBytes() {\n+        return rawBytes;\n+    }\n+\n+    @Override\n+    public NamedParameterSpec getParams() {\n+        return paramSpec;\n+    }\n+\n+    @Override\n+    public String getAlgorithm() {\n+        return fname;\n+    }\n+\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"NamedPKCS8Key keys are not directly deserializable\");\n+    }\n+\n+    @Override\n+    public void destroy() throws DestroyFailedException {\n+        Arrays.fill(rawBytes, (byte)0);\n+        Arrays.fill(key, (byte)0);\n+        if (encodedKey != null) {\n+            Arrays.fill(encodedKey, (byte)0);\n+        }\n+        destroyed = true;\n+    }\n+\n+    @Override\n+    public boolean isDestroyed() {\n+        return destroyed;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/NamedPKCS8Key.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.InvalidObjectException;\n@@ -275,0 +276,7 @@\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  s the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n@@ -279,1 +287,1 @@\n-        if (mdp.mech == null) {\n+        if (mdp == null || mdp.mech == null) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DRBG.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.x509.NamedX509Key;\n+\n+import javax.crypto.DecapsulateException;\n+import javax.crypto.KEM;\n+import javax.crypto.KEMSpi;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.PrivateKey;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+\/\/\/ A base class for all `KEM` implementations that can be\n+\/\/\/ configured with a named parameter set. See [NamedKeyPairGenerator]\n+\/\/\/ for more details.\n+public abstract class NamedKEM implements KEMSpi {\n+\n+    private final String fname; \/\/ family name\n+    private final String[] pnames; \/\/ allowed parameter set name (at least one)\n+\n+    \/\/\/ Creates a new `NamedKEM` object.\n+    \/\/\/\n+    \/\/\/ @param fname the family name\n+    \/\/\/ @param pnames the standard parameter set names, at least one is needed.\n+    protected NamedKEM(String fname, String... pnames) {\n+        if (fname == null) {\n+            throw new AssertionError(\"fname cannot be null\");\n+        }\n+        if (pnames == null || pnames.length == 0) {\n+            throw new AssertionError(\"pnames cannot be null or empty\");\n+        }\n+        this.fname = fname;\n+        this.pnames = pnames;\n+    }\n+\n+    @Override\n+    public EncapsulatorSpi engineNewEncapsulator(PublicKey publicKey,\n+            AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\n+                    \"The \" + fname + \" algorithm does not take any parameters\");\n+        }\n+        \/\/ translate also check the key\n+        var nk = (NamedX509Key) new NamedKeyFactory(fname, pnames)\n+                .engineTranslateKey(publicKey);\n+        var pk = nk.getRawBytes();\n+        return getKeyConsumerImpl(this, nk.getParams(), pk,\n+                implCheckPublicKey(nk.getParams().getName(), pk), secureRandom);\n+    }\n+\n+    @Override\n+    public DecapsulatorSpi engineNewDecapsulator(\n+            PrivateKey privateKey, AlgorithmParameterSpec spec)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\n+                    \"The \" + fname + \" algorithm does not take any parameters\");\n+        }\n+        \/\/ translate also check the key\n+        var nk = (NamedPKCS8Key) new NamedKeyFactory(fname, pnames)\n+                .engineTranslateKey(privateKey);\n+        var sk = nk.getRawBytes();\n+        return getKeyConsumerImpl(this, nk.getParams(), sk,\n+                implCheckPrivateKey(nk.getParams().getName(), sk), null);\n+    }\n+\n+    \/\/ We don't have a flag on whether key is public key or private key.\n+    \/\/ The correct method should always be called.\n+    private record KeyConsumerImpl(NamedKEM kem, String name, int sslen,\n+            int clen, byte[] key, Object k2, SecureRandom sr)\n+            implements KEMSpi.EncapsulatorSpi, KEMSpi.DecapsulatorSpi {\n+        @Override\n+        public SecretKey engineDecapsulate(byte[] encapsulation, int from, int to,\n+                String algorithm) throws DecapsulateException {\n+            if (encapsulation.length != clen) {\n+                throw new DecapsulateException(\"Invalid key encapsulation message length\");\n+            }\n+            var ss = kem.implDecapsulate(name, key, k2, encapsulation);\n+            try {\n+                return new SecretKeySpec(ss,\n+                        from, to - from, algorithm);\n+            } finally {\n+                Arrays.fill(ss, (byte)0);\n+            }\n+        }\n+\n+        @Override\n+        public KEM.Encapsulated engineEncapsulate(int from, int to, String algorithm) {\n+            var enc = kem.implEncapsulate(name, key, k2, sr);\n+            try {\n+                return new KEM.Encapsulated(\n+                        new SecretKeySpec(enc[1],\n+                                from, to - from, algorithm),\n+                        enc[0],\n+                        null);\n+            } finally {\n+                Arrays.fill(enc[1], (byte)0);\n+            }\n+        }\n+\n+        @Override\n+        public int engineSecretSize() {\n+            return sslen;\n+        }\n+\n+        @Override\n+        public int engineEncapsulationSize() {\n+            return clen;\n+        }\n+    }\n+\n+    private static KeyConsumerImpl getKeyConsumerImpl(NamedKEM kem,\n+            NamedParameterSpec nps, byte[] key, Object k2, SecureRandom sr) {\n+        String name = nps.getName();\n+        return new KeyConsumerImpl(kem, name, kem.implSecretSize(name), kem.implEncapsulationSize(name),\n+                key, k2, sr);\n+    }\n+\n+    \/\/\/ User-defined encap function.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param pk public key in raw bytes\n+    \/\/\/ @param pk2 parsed public key, `null` if none. See [#implCheckPublicKey].\n+    \/\/\/ @param sr SecureRandom object, `null` if not initialized\n+    \/\/\/ @return the key encapsulation message and the shared key (in this order)\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    protected abstract byte[][] implEncapsulate(String name, byte[] pk, Object pk2, SecureRandom sr);\n+\n+    \/\/\/ User-defined decap function.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param sk private key in raw bytes\n+    \/\/\/ @param sk2 parsed private key, `null` if none. See [#implCheckPrivateKey].\n+    \/\/\/ @param encap the key encapsulation message\n+    \/\/\/ @return the shared key\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    \/\/\/ @throws DecapsulateException if there is another error\n+    protected abstract byte[] implDecapsulate(String name, byte[] sk, Object sk2, byte[] encap)\n+            throws DecapsulateException;\n+\n+    \/\/\/ User-defined function returning shared secret key length.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @return shared secret key length\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    protected abstract int implSecretSize(String name);\n+\n+    \/\/\/ User-defined function returning key encapsulation message length.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @return key encapsulation message length\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    protected abstract int implEncapsulationSize(String name);\n+\n+    \/\/\/ User-defined function to validate a public key.\n+    \/\/\/\n+    \/\/\/ This method will be called in `newEncapsulator`. This gives the provider a chance to\n+    \/\/\/ reject the key so an `InvalidKeyException` can be thrown earlier.\n+    \/\/\/ An implementation can optionally return a \"parsed key\" as an `Object` value.\n+    \/\/\/ This object will be passed into the [#implEncapsulate] method along with the raw key.\n+    \/\/\/\n+    \/\/\/ The default implementation returns `null`.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param pk public key in raw bytes\n+    \/\/\/ @return a parsed key, `null` if none.\n+    \/\/\/ @throws InvalidKeyException if the key is invalid\n+    protected Object implCheckPublicKey(String name, byte[] pk) throws InvalidKeyException {\n+        return null;\n+    }\n+\n+    \/\/\/ User-defined function to validate a private key.\n+    \/\/\/\n+    \/\/\/ This method will be called in `newDecapsulator`. This gives the provider a chance to\n+    \/\/\/ reject the key so an `InvalidKeyException` can be thrown earlier.\n+    \/\/\/ An implementation can optionally return a \"parsed key\" as an `Object` value.\n+    \/\/\/ This object will be passed into the [#implDecapsulate] method along with the raw key.\n+    \/\/\/\n+    \/\/\/ The default implementation returns `null`.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param sk private key in raw bytes\n+    \/\/\/ @return a parsed key, `null` if none.\n+    \/\/\/ @throws InvalidKeyException if the key is invalid\n+    protected Object implCheckPrivateKey(String name, byte[] sk) throws InvalidKeyException {\n+        return null;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKEM.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -0,0 +1,288 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.util.RawKeySpec;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.security.AsymmetricKey;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.KeyFactorySpi;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.spec.EncodedKeySpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+\/\/\/ A base class for all `KeyFactory` implementations that can be\n+\/\/\/ configured with a named parameter set. See [NamedKeyPairGenerator]\n+\/\/\/ for more details.\n+\/\/\/\n+\/\/\/ This factory supports reading and writing to RAW formats:\n+\/\/\/\n+\/\/\/ 1. It reads from a RAW key using `translateKey` if `key.getFormat` is \"RAW\".\n+\/\/\/ 2. It writes to a RAW [EncodedKeySpec] if `getKeySpec(key, EncodedKeySpec.class)`\n+\/\/\/    is called. The format of the output is \"RAW\" and the algorithm is\n+\/\/\/    intentionally left unspecified.\n+\/\/\/ 3. It reads from and writes to the internal type [RawKeySpec].\n+\/\/\/\n+\/\/\/ When reading from a RAW format, it needs enough info to derive the\n+\/\/\/ parameter set name.\n+public class NamedKeyFactory extends KeyFactorySpi {\n+\n+    private final String fname; \/\/ family name\n+    private final String[] pnames; \/\/ allowed parameter set name (at least one)\n+\n+    \/\/\/ Creates a new `NamedKeyFactory` object.\n+    \/\/\/\n+    \/\/\/ @param fname the family name\n+    \/\/\/ @param pnames the standard parameter set names, at least one is needed.\n+    protected NamedKeyFactory(String fname, String... pnames) {\n+        if (fname == null) {\n+            throw new AssertionError(\"fname cannot be null\");\n+        }\n+        if (pnames == null || pnames.length == 0) {\n+            throw new AssertionError(\"pnames cannot be null or empty\");\n+        }\n+        this.fname = fname;\n+        this.pnames = pnames;\n+    }\n+\n+    private String checkName(String name) throws InvalidKeyException  {\n+        for (var pname : pnames) {\n+            if (pname.equalsIgnoreCase(name)) {\n+                \/\/ return the stored standard name\n+                return pname;\n+            }\n+        }\n+        throw new InvalidKeyException(\"Unsupported parameter set name: \" + name);\n+    }\n+\n+    @Override\n+    protected PublicKey engineGeneratePublic(KeySpec keySpec)\n+            throws InvalidKeySpecException {\n+        if (keySpec instanceof X509EncodedKeySpec xspec) {\n+            try {\n+                return fromX509(xspec.getEncoded());\n+            } catch (InvalidKeyException e) {\n+                throw new InvalidKeySpecException(e);\n+            }\n+        } else if (keySpec instanceof RawKeySpec rks) {\n+            if (pnames.length == 1) {\n+                return new NamedX509Key(fname, pnames[0], rks.getKeyArr());\n+            } else {\n+                throw new InvalidKeySpecException(\"Parameter set name unavailable\");\n+            }\n+        } else if (keySpec instanceof EncodedKeySpec espec\n+                && espec.getFormat().equalsIgnoreCase(\"RAW\")) {\n+            if (pnames.length == 1) {\n+                return new NamedX509Key(fname, pnames[0], espec.getEncoded());\n+            } else {\n+                throw new InvalidKeySpecException(\"Parameter set name unavailable\");\n+            }\n+        } else {\n+            throw new InvalidKeySpecException(\"Unsupported keyspec: \" + keySpec);\n+        }\n+    }\n+\n+    @Override\n+    protected PrivateKey engineGeneratePrivate(KeySpec keySpec)\n+            throws InvalidKeySpecException {\n+        if (keySpec instanceof PKCS8EncodedKeySpec pspec) {\n+            var bytes = pspec.getEncoded();\n+            try {\n+                return fromPKCS8(bytes);\n+            } catch (InvalidKeyException e) {\n+                throw new InvalidKeySpecException(e);\n+            } finally {\n+                Arrays.fill(bytes, (byte) 0);\n+            }\n+        } else if (keySpec instanceof RawKeySpec rks) {\n+            if (pnames.length == 1) {\n+                var bytes = rks.getKeyArr();\n+                try {\n+                    return new NamedPKCS8Key(fname, pnames[0], bytes);\n+                } finally {\n+                    Arrays.fill(bytes, (byte) 0);\n+                }\n+            } else {\n+                throw new InvalidKeySpecException(\"Parameter set name unavailable\");\n+            }\n+        } else if (keySpec instanceof EncodedKeySpec espec\n+                && espec.getFormat().equalsIgnoreCase(\"RAW\")) {\n+            if (pnames.length == 1) {\n+                var bytes = espec.getEncoded();\n+                try {\n+                    return new NamedPKCS8Key(fname, pnames[0], bytes);\n+                } finally {\n+                    Arrays.fill(bytes, (byte) 0);\n+                }\n+            } else {\n+                throw new InvalidKeySpecException(\"Parameter set name unavailable\");\n+            }\n+        } else {\n+            throw new InvalidKeySpecException(\"Unsupported keyspec: \" + keySpec);\n+        }\n+    }\n+\n+    private PrivateKey fromPKCS8(byte[] bytes)\n+            throws InvalidKeyException, InvalidKeySpecException {\n+        var k = new NamedPKCS8Key(fname, bytes);\n+        checkName(k.getParams().getName());\n+        return k;\n+    }\n+\n+    private PublicKey fromX509(byte[] bytes)\n+            throws InvalidKeyException, InvalidKeySpecException {\n+        var k = new NamedX509Key(fname, bytes);\n+        checkName(k.getParams().getName());\n+        return k;\n+    }\n+\n+    private static class RawEncodedKeySpec extends EncodedKeySpec {\n+        public RawEncodedKeySpec(byte[] encodedKey) {\n+            super(encodedKey);\n+        }\n+\n+        @Override\n+        public String getFormat() {\n+            return \"RAW\";\n+        }\n+    }\n+\n+    @Override\n+    protected <T extends KeySpec> T engineGetKeySpec(Key key, Class<T> keySpec)\n+            throws InvalidKeySpecException {\n+        try {\n+            key = engineTranslateKey(key);\n+        } catch (InvalidKeyException e) {\n+            throw new InvalidKeySpecException(e);\n+        }\n+        \/\/ key is now either NamedPKCS8Key or NamedX509Key of permitted param set\n+        if (key instanceof NamedPKCS8Key nk) {\n+            byte[] bytes = null;\n+            try {\n+                if (keySpec == PKCS8EncodedKeySpec.class) {\n+                    return keySpec.cast(\n+                            new PKCS8EncodedKeySpec(bytes = key.getEncoded()));\n+                } else if (keySpec == RawKeySpec.class) {\n+                    return keySpec.cast(new RawKeySpec(nk.getRawBytes()));\n+                } else if (keySpec.isAssignableFrom(EncodedKeySpec.class)) {\n+                    return keySpec.cast(\n+                            new RawEncodedKeySpec(nk.getRawBytes()));\n+                } else {\n+                    throw new InvalidKeySpecException(\"Unsupported type: \" + keySpec);\n+                }\n+            } finally {\n+                if (bytes != null) {\n+                    Arrays.fill(bytes, (byte)0);\n+                }\n+            }\n+        } else if (key instanceof NamedX509Key nk) {\n+            if (keySpec == X509EncodedKeySpec.class\n+                    && key.getFormat().equalsIgnoreCase(\"X.509\")) {\n+                return keySpec.cast(new X509EncodedKeySpec(key.getEncoded()));\n+            } else if (keySpec == RawKeySpec.class) {\n+                return keySpec.cast(new RawKeySpec(nk.getRawBytes()));\n+            } else if (keySpec.isAssignableFrom(EncodedKeySpec.class)) {\n+                return keySpec.cast(new RawEncodedKeySpec(nk.getRawBytes()));\n+            } else {\n+                throw new InvalidKeySpecException(\"Unsupported type: \" + keySpec);\n+            }\n+        }\n+        throw new AssertionError(\"No \" + keySpec.getName() + \" for \" + key.getClass());\n+    }\n+\n+    @Override\n+    protected Key engineTranslateKey(Key key) throws InvalidKeyException {\n+        if (key == null) {\n+            throw new InvalidKeyException(\"Key must not be null\");\n+        }\n+        if (key instanceof NamedX509Key nk) {\n+            checkName(nk.getParams().getName());\n+            return key;\n+        }\n+        if (key instanceof NamedPKCS8Key nk) {\n+            checkName(nk.getParams().getName());\n+            return key;\n+        }\n+        var format = key.getFormat();\n+        if (format == null) {\n+            throw new InvalidKeyException(\"Unextractable key\");\n+        } else if (format.equalsIgnoreCase(\"RAW\")) {\n+            var kAlg = key.getAlgorithm();\n+            if (key instanceof AsymmetricKey pk) {\n+                String name;\n+                \/\/ Three cases that we can find the parameter set name from a RAW key:\n+                \/\/ 1. getParams() returns one\n+                \/\/ 2. getAlgorithm() returns param set name (some provider does this)\n+                \/\/ 3. getAlgorithm() returns family name but this KF is for param set name\n+                if (pk.getParams() instanceof NamedParameterSpec nps) {\n+                    name = checkName(nps.getName());\n+                } else {\n+                    if (kAlg.equalsIgnoreCase(fname)) {\n+                        if (pnames.length == 1) {\n+                            name = pnames[0];\n+                        } else {\n+                            throw new InvalidKeyException(\"No parameter set info\");\n+                        }\n+                    } else {\n+                        name = checkName(kAlg);\n+                    }\n+                }\n+                return key instanceof PrivateKey\n+                        ? new NamedPKCS8Key(fname, name, key.getEncoded())\n+                        : new NamedX509Key(fname, name, key.getEncoded());\n+            } else {\n+                throw new InvalidKeyException(\"Unsupported key type: \" + key.getClass());\n+            }\n+        } else if (format.equalsIgnoreCase(\"PKCS#8\") && key instanceof PrivateKey) {\n+            var bytes = key.getEncoded();\n+            try {\n+                return fromPKCS8(bytes);\n+            } catch (InvalidKeySpecException e) {\n+                throw new InvalidKeyException(\"Invalid PKCS#8 key\", e);\n+            } finally {\n+                Arrays.fill(bytes, (byte) 0);\n+            }\n+        } else if (format.equalsIgnoreCase(\"X.509\") && key instanceof PublicKey) {\n+            try {\n+                return fromX509(key.getEncoded());\n+            } catch (InvalidKeySpecException e) {\n+                throw new InvalidKeyException(\"Invalid X.509 key\", e);\n+            }\n+        } else {\n+            throw new InvalidKeyException(\"Unsupported key format: \" + key.getFormat());\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKeyFactory.java","additions":288,"deletions":0,"binary":false,"changes":288,"status":"added"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidParameterException;\n+import java.security.KeyPair;\n+import java.security.KeyPairGeneratorSpi;\n+import java.security.ProviderException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Objects;\n+\n+\/\/\/ A base class for all `KeyPairGenerator` implementations that can be\n+\/\/\/ configured with a named parameter set.\n+\/\/\/\n+\/\/\/ Together with [NamedKeyFactory], [NamedKEM], and [NamedSignature], these\n+\/\/\/ classes form a compact framework designed to support any public key\n+\/\/\/ algorithm standardized with named parameter sets. In this scenario,\n+\/\/\/ the algorithm name is the \"family name\" and each standardized parameter\n+\/\/\/ set has a \"parameter set name\". Implementations of these classes are able\n+\/\/\/ to instantiate a `KeyPairGenerator`, `KeyFactory`, or `KEM` or `Signature`\n+\/\/\/ object using either the family name or a parameter set name. All keys used\n+\/\/\/ in this context will be of the type [NamedPKCS8Key] or [NamedX509Key],\n+\/\/\/ with `getAlgorithm` returning the family name, and `getParams` returning\n+\/\/\/ the parameter set name as a [NamedParameterSpec] object.\n+\/\/\/\n+\/\/\/ An implementation must include a zero-argument public constructor that\n+\/\/\/ calls `super(fname, pnames)`, where `fname` is the family name of the\n+\/\/\/ algorithm and `pnames` are its supported parameter set names. `pnames`\n+\/\/\/ must contain at least one element. For an implementation of\n+\/\/\/ `NamedKeyPairGenerator`, the first element becomes its default parameter\n+\/\/\/ set, i.e. the parameter set to be used in key pair generation unless\n+\/\/\/ [#initialize(AlgorithmParameterSpec, java.security.SecureRandom)]\n+\/\/\/ is called on a different parameter set.\n+\/\/\/\n+\/\/\/ An implementation must implement all abstract methods. For all these\n+\/\/\/ methods, the implementation must relinquish any \"ownership\" of any input\n+\/\/\/ and output array argument. Precisely, the implementation must not retain\n+\/\/\/ any reference to a returning array so that it won't be able to modify its\n+\/\/\/ content later. Similarly, the implementation must not modify any input\n+\/\/\/ array argument and must not retain any reference to an input array argument\n+\/\/\/ after the call.\n+\/\/\/\n+\/\/\/ Also, an implementation must not keep any extra copy of a private key.\n+\/\/\/ For key generation, the only copy is the one returned in the\n+\/\/\/ [#implGenerateKeyPair] call. For all other methods, it must not make\n+\/\/\/ a copy of the input private key. A `KEM` implementation also must not\n+\/\/\/ keep a copy of the shared secret key, no matter if it's an encapsulator\n+\/\/\/ or a decapsulator. Only the code that owns these sensitive data can\n+\/\/\/ choose to perform cleanup when it determines they are no longer needed.\n+\/\/\/\n+\/\/\/ The `NamedSignature` and `NamedKEM` classes provide `implCheckPublicKey`\n+\/\/\/ and `implCheckPrivateKey` methods that allow an implementation to validate\n+\/\/\/ a key before using it. An implementation may return a parsed key in\n+\/\/\/ a local type, and this parsed key will be passed to an operational method\n+\/\/\/ (For example, `implSign`) later. An implementation must not retain\n+\/\/\/ a reference of the parsed key.\n+\/\/\/\n+\/\/\/ When constructing a [NamedX509Key] or [NamedPKCS8Key] object from raw key\n+\/\/\/ bytes, the key bytes are directly referenced within the object, so the\n+\/\/\/ caller must not modify them afterward. Similarly, the key's `getRawBytes`\n+\/\/\/ method returns direct references to the underlying raw key bytes, meaning\n+\/\/\/ the caller must not alter the contents of the returned value.\n+\/\/\/\n+\/\/\/ Together, these measures ensure the classes are as efficient as possible,\n+\/\/\/ preventing unnecessary array cloning and potential data leaks. While these\n+\/\/\/ classes should not be considered immutable, strictly adhering to the rules\n+\/\/\/ above will ensure data integrity is maintained.\n+\/\/\/\n+\/\/\/ Note: A limitation of `NamedKeyPairGenerator` and `NamedKeyFactory` is\n+\/\/\/ that the keys generated by their implementations will always be of type\n+\/\/\/ `NamedX509Key` or `NamedPKCS8Key`. Existing implementations of algorithms\n+\/\/\/ like EdDSA and XDH have been generating keys implementing `EdECKey` or\n+\/\/\/ `XECKey` interfaces, and they are not rewritten with this framework.\n+\/\/\/ `NamedParameterSpec` fields not implemented with this framework include\n+\/\/\/ Ed25519, Ed448, X25519, and X448.\n+public abstract class NamedKeyPairGenerator extends KeyPairGeneratorSpi {\n+\n+    private final String fname; \/\/ family name\n+    private final String[] pnames; \/\/ allowed parameter set name (at least one)\n+\n+    protected String name; \/\/ init as\n+    private SecureRandom secureRandom;\n+\n+    \/\/\/ Creates a new `NamedKeyPairGenerator` object.\n+    \/\/\/\n+    \/\/\/ @param fname the family name\n+    \/\/\/ @param pnames supported parameter set names, at least one is needed.\n+    \/\/\/     If multiple, the first one becomes the default parameter set name.\n+    protected NamedKeyPairGenerator(String fname, String... pnames) {\n+        if (fname == null) {\n+            throw new AssertionError(\"fname cannot be null\");\n+        }\n+        if (pnames == null || pnames.length == 0) {\n+            throw new AssertionError(\"pnames cannot be null or empty\");\n+        }\n+        this.fname = fname;\n+        this.pnames = pnames;\n+    }\n+\n+    private String checkName(String name) throws InvalidAlgorithmParameterException  {\n+        for (var pname : pnames) {\n+            if (pname.equalsIgnoreCase(name)) {\n+                \/\/ return the stored standard name\n+                return pname;\n+            }\n+        }\n+        throw new InvalidAlgorithmParameterException(\n+                \"Unsupported parameter set name: \" + name);\n+    }\n+\n+    @Override\n+    public void initialize(AlgorithmParameterSpec params, SecureRandom random)\n+            throws InvalidAlgorithmParameterException {\n+        if (params instanceof NamedParameterSpec spec) {\n+            name = checkName(spec.getName());\n+        } else {\n+            throw new InvalidAlgorithmParameterException(\n+                    \"Unsupported AlgorithmParameterSpec: \" + params);\n+        }\n+        this.secureRandom = random;\n+    }\n+\n+    @Override\n+    public void initialize(int keysize, SecureRandom random) {\n+        if (keysize != -1) {\n+            \/\/ User can call initialize(-1, sr) to provide a SecureRandom\n+            \/\/ without touching the parameter set currently used\n+            throw new InvalidParameterException(\"keysize not supported\");\n+        }\n+        this.secureRandom = random;\n+    }\n+\n+    @Override\n+    public KeyPair generateKeyPair() {\n+        String pname = name != null ? name : pnames[0];\n+        var keys = implGenerateKeyPair(pname, secureRandom);\n+        return new KeyPair(new NamedX509Key(fname, pname, keys[0]),\n+                new NamedPKCS8Key(fname, pname, keys[1]));\n+    }\n+\n+    \/\/\/ User-defined key pair generator.\n+    \/\/\/\n+    \/\/\/ @param pname parameter set name\n+    \/\/\/ @param sr `SecureRandom` object, `null` if not initialized\n+    \/\/\/ @return public key and private key (in this order) in raw bytes\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    protected abstract byte[][] implGenerateKeyPair(String pname, SecureRandom sr);\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKeyPairGenerator.java","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.InvalidParameterException;\n+import java.security.PrivateKey;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.SignatureException;\n+import java.security.SignatureSpi;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Objects;\n+\n+\/\/\/ A base class for all `Signature` implementations that can be\n+\/\/\/ configured with a named parameter set. See [NamedKeyPairGenerator]\n+\/\/\/ for more details.\n+\/\/\/\n+\/\/\/ This class does not work with preHash signatures.\n+public abstract class NamedSignature extends SignatureSpi {\n+\n+    private final String fname; \/\/ family name\n+    private final String[] pnames; \/\/ allowed parameter set name (at least one)\n+\n+    private final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+\n+    \/\/ init with...\n+    private String name;\n+    private byte[] secKey;\n+    private byte[] pubKey;\n+\n+    private Object sk2;\n+    private Object pk2;\n+\n+    \/\/\/ Creates a new `NamedSignature` object.\n+    \/\/\/\n+    \/\/\/ @param fname the family name\n+    \/\/\/ @param pnames the standard parameter set names, at least one is needed.\n+    protected NamedSignature(String fname, String... pnames) {\n+        if (fname == null) {\n+            throw new AssertionError(\"fname cannot be null\");\n+        }\n+        if (pnames == null || pnames.length == 0) {\n+            throw new AssertionError(\"pnames cannot be null or empty\");\n+        }\n+        this.fname = fname;\n+        this.pnames = pnames;\n+    }\n+\n+    @Override\n+    protected void engineInitVerify(PublicKey publicKey) throws InvalidKeyException {\n+        \/\/ translate also check the key\n+        var nk = (NamedX509Key) new NamedKeyFactory(fname, pnames)\n+                .engineTranslateKey(publicKey);\n+        name = nk.getParams().getName();\n+        pubKey = nk.getRawBytes();\n+        pk2 = implCheckPublicKey(name, pubKey);\n+        secKey = null;\n+        bout.reset();\n+    }\n+\n+    @Override\n+    protected void engineInitSign(PrivateKey privateKey) throws InvalidKeyException {\n+        \/\/ translate also check the key\n+        var nk = (NamedPKCS8Key) new NamedKeyFactory(fname, pnames)\n+                .engineTranslateKey(privateKey);\n+        name = nk.getParams().getName();\n+        secKey = nk.getRawBytes();\n+        sk2 = implCheckPrivateKey(name, secKey);\n+        pubKey = null;\n+        bout.reset();\n+    }\n+\n+    @Override\n+    protected void engineUpdate(byte b) throws SignatureException {\n+        bout.write(b);\n+    }\n+\n+    @Override\n+    protected void engineUpdate(byte[] b, int off, int len) throws SignatureException {\n+        bout.write(b, off, len);\n+    }\n+\n+    @Override\n+    protected byte[] engineSign() throws SignatureException {\n+        if (secKey != null) {\n+            var msg = bout.toByteArray();\n+            bout.reset();\n+            return implSign(name, secKey, sk2, msg, appRandom);\n+        } else {\n+            throw new SignatureException(\"No private key\");\n+        }\n+    }\n+\n+    @Override\n+    protected boolean engineVerify(byte[] sig) throws SignatureException {\n+        if (pubKey != null) {\n+            var msg = bout.toByteArray();\n+            bout.reset();\n+            return implVerify(name, pubKey, pk2, msg, sig);\n+        } else {\n+            throw new SignatureException(\"No public key\");\n+        }\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    protected void engineSetParameter(String param, Object value)\n+            throws InvalidParameterException {\n+        throw new InvalidParameterException(\"setParameter() not supported\");\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    protected Object engineGetParameter(String param) throws InvalidParameterException {\n+        throw new InvalidParameterException(\"getParameter() not supported\");\n+    }\n+\n+    @Override\n+    protected void engineSetParameter(AlgorithmParameterSpec params)\n+            throws InvalidAlgorithmParameterException {\n+        if (params != null) {\n+            throw new InvalidAlgorithmParameterException(\n+                    \"The \" + fname + \" algorithm does not take any parameters\");\n+        }\n+    }\n+\n+    @Override\n+    protected AlgorithmParameters engineGetParameters() {\n+        return null;\n+    }\n+\n+    \/\/\/ User-defined sign function.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param sk private key in raw bytes\n+    \/\/\/ @param sk2 parsed private key, `null` if none. See [#implCheckPrivateKey].\n+    \/\/\/ @param msg the message\n+    \/\/\/ @param sr SecureRandom object, `null` if not initialized\n+    \/\/\/ @return the signature\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    \/\/\/ @throws SignatureException if there is another error\n+    protected abstract byte[] implSign(String name, byte[] sk, Object sk2,\n+            byte[] msg, SecureRandom sr) throws SignatureException;\n+\n+    \/\/\/ User-defined verify function.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param pk public key in raw bytes\n+    \/\/\/ @param pk2 parsed public key, `null` if none. See [#implCheckPublicKey].\n+    \/\/\/ @param msg the message\n+    \/\/\/ @param sig the signature\n+    \/\/\/ @return true if verified\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    \/\/\/ @throws SignatureException if there is another error\n+    protected abstract boolean implVerify(String name, byte[] pk, Object pk2,\n+            byte[] msg, byte[] sig) throws SignatureException;\n+\n+    \/\/\/ User-defined function to validate a public key.\n+    \/\/\/\n+    \/\/\/ This method will be called in `initVerify`. This gives the provider a chance to\n+    \/\/\/ reject the key so an `InvalidKeyException` can be thrown earlier.\n+    \/\/\/ An implementation can optionally return a \"parsed key\" as an `Object` value.\n+    \/\/\/ This object will be passed into the [#implVerify] method along with the raw key.\n+    \/\/\/\n+    \/\/\/ The default implementation returns `null`.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param pk public key in raw bytes\n+    \/\/\/ @return a parsed key, `null` if none.\n+    \/\/\/ @throws InvalidKeyException if the key is invalid\n+    protected Object implCheckPublicKey(String name, byte[] pk) throws InvalidKeyException {\n+        return null;\n+    }\n+\n+    \/\/\/ User-defined function to validate a private key.\n+    \/\/\/\n+    \/\/\/ This method will be called in `initSign`. This gives the provider a chance to\n+    \/\/\/ reject the key so an `InvalidKeyException` can be thrown earlier.\n+    \/\/\/ An implementation can optionally return a \"parsed key\" as an `Object` value.\n+    \/\/\/ This object will be passed into the [#implSign] method along with the raw key.\n+    \/\/\/\n+    \/\/\/ The default implementation returns `null`.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param sk private key in raw bytes\n+    \/\/\/ @return a parsed key, `null` if none.\n+    \/\/\/ @throws InvalidKeyException if the key is invalid\n+    protected Object implCheckPrivateKey(String name, byte[] sk) throws InvalidKeyException {\n+        return null;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedSignature.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -216,2 +216,0 @@\n-                extensions.send(hos);       \/\/ In TLS 1.3, use of certain\n-                                            \/\/ extensions is mandatory.\n@@ -1429,0 +1427,3 @@\n+            \/\/ Reset the ClientHello non-zero offset fragment allowance\n+            shc.acceptCliHelloFragments = false;\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ClientHello.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+    private SSLContextImpl  sslContext;\n@@ -49,0 +50,10 @@\n+    \/\/ Method to set TransportContext\n+    public void setTransportContext(TransportContext tc) {\n+        this.tc = tc;\n+    }\n+\n+    \/\/ Method to set SSLContext\n+    public void setSSLContext(SSLContextImpl sslContext) {\n+        this.sslContext = sslContext;\n+    }\n+\n@@ -540,0 +551,21 @@\n+    \/**\n+     * Turn a sufficiently-large initial ClientHello fragment into one that\n+     * stops immediately after the compression methods.  This is only used\n+     * for the initial CH message fragment at offset 0.\n+     *\n+     * @param srcFrag the fragment actually received by the DTLSReassembler\n+     * @param limit the size of the new, cloned\/truncated handshake fragment\n+     *\n+     * @return a truncated handshake fragment that is sized to look like a\n+     * complete message, but actually contains only up to the compression\n+     * methods (no extensions)\n+     *\/\n+    private static HandshakeFragment truncateChFragment(HandshakeFragment srcFrag,\n+            int limit) {\n+        return new HandshakeFragment(Arrays.copyOf(srcFrag.fragment, limit),\n+                srcFrag.contentType, srcFrag.majorVersion,\n+                srcFrag.minorVersion, srcFrag.recordEnS, srcFrag.recordEpoch,\n+                srcFrag.recordSeq, srcFrag.handshakeType, limit,\n+                srcFrag.messageSeq, srcFrag.fragmentOffset, limit);\n+    }\n+\n@@ -643,1 +675,1 @@\n-                \/\/ Not a dedired record, discard it.\n+                \/\/ Not a desired record, discard it.\n@@ -647,0 +679,7 @@\n+            if (hsf.handshakeType == SSLHandshake.CLIENT_HELLO.id) {\n+                \/\/ validate the first or subsequent ClientHello message\n+                if ((hsf = valHello(hsf, hsf.messageSeq == 0)) == null) {\n+                    return;\n+                }\n+            }\n+\n@@ -772,0 +811,94 @@\n+        private HandshakeFragment valHello(HandshakeFragment hsf,\n+                boolean firstHello) {\n+            ServerHandshakeContext shc =\n+                    (ServerHandshakeContext) tc.handshakeContext;\n+            \/\/ Drop any fragment that is not a zero offset until we've received\n+            \/\/ a second (or possibly later) CH message that passes the cookie\n+            \/\/ check.\n+            if (shc == null || !shc.acceptCliHelloFragments) {\n+                if (hsf.fragmentOffset != 0) {\n+                    return null;\n+                }\n+            } else {\n+                \/\/ Let this fragment through to the DTLSReassembler as-is\n+                return hsf;\n+            }\n+\n+            try {\n+                ByteBuffer fragmentData = ByteBuffer.wrap(hsf.fragment);\n+\n+                ProtocolVersion pv = ProtocolVersion.valueOf(\n+                        Record.getInt16(fragmentData));\n+                if (!pv.isDTLS) {\n+                    return null;\n+                }\n+                \/\/ Read the random (32 bytes)\n+                if (fragmentData.remaining() < 32) {\n+                    if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                        SSLLogger.fine(\"Rejected client hello fragment (bad random len) \" +\n+                                \"fo=\" + hsf.fragmentOffset + \" fl=\" + hsf.fragmentLength);\n+                    }\n+                    return null;\n+                }\n+                fragmentData.position(fragmentData.position() + 32);\n+\n+                \/\/ SessionID\n+                byte[] sessId = Record.getBytes8(fragmentData);\n+                if (sessId.length > 0  &&\n+                        !SSLConfiguration.enableDtlsResumeCookie) {\n+                    \/\/ If we are in a resumption it is possible that the cookie\n+                    \/\/ exchange will be skipped.  This is a server-side setting\n+                    \/\/ and it is NOT the default.  If enableDtlsResumeCookie is\n+                    \/\/ false though, then we will buffer fragments since there\n+                    \/\/ is no cookie exchange to execute prior to performing\n+                    \/\/ reassembly.\n+                    return hsf;\n+                }\n+\n+                \/\/ Cookie\n+                byte[] cookie = Record.getBytes8(fragmentData);\n+                if (firstHello && cookie.length != 0) {\n+                    if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                        SSLLogger.fine(\"Rejected initial client hello fragment (bad cookie len) \" +\n+                                \"fo=\" + hsf.fragmentOffset + \" fl=\" + hsf.fragmentLength);\n+                    }\n+                    return null;\n+                }\n+                \/\/ CipherSuites\n+                Record.getBytes16(fragmentData);\n+                \/\/ Compression methods\n+                Record.getBytes8(fragmentData);\n+\n+                \/\/ If it's the first fragment, we'll truncate it and push it\n+                \/\/ through the reassembler.\n+                if (firstHello) {\n+                    return truncateChFragment(hsf, fragmentData.position());\n+                } else {\n+                    HelloCookieManager hcMgr = sslContext.\n+                            getHelloCookieManager(ProtocolVersion.DTLS10);\n+                    ByteBuffer msgFragBuf = ByteBuffer.wrap(hsf.fragment, 0,\n+                            fragmentData.position());\n+                    ClientHello.ClientHelloMessage chMsg =\n+                            new ClientHello.ClientHelloMessage(shc, msgFragBuf, null);\n+                    if (!hcMgr.isCookieValid(shc, chMsg, cookie)) {\n+                        \/\/ Bad cookie check, truncate it and let the ClientHello\n+                        \/\/ consumer recheck, fail and take the appropriate action.\n+                        return truncateChFragment(hsf, fragmentData.position());\n+                    } else {\n+                        \/\/ It's a good cookie, return the original handshake\n+                        \/\/ fragment and let it go into the DTLSReassembler like\n+                        \/\/ any other fragment so we can wait for the rest of\n+                        \/\/ the CH message.\n+                        shc.acceptCliHelloFragments = true;\n+                        return hsf;\n+                    }\n+                }\n+            } catch (IOException ioe) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                    SSLLogger.fine(\"Rejected client hello fragment \" +\n+                            \"fo=\" + hsf.fragmentOffset + \" fl=\" + hsf.fragmentLength);\n+                }\n+                return null;\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DTLSInputRecord.java","additions":135,"deletions":2,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+    boolean acceptCliHelloFragments = false;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHandshakeContext.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,0 +159,5 @@\n+\n+        if (inputRecord instanceof DTLSInputRecord dtlsInputRecord) {\n+            dtlsInputRecord.setTransportContext(this);\n+            dtlsInputRecord.setSSLContext(this.sslContext);\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/TransportContext.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -187,2 +187,2 @@\n-        if (key instanceof ECKey) {\n-            ECParameterSpec paramSpec = ((ECKey) key).getParams();\n+        if (key instanceof AsymmetricKey ak) {\n+            AlgorithmParameterSpec paramSpec = ak.getParams();\n@@ -191,0 +191,2 @@\n+            } else if (paramSpec instanceof NamedParameterSpec nps) {\n+                result = nps.getName();\n@@ -192,2 +194,0 @@\n-        } else if (key instanceof EdECKey) {\n-            result = ((EdECKey) key).getParams().getName();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,0 +130,7 @@\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  is the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n@@ -136,1 +143,5 @@\n-            int[] comp = (int[])components;\n+            if (components == null) {\n+                throw new InvalidObjectException(\"OID components is null\");\n+            }\n+\n+            int[] comp = ((int[]) components).clone();\n@@ -145,0 +156,1 @@\n+            components = comp;\n@@ -146,0 +158,1 @@\n+            encoding = encoding.clone(); \/\/ defensive copying\n@@ -264,0 +277,1 @@\n+    \/\/ set 'encoding' field based on the specified 'components' and 'length'\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/ObjectIdentifier.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import sun.security.pkcs.NamedPKCS8Key;\n@@ -277,1 +278,1 @@\n-                    \"Unknown algorithm: \" + signatureAlgorithm);\n+                    \"Cannot extract digest algorithm from \" + signatureAlgorithm);\n@@ -393,2 +394,2 @@\n-            if (key instanceof EdECKey) {\n-                return AlgorithmId.get(((EdECKey) key).getParams().getName());\n+            if (key.getParams() instanceof NamedParameterSpec nps) {\n+                return AlgorithmId.get(nps.getName());\n@@ -434,0 +435,8 @@\n+        if (key instanceof NamedPKCS8Key n8k) {\n+            if (!sAlg.equalsIgnoreCase(n8k.getAlgorithm())\n+                    && !sAlg.equalsIgnoreCase(n8k.getParams().getName())) {\n+                throw new IllegalArgumentException(\n+                        \"key algorithm not compatible with signature algorithm\");\n+            }\n+            return;\n+        }\n@@ -498,2 +507,4 @@\n-            default -> kAlg; \/\/ All modern signature algorithms,\n-                             \/\/ RSASSA-PSS, ED25519, ED448, HSS\/LMS, etc\n+            default -> kAlg.contains(\"KEM\") ? null : kAlg;\n+                \/\/ All modern signature algorithms use the same name across\n+                \/\/ key algorithms and signature algorithms, for example,\n+                \/\/ RSASSA-PSS, ED25519, ED448, HSS\/LMS, etc\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureUtil.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.ObjectInputStream;\n@@ -29,0 +30,1 @@\n+import java.io.InvalidObjectException;\n@@ -32,1 +34,1 @@\n-\n+import java.util.Arrays;\n@@ -75,3 +77,1 @@\n-public final\n-class AlgIdDSA extends AlgorithmId implements DSAParams\n-{\n+public final class AlgIdDSA extends AlgorithmId implements DSAParams {\n@@ -82,0 +82,11 @@\n+    private static class DSAComponents {\n+        private final BigInteger p;\n+        private final BigInteger q;\n+        private final BigInteger g;\n+        DSAComponents(BigInteger p, BigInteger q, BigInteger g) {\n+            this.p = p;\n+            this.q = q;\n+            this.g = g;\n+        }\n+    }\n+\n@@ -85,1 +96,1 @@\n-    private BigInteger  p , q, g;\n+    private BigInteger p, q, g;\n@@ -88,1 +99,1 @@\n-    public BigInteger   getP () { return p; }\n+    public BigInteger   getP() { return p; }\n@@ -91,1 +102,1 @@\n-    public BigInteger   getQ () { return q; }\n+    public BigInteger   getQ() { return q; }\n@@ -94,1 +105,1 @@\n-    public BigInteger   getG () { return g; }\n+    public BigInteger   getG() { return g; }\n@@ -101,1 +112,1 @@\n-    public AlgIdDSA () {}\n+    public AlgIdDSA() {}\n@@ -112,1 +123,1 @@\n-    public AlgIdDSA (BigInteger p, BigInteger q, BigInteger g) {\n+    public AlgIdDSA(BigInteger p, BigInteger q, BigInteger g) {\n@@ -123,2 +134,4 @@\n-                initializeParams ();\n-\n+                \/\/ For algorithm IDs which haven't been created from a DER\n+                \/\/ encoded value, need to create DER encoding and store it\n+                \/\/ into \"encodedParams\"\n+                encodedParams = encode(p, q, g);\n@@ -136,41 +149,2 @@\n-    public String getName ()\n-        { return \"DSA\"; }\n-\n-\n-    \/*\n-     * For algorithm IDs which haven't been created from a DER encoded\n-     * value, \"params\" must be created.\n-     *\/\n-    private void initializeParams () throws IOException {\n-        DerOutputStream out = new DerOutputStream();\n-        out.putInteger(p);\n-        out.putInteger(q);\n-        out.putInteger(g);\n-        DerOutputStream result = new DerOutputStream();\n-        result.write(DerValue.tag_Sequence, out);\n-        encodedParams = result.toByteArray();\n-    }\n-\n-    \/**\n-     * Parses algorithm parameters P, Q, and G.  They're found\n-     * in the \"params\" member, which never needs to be changed.\n-     *\/\n-    protected void decodeParams () throws IOException {\n-        if (encodedParams == null) {\n-            throw new IOException(\"DSA alg params are null\");\n-        }\n-\n-        DerValue params = new DerValue(encodedParams);\n-        if (params.tag != DerValue.tag_Sequence) {\n-            throw new IOException(\"DSA alg parsing error\");\n-        }\n-\n-        params.data.reset ();\n-\n-        this.p = params.data.getBigInteger();\n-        this.q = params.data.getBigInteger();\n-        this.g = params.data.getBigInteger();\n-\n-        if (params.data.available () != 0)\n-            throw new IOException (\"AlgIdDSA params, extra=\"+\n-                                   params.data.available ());\n+    public String getName() {\n+        return \"DSA\";\n@@ -179,1 +153,0 @@\n-\n@@ -200,0 +173,40 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream. Override to check\n+     * on the 'p', 'q', 'g', and 'encodedParams'.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream) throws IOException {\n+        try {\n+            stream.defaultReadObject();\n+            \/\/ if any of the 'p', 'q', 'g', 'encodedParams' is non-null,\n+            \/\/ then they must be all non-null w\/ matching encoding\n+            if ((p != null || q != null || g != null || encodedParams != null)\n+                    && !Arrays.equals(encodedParams, encode(p, q, g))) {\n+                throw new InvalidObjectException(\"Invalid DSA alg params\");\n+            }\n+        } catch (ClassNotFoundException e) {\n+            throw new IOException(e);\n+        }\n+    }\n+\n+    \/*\n+     * Create the DER encoding w\/ the specified 'p', 'q', 'g'\n+     *\/\n+    private static byte[] encode(BigInteger p, BigInteger q,\n+            BigInteger g) throws IOException {\n+        if (p == null || q == null || g == null) {\n+            throw new InvalidObjectException(\"invalid null value\");\n+        }\n+        DerOutputStream out = new DerOutputStream();\n+        out.putInteger(p);\n+        out.putInteger(q);\n+        out.putInteger(g);\n+        DerOutputStream result = new DerOutputStream();\n+        result.write(DerValue.tag_Sequence, out);\n+        return result.toByteArray();\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AlgIdDSA.java","additions":68,"deletions":55,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.x509;\n+\n+import sun.security.util.BitArray;\n+\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+import java.io.Serial;\n+import java.security.InvalidKeyException;\n+import java.security.KeyRep;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.ProviderException;\n+import java.security.spec.NamedParameterSpec;\n+\n+\/\/\/ Represents a public key from an algorithm family that is specialized\n+\/\/\/ with a named parameter set.\n+\/\/\/\n+\/\/\/ This key is generated by either a [sun.security.provider.NamedKeyPairGenerator]\n+\/\/\/ or [sun.security.provider.NamedKeyFactory]. Its [#getAlgorithm] method\n+\/\/\/ returns the algorithm family name, while its [#getParams()] method returns\n+\/\/\/ the parameter set name as a [NamedParameterSpec] object. The algorithm\n+\/\/\/ identifier in the X.509 encoding of the key is always a single OID derived\n+\/\/\/ from the parameter set name.\n+\/\/\/\n+\/\/\/ @see sun.security.provider.NamedKeyPairGenerator\n+public final class NamedX509Key extends X509Key {\n+    @Serial\n+    private static final long serialVersionUID = 1L;\n+\n+    private final String fname;\n+    private final transient NamedParameterSpec paramSpec;\n+    private final byte[] rawBytes;\n+\n+    \/\/\/ Ctor from family name, parameter set name, raw key bytes.\n+    \/\/\/ Key bytes won't be cloned, caller must relinquish ownership\n+    public NamedX509Key(String fname, String pname, byte[] rawBytes) {\n+        this.fname = fname;\n+        this.paramSpec = new NamedParameterSpec(pname);\n+        try {\n+            this.algid = AlgorithmId.get(pname);\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new ProviderException(e);\n+        }\n+        this.rawBytes = rawBytes;\n+\n+        setKey(new BitArray(rawBytes.length * 8, rawBytes));\n+    }\n+\n+    \/\/\/ Ctor from family name, and X.509 bytes\n+    public NamedX509Key(String fname, byte[] encoded) throws InvalidKeyException {\n+        this.fname = fname;\n+        decode(encoded);\n+        this.paramSpec = new NamedParameterSpec(algid.getName());\n+        if (algid.encodedParams != null) {\n+            throw new InvalidKeyException(\"algorithm identifier has params\");\n+        }\n+        this.rawBytes = getKey().toByteArray();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        \/\/ Do not modify: this can be used by earlier JDKs that\n+        \/\/ do not have the getParams() method\n+        return paramSpec.getName() + \" public key\";\n+    }\n+\n+    \/\/\/ Returns the reference to the internal key. Caller must not modify\n+    \/\/\/ the content or keep a reference.\n+    public byte[] getRawBytes() {\n+        return rawBytes;\n+    }\n+\n+    @Override\n+    public NamedParameterSpec getParams() {\n+        return paramSpec;\n+    }\n+\n+    @Override\n+    public String getAlgorithm() {\n+        return fname;\n+    }\n+\n+    @java.io.Serial\n+    private Object writeReplace() throws java.io.ObjectStreamException {\n+        return new KeyRep(KeyRep.Type.PUBLIC, getAlgorithm(), getFormat(),\n+                getEncoded());\n+    }\n+\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"NamedX509Key keys are not directly deserializable\");\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/NamedX509Key.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -284,1 +284,0 @@\n-            aliases.put(\"HST\", \"Pacific\/Honolulu\");\n@@ -286,3 +285,2 @@\n-            zones.put(\"EST\", new ZoneInfo(\"EST\", -18000000));\n-            zones.put(\"MST\", new ZoneInfo(\"MST\", -25200000));\n-            zones.put(\"HST\", new ZoneInfo(\"HST\", -36000000));\n+            aliases.put(\"EST\", \"America\/Panama\");\n+            aliases.put(\"MST\", \"America\/Phoenix\");\n@@ -290,0 +288,1 @@\n+        aliases.put(\"HST\", \"Pacific\/Honolulu\");\n","filename":"src\/java.base\/share\/classes\/sun\/util\/calendar\/ZoneInfoFile.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -133,0 +133,17 @@\n+\n+#\n+# Maximum HTTP field section size that a client is prepared to accept\n+#\n+# jdk.http.maxHeaderSize=393216\n+#\n+# This is the maximum header field section size that a client is prepared to accept.\n+# This is computed as the sum of the size of the uncompressed header name, plus\n+# the size of the uncompressed header value, plus an overhead of 32 bytes for\n+# each field section line. If a peer sends a field section that exceeds this\n+# size a {@link java.net.ProtocolException ProtocolException} will be raised.\n+# This applies to all versions of the HTTP protocol. A value of zero or a negative\n+# value means no limit. If left unspecified, the default value is 393216 bytes\n+# or 384kB.\n+#\n+# Note: This property is currently used by the JDK Reference implementation. It\n+# is not guaranteed to be examined and used by other implementations.\n","filename":"src\/java.base\/share\/conf\/net.properties","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-tzdata2024a\n+tzdata2024b\n","filename":"src\/java.base\/share\/data\/tzdata\/VERSION","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -129,4 +129,3 @@\n-# From Paul Eggert (2018-02-16):\n-# Shanks gives 1907 for the transition to +02.\n-# For now, ignore that and follow the 1911-05-26 Portuguese decree\n-# (see Europe\/Lisbon).\n+# From Tim Parenti (2024-07-01), per Paul Eggert (2018-02-16):\n+# For timestamps before independence, see commentary for Europe\/Lisbon.\n+# Shanks gives 1907 instead for the transition to -02.\n@@ -136,4 +135,4 @@\n-\t\t\t-2:00\t-\t-02\t1942 Sep\n-\t\t\t-2:00\t1:00\t-01\t1945 Oct 15\n-\t\t\t-2:00\t-\t-02\t1975 Nov 25  2:00\n-\t\t\t-1:00\t-\t-01\n+\t\t\t-2:00\t-\t%z\t1942 Sep\n+\t\t\t-2:00\t1:00\t%z\t1945 Oct 15\n+\t\t\t-2:00\t-\t%z\t1975 Nov 25  2:00\n+\t\t\t-1:00\t-\t%z\n@@ -371,4 +370,2 @@\n-# From Paul Eggert (2018-02-16):\n-# Shanks gives 1911-05-26 for the transition to WAT,\n-# evidently confusing the date of the Portuguese decree\n-# (see Europe\/Lisbon) with the date that it took effect.\n+# From Tim Parenti (2024-07-01), per Paul Eggert (2018-02-16):\n+# For timestamps before independence, see commentary for Europe\/Lisbon.\n@@ -378,1 +375,1 @@\n-\t\t\t-1:00\t-\t-01\t1975\n+\t\t\t-1:00\t-\t%z\t1975\n@@ -443,1 +440,1 @@\n-\t\t\t2:30\t-\t+0230\t1928 Jun 30 24:00\n+\t\t\t2:30\t-\t%z\t1928 Jun 30 24:00\n@@ -445,2 +442,2 @@\n-\t\t\t2:30\t-\t+0230\t1936 Dec 31 24:00\n-\t\t\t2:45\t-\t+0245\t1942 Jul 31 24:00\n+\t\t\t2:30\t-\t%z\t1936 Dec 31 24:00\n+\t\t\t2:45\t-\t%z\t1942 Jul 31 24:00\n@@ -617,1 +614,1 @@\n-\t\t\t4:00 Mauritius\t+04\/+05\n+\t\t\t4:00 Mauritius\t%z\n@@ -1097,4 +1094,4 @@\n-\t\t\t 0:00\tMorocco\t+00\/+01\t1984 Mar 16\n-\t\t\t 1:00\t-\t+01\t1986\n-\t\t\t 0:00\tMorocco\t+00\/+01\t2018 Oct 28  3:00\n-\t\t\t 1:00\tMorocco\t+01\/+00\n+\t\t\t 0:00\tMorocco\t%z\t1984 Mar 16\n+\t\t\t 1:00\t-\t%z\t1986\n+\t\t\t 0:00\tMorocco\t%z\t2018 Oct 28  3:00\n+\t\t\t 1:00\tMorocco\t%z\n@@ -1114,3 +1111,3 @@\n-\t\t\t-1:00\t-\t-01\t1976 Apr 14\n-\t\t\t 0:00\tMorocco\t+00\/+01\t2018 Oct 28  3:00\n-\t\t\t 1:00\tMorocco\t+01\/+00\n+\t\t\t-1:00\t-\t%z\t1976 Apr 14\n+\t\t\t 0:00\tMorocco\t%z\t2018 Oct 28  3:00\n+\t\t\t 1:00\tMorocco\t%z\n@@ -1127,4 +1124,17 @@\n-# Shanks gives 1903-03-01 for the transition to CAT.\n-# Perhaps the 1911-05-26 Portuguese decree\n-# https:\/\/dre.pt\/pdf1sdip\/1911\/05\/12500\/23132313.pdf\n-# merely made it official?\n+# From Tim Parenti (2024-07-01):\n+# For timestamps before Mozambique's independence, see commentary for\n+# Europe\/Lisbon.\n+#\n+# From Paul Eggert (2024-05-24):\n+# The London Gazette, 1903-04-03, page 2245, says that\n+# as of 1903-03-03 a time ball at the port of Loureno Marques\n+# (as Maputo was then called) was dropped daily at 13:00:00 LMT,\n+# corresponding to 22:49:41.7 GMT, so local time was +02:10:18.3.\n+# Conversely, the newspaper South Africa, 1909-02-09, page 321,\n+# says the port had just installed an apparatus that communicated\n+# \"from the controlling clock in the new Observatory at Reuben Point ...\n+# exact mean South African time, i.e., 30 deg., or 2 hours East of Greenwich\".\n+# Although Shanks gives 1903-03-01 for the transition to CAT,\n+# evidently the port transitioned to CAT after 1903-03-03 but before\n+# the Portuguese legal transition of 1912-01-01 (see Europe\/Lisbon commentary).\n+# For lack of better info, list 1909 as the transition date.\n@@ -1133,1 +1143,2 @@\n-Zone\tAfrica\/Maputo\t2:10:20 -\tLMT\t1903 Mar\n+\t\t#STDOFF\t2:10:18.3\n+Zone\tAfrica\/Maputo\t2:10:18 -\tLMT\t1909\n@@ -1198,1 +1209,1 @@\n-\t\t\t1:30\t-\t+0130\t1903 Mar\n+\t\t\t1:30\t-\t%z\t1903 Mar\n@@ -1286,1 +1297,1 @@\n-\t\t\t0:30\t-\t+0030\t1919 Sep  1\n+\t\t\t0:30\t-\t%z\t1919 Sep  1\n","filename":"src\/java.base\/share\/data\/tzdata\/africa","additions":42,"deletions":31,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -113,17 +113,17 @@\n-\t\t\t 8:00\t-\t+08\t2009 Oct 18  2:00\n-\t\t\t11:00\t-\t+11\t2010 Mar  5  2:00\n-\t\t\t 8:00\t-\t+08\t2011 Oct 28  2:00\n-\t\t\t11:00\t-\t+11\t2012 Feb 21 17:00u\n-\t\t\t 8:00\t-\t+08\t2016 Oct 22\n-\t\t\t11:00\t-\t+11\t2018 Mar 11  4:00\n-\t\t\t 8:00\t-\t+08\t2018 Oct  7  4:00\n-\t\t\t11:00\t-\t+11\t2019 Mar 17  3:00\n-\t\t\t 8:00\t-\t+08\t2019 Oct  4  3:00\n-\t\t\t11:00\t-\t+11\t2020 Mar  8  3:00\n-\t\t\t 8:00\t-\t+08\t2020 Oct  4  0:01\n-\t\t\t11:00\t-\t+11\t2021 Mar 14  0:00\n-\t\t\t 8:00\t-\t+08\t2021 Oct  3  0:01\n-\t\t\t11:00\t-\t+11\t2022 Mar 13  0:00\n-\t\t\t 8:00\t-\t+08\t2022 Oct  2  0:01\n-\t\t\t11:00\t-\t+11\t2023 Mar  9  3:00\n-\t\t\t 8:00\t-\t+08\n+\t\t\t 8:00\t-\t%z\t2009 Oct 18  2:00\n+\t\t\t11:00\t-\t%z\t2010 Mar  5  2:00\n+\t\t\t 8:00\t-\t%z\t2011 Oct 28  2:00\n+\t\t\t11:00\t-\t%z\t2012 Feb 21 17:00u\n+\t\t\t 8:00\t-\t%z\t2016 Oct 22\n+\t\t\t11:00\t-\t%z\t2018 Mar 11  4:00\n+\t\t\t 8:00\t-\t%z\t2018 Oct  7  4:00\n+\t\t\t11:00\t-\t%z\t2019 Mar 17  3:00\n+\t\t\t 8:00\t-\t%z\t2019 Oct  4  3:00\n+\t\t\t11:00\t-\t%z\t2020 Mar  8  3:00\n+\t\t\t 8:00\t-\t%z\t2020 Oct  4  0:01\n+\t\t\t11:00\t-\t%z\t2021 Mar 14  0:00\n+\t\t\t 8:00\t-\t%z\t2021 Oct  3  0:01\n+\t\t\t11:00\t-\t%z\t2022 Mar 13  0:00\n+\t\t\t 8:00\t-\t%z\t2022 Oct  2  0:01\n+\t\t\t11:00\t-\t%z\t2023 Mar  9  3:00\n+\t\t\t 8:00\t-\t%z\n@@ -131,1 +131,1 @@\n-\t\t\t7:00\t-\t+07\t1964 Nov\n+\t\t\t7:00\t-\t%z\t1964 Nov\n@@ -133,5 +133,5 @@\n-\t\t\t7:00\t-\t+07\t2009 Oct 18  2:00\n-\t\t\t5:00\t-\t+05\t2010 Mar 10 20:00u\n-\t\t\t7:00\t-\t+07\t2011 Oct 28  2:00\n-\t\t\t5:00\t-\t+05\t2012 Feb 21 20:00u\n-\t\t\t7:00\t-\t+07\n+\t\t\t7:00\t-\t%z\t2009 Oct 18  2:00\n+\t\t\t5:00\t-\t%z\t2010 Mar 10 20:00u\n+\t\t\t7:00\t-\t%z\t2011 Oct 28  2:00\n+\t\t\t5:00\t-\t%z\t2012 Feb 21 20:00u\n+\t\t\t7:00\t-\t%z\n@@ -139,2 +139,2 @@\n-\t\t\t6:00\t-\t+06\t2009 Oct 18  2:00\n-\t\t\t5:00\t-\t+05\n+\t\t\t6:00\t-\t%z\t2009 Oct 18  2:00\n+\t\t\t5:00\t-\t%z\n@@ -316,1 +316,1 @@\n-\t\t\t7:00\t-\t+07\t1994 Feb\n+\t\t\t7:00\t-\t%z\t1994 Feb\n@@ -318,2 +318,2 @@\n-\t\t\t7:00\t-\t+07\t2023 Dec 18  2:00\n-\t\t\t5:00\t-\t+05\n+\t\t\t7:00\t-\t%z\t2023 Dec 18  2:00\n+\t\t\t5:00\t-\t%z\n@@ -352,1 +352,1 @@\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-3:00\t-\t%z\n","filename":"src\/java.base\/share\/data\/tzdata\/antarctica","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -109,2 +109,2 @@\n-\t\t\t4:00\t-\t+04\t1945\n-\t\t\t4:30\t-\t+0430\n+\t\t\t4:00\t-\t%z\t1945\n+\t\t\t4:30\t-\t%z\n@@ -142,6 +142,6 @@\n-\t\t\t3:00\t-\t+03\t1957 Mar\n-\t\t\t4:00 RussiaAsia +04\/+05\t1991 Mar 31  2:00s\n-\t\t\t3:00 RussiaAsia\t+03\/+04\t1995 Sep 24  2:00s\n-\t\t\t4:00\t-\t+04\t1997\n-\t\t\t4:00 RussiaAsia\t+04\/+05\t2011\n-\t\t\t4:00\tArmenia\t+04\/+05\n+\t\t\t3:00\t-\t%z\t1957 Mar\n+\t\t\t4:00 RussiaAsia %z\t1991 Mar 31  2:00s\n+\t\t\t3:00 RussiaAsia\t%z\t1995 Sep 24  2:00s\n+\t\t\t4:00\t-\t%z\t1997\n+\t\t\t4:00 RussiaAsia\t%z\t2011\n+\t\t\t4:00\tArmenia\t%z\n@@ -168,6 +168,6 @@\n-\t\t\t3:00\t-\t+03\t1957 Mar\n-\t\t\t4:00 RussiaAsia +04\/+05\t1991 Mar 31  2:00s\n-\t\t\t3:00 RussiaAsia\t+03\/+04\t1992 Sep lastSun  2:00s\n-\t\t\t4:00\t-\t+04\t1996\n-\t\t\t4:00\tEUAsia\t+04\/+05\t1997\n-\t\t\t4:00\tAzer\t+04\/+05\n+\t\t\t3:00\t-\t%z\t1957 Mar\n+\t\t\t4:00 RussiaAsia %z\t1991 Mar 31  2:00s\n+\t\t\t3:00 RussiaAsia\t%z\t1992 Sep lastSun  2:00s\n+\t\t\t4:00\t-\t%z\t1996\n+\t\t\t4:00\tEUAsia\t%z\t1997\n+\t\t\t4:00\tAzer\t%z\n@@ -254,5 +254,5 @@\n-\t\t\t6:30\t-\t+0630\t1942 May 15\n-\t\t\t5:30\t-\t+0530\t1942 Sep\n-\t\t\t6:30\t-\t+0630\t1951 Sep 30\n-\t\t\t6:00\t-\t+06\t2009\n-\t\t\t6:00\tDhaka\t+06\/+07\n+\t\t\t6:30\t-\t%z\t1942 May 15\n+\t\t\t5:30\t-\t%z\t1942 Sep\n+\t\t\t6:30\t-\t%z\t1951 Sep 30\n+\t\t\t6:00\t-\t%z\t2009\n+\t\t\t6:00\tDhaka\t%z\n@@ -263,2 +263,2 @@\n-\t\t\t5:30\t-\t+0530\t1987 Oct\n-\t\t\t6:00\t-\t+06\n+\t\t\t5:30\t-\t%z\t1987 Oct\n+\t\t\t6:00\t-\t%z\n@@ -274,2 +274,2 @@\n-\t\t\t5:00\t-\t+05\t1996\n-\t\t\t6:00\t-\t+06\n+\t\t\t5:00\t-\t%z\t1996\n+\t\t\t6:00\t-\t%z\n@@ -291,3 +291,3 @@\n-\t\t\t6:30\t-\t+0630\t1942 May\n-\t\t\t9:00\t-\t+09\t1945 May  3\n-\t\t\t6:30\t-\t+0630\n+\t\t\t6:30\t-\t%z\t1942 May\n+\t\t\t9:00\t-\t%z\t1945 May  3\n+\t\t\t6:30\t-\t%z\n@@ -682,1 +682,1 @@\n-\t\t\t6:00\t-\t+06\n+\t\t\t6:00\t-\t%z\n@@ -1140,1 +1140,1 @@\n-\t\t\t9:00\tMacau\t+09\/+10\t1945 Sep 30 24:00\n+\t\t\t9:00\tMacau\t%z\t1945 Sep 30 24:00\n@@ -1183,1 +1183,1 @@\n-\t\t\t3:00\t-\t+03\t2017 Oct 29 1:00u\n+\t\t\t3:00\t-\t%z\t2017 Oct 29 1:00u\n@@ -1224,9 +1224,9 @@\n-\t\t\t3:00\t-\t+03\t1957 Mar\n-\t\t\t4:00 RussiaAsia +04\/+05\t1991 Mar 31  2:00s\n-\t\t\t3:00 RussiaAsia +03\/+04\t1992\n-\t\t\t3:00 E-EurAsia\t+03\/+04\t1994 Sep lastSun\n-\t\t\t4:00 E-EurAsia\t+04\/+05\t1996 Oct lastSun\n-\t\t\t4:00\t1:00\t+05\t1997 Mar lastSun\n-\t\t\t4:00 E-EurAsia\t+04\/+05\t2004 Jun 27\n-\t\t\t3:00 RussiaAsia\t+03\/+04\t2005 Mar lastSun  2:00\n-\t\t\t4:00\t-\t+04\n+\t\t\t3:00\t-\t%z\t1957 Mar\n+\t\t\t4:00 RussiaAsia %z\t1991 Mar 31  2:00s\n+\t\t\t3:00 RussiaAsia %z\t1992\n+\t\t\t3:00 E-EurAsia\t%z\t1994 Sep lastSun\n+\t\t\t4:00 E-EurAsia\t%z\t1996 Oct lastSun\n+\t\t\t4:00\t1:00\t%z\t1997 Mar lastSun\n+\t\t\t4:00 E-EurAsia\t%z\t2004 Jun 27\n+\t\t\t3:00 RussiaAsia\t%z\t2005 Mar lastSun  2:00\n+\t\t\t4:00\t-\t%z\n@@ -1236,0 +1236,7 @@\n+# From Tim Parenti (2024-07-01):\n+# The 1912-01-01 transition occurred at 00:00 new time, per the 1911-05-24\n+# Portuguese decree (see Europe\/Lisbon).  A provision in article 5(c) of the\n+# decree prescribed that Timor \"will keep counting time in harmony with\n+# neighboring foreign colonies, [for] as long as they do not adopt the time\n+# that belongs to them in [the Washington Convention] system.\"\n+\n@@ -1259,5 +1266,5 @@\n-Zone\tAsia\/Dili\t8:22:20 -\tLMT\t1912 Jan  1\n-\t\t\t8:00\t-\t+08\t1942 Feb 21 23:00\n-\t\t\t9:00\t-\t+09\t1976 May  3\n-\t\t\t8:00\t-\t+08\t2000 Sep 17  0:00\n-\t\t\t9:00\t-\t+09\n+Zone\tAsia\/Dili\t8:22:20 -\tLMT\t1911 Dec 31 16:00u\n+\t\t\t8:00\t-\t%z\t1942 Feb 21 23:00\n+\t\t\t9:00\t-\t%z\t1976 May  3\n+\t\t\t8:00\t-\t%z\t2000 Sep 17  0:00\n+\t\t\t9:00\t-\t%z\n@@ -1329,1 +1336,1 @@\n-\t\t\t5:30\t1:00\t+0630\t1942 May 15\n+\t\t\t5:30\t1:00\t%z\t1942 May 15\n@@ -1331,1 +1338,1 @@\n-\t\t\t5:30\t1:00\t+0630\t1945 Oct 15\n+\t\t\t5:30\t1:00\t%z\t1945 Oct 15\n@@ -1383,6 +1390,6 @@\n-\t\t\t7:20\t-\t+0720\t1932 Nov\n-\t\t\t7:30\t-\t+0730\t1942 Mar 23\n-\t\t\t9:00\t-\t+09\t1945 Sep 23\n-\t\t\t7:30\t-\t+0730\t1948 May\n-\t\t\t8:00\t-\t+08\t1950 May\n-\t\t\t7:30\t-\t+0730\t1964\n+\t\t\t7:20\t-\t%z\t1932 Nov\n+\t\t\t7:30\t-\t%z\t1942 Mar 23\n+\t\t\t9:00\t-\t%z\t1945 Sep 23\n+\t\t\t7:30\t-\t%z\t1948 May\n+\t\t\t8:00\t-\t%z\t1950 May\n+\t\t\t7:30\t-\t%z\t1964\n@@ -1393,5 +1400,5 @@\n-\t\t\t7:30\t-\t+0730\t1942 Jan 29\n-\t\t\t9:00\t-\t+09\t1945 Sep 23\n-\t\t\t7:30\t-\t+0730\t1948 May\n-\t\t\t8:00\t-\t+08\t1950 May\n-\t\t\t7:30\t-\t+0730\t1964\n+\t\t\t7:30\t-\t%z\t1942 Jan 29\n+\t\t\t9:00\t-\t%z\t1945 Sep 23\n+\t\t\t7:30\t-\t%z\t1948 May\n+\t\t\t8:00\t-\t%z\t1950 May\n+\t\t\t7:30\t-\t%z\t1964\n@@ -1403,2 +1410,2 @@\n-\t\t\t8:00\t-\t+08\t1942 Feb  9\n-\t\t\t9:00\t-\t+09\t1945 Sep 23\n+\t\t\t8:00\t-\t%z\t1942 Feb  9\n+\t\t\t9:00\t-\t%z\t1945 Sep 23\n@@ -1408,2 +1415,2 @@\n-\t\t\t9:00\t-\t+09\t1944 Sep  1\n-\t\t\t9:30\t-\t+0930\t1964\n+\t\t\t9:00\t-\t%z\t1944 Sep  1\n+\t\t\t9:30\t-\t%z\t1964\n@@ -1645,3 +1652,3 @@\n-\t\t\t3:30\tIran\t+0330\/+0430 1977 Oct 20 24:00\n-\t\t\t4:00\tIran\t+04\/+05\t1979\n-\t\t\t3:30\tIran\t+0330\/+0430\n+\t\t\t3:30\tIran\t%z\t1977 Oct 20 24:00\n+\t\t\t4:00\tIran\t%z\t1979\n+\t\t\t3:30\tIran\t%z\n@@ -1690,2 +1697,2 @@\n-\t\t\t3:00\t-\t+03\t1982 May\n-\t\t\t3:00\tIraq\t+03\/+04\n+\t\t\t3:00\t-\t%z\t1982 May\n+\t\t\t3:00\tIraq\t%z\n@@ -2288,1 +2295,1 @@\n-\t\t\t3:00\t-\t+03\n+\t\t\t3:00\t-\t%z\n@@ -2499,1 +2506,1 @@\n-# East Kazkhstan (KZ-63), Jambyl\/Zhambyl (KZ-31), Jetisu\/Zhetysu (KZ-33),\n+# East Kazakhstan (KZ-63), Jambyl\/Zhambyl (KZ-31), Jetisu\/Zhetysu (KZ-33),\n@@ -2501,1 +2508,1 @@\n-# Shyumkent city (KZ-79), Turkistan (KZ-61), and Ulytau (KZ-62).\n+# Shymkent city (KZ-79), Turkistan (KZ-61), and Ulytau (KZ-62).\n@@ -2503,6 +2510,6 @@\n-\t\t\t5:00\t-\t+05\t1930 Jun 21\n-\t\t\t6:00 RussiaAsia +06\/+07\t1991 Mar 31  2:00s\n-\t\t\t5:00 RussiaAsia\t+05\/+06\t1992 Jan 19  2:00s\n-\t\t\t6:00 RussiaAsia\t+06\/+07\t2004 Oct 31  2:00s\n-\t\t\t6:00\t-\t+06\t2024 Mar  1  0:00\n-\t\t\t5:00\t-\t+05\n+\t\t\t5:00\t-\t%z\t1930 Jun 21\n+\t\t\t6:00 RussiaAsia %z\t1991 Mar 31  2:00s\n+\t\t\t5:00 RussiaAsia\t%z\t1992 Jan 19  2:00s\n+\t\t\t6:00 RussiaAsia\t%z\t2004 Oct 31  2:00s\n+\t\t\t6:00\t-\t%z\t2024 Mar  1  0:00\n+\t\t\t5:00\t-\t%z\n@@ -2511,11 +2518,11 @@\n-\t\t\t4:00\t-\t+04\t1930 Jun 21\n-\t\t\t5:00\t-\t+05\t1981 Apr  1\n-\t\t\t5:00\t1:00\t+06\t1981 Oct  1\n-\t\t\t6:00\t-\t+06\t1982 Apr  1\n-\t\t\t5:00 RussiaAsia\t+05\/+06\t1991 Mar 31  2:00s\n-\t\t\t4:00 RussiaAsia\t+04\/+05\t1991 Sep 29  2:00s\n-\t\t\t5:00 RussiaAsia\t+05\/+06\t1992 Jan 19  2:00s\n-\t\t\t6:00 RussiaAsia\t+06\/+07\t1992 Mar 29  2:00s\n-\t\t\t5:00 RussiaAsia\t+05\/+06\t2004 Oct 31  2:00s\n-\t\t\t6:00\t-\t+06\t2018 Dec 21  0:00\n-\t\t\t5:00\t-\t+05\n+\t\t\t4:00\t-\t%z\t1930 Jun 21\n+\t\t\t5:00\t-\t%z\t1981 Apr  1\n+\t\t\t5:00\t1:00\t%z\t1981 Oct  1\n+\t\t\t6:00\t-\t%z\t1982 Apr  1\n+\t\t\t5:00 RussiaAsia\t%z\t1991 Mar 31  2:00s\n+\t\t\t4:00 RussiaAsia\t%z\t1991 Sep 29  2:00s\n+\t\t\t5:00 RussiaAsia\t%z\t1992 Jan 19  2:00s\n+\t\t\t6:00 RussiaAsia\t%z\t1992 Mar 29  2:00s\n+\t\t\t5:00 RussiaAsia\t%z\t2004 Oct 31  2:00s\n+\t\t\t6:00\t-\t%z\t2018 Dec 21  0:00\n+\t\t\t5:00\t-\t%z\n@@ -2526,9 +2533,9 @@\n-\t\t\t4:00\t-\t+04\t1930 Jun 21\n-\t\t\t5:00\t-\t+05\t1981 Apr  1\n-\t\t\t5:00\t1:00\t+06\t1981 Oct  1\n-\t\t\t6:00\t-\t+06\t1982 Apr  1\n-\t\t\t5:00 RussiaAsia\t+05\/+06\t1991 Mar 31  2:00s\n-\t\t\t4:00 RussiaAsia\t+04\/+05\t1992 Jan 19  2:00s\n-\t\t\t5:00 RussiaAsia\t+05\/+06\t2004 Oct 31  2:00s\n-\t\t\t6:00\t-\t+06\t2024 Mar  1  0:00\n-\t\t\t5:00\t-\t+05\n+\t\t\t4:00\t-\t%z\t1930 Jun 21\n+\t\t\t5:00\t-\t%z\t1981 Apr  1\n+\t\t\t5:00\t1:00\t%z\t1981 Oct  1\n+\t\t\t6:00\t-\t%z\t1982 Apr  1\n+\t\t\t5:00 RussiaAsia\t%z\t1991 Mar 31  2:00s\n+\t\t\t4:00 RussiaAsia\t%z\t1992 Jan 19  2:00s\n+\t\t\t5:00 RussiaAsia\t%z\t2004 Oct 31  2:00s\n+\t\t\t6:00\t-\t%z\t2024 Mar  1  0:00\n+\t\t\t5:00\t-\t%z\n@@ -2537,8 +2544,8 @@\n-\t\t\t4:00\t-\t+04\t1930 Jun 21\n-\t\t\t5:00\t-\t+05\t1981 Apr  1\n-\t\t\t5:00\t1:00\t+06\t1981 Oct  1\n-\t\t\t6:00\t-\t+06\t1982 Apr  1\n-\t\t\t5:00 RussiaAsia\t+05\/+06\t1991 Mar 31  2:00s\n-\t\t\t4:00 RussiaAsia\t+04\/+05\t1992 Jan 19  2:00s\n-\t\t\t5:00 RussiaAsia\t+05\/+06\t2004 Oct 31  2:00s\n-\t\t\t5:00\t-\t+05\n+\t\t\t4:00\t-\t%z\t1930 Jun 21\n+\t\t\t5:00\t-\t%z\t1981 Apr  1\n+\t\t\t5:00\t1:00\t%z\t1981 Oct  1\n+\t\t\t6:00\t-\t%z\t1982 Apr  1\n+\t\t\t5:00 RussiaAsia\t%z\t1991 Mar 31  2:00s\n+\t\t\t4:00 RussiaAsia\t%z\t1992 Jan 19  2:00s\n+\t\t\t5:00 RussiaAsia\t%z\t2004 Oct 31  2:00s\n+\t\t\t5:00\t-\t%z\n@@ -2549,8 +2556,8 @@\n-\t\t\t4:00\t-\t+04\t1930 Jun 21\n-\t\t\t5:00\t-\t+05\t1981 Oct  1\n-\t\t\t6:00\t-\t+06\t1982 Apr  1\n-\t\t\t5:00 RussiaAsia\t+05\/+06\t1991 Mar 31  2:00s\n-\t\t\t4:00 RussiaAsia\t+04\/+05\t1992 Jan 19  2:00s\n-\t\t\t5:00 RussiaAsia\t+05\/+06\t1994 Sep 25  2:00s\n-\t\t\t4:00 RussiaAsia\t+04\/+05\t2004 Oct 31  2:00s\n-\t\t\t5:00\t-\t+05\n+\t\t\t4:00\t-\t%z\t1930 Jun 21\n+\t\t\t5:00\t-\t%z\t1981 Oct  1\n+\t\t\t6:00\t-\t%z\t1982 Apr  1\n+\t\t\t5:00 RussiaAsia\t%z\t1991 Mar 31  2:00s\n+\t\t\t4:00 RussiaAsia\t%z\t1992 Jan 19  2:00s\n+\t\t\t5:00 RussiaAsia\t%z\t1994 Sep 25  2:00s\n+\t\t\t4:00 RussiaAsia\t%z\t2004 Oct 31  2:00s\n+\t\t\t5:00\t-\t%z\n@@ -2560,8 +2567,8 @@\n-\t\t\t3:00\t-\t+03\t1930 Jun 21\n-\t\t\t5:00\t-\t+05\t1981 Oct  1\n-\t\t\t6:00\t-\t+06\t1982 Apr  1\n-\t\t\t5:00 RussiaAsia\t+05\/+06\t1991 Mar 31  2:00s\n-\t\t\t4:00 RussiaAsia\t+04\/+05\t1992 Jan 19  2:00s\n-\t\t\t5:00 RussiaAsia\t+05\/+06\t1999 Mar 28  2:00s\n-\t\t\t4:00 RussiaAsia\t+04\/+05\t2004 Oct 31  2:00s\n-\t\t\t5:00\t-\t+05\n+\t\t\t3:00\t-\t%z\t1930 Jun 21\n+\t\t\t5:00\t-\t%z\t1981 Oct  1\n+\t\t\t6:00\t-\t%z\t1982 Apr  1\n+\t\t\t5:00 RussiaAsia\t%z\t1991 Mar 31  2:00s\n+\t\t\t4:00 RussiaAsia\t%z\t1992 Jan 19  2:00s\n+\t\t\t5:00 RussiaAsia\t%z\t1999 Mar 28  2:00s\n+\t\t\t4:00 RussiaAsia\t%z\t2004 Oct 31  2:00s\n+\t\t\t5:00\t-\t%z\n@@ -2572,9 +2579,9 @@\n-\t\t\t3:00\t-\t+03\t1930 Jun 21\n-\t\t\t5:00\t-\t+05\t1981 Apr  1\n-\t\t\t5:00\t1:00\t+06\t1981 Oct  1\n-\t\t\t6:00\t-\t+06\t1982 Apr  1\n-\t\t\t5:00 RussiaAsia\t+05\/+06\t1989 Mar 26  2:00s\n-\t\t\t4:00 RussiaAsia\t+04\/+05\t1992 Jan 19  2:00s\n-\t\t\t5:00 RussiaAsia\t+05\/+06\t1992 Mar 29  2:00s\n-\t\t\t4:00 RussiaAsia\t+04\/+05\t2004 Oct 31  2:00s\n-\t\t\t5:00\t-\t+05\n+\t\t\t3:00\t-\t%z\t1930 Jun 21\n+\t\t\t5:00\t-\t%z\t1981 Apr  1\n+\t\t\t5:00\t1:00\t%z\t1981 Oct  1\n+\t\t\t6:00\t-\t%z\t1982 Apr  1\n+\t\t\t5:00 RussiaAsia\t%z\t1989 Mar 26  2:00s\n+\t\t\t4:00 RussiaAsia\t%z\t1992 Jan 19  2:00s\n+\t\t\t5:00 RussiaAsia\t%z\t1992 Mar 29  2:00s\n+\t\t\t4:00 RussiaAsia\t%z\t2004 Oct 31  2:00s\n+\t\t\t5:00\t-\t%z\n@@ -2601,5 +2608,5 @@\n-\t\t\t5:00\t-\t+05\t1930 Jun 21\n-\t\t\t6:00 RussiaAsia +06\/+07\t1991 Mar 31  2:00s\n-\t\t\t5:00 RussiaAsia\t+05\/+06\t1991 Aug 31  2:00\n-\t\t\t5:00\tKyrgyz\t+05\/+06\t2005 Aug 12\n-\t\t\t6:00\t-\t+06\n+\t\t\t5:00\t-\t%z\t1930 Jun 21\n+\t\t\t6:00 RussiaAsia %z\t1991 Mar 31  2:00s\n+\t\t\t5:00 RussiaAsia\t%z\t1991 Aug 31  2:00\n+\t\t\t5:00\tKyrgyz\t%z\t2005 Aug 12\n+\t\t\t6:00\t-\t%z\n@@ -2812,4 +2819,4 @@\n-\t\t\t7:30\t-\t+0730\t1933\n-\t\t\t8:00 NBorneo  +08\/+0820\t1942 Feb 16\n-\t\t\t9:00\t-\t+09\t1945 Sep 12\n-\t\t\t8:00\t-\t+08\n+\t\t\t7:30\t-\t%z\t1933\n+\t\t\t8:00 NBorneo\t%z\t1942 Feb 16\n+\t\t\t9:00\t-\t%z\t1945 Sep 12\n+\t\t\t8:00\t-\t%z\n@@ -2821,1 +2828,1 @@\n-\t\t\t5:00\t-\t+05\n+\t\t\t5:00\t-\t%z\n@@ -2923,3 +2930,31 @@\n-# XXX--in the absence of better information, assume that transition\n-# was at the start of 2008-03-31 (the day of Steffen Thorsen's report);\n-# this is almost surely wrong.\n+\n+# From Heitor David Pinto (2024-06-23):\n+# Sources about time zones in Mongolia seem to list one of two conflicting\n+# configurations.  The first configuration, mentioned in a comment to the TZ\n+# database in 1999, citing a Mongolian government website, lists the provinces\n+# of Bayan-lgii, Khovd and Uvs in UTC+7, and the rest of the country in\n+# UTC+8.  The second configuration, mentioned in a comment to the database in\n+# 2001, lists Bayan-lgii, Khovd, Uvs, Govi-Altai and Zavkhan in UTC+7, Dornod\n+# and Skhbaatar in UTC+9, and the rest of the country in UTC+8.\n+#\n+# The first configuration is still mentioned by several Mongolian travel\n+# agencies:\n+# https:\/\/www.adventurerider.mn\/en\/page\/about_mongolia\n+# http:\/\/www.naturetours.mn\/nt\/mongolia.php\n+# https:\/\/www.newjuulchin.mn\/web\/content\/7506?unique=fa24a0f6e96e022a3578ee5195ac879638c734ce\n+#\n+# It also matches these flight schedules in 2013:\n+# http:\/\/web.archive.org\/web\/20130722023600\/https:\/\/www.hunnuair.com\/en\/timetabled\n+# The flight times imply that the airports of Uliastai (Zavkhan), Choibalsan\n+# (Dornod) and Altai (Govi-Altai) are in the same time zone as Ulaanbaatar,\n+# and Khovd is one hour behind....\n+#\n+# The second configuration was mentioned by an official of the Mongolian\n+# standards agency in an interview in 2014: https:\/\/ikon.mn\/n\/9v6\n+# And it's still listed by the Mongolian aviation agency:\n+# https:\/\/ais.mn\/files\/aip\/eAIP\/2023-12-25\/html\/eSUP\/ZM-eSUP-23-04-en-MN.html\n+#\n+# ... I believe that the first configuration is what is actually observed in\n+# Mongolia and has been so all along, at least since 1999.  The second\n+# configuration closely matches the ideal time zone boundaries at 97.5 E and\n+# 112.5 E but it doesn't seem to be used in practice.\n@@ -2964,2 +2999,2 @@\n-\t\t\t6:00\t-\t+06\t1978\n-\t\t\t7:00\tMongol\t+07\/+08\n+\t\t\t6:00\t-\t%z\t1978\n+\t\t\t7:00\tMongol\t%z\n@@ -2968,9 +3003,2 @@\n-\t\t\t7:00\t-\t+07\t1978\n-\t\t\t8:00\tMongol\t+08\/+09\n-# Choibalsan, a.k.a. Bajan Tmen, Bajan Tumen, Chojbalsan,\n-# Choybalsan, Sanbejse, Tchoibalsan\n-Zone\tAsia\/Choibalsan\t7:38:00 -\tLMT\t1905 Aug\n-\t\t\t7:00\t-\t+07\t1978\n-\t\t\t8:00\t-\t+08\t1983 Apr\n-\t\t\t9:00\tMongol\t+09\/+10\t2008 Mar 31\n-\t\t\t8:00\tMongol\t+08\/+09\n+\t\t\t7:00\t-\t%z\t1978\n+\t\t\t8:00\tMongol\t%z\n@@ -2981,2 +3009,2 @@\n-\t\t\t5:30\t-\t+0530\t1986\n-\t\t\t5:45\t-\t+0545\n+\t\t\t5:30\t-\t%z\t1986\n+\t\t\t5:45\t-\t%z\n@@ -3128,4 +3156,4 @@\n-\t\t\t5:30\t-\t+0530\t1942 Sep\n-\t\t\t5:30\t1:00\t+0630\t1945 Oct 15\n-\t\t\t5:30\t-\t+0530\t1951 Sep 30\n-\t\t\t5:00\t-\t+05\t1971 Mar 26\n+\t\t\t5:30\t-\t%z\t1942 Sep\n+\t\t\t5:30\t1:00\t%z\t1945 Oct 15\n+\t\t\t5:30\t-\t%z\t1951 Sep 30\n+\t\t\t5:00\t-\t%z\t1971 Mar 26\n@@ -3679,1 +3707,1 @@\n-# From Paul Goyette (2018-06-15):\n+# From Paul Goyette (2018-06-15) with URLs updated by Guy Harris (2024-02-15):\n@@ -3685,2 +3713,2 @@\n-# [1] http:\/\/www.officialgazette.gov.ph\/2013\/05\/15\/republic-act-no-10535\/\n-# [2] https:\/\/www1.pagasa.dost.gov.ph\/index.php\/astronomy\/philippine-standard-time#republic-act-10535\n+# [1] https:\/\/www.officialgazette.gov.ph\/2013\/05\/15\/republic-act-no-10535\/\n+# [2] https:\/\/prsd.pagasa.dost.gov.ph\/index.php\/28-astronomy\/302-philippine-standard-time\n@@ -3719,2 +3747,2 @@\n-\t\t\t4:00\t-\t+04\t1972 Jun\n-\t\t\t3:00\t-\t+03\n+\t\t\t4:00\t-\t%z\t1972 Jun\n+\t\t\t3:00\t-\t%z\n@@ -3770,1 +3798,1 @@\n-\t\t\t3:00\t-\t+03\n+\t\t\t3:00\t-\t%z\n@@ -3778,7 +3806,7 @@\n-\t\t\t7:00\t-\t+07\t1933 Jan  1\n-\t\t\t7:00\t0:20\t+0720\t1936 Jan  1\n-\t\t\t7:20\t-\t+0720\t1941 Sep  1\n-\t\t\t7:30\t-\t+0730\t1942 Feb 16\n-\t\t\t9:00\t-\t+09\t1945 Sep 12\n-\t\t\t7:30\t-\t+0730\t1981 Dec 31 16:00u\n-\t\t\t8:00\t-\t+08\n+\t\t\t7:00\t-\t%z\t1933 Jan  1\n+\t\t\t7:00\t0:20\t%z\t1936 Jan  1\n+\t\t\t7:20\t-\t%z\t1941 Sep  1\n+\t\t\t7:30\t-\t%z\t1942 Feb 16\n+\t\t\t9:00\t-\t%z\t1945 Sep 12\n+\t\t\t7:30\t-\t%z\t1981 Dec 31 16:00u\n+\t\t\t8:00\t-\t%z\n@@ -3842,7 +3870,7 @@\n-\t\t\t5:30\t-\t+0530\t1942 Jan  5\n-\t\t\t5:30\t0:30\t+06\t1942 Sep\n-\t\t\t5:30\t1:00\t+0630\t1945 Oct 16  2:00\n-\t\t\t5:30\t-\t+0530\t1996 May 25  0:00\n-\t\t\t6:30\t-\t+0630\t1996 Oct 26  0:30\n-\t\t\t6:00\t-\t+06\t2006 Apr 15  0:30\n-\t\t\t5:30\t-\t+0530\n+\t\t\t5:30\t-\t%z\t1942 Jan  5\n+\t\t\t5:30\t0:30\t%z\t1942 Sep\n+\t\t\t5:30\t1:00\t%z\t1945 Oct 16  2:00\n+\t\t\t5:30\t-\t%z\t1996 May 25  0:00\n+\t\t\t6:30\t-\t%z\t1996 Oct 26  0:30\n+\t\t\t6:00\t-\t%z\t2006 Apr 15  0:30\n+\t\t\t5:30\t-\t%z\n@@ -4019,1 +4047,1 @@\n-\t\t\t3:00\t-\t+03\n+\t\t\t3:00\t-\t%z\n@@ -4025,4 +4053,4 @@\n-\t\t\t5:00\t-\t+05\t1930 Jun 21\n-\t\t\t6:00 RussiaAsia +06\/+07\t1991 Mar 31  2:00s\n-\t\t\t5:00\t1:00\t+06\t1991 Sep  9  2:00s\n-\t\t\t5:00\t-\t+05\n+\t\t\t5:00\t-\t%z\t1930 Jun 21\n+\t\t\t6:00 RussiaAsia %z\t1991 Mar 31  2:00s\n+\t\t\t5:00\t1:00\t%z\t1991 Sep  9  2:00s\n+\t\t\t5:00\t-\t%z\n@@ -4038,1 +4066,1 @@\n-\t\t\t7:00\t-\t+07\n+\t\t\t7:00\t-\t%z\n@@ -4044,4 +4072,4 @@\n-\t\t\t4:00\t-\t+04\t1930 Jun 21\n-\t\t\t5:00 RussiaAsia\t+05\/+06\t1991 Mar 31  2:00\n-\t\t\t4:00 RussiaAsia\t+04\/+05\t1992 Jan 19  2:00\n-\t\t\t5:00\t-\t+05\n+\t\t\t4:00\t-\t%z\t1930 Jun 21\n+\t\t\t5:00 RussiaAsia\t%z\t1991 Mar 31  2:00\n+\t\t\t4:00 RussiaAsia\t%z\t1992 Jan 19  2:00\n+\t\t\t5:00\t-\t%z\n@@ -4057,1 +4085,1 @@\n-\t\t\t4:00\t-\t+04\n+\t\t\t4:00\t-\t%z\n@@ -4063,6 +4091,6 @@\n-\t\t\t4:00\t-\t+04\t1930 Jun 21\n-\t\t\t5:00\t-\t+05\t1981 Apr  1\n-\t\t\t5:00\t1:00\t+06\t1981 Oct  1\n-\t\t\t6:00\t-\t+06\t1982 Apr  1\n-\t\t\t5:00 RussiaAsia\t+05\/+06\t1992\n-\t\t\t5:00\t-\t+05\n+\t\t\t4:00\t-\t%z\t1930 Jun 21\n+\t\t\t5:00\t-\t%z\t1981 Apr  1\n+\t\t\t5:00\t1:00\t%z\t1981 Oct  1\n+\t\t\t6:00\t-\t%z\t1982 Apr  1\n+\t\t\t5:00 RussiaAsia\t%z\t1992\n+\t\t\t5:00\t-\t%z\n@@ -4072,4 +4100,4 @@\n-\t\t\t5:00\t-\t+05\t1930 Jun 21\n-\t\t\t6:00 RussiaAsia\t+06\/+07\t1991 Mar 31  2:00\n-\t\t\t5:00 RussiaAsia\t+05\/+06\t1992\n-\t\t\t5:00\t-\t+05\n+\t\t\t5:00\t-\t%z\t1930 Jun 21\n+\t\t\t6:00 RussiaAsia\t%z\t1991 Mar 31  2:00\n+\t\t\t5:00 RussiaAsia\t%z\t1992\n+\t\t\t5:00\t-\t%z\n@@ -4133,1 +4161,1 @@\n-# It also mentions a 1945-03-29 decree (by a Japanese Goveror-General)\n+# It also mentions a 1945-03-29 decree (by a Japanese Governor-General)\n@@ -4154,8 +4182,8 @@\n-\t\t\t7:00\t-\t+07\t1942 Dec 31 23:00\n-\t\t\t8:00\t-\t+08\t1945 Mar 14 23:00\n-\t\t\t9:00\t-\t+09\t1945 Sep  1 24:00\n-\t\t\t7:00\t-\t+07\t1947 Apr  1\n-\t\t\t8:00\t-\t+08\t1955 Jul  1 01:00\n-\t\t\t7:00\t-\t+07\t1959 Dec 31 23:00\n-\t\t\t8:00\t-\t+08\t1975 Jun 13\n-\t\t\t7:00\t-\t+07\n+\t\t\t7:00\t-\t%z\t1942 Dec 31 23:00\n+\t\t\t8:00\t-\t%z\t1945 Mar 14 23:00\n+\t\t\t9:00\t-\t%z\t1945 Sep  1 24:00\n+\t\t\t7:00\t-\t%z\t1947 Apr  1\n+\t\t\t8:00\t-\t%z\t1955 Jul  1 01:00\n+\t\t\t7:00\t-\t%z\t1959 Dec 31 23:00\n+\t\t\t8:00\t-\t%z\t1975 Jun 13\n+\t\t\t7:00\t-\t%z\n","filename":"src\/java.base\/share\/data\/tzdata\/asia","additions":235,"deletions":207,"binary":false,"changes":442,"status":"modified"},{"patch":"@@ -69,2 +69,2 @@\n-\t\t\t 8:45\tAus +0845\/+0945\t1943 Jul\n-\t\t\t 8:45\tAW  +0845\/+0945\n+\t\t\t 8:45\tAus\t%z\t1943 Jul\n+\t\t\t 8:45\tAW\t%z\n@@ -235,2 +235,2 @@\n-\t\t\t10:30\tLH\t+1030\/+1130 1985 Jul\n-\t\t\t10:30\tLH\t+1030\/+11\n+\t\t\t10:30\tLH\t%z\t1985 Jul\n+\t\t\t10:30\tLH\t%z\n@@ -442,1 +442,1 @@\n-\t\t\t12:00\tFiji\t+12\/+13\n+\t\t\t12:00\tFiji\t%z\n@@ -447,1 +447,1 @@\n-\t\t\t -9:00\t-\t-09\n+\t\t\t -9:00\t-\t%z\n@@ -449,1 +449,1 @@\n-\t\t\t -9:30\t-\t-0930\n+\t\t\t -9:30\t-\t%z\n@@ -451,1 +451,1 @@\n-\t\t\t-10:00\t-\t-10\n+\t\t\t-10:00\t-\t%z\n@@ -494,1 +494,1 @@\n-\t\t\t 9:00\t-\t+09\t1944 Jul 31\n+\t\t\t 9:00\t-\t%z\t1944 Jul 31\n@@ -506,1 +506,1 @@\n-\t\t\t 12:00\t-\t+12\n+\t\t\t 12:00\t-\t%z\n@@ -512,3 +512,3 @@\n-\t\t\t-12:00\t-\t-12\t1979 Oct\n-\t\t\t-11:00\t-\t-11\t1994 Dec 31\n-\t\t\t 13:00\t-\t+13\n+\t\t\t-12:00\t-\t%z\t1979 Oct\n+\t\t\t-11:00\t-\t%z\t1994 Dec 31\n+\t\t\t 13:00\t-\t%z\n@@ -516,3 +516,3 @@\n-\t\t\t-10:40\t-\t-1040\t1979 Oct\n-\t\t\t-10:00\t-\t-10\t1994 Dec 31\n-\t\t\t 14:00\t-\t+14\n+\t\t\t-10:40\t-\t%z\t1979 Oct\n+\t\t\t-10:00\t-\t%z\t1994 Dec 31\n+\t\t\t 14:00\t-\t%z\n@@ -524,6 +524,6 @@\n-\t\t\t 11:00\t-\t+11\t1937\n-\t\t\t 10:00\t-\t+10\t1941 Apr  1\n-\t\t\t  9:00\t-\t+09\t1944 Feb  6\n-\t\t\t 11:00\t-\t+11\t1969 Oct\n-\t\t\t-12:00\t-\t-12\t1993 Aug 20 24:00\n-\t\t\t 12:00\t-\t+12\n+\t\t\t 11:00\t-\t%z\t1937\n+\t\t\t 10:00\t-\t%z\t1941 Apr  1\n+\t\t\t  9:00\t-\t%z\t1944 Feb  6\n+\t\t\t 11:00\t-\t%z\t1969 Oct\n+\t\t\t-12:00\t-\t%z\t1993 Aug 20 24:00\n+\t\t\t 12:00\t-\t%z\n@@ -537,8 +537,8 @@\n-\t\t\t 11:00\t-\t+11\t1914 Oct\n-\t\t\t  9:00\t-\t+09\t1919 Feb  1\n-\t\t\t 11:00\t-\t+11\t1937\n-\t\t\t 10:00\t-\t+10\t1941 Apr  1\n-\t\t\t  9:00\t-\t+09\t1945 Aug\n-\t\t\t 11:00\t-\t+11\t1969 Oct\n-\t\t\t 12:00\t-\t+12\t1999\n-\t\t\t 11:00\t-\t+11\n+\t\t\t 11:00\t-\t%z\t1914 Oct\n+\t\t\t  9:00\t-\t%z\t1919 Feb  1\n+\t\t\t 11:00\t-\t%z\t1937\n+\t\t\t 10:00\t-\t%z\t1941 Apr  1\n+\t\t\t  9:00\t-\t%z\t1945 Aug\n+\t\t\t 11:00\t-\t%z\t1969 Oct\n+\t\t\t 12:00\t-\t%z\t1999\n+\t\t\t 11:00\t-\t%z\n@@ -549,4 +549,4 @@\n-\t\t\t11:30\t-\t+1130\t1942 Aug 29\n-\t\t\t 9:00\t-\t+09\t1945 Sep  8\n-\t\t\t11:30\t-\t+1130\t1979 Feb 10  2:00\n-\t\t\t12:00\t-\t+12\n+\t\t\t11:30\t-\t%z\t1942 Aug 29\n+\t\t\t 9:00\t-\t%z\t1945 Sep  8\n+\t\t\t11:30\t-\t%z\t1979 Feb 10  2:00\n+\t\t\t12:00\t-\t%z\n@@ -563,1 +563,1 @@\n-\t\t\t11:00\tNC\t+11\/+12\n+\t\t\t11:00\tNC\t%z\n@@ -607,2 +607,2 @@\n-\t\t\t12:15\t-\t+1215\t1946 Jan  1\n-\t\t\t12:45\tChatham\t+1245\/+1345\n+\t\t\t12:15\t-\t%z\t1946 Jan  1\n+\t\t\t12:45\tChatham\t%z\n@@ -661,2 +661,2 @@\n-\t\t\t-10:30\t-\t-1030\t1978 Nov 12\n-\t\t\t-10:00\tCook\t-10\/-0930\n+\t\t\t-10:30\t-\t%z\t1978 Nov 12\n+\t\t\t-10:00\tCook\t%z\n@@ -679,2 +679,2 @@\n-\t\t\t-11:20\t-\t-1120\t1964 Jul\n-\t\t\t-11:00\t-\t-11\n+\t\t\t-11:20\t-\t%z\t1964 Jul\n+\t\t\t-11:00\t-\t%z\n@@ -685,6 +685,6 @@\n-\t\t\t11:12\t-\t+1112\t1951\n-\t\t\t11:30\t-\t+1130\t1974 Oct 27 02:00s\n-\t\t\t11:30\t1:00\t+1230\t1975 Mar  2 02:00s\n-\t\t\t11:30\t-\t+1130\t2015 Oct  4 02:00s\n-\t\t\t11:00\t-\t+11\t2019 Jul\n-\t\t\t11:00\tAN\t+11\/+12\n+\t\t\t11:12\t-\t%z\t1951\n+\t\t\t11:30\t-\t%z\t1974 Oct 27 02:00s\n+\t\t\t11:30\t1:00\t%z\t1975 Mar  2 02:00s\n+\t\t\t11:30\t-\t%z\t2015 Oct  4 02:00s\n+\t\t\t11:00\t-\t%z\t2019 Jul\n+\t\t\t11:00\tAN\t%z\n@@ -696,1 +696,1 @@\n-\t\t\t  9:00\t-\t+09\n+\t\t\t  9:00\t-\t%z\n@@ -702,1 +702,1 @@\n-\t\t\t10:00\t-\t+10\n+\t\t\t10:00\t-\t%z\n@@ -723,4 +723,4 @@\n-\t\t\t10:00\t-\t+10\t1942 Jul\n-\t\t\t 9:00\t-\t+09\t1945 Aug 21\n-\t\t\t10:00\t-\t+10\t2014 Dec 28  2:00\n-\t\t\t11:00\t-\t+11\n+\t\t\t10:00\t-\t%z\t1942 Jul\n+\t\t\t 9:00\t-\t%z\t1945 Aug 21\n+\t\t\t10:00\t-\t%z\t2014 Dec 28  2:00\n+\t\t\t11:00\t-\t%z\n@@ -731,2 +731,2 @@\n-\t\t\t-8:30\t-\t-0830\t1998 Apr 27  0:00\n-\t\t\t-8:00\t-\t-08\n+\t\t\t-8:30\t-\t%z\t1998 Apr 27  0:00\n+\t\t\t-8:00\t-\t%z\n@@ -821,3 +821,3 @@\n-\t\t\t-11:30\t-\t-1130\t1950\n-\t\t\t-11:00\tWS\t-11\/-10\t2011 Dec 29 24:00\n-\t\t\t 13:00\tWS\t+13\/+14\n+\t\t\t-11:30\t-\t%z\t1950\n+\t\t\t-11:00\tWS\t%z\t2011 Dec 29 24:00\n+\t\t\t 13:00\tWS\t%z\n@@ -829,1 +829,1 @@\n-\t\t\t11:00\t-\t+11\n+\t\t\t11:00\t-\t%z\n@@ -852,2 +852,2 @@\n-\t\t\t-11:00\t-\t-11\t2011 Dec 30\n-\t\t\t13:00\t-\t+13\n+\t\t\t-11:00\t-\t%z\t2011 Dec 30\n+\t\t\t13:00\t-\t%z\n@@ -865,3 +865,3 @@\n-\t\t\t12:20\t-\t+1220\t1961\n-\t\t\t13:00\t-\t+13\t1999\n-\t\t\t13:00\tTonga\t+13\/+14\n+\t\t\t12:20\t-\t%z\t1961\n+\t\t\t13:00\t-\t%z\t1999\n+\t\t\t13:00\tTonga\t%z\n@@ -956,1 +956,1 @@\n-\t\t\t11:00\tVanuatu\t+11\/+12\n+\t\t\t11:00\tVanuatu\t%z\n","filename":"src\/java.base\/share\/data\/tzdata\/australasia","additions":65,"deletions":65,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-# tzdb links for backward compatibility\n+# Links and zones for backward compatibility\n@@ -30,0 +30,1 @@\n+# It also provides a few zone entries for old naming conventions.\n@@ -70,0 +71,2 @@\n+Link\tEurope\/Brussels\t\tCET\n+Link\tAmerica\/Chicago\t\tCST6CDT\n@@ -84,0 +87,3 @@\n+Link\tEurope\/Athens\t\tEET\n+Link\tAmerica\/Panama\t\tEST\n+Link\tAmerica\/New_York\tEST5EDT\n@@ -122,0 +128,3 @@\n+Link\tEurope\/Brussels\t\tMET\n+Link\tAmerica\/Phoenix\t\tMST\n+Link\tAmerica\/Denver\t\tMST7MDT\n@@ -301,0 +310,1 @@\n+Link\tAsia\/Ulaanbaatar\tAsia\/Choibalsan\n@@ -315,0 +325,1 @@\n+Link\tEurope\/Lisbon\t\tWET\n@@ -340,0 +351,2 @@\n+Link\tPacific\/Honolulu\tHST\n+Link\tAmerica\/Los_Angeles\tPST8PDT\n","filename":"src\/java.base\/share\/data\/tzdata\/backward","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-# support for POSIX.1-2017-style TZ strings.  On such platforms these entries\n+# support for POSIX proleptic TZ strings.  On such platforms these entries\n@@ -77,26 +77,26 @@\n-Zone\tEtc\/GMT-14\t14\t-\t+14\n-Zone\tEtc\/GMT-13\t13\t-\t+13\n-Zone\tEtc\/GMT-12\t12\t-\t+12\n-Zone\tEtc\/GMT-11\t11\t-\t+11\n-Zone\tEtc\/GMT-10\t10\t-\t+10\n-Zone\tEtc\/GMT-9\t9\t-\t+09\n-Zone\tEtc\/GMT-8\t8\t-\t+08\n-Zone\tEtc\/GMT-7\t7\t-\t+07\n-Zone\tEtc\/GMT-6\t6\t-\t+06\n-Zone\tEtc\/GMT-5\t5\t-\t+05\n-Zone\tEtc\/GMT-4\t4\t-\t+04\n-Zone\tEtc\/GMT-3\t3\t-\t+03\n-Zone\tEtc\/GMT-2\t2\t-\t+02\n-Zone\tEtc\/GMT-1\t1\t-\t+01\n-Zone\tEtc\/GMT+1\t-1\t-\t-01\n-Zone\tEtc\/GMT+2\t-2\t-\t-02\n-Zone\tEtc\/GMT+3\t-3\t-\t-03\n-Zone\tEtc\/GMT+4\t-4\t-\t-04\n-Zone\tEtc\/GMT+5\t-5\t-\t-05\n-Zone\tEtc\/GMT+6\t-6\t-\t-06\n-Zone\tEtc\/GMT+7\t-7\t-\t-07\n-Zone\tEtc\/GMT+8\t-8\t-\t-08\n-Zone\tEtc\/GMT+9\t-9\t-\t-09\n-Zone\tEtc\/GMT+10\t-10\t-\t-10\n-Zone\tEtc\/GMT+11\t-11\t-\t-11\n-Zone\tEtc\/GMT+12\t-12\t-\t-12\n+Zone\tEtc\/GMT-14\t14\t-\t%z\n+Zone\tEtc\/GMT-13\t13\t-\t%z\n+Zone\tEtc\/GMT-12\t12\t-\t%z\n+Zone\tEtc\/GMT-11\t11\t-\t%z\n+Zone\tEtc\/GMT-10\t10\t-\t%z\n+Zone\tEtc\/GMT-9\t9\t-\t%z\n+Zone\tEtc\/GMT-8\t8\t-\t%z\n+Zone\tEtc\/GMT-7\t7\t-\t%z\n+Zone\tEtc\/GMT-6\t6\t-\t%z\n+Zone\tEtc\/GMT-5\t5\t-\t%z\n+Zone\tEtc\/GMT-4\t4\t-\t%z\n+Zone\tEtc\/GMT-3\t3\t-\t%z\n+Zone\tEtc\/GMT-2\t2\t-\t%z\n+Zone\tEtc\/GMT-1\t1\t-\t%z\n+Zone\tEtc\/GMT+1\t-1\t-\t%z\n+Zone\tEtc\/GMT+2\t-2\t-\t%z\n+Zone\tEtc\/GMT+3\t-3\t-\t%z\n+Zone\tEtc\/GMT+4\t-4\t-\t%z\n+Zone\tEtc\/GMT+5\t-5\t-\t%z\n+Zone\tEtc\/GMT+6\t-6\t-\t%z\n+Zone\tEtc\/GMT+7\t-7\t-\t%z\n+Zone\tEtc\/GMT+8\t-8\t-\t%z\n+Zone\tEtc\/GMT+9\t-9\t-\t%z\n+Zone\tEtc\/GMT+10\t-10\t-\t%z\n+Zone\tEtc\/GMT+11\t-11\t-\t%z\n+Zone\tEtc\/GMT+12\t-12\t-\t%z\n","filename":"src\/java.base\/share\/data\/tzdata\/etcetera","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -756,8 +756,0 @@\n-# These are for backward compatibility with older versions.\n-\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tWET\t\t0:00\tEU\tWE%sT\n-Zone\tCET\t\t1:00\tC-Eur\tCE%sT\n-Zone\tMET\t\t1:00\tC-Eur\tME%sT\n-Zone\tEET\t\t2:00\tEU\tEE%sT\n-\n@@ -897,1 +889,1 @@\n-\t\t\t3:00\t-\t+03\n+\t\t\t3:00\t-\t%z\n@@ -1202,2 +1194,2 @@\n-\t\t\t-3:00\t-\t-03\t1980 Apr  6  2:00\n-\t\t\t-3:00\tEU\t-03\/-02\t1996\n+\t\t\t-3:00\t-\t%z\t1980 Apr  6  2:00\n+\t\t\t-3:00\tEU\t%z\t1996\n@@ -1209,4 +1201,4 @@\n-\t\t\t-2:00\t-\t-02\t1980 Apr  6  2:00\n-\t\t\t-2:00\tC-Eur\t-02\/-01\t1981 Mar 29\n-\t\t\t-1:00\tEU\t-01\/+00 2024 Mar 31\n-\t\t\t-2:00\tEU\t-02\/-01\n+\t\t\t-2:00\t-\t%z\t1980 Apr  6  2:00\n+\t\t\t-2:00\tC-Eur\t%z\t1981 Mar 29\n+\t\t\t-1:00\tEU\t%z\t2024 Mar 31\n+\t\t\t-2:00\tEU\t%z\n@@ -1214,4 +1206,4 @@\n-\t\t\t-3:00\t-\t-03\t1980 Apr  6  2:00\n-\t\t\t-3:00\tEU\t-03\/-02\t2023 Mar 26  1:00u\n-\t\t\t-2:00\t-\t-02\t2023 Oct 29  1:00u\n-\t\t\t-2:00\tEU\t-02\/-01\n+\t\t\t-3:00\t-\t%z\t1980 Apr  6  2:00\n+\t\t\t-3:00\tEU\t%z\t2023 Mar 26  1:00u\n+\t\t\t-2:00\t-\t%z\t2023 Oct 29  1:00u\n+\t\t\t-2:00\tEU\t%z\n@@ -2089,4 +2081,33 @@\n-# From Paul Eggert (2014-08-11), after a heads-up from Stephen Colebourne:\n-# According to a Portuguese decree (1911-05-26)\n-# https:\/\/dre.pt\/application\/dir\/pdf1sdip\/1911\/05\/12500\/23132313.pdf\n-# Lisbon was at -0:36:44.68, but switched to GMT on 1912-01-01 at 00:00.\n+# From Tim Parenti (2024-07-01), per Alois Treindl (2021-02-07) and Michael\n+# Deckers (2021-02-10):\n+# http:\/\/oal.ul.pt\/documentos\/2018\/01\/hl1911a2018.pdf\/\n+# The Astronomical Observatory of Lisbon has published a list detailing the\n+# historical transitions in legal time within continental Portugal.  It\n+# directly references many decrees and ordinances which are, in turn,\n+# referenced below.  They can be viewed in the public archives of the Dirio da\n+# Repblica (until 1976-04-09 known as the Dirio do Govrno) at\n+# https:\/\/dre.pt\/ (in Portuguese).\n+#\n+# Most of the Rules below have been updated simply to match the Observatory's\n+# listing for continental (mainland) Portugal.  Although there are over 50\n+# referenced decrees and ordinances, only the handful with comments below have\n+# been verified against the text, typically to provide additional confidence\n+# wherever dates provided by Whitman and Shanks & Pottenger had disagreed.\n+# See further below for the Azores and Madeira.\n+\n+# From Tim Parenti (2024-07-01), per Paul Eggert (2014-08-11), after a\n+# heads-up from Stephen Colebourne:\n+# According to a 1911-05-24 Portuguese decree, Lisbon was at -0:36:44.68, but\n+# switched to GMT on 1912-01-01 at 00:00.\n+# https:\/\/dre.pt\/dr\/detalhe\/decreto\/593090\n+# https:\/\/dre.pt\/application\/conteudo\/593090\n+# The decree made legal time throughout Portugal and her possessions\n+# \"subordinate to the Greenwich meridian, according to the principle adopted at\n+# the Washington Convention in 1884\" and eliminated the \"difference of five\n+# minutes between the internal and external clocks of railway stations\".\n+#\n+# The decree was gazetted in the 1911-05-30 issue of Dirio do Govrno, and is\n+# considered to be dated 1911-05-24 by that issue's summary; however, the text\n+# of the decree itself is dated 1911-05-26.  The Dirio da Repblica website\n+# notes the discrepancy, but later laws and the Observatory all seem to refer\n+# to this decree by the 1911-05-24 date.\n@@ -2100,16 +2121,0 @@\n-# From Rui Pedro Salgueiro (1992-11-12):\n-# Portugal has recently (September, 27) changed timezone\n-# (from WET to MET or CET) to harmonize with EEC.\n-#\n-# Martin Bruckmann (1996-02-29) reports via Peter Ilieve\n-# that Portugal is reverting to 0:00 by not moving its clocks this spring.\n-# The new Prime Minister was fed up with getting up in the dark in the winter.\n-#\n-# From Paul Eggert (1996-11-12):\n-# IATA SSIM (1991-09) reports several 1991-09 and 1992-09 transitions\n-# at 02:00u, not 01:00u.  Assume that these are typos.\n-# IATA SSIM (1991\/1992) reports that the Azores were at -1:00.\n-# IATA SSIM (1993-02) says +0:00; later issues (through 1996-09) say -1:00.\n-# Guess that the Azores changed to EU rules in 1992 (since that's when Portugal\n-# harmonized with EU rules), and that they stayed +0:00 that winter.\n-#\n@@ -2117,3 +2122,19 @@\n-# DSH writes that despite Decree 1,469 (1915), the change to the clocks was not\n-# done every year, depending on what Spain did, because of railroad schedules.\n-# Go with Shanks & Pottenger.\n+# From Tim Parenti (2024-07-01), per Paul Eggert (1999-01-30):\n+# DSH writes in their history that Decreto 1469 of 1915-03-30 established\n+# summer time and that, \"despite\" this, the change to the clocks was not done\n+# every year, depending on what Spain did, because of railroad schedules.\n+# In fact, that decree had nothing to do with DST; rather, it regulated the\n+# sending of time signals.  But we do see linkage to Spain in the 1920s below.\n+# https:\/\/dre.pt\/dr\/detalhe\/decreto\/1469-1915-285721\n+# https:\/\/dre.pt\/application\/conteudo\/285721\n+#\n+# According to the Observatory, standard time was first advanced by Decreto\n+# 2433 of 1916-06-09 and restored by Decreto 2712 of 1916-10-28.  While Whitman\n+# gives 1916-10-31 for the latter transition, Shanks & Pottenger agrees more\n+# closely with the decree, which stated that its provision \"will start sixty\n+# minutes after the end of 31 October, according to the current time,\" i.e.,\n+# 01:00 on 1 November.\n+# https:\/\/dre.pt\/dr\/detalhe\/decreto\/2433-1916-267192\n+# https:\/\/dre.pt\/application\/conteudo\/267192\n+# https:\/\/dre.pt\/dr\/detalhe\/decreto\/2712-1916-590937\n+# https:\/\/dre.pt\/application\/conteudo\/590937\n@@ -2121,1 +2142,0 @@\n-# Whitman gives 1916 Oct 31; go with Shanks & Pottenger.\n@@ -2123,6 +2143,32 @@\n-Rule\tPort\t1917\tonly\t-\tFeb\t28\t23:00s\t1:00\tS\n-Rule\tPort\t1917\t1921\t-\tOct\t14\t23:00s\t0\t-\n-Rule\tPort\t1918\tonly\t-\tMar\t 1\t23:00s\t1:00\tS\n-Rule\tPort\t1919\tonly\t-\tFeb\t28\t23:00s\t1:00\tS\n-Rule\tPort\t1920\tonly\t-\tFeb\t29\t23:00s\t1:00\tS\n-Rule\tPort\t1921\tonly\t-\tFeb\t28\t23:00s\t1:00\tS\n+# From Tim Parenti (2024-07-01):\n+# Article 7 of Decreto 2922 of 1916-12-30 stated that \"the legal time will be\n+# advanced by sixty minutes from 1 March to 31 October.\"  Per Article 15, this\n+# came into force from 1917-01-01.  Just before the first fall back, Decreto\n+# 3446 of 1917-10-11 changed the annual end date to 14 October.\n+# https:\/\/dre.pt\/dr\/detalhe\/decreto\/2922-1916-261894\n+# https:\/\/dre.pt\/application\/conteudo\/261894\n+# https:\/\/dre.pt\/dr\/detalhe\/decreto\/3446-1917-495161\n+# https:\/\/dre.pt\/application\/conteudo\/495161\n+# This annual change was revoked by Decreto 8038 of 1922-02-18.\n+# https:\/\/dre.pt\/dr\/detalhe\/decreto\/8038-1922-569751\n+# https:\/\/dre.pt\/application\/conteudo\/569751\n+Rule\tPort\t1917\t1921\t-\tMar\t 1\t 0:00\t1:00\tS\n+Rule\tPort\t1917\t1921\t-\tOct\t14\t24:00\t0\t-\n+# From Tim Parenti (2024-07-01):\n+# Decreto 9592 of 1924-04-14 noted that \"France maintains the advance of legal\n+# time in the summer and Spain has now adopted it for the first time\" and\n+# considered \"that the absence of similar measures would cause serious\n+# difficulties for international rail connections with consequent repercussions\n+# on domestic service hours...\" along with \"inconvenient analogues...for postal\n+# and telegraph services.\"  Summer time would be in effect from 17 April to 4\n+# October, with the spring change explicitly specified by bringing clocks\n+# forward from 16 April 23:00.\n+# https:\/\/dre.pt\/dr\/detalhe\/decreto\/9592-1924-652133\n+# https:\/\/dre.pt\/application\/conteudo\/652133\n+#\n+# Decreto 10700, issued 1925-04-16, noted that Spain had not continued summer\n+# time, declared that \"the current legal hour prior to 17 April remains\n+# unchanged from that day forward\", and revoked legislation to the contrary,\n+# just a day before summer time would have otherwise resumed.\n+# https:\/\/dre.pt\/dr\/detalhe\/decreto\/10700-1925-437826\n+# https:\/\/dre.pt\/application\/conteudo\/437826\n@@ -2130,1 +2176,1 @@\n-Rule\tPort\t1924\tonly\t-\tOct\t14\t23:00s\t0\t-\n+Rule\tPort\t1924\tonly\t-\tOct\t 4\t23:00s\t0\t-\n@@ -2142,0 +2188,2 @@\n+# Note: The 1935 law specified 10-06 00:00, not 10-05 24:00, but the following\n+# is equivalent and more succinct.\n@@ -2152,0 +2200,9 @@\n+# From Tim Parenti (2024-07-01):\n+# Portaria 9465 of 1940-02-17 advanced clocks from Saturday 1940-02-24 23:00.\n+# The clocks were restored by Portaria 9658, issued Monday 1940-10-07,\n+# effective from 24:00 that very night, which agrees with Shanks & Pottenger;\n+# Whitman gives Saturday 1940-10-05 instead.\n+# https:\/\/dre.pt\/dr\/detalhe\/portaria\/9465-1940-189096\n+# https:\/\/dre.pt\/application\/conteudo\/189096\n+# https:\/\/dre.pt\/dr\/detalhe\/portaria\/9658-1940-196729\n+# https:\/\/dre.pt\/application\/conteudo\/196729\n@@ -2153,2 +2210,1 @@\n-# Shanks & Pottenger give 1940 Oct 7; go with Whitman.\n-Rule\tPort\t1940\t1941\t-\tOct\t 5\t23:00s\t0\t-\n+Rule\tPort\t1940\tonly\t-\tOct\t 7\t23:00s\t0\t-\n@@ -2156,0 +2212,1 @@\n+Rule\tPort\t1941\tonly\t-\tOct\t 5\t23:00s\t0\t-\n@@ -2165,3 +2222,22 @@\n-# Whitman says DST was not observed in 1950; go with Shanks & Pottenger.\n-# Whitman gives Oct lastSun for 1952 on; go with Shanks & Pottenger.\n-Rule\tPort\t1947\t1965\t-\tApr\tSun>=1\t 2:00s\t1:00\tS\n+# From Tim Parenti (2024-07-01), per Alois Treindl (2021-02-07):\n+# The Astronomical Observatory of Lisbon cites Portaria 11767 of 1947-03-28 for\n+# 1947 and Portaria 12286 of 1948-02-19 for 1948.\n+# https:\/\/dre.pt\/dr\/detalhe\/portaria\/11767-1947-414787\n+# https:\/\/dre.pt\/application\/conteudo\/414787\n+# https:\/\/dre.pt\/dr\/detalhe\/portaria\/12286-1948-152953\n+# https:\/\/dre.pt\/application\/conteudo\/152953\n+#\n+# Although the latter ordinance explicitly had the 1948-10-03 transition\n+# scheduled for 02:00 rather than 03:00 as had been used in 1947, Decreto-Lei\n+# 37048 of 1948-09-07 recognized \"that it is advisable to definitely set...the\n+# 'summer time' regime\", and fixed the fall transition at 03:00 moving forward.\n+# https:\/\/dre.pt\/dr\/detalhe\/decreto-lei\/37048-1948-373810\n+# https:\/\/dre.pt\/application\/conteudo\/373810\n+# While the Observatory only cites this act for 1949-1965 and not for 1948, it\n+# does not appear to have had any provision delaying its effect, so assume that\n+# it overrode the prior ordinance for 1948-10-03.\n+#\n+# Whitman says DST was not observed in 1950 and gives Oct lastSun for 1952 on.\n+# The Observatory, however, agrees with Shanks & Pottenger that 1950 was not an\n+# exception and that Oct Sun>=1 was maintained through 1965.\n+Rule\tPort\t1947\t1966\t-\tApr\tSun>=1\t 2:00s\t1:00\tS\n@@ -2169,8 +2245,61 @@\n-Rule\tPort\t1977\tonly\t-\tMar\t27\t 0:00s\t1:00\tS\n-Rule\tPort\t1977\tonly\t-\tSep\t25\t 0:00s\t0\t-\n-Rule\tPort\t1978\t1979\t-\tApr\tSun>=1\t 0:00s\t1:00\tS\n-Rule\tPort\t1978\tonly\t-\tOct\t 1\t 0:00s\t0\t-\n-Rule\tPort\t1979\t1982\t-\tSep\tlastSun\t 1:00s\t0\t-\n-Rule\tPort\t1980\tonly\t-\tMar\tlastSun\t 0:00s\t1:00\tS\n-Rule\tPort\t1981\t1982\t-\tMar\tlastSun\t 1:00s\t1:00\tS\n-Rule\tPort\t1983\tonly\t-\tMar\tlastSun\t 2:00s\t1:00\tS\n+# From Tim Parenti (2024-07-01):\n+# Decreto-Lei 47233 of 1966-10-01 considered that the \"duality\" in time was\n+# \"the cause of serious disturbances\" and noted that \"the countries with which\n+# we have the most frequent contacts...have already adopted\" a solution\n+# coinciding with the extant \"summer time\".  It established that the former\n+# \"summer time\" would apply year-round on the mainland and adjacent islands\n+# with immediate effect, as the fall back would have otherwise occurred later\n+# that evening.\n+# https:\/\/dre.pt\/dr\/detalhe\/decreto-lei\/47233-1966-293729\n+# Model this by changing zones without changing clocks at the\n+# previously-appointed fall back time.\n+#\n+# Decreto-Lei 309\/76 of 1976-04-27 acknowledged that those international\n+# contacts had returned to adopting seasonal times, and considered that the\n+# year-round advancement \"entails considerable sacrifices for the vast majority\n+# of the working population during the winter months\", including morning\n+# visibility concerns for schoolchildren.  It specified, beginning 1976-09-26\n+# 01:00, an annual return to UT+00 on the mainland from 00:00 UT on Sep lastSun\n+# to 00:00 UT on Mar lastSun (unless the latter date fell on Easter, in which\n+# case it was to be brought forward to the preceding Sunday).  It also assigned\n+# the Permanent Time Commission to study and propose revisions for the Azores\n+# and Madeira, neither of which resumed DST until 1982 (as described further\n+# below).\n+# https:\/\/dre.pt\/dr\/detalhe\/decreto-lei\/309-1976-502063\n+Rule\tPort\t1976\tonly\t-\tSep\tlastSun\t 1:00\t0\t-\n+Rule\tPort\t1977\tonly\t-\tMar\tlastSun\t 0:00s\t1:00\tS\n+Rule\tPort\t1977\tonly\t-\tSep\tlastSun\t 0:00s\t0\t-\n+# From Tim Parenti (2024-07-01):\n+# Beginning in 1978, rather than triggering the Easter rule of the 1976 decree\n+# (Easter fell on 1978-03-26), Article 5 was used instead, which allowed DST\n+# dates to be changed by order of the Minister of Education and Scientific\n+# Research, upon consultation with the Permanent Time Commission, \"whenever\n+# considered convenient.\"  As such, a series of one-off ordinances were\n+# promulgated for the mainland in 1978 through 1980, after which the 1976\n+# decree naturally came back into force from 1981.\n+Rule\tPort\t1978\t1980\t-\tApr\tSun>=1\t 1:00s\t1:00\tS\n+Rule\tPort\t1978\tonly\t-\tOct\t 1\t 1:00s\t0\t-\n+Rule\tPort\t1979\t1980\t-\tSep\tlastSun\t 1:00s\t0\t-\n+Rule\tPort\t1981\t1986\t-\tMar\tlastSun\t 0:00s\t1:00\tS\n+Rule\tPort\t1981\t1985\t-\tSep\tlastSun\t 0:00s\t0\t-\n+# From Tim Parenti (2024-07-01):\n+# Decreto-Lei 44-B\/86 of 1986-03-07 switched mainland Portugal's transition\n+# times from 0:00s to 1:00u to harmonize with the EEC from 1986-03-30.\n+# https:\/\/dre.pt\/dr\/detalhe\/decreto-lei\/44-b-1986-628280\n+# (Transitions of 1:00s as previously reported and used by the W-Eur rules,\n+# though equivalent, appear to have been fiction here.)  Madeira continued to\n+# use 0:00s for spring 1986 before joining with the mainland using 1:00u in the\n+# fall; meanwhile, in the Azores the two were equivalent, so the law specifying\n+# 0:00s wasn't touched until 1992.  (See below for more on the islands.)\n+#\n+# From Rui Pedro Salgueiro (1992-11-12):\n+# Portugal has recently (September, 27) changed timezone\n+# (from WET to MET or CET) to harmonize with EEC.\n+#\n+# Martin Bruckmann (1996-02-29) reports via Peter Ilieve\n+# that Portugal is reverting to 0:00 by not moving its clocks this spring.\n+# The new Prime Minister was fed up with getting up in the dark in the winter.\n+#\n+# From Paul Eggert (1996-11-12):\n+# IATA SSIM (1991-09) reports several 1991-09 and 1992-09 transitions\n+# at 02:00u, not 01:00u.  Assume that these are typos.\n@@ -2182,1 +2311,1 @@\n-\t\t\t 0:00\tPort\tWE%sT\t1966 Apr  3  2:00\n+\t\t\t 0:00\tPort\tWE%sT\t1966 Oct  2  2:00s\n@@ -2184,2 +2313,2 @@\n-\t\t\t 0:00\tPort\tWE%sT\t1983 Sep 25  1:00s\n-\t\t\t 0:00\tW-Eur\tWE%sT\t1992 Sep 27  1:00s\n+\t\t\t 0:00\tPort\tWE%sT\t1986\n+\t\t\t 0:00\tEU\tWE%sT\t1992 Sep 27  1:00u\n@@ -2188,0 +2317,11 @@\n+\n+# From Tim Parenti (2024-07-01):\n+# For the Azores and Madeira, legislation was followed from the laws currently\n+# in force as listed at:\n+# https:\/\/oal.ul.pt\/hora-legal\/legislacao\/\n+# working backward through references of revocation and abrogation to\n+# Decreto-Lei 47233 of 1966-10-01, the last time DST was abolished across the\n+# mainland and its adjacent islands.  Because of that reference, it is\n+# therefore assumed that DST rules in the islands prior to 1966 were like that\n+# of the mainland, though most legislation of the time didn't explicitly\n+# specify DST practices for the islands.\n@@ -2191,3 +2331,17 @@\n-#\t\t\t-2:00\tPort\t%z\t1966 Apr  3  2:00\n-#\t\t\t-1:00\tPort\t%z\t1983 Sep 25  1:00s\n-#\t\t\t-1:00\tW-Eur\t%z\t1992 Sep 27  1:00s\n+\t\t\t-2:00\tPort\t%z\t1966 Oct  2  2:00s\n+# From Tim Parenti (2024-07-01):\n+# While Decreto-Lei 309\/76 of 1976-04-27 reintroduced DST on the mainland by\n+# falling back on 1976-09-26, it assigned the Permanent Time Commission to\n+# study and propose revisions for the Azores and Madeira.  Decreto Regional\n+# 9\/77\/A of 1977-05-17 affirmed that \"the legal time remained unchanged in the\n+# Azores\" at UT-1, and would remain there year-round.\n+# https:\/\/dre.pt\/dr\/detalhe\/decreto-regional\/9-1977-252066\n+#\n+# Decreto Regional 2\/82\/A, published 1982-03-02, adopted DST in the same\n+# fashion as the mainland used at the time.\n+# https:\/\/dre.pt\/dr\/detalhe\/decreto-regional\/2-1982-599965\n+# Though transitions in the Azores officially remained at 0:00s through 1992,\n+# this was equivalent to the EU-style 1:00u adopted by the mainland in 1986, so\n+# model it as such.\n+\t\t\t-1:00\t-\t%z\t1982 Mar 28  0:00s\n+\t\t\t-1:00\tPort\t%z\t1986\n@@ -2195,11 +2349,11 @@\n-\t\t\t-2:00\tPort\t-02\/-01\t1942 Apr 25 22:00s\n-\t\t\t-2:00\tPort\t+00\t1942 Aug 15 22:00s\n-\t\t\t-2:00\tPort\t-02\/-01\t1943 Apr 17 22:00s\n-\t\t\t-2:00\tPort\t+00\t1943 Aug 28 22:00s\n-\t\t\t-2:00\tPort\t-02\/-01\t1944 Apr 22 22:00s\n-\t\t\t-2:00\tPort\t+00\t1944 Aug 26 22:00s\n-\t\t\t-2:00\tPort\t-02\/-01\t1945 Apr 21 22:00s\n-\t\t\t-2:00\tPort\t+00\t1945 Aug 25 22:00s\n-\t\t\t-2:00\tPort\t-02\/-01\t1966 Apr  3  2:00\n-\t\t\t-1:00\tPort\t-01\/+00\t1983 Sep 25  1:00s\n-\t\t\t-1:00\tW-Eur\t-01\/+00\t1992 Sep 27  1:00s\n+#\t\t\t-2:00\tPort\t-02\/-01\t1942 Apr 25 22:00s\n+#\t\t\t-2:00\tPort\t+00\t1942 Aug 15 22:00s\n+#\t\t\t-2:00\tPort\t-02\/-01\t1943 Apr 17 22:00s\n+#\t\t\t-2:00\tPort\t+00\t1943 Aug 28 22:00s\n+#\t\t\t-2:00\tPort\t-02\/-01\t1944 Apr 22 22:00s\n+#\t\t\t-2:00\tPort\t+00\t1944 Aug 26 22:00s\n+#\t\t\t-2:00\tPort\t-02\/-01\t1945 Apr 21 22:00s\n+#\t\t\t-2:00\tPort\t+00\t1945 Aug 25 22:00s\n+#\t\t\t-2:00\tPort\t-02\/-01\t1966 Oct  2  2:00s\n+#\t\t\t-1:00\t-\t-01\t1982 Mar 28  0:00s\n+#\t\t\t-1:00\tPort\t-01\/+00\t1986\n@@ -2207,2 +2361,20 @@\n-\t\t\t 0:00\tEU\tWE%sT\t1993 Mar 28  1:00u\n-\t\t\t-1:00\tEU\t-01\/+00\n+#\n+# From Paul Eggert (1996-11-12):\n+# IATA SSIM (1991\/1992) reports that the Azores were at -1:00.\n+# IATA SSIM (1993-02) says +0:00; later issues (through 1996-09) say -1:00.\n+#\n+# From Tim Parenti (2024-07-01):\n+# After mainland Portugal had shifted forward an hour from 1992-09-27, Decreto\n+# Legislativo Regional 29\/92\/A of 1992-12-23 sought to \"reduce the time\n+# difference\" by shifting the Azores forward as well from 1992-12-27.  Just six\n+# months later, this was revoked by Decreto Legislativo Regional 9\/93\/A, citing\n+# \"major changes in work habits and way of life.\"  Though the revocation didn't\n+# give a transition time, it was signed Wednesday 1993-06-16; assume it took\n+# effect later that evening, and that an EU-style spring forward (to +01) was\n+# still observed in the interim on 1993-03-28.\n+# https:\/\/dre.pt\/dr\/detalhe\/decreto-legislativo-regional\/29-1992-621553\n+# https:\/\/dre.pt\/dr\/detalhe\/decreto-legislativo-regional\/9-1993-389633\n+\t\t\t-1:00\tEU\t%z\t1992 Dec 27  1:00s\n+\t\t\t 0:00\tEU\tWE%sT\t1993 Jun 17  1:00u\n+\t\t\t-1:00\tEU\t%z\n+\n@@ -2212,1 +2384,1 @@\n-#\t\t\t-1:00\tPort\t%z\t1966 Apr  3  2:00\n+\t\t\t-1:00\tPort\t%z\t1966 Oct  2  2:00s\n@@ -2214,9 +2386,9 @@\n-\t\t\t-1:00\tPort\t-01\/+00\t1942 Apr 25 22:00s\n-\t\t\t-1:00\tPort\t+01\t1942 Aug 15 22:00s\n-\t\t\t-1:00\tPort\t-01\/+00\t1943 Apr 17 22:00s\n-\t\t\t-1:00\tPort\t+01\t1943 Aug 28 22:00s\n-\t\t\t-1:00\tPort\t-01\/+00\t1944 Apr 22 22:00s\n-\t\t\t-1:00\tPort\t+01\t1944 Aug 26 22:00s\n-\t\t\t-1:00\tPort\t-01\/+00\t1945 Apr 21 22:00s\n-\t\t\t-1:00\tPort\t+01\t1945 Aug 25 22:00s\n-\t\t\t-1:00\tPort\t-01\/+00\t1966 Apr  3  2:00\n+#\t\t\t-1:00\tPort\t-01\/+00\t1942 Apr 25 22:00s\n+#\t\t\t-1:00\tPort\t+01\t1942 Aug 15 22:00s\n+#\t\t\t-1:00\tPort\t-01\/+00\t1943 Apr 17 22:00s\n+#\t\t\t-1:00\tPort\t+01\t1943 Aug 28 22:00s\n+#\t\t\t-1:00\tPort\t-01\/+00\t1944 Apr 22 22:00s\n+#\t\t\t-1:00\tPort\t+01\t1944 Aug 26 22:00s\n+#\t\t\t-1:00\tPort\t-01\/+00\t1945 Apr 21 22:00s\n+#\t\t\t-1:00\tPort\t+01\t1945 Aug 25 22:00s\n+#\t\t\t-1:00\tPort\t-01\/+00\t1966 Oct  2  2:00s\n@@ -2224,1 +2396,15 @@\n-\t\t\t 0:00\tPort\tWE%sT\t1983 Sep 25  1:00s\n+#\n+# From Tim Parenti (2024-07-01):\n+# Decreto Regional 5\/82\/M, published 1982-04-03, established DST transitions at\n+# 0:00u, which for Madeira is equivalent to the mainland's rules (0:00s) at the\n+# time.  It came into effect the day following its publication, Sunday\n+# 1982-04-04, thus resuming Madeira's DST practice about a week later than the\n+# mainland and the Azores.\n+# https:\/\/dre.pt\/dr\/detalhe\/decreto-regional\/5-1982-608273\n+#\n+# Decreto Legislativo Regional 18\/86\/M, published 1986-10-01, adopted EU-style\n+# rules (1:00u) and entered into immediate force after being signed on\n+# 1986-07-31.\n+# https:\/\/dre.pt\/dr\/detalhe\/decreto-legislativo-regional\/18-1986-221705\n+\t\t\t 0:00\t-\tWET\t1982 Apr  4\n+\t\t\t 0:00\tPort\tWE%sT\t1986 Jul 31\n@@ -2436,1 +2622,1 @@\n-\t\t\t 3:00\t-\t+03\t2014 Oct 26  2:00s\n+\t\t\t 3:00\t-\t%z\t2014 Oct 26  2:00s\n@@ -2686,8 +2872,8 @@\n-\t\t\t 3:00\t-\t+03\t1930 Jun 21\n-\t\t\t 4:00\tRussia\t+04\/+05\t1989 Mar 26  2:00s\n-\t\t\t 3:00\tRussia\t+03\/+04\t1991 Mar 31  2:00s\n-\t\t\t 4:00\t-\t+04\t1992 Mar 29  2:00s\n-\t\t\t 3:00\tRussia\t+03\/+04\t2011 Mar 27  2:00s\n-\t\t\t 4:00\t-\t+04\t2014 Oct 26  2:00s\n-\t\t\t 3:00\t-\t+03\t2016 Mar 27  2:00s\n-\t\t\t 4:00\t-\t+04\n+\t\t\t 3:00\t-\t%z\t1930 Jun 21\n+\t\t\t 4:00\tRussia\t%z\t1989 Mar 26  2:00s\n+\t\t\t 3:00\tRussia\t%z\t1991 Mar 31  2:00s\n+\t\t\t 4:00\t-\t%z\t1992 Mar 29  2:00s\n+\t\t\t 3:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t 4:00\t-\t%z\t2014 Oct 26  2:00s\n+\t\t\t 3:00\t-\t%z\t2016 Mar 27  2:00s\n+\t\t\t 4:00\t-\t%z\n@@ -2723,3 +2909,3 @@\n-\t\t\t 3:00\t-\t+03\t1930 Jun 21\n-\t\t\t 4:00\t-\t+04\t1961 Nov 11\n-\t\t\t 4:00\tRussia\t+04\/+05\t1988 Mar 27  2:00s\n+\t\t\t 3:00\t-\t%z\t1930 Jun 21\n+\t\t\t 4:00\t-\t%z\t1961 Nov 11\n+\t\t\t 4:00\tRussia\t%z\t1988 Mar 27  2:00s\n@@ -2727,1 +2913,1 @@\n-\t\t\t 4:00\t-\t+04\t1992 Mar 29  2:00s\n+\t\t\t 4:00\t-\t%z\t1992 Mar 29  2:00s\n@@ -2731,1 +2917,1 @@\n-\t\t\t 4:00\t-\t+04\t2020 Dec 27  2:00s\n+\t\t\t 4:00\t-\t%z\t2020 Dec 27  2:00s\n@@ -2746,8 +2932,8 @@\n-\t\t\t 3:00\t-\t+03\t1930 Jun 21\n-\t\t\t 4:00\tRussia\t+04\/+05\t1988 Mar 27  2:00s\n-\t\t\t 3:00\tRussia\t+03\/+04\t1991 Mar 31  2:00s\n-\t\t\t 4:00\t-\t+04\t1992 Mar 29  2:00s\n-\t\t\t 3:00\tRussia\t+03\/+04\t2011 Mar 27  2:00s\n-\t\t\t 4:00\t-\t+04\t2014 Oct 26  2:00s\n-\t\t\t 3:00\t-\t+03\t2016 Dec  4  2:00s\n-\t\t\t 4:00\t-\t+04\n+\t\t\t 3:00\t-\t%z\t1930 Jun 21\n+\t\t\t 4:00\tRussia\t%z\t1988 Mar 27  2:00s\n+\t\t\t 3:00\tRussia\t%z\t1991 Mar 31  2:00s\n+\t\t\t 4:00\t-\t%z\t1992 Mar 29  2:00s\n+\t\t\t 3:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t 4:00\t-\t%z\t2014 Oct 26  2:00s\n+\t\t\t 3:00\t-\t%z\t2016 Dec  4  2:00s\n+\t\t\t 4:00\t-\t%z\n@@ -2761,2 +2947,2 @@\n-\t\t\t 3:00\t-\t+03\t1930 Jun 21\n-\t\t\t 4:00\tRussia\t+04\/+05\t1989 Mar 26  2:00s\n+\t\t\t 3:00\t-\t%z\t1930 Jun 21\n+\t\t\t 4:00\tRussia\t%z\t1989 Mar 26  2:00s\n@@ -2764,1 +2950,1 @@\n-\t\t\t 4:00\t-\t+04\t1992 Mar 29  2:00s\n+\t\t\t 4:00\t-\t%z\t1992 Mar 29  2:00s\n@@ -2779,9 +2965,9 @@\n-\t\t\t 3:00\t-\t+03\t1930 Jun 21\n-\t\t\t 4:00\t-\t+04\t1935 Jan 27\n-\t\t\t 4:00\tRussia\t+04\/+05\t1989 Mar 26  2:00s\n-\t\t\t 3:00\tRussia\t+03\/+04\t1991 Mar 31  2:00s\n-\t\t\t 2:00\tRussia\t+02\/+03\t1991 Sep 29  2:00s\n-\t\t\t 3:00\t-\t+03\t1991 Oct 20  3:00\n-\t\t\t 4:00\tRussia\t+04\/+05\t2010 Mar 28  2:00s\n-\t\t\t 3:00\tRussia\t+03\/+04\t2011 Mar 27  2:00s\n-\t\t\t 4:00\t-\t+04\n+\t\t\t 3:00\t-\t%z\t1930 Jun 21\n+\t\t\t 4:00\t-\t%z\t1935 Jan 27\n+\t\t\t 4:00\tRussia\t%z\t1989 Mar 26  2:00s\n+\t\t\t 3:00\tRussia\t%z\t1991 Mar 31  2:00s\n+\t\t\t 2:00\tRussia\t%z\t1991 Sep 29  2:00s\n+\t\t\t 3:00\t-\t%z\t1991 Oct 20  3:00\n+\t\t\t 4:00\tRussia\t%z\t2010 Mar 28  2:00s\n+\t\t\t 3:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t 4:00\t-\t%z\n@@ -2803,8 +2989,8 @@\n-\t\t\t 3:00\t-\t+03\t1930 Jun 21\n-\t\t\t 4:00\tRussia\t+04\/+05\t1989 Mar 26  2:00s\n-\t\t\t 3:00\tRussia\t+03\/+04\t1991 Mar 31  2:00s\n-\t\t\t 2:00\tRussia\t+02\/+03\t1992 Jan 19  2:00s\n-\t\t\t 3:00\tRussia\t+03\/+04\t2011 Mar 27  2:00s\n-\t\t\t 4:00\t-\t+04\t2014 Oct 26  2:00s\n-\t\t\t 3:00\t-\t+03\t2016 Mar 27  2:00s\n-\t\t\t 4:00\t-\t+04\n+\t\t\t 3:00\t-\t%z\t1930 Jun 21\n+\t\t\t 4:00\tRussia\t%z\t1989 Mar 26  2:00s\n+\t\t\t 3:00\tRussia\t%z\t1991 Mar 31  2:00s\n+\t\t\t 2:00\tRussia\t%z\t1992 Jan 19  2:00s\n+\t\t\t 3:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t 4:00\t-\t%z\t2014 Oct 26  2:00s\n+\t\t\t 3:00\t-\t%z\t2016 Mar 27  2:00s\n+\t\t\t 4:00\t-\t%z\n@@ -2835,6 +3021,6 @@\n-\t\t\t 4:00\t-\t+04\t1930 Jun 21\n-\t\t\t 5:00\tRussia\t+05\/+06\t1991 Mar 31  2:00s\n-\t\t\t 4:00\tRussia\t+04\/+05\t1992 Jan 19  2:00s\n-\t\t\t 5:00\tRussia\t+05\/+06\t2011 Mar 27  2:00s\n-\t\t\t 6:00\t-\t+06\t2014 Oct 26  2:00s\n-\t\t\t 5:00\t-\t+05\n+\t\t\t 4:00\t-\t%z\t1930 Jun 21\n+\t\t\t 5:00\tRussia\t%z\t1991 Mar 31  2:00s\n+\t\t\t 4:00\tRussia\t%z\t1992 Jan 19  2:00s\n+\t\t\t 5:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t 6:00\t-\t%z\t2014 Oct 26  2:00s\n+\t\t\t 5:00\t-\t%z\n@@ -2850,6 +3036,6 @@\n-\t\t\t 5:00\t-\t+05\t1930 Jun 21\n-\t\t\t 6:00\tRussia\t+06\/+07\t1991 Mar 31  2:00s\n-\t\t\t 5:00\tRussia\t+05\/+06\t1992 Jan 19  2:00s\n-\t\t\t 6:00\tRussia\t+06\/+07\t2011 Mar 27  2:00s\n-\t\t\t 7:00\t-\t+07\t2014 Oct 26  2:00s\n-\t\t\t 6:00\t-\t+06\n+\t\t\t 5:00\t-\t%z\t1930 Jun 21\n+\t\t\t 6:00\tRussia\t%z\t1991 Mar 31  2:00s\n+\t\t\t 5:00\tRussia\t%z\t1992 Jan 19  2:00s\n+\t\t\t 6:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t 7:00\t-\t%z\t2014 Oct 26  2:00s\n+\t\t\t 6:00\t-\t%z\n@@ -2888,8 +3074,8 @@\n-\t\t\t 6:00\t-\t+06\t1930 Jun 21\n-\t\t\t 7:00\tRussia\t+07\/+08\t1991 Mar 31  2:00s\n-\t\t\t 6:00\tRussia\t+06\/+07\t1992 Jan 19  2:00s\n-\t\t\t 7:00\tRussia\t+07\/+08\t1995 May 28\n-\t\t\t 6:00\tRussia\t+06\/+07\t2011 Mar 27  2:00s\n-\t\t\t 7:00\t-\t+07\t2014 Oct 26  2:00s\n-\t\t\t 6:00\t-\t+06\t2016 Mar 27  2:00s\n-\t\t\t 7:00\t-\t+07\n+\t\t\t 6:00\t-\t%z\t1930 Jun 21\n+\t\t\t 7:00\tRussia\t%z\t1991 Mar 31  2:00s\n+\t\t\t 6:00\tRussia\t%z\t1992 Jan 19  2:00s\n+\t\t\t 7:00\tRussia\t%z\t1995 May 28\n+\t\t\t 6:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t 7:00\t-\t%z\t2014 Oct 26  2:00s\n+\t\t\t 6:00\t-\t%z\t2016 Mar 27  2:00s\n+\t\t\t 7:00\t-\t%z\n@@ -2909,8 +3095,8 @@\n-\t\t\t 6:00\t-\t+06\t1930 Jun 21\n-\t\t\t 7:00\tRussia\t+07\/+08\t1991 Mar 31  2:00s\n-\t\t\t 6:00\tRussia\t+06\/+07\t1992 Jan 19  2:00s\n-\t\t\t 7:00\tRussia\t+07\/+08\t1993 May 23 # say Shanks & P.\n-\t\t\t 6:00\tRussia\t+06\/+07\t2011 Mar 27  2:00s\n-\t\t\t 7:00\t-\t+07\t2014 Oct 26  2:00s\n-\t\t\t 6:00\t-\t+06\t2016 Jul 24  2:00s\n-\t\t\t 7:00\t-\t+07\n+\t\t\t 6:00\t-\t%z\t1930 Jun 21\n+\t\t\t 7:00\tRussia\t%z\t1991 Mar 31  2:00s\n+\t\t\t 6:00\tRussia\t%z\t1992 Jan 19  2:00s\n+\t\t\t 7:00\tRussia\t%z\t1993 May 23 # say Shanks & P.\n+\t\t\t 6:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t 7:00\t-\t%z\t2014 Oct 26  2:00s\n+\t\t\t 6:00\t-\t%z\t2016 Jul 24  2:00s\n+\t\t\t 7:00\t-\t%z\n@@ -2961,8 +3147,8 @@\n-\t\t\t 6:00\t-\t+06\t1930 Jun 21\n-\t\t\t 7:00\tRussia\t+07\/+08\t1991 Mar 31  2:00s\n-\t\t\t 6:00\tRussia\t+06\/+07\t1992 Jan 19  2:00s\n-\t\t\t 7:00\tRussia\t+07\/+08\t2002 May  1  3:00\n-\t\t\t 6:00\tRussia\t+06\/+07\t2011 Mar 27  2:00s\n-\t\t\t 7:00\t-\t+07\t2014 Oct 26  2:00s\n-\t\t\t 6:00\t-\t+06\t2016 May 29  2:00s\n-\t\t\t 7:00\t-\t+07\n+\t\t\t 6:00\t-\t%z\t1930 Jun 21\n+\t\t\t 7:00\tRussia\t%z\t1991 Mar 31  2:00s\n+\t\t\t 6:00\tRussia\t%z\t1992 Jan 19  2:00s\n+\t\t\t 7:00\tRussia\t%z\t2002 May  1  3:00\n+\t\t\t 6:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t 7:00\t-\t%z\t2014 Oct 26  2:00s\n+\t\t\t 6:00\t-\t%z\t2016 May 29  2:00s\n+\t\t\t 7:00\t-\t%z\n@@ -2999,6 +3185,6 @@\n-\t\t\t 6:00\t-\t+06\t1930 Jun 21\n-\t\t\t 7:00\tRussia\t+07\/+08\t1991 Mar 31  2:00s\n-\t\t\t 6:00\tRussia\t+06\/+07\t1992 Jan 19  2:00s\n-\t\t\t 7:00\tRussia\t+07\/+08\t2010 Mar 28  2:00s\n-\t\t\t 6:00\tRussia\t+06\/+07\t2011 Mar 27  2:00s\n-\t\t\t 7:00\t-\t+07\n+\t\t\t 6:00\t-\t%z\t1930 Jun 21\n+\t\t\t 7:00\tRussia\t%z\t1991 Mar 31  2:00s\n+\t\t\t 6:00\tRussia\t%z\t1992 Jan 19  2:00s\n+\t\t\t 7:00\tRussia\t%z\t2010 Mar 28  2:00s\n+\t\t\t 6:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t 7:00\t-\t%z\n@@ -3018,6 +3204,6 @@\n-\t\t\t 6:00\t-\t+06\t1930 Jun 21\n-\t\t\t 7:00\tRussia\t+07\/+08\t1991 Mar 31  2:00s\n-\t\t\t 6:00\tRussia\t+06\/+07\t1992 Jan 19  2:00s\n-\t\t\t 7:00\tRussia\t+07\/+08\t2011 Mar 27  2:00s\n-\t\t\t 8:00\t-\t+08\t2014 Oct 26  2:00s\n-\t\t\t 7:00\t-\t+07\n+\t\t\t 6:00\t-\t%z\t1930 Jun 21\n+\t\t\t 7:00\tRussia\t%z\t1991 Mar 31  2:00s\n+\t\t\t 6:00\tRussia\t%z\t1992 Jan 19  2:00s\n+\t\t\t 7:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t 8:00\t-\t%z\t2014 Oct 26  2:00s\n+\t\t\t 7:00\t-\t%z\n@@ -3040,6 +3226,6 @@\n-\t\t\t 7:00\t-\t+07\t1930 Jun 21\n-\t\t\t 8:00\tRussia\t+08\/+09\t1991 Mar 31  2:00s\n-\t\t\t 7:00\tRussia\t+07\/+08\t1992 Jan 19  2:00s\n-\t\t\t 8:00\tRussia\t+08\/+09\t2011 Mar 27  2:00s\n-\t\t\t 9:00\t-\t+09\t2014 Oct 26  2:00s\n-\t\t\t 8:00\t-\t+08\n+\t\t\t 7:00\t-\t%z\t1930 Jun 21\n+\t\t\t 8:00\tRussia\t%z\t1991 Mar 31  2:00s\n+\t\t\t 7:00\tRussia\t%z\t1992 Jan 19  2:00s\n+\t\t\t 8:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t 9:00\t-\t%z\t2014 Oct 26  2:00s\n+\t\t\t 8:00\t-\t%z\n@@ -3062,7 +3248,7 @@\n-\t\t\t 8:00\t-\t+08\t1930 Jun 21\n-\t\t\t 9:00\tRussia\t+09\/+10\t1991 Mar 31  2:00s\n-\t\t\t 8:00\tRussia\t+08\/+09\t1992 Jan 19  2:00s\n-\t\t\t 9:00\tRussia\t+09\/+10\t2011 Mar 27  2:00s\n-\t\t\t10:00\t-\t+10\t2014 Oct 26  2:00s\n-\t\t\t 8:00\t-\t+08\t2016 Mar 27  2:00\n-\t\t\t 9:00\t-\t+09\n+\t\t\t 8:00\t-\t%z\t1930 Jun 21\n+\t\t\t 9:00\tRussia\t%z\t1991 Mar 31  2:00s\n+\t\t\t 8:00\tRussia\t%z\t1992 Jan 19  2:00s\n+\t\t\t 9:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t10:00\t-\t%z\t2014 Oct 26  2:00s\n+\t\t\t 8:00\t-\t%z\t2016 Mar 27  2:00\n+\t\t\t 9:00\t-\t%z\n@@ -3108,6 +3294,6 @@\n-\t\t\t 8:00\t-\t+08\t1930 Jun 21\n-\t\t\t 9:00\tRussia\t+09\/+10\t1991 Mar 31  2:00s\n-\t\t\t 8:00\tRussia\t+08\/+09\t1992 Jan 19  2:00s\n-\t\t\t 9:00\tRussia\t+09\/+10\t2011 Mar 27  2:00s\n-\t\t\t10:00\t-\t+10\t2014 Oct 26  2:00s\n-\t\t\t 9:00\t-\t+09\n+\t\t\t 8:00\t-\t%z\t1930 Jun 21\n+\t\t\t 9:00\tRussia\t%z\t1991 Mar 31  2:00s\n+\t\t\t 8:00\tRussia\t%z\t1992 Jan 19  2:00s\n+\t\t\t 9:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t10:00\t-\t%z\t2014 Oct 26  2:00s\n+\t\t\t 9:00\t-\t%z\n@@ -3131,6 +3317,6 @@\n-\t\t\t 9:00\t-\t+09\t1930 Jun 21\n-\t\t\t10:00\tRussia\t+10\/+11\t1991 Mar 31  2:00s\n-\t\t\t 9:00\tRussia\t+09\/+10\t1992 Jan 19  2:00s\n-\t\t\t10:00\tRussia\t+10\/+11\t2011 Mar 27  2:00s\n-\t\t\t11:00\t-\t+11\t2014 Oct 26  2:00s\n-\t\t\t10:00\t-\t+10\n+\t\t\t 9:00\t-\t%z\t1930 Jun 21\n+\t\t\t10:00\tRussia\t%z\t1991 Mar 31  2:00s\n+\t\t\t 9:00\tRussia\t%z\t1992 Jan 19  2:00s\n+\t\t\t10:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t11:00\t-\t%z\t2014 Oct 26  2:00s\n+\t\t\t10:00\t-\t%z\n@@ -3154,8 +3340,8 @@\n-\t\t\t 8:00\t-\t+08\t1930 Jun 21\n-\t\t\t 9:00\tRussia\t+09\/+10\t1991 Mar 31  2:00s\n-\t\t\t 8:00\tRussia\t+08\/+09\t1992 Jan 19  2:00s\n-\t\t\t 9:00\tRussia\t+09\/+10\t2004\n-\t\t\t10:00\tRussia\t+10\/+11\t2011 Mar 27  2:00s\n-\t\t\t11:00\t-\t+11\t2011 Sep 13  0:00s # Decree 725?\n-\t\t\t10:00\t-\t+10\t2014 Oct 26  2:00s\n-\t\t\t 9:00\t-\t+09\n+\t\t\t 8:00\t-\t%z\t1930 Jun 21\n+\t\t\t 9:00\tRussia\t%z\t1991 Mar 31  2:00s\n+\t\t\t 8:00\tRussia\t%z\t1992 Jan 19  2:00s\n+\t\t\t 9:00\tRussia\t%z\t2004\n+\t\t\t10:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t11:00\t-\t%z\t2011 Sep 13  0:00s # Decree 725?\n+\t\t\t10:00\t-\t%z\t2014 Oct 26  2:00s\n+\t\t\t 9:00\t-\t%z\n@@ -3177,8 +3363,8 @@\n-\t\t\t 9:00\t-\t+09\t1945 Aug 25\n-\t\t\t11:00\tRussia\t+11\/+12\t1991 Mar 31  2:00s # Sakhalin T\n-\t\t\t10:00\tRussia\t+10\/+11\t1992 Jan 19  2:00s\n-\t\t\t11:00\tRussia\t+11\/+12\t1997 Mar lastSun  2:00s\n-\t\t\t10:00\tRussia\t+10\/+11\t2011 Mar 27  2:00s\n-\t\t\t11:00\t-\t+11\t2014 Oct 26  2:00s\n-\t\t\t10:00\t-\t+10\t2016 Mar 27  2:00s\n-\t\t\t11:00\t-\t+11\n+\t\t\t 9:00\t-\t%z\t1945 Aug 25\n+\t\t\t11:00\tRussia\t%z\t1991 Mar 31  2:00s # Sakhalin T\n+\t\t\t10:00\tRussia\t%z\t1992 Jan 19  2:00s\n+\t\t\t11:00\tRussia\t%z\t1997 Mar lastSun  2:00s\n+\t\t\t10:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t11:00\t-\t%z\t2014 Oct 26  2:00s\n+\t\t\t10:00\t-\t%z\t2016 Mar 27  2:00s\n+\t\t\t11:00\t-\t%z\n@@ -3207,7 +3393,7 @@\n-\t\t\t10:00\t-\t+10\t1930 Jun 21 # Magadan Time\n-\t\t\t11:00\tRussia\t+11\/+12\t1991 Mar 31  2:00s\n-\t\t\t10:00\tRussia\t+10\/+11\t1992 Jan 19  2:00s\n-\t\t\t11:00\tRussia\t+11\/+12\t2011 Mar 27  2:00s\n-\t\t\t12:00\t-\t+12\t2014 Oct 26  2:00s\n-\t\t\t10:00\t-\t+10\t2016 Apr 24  2:00s\n-\t\t\t11:00\t-\t+11\n+\t\t\t10:00\t-\t%z\t1930 Jun 21 # Magadan Time\n+\t\t\t11:00\tRussia\t%z\t1991 Mar 31  2:00s\n+\t\t\t10:00\tRussia\t%z\t1992 Jan 19  2:00s\n+\t\t\t11:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t12:00\t-\t%z\t2014 Oct 26  2:00s\n+\t\t\t10:00\t-\t%z\t2016 Apr 24  2:00s\n+\t\t\t11:00\t-\t%z\n@@ -3258,6 +3444,6 @@\n-\t\t\t10:00\t-\t+10\t1930 Jun 21\n-\t\t\t11:00\tRussia\t+11\/+12\t1991 Mar 31  2:00s\n-\t\t\t10:00\tRussia\t+10\/+11\t1992 Jan 19  2:00s\n-\t\t\t11:00\tRussia\t+11\/+12\t2011 Mar 27  2:00s\n-\t\t\t12:00\t-\t+12\t2014 Oct 26  2:00s\n-\t\t\t11:00\t-\t+11\n+\t\t\t10:00\t-\t%z\t1930 Jun 21\n+\t\t\t11:00\tRussia\t%z\t1991 Mar 31  2:00s\n+\t\t\t10:00\tRussia\t%z\t1992 Jan 19  2:00s\n+\t\t\t11:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t12:00\t-\t%z\t2014 Oct 26  2:00s\n+\t\t\t11:00\t-\t%z\n@@ -3281,8 +3467,8 @@\n-\t\t\t 8:00\t-\t+08\t1930 Jun 21\n-\t\t\t 9:00\tRussia\t+09\/+10\t1981 Apr  1\n-\t\t\t11:00\tRussia\t+11\/+12\t1991 Mar 31  2:00s\n-\t\t\t10:00\tRussia\t+10\/+11\t1992 Jan 19  2:00s\n-\t\t\t11:00\tRussia\t+11\/+12\t2011 Mar 27  2:00s\n-\t\t\t12:00\t-\t+12\t2011 Sep 13  0:00s # Decree 725?\n-\t\t\t11:00\t-\t+11\t2014 Oct 26  2:00s\n-\t\t\t10:00\t-\t+10\n+\t\t\t 8:00\t-\t%z\t1930 Jun 21\n+\t\t\t 9:00\tRussia\t%z\t1981 Apr  1\n+\t\t\t11:00\tRussia\t%z\t1991 Mar 31  2:00s\n+\t\t\t10:00\tRussia\t%z\t1992 Jan 19  2:00s\n+\t\t\t11:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t12:00\t-\t%z\t2011 Sep 13  0:00s # Decree 725?\n+\t\t\t11:00\t-\t%z\t2014 Oct 26  2:00s\n+\t\t\t10:00\t-\t%z\n@@ -3301,6 +3487,6 @@\n-\t\t\t11:00\t-\t+11\t1930 Jun 21\n-\t\t\t12:00\tRussia\t+12\/+13\t1991 Mar 31  2:00s\n-\t\t\t11:00\tRussia\t+11\/+12\t1992 Jan 19  2:00s\n-\t\t\t12:00\tRussia\t+12\/+13\t2010 Mar 28  2:00s\n-\t\t\t11:00\tRussia\t+11\/+12\t2011 Mar 27  2:00s\n-\t\t\t12:00\t-\t+12\n+\t\t\t11:00\t-\t%z\t1930 Jun 21\n+\t\t\t12:00\tRussia\t%z\t1991 Mar 31  2:00s\n+\t\t\t11:00\tRussia\t%z\t1992 Jan 19  2:00s\n+\t\t\t12:00\tRussia\t%z\t2010 Mar 28  2:00s\n+\t\t\t11:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t12:00\t-\t%z\n@@ -3314,7 +3500,7 @@\n-\t\t\t12:00\t-\t+12\t1930 Jun 21\n-\t\t\t13:00\tRussia\t+13\/+14\t1982 Apr  1  0:00s\n-\t\t\t12:00\tRussia\t+12\/+13\t1991 Mar 31  2:00s\n-\t\t\t11:00\tRussia\t+11\/+12\t1992 Jan 19  2:00s\n-\t\t\t12:00\tRussia\t+12\/+13\t2010 Mar 28  2:00s\n-\t\t\t11:00\tRussia\t+11\/+12\t2011 Mar 27  2:00s\n-\t\t\t12:00\t-\t+12\n+\t\t\t12:00\t-\t%z\t1930 Jun 21\n+\t\t\t13:00\tRussia\t%z\t1982 Apr  1  0:00s\n+\t\t\t12:00\tRussia\t%z\t1991 Mar 31  2:00s\n+\t\t\t11:00\tRussia\t%z\t1992 Jan 19  2:00s\n+\t\t\t12:00\tRussia\t%z\t2010 Mar 28  2:00s\n+\t\t\t11:00\tRussia\t%z\t2011 Mar 27  2:00s\n+\t\t\t12:00\t-\t%z\n@@ -3439,1 +3625,1 @@\n-\t\t\t-1:00\t-\t-01\t1946 Sep 30  1:00\n+\t\t\t-1:00\t-\t%z\t1946 Sep 30  1:00\n@@ -3520,2 +3706,2 @@\n-# From Paul Eggert (2013-09-11):\n-# Round BMT to the nearest even second, 0:29:46.\n+# From Paul Eggert (2024-05-24):\n+# Express BMT as 0:29:45.500, approximately the same precision 7 26' 22.50\".\n@@ -3560,0 +3746,1 @@\n+\t\t#STDOFF\t0:29:45.500\n@@ -3757,1 +3944,1 @@\n-\t\t\t3:00\tTurkey\t+03\/+04\t1984 Nov  1  2:00\n+\t\t\t3:00\tTurkey\t%z\t1984 Nov  1  2:00\n@@ -3766,1 +3953,1 @@\n-\t\t\t3:00\t-\t+03\n+\t\t\t3:00\t-\t%z\n","filename":"src\/java.base\/share\/data\/tzdata\/europe","additions":450,"deletions":263,"binary":false,"changes":713,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-#Expires 2024\tDec\t28\t00:00:00\n+#Expires 2025\tJun\t28\t00:00:00\n@@ -98,2 +98,2 @@\n-#updated 1704708379 (2024-01-08 10:06:19 UTC)\n-#expires 1735344000 (2024-12-28 00:00:00 UTC)\n+#updated 1720104763 (2024-07-04 14:52:43 UTC)\n+#expires 1751068800 (2025-06-28 00:00:00 UTC)\n@@ -102,1 +102,1 @@\n-#\tFile expires on 28 December 2024\n+#\tFile expires on 28 June 2025\n","filename":"src\/java.base\/share\/data\/tzdata\/leapseconds","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -211,20 +211,0 @@\n-# From Arthur David Olson, 2005-12-19\n-# We generate the files specified below to guard against old files with\n-# obsolete information being left in the time zone binary directory.\n-# We limit the list to names that have appeared in previous versions of\n-# this time zone package.\n-# We do these as separate Zones rather than as Links to avoid problems if\n-# a particular place changes whether it observes DST.\n-# We put these specifications here in the northamerica file both to\n-# increase the chances that they'll actually get compiled and to\n-# avoid the need to duplicate the US rules in another file.\n-\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tEST\t\t -5:00\t-\tEST\n-Zone\tMST\t\t -7:00\t-\tMST\n-Zone\tHST\t\t-10:00\t-\tHST\n-Zone\tEST5EDT\t\t -5:00\tUS\tE%sT\n-Zone\tCST6CDT\t\t -6:00\tUS\tC%sT\n-Zone\tMST7MDT\t\t -7:00\tUS\tM%sT\n-Zone\tPST8PDT\t\t -8:00\tUS\tP%sT\n-\n@@ -2399,0 +2379,75 @@\n+# From Heitor David Pinto (2024-08-04):\n+# In 1931, the decree implementing DST specified that it would take\n+# effect on 30 April....\n+# https:\/\/www.dof.gob.mx\/nota_to_imagen_fs.php?cod_diario=192270&pagina=2&seccion=1\n+#\n+# In 1981, the decree changing Campeche, Yucatn and Quintana Roo to UTC-5\n+# specified that it would enter into force on 26 December 1981 at 2:00....\n+# https:\/\/www.dof.gob.mx\/nota_to_imagen_fs.php?codnota=4705667&fecha=23\/12\/1981&cod_diario=202796\n+#\n+# In 1982, the decree returning Campeche and Yucatn to UTC-6 specified that\n+# it would enter into force on 2 November 1982 at 2:00....\n+# https:\/\/www.dof.gob.mx\/nota_to_imagen_fs.php?cod_diario=205689&pagina=3&seccion=0\n+#\n+# Quintana Roo changed to UTC-6 on 4 January 1983 at 0:00, and again\n+# to UTC-5 on 26 October 1997 at 2:00....\n+# https:\/\/www.dof.gob.mx\/nota_to_imagen_fs.php?codnota=4787355&fecha=28\/12\/1982&cod_diario=206112\n+# https:\/\/www.dof.gob.mx\/nota_to_imagen_fs.php?cod_diario=209559&pagina=15&seccion=0\n+#\n+# Durango, Coahuila, Nuevo Len and Tamaulipas were set to UTC-7 on 1 January\n+# 1922, and changed to UTC-6 on 10 June 1927.  Then Durango, Coahuila and\n+# Nuevo Len (but not Tamaulipas) returned to UTC-7 on 15 November 1930,\n+# observed DST in 1931, and changed again to UTC-6 on 1 April 1932....\n+# https:\/\/www.dof.gob.mx\/nota_to_imagen_fs.php?codnota=4441846&fecha=29\/12\/1921&cod_diario=187468\n+# https:\/\/www.dof.gob.mx\/nota_to_imagen_fs.php?codnota=4541520&fecha=09\/06\/1927&cod_diario=193920\n+# https:\/\/www.dof.gob.mx\/nota_to_imagen_fs.php?codnota=4491963&fecha=15\/11\/1930&cod_diario=190835\n+# https:\/\/www.dof.gob.mx\/nota_to_imagen_fs.php?codnota=4418437&fecha=21\/01\/1932&cod_diario=185588\n+#\n+# ... the ... 10 June 1927 ... decree only said 10 June 1927, without\n+# specifying a time, so I suppose that it should be considered at 0:00.\n+# https:\/\/www.dof.gob.mx\/nota_to_imagen_fs.php?codnota=4541520&fecha=09\/06\/1927&cod_diario=193920\n+#\n+# In 1942, the decree changing Baja California, Baja California Sur, Sonora,\n+# Sinaloa and Nayarit to UTC-7 was published on 24 April, but it said that it\n+# would apply from 1 April, so it's unclear when the change actually\n+# occurred. The database currently shows 24 April 1942.\n+# https:\/\/www.dof.gob.mx\/nota_to_imagen_fs.php?cod_diario=192203&pagina=2&seccion=1\n+#\n+# Baja California Sur, Sonora, Sinaloa and Nayarit never used UTC-8.  The ...\n+# 14 January 1949 ... change [to UTC-8] only occurred in Baja California.\n+# https:\/\/www.dof.gob.mx\/nota_to_imagen_fs.php?codnota=4515613&fecha=13\/01\/1949&cod_diario=192309\n+#\n+# In 1945, the decree changing Baja California to UTC-8 specified that it\n+# would take effect on the third day from its publication.\n+# It was published on 12 November, so it would take effect on 15 November....\n+# https:\/\/www.dof.gob.mx\/nota_to_imagen_fs.php?codnota=4555049&fecha=12\/11\/1945&cod_diario=194763\n+#\n+# In 1948, the decree changing Baja California to UTC-7 specified that it\n+# would take effect on \"this date\".  The decree was made on 13 March,\n+# but published on 5 April, so it's unclear when the change actually occurred.\n+# The database currently shows 5 April 1948.\n+# https:\/\/www.dof.gob.mx\/nota_to_imagen_fs.php?cod_diario=188624&pagina=2&seccion=0\n+#\n+# In 1949, the decree changing Baja California to UTC-8 was published on 13\n+# January, but it said that it would apply from 1 January, so it's unclear when\n+# the change actually occurred.  The database currently shows 14 January 1949.\n+# https:\/\/www.dof.gob.mx\/nota_to_imagen_fs.php?codnota=4515613&fecha=13\/01\/1949&cod_diario=192309\n+#\n+# Baja California also observed UTC-7 from 1 May to 24 September 1950,\n+# from 29 April to 30 September 1951 at 2:00,\n+# and from 27 April to 28 September 1952 at 2:00....\n+# https:\/\/www.dof.gob.mx\/nota_to_imagen_fs.php?codnota=4600403&fecha=29\/04\/1950&cod_diario=197505\n+# https:\/\/www.dof.gob.mx\/nota_to_imagen_fs.php?codnota=4623553&fecha=23\/09\/1950&cod_diario=198805\n+# https:\/\/www.dof.gob.mx\/nota_to_imagen_fs.php?codnota=4469444&fecha=27\/04\/1951&cod_diario=189317\n+# https:\/\/www.dof.gob.mx\/nota_to_imagen_fs.php?codnota=4533868&fecha=10\/03\/1952&cod_diario=193465\n+#\n+# All changes in Baja California from 1948 to 1952 match those in California,\n+# on the same dates or with a difference of one day.\n+# So it may be easier to implement these changes as DST with rule CA\n+# during this whole period.\n+#\n+# From Paul Eggert (2024-08-18):\n+# For now, maintain the slightly-different history for Baja California,\n+# as we have no information on whether 1948\/1952 clocks in Tijuana followed\n+# the decrees or followed San Diego.\n+\n@@ -2602,1 +2657,1 @@\n-Rule\tMexico\t1931\tonly\t-\tMay\t1\t23:00\t1:00\tD\n+Rule\tMexico\t1931\tonly\t-\tApril\t30\t0:00\t1:00\tD\n@@ -2621,1 +2676,3 @@\n-\t\t\t-6:00\t-\tCST\t1981 Dec 23\n+\t\t\t-6:00\t-\tCST\t1981 Dec 26  2:00\n+\t\t\t-5:00\t-\tEST\t1983 Jan  4  0:00\n+\t\t\t-6:00\tMexico\tC%sT\t1997 Oct 26  2:00\n@@ -2627,2 +2684,2 @@\n-\t\t\t-6:00\t-\tCST\t1981 Dec 23\n-\t\t\t-5:00\t-\tEST\t1982 Dec  2\n+\t\t\t-6:00\t-\tCST\t1981 Dec 26  2:00\n+\t\t\t-5:00\t-\tEST\t1982 Nov  2  2:00\n@@ -2645,0 +2702,3 @@\n+\t\t\t-7:00\t-\tMST\t1927 Jun 10\n+\t\t\t-6:00\t-\tCST\t1930 Nov 15\n+\t\t\t-7:00\tMexico\tM%sT\t1932 Apr  1\n@@ -2650,1 +2710,1 @@\n-\t\t\t-7:00\t-\tMST\t1927 Jun 10 23:00\n+\t\t\t-7:00\t-\tMST\t1927 Jun 10\n@@ -2661,1 +2721,1 @@\n-\t\t\t-7:00\t-\tMST\t1927 Jun 10 23:00\n+\t\t\t-7:00\t-\tMST\t1927 Jun 10\n@@ -2676,1 +2736,1 @@\n-\t\t\t-7:00\t-\tMST\t1927 Jun 10 23:00\n+\t\t\t-7:00\t-\tMST\t1927 Jun 10\n@@ -2688,1 +2748,1 @@\n-\t\t\t-7:00\t-\tMST\t1927 Jun 10 23:00\n+\t\t\t-7:00\t-\tMST\t1927 Jun 10\n@@ -2698,1 +2758,1 @@\n-\t\t\t-7:00\t-\tMST\t1927 Jun 10 23:00\n+\t\t\t-7:00\t-\tMST\t1927 Jun 10\n@@ -2702,2 +2762,1 @@\n-\t\t\t-7:00\t-\tMST\t1949 Jan 14\n-\t\t\t-8:00\t-\tPST\t1970\n+\t\t\t-7:00\t-\tMST\t1996\n@@ -2709,1 +2768,1 @@\n-\t\t\t-7:00\t-\tMST\t1927 Jun 10 23:00\n+\t\t\t-7:00\t-\tMST\t1927 Jun 10\n@@ -2713,2 +2772,1 @@\n-\t\t\t-7:00\t-\tMST\t1949 Jan 14\n-\t\t\t-8:00\t-\tPST\t1970\n+\t\t\t-7:00\t-\tMST\t1970\n@@ -2747,1 +2805,1 @@\n-\t\t\t-7:00\t-\tMST\t1927 Jun 10 23:00\n+\t\t\t-7:00\t-\tMST\t1927 Jun 10\n@@ -2751,2 +2809,1 @@\n-\t\t\t-7:00\t-\tMST\t1949 Jan 14\n-\t\t\t-8:00\t-\tPST\t1970\n+\t\t\t-7:00\t-\tMST\t1970\n@@ -2759,1 +2816,1 @@\n-\t\t\t-8:00\t-\tPST\t1927 Jun 10 23:00\n+\t\t\t-8:00\t-\tPST\t1927 Jun 10\n@@ -2765,1 +2822,1 @@\n-\t\t\t-8:00\t1:00\tPPT\t1945 Nov 12 # Peace\n+\t\t\t-8:00\t1:00\tPPT\t1945 Nov 15 # Peace\n@@ -2768,0 +2825,6 @@\n+\t\t\t-8:00\t-\tPST\t1950 May  1\n+\t\t\t-8:00\t1:00\tPDT\t1950 Sep 24\n+\t\t\t-8:00\t-\tPST\t1951 Apr 29  2:00\n+\t\t\t-8:00\t1:00\tPDT\t1951 Sep 30  2:00\n+\t\t\t-8:00\t-\tPST\t1952 Apr 27  2:00\n+\t\t\t-8:00\t1:00\tPDT\t1952 Sep 28  2:00\n@@ -3576,2 +3639,2 @@\n-\t\t\t-3:00\t-\t-03\t1987\n-\t\t\t-3:00\tCanada\t-03\/-02\n+\t\t\t-3:00\t-\t%z\t1987\n+\t\t\t-3:00\tCanada\t%z\n","filename":"src\/java.base\/share\/data\/tzdata\/northamerica","additions":104,"deletions":41,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -428,5 +428,5 @@\n-\t\t\t-4:00\t-\t-04\t1930 Dec\n-\t\t\t-4:00\tArg\t-04\/-03\t1969 Oct  5\n-\t\t\t-3:00\tArg\t-03\/-02\t1999 Oct  3\n-\t\t\t-4:00\tArg\t-04\/-03\t2000 Mar  3\n-\t\t\t-3:00\tArg\t-03\/-02\n+\t\t\t-4:00\t-\t%z\t1930 Dec\n+\t\t\t-4:00\tArg\t%z\t1969 Oct  5\n+\t\t\t-3:00\tArg\t%z\t1999 Oct  3\n+\t\t\t-4:00\tArg\t%z\t2000 Mar  3\n+\t\t\t-3:00\tArg\t%z\n@@ -447,7 +447,7 @@\n-\t\t\t-4:00\t-\t-04\t1930 Dec\n-\t\t\t-4:00\tArg\t-04\/-03\t1969 Oct  5\n-\t\t\t-3:00\tArg\t-03\/-02\t1991 Mar  3\n-\t\t\t-4:00\t-\t-04\t1991 Oct 20\n-\t\t\t-3:00\tArg\t-03\/-02\t1999 Oct  3\n-\t\t\t-4:00\tArg\t-04\/-03\t2000 Mar  3\n-\t\t\t-3:00\tArg\t-03\/-02\n+\t\t\t-4:00\t-\t%z\t1930 Dec\n+\t\t\t-4:00\tArg\t%z\t1969 Oct  5\n+\t\t\t-3:00\tArg\t%z\t1991 Mar  3\n+\t\t\t-4:00\t-\t%z\t1991 Oct 20\n+\t\t\t-3:00\tArg\t%z\t1999 Oct  3\n+\t\t\t-4:00\tArg\t%z\t2000 Mar  3\n+\t\t\t-3:00\tArg\t%z\n@@ -459,8 +459,8 @@\n-\t\t\t-4:00\t-\t-04\t1930 Dec\n-\t\t\t-4:00\tArg\t-04\/-03\t1969 Oct  5\n-\t\t\t-3:00\tArg\t-03\/-02\t1991 Mar  3\n-\t\t\t-4:00\t-\t-04\t1991 Oct 20\n-\t\t\t-3:00\tArg\t-03\/-02\t1999 Oct  3\n-\t\t\t-4:00\tArg\t-04\/-03\t2000 Mar  3\n-\t\t\t-3:00\tArg\t-03\/-02\t2008 Oct 18\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-4:00\t-\t%z\t1930 Dec\n+\t\t\t-4:00\tArg\t%z\t1969 Oct  5\n+\t\t\t-3:00\tArg\t%z\t1991 Mar  3\n+\t\t\t-4:00\t-\t%z\t1991 Oct 20\n+\t\t\t-3:00\tArg\t%z\t1999 Oct  3\n+\t\t\t-4:00\tArg\t%z\t2000 Mar  3\n+\t\t\t-3:00\tArg\t%z\t2008 Oct 18\n+\t\t\t-3:00\t-\t%z\n@@ -472,9 +472,9 @@\n-\t\t\t-4:00\t-\t-04\t1930 Dec\n-\t\t\t-4:00\tArg\t-04\/-03\t1969 Oct  5\n-\t\t\t-3:00\tArg\t-03\/-02\t1991 Mar  3\n-\t\t\t-4:00\t-\t-04\t1991 Oct 20\n-\t\t\t-3:00\tArg\t-03\/-02\t1999 Oct  3\n-\t\t\t-4:00\tArg\t-04\/-03\t2000 Mar  3\n-\t\t\t-3:00\t-\t-03\t2004 Jun  1\n-\t\t\t-4:00\t-\t-04\t2004 Jun 13\n-\t\t\t-3:00\tArg\t-03\/-02\n+\t\t\t-4:00\t-\t%z\t1930 Dec\n+\t\t\t-4:00\tArg\t%z\t1969 Oct  5\n+\t\t\t-3:00\tArg\t%z\t1991 Mar  3\n+\t\t\t-4:00\t-\t%z\t1991 Oct 20\n+\t\t\t-3:00\tArg\t%z\t1999 Oct  3\n+\t\t\t-4:00\tArg\t%z\t2000 Mar  3\n+\t\t\t-3:00\t-\t%z\t2004 Jun  1\n+\t\t\t-4:00\t-\t%z\t2004 Jun 13\n+\t\t\t-3:00\tArg\t%z\n@@ -486,10 +486,10 @@\n-\t\t\t-4:00\t-\t-04\t1930 Dec\n-\t\t\t-4:00\tArg\t-04\/-03\t1969 Oct  5\n-\t\t\t-3:00\tArg\t-03\/-02\t1991 Mar  1\n-\t\t\t-4:00\t-\t-04\t1991 May  7\n-\t\t\t-3:00\tArg\t-03\/-02\t1999 Oct  3\n-\t\t\t-4:00\tArg\t-04\/-03\t2000 Mar  3\n-\t\t\t-3:00\t-\t-03\t2004 Jun  1\n-\t\t\t-4:00\t-\t-04\t2004 Jun 20\n-\t\t\t-3:00\tArg\t-03\/-02\t2008 Oct 18\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-4:00\t-\t%z\t1930 Dec\n+\t\t\t-4:00\tArg\t%z\t1969 Oct  5\n+\t\t\t-3:00\tArg\t%z\t1991 Mar  1\n+\t\t\t-4:00\t-\t%z\t1991 May  7\n+\t\t\t-3:00\tArg\t%z\t1999 Oct  3\n+\t\t\t-4:00\tArg\t%z\t2000 Mar  3\n+\t\t\t-3:00\t-\t%z\t2004 Jun  1\n+\t\t\t-4:00\t-\t%z\t2004 Jun 20\n+\t\t\t-3:00\tArg\t%z\t2008 Oct 18\n+\t\t\t-3:00\t-\t%z\n@@ -501,10 +501,10 @@\n-\t\t\t-4:00\t-\t-04\t1930 Dec\n-\t\t\t-4:00\tArg\t-04\/-03\t1969 Oct  5\n-\t\t\t-3:00\tArg\t-03\/-02\t1991 Mar  1\n-\t\t\t-4:00\t-\t-04\t1991 May  7\n-\t\t\t-3:00\tArg\t-03\/-02\t1999 Oct  3\n-\t\t\t-4:00\tArg\t-04\/-03\t2000 Mar  3\n-\t\t\t-3:00\t-\t-03\t2004 May 31\n-\t\t\t-4:00\t-\t-04\t2004 Jul 25\n-\t\t\t-3:00\tArg\t-03\/-02\t2008 Oct 18\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-4:00\t-\t%z\t1930 Dec\n+\t\t\t-4:00\tArg\t%z\t1969 Oct  5\n+\t\t\t-3:00\tArg\t%z\t1991 Mar  1\n+\t\t\t-4:00\t-\t%z\t1991 May  7\n+\t\t\t-3:00\tArg\t%z\t1999 Oct  3\n+\t\t\t-4:00\tArg\t%z\t2000 Mar  3\n+\t\t\t-3:00\t-\t%z\t2004 May 31\n+\t\t\t-4:00\t-\t%z\t2004 Jul 25\n+\t\t\t-3:00\tArg\t%z\t2008 Oct 18\n+\t\t\t-3:00\t-\t%z\n@@ -516,11 +516,11 @@\n-\t\t\t-4:00\t-\t-04\t1930 Dec\n-\t\t\t-4:00\tArg\t-04\/-03\t1969 Oct  5\n-\t\t\t-3:00\tArg\t-03\/-02\t1990 Mar  4\n-\t\t\t-4:00\t-\t-04\t1990 Oct 28\n-\t\t\t-4:00\t1:00\t-03\t1991 Mar 17\n-\t\t\t-4:00\t-\t-04\t1991 Oct  6\n-\t\t\t-3:00\t1:00\t-02\t1992\n-\t\t\t-3:00\tArg\t-03\/-02\t1999 Oct  3\n-\t\t\t-4:00\tArg\t-04\/-03\t2000 Mar  3\n-\t\t\t-3:00\tArg\t-03\/-02\t2008 Oct 18\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-4:00\t-\t%z\t1930 Dec\n+\t\t\t-4:00\tArg\t%z\t1969 Oct  5\n+\t\t\t-3:00\tArg\t%z\t1990 Mar  4\n+\t\t\t-4:00\t-\t%z\t1990 Oct 28\n+\t\t\t-4:00\t1:00\t%z\t1991 Mar 17\n+\t\t\t-4:00\t-\t%z\t1991 Oct  6\n+\t\t\t-3:00\t1:00\t%z\t1992\n+\t\t\t-3:00\tArg\t%z\t1999 Oct  3\n+\t\t\t-4:00\tArg\t%z\t2000 Mar  3\n+\t\t\t-3:00\tArg\t%z\t2008 Oct 18\n+\t\t\t-3:00\t-\t%z\n@@ -532,10 +532,10 @@\n-\t\t\t-4:00\t-\t-04\t1930 Dec\n-\t\t\t-4:00\tArg\t-04\/-03\t1969 Oct  5\n-\t\t\t-3:00\tArg\t-03\/-02\t1991 Mar  3\n-\t\t\t-4:00\t-\t-04\t1991 Oct 20\n-\t\t\t-3:00\tArg\t-03\/-02\t1999 Oct  3\n-\t\t\t-4:00\tArg\t-04\/-03\t2000 Mar  3\n-\t\t\t-3:00\t-\t-03\t2004 Jun  1\n-\t\t\t-4:00\t-\t-04\t2004 Jun 20\n-\t\t\t-3:00\tArg\t-03\/-02\t2008 Oct 18\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-4:00\t-\t%z\t1930 Dec\n+\t\t\t-4:00\tArg\t%z\t1969 Oct  5\n+\t\t\t-3:00\tArg\t%z\t1991 Mar  3\n+\t\t\t-4:00\t-\t%z\t1991 Oct 20\n+\t\t\t-3:00\tArg\t%z\t1999 Oct  3\n+\t\t\t-4:00\tArg\t%z\t2000 Mar  3\n+\t\t\t-3:00\t-\t%z\t2004 Jun  1\n+\t\t\t-4:00\t-\t%z\t2004 Jun 20\n+\t\t\t-3:00\tArg\t%z\t2008 Oct 18\n+\t\t\t-3:00\t-\t%z\n@@ -547,14 +547,14 @@\n-\t\t\t-4:00\t-\t-04\t1930 Dec\n-\t\t\t-4:00\tArg\t-04\/-03\t1969 Oct  5\n-\t\t\t-3:00\tArg\t-03\/-02\t1990 Mar  4\n-\t\t\t-4:00\t-\t-04\t1990 Oct 15\n-\t\t\t-4:00\t1:00\t-03\t1991 Mar  1\n-\t\t\t-4:00\t-\t-04\t1991 Oct 15\n-\t\t\t-4:00\t1:00\t-03\t1992 Mar  1\n-\t\t\t-4:00\t-\t-04\t1992 Oct 18\n-\t\t\t-3:00\tArg\t-03\/-02\t1999 Oct  3\n-\t\t\t-4:00\tArg\t-04\/-03\t2000 Mar  3\n-\t\t\t-3:00\t-\t-03\t2004 May 23\n-\t\t\t-4:00\t-\t-04\t2004 Sep 26\n-\t\t\t-3:00\tArg\t-03\/-02\t2008 Oct 18\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-4:00\t-\t%z\t1930 Dec\n+\t\t\t-4:00\tArg\t%z\t1969 Oct  5\n+\t\t\t-3:00\tArg\t%z\t1990 Mar  4\n+\t\t\t-4:00\t-\t%z\t1990 Oct 15\n+\t\t\t-4:00\t1:00\t%z\t1991 Mar  1\n+\t\t\t-4:00\t-\t%z\t1991 Oct 15\n+\t\t\t-4:00\t1:00\t%z\t1992 Mar  1\n+\t\t\t-4:00\t-\t%z\t1992 Oct 18\n+\t\t\t-3:00\tArg\t%z\t1999 Oct  3\n+\t\t\t-4:00\tArg\t%z\t2000 Mar  3\n+\t\t\t-3:00\t-\t%z\t2004 May 23\n+\t\t\t-4:00\t-\t%z\t2004 Sep 26\n+\t\t\t-3:00\tArg\t%z\t2008 Oct 18\n+\t\t\t-3:00\t-\t%z\n@@ -570,14 +570,14 @@\n-\t\t\t-4:00\t-\t-04\t1930 Dec\n-\t\t\t-4:00\tArg\t-04\/-03\t1969 Oct  5\n-\t\t\t-3:00\tArg\t-03\/-02\t1990\n-\t\t\t-3:00\t1:00\t-02\t1990 Mar 14\n-\t\t\t-4:00\t-\t-04\t1990 Oct 15\n-\t\t\t-4:00\t1:00\t-03\t1991 Mar  1\n-\t\t\t-4:00\t-\t-04\t1991 Jun  1\n-\t\t\t-3:00\t-\t-03\t1999 Oct  3\n-\t\t\t-4:00\t1:00\t-03\t2000 Mar  3\n-\t\t\t-3:00\t-\t-03\t2004 May 31\n-\t\t\t-4:00\t-\t-04\t2004 Jul 25\n-\t\t\t-3:00\tArg\t-03\/-02\t2008 Jan 21\n-\t\t\t-4:00\tSanLuis\t-04\/-03\t2009 Oct 11\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-4:00\t-\t%z\t1930 Dec\n+\t\t\t-4:00\tArg\t%z\t1969 Oct  5\n+\t\t\t-3:00\tArg\t%z\t1990\n+\t\t\t-3:00\t1:00\t%z\t1990 Mar 14\n+\t\t\t-4:00\t-\t%z\t1990 Oct 15\n+\t\t\t-4:00\t1:00\t%z\t1991 Mar  1\n+\t\t\t-4:00\t-\t%z\t1991 Jun  1\n+\t\t\t-3:00\t-\t%z\t1999 Oct  3\n+\t\t\t-4:00\t1:00\t%z\t2000 Mar  3\n+\t\t\t-3:00\t-\t%z\t2004 May 31\n+\t\t\t-4:00\t-\t%z\t2004 Jul 25\n+\t\t\t-3:00\tArg\t%z\t2008 Jan 21\n+\t\t\t-4:00\tSanLuis\t%z\t2009 Oct 11\n+\t\t\t-3:00\t-\t%z\n@@ -589,8 +589,8 @@\n-\t\t\t-4:00\t-\t-04\t1930 Dec\n-\t\t\t-4:00\tArg\t-04\/-03\t1969 Oct  5\n-\t\t\t-3:00\tArg\t-03\/-02\t1999 Oct  3\n-\t\t\t-4:00\tArg\t-04\/-03\t2000 Mar  3\n-\t\t\t-3:00\t-\t-03\t2004 Jun  1\n-\t\t\t-4:00\t-\t-04\t2004 Jun 20\n-\t\t\t-3:00\tArg\t-03\/-02\t2008 Oct 18\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-4:00\t-\t%z\t1930 Dec\n+\t\t\t-4:00\tArg\t%z\t1969 Oct  5\n+\t\t\t-3:00\tArg\t%z\t1999 Oct  3\n+\t\t\t-4:00\tArg\t%z\t2000 Mar  3\n+\t\t\t-3:00\t-\t%z\t2004 Jun  1\n+\t\t\t-4:00\t-\t%z\t2004 Jun 20\n+\t\t\t-3:00\tArg\t%z\t2008 Oct 18\n+\t\t\t-3:00\t-\t%z\n@@ -602,8 +602,8 @@\n-\t\t\t-4:00\t-\t-04\t1930 Dec\n-\t\t\t-4:00\tArg\t-04\/-03\t1969 Oct  5\n-\t\t\t-3:00\tArg\t-03\/-02\t1999 Oct  3\n-\t\t\t-4:00\tArg\t-04\/-03\t2000 Mar  3\n-\t\t\t-3:00\t-\t-03\t2004 May 30\n-\t\t\t-4:00\t-\t-04\t2004 Jun 20\n-\t\t\t-3:00\tArg\t-03\/-02\t2008 Oct 18\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-4:00\t-\t%z\t1930 Dec\n+\t\t\t-4:00\tArg\t%z\t1969 Oct  5\n+\t\t\t-3:00\tArg\t%z\t1999 Oct  3\n+\t\t\t-4:00\tArg\t%z\t2000 Mar  3\n+\t\t\t-3:00\t-\t%z\t2004 May 30\n+\t\t\t-4:00\t-\t%z\t2004 Jun 20\n+\t\t\t-3:00\tArg\t%z\t2008 Oct 18\n+\t\t\t-3:00\t-\t%z\n@@ -616,1 +616,1 @@\n-\t\t\t-4:00\t-\t-04\n+\t\t\t-4:00\t-\t%z\n@@ -987,6 +987,6 @@\n-\t\t\t-2:00\tBrazil\t-02\/-01\t1990 Sep 17\n-\t\t\t-2:00\t-\t-02\t1999 Sep 30\n-\t\t\t-2:00\tBrazil\t-02\/-01\t2000 Oct 15\n-\t\t\t-2:00\t-\t-02\t2001 Sep 13\n-\t\t\t-2:00\tBrazil\t-02\/-01\t2002 Oct  1\n-\t\t\t-2:00\t-\t-02\n+\t\t\t-2:00\tBrazil\t%z\t1990 Sep 17\n+\t\t\t-2:00\t-\t%z\t1999 Sep 30\n+\t\t\t-2:00\tBrazil\t%z\t2000 Oct 15\n+\t\t\t-2:00\t-\t%z\t2001 Sep 13\n+\t\t\t-2:00\tBrazil\t%z\t2002 Oct  1\n+\t\t\t-2:00\t-\t%z\n@@ -1005,2 +1005,2 @@\n-\t\t\t-3:00\tBrazil\t-03\/-02\t1988 Sep 12\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-3:00\tBrazil\t%z\t1988 Sep 12\n+\t\t\t-3:00\t-\t%z\n@@ -1011,3 +1011,3 @@\n-\t\t\t-4:00\tBrazil\t-04\/-03\t1988 Sep 12\n-\t\t\t-4:00\t-\t-04\t2008 Jun 24  0:00\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-4:00\tBrazil\t%z\t1988 Sep 12\n+\t\t\t-4:00\t-\t%z\t2008 Jun 24  0:00\n+\t\t\t-3:00\t-\t%z\n@@ -1018,6 +1018,6 @@\n-\t\t\t-3:00\tBrazil\t-03\/-02\t1990 Sep 17\n-\t\t\t-3:00\t-\t-03\t1999 Sep 30\n-\t\t\t-3:00\tBrazil\t-03\/-02\t2000 Oct 22\n-\t\t\t-3:00\t-\t-03\t2001 Sep 13\n-\t\t\t-3:00\tBrazil\t-03\/-02\t2002 Oct  1\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-3:00\tBrazil\t%z\t1990 Sep 17\n+\t\t\t-3:00\t-\t%z\t1999 Sep 30\n+\t\t\t-3:00\tBrazil\t%z\t2000 Oct 22\n+\t\t\t-3:00\t-\t%z\t2001 Sep 13\n+\t\t\t-3:00\tBrazil\t%z\t2002 Oct  1\n+\t\t\t-3:00\t-\t%z\n@@ -1027,6 +1027,6 @@\n-\t\t\t-3:00\tBrazil\t-03\/-02\t1990 Sep 17\n-\t\t\t-3:00\t-\t-03\t1999 Sep 30\n-\t\t\t-3:00\tBrazil\t-03\/-02\t2000 Oct 15\n-\t\t\t-3:00\t-\t-03\t2001 Sep 13\n-\t\t\t-3:00\tBrazil\t-03\/-02\t2002 Oct  1\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-3:00\tBrazil\t%z\t1990 Sep 17\n+\t\t\t-3:00\t-\t%z\t1999 Sep 30\n+\t\t\t-3:00\tBrazil\t%z\t2000 Oct 15\n+\t\t\t-3:00\t-\t%z\t2001 Sep 13\n+\t\t\t-3:00\tBrazil\t%z\t2002 Oct  1\n+\t\t\t-3:00\t-\t%z\n@@ -1036,6 +1036,6 @@\n-\t\t\t-3:00\tBrazil\t-03\/-02\t1990 Sep 17\n-\t\t\t-3:00\t-\t-03\t1995 Sep 14\n-\t\t\t-3:00\tBrazil\t-03\/-02\t2003 Sep 24\n-\t\t\t-3:00\t-\t-03\t2012 Oct 21\n-\t\t\t-3:00\tBrazil\t-03\/-02\t2013 Sep\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-3:00\tBrazil\t%z\t1990 Sep 17\n+\t\t\t-3:00\t-\t%z\t1995 Sep 14\n+\t\t\t-3:00\tBrazil\t%z\t2003 Sep 24\n+\t\t\t-3:00\t-\t%z\t2012 Oct 21\n+\t\t\t-3:00\tBrazil\t%z\t2013 Sep\n+\t\t\t-3:00\t-\t%z\n@@ -1045,8 +1045,8 @@\n-\t\t\t-3:00\tBrazil\t-03\/-02\t1990 Sep 17\n-\t\t\t-3:00\t-\t-03\t1995 Oct 13\n-\t\t\t-3:00\tBrazil\t-03\/-02\t1996 Sep  4\n-\t\t\t-3:00\t-\t-03\t1999 Sep 30\n-\t\t\t-3:00\tBrazil\t-03\/-02\t2000 Oct 22\n-\t\t\t-3:00\t-\t-03\t2001 Sep 13\n-\t\t\t-3:00\tBrazil\t-03\/-02\t2002 Oct  1\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-3:00\tBrazil\t%z\t1990 Sep 17\n+\t\t\t-3:00\t-\t%z\t1995 Oct 13\n+\t\t\t-3:00\tBrazil\t%z\t1996 Sep  4\n+\t\t\t-3:00\t-\t%z\t1999 Sep 30\n+\t\t\t-3:00\tBrazil\t%z\t2000 Oct 22\n+\t\t\t-3:00\t-\t%z\t2001 Sep 13\n+\t\t\t-3:00\tBrazil\t%z\t2002 Oct  1\n+\t\t\t-3:00\t-\t%z\n@@ -1058,4 +1058,4 @@\n-\t\t\t-3:00\tBrazil\t-03\/-02\t2003 Sep 24\n-\t\t\t-3:00\t-\t-03\t2011 Oct 16\n-\t\t\t-3:00\tBrazil\t-03\/-02\t2012 Oct 21\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-3:00\tBrazil\t%z\t2003 Sep 24\n+\t\t\t-3:00\t-\t%z\t2011 Oct 16\n+\t\t\t-3:00\tBrazil\t%z\t2012 Oct 21\n+\t\t\t-3:00\t-\t%z\n@@ -1067,3 +1067,3 @@\n-\t\t\t-3:00\tBrazil\t-03\/-02\t1963 Oct 23  0:00\n-\t\t\t-3:00\t1:00\t-02\t1964\n-\t\t\t-3:00\tBrazil\t-03\/-02\n+\t\t\t-3:00\tBrazil\t%z\t1963 Oct 23  0:00\n+\t\t\t-3:00\t1:00\t%z\t1964\n+\t\t\t-3:00\tBrazil\t%z\n@@ -1073,1 +1073,1 @@\n-\t\t\t-4:00\tBrazil\t-04\/-03\n+\t\t\t-4:00\tBrazil\t%z\n@@ -1077,3 +1077,3 @@\n-\t\t\t-4:00\tBrazil\t-04\/-03\t2003 Sep 24\n-\t\t\t-4:00\t-\t-04\t2004 Oct  1\n-\t\t\t-4:00\tBrazil\t-04\/-03\n+\t\t\t-4:00\tBrazil\t%z\t2003 Sep 24\n+\t\t\t-4:00\t-\t%z\t2004 Oct  1\n+\t\t\t-4:00\tBrazil\t%z\n@@ -1083,2 +1083,2 @@\n-\t\t\t-4:00\tBrazil\t-04\/-03\t1988 Sep 12\n-\t\t\t-4:00\t-\t-04\n+\t\t\t-4:00\tBrazil\t%z\t1988 Sep 12\n+\t\t\t-4:00\t-\t%z\n@@ -1088,4 +1088,4 @@\n-\t\t\t-4:00\tBrazil\t-04\/-03\t1988 Sep 12\n-\t\t\t-4:00\t-\t-04\t1999 Sep 30\n-\t\t\t-4:00\tBrazil\t-04\/-03\t2000 Oct 15\n-\t\t\t-4:00\t-\t-04\n+\t\t\t-4:00\tBrazil\t%z\t1988 Sep 12\n+\t\t\t-4:00\t-\t%z\t1999 Sep 30\n+\t\t\t-4:00\tBrazil\t%z\t2000 Oct 15\n+\t\t\t-4:00\t-\t%z\n@@ -1097,4 +1097,4 @@\n-\t\t\t-4:00\tBrazil\t-04\/-03\t1988 Sep 12\n-\t\t\t-4:00\t-\t-04\t1993 Sep 28\n-\t\t\t-4:00\tBrazil\t-04\/-03\t1994 Sep 22\n-\t\t\t-4:00\t-\t-04\n+\t\t\t-4:00\tBrazil\t%z\t1988 Sep 12\n+\t\t\t-4:00\t-\t%z\t1993 Sep 28\n+\t\t\t-4:00\tBrazil\t%z\t1994 Sep 22\n+\t\t\t-4:00\t-\t%z\n@@ -1105,6 +1105,6 @@\n-\t\t\t-5:00\tBrazil\t-05\/-04\t1988 Sep 12\n-\t\t\t-5:00\t-\t-05\t1993 Sep 28\n-\t\t\t-5:00\tBrazil\t-05\/-04\t1994 Sep 22\n-\t\t\t-5:00\t-\t-05\t2008 Jun 24  0:00\n-\t\t\t-4:00\t-\t-04\t2013 Nov 10\n-\t\t\t-5:00\t-\t-05\n+\t\t\t-5:00\tBrazil\t%z\t1988 Sep 12\n+\t\t\t-5:00\t-\t%z\t1993 Sep 28\n+\t\t\t-5:00\tBrazil\t%z\t1994 Sep 22\n+\t\t\t-5:00\t-\t%z\t2008 Jun 24  0:00\n+\t\t\t-4:00\t-\t%z\t2013 Nov 10\n+\t\t\t-5:00\t-\t%z\n@@ -1114,4 +1114,4 @@\n-\t\t\t-5:00\tBrazil\t-05\/-04\t1988 Sep 12\n-\t\t\t-5:00\t-\t-05\t2008 Jun 24  0:00\n-\t\t\t-4:00\t-\t-04\t2013 Nov 10\n-\t\t\t-5:00\t-\t-05\n+\t\t\t-5:00\tBrazil\t%z\t1988 Sep 12\n+\t\t\t-5:00\t-\t%z\t2008 Jun 24  0:00\n+\t\t\t-4:00\t-\t%z\t2013 Nov 10\n+\t\t\t-5:00\t-\t%z\n@@ -1385,1 +1385,1 @@\n-\t\t\t-5:00\t-\t-05\t1916 Jul  1\n+\t\t\t-5:00\t-\t%z\t1916 Jul  1\n@@ -1387,1 +1387,1 @@\n-\t\t\t-4:00\t-\t-04\t1919 Jul  1\n+\t\t\t-4:00\t-\t%z\t1919 Jul  1\n@@ -1389,8 +1389,8 @@\n-\t\t\t-5:00\tChile\t-05\/-04\t1932 Sep  1\n-\t\t\t-4:00\t-\t-04\t1942 Jun  1\n-\t\t\t-5:00\t-\t-05\t1942 Aug  1\n-\t\t\t-4:00\t-\t-04\t1946 Jul 14 24:00\n-\t\t\t-4:00\t1:00\t-03\t1946 Aug 28 24:00 # central CL\n-\t\t\t-5:00\t1:00\t-04\t1947 Mar 31 24:00\n-\t\t\t-5:00\t-\t-05\t1947 May 21 23:00\n-\t\t\t-4:00\tChile\t-04\/-03\n+\t\t\t-5:00\tChile\t%z\t1932 Sep  1\n+\t\t\t-4:00\t-\t%z\t1942 Jun  1\n+\t\t\t-5:00\t-\t%z\t1942 Aug  1\n+\t\t\t-4:00\t-\t%z\t1946 Jul 14 24:00\n+\t\t\t-4:00\t1:00\t%z\t1946 Aug 28 24:00 # central CL\n+\t\t\t-5:00\t1:00\t%z\t1947 Mar 31 24:00\n+\t\t\t-5:00\t-\t%z\t1947 May 21 23:00\n+\t\t\t-4:00\tChile\t%z\n@@ -1399,1 +1399,1 @@\n-\t\t\t-5:00\t-\t-05\t1916 Jul  1\n+\t\t\t-5:00\t-\t%z\t1916 Jul  1\n@@ -1401,1 +1401,1 @@\n-\t\t\t-4:00\t-\t-04\t1919 Jul  1\n+\t\t\t-4:00\t-\t%z\t1919 Jul  1\n@@ -1403,8 +1403,8 @@\n-\t\t\t-5:00\tChile\t-05\/-04\t1932 Sep  1\n-\t\t\t-4:00\t-\t-04\t1942 Jun  1\n-\t\t\t-5:00\t-\t-05\t1942 Aug  1\n-\t\t\t-4:00\t-\t-04\t1946 Aug 28 24:00\n-\t\t\t-5:00\t1:00\t-04\t1947 Mar 31 24:00\n-\t\t\t-5:00\t-\t-05\t1947 May 21 23:00\n-\t\t\t-4:00\tChile\t-04\/-03\t2016 Dec  4\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-5:00\tChile\t%z\t1932 Sep  1\n+\t\t\t-4:00\t-\t%z\t1942 Jun  1\n+\t\t\t-5:00\t-\t%z\t1942 Aug  1\n+\t\t\t-4:00\t-\t%z\t1946 Aug 28 24:00\n+\t\t\t-5:00\t1:00\t%z\t1947 Mar 31 24:00\n+\t\t\t-5:00\t-\t%z\t1947 May 21 23:00\n+\t\t\t-4:00\tChile\t%z\t2016 Dec  4\n+\t\t\t-3:00\t-\t%z\n@@ -1413,2 +1413,2 @@\n-\t\t\t-7:00\tChile\t-07\/-06\t1982 Mar 14 3:00u # Easter Time\n-\t\t\t-6:00\tChile\t-06\/-05\n+\t\t\t-7:00\tChile\t%z\t1982 Mar 14 3:00u # Easter Time\n+\t\t\t-6:00\tChile\t%z\n@@ -1434,4 +1434,4 @@\n-\t\t\t-4:00\tArg\t-04\/-03\t1969 Oct  5\n-\t\t\t-3:00\tArg\t-03\/-02\t1982 May\n-\t\t\t-4:00\tChile\t-04\/-03\t2016 Dec  4\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-4:00\tArg\t%z\t1969 Oct  5\n+\t\t\t-3:00\tArg\t%z\t1982 May\n+\t\t\t-4:00\tChile\t%z\t2016 Dec  4\n+\t\t\t-3:00\t-\t%z\n@@ -1456,1 +1456,1 @@\n-\t\t\t-5:00\tCO\t-05\/-04\n+\t\t\t-5:00\tCO\t%z\n@@ -1487,1 +1487,1 @@\n-\t\t\t-5:00\tEcuador\t-05\/-04\n+\t\t\t-5:00\tEcuador\t%z\n@@ -1489,2 +1489,2 @@\n-\t\t\t-5:00\t-\t-05\t1986\n-\t\t\t-6:00\tEcuador\t-06\/-05\n+\t\t\t-5:00\t-\t%z\t1986\n+\t\t\t-6:00\tEcuador\t%z\n@@ -1590,4 +1590,4 @@\n-\t\t\t-4:00\tFalk\t-04\/-03\t1983 May\n-\t\t\t-3:00\tFalk\t-03\/-02\t1985 Sep 15\n-\t\t\t-4:00\tFalk\t-04\/-03\t2010 Sep  5  2:00\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-4:00\tFalk\t%z\t1983 May\n+\t\t\t-3:00\tFalk\t%z\t1985 Sep 15\n+\t\t\t-4:00\tFalk\t%z\t2010 Sep  5  2:00\n+\t\t\t-3:00\t-\t%z\n@@ -1601,2 +1601,2 @@\n-\t\t\t-4:00\t-\t-04\t1967 Oct\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-4:00\t-\t%z\t1967 Oct\n+\t\t\t-3:00\t-\t%z\n@@ -1636,4 +1636,4 @@\n-\t\t\t-4:00\t-\t-04\t1915 Mar  1\n-\t\t\t-3:45\t-\t-0345\t1975 Aug  1\n-\t\t\t-3:00\t-\t-03\t1992 Mar 29  1:00\n-\t\t\t-4:00\t-\t-04\n+\t\t\t-4:00\t-\t%z\t1915 Mar  1\n+\t\t\t-3:45\t-\t%z\t1975 Aug  1\n+\t\t\t-3:00\t-\t%z\t1992 Mar 29  1:00\n+\t\t\t-4:00\t-\t%z\n@@ -1737,3 +1737,3 @@\n-\t\t\t-4:00\t-\t-04\t1972 Oct\n-\t\t\t-3:00\t-\t-03\t1974 Apr\n-\t\t\t-4:00\tPara\t-04\/-03\n+\t\t\t-4:00\t-\t%z\t1972 Oct\n+\t\t\t-3:00\t-\t%z\t1974 Apr\n+\t\t\t-4:00\tPara\t%z\n@@ -1766,1 +1766,1 @@\n-\t\t\t-5:00\tPeru\t-05\/-04\n+\t\t\t-5:00\tPeru\t%z\n@@ -1771,1 +1771,1 @@\n-\t\t\t-2:00\t-\t-02\n+\t\t\t-2:00\t-\t%z\n@@ -1781,2 +1781,2 @@\n-\t\t\t-3:30\t-\t-0330\t1984 Oct\n-\t\t\t-3:00\t-\t-03\n+\t\t\t-3:30\t-\t%z\t1984 Oct\n+\t\t\t-3:00\t-\t%z\n@@ -1997,9 +1997,9 @@\n-\t\t\t-4:00\t-\t-04\t1923 Oct  1\n-\t\t\t-3:30\tUruguay\t-0330\/-03 1942 Dec 14\n-\t\t\t-3:00\tUruguay\t-03\/-0230 1960\n-\t\t\t-3:00\tUruguay\t-03\/-02\t1968\n-\t\t\t-3:00\tUruguay\t-03\/-0230 1970\n-\t\t\t-3:00\tUruguay\t-03\/-02\t1974\n-\t\t\t-3:00\tUruguay\t-03\/-0130 1974 Mar 10\n-\t\t\t-3:00\tUruguay\t-03\/-0230 1974 Dec 22\n-\t\t\t-3:00\tUruguay\t-03\/-02\n+\t\t\t-4:00\t-\t%z\t1923 Oct  1\n+\t\t\t-3:30\tUruguay\t%z\t1942 Dec 14\n+\t\t\t-3:00\tUruguay\t%z\t1960\n+\t\t\t-3:00\tUruguay\t%z\t1968\n+\t\t\t-3:00\tUruguay\t%z\t1970\n+\t\t\t-3:00\tUruguay\t%z\t1974\n+\t\t\t-3:00\tUruguay\t%z\t1974 Mar 10\n+\t\t\t-3:00\tUruguay\t%z\t1974 Dec 22\n+\t\t\t-3:00\tUruguay\t%z\n@@ -2039,4 +2039,4 @@\n-\t\t\t-4:30\t-\t-0430\t1965 Jan  1  0:00\n-\t\t\t-4:00\t-\t-04\t2007 Dec  9  3:00\n-\t\t\t-4:30\t-\t-0430\t2016 May  1  2:30\n-\t\t\t-4:00\t-\t-04\n+\t\t\t-4:30\t-\t%z\t1965 Jan  1  0:00\n+\t\t\t-4:00\t-\t%z\t2007 Dec  9  3:00\n+\t\t\t-4:30\t-\t%z\t2016 May  1  2:30\n+\t\t\t-4:00\t-\t%z\n","filename":"src\/java.base\/share\/data\/tzdata\/southamerica","additions":243,"deletions":243,"binary":false,"changes":486,"status":"modified"},{"patch":"@@ -290,2 +290,1 @@\n-MN\t+4801+09139\tAsia\/Hovd\tBayan-Olgiy, Govi-Altai, Hovd, Uvs, Zavkhan\n-MN\t+4804+11430\tAsia\/Choibalsan\tDornod, Sukhbaatar\n+MN\t+4801+09139\tAsia\/Hovd\tBayan-Olgii, Hovd, Uvs\n","filename":"src\/java.base\/share\/data\/tzdata\/zone.tab","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,1 +117,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n@@ -262,1 +262,1 @@\n-    if ((*env)->ExceptionOccurred(env))\n+    if ((*env)->ExceptionCheck(env))\n","filename":"src\/java.base\/share\/native\/libjava\/ClassLoader.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,6 @@\n+\n+JNIEXPORT void JNICALL\n+Java_java_lang_ref_PhantomReference_clear0(JNIEnv *env, jobject ref)\n+{\n+    JVM_ReferenceClear(env, ref);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/PhantomReference.c","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-        if ((*env)->ExceptionOccurred(env))                \\\n+        if ((*env)->ExceptionCheck(env))                \\\n@@ -89,1 +89,1 @@\n-        if ((*env)->ExceptionOccurred(env))                \\\n+        if ((*env)->ExceptionCheck(env))                \\\n","filename":"src\/java.base\/share\/native\/libjava\/System.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -178,1 +178,1 @@\n-    if (!(*env)->ExceptionOccurred(env)) {\n+    if (!(*env)->ExceptionCheck(env)) {\n","filename":"src\/java.base\/share\/native\/libjava\/io_util.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,1 +120,1 @@\n-    if (!(*env)->ExceptionOccurred(env)) {\n+    if (!(*env)->ExceptionCheck(env)) {\n@@ -169,1 +169,1 @@\n-    if (!(*env)->ExceptionOccurred(env)) {\n+    if (!(*env)->ExceptionCheck(env)) {\n","filename":"src\/java.base\/share\/native\/libjava\/jni_util.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef _UB_H_\n+#define _UB_H_\n+\n+\/* ATTRIBUTE_NO_UBSAN - Function attribute which informs the compiler to disable UBSan checks in the\n+ * following function or method.\n+ *\/\n+#ifdef UNDEFINED_BEHAVIOR_SANITIZER\n+#if defined(__clang__) || defined(__GNUC__)\n+#define ATTRIBUTE_NO_UBSAN __attribute__((no_sanitize(\"undefined\")))\n+#endif\n+#endif\n+\n+#ifndef ATTRIBUTE_NO_UBSAN\n+#define ATTRIBUTE_NO_UBSAN\n+#endif\n+\n+#endif\n","filename":"src\/java.base\/share\/native\/libjava\/ub.h","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -354,1 +354,1 @@\n-        if ((*env)->ExceptionOccurred(env)) { \\\n+        if ((*env)->ExceptionCheck(env)) { \\\n@@ -366,1 +366,1 @@\n-        if ((*env)->ExceptionOccurred(env)) { \\\n+        if ((*env)->ExceptionCheck(env)) { \\\n@@ -1525,1 +1525,1 @@\n-        if (!(*env)->ExceptionOccurred(env)) {\n+        if (!(*env)->ExceptionCheck(env)) {\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -249,1 +249,1 @@\n-        if ((*env)->ExceptionOccurred(env)) { \\\n+        if ((*env)->ExceptionCheck(env)) { \\\n@@ -256,1 +256,1 @@\n-        if ((*env)->ExceptionOccurred(env)) { \\\n+        if ((*env)->ExceptionCheck(env)) { \\\n","filename":"src\/java.base\/share\/native\/libjli\/java.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,239 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.net.www.protocol.jar;\n-\n-import java.io.IOException;\n-import java.io.FileNotFoundException;\n-import java.net.URL;\n-import java.net.URLConnection;\n-import java.util.HashMap;\n-import java.util.jar.JarFile;\n-import java.security.Permission;\n-import sun.net.util.URLUtil;\n-\n-\/* A factory for cached JAR file. This class is used to both retrieve\n- * and cache Jar files.\n- *\n- * @author Benjamin Renaud\n- * @since 1.2\n- *\/\n-class JarFileFactory implements URLJarFile.URLJarFileCloseController {\n-\n-    \/* the url to file cache *\/\n-    private static final HashMap<String, JarFile> fileCache = new HashMap<>();\n-\n-    \/* the file to url cache *\/\n-    private static final HashMap<JarFile, URL> urlCache = new HashMap<>();\n-\n-    private static final JarFileFactory instance = new JarFileFactory();\n-\n-    private JarFileFactory() { }\n-\n-    public static JarFileFactory getInstance() {\n-        return instance;\n-    }\n-\n-    URLConnection getConnection(JarFile jarFile) throws IOException {\n-        URL u;\n-        synchronized (instance) {\n-            u = urlCache.get(jarFile);\n-        }\n-        if (u != null)\n-            return u.openConnection();\n-\n-        return null;\n-    }\n-\n-    public JarFile get(URL url) throws IOException {\n-        return get(url, true);\n-    }\n-\n-    \/**\n-     * Get or create a {@code JarFile} for the given {@code url}.\n-     * If {@code useCaches} is true, this method attempts to find\n-     * a jar file in the cache, and if so, returns it.\n-     * If no jar file is found in the cache, or {@code useCaches}\n-     * is false, the method creates a new jar file.\n-     * If the URL points to a local file, the returned jar file\n-     * will not be put in the cache yet.\n-     * The caller should then call {@link #cacheIfAbsent(URL, JarFile)}\n-     * with the returned jar file, if updating the cache is desired.\n-     * @param url the jar file url\n-     * @param useCaches whether the cache should be used\n-     * @return a new or cached jar file.\n-     * @throws IOException if the jar file couldn't be created\n-     *\/\n-    JarFile getOrCreate(URL url, boolean useCaches) throws IOException {\n-        if (useCaches == false) {\n-            return get(url, false);\n-        }\n-\n-        if (!URLJarFile.isFileURL(url)) {\n-            \/\/ A temporary file will be created, we can prepopulate\n-            \/\/ the cache in this case.\n-            return get(url, useCaches);\n-        }\n-\n-        \/\/ We have a local file. Do not prepopulate the cache.\n-        JarFile result;\n-        synchronized (instance) {\n-            result = getCachedJarFile(url);\n-        }\n-        if (result == null) {\n-            result = URLJarFile.getJarFile(url, this);\n-        }\n-        if (result == null)\n-            throw new FileNotFoundException(url.toString());\n-        return result;\n-    }\n-\n-    \/**\n-     * Close the given jar file if it isn't present in the cache.\n-     * Otherwise, does nothing.\n-     * @param url the jar file URL\n-     * @param jarFile the jar file to close\n-     * @return true if the jar file has been closed, false otherwise.\n-     * @throws IOException if an error occurs while closing the jar file.\n-     *\/\n-    boolean closeIfNotCached(URL url, JarFile jarFile) throws IOException {\n-        JarFile result;\n-        synchronized (instance) {\n-            result = getCachedJarFile(url);\n-        }\n-        if (result != jarFile) jarFile.close();\n-        return result != jarFile;\n-    }\n-\n-    boolean cacheIfAbsent(URL url, JarFile jarFile) {\n-        JarFile cached;\n-        synchronized (instance) {\n-            String key = urlKey(url);\n-            cached = fileCache.get(key);\n-            if (cached == null) {\n-                fileCache.put(key, jarFile);\n-                urlCache.put(jarFile, url);\n-            }\n-        }\n-        return cached == null || cached == jarFile;\n-    }\n-\n-    JarFile get(URL url, boolean useCaches) throws IOException {\n-\n-        JarFile result;\n-        JarFile local_result;\n-\n-        if (useCaches) {\n-            synchronized (instance) {\n-                result = getCachedJarFile(url);\n-            }\n-            if (result == null) {\n-                local_result = URLJarFile.getJarFile(url, this);\n-                synchronized (instance) {\n-                    result = getCachedJarFile(url);\n-                    if (result == null) {\n-                        fileCache.put(urlKey(url), local_result);\n-                        urlCache.put(local_result, url);\n-                        result = local_result;\n-                    } else {\n-                        if (local_result != null) {\n-                            local_result.close();\n-                        }\n-                    }\n-                }\n-            }\n-        } else {\n-            result = URLJarFile.getJarFile(url, this);\n-        }\n-        if (result == null)\n-            throw new FileNotFoundException(url.toString());\n-\n-        return result;\n-    }\n-\n-    \/**\n-     * Callback method of the URLJarFileCloseController to\n-     * indicate that the JarFile is closed. This way we can\n-     * remove the JarFile from the cache\n-     *\/\n-    public void close(JarFile jarFile) {\n-        synchronized (instance) {\n-            URL urlRemoved = urlCache.remove(jarFile);\n-            if (urlRemoved != null)\n-                fileCache.remove(urlKey(urlRemoved));\n-        }\n-    }\n-\n-    private JarFile getCachedJarFile(URL url) {\n-        assert Thread.holdsLock(instance);\n-        JarFile result = fileCache.get(urlKey(url));\n-\n-        \/* if the JAR file is cached, the permission will always be there *\/\n-        if (result != null) {\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                Permission perm = getPermission(result);\n-                if (perm != null) {\n-                    try {\n-                        sm.checkPermission(perm);\n-                    } catch (SecurityException se) {\n-                        \/\/ fallback to checkRead\/checkConnect for pre 1.2\n-                        \/\/ security managers\n-                        if ((perm instanceof java.io.FilePermission) &&\n-                            perm.getActions().contains(\"read\")) {\n-                            sm.checkRead(perm.getName());\n-                        } else if ((perm instanceof\n-                            java.net.SocketPermission) &&\n-                            perm.getActions().contains(\"connect\")) {\n-                            sm.checkConnect(url.getHost(), url.getPort());\n-                        } else {\n-                            throw se;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        return result;\n-    }\n-\n-    private String urlKey(URL url) {\n-        String urlstr =  URLUtil.urlNoFragString(url);\n-        if (\"runtime\".equals(url.getRef())) urlstr += \"#runtime\";\n-        return urlstr;\n-    }\n-\n-    private Permission getPermission(JarFile jarFile) {\n-        try {\n-            URLConnection uc = getConnection(jarFile);\n-            if (uc != null)\n-                return uc.getPermission();\n-        } catch (IOException ioe) {\n-            \/\/ gulp\n-        }\n-\n-        return null;\n-    }\n-}\n","filename":"src\/java.base\/unix\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","additions":0,"deletions":239,"binary":false,"changes":239,"status":"deleted"},{"patch":"@@ -138,1 +138,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n@@ -153,1 +153,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n","filename":"src\/java.base\/unix\/native\/libjava\/io_util_md.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -377,1 +377,1 @@\n-        if (sock < 0 && (*env)->ExceptionOccurred(env)) {\n+        if (sock < 0 && (*env)->ExceptionCheck(env)) {\n@@ -386,1 +386,1 @@\n-            if ((*env)->ExceptionOccurred(env)) {\n+            if ((*env)->ExceptionCheck(env)) {\n@@ -404,1 +404,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n@@ -859,1 +859,1 @@\n-    if (sock < 0 && (*env)->ExceptionOccurred(env)) {\n+    if (sock < 0 && (*env)->ExceptionCheck(env)) {\n@@ -868,1 +868,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n@@ -887,1 +887,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n@@ -1240,1 +1240,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n@@ -1284,1 +1284,1 @@\n-            if ((*env)->ExceptionOccurred(env)) {\n+            if ((*env)->ExceptionCheck(env)) {\n@@ -1481,1 +1481,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n@@ -1555,1 +1555,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n@@ -1720,1 +1720,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n@@ -1760,1 +1760,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n","filename":"src\/java.base\/unix\/native\/libnet\/NetworkInterface.c","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-        if (res < 0 && !(*env)->ExceptionOccurred(env))\n+        if (res < 0 && !(*env)->ExceptionCheck(env))\n","filename":"src\/java.base\/unix\/native\/libnet\/SdpSupport.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-            if ((*env)->ExceptionOccurred(env)) {\n+            if ((*env)->ExceptionCheck(env)) {\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/UnixDomainSockets.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2666,1 +2666,1 @@\n-        Shape result = textLine.getOutline(tx);\n+        Shape result = textLine.getOutline();\n@@ -2671,0 +2671,9 @@\n+        if (tx != null) {\n+            if (result instanceof GeneralPath gp) {\n+                \/\/ transform in place\n+                gp.transform(tx);\n+            } else {\n+                \/\/ create a transformed copy\n+                result = tx.createTransformedShape(result);\n+            }\n+        }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/font\/TextLayout.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -867,1 +867,1 @@\n-    public Shape getOutline(AffineTransform tx) {\n+    public Shape getOutline() {\n@@ -873,1 +873,0 @@\n-\n@@ -877,3 +876,0 @@\n-        if (tx != null) {\n-            dstShape.transform(tx);\n-        }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/font\/TextLine.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+#include \"ub.h\"\n+\n@@ -169,0 +171,1 @@\n+ATTRIBUTE_NO_UBSAN\n","filename":"src\/java.desktop\/share\/native\/libawt\/java2d\/loops\/IntRgb.c","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -774,0 +774,1 @@\n+                case XWM.KDE2_WM:\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XWindowPeer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -72,0 +73,2 @@\n+    static final int MAX_NON_FINAL_RESPONSES =\n+            Utils.getIntegerNetProperty(\"jdk.httpclient.maxNonFinalResponses\", 8);\n@@ -96,0 +99,2 @@\n+    final AtomicInteger nonFinalResponses = new AtomicInteger();\n+\n@@ -362,1 +367,1 @@\n-        request.setH2Upgrade(client.client2());\n+        request.setH2Upgrade(this);\n@@ -485,0 +490,1 @@\n+                        nonFinalResponses.incrementAndGet();\n@@ -486,2 +492,1 @@\n-                        if (debug.on())\n-                            debug.log(\"Received 100-Continue for %s\", r1);\n+                        if (debug.on()) debug.log(\"Received 100-Continue for %s\", r1);\n@@ -495,3 +500,3 @@\n-                        Log.logTrace(\"Expectation failed: Received {0}\", rcode);\n-                        if (debug.on())\n-                            debug.log(\"Expect-Continue failed (%d) for: %s\", rcode, r1);\n+                        Log.logTrace(\"Expectation failed: Received {0}\",\n+                                rcode);\n+                        if (debug.on()) debug.log(\"Expect-Continue failed (%d) for: %s\", rcode, r1);\n@@ -562,6 +567,14 @@\n-            \/\/ ignore this Response and wait again for the subsequent response headers\n-            final CompletableFuture<Response> cf = exchImpl.getResponseAsync(parentExecutor);\n-            \/\/ we recompose the CF again into the ignore1xxResponse check\/function because\n-            \/\/ the 1xx response is allowed to be sent multiple times for a request, before\n-            \/\/ a final response arrives\n-            return cf.thenCompose(this::ignore1xxResponse);\n+            int count = nonFinalResponses.incrementAndGet();\n+            if (MAX_NON_FINAL_RESPONSES > 0 && (count < 0 || count > MAX_NON_FINAL_RESPONSES)) {\n+                return MinimalFuture.failedFuture(\n+                        new ProtocolException(String.format(\n+                                \"Too many interim responses received: %s > %s\",\n+                                count, MAX_NON_FINAL_RESPONSES)));\n+            } else {\n+                \/\/ ignore this Response and wait again for the subsequent response headers\n+                final CompletableFuture<Response> cf = exchImpl.getResponseAsync(parentExecutor);\n+                \/\/ we recompose the CF again into the ignore1xxResponse check\/function because\n+                \/\/ the 1xx response is allowed to be sent multiple times for a request, before\n+                \/\/ a final response arrives\n+                return cf.thenCompose(this::ignore1xxResponse);\n+            }\n@@ -832,0 +845,8 @@\n+    boolean pushEnabled() {\n+        return pushGroup != null;\n+    }\n+\n+    String h2cSettingsStrings() {\n+        return client.client2().getSettingsString(pushEnabled());\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Exchange.java","additions":33,"deletions":12,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.IOException;\n@@ -56,0 +57,6 @@\n+    private long size;\n+\n+    private static final int K = 1024;\n+    private static  final int MAX_HTTP_HEADER_SIZE = Utils.getIntegerNetProperty(\n+            \"jdk.http.maxHeaderSize\",\n+                Integer.MIN_VALUE, Integer.MAX_VALUE, 384 * K, true);\n@@ -167,1 +174,3 @@\n-    private void readResumeStatusLine(ByteBuffer input) {\n+    private void readResumeStatusLine(ByteBuffer input) throws ProtocolException {\n+        final long max = MAX_HTTP_HEADER_SIZE - size - 32 - sb.length();\n+        int count = 0;\n@@ -172,0 +181,3 @@\n+            if (++count > max) {\n+                checkMaxHeaderSize(sb.length());\n+            }\n@@ -188,0 +200,1 @@\n+        size = size + 32 + statusLine.length();\n@@ -208,1 +221,17 @@\n-    private void maybeStartHeaders(ByteBuffer input) {\n+    private void checkMaxHeaderSize(int sz) throws ProtocolException {\n+        long s = size + sz + 32;\n+        if (MAX_HTTP_HEADER_SIZE > 0 && s > MAX_HTTP_HEADER_SIZE) {\n+            throw new ProtocolException(String.format(\"Header size too big: %s > %s\",\n+                    s, MAX_HTTP_HEADER_SIZE));\n+        }\n+    }\n+    static private long newSize(long size, int name, int value) throws ProtocolException {\n+        long newSize = size + name + value + 32;\n+        if (MAX_HTTP_HEADER_SIZE > 0 && newSize > MAX_HTTP_HEADER_SIZE) {\n+            throw new ProtocolException(String.format(\"Header size too big: %s > %s\",\n+                    newSize, MAX_HTTP_HEADER_SIZE));\n+        }\n+        return newSize;\n+    }\n+\n+    private void maybeStartHeaders(ByteBuffer input) throws ProtocolException {\n@@ -218,0 +247,1 @@\n+            checkMaxHeaderSize(sb.length());\n@@ -235,1 +265,1 @@\n-    private void readResumeHeader(ByteBuffer input) {\n+    private void readResumeHeader(ByteBuffer input) throws ProtocolException {\n@@ -238,0 +268,2 @@\n+        final long max = MAX_HTTP_HEADER_SIZE - size - 32 - sb.length();\n+        int count = 0;\n@@ -251,0 +283,3 @@\n+            if (++count > max) {\n+                checkMaxHeaderSize(sb.length());\n+            }\n@@ -271,1 +306,1 @@\n-\n+        size = newSize(size, name.length(), value.length());\n@@ -276,1 +311,1 @@\n-    private void resumeOrLF(ByteBuffer input) {\n+    private void resumeOrLF(ByteBuffer input) throws ProtocolException {\n@@ -286,0 +321,1 @@\n+            checkMaxHeaderSize(sb.length());\n@@ -290,0 +326,1 @@\n+            checkMaxHeaderSize(1);\n@@ -315,0 +352,1 @@\n+            checkMaxHeaderSize(sb.length());\n@@ -325,0 +363,1 @@\n+            checkMaxHeaderSize(sb.length());\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1HeaderParser.java","additions":44,"deletions":5,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import jdk.internal.net.http.common.Log;\n@@ -49,0 +48,1 @@\n+import static jdk.internal.net.http.frame.SettingsFrame.MAX_HEADER_LIST_SIZE;\n@@ -101,0 +101,1 @@\n+        boolean pushEnabled = exchange.pushEnabled();\n@@ -107,1 +108,2 @@\n-                    if (!connection.tryReserveForPoolCheckout() || !connection.reserveStream(true)) {\n+                    if (!connection.tryReserveForPoolCheckout()\n+                            || !connection.reserveStream(true, pushEnabled)) {\n@@ -110,1 +112,3 @@\n-                                    \" reserved for use: %s\", connection);\n+                                    \" reserved for use%s: %s\",\n+                                    pushEnabled ? \" with server push enabled\" : \"\",\n+                                    connection);\n@@ -140,1 +144,1 @@\n-                                conn.reserveStream(true);\n+                                conn.reserveStream(true, exchange.pushEnabled());\n@@ -186,4 +190,15 @@\n-                c.setFinalStream();\n-                if (debug.on())\n-                    debug.log(\"existing entry in connection pool for %s\", key);\n-                return false;\n+                if (c.serverPushEnabled() && !c1.serverPushEnabled()) {\n+                    c1.setFinalStream();\n+                    connections.remove(key, c1);\n+                    connections.put(key, c);\n+                    if (debug.on()) {\n+                        debug.log(\"Replacing %s with %s in connection pool\", c1, c);\n+                    }\n+                    if (c1.shouldClose()) c1.close();\n+                    return  true;\n+                } else {\n+                    c.setFinalStream();\n+                    if (debug.on())\n+                        debug.log(\"existing entry in connection pool for %s\", key);\n+                    return false;\n+                }\n@@ -253,2 +268,2 @@\n-    String getSettingsString() {\n-        SettingsFrame sf = getClientSettings();\n+    String getSettingsString(boolean defaultServerPush) {\n+        SettingsFrame sf = getClientSettings(defaultServerPush);\n@@ -264,8 +279,1 @@\n-        int value =  Utils.getIntegerNetProperty(property, defaultValue);\n-        \/\/ use default value if misconfigured\n-        if (value < min || value > max) {\n-            Log.logError(\"Property value for {0}={1} not in [{2}..{3}]: \" +\n-                    \"using default={4}\", property, value, min, max, defaultValue);\n-            value = defaultValue;\n-        }\n-        return value;\n+        return Utils.getIntegerNetProperty(property, min, max, defaultValue, true);\n@@ -291,1 +299,12 @@\n-    SettingsFrame getClientSettings() {\n+    \/**\n+     * This method is used to test whether pushes are globally\n+     * disabled on all connections.\n+     * @return true if pushes are globally disabled on all connections\n+     *\/\n+    boolean serverPushDisabled() {\n+        return getParameter(\n+                \"jdk.httpclient.enablepush\",\n+                0, 1, 1) == 0;\n+    }\n+\n+    SettingsFrame getClientSettings(boolean defaultServerPush) {\n@@ -300,1 +319,1 @@\n-                0, 1, 1));\n+                0, 1, defaultServerPush ? 1 : 0));\n@@ -302,3 +321,4 @@\n-        \/\/ no lower than 100. We use 100. 0 means no stream would be\n-        \/\/ accepted. That would render the client to be non functional,\n-        \/\/ so we won't let 0 be configured for our Http2ClientImpl.\n+        \/\/ no lower than 100. We use 100, unless push promises are\n+        \/\/ disabled.\n+        int initialServerStreams = frame.getParameter(ENABLE_PUSH) == 0\n+                ? 0 : 100;\n@@ -307,1 +327,1 @@\n-                1, Integer.MAX_VALUE, 100));\n+                0, Integer.MAX_VALUE, initialServerStreams));\n@@ -320,0 +340,8 @@\n+        \/\/ Maximum field section size we're prepared to accept\n+        \/\/ This is the uncompressed name + value size + 32 per field line\n+        int maxHeaderSize = getParameter(\n+                \"jdk.http.maxHeaderSize\",\n+                Integer.MIN_VALUE, Integer.MAX_VALUE, 384 * K);\n+        \/\/ If the property is <= 0 the value is unlimited\n+        if (maxHeaderSize <= 0) maxHeaderSize = -1;\n+        frame.setParameter(MAX_HEADER_LIST_SIZE, maxHeaderSize);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2ClientImpl.java","additions":53,"deletions":25,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.net.ProtocolException;\n@@ -52,0 +53,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -91,0 +93,1 @@\n+import static jdk.internal.net.http.frame.SettingsFrame.ENABLE_PUSH;\n@@ -95,0 +98,1 @@\n+import static jdk.internal.net.http.frame.SettingsFrame.MAX_HEADER_LIST_SIZE;\n@@ -330,0 +334,39 @@\n+    private final class PushPromiseDecoder extends HeaderDecoder implements DecodingCallback {\n+\n+        final int parentStreamId;\n+        final int pushPromiseStreamId;\n+        final Stream<?> parent;\n+        final AtomicReference<Throwable> errorRef = new AtomicReference<>();\n+\n+        PushPromiseDecoder(int parentStreamId, int pushPromiseStreamId, Stream<?> parent) {\n+            this.parentStreamId = parentStreamId;\n+            this.pushPromiseStreamId = pushPromiseStreamId;\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        protected void addHeader(String name, String value) {\n+            if (errorRef.get() == null) {\n+                super.addHeader(name, value);\n+            }\n+        }\n+\n+        @Override\n+        public void onMaxHeaderListSizeReached(long size, int maxHeaderListSize) throws ProtocolException {\n+            try {\n+                DecodingCallback.super.onMaxHeaderListSizeReached(size, maxHeaderListSize);\n+            } catch (ProtocolException pe) {\n+                if (parent != null) {\n+                    if (errorRef.compareAndSet(null, pe)) {\n+                        \/\/ cancel the parent stream\n+                        resetStream(pushPromiseStreamId, ResetFrame.REFUSED_STREAM);\n+                        parent.onProtocolError(pe);\n+                    }\n+                } else {\n+                    \/\/ interrupt decoding and closes the connection\n+                    throw pe;\n+                }\n+            }\n+        }\n+    }\n+\n@@ -358,1 +401,1 @@\n-    private record PushContinuationState(HeaderDecoder pushContDecoder, PushPromiseFrame pushContFrame) {}\n+    private record PushContinuationState(PushPromiseDecoder pushContDecoder, PushPromiseFrame pushContFrame) {}\n@@ -373,1 +416,1 @@\n-    private volatile Throwable cause;\n+    private final AtomicReference<Throwable> cause = new AtomicReference<>();\n@@ -377,0 +420,3 @@\n+    private ValidatingHeadersConsumer orphanedConsumer;\n+    private final AtomicInteger orphanedHeaders = new AtomicInteger();\n+\n@@ -378,0 +424,2 @@\n+    static final int MAX_LITERAL_WITH_INDEXING =\n+            Utils.getIntegerNetProperty(\"jdk.httpclient.maxLiteralWithIndexing\",512);\n@@ -379,0 +427,7 @@\n+    \/\/ The maximum number of HEADER frames, CONTINUATION frames, or PUSH_PROMISE frames\n+    \/\/ referring to an already closed or non-existent stream that a client will accept to\n+    \/\/ process. Receiving frames referring to non-existent or closed streams doesn't necessarily\n+    \/\/ constitute an HTTP\/2 protocol error, but receiving too many may indicate a problem\n+    \/\/ with the connection. If this limit is reached, a {@link java.net.ProtocolException\n+    \/\/ ProtocolException} will be raised and the connection will be closed.\n+    static final int MAX_ORPHANED_HEADERS = 1024;\n@@ -386,1 +441,2 @@\n-                            String key) {\n+                            String key,\n+                            boolean defaultServerPush) {\n@@ -392,1 +448,1 @@\n-        this.clientSettings = this.client2.getClientSettings();\n+        this.clientSettings = this.client2.getClientSettings(defaultServerPush);\n@@ -398,1 +454,2 @@\n-        this.hpackIn = new Decoder(clientSettings.getParameter(HEADER_TABLE_SIZE));\n+        this.hpackIn = new Decoder(clientSettings.getParameter(HEADER_TABLE_SIZE),\n+                clientSettings.getParameter(MAX_HEADER_LIST_SIZE), MAX_LITERAL_WITH_INDEXING);\n@@ -417,1 +474,2 @@\n-                    Supplier<ByteBuffer> initial)\n+                    Supplier<ByteBuffer> initial,\n+                    boolean defaultServerPush)\n@@ -423,2 +481,3 @@\n-                keyFor(connection));\n-        reserveStream(true);\n+                keyFor(connection),\n+                defaultServerPush);\n+        reserveStream(true, clientSettings.getFlag(ENABLE_PUSH));\n@@ -457,1 +516,2 @@\n-        return MinimalFuture.supply(() -> new Http2Connection(connection, client2, exchange, initial));\n+        return MinimalFuture.supply(() -> new Http2Connection(connection, client2, exchange, initial,\n+                exchange.pushEnabled()));\n@@ -481,1 +541,2 @@\n-                          Http2Connection hc = new Http2Connection(request, h2client, connection);\n+                          Http2Connection hc = new Http2Connection(request, h2client,\n+                                  connection, exchange.pushEnabled());\n@@ -496,1 +557,2 @@\n-                            HttpConnection connection)\n+                            HttpConnection connection,\n+                            boolean defaultServerPush)\n@@ -502,1 +564,2 @@\n-             keyFor(request));\n+             keyFor(request),\n+             defaultServerPush);\n@@ -525,1 +588,1 @@\n-    boolean reserveStream(boolean clientInitiated) throws IOException {\n+    boolean reserveStream(boolean clientInitiated, boolean pushEnabled) throws IOException {\n@@ -528,1 +591,1 @@\n-            return reserveStream0(clientInitiated);\n+            return reserveStream0(clientInitiated, pushEnabled);\n@@ -534,1 +597,1 @@\n-    private boolean reserveStream0(boolean clientInitiated) throws IOException {\n+    private boolean reserveStream0(boolean clientInitiated, boolean pushEnabled) throws IOException {\n@@ -538,1 +601,7 @@\n-        if (clientInitiated && (lastReservedClientStreamid + 2) >= MAX_CLIENT_STREAM_ID) {\n+        \/\/ If requesting to reserve a stream for an exchange for which push is enabled,\n+        \/\/ we will reserve the stream in this connection only if this connection is also\n+        \/\/ push enabled, unless pushes are globally disabled.\n+        boolean pushCompatible = !clientInitiated || !pushEnabled\n+                || this.serverPushEnabled()\n+                || client2.serverPushDisabled();\n+        if (clientInitiated && (lastReservedClientStreamid >= MAX_CLIENT_STREAM_ID -2  || !pushCompatible)) {\n@@ -542,1 +611,1 @@\n-        } else if (!clientInitiated && (lastReservedServerStreamid + 2) >= MAX_SERVER_STREAM_ID) {\n+        } else if (!clientInitiated && (lastReservedServerStreamid >= MAX_SERVER_STREAM_ID - 2)) {\n@@ -567,0 +636,9 @@\n+    boolean shouldClose() {\n+        stateLock.lock();\n+        try {\n+            return finalStream() && streams.isEmpty();\n+        } finally {\n+            stateLock.unlock();\n+        }\n+    }\n+\n@@ -694,0 +772,4 @@\n+    public boolean serverPushEnabled() {\n+        return clientSettings.getParameter(SettingsFrame.ENABLE_PUSH) == 1;\n+    }\n+\n@@ -798,1 +880,1 @@\n-        return cause;\n+        return cause.get();\n@@ -807,2 +889,1 @@\n-            Throwable initialCause = this.cause;\n-            if (initialCause == null && t != null) this.cause = t;\n+            cause.compareAndSet(null, t);\n@@ -812,0 +893,1 @@\n+\n@@ -822,0 +904,1 @@\n+        subscriber.stop(cause.get());\n@@ -875,0 +958,6 @@\n+            if (frame instanceof PushPromiseFrame && !serverPushEnabled()) {\n+                String protocolError = \"received a PUSH_PROMISE when SETTINGS_ENABLE_PUSH is 0\";\n+                protocolError(ResetFrame.PROTOCOL_ERROR, protocolError);\n+                return;\n+            }\n+\n@@ -876,0 +965,8 @@\n+            var nextstreamid = this.nextstreamid;\n+            if (stream == null && (streamid & 0x01) == 0x01 && streamid >= nextstreamid) {\n+                String protocolError = String.format(\n+                        \"received a frame for a non existing streamid(%s) >= nextstreamid(%s)\",\n+                        streamid, nextstreamid);\n+                protocolError(ResetFrame.PROTOCOL_ERROR, protocolError);\n+                return;\n+            }\n@@ -879,1 +976,6 @@\n-                if (frame instanceof HeaderFrame) {\n+                if (frame instanceof HeaderFrame hf) {\n+                    String protocolError = checkMaxOrphanedHeadersExceeded(hf);\n+                    if (protocolError != null) {\n+                        protocolError(ResetFrame.PROTOCOL_ERROR, protocolError);\n+                        return;\n+                    }\n@@ -882,1 +984,4 @@\n-                    DecodingCallback decoder = new ValidatingHeadersConsumer()::onDecoded;\n+                    if (orphanedConsumer == null || frame.getClass() != ContinuationFrame.class) {\n+                        orphanedConsumer = new ValidatingHeadersConsumer();\n+                    }\n+                    DecodingCallback decoder = orphanedConsumer::onDecoded;\n@@ -884,2 +989,2 @@\n-                        decodeHeaders((HeaderFrame) frame, decoder);\n-                    } catch (UncheckedIOException e) {\n+                        decodeHeaders(hf, decoder);\n+                    } catch (IOException | UncheckedIOException e) {\n@@ -913,1 +1018,2 @@\n-            if (pushContinuationState != null) {\n+            PushContinuationState pcs = pushContinuationState;\n+            if (pcs != null) {\n@@ -915,0 +1021,7 @@\n+                    if (stream == null) {\n+                        String protocolError = checkMaxOrphanedHeadersExceeded(cf);\n+                        if (protocolError != null) {\n+                            protocolError(ResetFrame.PROTOCOL_ERROR, protocolError);\n+                            return;\n+                        }\n+                    }\n@@ -916,6 +1029,9 @@\n-                        if (streamid == pushContinuationState.pushContFrame.streamid())\n-                            handlePushContinuation(stream, cf);\n-                        else\n-                            protocolError(ErrorFrame.PROTOCOL_ERROR, \"Received a Continuation Frame with an \" +\n-                                    \"unexpected stream id\");\n-                    } catch (UncheckedIOException e) {\n+                        if (streamid == pcs.pushContFrame.streamid())\n+                            handlePushContinuation(pcs, stream, cf);\n+                        else {\n+                            String protocolError = \"Received a CONTINUATION with \" +\n+                                    \"unexpected stream id: \" + streamid + \" != \"\n+                                    + pcs.pushContFrame.streamid();\n+                            protocolError(ErrorFrame.PROTOCOL_ERROR, protocolError);\n+                        }\n+                    } catch (IOException | UncheckedIOException e) {\n@@ -928,1 +1044,2 @@\n-                    protocolError(ErrorFrame.PROTOCOL_ERROR, \"Expected a Continuation frame but received \" + frame);\n+                    String protocolError = \"Expected a CONTINUATION frame but received \" + frame;\n+                    protocolError(ErrorFrame.PROTOCOL_ERROR, protocolError);\n@@ -935,1 +1052,1 @@\n-                    } catch (UncheckedIOException e) {\n+                    } catch (IOException | UncheckedIOException e) {\n@@ -943,1 +1060,1 @@\n-                    } catch (UncheckedIOException e) {\n+                    } catch (IOException | UncheckedIOException e) {\n@@ -956,0 +1073,10 @@\n+    private String checkMaxOrphanedHeadersExceeded(HeaderFrame hf) {\n+        if (MAX_ORPHANED_HEADERS > 0 ) {\n+            int orphaned = orphanedHeaders.incrementAndGet();\n+            if (orphaned < 0 || orphaned > MAX_ORPHANED_HEADERS) {\n+               return \"Too many orphaned header frames received on connection\";\n+            }\n+        }\n+        return null;\n+    }\n+\n@@ -980,0 +1107,8 @@\n+        int promisedStreamid = pp.getPromisedStream();\n+        if ((promisedStreamid & 0x01) != 0x00) {\n+            throw new ProtocolException(\"Received PUSH_PROMISE for stream \" + promisedStreamid);\n+        }\n+        int streamId = pp.streamid();\n+        if ((streamId & 0x01) != 0x01) {\n+            throw new ProtocolException(\"Received PUSH_PROMISE on stream \" + streamId);\n+        }\n@@ -983,3 +1118,2 @@\n-        HeaderDecoder decoder = new HeaderDecoder();\n-        decodeHeaders(pp, decoder::onDecoded);\n-        int promisedStreamid = pp.getPromisedStream();\n+        PushPromiseDecoder decoder = new PushPromiseDecoder(streamId, promisedStreamid, parent);\n+        decodeHeaders(pp, decoder);\n@@ -987,1 +1121,3 @@\n-            completePushPromise(promisedStreamid, parent, decoder.headers());\n+            if (decoder.errorRef.get() == null) {\n+                completePushPromise(promisedStreamid, parent, decoder.headers());\n+            }\n@@ -993,1 +1129,1 @@\n-    private <T> void handlePushContinuation(Stream<T> parent, ContinuationFrame cf)\n+    private <T> void handlePushContinuation(PushContinuationState pcs, Stream<T> parent, ContinuationFrame cf)\n@@ -995,2 +1131,4 @@\n-        var pcs = pushContinuationState;\n-        decodeHeaders(cf, pcs.pushContDecoder::onDecoded);\n+        assert pcs.pushContFrame.streamid() == cf.streamid() : String.format(\n+                    \"Received CONTINUATION on a different stream %s != %s\",\n+                    cf.streamid(), pcs.pushContFrame.streamid());\n+        decodeHeaders(cf, pcs.pushContDecoder);\n@@ -999,2 +1137,4 @@\n-            completePushPromise(pcs.pushContFrame.getPromisedStream(), parent,\n-                    pcs.pushContDecoder.headers());\n+            if (pcs.pushContDecoder.errorRef.get() == null) {\n+                completePushPromise(pcs.pushContFrame.getPromisedStream(), parent,\n+                        pcs.pushContDecoder.headers());\n+            }\n@@ -1007,0 +1147,4 @@\n+        if (parent == null) {\n+            resetStream(promisedStreamid, ResetFrame.REFUSED_STREAM);\n+            return;\n+        }\n@@ -1008,0 +1152,9 @@\n+        if (promisedStreamid < nextPushStream) {\n+            \/\/ From RFC 9113 section 5.1.1:\n+            \/\/ The identifier of a newly established stream MUST be numerically\n+            \/\/ greater than all streams that the initiating endpoint has\n+            \/\/ opened or reserved.\n+            protocolError(ResetFrame.PROTOCOL_ERROR, String.format(\n+                    \"Unexpected stream identifier: %s < %s\", promisedStreamid, nextPushStream));\n+            return;\n+        }\n@@ -1009,0 +1162,1 @@\n+            \/\/ we don't support skipping stream ids;\n@@ -1011,1 +1165,1 @@\n-        } else if (!reserveStream(false)) {\n+        } else if (!reserveStream(false, true)) {\n@@ -1180,0 +1334,3 @@\n+        String protocolError = \"protocol error\" + (msg == null?\"\":(\": \" + msg));\n+        ProtocolException protocolException =\n+                new ProtocolException(protocolError);\n@@ -1181,0 +1338,3 @@\n+            framesDecoder.close(protocolError);\n+            subscriber.stop(protocolException);\n+            if (debug.on()) debug.log(\"Sending GOAWAY due to \" + protocolException);\n@@ -1184,1 +1344,1 @@\n-        shutdown(new IOException(\"protocol error\" + (msg == null?\"\":(\": \" + msg))));\n+        shutdown(protocolException);\n@@ -1359,1 +1519,1 @@\n-        return new Stream.PushedStream<>(pg, this, pushEx);\n+        return new Stream.PushedStream<>(parent, pg, this, pushEx);\n@@ -1469,1 +1629,1 @@\n-        for(HttpHeaders header : headers) {\n+        for (HttpHeaders header : headers) {\n@@ -1476,3 +1636,5 @@\n-                        buffer.flip();\n-                        buffers.add(buffer);\n-                        buffer =  getHeaderBuffer(bufferSize);\n+                        if (!buffer.hasRemaining()) {\n+                            buffer.flip();\n+                            buffers.add(buffer);\n+                            buffer = getHeaderBuffer(bufferSize);\n+                        }\n@@ -1517,1 +1679,1 @@\n-                cause = this.cause;\n+                cause = this.cause.get();\n@@ -1556,0 +1718,2 @@\n+                        \/\/ we are creating a new stream: reset orphaned header count\n+                        orphanedHeaders.set(0);\n@@ -1624,1 +1788,1 @@\n-        private volatile Throwable error;\n+        private final AtomicReference<Throwable> errorRef = new AtomicReference<>();\n@@ -1645,2 +1809,1 @@\n-                Throwable x = error;\n-                if (x == null) error = t;\n+                errorRef.compareAndSet(null, t);\n@@ -1648,1 +1811,1 @@\n-                Throwable x = error;\n+                Throwable x = errorRef.get();\n@@ -1683,0 +1846,1 @@\n+            if (completed) return;\n@@ -1691,0 +1855,1 @@\n+            if (completed) return;\n@@ -1692,1 +1857,1 @@\n-            error = throwable;\n+            errorRef.compareAndSet(null, throwable);\n@@ -1699,0 +1864,1 @@\n+            if (completed) return;\n@@ -1703,1 +1869,1 @@\n-            error = new EOFException(msg);\n+            errorRef.compareAndSet(null, new EOFException(msg));\n@@ -1715,0 +1881,12 @@\n+\n+        void stop(Throwable error) {\n+            if (errorRef.compareAndSet(null, error)) {\n+                completed = true;\n+                scheduler.stop();\n+                queue.clear();\n+                if (subscription != null) {\n+                    subscription.cancel();\n+                }\n+                queue.clear();\n+            }\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":235,"deletions":57,"binary":false,"changes":292,"status":"modified"},{"patch":"@@ -967,1 +967,3 @@\n-                throw new ProtocolException(msg);\n+                ProtocolException pe = new ProtocolException(msg);\n+                pe.initCause(throwable);\n+                throw pe;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -290,1 +290,1 @@\n-    void setH2Upgrade(Http2ClientImpl h2client) {\n+    void setH2Upgrade(Exchange<?> exchange) {\n@@ -293,1 +293,1 @@\n-        systemHeadersBuilder.setHeader(\"HTTP2-Settings\", h2client.getSettingsString());\n+        systemHeadersBuilder.setHeader(\"HTTP2-Settings\", exchange.h2cSettingsStrings());\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpRequestImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import java.util.Objects;\n@@ -140,0 +141,5 @@\n+            String initiatingScheme = initiatingURI.getScheme();\n+            String pushRequestScheme = pushRequestURI.getScheme();\n+\n+            if (!initiatingScheme.equalsIgnoreCase(pushRequestScheme)) return;\n+\n@@ -142,1 +148,1 @@\n-                if (\"https\".equalsIgnoreCase(initiatingURI.getScheme()))\n+                if (\"https\".equalsIgnoreCase(initiatingScheme))\n@@ -149,1 +155,1 @@\n-                if (\"https\".equalsIgnoreCase(pushRequestURI.getScheme()))\n+                if (\"https\".equalsIgnoreCase(pushRequestScheme))\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ResponseBodyHandlers.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.net.ProtocolException;\n@@ -46,0 +47,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -55,0 +57,1 @@\n+\n@@ -59,0 +62,2 @@\n+import static jdk.internal.net.http.Exchange.MAX_NON_FINAL_RESPONSES;\n+\n@@ -143,0 +148,3 @@\n+    private volatile boolean trailerReceived;\n+    private AtomicInteger nonFinalResponseCount = new AtomicInteger();\n+\n@@ -523,1 +531,13 @@\n-        return rspHeadersConsumer::onDecoded;\n+        return rspHeadersConsumer;\n+    }\n+\n+    String checkInterimResponseCountExceeded() {\n+        \/\/ this is also checked by Exchange - but tracking it here too provides\n+        \/\/ a more informative message.\n+        int count = nonFinalResponseCount.incrementAndGet();\n+        if (MAX_NON_FINAL_RESPONSES > 0 && (count < 0 || count > MAX_NON_FINAL_RESPONSES)) {\n+            return String.format(\n+                    \"Stream %s PROTOCOL_ERROR: too many interim responses received: %s > %s\",\n+                    streamid, count, MAX_NON_FINAL_RESPONSES);\n+        }\n+        return null;\n@@ -530,3 +550,13 @@\n-            responseCode = (int) responseHeaders\n-                    .firstValueAsLong(\":status\")\n-                    .orElseThrow(() -> new IOException(\"no statuscode in response\"));\n+            try {\n+                responseCode = (int) responseHeaders\n+                        .firstValueAsLong(\":status\")\n+                        .orElseThrow(() -> new ProtocolException(String.format(\n+                                \"Stream %s PROTOCOL_ERROR: no status code in response\",\n+                                streamid)));\n+            } catch (ProtocolException cause) {\n+                cancelImpl(cause, ResetFrame.PROTOCOL_ERROR);\n+                rspHeadersConsumer.reset();\n+                return;\n+            }\n+\n+            String protocolErrorMsg = null;\n@@ -540,3 +570,9 @@\n-                String msg = (\"Stream %s PROTOCOL_ERROR: \" +\n-                        \"HEADERS frame with status %s has END_STREAM flag set\")\n-                        .formatted(streamid, responseCode);\n+                protocolErrorMsg = String.format(\n+                        \"Stream %s PROTOCOL_ERROR: \" +\n+                        \"HEADERS frame with status %s has END_STREAM flag set\",\n+                        streamid, responseCode);\n+            } else {\n+                protocolErrorMsg = checkInterimResponseCountExceeded();\n+            }\n+\n+            if (protocolErrorMsg != null) {\n@@ -544,1 +580,1 @@\n-                    debug.log(msg);\n+                    debug.log(protocolErrorMsg);\n@@ -546,1 +582,3 @@\n-                cancelImpl(new IOException(msg), ResetFrame.PROTOCOL_ERROR);\n+                cancelImpl(new ProtocolException(protocolErrorMsg), ResetFrame.PROTOCOL_ERROR);\n+                rspHeadersConsumer.reset();\n+                return;\n@@ -553,4 +591,4 @@\n-        \/* TODO: review if needs to be removed\n-           the value is not used, but in case `content-length` doesn't parse as\n-           long, there will be NumberFormatException. If left as is, make sure\n-           code up the stack handles NFE correctly. *\/\n+            \/* TODO: review if needs to be removed\n+               the value is not used, but in case `content-length` doesn't parse as\n+               long, there will be NumberFormatException. If left as is, make sure\n+               code up the stack handles NFE correctly. *\/\n@@ -575,0 +613,9 @@\n+            if (trailerReceived) {\n+                String protocolErrorMsg = String.format(\n+                        \"Stream %s PROTOCOL_ERROR: trailers already received\", streamid);\n+                if (debug.on()) {\n+                    debug.log(protocolErrorMsg);\n+                }\n+                cancelImpl(new ProtocolException(protocolErrorMsg), ResetFrame.PROTOCOL_ERROR);\n+            }\n+            trailerReceived = true;\n@@ -1185,1 +1232,1 @@\n-     * one response, but intermediate responses like 100 are allowed\n+     * one response, but interim responses like 100 are allowed\n@@ -1404,1 +1451,1 @@\n-    private void cancelImpl(final Throwable e, final int resetFrameErrCode) {\n+    void cancelImpl(final Throwable e, final int resetFrameErrCode) {\n@@ -1514,0 +1561,1 @@\n+        final Stream<T> parent;\n@@ -1523,1 +1571,2 @@\n-        PushedStream(PushGroup<T> pushGroup,\n+        PushedStream(Stream<T> parent,\n+                     PushGroup<T> pushGroup,\n@@ -1528,0 +1577,1 @@\n+            this.parent = parent;\n@@ -1532,1 +1582,0 @@\n-\n@@ -1620,1 +1669,10 @@\n-                    completeResponseExceptionally(new IOException(\"No status code\"));\n+                    cancelImpl(new ProtocolException(\"No status code\"), ResetFrame.PROTOCOL_ERROR);\n+                    rspHeadersConsumer.reset();\n+                    return;\n+                } else if (responseCode >= 100 && responseCode < 200) {\n+                    String protocolErrorMsg = checkInterimResponseCountExceeded();\n+                    if (protocolErrorMsg != null) {\n+                        cancelImpl(new ProtocolException(protocolErrorMsg), ResetFrame.PROTOCOL_ERROR);\n+                        rspHeadersConsumer.reset();\n+                        return;\n+                    }\n@@ -1730,1 +1788,3 @@\n-    private class HeadersConsumer extends ValidatingHeadersConsumer {\n+    private class HeadersConsumer extends ValidatingHeadersConsumer implements DecodingCallback {\n+\n+        boolean maxHeaderListSizeReached;\n@@ -1743,0 +1803,3 @@\n+            if (maxHeaderListSizeReached) {\n+                return;\n+            }\n@@ -1765,0 +1828,17 @@\n+\n+        @Override\n+        public void onMaxHeaderListSizeReached(long size, int maxHeaderListSize) throws ProtocolException {\n+            if (maxHeaderListSizeReached) return;\n+            try {\n+                DecodingCallback.super.onMaxHeaderListSizeReached(size, maxHeaderListSize);\n+            } catch (ProtocolException cause) {\n+                maxHeaderListSizeReached = true;\n+                \/\/ If this is a push stream: cancel the parent.\n+                if (Stream.this instanceof Stream.PushedStream<?> ps) {\n+                    ps.parent.onProtocolError(cause);\n+                }\n+                \/\/ cancel the stream, continue processing\n+                onProtocolError(cause);\n+                reset();\n+            }\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":99,"deletions":19,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -42,1 +42,5 @@\n-        headersBuilder.addHeader(n, v);\n+        addHeader(n, v);\n+    }\n+\n+    protected void addHeader(String name, String value) {\n+        headersBuilder.addHeader(name, value);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/HeaderDecoder.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -619,0 +619,13 @@\n+    public static int getIntegerNetProperty(String property, int min, int max, int defaultValue, boolean log) {\n+        int value =  Utils.getIntegerNetProperty(property, defaultValue);\n+        \/\/ use default value if misconfigured\n+        if (value < min || value > max) {\n+            if (log && Log.errors()) {\n+                Log.logError(\"Property value for {0}={1} not in [{2}..{3}]: \" +\n+                        \"using default={4}\", property, value, min, max, defaultValue);\n+            }\n+            value = defaultValue;\n+        }\n+        return value;\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.net.ProtocolException;\n@@ -110,0 +111,2 @@\n+    private final int maxHeaderListSize;\n+    private final int maxIndexed;\n@@ -116,0 +119,2 @@\n+    private long size;\n+    private int indexed;\n@@ -132,0 +137,25 @@\n+        this(capacity, 0, 0);\n+    }\n+\n+    \/**\n+     * Constructs a {@code Decoder} with the specified initial capacity of the\n+     * header table, a max header list size, and a maximum number of literals\n+     * with indexing per header section.\n+     *\n+     * <p> The value of the capacity has to be agreed between decoder and encoder out-of-band,\n+     * e.g. by a protocol that uses HPACK\n+     * (see <a href=\"https:\/\/tools.ietf.org\/html\/rfc7541#section-4.2\">4.2. Maximum Table Size<\/a>).\n+     *\n+     * @param capacity\n+     *         a non-negative integer\n+     * @param maxHeaderListSize\n+     *         a maximum value for the header list size. This is the uncompressed\n+     *         names size + uncompressed values size + 32 bytes per field line\n+     * @param maxIndexed\n+     *         the maximum number of literal with indexing we're prepared to handle\n+     *         for a header field section\n+     *\n+     * @throws IllegalArgumentException\n+     *         if capacity is negative\n+     *\/\n+    public Decoder(int capacity, int maxHeaderListSize, int maxIndexed) {\n@@ -148,0 +178,2 @@\n+        this.maxHeaderListSize = maxHeaderListSize;\n+        this.maxIndexed = maxIndexed;\n@@ -245,1 +277,1 @@\n-                                            headerBlock, endOfHeaderBlock));\n+                    headerBlock, endOfHeaderBlock));\n@@ -252,1 +284,1 @@\n-                                            state));\n+                    state));\n@@ -255,0 +287,3 @@\n+        if (endOfHeaderBlock) {\n+            size = indexed = 0;\n+        }\n@@ -260,1 +295,1 @@\n-            case READY                  ->  resumeReady(input);\n+            case READY                  ->  resumeReady(input, action);\n@@ -271,1 +306,1 @@\n-    private void resumeReady(ByteBuffer input) {\n+    private void resumeReady(ByteBuffer input, DecodingCallback action) throws IOException {\n@@ -292,0 +327,3 @@\n+                if (maxIndexed > 0 && ++indexed > maxIndexed) {\n+                    action.onMaxLiteralWithIndexingReached(indexed, maxIndexed);\n+                }\n@@ -318,0 +356,6 @@\n+    private void checkMaxHeaderListSize(long sz, DecodingCallback consumer) throws ProtocolException {\n+        if (maxHeaderListSize > 0 && sz > maxHeaderListSize) {\n+            consumer.onMaxHeaderListSizeReached(sz, maxHeaderListSize);\n+        }\n+    }\n+\n@@ -335,0 +379,2 @@\n+            size = size + 32 + f.name.length() + f.value.length();\n+            checkMaxHeaderListSize(size, action);\n@@ -377,1 +423,1 @@\n-        if (!completeReading(input)) {\n+        if (!completeReading(input, action)) {\n@@ -388,0 +434,2 @@\n+                size = size + 32 + f.name.length() + value.length();\n+                checkMaxHeaderListSize(size, action);\n@@ -395,0 +443,2 @@\n+                size = size + 32 + name.length() + value.length();\n+                checkMaxHeaderListSize(size, action);\n@@ -428,1 +478,1 @@\n-        if (!completeReading(input)) {\n+        if (!completeReading(input, action)) {\n@@ -448,0 +498,2 @@\n+                size = size + 32 + n.length() + v.length();\n+                checkMaxHeaderListSize(size, action);\n@@ -456,0 +508,2 @@\n+                size = size + 32 + n.length() + v.length();\n+                checkMaxHeaderListSize(size, action);\n@@ -489,1 +543,1 @@\n-        if (!completeReading(input)) {\n+        if (!completeReading(input, action)) {\n@@ -500,0 +554,2 @@\n+                size = size + 32 + f.name.length() + value.length();\n+                checkMaxHeaderListSize(size, action);\n@@ -507,0 +563,2 @@\n+                size = size + 32 + name.length() + value.length();\n+                checkMaxHeaderListSize(size, action);\n@@ -544,1 +602,1 @@\n-    private boolean completeReading(ByteBuffer input) throws IOException {\n+    private boolean completeReading(ByteBuffer input, DecodingCallback action) throws IOException {\n@@ -554,0 +612,2 @@\n+                    long sz = size + 32 + name.length();\n+                    checkMaxHeaderListSize(sz, action);\n@@ -563,0 +623,2 @@\n+                long sz = size + 32 + name.length() + value.length();\n+                checkMaxHeaderListSize(sz, action);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/hpack\/Decoder.java","additions":71,"deletions":9,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.net.ProtocolException;\n@@ -295,0 +296,13 @@\n+\n+    default void onMaxHeaderListSizeReached(long size, int maxHeaderListSize)\n+        throws ProtocolException {\n+        throw new ProtocolException(String\n+                .format(\"Size exceeds MAX_HEADERS_LIST_SIZE: %s > %s\",\n+                        size, maxHeaderListSize));\n+    }\n+\n+    default void onMaxLiteralWithIndexingReached(long indexed, int maxIndexed)\n+            throws ProtocolException {\n+        throw new ProtocolException(String.format(\"Too many literal with indexing: %s > %s\",\n+                indexed, maxIndexed));\n+    }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/hpack\/DecodingCallback.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -261,0 +261,1 @@\n+        assert encoding : \"encoding is false\";\n@@ -263,1 +264,1 @@\n-    private boolean isHuffmanBetterFor(CharSequence value) {\n+    protected final boolean isHuffmanBetterFor(CharSequence value) {\n@@ -343,0 +344,4 @@\n+    protected final int tableIndexOf(CharSequence name, CharSequence value) {\n+        return getHeaderTable().indexOf(name, value);\n+    }\n+\n@@ -383,0 +388,1 @@\n+        assert done || encoding : \"done: \" + done + \", encoding: \" + encoding;\n@@ -545,0 +551,4 @@\n+\n+    protected final Logger logger() {\n+        return logger;\n+    }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/hpack\/Encoder.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,0 +118,19 @@\n+ * <li><p><b>{@systemProperty jdk.httpclient.maxLiteralWithIndexing}<\/b> (default: 512)<br>\n+ * The maximum number of header field lines (header name and value pairs) that a\n+ * client is willing to add to the HPack Decoder dynamic table during the decoding\n+ * of an entire header field section.\n+ * This is purely an implementation limit.\n+ * If a peer sends a field section with encoding that\n+ * exceeds this limit a {@link java.net.ProtocolException ProtocolException} will be raised.\n+ * A value of zero or a negative value means no limit.\n+ * <\/li>\n+ * <li><p><b>{@systemProperty jdk.httpclient.maxNonFinalResponses}<\/b> (default: 8)<br>\n+ * The maximum number of interim (non-final) responses that a client is prepared\n+ * to accept on a request-response stream before the final response is received.\n+ * Interim responses are responses with a status in the range [100, 199] inclusive.\n+ * This is purely an implementation limit.\n+ * If a peer sends a number of interim response that exceeds this limit before\n+ * sending the final response, a {@link java.net.ProtocolException ProtocolException}\n+ * will be raised.\n+ * A value of zero or a negative value means no limit.\n+ * <\/li>\n@@ -158,0 +177,9 @@\n+ * <li><p><b>{@systemProperty jdk.http.maxHeaderSize}<\/b> (default: 393216 or 384kB)\n+ * <br>The maximum header field section size that the client is prepared to accept.\n+ * This is computed as the sum of the size of the uncompressed header name, plus\n+ * the size of the uncompressed header value, plus an overhead of 32 bytes for\n+ * each field section line. If a peer sends a field section that exceeds this\n+ * size a {@link java.net.ProtocolException ProtocolException} will be raised.\n+ * This applies to all versions of the protocol. A value of zero or a negative\n+ * value means no limit.\n+ * <\/li>\n","filename":"src\/java.net.http\/share\/classes\/module-info.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-        if ((*env)->ExceptionOccurred(env)) return;\n+        if ((*env)->ExceptionCheck(env)) return;\n@@ -214,1 +214,1 @@\n-        if ((*env)->ExceptionOccurred(env)) return NULL;\n+        if ((*env)->ExceptionCheck(env)) return NULL;\n@@ -895,1 +895,1 @@\n-            if ((*env)->ExceptionOccurred(env)) {\n+            if ((*env)->ExceptionCheck(env)) {\n@@ -943,1 +943,1 @@\n-    if ((*env)->ExceptionOccurred(env)) return; \/\/ already failed\n+    if ((*env)->ExceptionCheck(env)) return; \/\/ already failed\n@@ -946,1 +946,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n@@ -963,1 +963,1 @@\n-        if ((*env)->ExceptionOccurred(env)) goto bad;\n+        if ((*env)->ExceptionCheck(env)) goto bad;\n@@ -965,1 +965,1 @@\n-        if ((*env)->ExceptionOccurred(env)) goto bad;\n+        if ((*env)->ExceptionCheck(env)) goto bad;\n@@ -1006,1 +1006,1 @@\n-            if (!(*env)->ExceptionOccurred(env)) {\n+            if (!(*env)->ExceptionCheck(env)) {\n","filename":"src\/java.prefs\/macosx\/native\/libprefs\/MacOSXPreferencesFile.m","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        if ((*env)->ExceptionOccurred(env) != NULL) {\n+        if ((*env)->ExceptionCheck(env)) {\n","filename":"src\/java.security.jgss\/macosx\/native\/libosxkrb5\/SCDynamicStoreConfig.m","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -173,1 +173,1 @@\n-        return \"key \"  + key.toString();\n+        return \"EncryptionKey: \" + key.toString();\n","filename":"src\/java.security.jgss\/share\/classes\/javax\/security\/auth\/kerberos\/EncryptionKey.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.util.Base64;\n@@ -143,2 +142,1 @@\n-            return \"KRB_CRED from \" + sender + \" to \" + recipient + \":\\n\"\n-                    + Base64.getUrlEncoder().encodeToString(message);\n+            return \"KRB_CRED from \" + sender + \" to \" + recipient;\n","filename":"src\/java.security.jgss\/share\/classes\/javax\/security\/auth\/kerberos\/KerberosCredMessage.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -276,3 +276,3 @@\n-        return \"Kerberos Principal \" + principal +\n-                \"Key Version \" + versionNum +\n-                \"key \"  + key.toString();\n+        return \"KerberosKey: principal \" + principal +\n+                \", version \" + versionNum +\n+                \", key \"  + key.toString();\n","filename":"src\/java.security.jgss\/share\/classes\/javax\/security\/auth\/kerberos\/KerberosKey.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,2 @@\n-import sun.security.util.HexDumpEncoder;\n+\n+import sun.security.jgss.krb5.Krb5Util;\n@@ -228,9 +229,2 @@\n-        HexDumpEncoder hd = new HexDumpEncoder();\n-        return \"EncryptionKey: keyType=\" + keyType\n-                          + \" keyBytes (hex dump)=\"\n-                          + (keyBytes == null || keyBytes.length == 0 ?\n-                             \" Empty Key\" :\n-                             '\\n' + hd.encodeBuffer(keyBytes)\n-                          + '\\n');\n-\n-\n+        return \"keyType=\" + keyType\n+                + \", \" + Krb5Util.keyInfo(keyBytes);\n","filename":"src\/java.security.jgss\/share\/classes\/javax\/security\/auth\/kerberos\/KeyImpl.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.io.OutputStream;\n+import java.io.InvalidObjectException;\n@@ -38,0 +38,2 @@\n+import java.io.ObjectInputStream;\n+import java.io.OutputStream;\n@@ -902,5 +904,0 @@\n-        if (DEBUG != null) {\n-            DEBUG.println(\"Krb5Context.wrap: data=[\"\n-                               + getHexBytes(inBuf, offset, len)\n-                               + \"]\");\n-        }\n@@ -908,3 +905,4 @@\n-        if (state != STATE_DONE)\n-        throw new GSSException(GSSException.NO_CONTEXT, -1,\n-                               \"Wrap called in invalid state!\");\n+        if (state != STATE_DONE) {\n+            throw new GSSException(GSSException.NO_CONTEXT, -1,\n+                    \"Wrap called in invalid state!\");\n+        }\n@@ -1053,6 +1051,0 @@\n-            if (DEBUG != null) {\n-                DEBUG.println(\"Krb5Context.unwrap: data=[\"\n-                                   + getHexBytes(data, 0, data.length)\n-                                   + \"]\");\n-            }\n-\n@@ -1408,2 +1400,16 @@\n-            return \"Kerberos session key: etype: \" + key.getEType() + \"\\n\" +\n-                    new HexDumpEncoder().encodeBuffer(key.getBytes());\n+            return \"Kerberos session key: etype=\" + key.getEType()\n+                    + \", \" + Krb5Util.keyInfo(key.getBytes());\n+        }\n+\n+        \/**\n+         * Restores the state of this object from the stream.\n+         *\n+         * @param  stream the {@code ObjectInputStream} from which data is read\n+         * @throws IOException if an I\/O error occurs\n+         * @throws ClassNotFoundException if a serialized class cannot be loaded\n+         *\/\n+        @java.io.Serial\n+        private void readObject(ObjectInputStream stream)\n+                throws IOException, ClassNotFoundException {\n+            throw new InvalidObjectException\n+                    (\"KerberosSessionKey not directly deserializable\");\n@@ -1480,1 +1486,0 @@\n-\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/krb5\/Krb5Context.java","additions":23,"deletions":18,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.io.InvalidObjectException;\n@@ -37,0 +38,1 @@\n+import java.io.ObjectInputStream;\n@@ -403,0 +405,13 @@\n+\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\"Krb5InitCredential not deserializable\");\n+    }\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/krb5\/Krb5InitCredential.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -190,0 +190,15 @@\n+\n+    public static String keyInfo(byte[] data) {\n+        if (data == null) {\n+            return \"null key\";\n+        } else if (data.length == 0) {\n+            return \"empty key\";\n+        } else {\n+            for (byte b : data) {\n+                if (b != 0) {\n+                    return data.length + \"-byte key\";\n+                }\n+            }\n+            return data.length + \"-byte zero key\";\n+        }\n+    }\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/krb5\/Krb5Util.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import sun.security.jgss.krb5.Krb5Util;\n@@ -501,6 +502,1 @@\n-                + \" kvno=\" + kvno\n-                + \" keyValue (hex dump)=\"\n-                + (keyValue == null || keyValue.length == 0 ?\n-                \" Empty Key\" : '\\n'\n-                + Krb5.hexDumper.encodeBuffer(keyValue)\n-                + '\\n');\n+                + \", kvno=\" + kvno + \", \" + Krb5Util.keyInfo(keyValue);\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/EncryptionKey.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -86,3 +86,1 @@\n-\/\/ The instance fields not statically typed as Serializable are ASN.1\n-\/\/ encoded and written by the writeObject method.\n-@SuppressWarnings(\"serial\")\n+\n@@ -92,13 +90,16 @@\n-    private int pvno;\n-    private int msgType;\n-    private KerberosTime cTime; \/\/optional\n-    private Integer cuSec; \/\/optional\n-    private KerberosTime sTime;\n-    private Integer suSec;\n-    private int errorCode;\n-    private Realm crealm; \/\/optional\n-    private PrincipalName cname; \/\/optional\n-    private PrincipalName sname;\n-    private String eText; \/\/optional\n-    private byte[] eData; \/\/optional\n-    private Checksum eCksum; \/\/optional\n+    private transient int pvno;\n+    private transient int msgType;\n+    private transient KerberosTime cTime; \/\/optional\n+    private transient Integer cuSec; \/\/optional\n+    private transient KerberosTime sTime;\n+    private transient Integer suSec;\n+    private transient int errorCode;\n+    private transient Realm crealm; \/\/optional\n+    private transient PrincipalName cname; \/\/optional\n+    private transient PrincipalName sname;\n+    private transient String eText; \/\/optional\n+    private transient byte[] eData; \/\/optional\n+    private transient Checksum eCksum; \/\/optional\n+\n+    private transient PAData[] pa;    \/\/ PA-DATA in eData\n+\n@@ -106,1 +107,0 @@\n-    private PAData[] pa;    \/\/ PA-DATA in eData\n@@ -108,0 +108,8 @@\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  is the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/internal\/KRBError.java","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -323,3 +323,0 @@\n-    public static final sun.security.util.HexDumpEncoder hexDumper =\n-        new sun.security.util.HexDumpEncoder();\n-\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/internal\/Krb5.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -198,4 +198,0 @@\n-                if (DEBUG != null) {\n-                    DEBUG.println(\">>> Kinit console input \" +\n-                        new String(psswd));\n-                }\n","filename":"src\/java.security.jgss\/windows\/classes\/sun\/security\/krb5\/internal\/tools\/Kinit.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -880,1 +880,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n@@ -886,1 +886,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n@@ -996,1 +996,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n@@ -1021,1 +1021,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n","filename":"src\/java.security.jgss\/windows\/native\/libw2k_lsa_auth\/NativeCreds.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -435,1 +435,1 @@\n-            if ((*env)->ExceptionOccurred(env)) return;\n+            if ((*env)->ExceptionCheck(env)) return;\n@@ -466,1 +466,1 @@\n-    if ((*env)->ExceptionOccurred(env)) return;\n+    if ((*env)->ExceptionCheck(env)) return;\n@@ -639,1 +639,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n","filename":"src\/jdk.attach\/windows\/native\/libattach\/VirtualMachineImpl.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -423,0 +423,17 @@\n+        noModule = new ModuleSymbol(names.empty, null) {\n+            @Override public boolean isNoModule() {\n+                return true;\n+            }\n+        };\n+        addRootPackageFor(noModule);\n+\n+        Source source = Source.instance(context);\n+        if (Feature.MODULES.allowedInSource(source)) {\n+            java_base = enterModule(names.java_base);\n+            \/\/avoid completing java.base during the Symtab initialization\n+            java_base.completer = Completer.NULL_COMPLETER;\n+            java_base.visiblePackages = Collections.emptyMap();\n+        } else {\n+            java_base = noModule;\n+        }\n+\n@@ -430,1 +447,0 @@\n-                    ModuleSymbol java_base = enterModule(names.java_base);\n@@ -450,1 +466,0 @@\n-                    ModuleSymbol java_base = enterModule(names.java_base);\n@@ -459,7 +474,0 @@\n-        noModule = new ModuleSymbol(names.empty, null) {\n-            @Override public boolean isNoModule() {\n-                return true;\n-            }\n-        };\n-        addRootPackageFor(noModule);\n-\n@@ -529,10 +537,0 @@\n-        Source source = Source.instance(context);\n-        if (Feature.MODULES.allowedInSource(source)) {\n-            java_base = enterModule(names.java_base);\n-            \/\/avoid completing java.base during the Symtab initialization\n-            java_base.completer = Completer.NULL_COMPLETER;\n-            java_base.visiblePackages = Collections.emptyMap();\n-        } else {\n-            java_base = noModule;\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":17,"deletions":19,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -243,0 +243,13 @@\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\"P11Key not directly deserializable\");\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,0 +190,8 @@\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  in the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n@@ -193,0 +201,6 @@\n+        if (token == null) {\n+            throw new InvalidObjectException(\"token is null\");\n+        }\n+        if (mixBuffer != null) {\n+            mixBuffer = mixBuffer.clone();\n+        }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11SecureRandom.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1950,0 +1950,13 @@\n+    \/**\n+     * Restores the state of this object from the stream.\n+     *\n+     * @param  stream the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n+     *\/\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\"SunPKCS11 not directly deserializable\");\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -130,5 +130,0 @@\n-        sb.append(Constants.INDENT);\n-        sb.append(\"pPassword: \");\n-        sb.append(pPassword);\n-        sb.append(Constants.NEWLINE);\n-\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_PBE_PARAMS.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## OASIS PKCS #11 Cryptographic Token Interface v3.0\n+## OASIS PKCS #11 Cryptographic Token Interface v3.1\n@@ -6,1 +6,1 @@\n-Copyright  OASIS Open 2020. All Rights Reserved.\n+Copyright  OASIS Open 2023. All Rights Reserved.\n@@ -8,1 +8,1 @@\n-    All capitalized terms in the following text have the meanings\n+All capitalized terms in the following text have the meanings\n@@ -11,1 +11,1 @@\n-[http:\/\/www.oasis-open.org\/policies-guidelines\/ipr]\n+[https:\/\/www.oasis-open.org\/policies-guidelines\/ipr\/].\n@@ -13,1 +13,1 @@\n-    This document and translations of it may be copied and furnished to\n+This document and translations of it may be copied and furnished to\n@@ -26,1 +26,1 @@\n-    The limited permissions granted above are perpetual and will not be\n+The limited permissions granted above are perpetual and will not be\n@@ -29,1 +29,1 @@\n-    This document and the information contained herein is provided on an\n+This document and the information contained herein is provided on an\n@@ -38,1 +38,5 @@\n-    [OASIS requests that any OASIS Party or any other party that\n+As stated in the OASIS IPR Policy, the following three paragraphs in\n+brackets apply to OASIS Standards Final Deliverable documents (Committee\n+Specifications, OASIS Standards, or Approved Errata).\n+\n+[OASIS requests that any OASIS Party or any other party that\n@@ -46,1 +50,1 @@\n-    [OASIS invites any party to contact the OASIS TC Administrator if it\n+[OASIS invites any party to contact the OASIS TC Administrator if it\n@@ -55,1 +59,1 @@\n-    [OASIS takes no position regarding the validity or scope of any\n+[OASIS takes no position regarding the validity or scope of any\n","filename":"src\/jdk.crypto.cryptoki\/share\/legal\/pkcs11cryptotoken.md","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1,5 +1,8 @@\n-\/* Copyright (c) OASIS Open 2016-2019. All Rights Reserved.\n- * Distributed under the terms of the OASIS IPR Policy,\n- * [http:\/\/www.oasis-open.org\/policies-guidelines\/ipr], AS-IS, WITHOUT ANY\n- * IMPLIED OR EXPRESS WARRANTY; there is no warranty of MERCHANTABILITY, FITNESS FOR A\n- * PARTICULAR PURPOSE or NONINFRINGEMENT of the rights of others.\n+\/*\n+ * PKCS #11 Specification Version 3.1\n+ * OASIS Standard\n+ * 23 July 2023\n+ * Copyright (c) OASIS Open 2023. All Rights Reserved.\n+ * Source: https:\/\/docs.oasis-open.org\/pkcs11\/pkcs11-spec\/v3.1\/os\/include\/pkcs11-v3.1\/\n+ * Latest stage of narrative specification: https:\/\/docs.oasis-open.org\/pkcs11\/pkcs11-spec\/v3.1\/pkcs11-spec-v3.1.html\n+ * TC IPR Statement: https:\/\/www.oasis-open.org\/committees\/pkcs11\/ipr.php\n@@ -50,1 +53,1 @@\n- * If you're using windows, it might be defined by:\n+ * If you're using Windows, it might be defined by:\n@@ -68,1 +71,1 @@\n- * If you're using Windows to declare a function in a Win32 cryptoki .dll,\n+ * If you're using Windows to declare a function in a Win32 Cryptoki .dll,\n@@ -244,1 +247,0 @@\n-\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/pkcs11.h","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,9 +1,8 @@\n-\/* Copyright (c) OASIS Open 2016, 2019. All Rights Reserved.\/\n- * \/Distributed under the terms of the OASIS IPR Policy,\n- * [http:\/\/www.oasis-open.org\/policies-guidelines\/ipr], AS-IS, WITHOUT ANY\n- * IMPLIED OR EXPRESS WARRANTY; there is no warranty of MERCHANTABILITY, FITNESS FOR A\n- * PARTICULAR PURPOSE or NONINFRINGEMENT of the rights of others.\n- *\/\n-\n-\/* Latest version of the specification:\n- * http:\/\/docs.oasis-open.org\/pkcs11\/pkcs11-base\/v2.40\/pkcs11-base-v2.40.html\n+\/*\n+ * PKCS #11 Specification Version 3.1\n+ * OASIS Standard\n+ * 23 July 2023\n+ * Copyright (c) OASIS Open 2023. All Rights Reserved.\n+ * Source: https:\/\/docs.oasis-open.org\/pkcs11\/pkcs11-spec\/v3.1\/os\/include\/pkcs11-v3.1\/\n+ * Latest stage of narrative specification: https:\/\/docs.oasis-open.org\/pkcs11\/pkcs11-spec\/v3.1\/pkcs11-spec-v3.1.html\n+ * TC IPR Statement: https:\/\/www.oasis-open.org\/committees\/pkcs11\/ipr.php\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/pkcs11f.h","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,9 +1,8 @@\n-\/* Copyright (c) OASIS Open 2016, 2019. All Rights Reserved.\/\n- * \/Distributed under the terms of the OASIS IPR Policy,\n- * [http:\/\/www.oasis-open.org\/policies-guidelines\/ipr], AS-IS, WITHOUT ANY\n- * IMPLIED OR EXPRESS WARRANTY; there is no warranty of MERCHANTABILITY, FITNESS FOR A\n- * PARTICULAR PURPOSE or NONINFRINGEMENT of the rights of others.\n- *\/\n-\n-\/* Latest version of the specification:\n- * http:\/\/docs.oasis-open.org\/pkcs11\/pkcs11-base\/v2.40\/pkcs11-base-v2.40.html\n+\/*\n+ * PKCS #11 Specification Version 3.1\n+ * OASIS Standard\n+ * 23 July 2023\n+ * Copyright (c) OASIS Open 2023. All Rights Reserved.\n+ * Source: https:\/\/docs.oasis-open.org\/pkcs11\/pkcs11-spec\/v3.1\/os\/include\/pkcs11-v3.1\/\n+ * Latest stage of narrative specification: https:\/\/docs.oasis-open.org\/pkcs11\/pkcs11-spec\/v3.1\/pkcs11-spec-v3.1.html\n+ * TC IPR Statement: https:\/\/www.oasis-open.org\/committees\/pkcs11\/ipr.php\n@@ -21,1 +20,1 @@\n-#define CRYPTOKI_VERSION_MINOR          0\n+#define CRYPTOKI_VERSION_MINOR          1\n@@ -332,0 +331,2 @@\n+#define CKP_COMPLETE_PROVIDER         0x00000005UL\n+#define CKP_HKDF_TLS_TOKEN            0x00000006UL\n@@ -334,0 +335,1 @@\n+\n@@ -412,0 +414,1 @@\n+\n@@ -415,0 +418,1 @@\n+#define CKK_HSS                 0x00000046UL\n@@ -484,3 +488,3 @@\n-#define CKA_HASH_OF_SUBJECT_PUBLIC_KEY  0x0000008AUL\n-#define CKA_HASH_OF_ISSUER_PUBLIC_KEY   0x0000008BUL\n-#define CKA_NAME_HASH_ALGORITHM         0x0000008CUL\n+#define CKA_HASH_OF_SUBJECT_PUBLIC_KEY  0x0000008aUL\n+#define CKA_HASH_OF_ISSUER_PUBLIC_KEY   0x0000008bUL\n+#define CKA_NAME_HASH_ALGORITHM         0x0000008cUL\n@@ -499,3 +503,3 @@\n-#define CKA_VERIFY             0x0000010AUL\n-#define CKA_VERIFY_RECOVER     0x0000010BUL\n-#define CKA_DERIVE             0x0000010CUL\n+#define CKA_VERIFY             0x0000010aUL\n+#define CKA_VERIFY_RECOVER     0x0000010bUL\n+#define CKA_DERIVE             0x0000010cUL\n@@ -558,6 +562,6 @@\n-#define CKA_OTP_COUNTER               0x0000022EUL\n-#define CKA_OTP_TIME                  0x0000022FUL\n-#define CKA_OTP_USER_IDENTIFIER       0x0000022AUL\n-#define CKA_OTP_SERVICE_IDENTIFIER    0x0000022BUL\n-#define CKA_OTP_SERVICE_LOGO          0x0000022CUL\n-#define CKA_OTP_SERVICE_LOGO_TYPE     0x0000022DUL\n+#define CKA_OTP_COUNTER               0x0000022eUL\n+#define CKA_OTP_TIME                  0x0000022fUL\n+#define CKA_OTP_USER_IDENTIFIER       0x0000022aUL\n+#define CKA_OTP_SERVICE_IDENTIFIER    0x0000022bUL\n+#define CKA_OTP_SERVICE_LOGO          0x0000022cUL\n+#define CKA_OTP_SERVICE_LOGO_TYPE     0x0000022dUL\n@@ -589,0 +593,1 @@\n+\n@@ -606,0 +611,7 @@\n+\/* HSS *\/\n+#define CKA_HSS_LEVELS                  0x00000617UL\n+#define CKA_HSS_LMS_TYPE                0x00000618UL\n+#define CKA_HSS_LMOTS_TYPE              0x00000619UL\n+#define CKA_HSS_LMS_TYPES               0x0000061aUL\n+#define CKA_HSS_LMOTS_TYPES             0x0000061bUL\n+#define CKA_HSS_KEYS_REMAINING          0x0000061cUL\n@@ -647,5 +659,5 @@\n-#define CKM_RSA_X9_31_KEY_PAIR_GEN     0x0000000AUL\n-#define CKM_RSA_X9_31                  0x0000000BUL\n-#define CKM_SHA1_RSA_X9_31             0x0000000CUL\n-#define CKM_RSA_PKCS_PSS               0x0000000DUL\n-#define CKM_SHA1_RSA_PKCS_PSS          0x0000000EUL\n+#define CKM_RSA_X9_31_KEY_PAIR_GEN     0x0000000aUL\n+#define CKM_RSA_X9_31                  0x0000000bUL\n+#define CKM_SHA1_RSA_X9_31             0x0000000cUL\n+#define CKM_RSA_PKCS_PSS               0x0000000dUL\n+#define CKM_SHA1_RSA_PKCS_PSS          0x0000000eUL\n@@ -662,2 +674,2 @@\n-#define CKM_DSA_SHA3_384               0x0000001AUL\n-#define CKM_DSA_SHA3_512               0x0000001BUL\n+#define CKM_DSA_SHA3_384               0x0000001aUL\n+#define CKM_DSA_SHA3_512               0x0000001bUL\n@@ -685,6 +697,6 @@\n-#define CKM_SHA512_224_HMAC_GENERAL    0x0000004AUL\n-#define CKM_SHA512_224_KEY_DERIVATION  0x0000004BUL\n-#define CKM_SHA512_256                 0x0000004CUL\n-#define CKM_SHA512_256_HMAC            0x0000004DUL\n-#define CKM_SHA512_256_HMAC_GENERAL    0x0000004EUL\n-#define CKM_SHA512_256_KEY_DERIVATION  0x0000004FUL\n+#define CKM_SHA512_224_HMAC_GENERAL    0x0000004aUL\n+#define CKM_SHA512_224_KEY_DERIVATION  0x0000004bUL\n+#define CKM_SHA512_256                 0x0000004cUL\n+#define CKM_SHA512_256_HMAC            0x0000004dUL\n+#define CKM_SHA512_256_HMAC_GENERAL    0x0000004eUL\n+#define CKM_SHA512_256_KEY_DERIVATION  0x0000004fUL\n@@ -784,19 +796,19 @@\n-#define CKM_ACTI                       0x000002A0UL\n-#define CKM_ACTI_KEY_GEN               0x000002A1UL\n-\n-#define CKM_SHA3_256                   0x000002B0UL\n-#define CKM_SHA3_256_HMAC              0x000002B1UL\n-#define CKM_SHA3_256_HMAC_GENERAL      0x000002B2UL\n-#define CKM_SHA3_256_KEY_GEN           0x000002B3UL\n-#define CKM_SHA3_224                   0x000002B5UL\n-#define CKM_SHA3_224_HMAC              0x000002B6UL\n-#define CKM_SHA3_224_HMAC_GENERAL      0x000002B7UL\n-#define CKM_SHA3_224_KEY_GEN           0x000002B8UL\n-#define CKM_SHA3_384                   0x000002C0UL\n-#define CKM_SHA3_384_HMAC              0x000002C1UL\n-#define CKM_SHA3_384_HMAC_GENERAL      0x000002C2UL\n-#define CKM_SHA3_384_KEY_GEN           0x000002C3UL\n-#define CKM_SHA3_512                   0x000002D0UL\n-#define CKM_SHA3_512_HMAC              0x000002D1UL\n-#define CKM_SHA3_512_HMAC_GENERAL      0x000002D2UL\n-#define CKM_SHA3_512_KEY_GEN           0x000002D3UL\n+#define CKM_ACTI                       0x000002a0UL\n+#define CKM_ACTI_KEY_GEN               0x000002a1UL\n+\n+#define CKM_SHA3_256                   0x000002b0UL\n+#define CKM_SHA3_256_HMAC              0x000002b1UL\n+#define CKM_SHA3_256_HMAC_GENERAL      0x000002b2UL\n+#define CKM_SHA3_256_KEY_GEN           0x000002b3UL\n+#define CKM_SHA3_224                   0x000002b5UL\n+#define CKM_SHA3_224_HMAC              0x000002b6UL\n+#define CKM_SHA3_224_HMAC_GENERAL      0x000002b7UL\n+#define CKM_SHA3_224_KEY_GEN           0x000002b8UL\n+#define CKM_SHA3_384                   0x000002c0UL\n+#define CKM_SHA3_384_HMAC              0x000002c1UL\n+#define CKM_SHA3_384_HMAC_GENERAL      0x000002c2UL\n+#define CKM_SHA3_384_KEY_GEN           0x000002c3UL\n+#define CKM_SHA3_512                   0x000002d0UL\n+#define CKM_SHA3_512_HMAC              0x000002d1UL\n+#define CKM_SHA3_512_HMAC_GENERAL      0x000002d2UL\n+#define CKM_SHA3_512_KEY_GEN           0x000002d3UL\n@@ -873,3 +885,3 @@\n-#define CKM_SHA3_512_KEY_DERIVATION    0x0000039AUL\n-#define CKM_SHAKE_128_KEY_DERIVATION   0x0000039BUL\n-#define CKM_SHAKE_256_KEY_DERIVATION   0x0000039CUL\n+#define CKM_SHA3_512_KEY_DERIVATION    0x0000039aUL\n+#define CKM_SHAKE_128_KEY_DERIVATION   0x0000039bUL\n+#define CKM_SHAKE_256_KEY_DERIVATION   0x0000039cUL\n@@ -883,34 +895,36 @@\n-#define CKM_PBE_MD2_DES_CBC            0x000003A0UL\n-#define CKM_PBE_MD5_DES_CBC            0x000003A1UL\n-#define CKM_PBE_MD5_CAST_CBC           0x000003A2UL\n-#define CKM_PBE_MD5_CAST3_CBC          0x000003A3UL\n-#define CKM_PBE_MD5_CAST5_CBC          0x000003A4UL \/* Deprecated *\/\n-#define CKM_PBE_MD5_CAST128_CBC        0x000003A4UL\n-#define CKM_PBE_SHA1_CAST5_CBC         0x000003A5UL \/* Deprecated *\/\n-#define CKM_PBE_SHA1_CAST128_CBC       0x000003A5UL\n-#define CKM_PBE_SHA1_RC4_128           0x000003A6UL\n-#define CKM_PBE_SHA1_RC4_40            0x000003A7UL\n-#define CKM_PBE_SHA1_DES3_EDE_CBC      0x000003A8UL\n-#define CKM_PBE_SHA1_DES2_EDE_CBC      0x000003A9UL\n-#define CKM_PBE_SHA1_RC2_128_CBC       0x000003AAUL\n-#define CKM_PBE_SHA1_RC2_40_CBC        0x000003ABUL\n-\n-#define CKM_PKCS5_PBKD2                0x000003B0UL\n-\n-#define CKM_PBA_SHA1_WITH_SHA1_HMAC    0x000003C0UL\n-\n-#define CKM_WTLS_PRE_MASTER_KEY_GEN         0x000003D0UL\n-#define CKM_WTLS_MASTER_KEY_DERIVE          0x000003D1UL\n-#define CKM_WTLS_MASTER_KEY_DERIVE_DH_ECC   0x000003D2UL\n-#define CKM_WTLS_PRF                        0x000003D3UL\n-#define CKM_WTLS_SERVER_KEY_AND_MAC_DERIVE  0x000003D4UL\n-#define CKM_WTLS_CLIENT_KEY_AND_MAC_DERIVE  0x000003D5UL\n-\n-#define CKM_TLS12_MAC                       0x000003D8UL\n-#define CKM_TLS12_KDF                       0x000003D9UL\n-#define CKM_TLS12_MASTER_KEY_DERIVE         0x000003E0UL\n-#define CKM_TLS12_KEY_AND_MAC_DERIVE        0x000003E1UL\n-#define CKM_TLS12_MASTER_KEY_DERIVE_DH      0x000003E2UL\n-#define CKM_TLS12_KEY_SAFE_DERIVE           0x000003E3UL\n-#define CKM_TLS_MAC                         0x000003E4UL\n-#define CKM_TLS_KDF                         0x000003E5UL\n+#define CKM_PBE_MD2_DES_CBC            0x000003a0UL\n+#define CKM_PBE_MD5_DES_CBC            0x000003a1UL\n+#define CKM_PBE_MD5_CAST_CBC           0x000003a2UL\n+#define CKM_PBE_MD5_CAST3_CBC          0x000003a3UL\n+#define CKM_PBE_MD5_CAST5_CBC          0x000003a4UL \/* Deprecated *\/\n+#define CKM_PBE_MD5_CAST128_CBC        0x000003a4UL\n+#define CKM_PBE_SHA1_CAST5_CBC         0x000003a5UL \/* Deprecated *\/\n+#define CKM_PBE_SHA1_CAST128_CBC       0x000003a5UL\n+#define CKM_PBE_SHA1_RC4_128           0x000003a6UL\n+#define CKM_PBE_SHA1_RC4_40            0x000003a7UL\n+#define CKM_PBE_SHA1_DES3_EDE_CBC      0x000003a8UL\n+#define CKM_PBE_SHA1_DES2_EDE_CBC      0x000003a9UL\n+#define CKM_PBE_SHA1_RC2_128_CBC       0x000003aaUL\n+#define CKM_PBE_SHA1_RC2_40_CBC        0x000003abUL\n+\n+#define CKM_PKCS5_PBKD2                0x000003b0UL\n+\n+#define CKM_PBA_SHA1_WITH_SHA1_HMAC    0x000003c0UL\n+\n+#define CKM_WTLS_PRE_MASTER_KEY_GEN         0x000003d0UL\n+#define CKM_WTLS_MASTER_KEY_DERIVE          0x000003d1UL\n+#define CKM_WTLS_MASTER_KEY_DERIVE_DH_ECC   0x000003d2UL\n+#define CKM_WTLS_PRF                        0x000003d3UL\n+#define CKM_WTLS_SERVER_KEY_AND_MAC_DERIVE  0x000003d4UL\n+#define CKM_WTLS_CLIENT_KEY_AND_MAC_DERIVE  0x000003d5UL\n+\n+#define CKM_TLS10_MAC_SERVER                0x000003d6UL\n+#define CKM_TLS10_MAC_CLIENT                0x000003d7UL\n+#define CKM_TLS12_MAC                       0x000003d8UL\n+#define CKM_TLS12_KDF                       0x000003d9UL\n+#define CKM_TLS12_MASTER_KEY_DERIVE         0x000003e0UL\n+#define CKM_TLS12_KEY_AND_MAC_DERIVE        0x000003e1UL\n+#define CKM_TLS12_MASTER_KEY_DERIVE_DH      0x000003e2UL\n+#define CKM_TLS12_KEY_SAFE_DERIVE           0x000003e3UL\n+#define CKM_TLS_MAC                         0x000003e4UL\n+#define CKM_TLS_KDF                         0x000003e5UL\n@@ -986,1 +1000,1 @@\n-#define CKM_EC_KEY_PAIR_GEN_W_EXTRA_BITS 0x0000140BUL\n+#define CKM_EC_KEY_PAIR_GEN_W_EXTRA_BITS 0x0000140bUL\n@@ -1015,2 +1029,2 @@\n-#define CKM_AES_CMAC                   0x0000108AUL\n-#define CKM_AES_CMAC_GENERAL           0x0000108BUL\n+#define CKM_AES_CMAC                   0x0000108aUL\n+#define CKM_AES_CMAC_GENERAL           0x0000108bUL\n@@ -1018,3 +1032,3 @@\n-#define CKM_AES_XCBC_MAC               0x0000108CUL\n-#define CKM_AES_XCBC_MAC_96            0x0000108DUL\n-#define CKM_AES_GMAC                   0x0000108EUL\n+#define CKM_AES_XCBC_MAC               0x0000108cUL\n+#define CKM_AES_XCBC_MAC_96            0x0000108dUL\n+#define CKM_AES_GMAC                   0x0000108eUL\n@@ -1069,0 +1083,1 @@\n+#define CKM_AES_KEY_WRAP_PKCS7         0x0000210CUL\n@@ -1128,0 +1143,8 @@\n+#define CKM_IKE2_PRF_PLUS_DERIVE       0x0000402eUL\n+#define CKM_IKE_PRF_DERIVE             0x0000402fUL\n+#define CKM_IKE1_PRF_DERIVE            0x00004030UL\n+#define CKM_IKE1_EXTENDED_DERIVE       0x00004031UL\n+#define CKM_HSS_KEY_PAIR_GEN           0x00004032UL\n+#define CKM_HSS                        0x00004033UL\n+\n+\n@@ -1323,0 +1346,1 @@\n+#define CKR_KEY_EXHAUSTED                     0x00000203UL\n@@ -1439,0 +1463,1 @@\n+\n@@ -1704,2 +1729,1 @@\n-typedef CK_DES_CBC_ENCRYPT_DATA_PARAMS CK_PTR \\\n-        CK_DES_CBC_ENCRYPT_DATA_PARAMS_PTR;\n+typedef CK_DES_CBC_ENCRYPT_DATA_PARAMS CK_PTR CK_DES_CBC_ENCRYPT_DATA_PARAMS_PTR;\n@@ -1713,2 +1737,1 @@\n-typedef CK_AES_CBC_ENCRYPT_DATA_PARAMS CK_PTR \\\n-        CK_AES_CBC_ENCRYPT_DATA_PARAMS_PTR;\n+typedef CK_AES_CBC_ENCRYPT_DATA_PARAMS CK_PTR CK_AES_CBC_ENCRYPT_DATA_PARAMS_PTR;\n@@ -2054,0 +2077,1 @@\n+#define CKG_GENERATE_COUNTER_XOR 0x00000004UL\n@@ -2064,1 +2088,1 @@\n-typedef CK_GCM_MESSAGE_PARAMS CK_GCM_MESSAGE_PARAMS_PTR;\n+typedef CK_GCM_MESSAGE_PARAMS CK_PTR CK_GCM_MESSAGE_PARAMS_PTR;\n@@ -2087,1 +2111,1 @@\n-typedef CK_CCM_MESSAGE_PARAMS CK_CCM_MESSAGE_PARAMS_PTR;\n+typedef CK_CCM_MESSAGE_PARAMS CK_PTR CK_CCM_MESSAGE_PARAMS_PTR;\n@@ -2342,1 +2366,0 @@\n-\n@@ -2426,0 +2449,1 @@\n+\/* HKDF params *\/\n@@ -2443,0 +2467,55 @@\n+\/* HSS *\/\n+typedef CK_ULONG                   CK_HSS_LEVELS;\n+typedef CK_ULONG                   CK_LMS_TYPE;\n+typedef CK_ULONG                   CK_LMOTS_TYPE;\n+\n+typedef struct specifiedParams {\n+    CK_HSS_LEVELS levels;\n+    CK_LMS_TYPE   lm_type[8];\n+    CK_LMOTS_TYPE lm_ots_type[8];\n+} specifiedParams;\n+\n+\/* IKE Params *\/\n+typedef struct CK_IKE2_PRF_PLUS_DERIVE_PARAMS {\n+    CK_MECHANISM_TYPE prfMechanism;\n+    CK_BBOOL          bHasSeedKey;\n+    CK_OBJECT_HANDLE  hSeedKey;\n+    CK_BYTE_PTR       pSeedData;\n+    CK_ULONG          ulSeedDataLen;\n+} CK_IKE2_PRF_PLUS_DERIVE_PARAMS;\n+typedef CK_IKE2_PRF_PLUS_DERIVE_PARAMS CK_PTR CK_IKE2_PRF_PLUS_DERIVE_PARAMS_PTR;\n+\n+typedef struct CK_IKE_PRF_DERIVE_PARAMS {\n+    CK_MECHANISM_TYPE prfMechanism;\n+    CK_BBOOL          bDataAsKey;\n+    CK_BBOOL          bRekey;\n+    CK_BYTE_PTR       pNi;\n+    CK_ULONG          ulNiLen;\n+    CK_BYTE_PTR       pNr;\n+    CK_ULONG          ulNrLen;\n+    CK_OBJECT_HANDLE  hNewKey;\n+} CK_IKE_PRF_DERIVE_PARAMS;\n+typedef CK_IKE_PRF_DERIVE_PARAMS CK_PTR CK_IKE_PRF_DERIVE_PARAMS_PTR;\n+\n+typedef struct CK_IKE1_PRF_DERIVE_PARAMS {\n+    CK_MECHANISM_TYPE prfMechanism;\n+    CK_BBOOL          bHasPrevKey;\n+    CK_OBJECT_HANDLE  hKeygxy;\n+    CK_OBJECT_HANDLE  hPrevKey;\n+    CK_BYTE_PTR       pCKYi;\n+    CK_ULONG          ulCKYiLen;\n+    CK_BYTE_PTR       pCKYr;\n+    CK_ULONG          ulCKYrLen;\n+    CK_BYTE           keyNumber;\n+} CK_IKE1_PRF_DERIVE_PARAMS;\n+typedef CK_IKE1_PRF_DERIVE_PARAMS CK_PTR CK_IKE1_PRF_DERIVE_PARAMS_PTR;\n+\n+typedef struct CK_IKE1_EXTENDED_DERIVE_PARAMS {\n+    CK_MECHANISM_TYPE prfMechanism;\n+    CK_BBOOL          bHasKeygxy;\n+    CK_OBJECT_HANDLE  hKeygxy;\n+    CK_BYTE_PTR       pExtraData;\n+    CK_ULONG          ulExtraDataLen;\n+} CK_IKE1_EXTENDED_DERIVE_PARAMS;\n+typedef CK_IKE1_EXTENDED_DERIVE_PARAMS CK_PTR CK_IKE1_EXTENDED_DERIVE_PARAMS_PTR;\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/pkcs11t.h","additions":183,"deletions":104,"binary":false,"changes":287,"status":"modified"},{"patch":"@@ -392,3 +392,3 @@\n-      \/\/ int rslt =\n-      hcreate_r(htab_sz, symtab->hash_table);\n-      \/\/ guarantee(rslt, \"unexpected failure: hcreate_r\");\n+      if (hcreate_r(htab_sz, symtab->hash_table) == 0) {\n+        goto bad;\n+      }\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/symtab.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,10 @@\n+ * <li><p><b>{@systemProperty sun.net.httpserver.maxReqHeaderSize}<\/b> (default: 393216 or 384kB)<br>\n+ *  The maximum header field section size that the server is prepared to accept.\n+ *  This is computed as the sum of the size of the header name, plus\n+ *  the size of the header value, plus an overhead of 32 bytes for\n+ *  each field section line. The request line counts as a first field section line,\n+ *  where the name is empty and the value is the whole line.\n+ *  If this limit is exceeded while the headers are being read, then the connection\n+ *  is terminated and the request ignored.\n+ *  If the value is less than or equal to zero, there is no limit.\n+ * <\/li>\n","filename":"src\/jdk.httpserver\/share\/classes\/module-info.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+    private final int maxReqHeaderSize;\n@@ -49,0 +50,1 @@\n+        this.maxReqHeaderSize = ServerConfig.getMaxReqHeaderSize();\n@@ -78,0 +80,1 @@\n+        long lsize = 32;\n@@ -90,0 +93,1 @@\n+                    lsize = lsize + 2;\n@@ -96,0 +100,1 @@\n+                    lsize = lsize + 1;\n@@ -98,0 +103,5 @@\n+            if (maxReqHeaderSize > 0 && lsize > maxReqHeaderSize) {\n+                throw new IOException(\"Maximum header (\" +\n+                        \"sun.net.httpserver.maxReqHeaderSize) exceeded, \" +\n+                        ServerConfig.getMaxReqHeaderSize() + \".\");\n+            }\n@@ -103,1 +113,1 @@\n-    private void consume (int c) {\n+    private void consume (int c) throws IOException {\n@@ -141,0 +151,1 @@\n+        long hsize = startLine.length() + 32L;\n@@ -147,0 +158,1 @@\n+            hsize = hsize + 1;\n@@ -148,0 +160,7 @@\n+                \/\/ We start parsing for a new name value pair here.\n+                \/\/ The max header size includes an overhead of 32 bytes per\n+                \/\/ name value pair.\n+                \/\/ See SETTINGS_MAX_HEADER_LIST_SIZE, RFC 9113, section 6.5.2.\n+                long maxRemaining = maxReqHeaderSize > 0\n+                        ? maxReqHeaderSize - hsize - 32\n+                        : Long.MAX_VALUE;\n@@ -181,0 +200,5 @@\n+                    if (maxReqHeaderSize > 0 && len > maxRemaining) {\n+                        throw new IOException(\"Maximum header (\" +\n+                                \"sun.net.httpserver.maxReqHeaderSize) exceeded, \" +\n+                                ServerConfig.getMaxReqHeaderSize() + \".\");\n+                    }\n@@ -208,0 +232,7 @@\n+            hsize = hsize + len + 32;\n+            if (maxReqHeaderSize > 0 && hsize > maxReqHeaderSize) {\n+                throw new IOException(\"Maximum header (\" +\n+                        \"sun.net.httpserver.maxReqHeaderSize) exceeded, \" +\n+                        ServerConfig.getMaxReqHeaderSize() + \".\");\n+            }\n+\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/Request.java","additions":33,"deletions":2,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,1 @@\n+    private static final int  DEFAULT_MAX_REQ_HEADER_SIZE = 380 * 1024;\n@@ -65,0 +66,3 @@\n+    \/\/ a maximum value for the header list size. This is the\n+    \/\/ names size + values size + 32 bytes per field line\n+    private static int maxReqHeadersSize;\n@@ -110,0 +114,8 @@\n+                    \/\/ a value <= 0 means unlimited\n+                    maxReqHeadersSize = Integer.getInteger(\n+                            \"sun.net.httpserver.maxReqHeaderSize\",\n+                            DEFAULT_MAX_REQ_HEADER_SIZE);\n+                    if (maxReqHeadersSize <= 0) {\n+                        maxReqHeadersSize = 0;\n+                    }\n+\n@@ -218,0 +230,4 @@\n+    static int getMaxReqHeaderSize() {\n+        return maxReqHeadersSize;\n+    }\n+\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ServerConfig.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#if __GNUC__ >= 14 || (defined(__clang_major__) && __clang_major__ >= 17)\n+\n@@ -120,1 +122,3 @@\n-#endif \/* __riscv_v_intrinsic *\/\n+#endif  \/* __riscv_v_intrinsic *\/\n+\n+#endif  \/* check gcc and clang version *\/\n","filename":"src\/jdk.incubator.vector\/linux\/native\/libsleef\/lib\/vector_math_rvv.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Byte128Vector selectFrom(Vector<Byte> v1,\n+                                   Vector<Byte> v2) {\n+        return (Byte128Vector)\n+            super.selectFromTemplate((Byte128Vector) v1, (Byte128Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Byte256Vector selectFrom(Vector<Byte> v1,\n+                                   Vector<Byte> v2) {\n+        return (Byte256Vector)\n+            super.selectFromTemplate((Byte256Vector) v1, (Byte256Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Byte512Vector selectFrom(Vector<Byte> v1,\n+                                   Vector<Byte> v2) {\n+        return (Byte512Vector)\n+            super.selectFromTemplate((Byte512Vector) v1, (Byte512Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Byte64Vector selectFrom(Vector<Byte> v1,\n+                                   Vector<Byte> v2) {\n+        return (Byte64Vector)\n+            super.selectFromTemplate((Byte64Vector) v1, (Byte64Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector selectFrom(Vector<Byte> v1,\n+                                   Vector<Byte> v2) {\n+        return (ByteMaxVector)\n+            super.selectFromTemplate((ByteMaxVector) v1, (ByteMaxVector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -539,0 +539,13 @@\n+    static ByteVector selectFromTwoVectorHelper(Vector<Byte> indexes, Vector<Byte> src1, Vector<Byte> src2) {\n+        int vlen = indexes.length();\n+        byte[] res = new byte[vlen];\n+        byte[] vecPayload1 = ((ByteVector)indexes).vec();\n+        byte[] vecPayload2 = ((ByteVector)src1).vec();\n+        byte[] vecPayload3 = ((ByteVector)src2).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int wrapped_index = VectorIntrinsics.wrapToRange((int)vecPayload1[i], 2 * vlen);\n+            res[i] = wrapped_index >= vlen ? vecPayload3[wrapped_index - vlen] : vecPayload2[wrapped_index];\n+        }\n+        return ((ByteVector)src1).vectorFactory(res);\n+    }\n+\n@@ -2578,0 +2591,16 @@\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ByteVector selectFrom(Vector<Byte> v1, Vector<Byte> v2);\n+\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final ByteVector selectFromTemplate(ByteVector v1, ByteVector v2) {\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), byte.class, length(), this, v1, v2,\n+                                                   (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Double128Vector selectFrom(Vector<Double> v1,\n+                                   Vector<Double> v2) {\n+        return (Double128Vector)\n+            super.selectFromTemplate((Double128Vector) v1, (Double128Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Double256Vector selectFrom(Vector<Double> v1,\n+                                   Vector<Double> v2) {\n+        return (Double256Vector)\n+            super.selectFromTemplate((Double256Vector) v1, (Double256Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Double512Vector selectFrom(Vector<Double> v1,\n+                                   Vector<Double> v2) {\n+        return (Double512Vector)\n+            super.selectFromTemplate((Double512Vector) v1, (Double512Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Double64Vector selectFrom(Vector<Double> v1,\n+                                   Vector<Double> v2) {\n+        return (Double64Vector)\n+            super.selectFromTemplate((Double64Vector) v1, (Double64Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector selectFrom(Vector<Double> v1,\n+                                   Vector<Double> v2) {\n+        return (DoubleMaxVector)\n+            super.selectFromTemplate((DoubleMaxVector) v1, (DoubleMaxVector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -528,0 +528,13 @@\n+    static DoubleVector selectFromTwoVectorHelper(Vector<Double> indexes, Vector<Double> src1, Vector<Double> src2) {\n+        int vlen = indexes.length();\n+        double[] res = new double[vlen];\n+        double[] vecPayload1 = ((DoubleVector)indexes).vec();\n+        double[] vecPayload2 = ((DoubleVector)src1).vec();\n+        double[] vecPayload3 = ((DoubleVector)src2).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int wrapped_index = VectorIntrinsics.wrapToRange((int)vecPayload1[i], 2 * vlen);\n+            res[i] = wrapped_index >= vlen ? vecPayload3[wrapped_index - vlen] : vecPayload2[wrapped_index];\n+        }\n+        return ((DoubleVector)src1).vectorFactory(res);\n+    }\n+\n@@ -2420,0 +2433,16 @@\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    DoubleVector selectFrom(Vector<Double> v1, Vector<Double> v2);\n+\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final DoubleVector selectFromTemplate(DoubleVector v1, DoubleVector v2) {\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), double.class, length(), this, v1, v2,\n+                                                   (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Float128Vector selectFrom(Vector<Float> v1,\n+                                   Vector<Float> v2) {\n+        return (Float128Vector)\n+            super.selectFromTemplate((Float128Vector) v1, (Float128Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Float256Vector selectFrom(Vector<Float> v1,\n+                                   Vector<Float> v2) {\n+        return (Float256Vector)\n+            super.selectFromTemplate((Float256Vector) v1, (Float256Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Float512Vector selectFrom(Vector<Float> v1,\n+                                   Vector<Float> v2) {\n+        return (Float512Vector)\n+            super.selectFromTemplate((Float512Vector) v1, (Float512Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public Float64Vector selectFrom(Vector<Float> v1,\n+                                   Vector<Float> v2) {\n+        return (Float64Vector)\n+            super.selectFromTemplate((Float64Vector) v1, (Float64Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -496,0 +496,7 @@\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector selectFrom(Vector<Float> v1,\n+                                   Vector<Float> v2) {\n+        return (FloatMaxVector)\n+            super.selectFromTemplate((FloatMaxVector) v1, (FloatMaxVector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -528,0 +528,13 @@\n+    static FloatVector selectFromTwoVectorHelper(Vector<Float> indexes, Vector<Float> src1, Vector<Float> src2) {\n+        int vlen = indexes.length();\n+        float[] res = new float[vlen];\n+        float[] vecPayload1 = ((FloatVector)indexes).vec();\n+        float[] vecPayload2 = ((FloatVector)src1).vec();\n+        float[] vecPayload3 = ((FloatVector)src2).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int wrapped_index = VectorIntrinsics.wrapToRange((int)vecPayload1[i], 2 * vlen);\n+            res[i] = wrapped_index >= vlen ? vecPayload3[wrapped_index - vlen] : vecPayload2[wrapped_index];\n+        }\n+        return ((FloatVector)src1).vectorFactory(res);\n+    }\n+\n@@ -2432,0 +2445,16 @@\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    FloatVector selectFrom(Vector<Float> v1, Vector<Float> v2);\n+\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final FloatVector selectFromTemplate(FloatVector v1, FloatVector v2) {\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), float.class, length(), this, v1, v2,\n+                                                   (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Int128Vector selectFrom(Vector<Integer> v1,\n+                                   Vector<Integer> v2) {\n+        return (Int128Vector)\n+            super.selectFromTemplate((Int128Vector) v1, (Int128Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Int256Vector selectFrom(Vector<Integer> v1,\n+                                   Vector<Integer> v2) {\n+        return (Int256Vector)\n+            super.selectFromTemplate((Int256Vector) v1, (Int256Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Int512Vector selectFrom(Vector<Integer> v1,\n+                                   Vector<Integer> v2) {\n+        return (Int512Vector)\n+            super.selectFromTemplate((Int512Vector) v1, (Int512Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Int64Vector selectFrom(Vector<Integer> v1,\n+                                   Vector<Integer> v2) {\n+        return (Int64Vector)\n+            super.selectFromTemplate((Int64Vector) v1, (Int64Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public IntMaxVector selectFrom(Vector<Integer> v1,\n+                                   Vector<Integer> v2) {\n+        return (IntMaxVector)\n+            super.selectFromTemplate((IntMaxVector) v1, (IntMaxVector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -539,0 +539,13 @@\n+    static IntVector selectFromTwoVectorHelper(Vector<Integer> indexes, Vector<Integer> src1, Vector<Integer> src2) {\n+        int vlen = indexes.length();\n+        int[] res = new int[vlen];\n+        int[] vecPayload1 = ((IntVector)indexes).vec();\n+        int[] vecPayload2 = ((IntVector)src1).vec();\n+        int[] vecPayload3 = ((IntVector)src2).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int wrapped_index = VectorIntrinsics.wrapToRange((int)vecPayload1[i], 2 * vlen);\n+            res[i] = wrapped_index >= vlen ? vecPayload3[wrapped_index - vlen] : vecPayload2[wrapped_index];\n+        }\n+        return ((IntVector)src1).vectorFactory(res);\n+    }\n+\n@@ -2563,0 +2576,16 @@\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    IntVector selectFrom(Vector<Integer> v1, Vector<Integer> v2);\n+\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final IntVector selectFromTemplate(IntVector v1, IntVector v2) {\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), int.class, length(), this, v1, v2,\n+                                                   (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -499,0 +499,7 @@\n+    @Override\n+    @ForceInline\n+    public Long128Vector selectFrom(Vector<Long> v1,\n+                                   Vector<Long> v2) {\n+        return (Long128Vector)\n+            super.selectFromTemplate((Long128Vector) v1, (Long128Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -499,0 +499,7 @@\n+    @Override\n+    @ForceInline\n+    public Long256Vector selectFrom(Vector<Long> v1,\n+                                   Vector<Long> v2) {\n+        return (Long256Vector)\n+            super.selectFromTemplate((Long256Vector) v1, (Long256Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -499,0 +499,7 @@\n+    @Override\n+    @ForceInline\n+    public Long512Vector selectFrom(Vector<Long> v1,\n+                                   Vector<Long> v2) {\n+        return (Long512Vector)\n+            super.selectFromTemplate((Long512Vector) v1, (Long512Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -499,0 +499,7 @@\n+    @Override\n+    @ForceInline\n+    public Long64Vector selectFrom(Vector<Long> v1,\n+                                   Vector<Long> v2) {\n+        return (Long64Vector)\n+            super.selectFromTemplate((Long64Vector) v1, (Long64Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -499,0 +499,7 @@\n+    @Override\n+    @ForceInline\n+    public LongMaxVector selectFrom(Vector<Long> v1,\n+                                   Vector<Long> v2) {\n+        return (LongMaxVector)\n+            super.selectFromTemplate((LongMaxVector) v1, (LongMaxVector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -539,0 +539,13 @@\n+    static LongVector selectFromTwoVectorHelper(Vector<Long> indexes, Vector<Long> src1, Vector<Long> src2) {\n+        int vlen = indexes.length();\n+        long[] res = new long[vlen];\n+        long[] vecPayload1 = ((LongVector)indexes).vec();\n+        long[] vecPayload2 = ((LongVector)src1).vec();\n+        long[] vecPayload3 = ((LongVector)src2).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int wrapped_index = VectorIntrinsics.wrapToRange((int)vecPayload1[i], 2 * vlen);\n+            res[i] = wrapped_index >= vlen ? vecPayload3[wrapped_index - vlen] : vecPayload2[wrapped_index];\n+        }\n+        return ((LongVector)src1).vectorFactory(res);\n+    }\n+\n@@ -2429,0 +2442,16 @@\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    LongVector selectFrom(Vector<Long> v1, Vector<Long> v2);\n+\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final LongVector selectFromTemplate(LongVector v1, LongVector v2) {\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), long.class, length(), this, v1, v2,\n+                                                   (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Short128Vector selectFrom(Vector<Short> v1,\n+                                   Vector<Short> v2) {\n+        return (Short128Vector)\n+            super.selectFromTemplate((Short128Vector) v1, (Short128Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Short256Vector selectFrom(Vector<Short> v1,\n+                                   Vector<Short> v2) {\n+        return (Short256Vector)\n+            super.selectFromTemplate((Short256Vector) v1, (Short256Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Short512Vector selectFrom(Vector<Short> v1,\n+                                   Vector<Short> v2) {\n+        return (Short512Vector)\n+            super.selectFromTemplate((Short512Vector) v1, (Short512Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public Short64Vector selectFrom(Vector<Short> v1,\n+                                   Vector<Short> v2) {\n+        return (Short64Vector)\n+            super.selectFromTemplate((Short64Vector) v1, (Short64Vector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -509,0 +509,7 @@\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector selectFrom(Vector<Short> v1,\n+                                   Vector<Short> v2) {\n+        return (ShortMaxVector)\n+            super.selectFromTemplate((ShortMaxVector) v1, (ShortMaxVector) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -539,0 +539,13 @@\n+    static ShortVector selectFromTwoVectorHelper(Vector<Short> indexes, Vector<Short> src1, Vector<Short> src2) {\n+        int vlen = indexes.length();\n+        short[] res = new short[vlen];\n+        short[] vecPayload1 = ((ShortVector)indexes).vec();\n+        short[] vecPayload2 = ((ShortVector)src1).vec();\n+        short[] vecPayload3 = ((ShortVector)src2).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int wrapped_index = VectorIntrinsics.wrapToRange((int)vecPayload1[i], 2 * vlen);\n+            res[i] = wrapped_index >= vlen ? vecPayload3[wrapped_index - vlen] : vecPayload2[wrapped_index];\n+        }\n+        return ((ShortVector)src1).vectorFactory(res);\n+    }\n+\n@@ -2579,0 +2592,16 @@\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ShortVector selectFrom(Vector<Short> v1, Vector<Short> v2);\n+\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final ShortVector selectFromTemplate(ShortVector v1, ShortVector v2) {\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), short.class, length(), this, v1, v2,\n+                                                   (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2759,0 +2759,55 @@\n+    \/**\n+     * Using values stored in the lanes of this vector,\n+     * assemble values stored in the second vector {@code v1}\n+     * and third vector {@code v2}. The second and third vectors thus\n+     * serve as a table, whose elements are selected by indexes\n+     * in this vector.\n+     *\n+     * This is a cross-lane operation that rearranges the lane\n+     * elements of the argument vectors, under the control of\n+     * this vector.\n+     *\n+     * For each lane {@code N} of this vector, and for each lane\n+     * value {@code I=wrapIndex(this.lane(N)} in this vector,\n+     * the output lane {@code N} obtains the value from\n+     * the second vector at lane {@code I} if {@code I < VLENGTH}.\n+     * Otherwise, the output lane {@code N} obtains the value from\n+     * the third vector at lane {@code I - VLENGTH}.\n+     *\n+     * Here, {@code VLENGTH} is the result of {@code this.length()},\n+     * and for integral values {@code wrapIndex} computes the result of\n+     * {@code Math.floorMod(E, 2 * VLENGTH)}, where {@code E} is the index\n+     * to be wrapped. As long as {@code VLENGTH} is a power of two, then the\n+     * result is also equal to {@code E & (2 * VLENGTH - 1)}.\n+     *\n+     * For floating point values {@code wrapIndex} computes\n+     * {@code Math.floorMod(convert(E), 2 * VLENGTH)}, where {@code convert}\n+     * converts the floating point value to an integral value with the same\n+     * number of representational bits - as in converting a double value to\n+     * a long value ({@code (long)doubleVal}), or a float value to an int value\n+     * ({@code (int)floatVal}).\n+     *\n+     * In this way, the result contains only values stored in the\n+     * argument vectors {@code v1} and {@code v2}, but presented in\n+     * an order which depends on the index values in {@code this}.\n+     *\n+     * The result for integral values is the same as the expression\n+     * {@snippet lang=java :\n+     * v1.rearrange(\n+     * this.lanewise(VectorOperators.AND, 2 * VLENGTH - 1).toShuffle(),\n+     * v2)\n+     * }\n+     * when {@code VLENGTH} is a power of two.\n+     * The lane-wise {@code AND} operation results in a vector whose\n+     * elements are in the range {@code [0, 2 * VLENGTH - 1])}. The shuffle\n+     * conversion results in a partially wrapped shuffle whose indexes are\n+     * in the range {@code [-VLENGTH, VLENGTH - 1])}, where exceptional\n+     * indexes are used to select elements in the third vector.\n+     *\n+     * @param v1 the first input vector\n+     * @param v2 the second input vector\n+     * @return the rearrangement of lane elements of {@code v1} and {@code v2}\n+     * @see #rearrange(VectorShuffle,Vector)\n+     *\/\n+    public abstract Vector<E> selectFrom(Vector<E> v1, Vector<E> v2);\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -566,0 +566,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -553,0 +553,13 @@\n+    static $abstractvectortype$ selectFromTwoVectorHelper(Vector<$Boxtype$> indexes, Vector<$Boxtype$> src1, Vector<$Boxtype$> src2) {\n+        int vlen = indexes.length();\n+        $type$[] res = new $type$[vlen];\n+        $type$[] vecPayload1 = (($abstractvectortype$)indexes).vec();\n+        $type$[] vecPayload2 = (($abstractvectortype$)src1).vec();\n+        $type$[] vecPayload3 = (($abstractvectortype$)src2).vec();\n+        for (int i = 0; i < vlen; i++) {\n+            int wrapped_index = VectorIntrinsics.wrapToRange((int)vecPayload1[i], 2 * vlen);\n+            res[i] = wrapped_index >= vlen ? vecPayload3[wrapped_index - vlen] : vecPayload2[wrapped_index];\n+        }\n+        return (($abstractvectortype$)src1).vectorFactory(res);\n+    }\n+\n@@ -2955,0 +2968,16 @@\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    $abstractvectortype$ selectFrom(Vector<$Boxtype$> v1, Vector<$Boxtype$> v2);\n+\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final $abstractvectortype$ selectFromTemplate($abstractvectortype$ v1, $abstractvectortype$ v2) {\n+        return VectorSupport.selectFromTwoVectorOp(getClass(), $type$.class, length(), this, v1, v2,\n+                                                   (vec1, vec2, vec3) -> selectFromTwoVectorHelper(vec1, vec2, vec3));\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -515,0 +515,7 @@\n+    @Override\n+    @ForceInline\n+    public $vectortype$ selectFrom(Vector<$Boxtype$> v1,\n+                                   Vector<$Boxtype$> v2) {\n+        return ($vectortype$)\n+            super.selectFromTemplate(($vectortype$) v1, ($vectortype$) v2);  \/\/ specialize\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2645,1 +2645,1 @@\n-            String name = forWhat.getSimpleName().toString();\n+            var name = forWhat.getSimpleName().toString();\n@@ -2647,6 +2647,5 @@\n-            String leadingNoteKey = \"doclet.RestrictedLeadingNote\";\n-            Content leadingNote =\n-                    contents.getContent(leadingNoteKey, nameCode);\n-            restrictedDiv.add(HtmlTree.SPAN(HtmlStyles.restrictedLabel,\n-                    leadingNote));\n-            Content note1 = contents.getContent(\"doclet.RestrictedTrailingNote1\", nameCode);\n+            var restrictedMethodLink = getRestrictedMethodDocLink();\n+            var leadingNoteKey = \"doclet.RestrictedLeadingNote\";\n+            var leadingNote = contents.getContent(leadingNoteKey, nameCode, restrictedMethodLink);\n+            restrictedDiv.add(HtmlTree.SPAN(HtmlStyles.restrictedLabel, leadingNote));\n+            var note1 = contents.getContent(\"doclet.RestrictedTrailingNote1\", nameCode);\n@@ -2654,1 +2653,1 @@\n-            Content note2 = contents.getContent(\"doclet.RestrictedTrailingNote2\", nameCode);\n+            var note2 = contents.getContent(\"doclet.RestrictedTrailingNote2\", nameCode);\n@@ -2660,0 +2659,13 @@\n+    private Content getRestrictedMethodDocLink() {\n+        var restrictedMethodLabel = contents.getContent(\"doclet.RestrictedMethod\");\n+        var javaLang = utils.elementUtils.getPackageElement(\"java.lang\");\n+        if (utils.isIncluded(javaLang)) {\n+            var restrictedDocPath = pathToRoot\n+                    .resolve(docPaths.forPackage(javaLang))\n+                    .resolve(DocPaths.DOC_FILES)\n+                    .resolve(DocPaths.RESTRICTED_DOC);\n+            return links.createLink(restrictedDocPath, restrictedMethodLabel);\n+        }\n+        return restrictedMethodLabel;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -427,1 +427,2 @@\n-doclet.RestrictedLeadingNote={0} is a restricted method of the Java platform.\n+doclet.RestrictedMethod=restricted method\n+doclet.RestrictedLeadingNote={0} is a {1} of the Java platform.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -166,0 +166,3 @@\n+    \/** The name of the doc-file for restricted methods. *\/\n+    public static final DocPath RESTRICTED_DOC = DocPath.create(\"RestrictedMethods.html\");\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocPaths.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-        int pc = 0;\n+        int[] pcState = {0};\n@@ -97,1 +97,1 @@\n-            for (var coe: attr) {\n+            attr.forEach(coe -> {\n@@ -99,1 +99,2 @@\n-                    for (InstructionDetailWriter w: detailWriters)\n+                    int pc = pcState[0];\n+                    for (InstructionDetailWriter w : detailWriters)\n@@ -102,1 +103,1 @@\n-                    pc += instr.sizeInBytes();\n+                    pcState[0] = pc + instr.sizeInBytes();\n@@ -104,1 +105,1 @@\n-            }\n+            });\n@@ -106,1 +107,1 @@\n-            report(\"error at or after byte \" + pc);\n+            report(\"error at or after address \" + pcState[0] + \": \" + e.getMessage());\n@@ -109,0 +110,1 @@\n+        int pc = pcState[0];\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/CodeWriter.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,1 +118,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n@@ -147,1 +147,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n@@ -177,1 +177,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n@@ -224,1 +224,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n@@ -329,1 +329,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n","filename":"src\/jdk.jdi\/share\/native\/libdt_shmem\/SharedMemoryConnection.c","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n@@ -112,1 +112,1 @@\n-    if ((*env)->ExceptionOccurred(env)) {\n+    if ((*env)->ExceptionCheck(env)) {\n@@ -146,1 +146,1 @@\n-        if ((nameString == NULL) && !(*env)->ExceptionOccurred(env)) {\n+        if ((nameString == NULL) && !(*env)->ExceptionCheck(env)) {\n@@ -193,1 +193,1 @@\n-        if ((*env)->ExceptionOccurred(env)) {\n+        if ((*env)->ExceptionCheck(env)) {\n","filename":"src\/jdk.jdi\/share\/native\/libdt_shmem\/SharedMemoryTransport.c","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -320,1 +320,1 @@\n-                argmap.put(\"dcmd.arg.type\", arginfo.getType());\n+                argmap.put(\"dcmd.arg.type\", sanitiseType(arginfo.getType()));\n@@ -338,0 +338,16 @@\n+    \/\/ Type names that will be published in dcmd.arg.type:\n+    private static final String [] publicTypes = new String [] { \"INT\", \"STRING\", \"BOOLEAN\", \"STRING SET\", \"MEMORY SIZE\", \"NANOTIME\" };\n+\n+    private static final String sanitiseType(String typeName) {\n+        \/\/ For any typeName not in the set to be made public, return \"STRING\".\n+        if (typeName == null) {\n+            return null;\n+        }\n+        for (String t : publicTypes) {\n+            if (typeName.equals(t)) {\n+                return t;\n+            }\n+        }\n+        return \"STRING\";\n+    }\n+\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/DiagnosticCommandImpl.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+import java.time.Duration;\n@@ -53,0 +54,2 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -54,0 +57,1 @@\n+import java.util.stream.IntStream;\n@@ -98,1 +102,1 @@\n-    private static final int MIN_TIMEOUT = 50; \/\/ msec after which there are no retries.\n+    private static final int MIN_TIMEOUT = 0; \/\/ msec after which there are no retries.\n@@ -226,1 +230,4 @@\n-\n+        \/\/ Holder for unfulfilled timeouts left for each server\n+        AtomicLong[] unfulfilledUdpTimeouts = IntStream.range(0, servers.length)\n+                .mapToObj(_ -> new AtomicLong())\n+                .toArray(AtomicLong[]::new);\n@@ -233,2 +240,2 @@\n-            for (int retry = 0; retry < retries; retry++) {\n-\n+            for (int retry = 0; retry <= retries; retry++) {\n+                boolean isLastRetry = retry == retries;\n@@ -240,0 +247,5 @@\n+                    \/\/ unfulfilledServerTimeout is always >= 0\n+                    AtomicLong unfulfilledServerTimeout = unfulfilledUdpTimeouts[i];\n+                    if (isLastRetry && unfulfilledServerTimeout.get() == 0) {\n+                        continue;\n+                    }\n@@ -248,1 +260,1 @@\n-                                                retry, xid);\n+                                retry, xid, unfulfilledServerTimeout, isLastRetry);\n@@ -262,1 +274,6 @@\n-                            int retryTimeout = (timeout * (1 << retry));\n+                            long retryTimeout = Math.clamp(\n+                                    timeout * (1L << (isLastRetry\n+                                            ? retry - 1\n+                                            : retry)),\n+                                    0L, Integer.MAX_VALUE);\n+                            ;\n@@ -304,1 +321,3 @@\n-                        if (caughtException == null) {\n+                        if (caughtException == null || servers.length == 1) {\n+                            \/\/ If there are several servers we continue trying with other\n+                            \/\/ servers, otherwise this exception will be reported\n@@ -306,0 +325,3 @@\n+                        } else {\n+                            \/\/ Best reporting effort\n+                            caughtException.addSuppressed(ex);\n@@ -312,1 +334,4 @@\n-                        if (caughtException == null) {\n+                        if (caughtException instanceof CommunicationException ce) {\n+                            e.addSuppressed(ce);\n+                            caughtException = e;\n+                        } else if (caughtException == null) {\n@@ -330,1 +355,3 @@\n-                        if (caughtException == null) {\n+                        if (caughtException == null || servers.length == 1) {\n+                            \/\/ If there are several servers we continue trying with other\n+                            \/\/ servers, otherwise this exception will be reported\n@@ -332,0 +359,3 @@\n+                        } else {\n+                            \/\/ Best reporting effort\n+                            caughtException.addSuppressed(e);\n@@ -342,2 +372,2 @@\n-        if (caughtException instanceof NamingException) {\n-            throw (NamingException) caughtException;\n+        if (caughtException instanceof NamingException ne) {\n+            throw ne;\n@@ -427,1 +457,3 @@\n-                                     int port, int retry, int xid)\n+                              int port, int retry, int xid,\n+                              AtomicLong unfulfilledTimeout,\n+                              boolean unfulfilledOnly)\n@@ -431,0 +463,20 @@\n+\n+\n+        \/\/ use 1L below to ensure conversion to long and avoid potential\n+        \/\/ integer overflow (timeout is an int).\n+        \/\/ no point in supporting timeout > Integer.MAX_VALUE, clamp if needed\n+        \/\/ timeout remaining after successive 'blockingReceive()'.\n+        long thisIterationTimeout = unfulfilledOnly\n+                ? 0L\n+                : Math.clamp(timeout * (1L << retry), 0L, Integer.MAX_VALUE);\n+\n+        \/\/ Compensate with server's positive unfulfilled timeout.\n+        \/\/ Calling method never supplies zero 'unfulfilledTimeout' when\n+        \/\/ 'unfulfilledOnly' is 'true', therefore 'thisIterationTimeout'\n+        \/\/ will always be a positive number, ie infinite timeout\n+        \/\/ is not possible.\n+        thisIterationTimeout += unfulfilledTimeout.get();\n+\n+        \/\/ Track left timeout for the current retry\n+        long timeoutLeft = thisIterationTimeout;\n+        long start = 0;\n@@ -439,1 +491,0 @@\n-                int pktTimeout = (timeout * (1 << retry));\n@@ -442,2 +493,0 @@\n-                \/\/ timeout remaining after successive 'blockingReceive()'\n-                int timeoutLeft = pktTimeout;\n@@ -446,0 +495,1 @@\n+                start = System.nanoTime();\n@@ -459,3 +509,1 @@\n-                    long start = System.currentTimeMillis();\n-                    gotData = blockingReceive(udpChannel, ipkt, timeoutLeft);\n-                    long end = System.currentTimeMillis();\n+                    gotData = blockingReceive(udpChannel, target, ipkt, timeoutLeft);\n@@ -474,1 +522,3 @@\n-                    timeoutLeft = pktTimeout - ((int) (end - start));\n+                    long elapsedMillis = TimeUnit.NANOSECONDS\n+                                                 .toMillis(System.nanoTime() - start);\n+                    timeoutLeft = thisIterationTimeout - elapsedMillis;\n@@ -480,0 +530,3 @@\n+            long carryoverTimeout = thisIterationTimeout -\n+                    TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n+            unfulfilledTimeout.set(Math.max(0, carryoverTimeout));\n@@ -484,1 +537,2 @@\n-    boolean blockingReceive(DatagramChannel dc, ByteBuffer buffer, long timeout) throws IOException {\n+    boolean blockingReceive(DatagramChannel dc, InetSocketAddress target,\n+                            ByteBuffer buffer, long timeout) throws IOException {\n@@ -494,2 +548,8 @@\n-                dc.receive(buffer);\n-                dataReceived = true;\n+                int before = buffer.position();\n+                var senderAddress = dc.receive(buffer);\n+                \/\/ Empty packets are ignored\n+                dataReceived = target.equals(senderAddress) && buffer.position() > before;\n+            }\n+            \/\/ Avoid contention with Selector.close() if called by a clean-up thread\n+            synchronized (keys) {\n+                keys.clear();\n@@ -497,1 +557,0 @@\n-            keys.clear();\n@@ -753,1 +812,1 @@\n-    private int timeoutLeft;\n+    private long timeoutLeft;\n@@ -755,1 +814,1 @@\n-    Tcp(InetAddress server, int port, int timeout) throws IOException {\n+    Tcp(InetAddress server, int port, long timeout) throws IOException {\n@@ -758,3 +817,8 @@\n-            long start = System.currentTimeMillis();\n-            sock.connect(new InetSocketAddress(server, port), timeout);\n-            timeoutLeft = (int) (timeout - (System.currentTimeMillis() - start));\n+            long start = System.nanoTime();\n+            \/\/ It is safe to cast to int since the value is\n+            \/\/ clamped by the caller\n+            int intTimeout = (int) timeout;\n+            sock.connect(new InetSocketAddress(server, port), intTimeout);\n+            timeoutLeft = Duration.ofMillis(timeout)\n+                    .minus(Duration.ofNanos((System.nanoTime() - start)))\n+                    .toMillis();\n@@ -788,3 +852,4 @@\n-\n-        sock.setSoTimeout(timeoutLeft);\n-        long start = System.currentTimeMillis();\n+        \/\/ It is safe to cast to int since the value is clamped\n+        int intTimeout = (int) timeoutLeft;\n+        sock.setSoTimeout(intTimeout);\n+        long start = System.nanoTime();\n@@ -795,1 +860,2 @@\n-            timeoutLeft -= (int) (System.currentTimeMillis() - start);\n+            timeoutLeft -= TimeUnit.NANOSECONDS.toMillis(\n+                    System.nanoTime() - start);\n","filename":"src\/jdk.naming.dns\/share\/classes\/com\/sun\/jndi\/dns\/DnsClient.java","additions":99,"deletions":33,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-                timeout = val;\n+                timeout = Math.max(val, 0);\n@@ -185,1 +185,1 @@\n-                retries = val;\n+                retries = Math.clamp(val, 1, 30);\n@@ -260,1 +260,1 @@\n-            : Integer.parseInt(val);\n+            : Math.max(Integer.parseInt(val), 0);\n@@ -264,1 +264,1 @@\n-            : Integer.parseInt(val);\n+            : Math.clamp(Integer.parseInt(val), 1, 30);\n","filename":"src\/jdk.naming.dns\/share\/classes\/com\/sun\/jndi\/dns\/DnsContext.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import sun.security.util.HexDumpEncoder;\n+\n@@ -772,1 +772,0 @@\n-                    HexDumpEncoder hd = new HexDumpEncoder();\n@@ -777,4 +776,1 @@\n-                            debug.println(\"EncryptionKey: keyType=\" +\n-                                encKeys[i].getEType() +\n-                                \" keyBytes (hex dump)=\" +\n-                                hd.encodeBuffer(encKeys[i].getBytes()));\n+                            debug.println(encKeys[i].toString());\n@@ -871,1 +867,1 @@\n-                    (\"password is \" + new String(password));\n+                    (\"Get password from shared state\");\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/module\/Krb5LoginModule.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -174,1 +174,0 @@\n-\n@@ -184,0 +183,17 @@\n+TEST_VM_F(NMTVMATreeTest, UseFlagInplace) {\n+  Tree tree;\n+  VMATree::RegionData rd1(si[0], mtTest);\n+  VMATree::RegionData rd2(si[1], mtNone);\n+  tree.reserve_mapping(0, 100, rd1);\n+  tree.commit_mapping(20, 50, rd2, true);\n+  tree.uncommit_mapping(30, 10, rd2);\n+  tree.visit_in_order([&](Node* node) {\n+    if (node->key() != 100) {\n+      EXPECT_EQ(mtTest, node->val().out.mem_tag()) << \"failed at: \" << node->key();\n+      if (node->key() != 20 && node->key() != 40) {\n+        EXPECT_EQ(VMATree::StateType::Reserved, node->val().out.type());\n+      }\n+    }\n+  });\n+}\n+\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -408,0 +408,80 @@\n+#ifndef MAX_PATH\n+#define MAX_PATH    (2 * K)\n+#endif\n+\n+TEST_VM(os, realpath) {\n+  \/\/ POSIX requires that the file exists; Windows tests for a valid drive letter\n+  \/\/ but may or may not test if the file exists. *\/\n+  static const char* nosuchpath = \"\/1234567890123456789\";\n+  static const char* tmppath = \"\/tmp\";\n+\n+  char buffer[MAX_PATH];\n+\n+  \/\/ Test a non-existant path, but provide a short buffer.\n+  errno = 0;\n+  const char* returnedBuffer = os::realpath(nosuchpath, buffer, sizeof(nosuchpath) - 2);\n+  \/\/ Reports ENOENT on Linux, ENAMETOOLONG on Windows.\n+  EXPECT_TRUE(returnedBuffer == nullptr);\n+#ifdef _WINDOWS\n+  EXPECT_TRUE(errno == ENAMETOOLONG);\n+#else\n+  EXPECT_TRUE(errno == ENOENT);\n+#endif\n+\n+  \/\/ Test a non-existant path, but provide an adequate buffer.\n+  errno = 0;\n+  buffer[0] = 0;\n+  returnedBuffer = os::realpath(nosuchpath, buffer, sizeof(nosuchpath) + 3);\n+  \/\/ Reports ENOENT on Linux, may return 0 (and report an error) or buffer on some versions of Windows.\n+#ifdef _WINDOWS\n+  if (returnedBuffer != nullptr) {\n+    EXPECT_TRUE(returnedBuffer == buffer);\n+  } else {\n+    EXPECT_TRUE(errno != 0);\n+  }\n+#else\n+  EXPECT_TRUE(returnedBuffer == nullptr);\n+  EXPECT_TRUE(errno == ENOENT);\n+#endif\n+\n+  \/\/ Test an existing path using a large buffer.\n+  errno = 0;\n+  returnedBuffer = os::realpath(tmppath, buffer, MAX_PATH);\n+  EXPECT_TRUE(returnedBuffer == buffer);\n+\n+  \/\/ Test an existing path using a buffer that is too small on a normal macOS install.\n+  errno = 0;\n+  returnedBuffer = os::realpath(tmppath, buffer, strlen(tmppath) + 3);\n+  \/\/ On MacOS, \/tmp is a symlink to \/private\/tmp, so doesn't fit in a small buffer.\n+#ifndef __APPLE__\n+  EXPECT_TRUE(returnedBuffer == buffer);\n+#else\n+  EXPECT_TRUE(returnedBuffer == nullptr);\n+  EXPECT_TRUE(errno == ENAMETOOLONG);\n+#endif\n+\n+  \/\/ Test an existing path using a buffer that is too small.\n+  errno = 0;\n+  returnedBuffer = os::realpath(tmppath, buffer, strlen(tmppath) - 1);\n+  EXPECT_TRUE(returnedBuffer == nullptr);\n+  EXPECT_TRUE(errno == ENAMETOOLONG);\n+\n+  \/\/ The following tests cause an assert inside os::realpath() in fastdebug mode:\n+#ifndef ASSERT\n+  errno = 0;\n+  returnedBuffer = os::realpath(nullptr, buffer, sizeof(buffer));\n+  EXPECT_TRUE(returnedBuffer == nullptr);\n+  EXPECT_TRUE(errno == EINVAL);\n+\n+  errno = 0;\n+  returnedBuffer = os::realpath(tmppath, nullptr, sizeof(buffer));\n+  EXPECT_TRUE(returnedBuffer == nullptr);\n+  EXPECT_TRUE(errno == EINVAL);\n+\n+  errno = 0;\n+  returnedBuffer = os::realpath(tmppath, buffer, 0);\n+  EXPECT_TRUE(returnedBuffer == nullptr);\n+  EXPECT_TRUE(errno == EINVAL);\n+#endif\n+}\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -363,1 +363,1 @@\n-    auto pretouch = [heap](Thread*, int) {\n+    auto pretouch = [&](Thread*, int) {\n@@ -366,1 +366,1 @@\n-    auto useMemory = [heap](Thread*, int) {\n+    auto useMemory = [&](Thread*, int) {\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-applications\/ctw\/modules\/java_base_2.java 8341831 linux-x64\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-    docker.support \\\n+    container.support \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.ArrayList;\n+\n+\/**\n+  * @test\n+  * @bug 8340313\n+  * @summary Test that concurrent patching of oop immediates is thread-safe in C1.\n+  * @run main\/othervm\/timeout=480 -Xcomp -XX:CompileCommand=compileonly,TestConcurrentPatching::* -XX:TieredStopAtLevel=1 TestConcurrentPatching\n+  *\/\n+\n+class MyClass { }\n+\n+class Holder {\n+    public static final MyClass OBJ1 = null;\n+    public static final MyClass OBJ2 = null;\n+    public static final MyClass OBJ3 = null;\n+    public static final MyClass OBJ4 = null;\n+    public static final MyClass OBJ5 = null;\n+    public static final MyClass OBJ6 = null;\n+    public static final MyClass OBJ7 = null;\n+    public static final MyClass OBJ8 = null;\n+    public static final MyClass OBJ9 = null;\n+    public static final MyClass OBJ10 = null;\n+    public static final MyClass OBJ11 = null;\n+    public static final MyClass OBJ12 = null;\n+    public static final MyClass OBJ13 = null;\n+    public static final MyClass OBJ14 = null;\n+    public static final MyClass OBJ15 = null;\n+    public static final MyClass OBJ16 = null;\n+    public static final MyClass OBJ17 = null;\n+    public static final MyClass OBJ18 = null;\n+    public static final MyClass OBJ19 = null;\n+    public static final MyClass OBJ20 = null;\n+}\n+\n+public class TestConcurrentPatching {\n+    \/\/ Increase to 100_000 for a good chance of reproducing the issue with a single run\n+    static final int ITERATIONS = 1000;\n+\n+    static Object field;\n+\n+    \/\/ 'Holder' class is unloaded on first execution and therefore field\n+    \/\/ accesses require patching when the method is C1 compiled (with -Xcomp).\n+    public static void test() {\n+        field = Holder.OBJ1;\n+        field = Holder.OBJ2;\n+        field = Holder.OBJ3;\n+        field = Holder.OBJ4;\n+        field = Holder.OBJ5;\n+        field = Holder.OBJ6;\n+        field = Holder.OBJ7;\n+        field = Holder.OBJ8;\n+        field = Holder.OBJ9;\n+        field = Holder.OBJ10;\n+        field = Holder.OBJ11;\n+        field = Holder.OBJ12;\n+        field = Holder.OBJ13;\n+        field = Holder.OBJ14;\n+        field = Holder.OBJ15;\n+        field = Holder.OBJ16;\n+        field = Holder.OBJ17;\n+        field = Holder.OBJ18;\n+        field = Holder.OBJ19;\n+        field = Holder.OBJ20;\n+    }\n+\n+    \/\/ Appendix of invokedynamic call sites is unloaded on first execution and\n+    \/\/ therefore requires patching when the method is C1 compiled (with -Xcomp).\n+    public static void testIndy() throws Throwable {\n+          field = (Runnable) () -> { };\n+          field = (Runnable) () -> { };\n+          field = (Runnable) () -> { };\n+          field = (Runnable) () -> { };\n+          field = (Runnable) () -> { };\n+          field = (Runnable) () -> { };\n+          field = (Runnable) () -> { };\n+          field = (Runnable) () -> { };\n+          field = (Runnable) () -> { };\n+          field = (Runnable) () -> { };\n+    }\n+\n+    \/\/ Run 'test' by multiple threads to trigger concurrent patching of field accesses\n+    static void runWithThreads(Method method) {\n+        ArrayList<Thread> threads = new ArrayList<>();\n+        for (int threadIdx = 0; threadIdx < 10; threadIdx++) {\n+            threads.add(new Thread(() -> {\n+                try {\n+                    method.invoke(null);\n+                } catch (Exception e) {\n+                    throw new IllegalStateException(e);\n+                }\n+            }));\n+        }\n+        threads.forEach(Thread::start);\n+        threads.forEach(t -> {\n+            try {\n+                t.join();\n+            } catch (Throwable e) {\n+                throw new IllegalStateException(e);\n+            }\n+        });\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Class<?> thisClass = TestConcurrentPatching.class;\n+        ClassLoader defaultLoader = thisClass.getClassLoader();\n+        URL classesDir = thisClass.getProtectionDomain().getCodeSource().getLocation();\n+\n+        \/\/ Load the test class multiple times with a separate class loader to make sure\n+        \/\/ that the 'Holder' class is unloaded for each compilation of method 'test'\n+        \/\/ and that the appendix of the invokedynamic call site is unloaded for each\n+        \/\/ compilation of method 'testIndy'.\n+        for (int i = 0; i < ITERATIONS; ++i) {\n+            URLClassLoader myLoader = URLClassLoader.newInstance(new URL[] {classesDir}, defaultLoader.getParent());\n+            Class<?> testClass = Class.forName(thisClass.getCanonicalName(), true, myLoader);\n+            runWithThreads(testClass.getDeclaredMethod(\"test\"));\n+            runWithThreads(testClass.getDeclaredMethod(\"testIndy\"));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestConcurrentPatching.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8336726\n+ * @summary Test that post-parse call devirtualization works when call does not have an IO projection.\n+ * @run main\/othervm -XX:-TieredCompilation -Xcomp -XX:CompileCommand=compileonly,TestCallDevirtualizationWithInfiniteLoop::test\n+ *                   TestCallDevirtualizationWithInfiniteLoop\n+ *\/\n+\n+public class TestCallDevirtualizationWithInfiniteLoop {\n+\n+    static interface I {\n+        public void method();\n+    }\n+\n+    static final class A implements I {\n+        @Override\n+        public void method() { };\n+    }\n+\n+    static final class B implements I {\n+        @Override\n+        public void method() { };\n+    }\n+\n+    static final A a = new A();\n+    static final B b = new B();\n+\n+    public static void test(boolean flag) {\n+        \/\/ Avoid executing endless loop\n+        if (flag) {\n+            return;\n+        }\n+\n+        \/\/ We only know after loop opts that the receiver type is B.\n+        I recv = a;\n+        for (int i = 0; i < 3; ++i) {\n+            if (i > 1) {\n+                recv = b;\n+            }\n+        }\n+        \/\/ Post-parse call devirtualization will then convert below\n+        \/\/ virtual call to a static call.\n+        recv.method();\n+\n+        \/\/ Endless loop which does not use IO. As a result the IO\n+        \/\/ projection of the call is removed unexpectedly.\n+        while (true) { }\n+    }\n+\n+    public static void main(String[] args) {\n+        test(true);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestCallDevirtualizationWithInfiniteLoop.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -51,1 +51,1 @@\n-    @IR(counts = { IRNode.NOP, \"1\" })\n+    @IR(counts = { IRNode.NOP, \"<=1\" })\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestPadding.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +39,0 @@\n- * @requires (os.simpleArch == \"x64\") | (os.simpleArch == \"aarch64\")\n@@ -150,2 +150,6 @@\n-    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n-    public static void testByteLong1(byte[] dest, long[] src) {\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ 32-bit: offsets are badly aligned (UNSAFE.ARRAY_BYTE_BASE_OFFSET is 4 byte aligned, but not 8 byte aligned).\n+    \/\/         might get fixed with JDK-8325155.\n+    public static void testByteLong1a(byte[] dest, long[] src) {\n@@ -157,1 +161,34 @@\n-    @Run(test = \"testByteLong1\")\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ 32-bit: address has ConvL2I for cast of long to address, not supported.\n+    public static void testByteLong1b(byte[] dest, long[] src) {\n+        for (int i = 0; i < src.length; i++) {\n+            UNSAFE.putLongUnaligned(dest, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8L * i, src[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    public static void testByteLong1c(byte[] dest, long[] src) {\n+        long base = 64; \/\/ make sure it is big enough and 8 byte aligned (required for 32-bit)\n+        for (int i = 0; i < src.length - 8; i++) {\n+            UNSAFE.putLongUnaligned(dest, base + 8 * i, src[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ 32-bit: address has ConvL2I for cast of long to address, not supported.\n+    public static void testByteLong1d(byte[] dest, long[] src) {\n+        long base = 64; \/\/ make sure it is big enough and 8 byte aligned (required for 32-bit)\n+        for (int i = 0; i < src.length - 8; i++) {\n+            UNSAFE.putLongUnaligned(dest, base + 8L * i, src[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"testByteLong1a\", \"testByteLong1b\", \"testByteLong1c\", \"testByteLong1d\"})\n@@ -159,1 +196,4 @@\n-        runAndVerify(() -> testByteLong1(byteArray, longArray), 0);\n+        runAndVerify(() -> testByteLong1a(byteArray, longArray), 0);\n+        runAndVerify(() -> testByteLong1b(byteArray, longArray), 0);\n+        testByteLong1c(byteArray, longArray);\n+        testByteLong1d(byteArray, longArray);\n@@ -163,2 +203,6 @@\n-    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n-    public static void testByteLong2(byte[] dest, long[] src) {\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ 32-bit: offsets are badly aligned (UNSAFE.ARRAY_BYTE_BASE_OFFSET is 4 byte aligned, but not 8 byte aligned).\n+    \/\/         might get fixed with JDK-8325155.\n+    public static void testByteLong2a(byte[] dest, long[] src) {\n@@ -170,1 +214,12 @@\n-    @Run(test = \"testByteLong2\")\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ 32-bit: address has ConvL2I for cast of long to address, not supported.\n+    public static void testByteLong2b(byte[] dest, long[] src) {\n+        for (int i = 1; i < src.length; i++) {\n+            UNSAFE.putLongUnaligned(dest, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8L * (i - 1), src[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"testByteLong2a\", \"testByteLong2b\"})\n@@ -172,1 +227,2 @@\n-        runAndVerify(() -> testByteLong2(byteArray, longArray), -8);\n+        runAndVerify(() -> testByteLong2a(byteArray, longArray), -8);\n+        runAndVerify(() -> testByteLong2b(byteArray, longArray), -8);\n@@ -176,2 +232,6 @@\n-    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n-    public static void testByteLong3(byte[] dest, long[] src) {\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ 32-bit: offsets are badly aligned (UNSAFE.ARRAY_BYTE_BASE_OFFSET is 4 byte aligned, but not 8 byte aligned).\n+    \/\/         might get fixed with JDK-8325155.\n+    public static void testByteLong3a(byte[] dest, long[] src) {\n@@ -183,1 +243,12 @@\n-    @Run(test = \"testByteLong3\")\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ 32-bit: address has ConvL2I for cast of long to address, not supported.\n+    public static void testByteLong3b(byte[] dest, long[] src) {\n+        for (int i = 0; i < src.length - 1; i++) {\n+            UNSAFE.putLongUnaligned(dest, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8L * (i + 1), src[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"testByteLong3a\", \"testByteLong3b\"})\n@@ -185,1 +256,2 @@\n-        runAndVerify(() -> testByteLong3(byteArray, longArray), 8);\n+        runAndVerify(() -> testByteLong3a(byteArray, longArray), 8);\n+        runAndVerify(() -> testByteLong3b(byteArray, longArray), 8);\n@@ -190,0 +262,2 @@\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n@@ -191,0 +265,2 @@\n+    \/\/ 32-bit: offsets are badly aligned (UNSAFE.ARRAY_BYTE_BASE_OFFSET is 4 byte aligned, but not 8 byte aligned).\n+    \/\/         might get fixed with JDK-8325155.\n@@ -192,1 +268,1 @@\n-    public static void testByteLong4(byte[] dest, long[] src, int start, int stop) {\n+    public static void testByteLong4a(byte[] dest, long[] src, int start, int stop) {\n@@ -198,1 +274,14 @@\n-    @Run(test = \"testByteLong4\")\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"})\n+    \/\/ 32-bit: address has ConvL2I for cast of long to address, not supported.\n+    \/\/ AlignVector cannot guarantee that invar is aligned.\n+    public static void testByteLong4b(byte[] dest, long[] src, int start, int stop) {\n+        for (int i = start; i < stop; i++) {\n+            UNSAFE.putLongUnaligned(dest, 8L * i + baseOffset, src[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"testByteLong4a\", \"testByteLong4b\"})\n@@ -201,1 +290,2 @@\n-        runAndVerify(() -> testByteLong4(byteArray, longArray, 0, size), 0);\n+        runAndVerify(() -> testByteLong4a(byteArray, longArray, 0, size), 0);\n+        runAndVerify(() -> testByteLong4b(byteArray, longArray, 0, size), 0);\n@@ -205,2 +295,6 @@\n-    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n-    public static void testByteLong5(byte[] dest, long[] src, int start, int stop) {\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ 32-bit: offsets are badly aligned (UNSAFE.ARRAY_BYTE_BASE_OFFSET is 4 byte aligned, but not 8 byte aligned).\n+    \/\/         might get fixed with JDK-8325155.\n+    public static void testByteLong5a(byte[] dest, long[] src, int start, int stop) {\n@@ -212,1 +306,12 @@\n-    @Run(test = \"testByteLong5\")\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ 32-bit: address has ConvL2I for cast of long to address, not supported.\n+    public static void testByteLong5b(byte[] dest, long[] src, int start, int stop) {\n+        for (int i = start; i < stop; i++) {\n+            UNSAFE.putLongUnaligned(dest, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8L * (i + baseOffset), src[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"testByteLong5a\", \"testByteLong5b\"})\n@@ -215,1 +320,2 @@\n-        runAndVerify(() -> testByteLong5(byteArray, longArray, 0, size-1), 8);\n+        runAndVerify(() -> testByteLong5a(byteArray, longArray, 0, size-1), 8);\n+        runAndVerify(() -> testByteLong5b(byteArray, longArray, 0, size-1), 8);\n@@ -219,2 +325,6 @@\n-    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n-    public static void testByteByte1(byte[] dest, byte[] src) {\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ 32-bit: offsets are badly aligned (UNSAFE.ARRAY_BYTE_BASE_OFFSET is 4 byte aligned, but not 8 byte aligned).\n+    \/\/         might get fixed with JDK-8325155.\n+    public static void testByteByte1a(byte[] dest, byte[] src) {\n@@ -226,1 +336,12 @@\n-    @Run(test = \"testByteByte1\")\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ 32-bit: address has ConvL2I for cast of long to address, not supported.\n+    public static void testByteByte1b(byte[] dest, byte[] src) {\n+        for (int i = 0; i < src.length \/ 8; i++) {\n+            UNSAFE.putLongUnaligned(dest, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8L * i, UNSAFE.getLongUnaligned(src, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8L * i));\n+        }\n+    }\n+\n+    @Run(test = {\"testByteByte1a\", \"testByteByte1b\"})\n@@ -228,1 +349,2 @@\n-        runAndVerify2(() -> testByteByte1(byteArray, byteArray), 0);\n+        runAndVerify2(() -> testByteByte1a(byteArray, byteArray), 0);\n+        runAndVerify2(() -> testByteByte1b(byteArray, byteArray), 0);\n@@ -232,2 +354,6 @@\n-    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n-    public static void testByteByte2(byte[] dest, byte[] src) {\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ 32-bit: offsets are badly aligned (UNSAFE.ARRAY_BYTE_BASE_OFFSET is 4 byte aligned, but not 8 byte aligned).\n+    \/\/         might get fixed with JDK-8325155.\n+    public static void testByteByte2a(byte[] dest, byte[] src) {\n@@ -239,1 +365,12 @@\n-    @Run(test = \"testByteByte2\")\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ 32-bit: address has ConvL2I for cast of long to address, not supported.\n+    public static void testByteByte2b(byte[] dest, byte[] src) {\n+        for (int i = 1; i < src.length \/ 8; i++) {\n+            UNSAFE.putLongUnaligned(dest, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8L * (i - 1), UNSAFE.getLongUnaligned(src, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8L * i));\n+        }\n+    }\n+\n+    @Run(test = {\"testByteByte2a\", \"testByteByte2b\"})\n@@ -241,1 +378,2 @@\n-        runAndVerify2(() -> testByteByte2(byteArray, byteArray), -8);\n+        runAndVerify2(() -> testByteByte2a(byteArray, byteArray), -8);\n+        runAndVerify2(() -> testByteByte2b(byteArray, byteArray), -8);\n@@ -246,1 +384,1 @@\n-    public static void testByteByte3(byte[] dest, byte[] src) {\n+    public static void testByteByte3a(byte[] dest, byte[] src) {\n@@ -252,1 +390,9 @@\n-    @Run(test = \"testByteByte3\")\n+    @Test\n+    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR })\n+    public static void testByteByte3b(byte[] dest, byte[] src) {\n+        for (int i = 0; i < src.length \/ 8 - 1; i++) {\n+            UNSAFE.putLongUnaligned(dest, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8L * (i + 1), UNSAFE.getLongUnaligned(src, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8L * i));\n+        }\n+    }\n+\n+    @Run(test = {\"testByteByte3a\", \"testByteByte3b\"})\n@@ -254,1 +400,2 @@\n-        runAndVerify2(() -> testByteByte3(byteArray, byteArray), 8);\n+        runAndVerify2(() -> testByteByte3a(byteArray, byteArray), 8);\n+        runAndVerify2(() -> testByteByte3b(byteArray, byteArray), 8);\n@@ -259,1 +406,1 @@\n-    public static void testByteByte4(byte[] dest, byte[] src, int start, int stop) {\n+    public static void testByteByte4a(byte[] dest, byte[] src, int start, int stop) {\n@@ -265,1 +412,9 @@\n-    @Run(test = \"testByteByte4\")\n+    @Test\n+    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR })\n+    public static void testByteByte4b(byte[] dest, byte[] src, int start, int stop) {\n+        for (int i = start; i < stop; i++) {\n+            UNSAFE.putLongUnaligned(dest, 8L * i + baseOffset, UNSAFE.getLongUnaligned(src, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8L * i));\n+        }\n+    }\n+\n+    @Run(test = {\"testByteByte4a\", \"testByteByte4b\"})\n@@ -268,1 +423,2 @@\n-        runAndVerify2(() -> testByteByte4(byteArray, byteArray, 0, size), 0);\n+        runAndVerify2(() -> testByteByte4a(byteArray, byteArray, 0, size), 0);\n+        runAndVerify2(() -> testByteByte4b(byteArray, byteArray, 0, size), 0);\n@@ -273,1 +429,1 @@\n-    public static void testByteByte5(byte[] dest, byte[] src, int start, int stop) {\n+    public static void testByteByte5a(byte[] dest, byte[] src, int start, int stop) {\n@@ -279,1 +435,9 @@\n-    @Run(test = \"testByteByte5\")\n+    @Test\n+    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR })\n+    public static void testByteByte5b(byte[] dest, byte[] src, int start, int stop) {\n+        for (int i = start; i < stop; i++) {\n+            UNSAFE.putLongUnaligned(dest, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8L * (i + baseOffset), UNSAFE.getLongUnaligned(src, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8L * i));\n+        }\n+    }\n+\n+    @Run(test = {\"testByteByte5a\", \"testByteByte5b\"})\n@@ -282,1 +446,2 @@\n-        runAndVerify2(() -> testByteByte5(byteArray, byteArray, 0, size-1), 8);\n+        runAndVerify2(() -> testByteByte5a(byteArray, byteArray, 0, size-1), 8);\n+        runAndVerify2(() -> testByteByte5b(byteArray, byteArray, 0, size-1), 8);\n@@ -286,2 +451,5 @@\n-    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n-    public static void testOffHeapLong1(long dest, long[] src) {\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \"=0\", IRNode.STORE_VECTOR, \"=0\" }) \/\/ temporary\n+    \/\/ @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n+    \/\/ FAILS: adr is CastX2P(dest + 8 * (i + int_con))\n+    \/\/ See: JDK-8331576\n+    public static void testOffHeapLong1a(long dest, long[] src) {\n@@ -293,1 +461,12 @@\n-    @Run(test = \"testOffHeapLong1\")\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \"=0\", IRNode.STORE_VECTOR, \"=0\" }) \/\/ temporary\n+    \/\/ @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n+    \/\/ FAILS: adr is CastX2P(dest + 8L * (i + int_con))\n+    \/\/ See: JDK-8331576\n+    public static void testOffHeapLong1b(long dest, long[] src) {\n+        for (int i = 0; i < src.length; i++) {\n+            UNSAFE.putLongUnaligned(null, dest + 8L * i, src[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"testOffHeapLong1a\", \"testOffHeapLong1b\"})\n@@ -295,1 +474,2 @@\n-        runAndVerify3(() -> testOffHeapLong1(baseOffHeap, longArray), 0);\n+        runAndVerify3(() -> testOffHeapLong1a(baseOffHeap, longArray), 0);\n+        runAndVerify3(() -> testOffHeapLong1b(baseOffHeap, longArray), 0);\n@@ -299,2 +479,5 @@\n-    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n-    public static void testOffHeapLong2(long dest, long[] src) {\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \"=0\", IRNode.STORE_VECTOR, \"=0\" }) \/\/ temporary\n+    \/\/ @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n+    \/\/ FAILS: adr is CastX2P\n+    \/\/ See: JDK-8331576\n+    public static void testOffHeapLong2a(long dest, long[] src) {\n@@ -306,1 +489,12 @@\n-    @Run(test = \"testOffHeapLong2\")\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \"=0\", IRNode.STORE_VECTOR, \"=0\" }) \/\/ temporary\n+    \/\/ @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n+    \/\/ FAILS: adr is CastX2P\n+    \/\/ See: JDK-8331576\n+    public static void testOffHeapLong2b(long dest, long[] src) {\n+        for (int i = 1; i < src.length; i++) {\n+            UNSAFE.putLongUnaligned(null, dest + 8L * (i - 1), src[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"testOffHeapLong2a\", \"testOffHeapLong2b\"})\n@@ -308,1 +502,2 @@\n-        runAndVerify3(() -> testOffHeapLong2(baseOffHeap, longArray), -8);\n+        runAndVerify3(() -> testOffHeapLong2a(baseOffHeap, longArray), -8);\n+        runAndVerify3(() -> testOffHeapLong2b(baseOffHeap, longArray), -8);\n@@ -312,2 +507,5 @@\n-    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n-    public static void testOffHeapLong3(long dest, long[] src) {\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \"=0\", IRNode.STORE_VECTOR, \"=0\" }) \/\/ temporary\n+    \/\/ @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n+    \/\/ FAILS: adr is CastX2P\n+    \/\/ See: JDK-8331576\n+    public static void testOffHeapLong3a(long dest, long[] src) {\n@@ -319,1 +517,12 @@\n-    @Run(test = \"testOffHeapLong3\")\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \"=0\", IRNode.STORE_VECTOR, \"=0\" }) \/\/ temporary\n+    \/\/ @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" })\n+    \/\/ FAILS: adr is CastX2P\n+    \/\/ See: JDK-8331576\n+    public static void testOffHeapLong3b(long dest, long[] src) {\n+        for (int i = 0; i < src.length - 1; i++) {\n+            UNSAFE.putLongUnaligned(null, dest + 8L * (i + 1), src[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"testOffHeapLong3a\", \"testOffHeapLong3b\"})\n@@ -321,1 +530,2 @@\n-        runAndVerify3(() -> testOffHeapLong3(baseOffHeap, longArray), 8);\n+        runAndVerify3(() -> testOffHeapLong3a(baseOffHeap, longArray), 8);\n+        runAndVerify3(() -> testOffHeapLong3b(baseOffHeap, longArray), 8);\n@@ -325,2 +535,5 @@\n-    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n-        applyIf = {\"AlignVector\", \"false\"})\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \"=0\", IRNode.STORE_VECTOR, \"=0\" }) \/\/ temporary\n+    \/\/ @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+    \/\/     applyIf = {\"AlignVector\", \"false\"})\n+    \/\/ FAILS: adr is CastX2P\n+    \/\/ See: JDK-8331576\n@@ -328,1 +541,1 @@\n-    public static void testOffHeapLong4(long dest, long[] src, int start, int stop) {\n+    public static void testOffHeapLong4a(long dest, long[] src, int start, int stop) {\n@@ -334,1 +547,14 @@\n-    @Run(test = \"testOffHeapLong4\")\n+    @Test\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \"=0\", IRNode.STORE_VECTOR, \"=0\" }) \/\/ temporary\n+    \/\/ @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\" },\n+    \/\/     applyIf = {\"AlignVector\", \"false\"})\n+    \/\/ FAILS: adr is CastX2P\n+    \/\/ See: JDK-8331576\n+    \/\/ AlignVector cannot guarantee that invar is aligned.\n+    public static void testOffHeapLong4b(long dest, long[] src, int start, int stop) {\n+        for (int i = start; i < stop; i++) {\n+            UNSAFE.putLongUnaligned(null, dest + 8L * i + baseOffset, src[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"testOffHeapLong4a\", \"testOffHeapLong4b\"})\n@@ -337,1 +563,2 @@\n-        runAndVerify3(() -> testOffHeapLong4(baseOffHeap, longArray, 0, size-1), 8);\n+        runAndVerify3(() -> testOffHeapLong4a(baseOffHeap, longArray, 0, size-1), 8);\n+        runAndVerify3(() -> testOffHeapLong4b(baseOffHeap, longArray, 0, size-1), 8);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java","additions":281,"deletions":54,"binary":false,"changes":335,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests.gc;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import jdk.test.whitebox.gc.GC;\n+\n+import java.lang.ref.*;\n+import java.util.*;\n+\n+\/*\n+ * @test\n+ * @bug 8329597\n+ * @summary Test that Reference.clear intrinsics are properly handled\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @requires vm.compiler2.enabled\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.c2.irTests.gc.ReferenceClearTests\n+\n+ *\/\n+public class ReferenceClearTests {\n+\n+    private static String[] args(String... add) {\n+        List<String> args = new ArrayList<>();\n+\n+         \/\/ Use PerMethodTrapLimit=0 to compile all branches in the intrinsics.\n+        args.add(\"-XX:PerMethodTrapLimit=0\");\n+\n+        \/\/ Forcefully inline all methods to reach the intrinsic code.\n+        args.add(\"-XX:CompileCommand=inline,compiler.c2.irTests.gc.ReferenceClearTests::*\");\n+        args.add(\"-XX:CompileCommand=inline,java.lang.ref.Reference::*\");\n+        args.add(\"-XX:CompileCommand=inline,java.lang.ref.PhantomReference::*\");\n+\n+        \/\/ Mix in test config code.\n+        args.addAll(Arrays.asList(add));\n+\n+        return args.toArray(new String[0]);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework();\n+\n+        int idx = 0;\n+        if (GC.isSelectedErgonomically() && GC.Serial.isSupported()) {\n+            \/\/ Serial does not have SATB\/keep-alive barriers at all.\n+            \/\/ There are inter-generational barriers on stores, but they are\n+            \/\/ folded away for null stores like clear().\n+            framework.addScenarios(new Scenario(idx++, args(\n+                \"-XX:+UseSerialGC\"\n+            )));\n+        }\n+        if (GC.isSelectedErgonomically() && GC.Parallel.isSupported()) {\n+            \/\/ Parallel does not have SATB\/keep-alive barriers at all.\n+            \/\/ There are inter-generational barriers on stores, but they\n+            \/\/ should be folded away for null stores like clear().\n+            framework.addScenarios(new Scenario(idx++, args(\n+                \"-XX:+UseParallelGC\"\n+            )));\n+        }\n+        if (GC.isSelectedErgonomically() && GC.G1.isSupported()) {\n+            \/\/ G1 does not have barriers in C2 IR.\n+            framework.addScenarios(new Scenario(idx++, args(\n+                \"-XX:+UseG1GC\"\n+            )));\n+        }\n+        if (GC.isSelectedErgonomically() && GC.Shenandoah.isSupported()) {\n+            \/\/ Shenandoah has SATB\/keep-alive barriers, but they should not be\n+            \/\/ present clear()-s. There are load-reference barriers, which would\n+            \/\/ confuse the tests, so we enable only SATB barriers.\n+            framework.addScenarios(new Scenario(idx++, args(\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:ShenandoahGCMode=passive\",\n+                \"-XX:+ShenandoahSATBBarrier\",\n+                \"-XX:+UseShenandoahGC\"\n+            )));\n+        }\n+        if (GC.isSelectedErgonomically() && GC.Z.isSupported()) {\n+            \/\/ Z does not have barriers in C2 IR.\n+            framework.addScenarios(new Scenario(idx++, args(\n+                \"-XX:+UseZGC\"\n+            )));\n+        }\n+        framework.start();\n+    }\n+\n+    static final Object REF = new Object();\n+\n+    static final SoftReference<Object> SR = new SoftReference<>(REF);\n+    static final WeakReference<Object> WR = new WeakReference<>(REF);\n+    static final PhantomReference<Object> PR = new PhantomReference<>(REF, null);\n+\n+    \/\/ We assert there is only a single load and a single store of Reference.referent.\n+    \/\/ This serves as signal that no GC barriers are emitted in IR.\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE, \"1\",\n+                   IRNode.LOAD, \"1\" })\n+    public void soft() {\n+        SR.clear();\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE, \"1\",\n+                   IRNode.LOAD, \"1\" })\n+    public void weak() {\n+        WR.clear();\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE, \"1\",\n+                   IRNode.LOAD, \"1\" })\n+    public void phantom() {\n+        PR.clear();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/gc\/ReferenceClearTests.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.compile_framework;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Build a ClassLoader that loads from classpath and {@code classesDir}.\n+ * Helper class that generates a ClassLoader which allows loading classes\n+ * from the classpath (see {@link Utils#getClassPaths()}) and {@code classesDir}.\n+ * <p>\n+ * The CompileFramework compiles all its classes to a specific {@code classesDir},\n+ * and this generated ClassLoader thus can be used to load those classes.\n+ *\/\n+class ClassLoaderBuilder {\n+\n+    \/**\n+     * Build a ClassLoader that loads from classpath and {@code classesDir}.\n+     *\/\n+    public static ClassLoader build(Path classesDir) {\n+        ClassLoader sysLoader = ClassLoader.getSystemClassLoader();\n+\n+        try {\n+            \/\/ Classpath for all included classes (e.g. IR Framework).\n+            \/\/ Get all class paths, convert to URLs.\n+            List<URL> urls = new ArrayList<>();\n+            for (String path : Utils.getClassPaths()) {\n+                urls.add(new File(path).toURI().toURL());\n+            }\n+            \/\/ And add in the compiled classes from this instance of CompileFramework.\n+            urls.add(new File(classesDir.toString()).toURI().toURL());\n+            return URLClassLoader.newInstance(urls.toArray(URL[]::new), sysLoader);\n+        } catch (IOException e) {\n+            throw new CompileFrameworkException(\"IOException while creating ClassLoader\", e);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/compile_framework\/ClassLoaderBuilder.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.compile_framework;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.List;\n+import jdk.test.lib.JDKToolFinder;\n+\n+\/**\n+ * Helper class for compilation of Java and Jasm {@link SourceCode}.\n+ *\/\n+class Compile {\n+    private static final int COMPILE_TIMEOUT = 60;\n+\n+    private static final String JAVA_PATH = JDKToolFinder.getJDKTool(\"java\");\n+    private static final String JAVAC_PATH = JDKToolFinder.getJDKTool(\"javac\");\n+\n+    \/**\n+     * Compile all sources in {@code javaSources}. First write them to the {@code sourceDir},\n+     * then compile them to class-files which are stored in {@code classesDir}.\n+     *\/\n+    public static void compileJavaSources(List<SourceCode> javaSources, Path sourceDir, Path classesDir) {\n+        if (javaSources.isEmpty()) {\n+            Utils.printlnVerbose(\"No java sources to compile.\");\n+            return;\n+        }\n+        Utils.printlnVerbose(\"Compiling Java sources: \" + javaSources.size());\n+\n+        List<Path> javaFilePaths = writeSourcesToFiles(javaSources, sourceDir);\n+        compileJavaFiles(javaFilePaths, classesDir);\n+        Utils.printlnVerbose(\"Java sources compiled.\");\n+    }\n+\n+    \/**\n+     * Compile a list of files (i.e. {@code paths}) using javac and store\n+     * them in {@code classesDir}.\n+     *\/\n+    private static void compileJavaFiles(List<Path> paths, Path classesDir) {\n+        List<String> command = new ArrayList<>();\n+\n+        command.add(JAVAC_PATH);\n+        command.add(\"-classpath\");\n+        \/\/ Note: the backslashes from windows paths must be escaped!\n+        command.add(Utils.getEscapedClassPathAndClassesDir(classesDir));\n+        command.add(\"-d\");\n+        command.add(classesDir.toString());\n+        for (Path path : paths) {\n+            command.add(path.toAbsolutePath().toString());\n+        }\n+\n+        executeCompileCommand(command);\n+    }\n+\n+    \/**\n+     * Compile all sources in {@code jasmSources}. First write them to the {@code sourceDir},\n+     * then compile them to class-files which are stored in {@code classesDir}.\n+     *\/\n+    public static void compileJasmSources(List<SourceCode> jasmSources, Path sourceDir, Path classesDir) {\n+        if (jasmSources.isEmpty()) {\n+            Utils.printlnVerbose(\"No jasm sources to compile.\");\n+            return;\n+        }\n+        Utils.printlnVerbose(\"Compiling jasm sources: \" + jasmSources.size());\n+\n+        List<Path> jasmFilePaths = writeSourcesToFiles(jasmSources, sourceDir);\n+        compileJasmFiles(jasmFilePaths, classesDir);\n+        Utils.printlnVerbose(\"Jasm sources compiled.\");\n+    }\n+\n+    \/**\n+     * Compile a list of files (i.e. {@code paths}) using asmtools jasm and store\n+     * them in {@code classesDir}.\n+     *\/\n+    private static void compileJasmFiles(List<Path> paths, Path classesDir) {\n+        List<String> command = new ArrayList<>();\n+\n+        command.add(JAVA_PATH);\n+        command.add(\"-classpath\");\n+        command.add(getAsmToolsPath());\n+        command.add(\"org.openjdk.asmtools.jasm.Main\");\n+        command.add(\"-d\");\n+        command.add(classesDir.toString());\n+        for (Path path : paths) {\n+            command.add(path.toAbsolutePath().toString());\n+        }\n+\n+        executeCompileCommand(command);\n+    }\n+\n+    \/**\n+     * Get the path of asmtools, which is shipped with JTREG.\n+     *\/\n+    private static String getAsmToolsPath() {\n+        for (String path : Utils.getClassPaths()) {\n+            if (path.endsWith(\"jtreg.jar\")) {\n+                File jtreg = new File(path);\n+                File dir = jtreg.getAbsoluteFile().getParentFile();\n+                File asmtools = new File(dir, \"asmtools.jar\");\n+                if (!asmtools.exists()) {\n+                    throw new InternalCompileFrameworkException(\"Found jtreg.jar in classpath, but could not find asmtools.jar\");\n+                }\n+                return asmtools.getAbsolutePath();\n+            }\n+        }\n+        throw new InternalCompileFrameworkException(\"Could not find asmtools because could not find jtreg.jar in classpath\");\n+    }\n+\n+    private static void writeCodeToFile(String code, Path path) {\n+        Utils.printlnVerbose(\"File: \" + path);\n+\n+        \/\/ Ensure directory of the file exists.\n+        Path dir = path.getParent();\n+        try {\n+            Files.createDirectories(dir);\n+        } catch (Exception e) {\n+            throw new CompileFrameworkException(\"Could not create directory: \" + dir, e);\n+        }\n+\n+        \/\/ Write to file.\n+        try (BufferedWriter writer = Files.newBufferedWriter(path)) {\n+            writer.write(code);\n+        } catch (Exception e) {\n+            throw new CompileFrameworkException(\"Could not write file: \" + path, e);\n+        }\n+    }\n+\n+    \/**\n+     * Write each source in {@code sources} to a file inside {@code sourceDir}.\n+     *\/\n+    private static List<Path> writeSourcesToFiles(List<SourceCode> sources, Path sourceDir) {\n+        List<Path> storedFiles = new ArrayList<>();\n+        for (SourceCode sourceCode : sources) {\n+            Path path = sourceDir.resolve(sourceCode.filePathName());\n+            writeCodeToFile(sourceCode.code(), path);\n+            storedFiles.add(path);\n+        }\n+        return storedFiles;\n+    }\n+\n+    \/**\n+     * Execute a given compilation, given as a {@code command}.\n+     *\/\n+    private static void executeCompileCommand(List<String> command) {\n+        Utils.printlnVerbose(\"Compile command: \" + String.join(\" \", command));\n+\n+        ProcessBuilder builder = new ProcessBuilder(command);\n+        builder.redirectErrorStream(true);\n+\n+        String output;\n+        int exitCode;\n+        try {\n+            Process process = builder.start();\n+            boolean exited = process.waitFor(COMPILE_TIMEOUT, TimeUnit.SECONDS);\n+            if (!exited) {\n+                process.destroyForcibly();\n+                System.out.println(\"Timeout: compile command: \" + String.join(\" \", command));\n+                throw new InternalCompileFrameworkException(\"Process timeout: compilation took too long.\");\n+            }\n+            output = new String(process.getInputStream().readAllBytes(), StandardCharsets.UTF_8);\n+            exitCode = process.exitValue();\n+        } catch (IOException e) {\n+            throw new InternalCompileFrameworkException(\"IOException during compilation\", e);\n+        } catch (InterruptedException e) {\n+            throw new CompileFrameworkException(\"InterruptedException during compilation\", e);\n+        }\n+\n+        if (exitCode != 0 || !output.isEmpty()) {\n+            System.err.println(\"Compilation failed.\");\n+            System.err.println(\"Exit code: \" + exitCode);\n+            System.err.println(\"Output: '\" + output + \"'\");\n+            throw new CompileFrameworkException(\"Compilation failed.\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/compile_framework\/Compile.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.compile_framework;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * This is the entry-point for the Compile Framework. Its purpose it to allow\n+ * compilation and execution of Java and Jasm sources generated at runtime.\n+ *\n+ * <p> Please reference the README.md for more details and examples.\n+ *\/\n+public class CompileFramework {\n+    private final List<SourceCode> javaSources = new ArrayList<>();\n+    private final List<SourceCode> jasmSources = new ArrayList<>();\n+    private final Path sourceDir = Utils.makeUniqueDir(\"compile-framework-sources-\");\n+    private final Path classesDir = Utils.makeUniqueDir(\"compile-framework-classes-\");\n+    private ClassLoader classLoader;\n+\n+    \/**\n+     * Set up a new Compile Framework instance, for a new compilation unit.\n+     *\/\n+    public CompileFramework() {}\n+\n+    \/**\n+     * Add a Java source to the compilation.\n+     *\n+     * @param className Class name of the class (e.g. \"{@code p.xyz.YXZ}\").\n+     * @param code Java code for the class, in the form of a {@link String}.\n+     *\/\n+    public void addJavaSourceCode(String className, String code) {\n+        javaSources.add(new SourceCode(className, \"java\", code));\n+    }\n+\n+    \/**\n+     * Add a Jasm source to the compilation.\n+     *\n+     * @param className Class name of the class (e.g. \"{@code p.xyz.YXZ}\").\n+     * @param code Jasm code for the class, in the form of a {@link String}.\n+     *\/\n+    public void addJasmSourceCode(String className, String code) {\n+        jasmSources.add(new SourceCode(className, \"jasm\", code));\n+    }\n+\n+    \/**\n+     * Compile all sources: store the sources to the {@link sourceDir} directory, compile\n+     * Java and Jasm sources and store the generated class-files in the {@link classesDir}\n+     * directory.\n+     *\/\n+    public void compile() {\n+        if (classLoader != null) {\n+            throw new CompileFrameworkException(\"Cannot compile twice!\");\n+        }\n+\n+        Utils.printlnVerbose(\"------------------ CompileFramework: SourceCode -------------------\");\n+        Utils.printlnVerbose(sourceCodesAsString(jasmSources));\n+        Utils.printlnVerbose(sourceCodesAsString(javaSources));\n+\n+        System.out.println(\"------------------ CompileFramework: Compilation ------------------\");\n+        System.out.println(\"Source directory: \" + sourceDir);\n+        System.out.println(\"Classes directory: \" + classesDir);\n+\n+        Compile.compileJasmSources(jasmSources, sourceDir, classesDir);\n+        Compile.compileJavaSources(javaSources, sourceDir, classesDir);\n+        classLoader = ClassLoaderBuilder.build(classesDir);\n+    }\n+\n+    private static String sourceCodesAsString(List<SourceCode> sourceCodes) {\n+        StringBuilder builder = new StringBuilder();\n+        for (SourceCode sourceCode : sourceCodes) {\n+            builder.append(\"SourceCode: \").append(sourceCode.filePathName()).append(System.lineSeparator());\n+            builder.append(sourceCode.code()).append(System.lineSeparator());\n+        }\n+        return builder.toString();\n+    }\n+\n+    \/**\n+     * Access a class from the compiled code.\n+     *\n+     * @param name Name of the class to be retrieved.\n+     * @return The class corresponding to the {@code name}.\n+     *\/\n+    public Class<?> getClass(String name) {\n+        try {\n+            return Class.forName(name, true, classLoader);\n+        } catch (ClassNotFoundException e) {\n+            throw new CompileFrameworkException(\"Class not found:\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Invoke a static method from the compiled code.\n+     *\n+     * @param className Class name of a compiled class.\n+     * @param methodName Method name of the class.\n+     * @param args List of arguments for the method invocation.\n+     * @return Return value from the invocation.\n+     *\/\n+    public Object invoke(String className, String methodName, Object[] args) {\n+        Method method = findMethod(className, methodName);\n+\n+        try {\n+            return method.invoke(null, args);\n+        } catch (IllegalAccessException e) {\n+            throw new CompileFrameworkException(\"Illegal access:\", e);\n+        } catch (InvocationTargetException e) {\n+            throw new CompileFrameworkException(\"Invocation target:\", e);\n+        }\n+    }\n+\n+    private Method findMethod(String className, String methodName) {\n+        Class<?> c = getClass(className);\n+        Method[] methods = c.getDeclaredMethods();\n+        Method method = null;\n+\n+        for (Method m : methods) {\n+            if (m.getName().equals(methodName)) {\n+                if (method != null) {\n+                  throw new CompileFrameworkException(\"Method name \\\"\" + methodName + \"\\\" not unique in class \\n\" + className + \"\\\".\");\n+                }\n+                method = m;\n+            }\n+        }\n+\n+        if (method == null) {\n+            throw new CompileFrameworkException(\"Method \\\"\" + methodName + \"\\\" not found in class \\n\" + className + \"\\\".\");\n+        }\n+\n+        return method;\n+    }\n+\n+    \/**\n+     * Returns the classpath appended with the {@link classesDir}, where\n+     * the compiled classes are stored. This enables another VM to load\n+     * the compiled classes. Note, the string is already backslash escaped,\n+     * so that Windows paths which use backslashes can be used directly\n+     * as strings.\n+     *\n+     * @return Classpath appended with the path to the compiled classes.\n+     *\/\n+    public String getEscapedClassPathOfCompiledClasses() {\n+        return Utils.getEscapedClassPathAndClassesDir(classesDir);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/compile_framework\/CompileFramework.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.compile_framework;\n+\n+\/**\n+ * Exception thrown in the Compilation Framework. Most likely, the user is responsible for the failure.\n+ *\/\n+public class CompileFrameworkException extends RuntimeException {\n+    public CompileFrameworkException(String message) {\n+        super(\"Exception in Compile Framework:\" + System.lineSeparator() + message);\n+    }\n+\n+    public CompileFrameworkException(String message, Throwable e) {\n+        super(\"Exception in Compile Framework:\" + System.lineSeparator() + message, e);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/compile_framework\/CompileFrameworkException.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.compile_framework;\n+\n+\/**\n+ * Internal exception thrown in Compilation Framework. Most likely, this is due to a bug in the CompileFramework.\n+ *\/\n+public class InternalCompileFrameworkException extends RuntimeException {\n+    public InternalCompileFrameworkException(String message) {\n+        super(\"Internal exception in Compile Framework, please file a bug:\" + System.lineSeparator() + message);\n+    }\n+\n+    public InternalCompileFrameworkException(String message, Throwable e) {\n+        super(\"Internal exception in Compile Framework, please file a bug:\" + System.lineSeparator() + message, e);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/compile_framework\/InternalCompileFrameworkException.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+# Compile Framework\n+The Compile Framework allows the compilation and execution of Java and Jasm sources, which are generated at runtime.\n+\n+## Motivation\n+We want to be able to generate Java and Jasm source code in the form of Strings at runtime, then compile them, load the classes and invoke some methods. This allows us to write more elaborate tests. For example small dedicated fuzzers that are targetted at some specific compiler optimization.\n+\n+This is more powerful than hand-written tests, as we can generalize tests and cover more examples. It can also be better than a script-generated test: those are static and often the script is not integrated with the generated test. Another limitation of a generator script is that it is only run once, creating fixed static tests. Compilation at runtime allows us to randomly generate tests each time.\n+\n+Of course we could compile at runtime without this framework, but it abstracts away the complexity of compilation, and allows the test-writer to focus on the generation of the source code.\n+\n+## How to Use the Compile Framework\n+\n+Please reference the examples found in [examples](..\/..\/..\/testlibrary_tests\/compile_framework\/examples\/). Some basic tests can be found in [tests](..\/..\/..\/testlibrary_tests\/compile_framework\/tests\/).\n+\n+Here a very simple example:\n+\n+    \/\/ Create a new CompileFramework instance.\n+    CompileFramework compileFramework = new CompileFramework();\n+\n+    \/\/ Add a java source file.\n+    compileFramework.addJavaSourceCode(\"XYZ\", \"<your XYZ definition string>\");\n+\n+    \/\/ Compile the source file.\n+    compileFramework.compile();\n+\n+    \/\/ Object returnValue = XYZ.test(5);\n+    Object returnValue = compileFramework.invoke(\"XYZ\", \"test\", new Object[] {5});\n+\n+### Creating a new Compile Framework Instance\n+\n+First, one must create a `new CompileFramework()`, which creates two directories: a sources and a classes directory (see `sourcesDir` and `classesDir` in [CompileFramework](.\/CompileFramework.java)). The sources directory is where all the sources are placed by the Compile Framework, and the classes directory is where all the compiled classes are placed by the Compile Framework.\n+\n+The Compile Framework prints the names of the directories, they are subdirectories of the JTREG scratch directory `JTWork\/scratch`.\n+\n+### Adding Sources to the Compilation\n+\n+Java and Jasm sources can be added to the compilation using `compileFramework.addJavaSourceCode()` and `compileFramework.addJasmSourceCode()`. The source classes can depend on each other, and they can also use the IR Framework ([IRFrameworkJavaExample](..\/..\/..\/testlibrary_tests\/compile_framework\/examples\/IRFrameworkJavaExample.java)).\n+\n+When using the IR Framework, or any other library that needs to be compiled, it can be necessary to explicitly let JTREG compile that library. For example with `@compile ..\/..\/..\/compiler\/lib\/ir_framework\/TestFramework.java`. Otherwise, the corresponding class files may not be available, and a corresponding failure will be encounter at class loading.\n+\n+### Compiling\n+\n+All sources are compiled with `compileFramework.compile()`. First, the sources are stored to the sources directory, then compiled, and then the class-files stored in the classes directory. The respective directory names are printed, so that the user can easily access the generated files for debugging.\n+\n+### Interacting with the Compiled Code\n+\n+The compiled code is then loaded with a `ClassLoader`. The classes can be accessed directly with `compileFramework.getClass(name)`. Specific methods can also directly be invoked with `compileFramework.invoke()`.\n+\n+Should one require the modified classpath that includes the compiled classes, this is available with `compileFramework.getEscapedClassPathOfCompiledClasses()`. This can be necessary if the test launches any other VMs that also access the compiled classes. This is for example necessary when using the IR Framework.\n+\n+### Running the Compiled Code in a New VM\n+\n+One can also run the compiled code in a new VM. For this, one has to set the classpath with `compileFramework.getEscapedClassPathOfCompiledClasses()` ([RunWithFlagsExample](..\/..\/..\/testlibrary_tests\/compile_framework\/examples\/RunWithFlagsExample.java))\n+\n+### Verbose Printing\n+\n+For debugging purposes, one can enable verbose printing, with `-DCompileFrameworkVerbose=true`.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/compile_framework\/README.md","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.compile_framework;\n+\n+\/**\n+ * This class represents the source code of a specific class.\n+ *\/\n+record SourceCode(String className, String extension, String code) {\n+    public String filePathName() {\n+        StringBuilder builder = new StringBuilder();\n+        builder.append(className.replace('.','\/')).append(\".\").append(extension);\n+        return builder.toString();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/compile_framework\/SourceCode.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.compile_framework;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.nio.file.Path;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Utility class, with many helper methods for the Compile Framework.\n+ *\/\n+class Utils {\n+    private static final boolean VERBOSE = Boolean.getBoolean(\"CompileFrameworkVerbose\");\n+\n+    \/**\n+     * Verbose printing, enabled with {@code -DCompileFrameworkVerbose=true}.\n+     *\/\n+    public static void printlnVerbose(String s) {\n+        if (VERBOSE) {\n+            System.out.println(s);\n+        }\n+    }\n+\n+    \/**\n+     * Create a temporary directory with a unique name to avoid collisions\n+     * with multi-threading. Used to create the sources and classes directories. Since they\n+     * are unique even across threads, the Compile Framework is multi-threading safe, i.e.\n+     * it does not have collisions if two instances generate classes with the same name.\n+     *\/\n+    public static Path makeUniqueDir(String prefix) {\n+        try {\n+            return Files.createTempDirectory(Paths.get(\".\"), prefix);\n+        } catch (Exception e) {\n+            throw new InternalCompileFrameworkException(\"Could not set up temporary directory\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Get all paths in the classpath.\n+     *\/\n+    public static String[] getClassPaths() {\n+        String separator = File.pathSeparator;\n+        return System.getProperty(\"java.class.path\").split(separator);\n+    }\n+\n+    \/**\n+     * Return the classpath, appended with the {@code classesDir}.\n+     *\/\n+    public static String getEscapedClassPathAndClassesDir(Path classesDir) {\n+        String cp = System.getProperty(\"java.class.path\") +\n+                    File.pathSeparator +\n+                    classesDir.toAbsolutePath();\n+        \/\/ Escape the backslash for Windows paths. We are using the path in the\n+        \/\/ command-line and Java code, so we always want it to be escaped.\n+        return cp.replace(\"\\\\\", \"\\\\\\\\\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/compile_framework\/Utils.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -122,7 +122,7 @@\n-    private static final String TYPE_BYTE   = \"byte\";\n-    private static final String TYPE_CHAR   = \"char\";\n-    private static final String TYPE_SHORT  = \"short\";\n-    private static final String TYPE_INT    = \"int\";\n-    private static final String TYPE_LONG   = \"long\";\n-    private static final String TYPE_FLOAT  = \"float\";\n-    private static final String TYPE_DOUBLE = \"double\";\n+    private static final String TYPE_BYTE   = \"B\";\n+    private static final String TYPE_CHAR   = \"C\";\n+    private static final String TYPE_SHORT  = \"S\";\n+    private static final String TYPE_INT    = \"I\";\n+    private static final String TYPE_LONG   = \"J\";\n+    private static final String TYPE_FLOAT  = \"F\";\n+    private static final String TYPE_DOUBLE = \"D\";\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,2 +136,1 @@\n-        return nodeRegex.replaceAll(IRNode.IS_REPLACED,\n-                                    \"vector[A-Za-z]\\\\\\\\[\" + sizeRegex + \"\\\\\\\\]:\\\\\\\\{\" + type + \"\\\\\\\\}\");\n+        return nodeRegex.replaceAll(IRNode.IS_REPLACED, \"vector[A-Za-z]<\" + type + \",\" + sizeRegex + \">\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/checkattribute\/parsing\/RawIRNode.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1366,1 +1366,1 @@\n-            int adr = UNSAFE.ARRAY_LONG_BASE_OFFSET + 8 * i;\n+            long adr = UNSAFE.ARRAY_LONG_BASE_OFFSET + 8L * i;\n@@ -1378,1 +1378,1 @@\n-            int adr = UNSAFE.ARRAY_LONG_BASE_OFFSET + 8 * i + 1;\n+            long adr = UNSAFE.ARRAY_LONG_BASE_OFFSET + 8L * i + 1;\n@@ -1395,1 +1395,1 @@\n-            int adr = UNSAFE.ARRAY_LONG_BASE_OFFSET + 8 * i;\n+            long adr = UNSAFE.ARRAY_LONG_BASE_OFFSET + 8L * i;\n@@ -1425,1 +1425,1 @@\n-            int adr = UNSAFE.ARRAY_LONG_BASE_OFFSET + 8 * i + 1;\n+            long adr = UNSAFE.ARRAY_LONG_BASE_OFFSET + 8L * i + 1;\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAlignVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1093,2 +1093,2 @@\n-        int scale  = scale_con();\n-        int offset = offset1_con_or_var();\n+        long scale  = scale_con();\n+        long offset = offset1_con_or_var();\n@@ -1097,1 +1097,1 @@\n-            int adr = UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset + i * scale;\n+            long adr = UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset + i * scale;\n@@ -1108,4 +1108,4 @@\n-        int scale  = scale_con();\n-        int offset1 = offset1_con_or_var();\n-        int offset2 = offset2_con_or_var();\n-        int offset3 = offset3_con_or_var();\n+        long scale  = scale_con();\n+        long offset1 = offset1_con_or_var();\n+        long offset2 = offset2_con_or_var();\n+        long offset3 = offset3_con_or_var();\n@@ -1118,3 +1118,3 @@\n-            int adr1 = UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset1 + i * scale;\n-            int adr2 = UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset2 + i * scale;\n-            int adr3 = UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset3 + i * scale;\n+            long adr1 = UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset1 + i * scale;\n+            long adr2 = UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset2 + i * scale;\n+            long adr3 = UNSAFE.ARRAY_BYTE_BASE_OFFSET + offset3 + i * scale;\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAlignVectorFuzzer.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -175,4 +175,4 @@\n-            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0, dataIa[i+0] + 1);\n-            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4, dataIa[i+1] + 1);\n-            dataIb[i+0] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0);\n-            dataIb[i+1] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4);\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 0, dataIa[i+0] + 1);\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 4, dataIa[i+1] + 1);\n+            dataIb[i+0] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 0);\n+            dataIb[i+1] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 4);\n@@ -251,4 +251,4 @@\n-            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0, dataIa[i+0] + 1); \/\/ A\n-            dataIb[i+0] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0); \/\/ X\n-            dataIb[i+1] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4); \/\/ Y\n-            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4, dataIa[i+1] + 1); \/\/ B\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 0, dataIa[i+0] + 1); \/\/ A\n+            dataIb[i+0] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 0); \/\/ X\n+            dataIb[i+1] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 4); \/\/ Y\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 4, dataIa[i+1] + 1); \/\/ B\n@@ -278,12 +278,12 @@\n-            int v00 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0) + 3;\n-            int v01 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4) + 3;\n-            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0, v00);\n-            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4, v01);\n-            int v10 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0) * 45;\n-            int v11 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4) * 45;\n-            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0, v10);\n-            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4, v11);\n-            float v20 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0) + 0.55f;\n-            float v21 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4) + 0.55f;\n-            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0, v20);\n-            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4, v21);\n+            int v00 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 0) + 3;\n+            int v01 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 4) + 3;\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 0, v00);\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 4, v01);\n+            int v10 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 0) * 45;\n+            int v11 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 4) * 45;\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 0, v10);\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 4, v11);\n+            float v20 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 0) + 0.55f;\n+            float v21 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 4) + 0.55f;\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 0, v20);\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 4, v21);\n@@ -310,12 +310,12 @@\n-            int v00 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0) + 3;\n-            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0, v00);\n-            int v10 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0) * 45;\n-            int v11 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4) * 45;\n-            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0, v10);\n-            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4, v11);\n-            float v20 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0) + 0.55f;\n-            float v21 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4) + 0.55f;\n-            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0, v20);\n-            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4, v21);\n-            int v01 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4) + 3; \/\/ moved down\n-            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4, v01);\n+            int v00 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 0) + 3;\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 0, v00);\n+            int v10 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 0) * 45;\n+            int v11 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 4) * 45;\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 0, v10);\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 4, v11);\n+            float v20 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 0) + 0.55f;\n+            float v21 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 4) + 0.55f;\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 0, v20);\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 4, v21);\n+            int v01 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 4) + 3; \/\/ moved down\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 4, v01);\n@@ -343,8 +343,8 @@\n-            int v00 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0) + 3;\n-            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0, v00);\n-            int v10 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0) * 45;\n-            int v11 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4) * 45;\n-            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0, v10);\n-            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4, v11);\n-            int v01 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4) + 3;\n-            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4, v01);\n+            int v00 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 0) + 3;\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 0, v00);\n+            int v10 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 0) * 45;\n+            int v11 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 4) * 45;\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 0, v10);\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 4, v11);\n+            int v01 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 4) + 3;\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 4, v01);\n@@ -352,4 +352,4 @@\n-            float v20 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0) + 0.55f;\n-            float v21 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4) + 0.55f;\n-            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0, v20);\n-            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4, v21);\n+            float v20 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 0) + 0.55f;\n+            float v21 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 4) + 0.55f;\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 0, v20);\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 4, v21);\n@@ -376,4 +376,4 @@\n-            float v20 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0) + 0.55f;\n-            float v21 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4) + 0.55f;\n-            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0, v20);\n-            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4, v21);\n+            float v20 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 0) + 0.55f;\n+            float v21 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 4) + 0.55f;\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 0, v20);\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 4, v21);\n@@ -381,8 +381,8 @@\n-            int v00 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0) + 3;\n-            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0, v00);\n-            int v10 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0) * 45;\n-            int v11 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4) * 45;\n-            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0, v10);\n-            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4, v11);\n-            int v01 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4) + 3;\n-            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4, v01);\n+            int v00 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 0) + 3;\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 0, v00);\n+            int v10 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 0) * 45;\n+            int v11 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 4) * 45;\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 0, v10);\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 4, v11);\n+            int v01 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 4) + 3;\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 4, v01);\n@@ -426,12 +426,12 @@\n-            int v00 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0) + 3; \/\/ A\n-            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0, v00);\n-            int v10 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0) * 45; \/\/ R: constant mismatch\n-            int v11 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4) + 43; \/\/ S\n-            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0, v10);\n-            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4, v11);\n-            float v20 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0) + 0.55f; \/\/ U\n-            float v21 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4) + 0.55f; \/\/ V\n-            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0, v20);\n-            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4, v21);\n-            int v01 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4) + 3; \/\/ B: moved down\n-            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4, v01);\n+            int v00 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 0) + 3; \/\/ A\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 0, v00);\n+            int v10 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 0) * 45; \/\/ R: constant mismatch\n+            int v11 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 4) + 43; \/\/ S\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 0, v10);\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 4, v11);\n+            float v20 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 0) + 0.55f; \/\/ U\n+            float v21 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 4) + 0.55f; \/\/ V\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 0, v20);\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 4, v21);\n+            int v01 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 4) + 3; \/\/ B: moved down\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 4, v01);\n@@ -466,2 +466,2 @@\n-            int datav = unsafe.getInt(data, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i);\n-            int goldv = unsafe.getInt(gold, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i);\n+            int datav = unsafe.getInt(data, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i);\n+            int goldv = unsafe.getInt(gold, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i);\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestIndependentPacksWithCyclicDependency.java","additions":70,"deletions":70,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -61,12 +61,12 @@\n-            int v00 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0) + 3;\n-            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0, v00);\n-            int v10 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0) * 45;\n-            int v11 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4) + 43;\n-            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0, v10);\n-            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4, v11);\n-            float v20 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0) + 0.55f;\n-            float v21 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4) + 0.55f;\n-            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0, v20);\n-            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4, v21);\n-            int v01 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4) + 3; \/\/ moved down\n-            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4, v01);\n+            int v00 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 0) + 3;\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 0, v00);\n+            int v10 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 0) * 45;\n+            int v11 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 4) + 43;\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 0, v10);\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 4, v11);\n+            float v20 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 0) + 0.55f;\n+            float v21 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4L * i + 4) + 0.55f;\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 0, v20);\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 4, v21);\n+            int v01 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 4) + 3; \/\/ moved down\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 4, v01);\n@@ -86,2 +86,2 @@\n-            int datav = unsafe.getInt(data, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i);\n-            int goldv = unsafe.getInt(gold, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i);\n+            int datav = unsafe.getInt(data, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i);\n+            int goldv = unsafe.getInt(gold, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i);\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestIndependentPacksWithCyclicDependency2.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -127,4 +127,4 @@\n-            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0, dataIa[i+0] + 1);  \/\/ A +1\n-            dataIb[i+0] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0);  \/\/ X\n-            dataIb[i+1] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4);  \/\/ Y\n-            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4, dataIa[i+1] * 11); \/\/ B *11\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 0, dataIa[i+0] + 1);  \/\/ A +1\n+            dataIb[i+0] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 0);  \/\/ X\n+            dataIb[i+1] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4L * i + 4);  \/\/ Y\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4L * i + 4, dataIa[i+1] * 11); \/\/ B *11\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestScheduleReordersScalarMemops.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/DockerBasicTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/ShareTmpDir.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestCPUAwareness.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestCPUSets.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestContainerInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @requires (docker.support & os.maxMemory >= 2g)\n+ * @requires (container.support & os.maxMemory >= 2g)\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJFREvents.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJFRNetworkEvents.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJFRWithJMX.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJcmd.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJcmdWithSideCar.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +32,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestLimitsUpdating.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMemoryAwareness.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMisc.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestPids.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc;\n+\n+\/* @test TestObjectAlignmentCardSize.java\n+ * @summary Test to check correct handling of ObjectAlignmentInBytes and GCCardSizeInBytes combinations\n+ * @requires vm.gc != \"Z\"\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @run driver gc.TestObjectAlignmentCardSize\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestObjectAlignmentCardSize {\n+  private static void runTest(int objectAlignment, int cardSize, boolean shouldSucceed) throws Exception {\n+    OutputAnalyzer output = ProcessTools.executeTestJava(\n+        \"-XX:ObjectAlignmentInBytes=\" + objectAlignment,\n+        \"-XX:GCCardSizeInBytes=\" + cardSize,\n+        \"-Xmx32m\",\n+        \"-Xms32m\",\n+        \"-version\");\n+\n+    System.out.println(\"Output:\\n\" + output.getOutput());\n+\n+    if (shouldSucceed) {\n+      output.shouldHaveExitValue(0);\n+    } else {\n+      output.shouldContain(\"Invalid combination of GCCardSizeInBytes and ObjectAlignmentInBytes\");\n+      output.shouldNotHaveExitValue(0);\n+    }\n+  }\n+\n+  public static void main(String[] args) throws Exception {\n+    runTest(8, 512, true);\n+    runTest(128, 128, true);\n+    runTest(256, 128, false);\n+    runTest(256, 256, true);\n+    runTest(256, 512, true);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/TestObjectAlignmentCardSize.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+ * @requires vm.compMode != \"Xcomp\"\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1HeapSizeFlags.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @requires vm.compMode != \"Xcomp\"\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestParallelHeapSizeFlags.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @requires vm.compMode != \"Xcomp\"\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestSerialHeapSizeFlags.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run driver TestClassLoaderLeak\n+ * @run driver\/timeout=600 TestClassLoaderLeak\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestClassLoaderLeak.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+ * @requires vm.flagless\n@@ -46,0 +47,10 @@\n+    private static String ulimitString(int limit) {\n+        String string = \"ulimit -c \";\n+        if (limit != Integer.MAX_VALUE) {\n+            string += limit;\n+        } else {\n+            string += \"unlimited\";\n+        }\n+        return string+\";\";\n+    }\n+\n@@ -48,1 +59,1 @@\n-                                             .shouldNotHaveExitValue(0);\n+        .shouldNotHaveExitValue(0);\n@@ -53,1 +64,1 @@\n-                                                 .shouldNotHaveExitValue(0);\n+            .shouldNotHaveExitValue(0);\n@@ -55,3 +66,7 @@\n-            runTest(\"-XX:+CreateCoredumpOnCrash\").shouldNotContain(\"CreateCoredumpOnCrash turned off, no core file dumped\")\n-                                                 .shouldNotHaveExitValue(0);\n-        }\n+            String exec_cmd[] = {\"sh\", \"-c\", \"ulimit -c\"};\n+            OutputAnalyzer oa = new OutputAnalyzer(Runtime.getRuntime().exec(exec_cmd));\n+            oa.shouldHaveExitValue(0);\n+            if (!oa.contains(\"0\\n\")) {\n+                oa = runTest(\"-XX:+CreateCoredumpOnCrash\");\n+                oa.shouldContain(\"Core dump will be written.\");\n+                oa.shouldNotHaveExitValue(0);\n@@ -59,0 +74,11 @@\n+                oa = runTest(\"-XX:+CreateCoredumpOnCrash\", ulimitString(1024));\n+                oa.shouldContain(\"warning: CreateCoredumpOnCrash specified, but\");\n+                oa.shouldNotHaveExitValue(0);\n+\n+                oa = runTest(\"-XX:+CreateCoredumpOnCrash\", ulimitString(0));\n+                oa.shouldContain(\"warning: CreateCoredumpOnCrash specified, but\");\n+                oa.shouldNotHaveExitValue(0);\n+            } else {\n+                throw new Exception(\"ulimit is not set correctly, try 'ulimit -c unlimited' and re-run.\");\n+            }\n+        }\n@@ -60,0 +86,1 @@\n+\n@@ -61,4 +88,15 @@\n-        return new OutputAnalyzer(\n-            ProcessTools.createLimitedTestJavaProcessBuilder(\n-            \"-Xmx128m\", \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\", option, Crasher.class.getName())\n-            .start());\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xmx128m\",\n+                                                                             \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                                                                             option, Crasher.class.getName());\n+        return new OutputAnalyzer(pb.start());\n+    }\n+    public static OutputAnalyzer runTest(String option, String limit) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xmx128m\",\n+                                                                             \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                                                                             option, new String(\"'\"+Crasher.class.getName()+\"'\"));\n+        String args = \"\";\n+        for (String s:pb.command()) {\n+            args += s+\" \";\n+        }\n+        String exec_cmd[] = {\"sh\", \"-c\", limit+args};\n+        return new OutputAnalyzer(Runtime.getRuntime().exec(exec_cmd));\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/CreateCoredumpOnCrash.java","additions":48,"deletions":10,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import jdk.internal.misc.Unsafe;\n+\n+\/*\n+ * @test\n+ * @bug 8341471\n+ * @summary Reversed field layout caused by unstable sorting\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm TestFieldLayout\n+ *\/\n+\n+public class TestFieldLayout {\n+\n+    private static final Unsafe U = Unsafe.getUnsafe();\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        boolean endResult = true;\n+        long previous = 0;\n+\n+        for (Field f : Test.class.getDeclaredFields()) {\n+            long current = U.objectFieldOffset(f);\n+            if (current < previous) {\n+                System.out.printf(\"FAILED: field %s offset %d previous %d\\n\",\n+                                  f.getName(), current, previous);\n+                endResult = false;\n+            }\n+            previous = current;\n+        }\n+\n+        System.out.println(endResult ? \"Test PASSES\" : \"Test FAILS\");\n+        if (!endResult) {\n+            throw new Error(\"Test failed\");\n+        }\n+    }\n+\n+    public class Test {\n+        char a000;\n+        char a001;\n+        char a002;\n+        char a003;\n+        char a004;\n+        char a005;\n+        char a006;\n+        char a007;\n+        char a008;\n+        char a009;\n+        char a00a;\n+        char a00b;\n+    }\n+\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/FieldLayout\/TestFieldLayout.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Example test to use the Compile Framework.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver compile_framework.examples.CombinedJavaJasmExample\n+ *\/\n+\n+package compile_framework.examples;\n+\n+import compiler.lib.compile_framework.*;\n+\n+\/**\n+ * This test shows a compilation of multiple Java and Jasm source code files.\n+ * In this example, the classes even reference each other.\n+ *\/\n+public class CombinedJavaJasmExample {\n+\n+    \/\/ Generate a source jasm file as String\n+    public static String generateJasm() {\n+        return \"\"\"\n+               package p\/xyz;\n+\n+               super public class XYZJasm {\n+                   public static Method test:\"(I)I\"\n+                   stack 20 locals 20\n+                   {\n+                       iload_0;\n+                       iconst_2;\n+                       imul;\n+                       invokestatic Method p\/xyz\/XYZJava.\"mul3\":\"(I)I\";\n+                       ireturn;\n+                   }\n+\n+                   public static Method mul5:\"(I)I\"\n+                   stack 20 locals 20\n+                   {\n+                       iload_0;\n+                       ldc 5;\n+                       imul;\n+                       ireturn;\n+                   }\n+               }\n+               \"\"\";\n+    }\n+\n+    \/\/ Generate a source java file as String\n+    public static String generateJava() {\n+        return \"\"\"\n+               package p.xyz;\n+\n+               public class XYZJava {\n+                   public static int test(int i) {\n+                       return p.xyz.XYZJasm.mul5(i * 7);\n+                   }\n+\n+                   public static int mul3(int i) {\n+                       return i * 3;\n+                   }\n+               }\n+               \"\"\";\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Generate files.\n+        comp.addJasmSourceCode(\"p.xyz.XYZJasm\", generateJasm());\n+        comp.addJavaSourceCode(\"p.xyz.XYZJava\", generateJava());\n+\n+        \/\/ Compile the source files.\n+        comp.compile();\n+\n+        test(comp, \"p.xyz.XYZJasm\", \"test\", 11, 11 * 2 * 3);\n+        test(comp, \"p.xyz.XYZJava\", \"test\", 13, 13 * 7 * 5);\n+\n+        System.out.println(\"Success.\");\n+    }\n+\n+    public static void test(CompileFramework comp, String className, String methodName, int input, int expected) {\n+        Object ret = comp.invoke(className, methodName, new Object[] {input});\n+\n+        \/\/ Extract return value of invocation, verify its value.\n+        int i = (int)ret;\n+        System.out.println(\"Result of call: \" + i + \" vs expected: \" + expected);\n+        if (i != expected) {\n+            throw new RuntimeException(\"wrong value: \" + i);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compile_framework\/examples\/CombinedJavaJasmExample.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Example test to use the Compile Framework together with the IR Framework (i.e. TestFramework).\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @compile ..\/..\/..\/compiler\/lib\/ir_framework\/TestFramework.java\n+ * @run driver compile_framework.examples.IRFrameworkJavaExample\n+ *\/\n+\n+package compile_framework.examples;\n+\n+import compiler.lib.compile_framework.*;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.Platform;\n+import java.lang.reflect.InvocationTargetException;\n+\n+\/**\n+ * This test shows that the IR verification can be done on code compiled by the Compile Framework.\n+ * The \"@compile\" command for JTREG is required so that the IRFramework is compiled, other javac\n+ * might not compile it because it is not present in the class, only in the dynamically compiled\n+ * code.\n+ * <p>\n+ * Additionally, we must set the classpath for the Test-VM, so that it has access to all compiled\n+ * classes (see {@link CompileFramework#getEscapedClassPathOfCompiledClasses}).\n+ *\/\n+public class IRFrameworkJavaExample {\n+\n+    public static void main(String[] args) {\n+        testX1();\n+        testX2();\n+    }\n+\n+    \/\/ Generate a source java file as String\n+    public static String generateX1(CompileFramework comp) {\n+        return String.format(\"\"\"\n+               import compiler.lib.ir_framework.*;\n+\n+               public class X1 {\n+                   public static void main(String args[]) {\n+                       TestFramework framework = new TestFramework(X1.class);\n+                       framework.addFlags(\"-classpath\", \"%s\");\n+                       framework.start();\n+                   }\n+\n+                   @Test\n+                   @IR(counts = {IRNode.LOAD_VECTOR_F, \"> 0\"},\n+                       applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+                   static float[] test() {\n+                       float[] a = new float[1024*8];\n+                       for (int i = 0; i < a.length; i++) {\n+                           a[i]++;\n+                       }\n+                       return a;\n+                   }\n+               }\n+               \"\"\", comp.getEscapedClassPathOfCompiledClasses());\n+    }\n+\n+    static void testX1() {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"X1\", generateX1(comp));\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        \/\/ X1.main();\n+        comp.invoke(\"X1\", \"main\", new Object[] {null});\n+    }\n+\n+    \/\/ Generate a source java file as String\n+    public static String generateX2(CompileFramework comp) {\n+        \/\/ Example with conflicting \"@IR\" rules -> expect a IRViolationException.\n+        return String.format(\"\"\"\n+               import compiler.lib.ir_framework.*;\n+\n+               public class X2 {\n+                   public static void main(String args[]) {\n+                       TestFramework framework = new TestFramework(X2.class);\n+                       framework.addFlags(\"-classpath\", \"%s\");\n+                       framework.start();\n+                   }\n+\n+                   @Test\n+                   @IR(counts = {IRNode.LOAD, \"> 0\"})\n+                   @IR(failOn = IRNode.LOAD)\n+                   static void test() {\n+                   }\n+               }\n+               \"\"\", comp.getEscapedClassPathOfCompiledClasses());\n+    }\n+\n+    static void testX2() {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"X2\", generateX2(comp));\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        \/\/ Load the compiled class.\n+        Class<?> c = comp.getClass(\"X2\");\n+\n+        \/\/ Invoke the \"X2.main\" method from the compiled and loaded class.\n+        try {\n+            c.getDeclaredMethod(\"main\", new Class[] { String[].class }).invoke(null, new Object[] { null });\n+\n+            \/\/ Check if IR framework is expected to execute the IR rules.\n+            if (Utils.getTestJavaOpts().length == 0 && Platform.isDebugBuild() && !Platform.isInt() && !Platform.isComp()) {\n+                throw new RuntimeException(\"IRViolationException expected.\");\n+            } else {\n+                System.out.println(\"Got no IRViolationException, but was also not expected.\");\n+            }\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(\"No such method:\", e);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(\"Illegal access:\", e);\n+        } catch (InvocationTargetException e) {\n+            Throwable t = e.getCause();\n+            if (t == null) {\n+                throw new RuntimeException(\"IRViolationException expected:\", e);\n+            }\n+            if (!t.getClass().getSimpleName().equals(\"IRViolationException\")) {\n+                throw new RuntimeException(\"IRViolationException expected:\", e);\n+            }\n+            System.out.println(\"Success, we got a IRViolationException.\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compile_framework\/examples\/IRFrameworkJavaExample.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Example test to use the Compile Framework.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver comile_framework.examples.MultiFileJasmExample\n+ *\/\n+\n+package comile_framework.examples;\n+\n+import compiler.lib.compile_framework.*;\n+import java.io.StringWriter;\n+import java.io.PrintWriter;\n+\n+\/**\n+ * This test shows a compilation of multiple jasm source code files.\n+ *\/\n+public class MultiFileJasmExample {\n+\n+    \/\/ Generate a source jasm file as String\n+    public static String generate(int i) {\n+        StringWriter writer = new StringWriter();\n+        PrintWriter out = new PrintWriter(writer);\n+        out.println(\"package p\/xyz;\");\n+        out.println(\"\");\n+        out.println(\"super public class XYZ\" + i + \" {\");\n+        out.println(\"    public static Method test:\\\"(I)I\\\"\");\n+        out.println(\"    stack 20 locals 20\");\n+        out.println(\"    {\");\n+        out.println(\"        iload_0;\");\n+        out.println(\"        iconst_2;\"); \/\/ every call multiplies by 2, in total 2^10 = 1024\n+        out.println(\"        imul;\");\n+        if (i != 0) {\n+            out.println(\"        invokestatic Method p\/xyz\/XYZ\" + (i-1) + \".\\\"test\\\":\\\"(I)I\\\";\");\n+        }\n+        out.println(\"        ireturn;\");\n+        out.println(\"    }\");\n+        out.println(\"}\");\n+        return writer.toString();\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Generate 10 files.\n+        for (int i = 0; i < 10; i++) {\n+            comp.addJasmSourceCode(\"p.xyz.XYZ\" + i, generate(i));\n+        }\n+\n+        \/\/ Compile the source files.\n+        comp.compile();\n+\n+        \/\/ Object ret = XYZ9.test(5);\n+        Object ret = comp.invoke(\"p.xyz.XYZ9\", \"test\", new Object[] { 5 });\n+\n+        \/\/ Extract return value of invocation, verify its value.\n+        int i = (int)ret;\n+        System.out.println(\"Result of call: \" + i);\n+        if (i != 5 * 1024) {\n+            throw new RuntimeException(\"wrong value: \" + i);\n+        }\n+        System.out.println(\"Success.\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compile_framework\/examples\/MultiFileJasmExample.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Example test to use the Compile Framework.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver compile_framework.examples.MultiFileJavaExample\n+ *\/\n+\n+package compile_framework.examples;\n+\n+import compiler.lib.compile_framework.*;\n+import java.io.StringWriter;\n+import java.io.PrintWriter;\n+\n+\/**\n+ * This test shows a compilation of multiple java source code files.\n+ *\/\n+public class MultiFileJavaExample {\n+\n+    \/\/ Generate a source java file as String\n+    public static String generate(int i) {\n+        StringWriter writer = new StringWriter();\n+        PrintWriter out = new PrintWriter(writer);\n+        out.println(\"package p.xyz;\");\n+        out.println(\"\");\n+        out.println(\"public class XYZ\" + i + \" {\");\n+        if (i > 0) {\n+            out.println(\"    public XYZ\" + (i - 1) + \" xyz = new XYZ\" + (i - 1) + \"();\");\n+        }\n+        out.println(\"\");\n+        out.println(\"    public static Object test() {\");\n+        out.println(\"        return new XYZ\" + i + \"();\");\n+        out.println(\"    }\");\n+        out.println(\"}\");\n+        return writer.toString();\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Generate 10 files.\n+        for (int i = 0; i < 10; i++) {\n+            comp.addJavaSourceCode(\"p.xyz.XYZ\" + i, generate(i));\n+        }\n+\n+        \/\/ Compile the source files.\n+        comp.compile();\n+\n+        \/\/ Object ret = XYZ9.test();\n+        Object ret = comp.invoke(\"p.xyz.XYZ9\", \"test\", new Object[] {});\n+\n+        if (!ret.getClass().getSimpleName().equals(\"XYZ9\")) {\n+            throw new RuntimeException(\"wrong result:\" + ret);\n+        }\n+        System.out.println(\"Success.\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compile_framework\/examples\/MultiFileJavaExample.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Example test to use the Compile Framework and run the compiled code with additional flags\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver compile_framework.examples.RunWithFlagsExample\n+ *\/\n+\n+package compile_framework.examples;\n+\n+import compiler.lib.compile_framework.*;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * This test shows how the generated code can be compiled and invoked in a new VM. This allows\n+ * the execution of the code with additional VM flags and options.\n+ * <p>\n+ * The new VM must be able to locate the class files of the newly compiled code. For this we\n+ * set the class path using {@link CompileFramework#getEscapedClassPathOfCompiledClasses}.\n+ *\/\n+public class RunWithFlagsExample {\n+\n+    private static String generate() {\n+        return \"\"\"\n+               package p.xyz;\n+\n+               public class X {\n+                   public static void main(String args[]) {\n+                       System.out.println(\"Hello world!\");\n+                       System.out.println(System.getProperty(\"MyMessage\", \"fail\"));\n+                       System.err.println(args[0]);\n+                   }\n+               }\n+               \"\"\";\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a Java source file.\n+        comp.addJavaSourceCode(\"p.xyz.X\", generate());\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        \/\/ Build command line.\n+        String[] command = {\n+            \/\/ Set the classpath to include our newly compiled class.\n+            \"-classpath\",\n+            comp.getEscapedClassPathOfCompiledClasses(),\n+            \/\/ Pass additional flags here.\n+            \/\/ \"-Xbatch\" is a harmless VM flag, so this example runs everywhere without issues.\n+            \"-Xbatch\",\n+            \/\/ We can also pass properties like \"MyMessage\".\n+            \"-DMyMessage=hello_world\",\n+            \"p.xyz.X\",\n+            \"hello_arg\"\n+        };\n+\n+        \/\/ Execute the command, and capture the output.\n+        \/\/ The JTREG Java and VM options are automatically passed to the test VM.\n+        OutputAnalyzer analyzer = ProcessTools.executeTestJava(command);\n+\n+        \/\/ Verify output.\n+        analyzer.shouldHaveExitValue(0);\n+        analyzer.stdoutContains(\"Hello world!\");\n+        analyzer.stdoutContains(\"hello_world\");\n+        analyzer.stdoutContains(\"hello_arg\");\n+\n+        \/\/ Print output to stderr.\n+        analyzer.reportDiagnosticSummary();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compile_framework\/examples\/RunWithFlagsExample.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Example test to use the Compile Framework.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver compile_framework.examples.SimpleJasmExample\n+ *\/\n+\n+package compile_framework.examples;\n+\n+import compiler.lib.compile_framework.*;\n+\n+\/**\n+ * This test shows a simple compilation of java source code, and its invocation.\n+ *\/\n+public class SimpleJasmExample {\n+\n+    \/\/ Generate a source jasm file as String\n+    public static String generate() {\n+        return \"\"\"\n+               super public class XYZ {\n+                   public static Method test:\"(I)I\"\n+                   stack 20 locals 20\n+                   {\n+                       iload_0;\n+                       iconst_2;\n+                       imul;\n+                       ireturn;\n+                   }\n+               }\n+               \"\"\";\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        String src = generate();\n+        comp.addJasmSourceCode(\"XYZ\", src);\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        \/\/ Object ret = XYZ.test(5);\n+        Object ret = comp.invoke(\"XYZ\", \"test\", new Object[] {5});\n+\n+        \/\/ Extract return value of invocation, verify its value.\n+        int i = (int)ret;\n+        System.out.println(\"Result of call: \" + i);\n+        if (i != 10) {\n+            throw new RuntimeException(\"wrong value: \" + i);\n+        }\n+        System.out.println(\"Success.\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compile_framework\/examples\/SimpleJasmExample.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Example test to use the Compile Framework.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver compile_framework.examples.SimpleJavaExample\n+ *\/\n+\n+package compile_framework.examples;\n+\n+import compiler.lib.compile_framework.*;\n+\n+\/**\n+ * This test shows a simple compilation of java source code, and its invocation.\n+ *\/\n+public class SimpleJavaExample {\n+\n+    \/\/ Generate a source java file as String\n+    public static String generate() {\n+        return \"\"\"\n+               public class XYZ {\n+                   public static int test(int i) {\n+                       System.out.println(\"Hello from XYZ.test: \" + i);\n+                       return i * 2;\n+                   }\n+               }\n+               \"\"\";\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"XYZ\", generate());\n+\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        \/\/ Object ret = XYZ.test(5);\n+        Object ret = comp.invoke(\"XYZ\", \"test\", new Object[] {5});\n+\n+        \/\/ Extract return value of invocation, verify its value.\n+        int i = (int)ret;\n+        System.out.println(\"Result of call: \" + i);\n+        if (i != 10) {\n+            throw new RuntimeException(\"wrong value: \" + i);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compile_framework\/examples\/SimpleJavaExample.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Example test with failing jasm compilation.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver compile_framework.tests.TestBadJasmCompilation\n+ *\/\n+\n+package compile_framework.tests;\n+\n+import compiler.lib.compile_framework.*;\n+\n+public class TestBadJasmCompilation {\n+\n+    \/\/ Generate a source jasm file as String\n+    public static String generate() {\n+        return \"\"\"\n+               super public class XYZ {\n+                   some bad code\n+               }\n+               \"\"\";\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJasmSourceCode(\"XYZ\", generate());\n+\n+        try {\n+            \/\/ Compile the source file.\n+            comp.compile();\n+            throw new RuntimeException(\"Expected compilation to fail.\");\n+        } catch (CompileFrameworkException e) {\n+            System.out.println(\"Success, expected compilation to fail.\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compile_framework\/tests\/TestBadJasmCompilation.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Example test with failing java compilation.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver compile_framework.tests.TestBadJavaCompilation\n+ *\/\n+\n+package compile_framework.tests;\n+\n+import compiler.lib.compile_framework.*;\n+\n+public class TestBadJavaCompilation {\n+\n+    \/\/ Generate a source java file as String\n+    public static String generate() {\n+        return \"\"\"\n+               public class XYZ {\n+                   some bad code\n+               }\n+               \"\"\";\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"XYZ\", generate());\n+\n+        try {\n+            \/\/ Compile the source file.\n+            comp.compile();\n+            throw new RuntimeException(\"Expected compilation to fail.\");\n+        } catch (CompileFrameworkException e) {\n+            System.out.println(\"Success, expected compilation to fail.\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compile_framework\/tests\/TestBadJavaCompilation.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Example test with multi-threaded use of the CompileFramework.\n+ *          Tests that the source and class directories are set up correctly.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver compile_framework.tests.TestConcurrentCompilation\n+ *\/\n+\n+package compile_framework.tests;\n+\n+import compiler.lib.compile_framework.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class TestConcurrentCompilation {\n+\n+    \/\/ Generate a source java file as String\n+    public static String generate(int i) {\n+        return String.format(\"\"\"\n+                             public class XYZ {\n+                                 public static int test() {\n+                                     return %d;\n+                                 }\n+                             }\n+                             \"\"\", i);\n+    }\n+\n+    public static void test(int i) {\n+        System.out.println(\"Generate and compile XYZ for \" + i);\n+        CompileFramework comp = new CompileFramework();\n+        comp.addJavaSourceCode(\"XYZ\", generate(i));\n+        comp.compile();\n+\n+        \/\/ Now, sleep to give the other threads time to compile and store their class-files.\n+        System.out.println(\"Sleep for \" + i);\n+        try {\n+            Thread.sleep(100);\n+        } catch (InterruptedException e) {\n+            System.out.println(\"Sleep interrupted for \" + i);\n+        }\n+\n+        \/\/ Now, hopefully all threads have compiled and stored their class-files.\n+        \/\/ We can check if we get the expected result, i.e. the class-file from the current thread.\n+        System.out.println(\"Run XYZ.test for \" + i);\n+        int j = (int)comp.invoke(\"XYZ\", \"test\", new Object[] {});\n+        if (i != j) {\n+            System.out.println(\"Wrong value: \" + i + \" vs \" + j);\n+            throw new RuntimeException(\"Wrong value: \" + i + \" vs \" + j);\n+        }\n+        System.out.println(\"Success for \" + i);\n+    }\n+\n+    public static class MyRunnable implements Runnable {\n+        private int i;\n+\n+        public MyRunnable(int i) {\n+            this.i = i;\n+        }\n+\n+        public void run() {\n+            TestConcurrentCompilation.test(i);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"Generating threads:\");\n+        List<Thread> threads = new ArrayList<Thread>();\n+        for (int i = 0; i < 3; i++) {\n+            Thread thread = new Thread(new MyRunnable(i));\n+            thread.start();\n+            threads.add(thread);\n+        }\n+        System.out.println(\"Waiting to join threads:\");\n+        try {\n+            for (Thread thread : threads) {\n+                thread.join();\n+            }\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(\"interrupted\", e);\n+        }\n+        System.out.println(\"Success.\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compile_framework\/tests\/TestConcurrentCompilation.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -134,0 +134,1 @@\n+java\/awt\/dnd\/CustomDragCursorTest.java 8242805 macosx-all\n@@ -146,0 +147,1 @@\n+java\/awt\/EventQueue\/PushPopDeadlock\/PushPopDeadlock.java 8024034 generic-all\n@@ -202,0 +204,3 @@\n+java\/awt\/dnd\/DnDRemoveFocusOwnerCrashTest.java 8242805 macosx-all\n+java\/awt\/dnd\/DnDCursorCrashTest.java 8242805 macosx-all\n+java\/awt\/dnd\/DnDClipboardDeadlockTest.java 8079553 linux-all\n@@ -476,0 +481,5 @@\n+java\/awt\/Dialog\/PrintToFileTest\/PrintToFileRevoked.java 8029249 macosx-all\n+java\/awt\/Dialog\/PrintToFileTest\/PrintToFileGranted.java 8029249 macosx-all\n+java\/awt\/Dialog\/ChoiceModalDialogTest.java 8161475 macosx-all\n+java\/awt\/Dialog\/FileDialogUserFilterTest.java 8001142 generic-all\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    docker.support \\\n+    container.support \\\n","filename":"test\/jdk\/TEST.ROOT","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-#  Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,2 @@\n-    :jdk_jpackage\n+    :jdk_jpackage \\\n+    :jdk_since_checks\n@@ -669,0 +670,4 @@\n+\n+# Set of tests for `@since` checks in source code documentation\n+jdk_since_checks = \\\n+   tools\/sincechecker\/modules\/java_base\/CheckSince_javaBase.java\n","filename":"test\/jdk\/TEST.groups","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -161,0 +161,13 @@\n+ *\n+ * @bug 8341819\n+ * @comment Regression test for re-locking racing with deflation with LM_LIGHTWEIGHT.\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks\n+ *                 -XX:LockingMode=2\n+ *                 -XX:GuaranteedAsyncDeflationInterval=1\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import java.time.Instant;\n@@ -43,1 +42,1 @@\n- * @run main Timeout\n+ * @run main\/othervm Timeout\n@@ -51,0 +50,4 @@\n+    \/\/ DnsClient retries again with increased timeout if left\n+    \/\/ timeout is less than this value, and max retry attempts\n+    \/\/ is not reached\n+    private static final int DNS_CLIENT_MIN_TIMEOUT = 0;\n@@ -52,1 +55,1 @@\n-    private Instant startTime;\n+    private long startTime;\n@@ -84,1 +87,1 @@\n-            startTime = Instant.now();\n+            startTime = System.nanoTime();\n@@ -95,1 +98,1 @@\n-            Duration elapsedTime = Duration.between(startTime, Instant.now());\n+            Duration elapsedTime = Duration.ofNanos(System.nanoTime() - startTime);\n@@ -101,2 +104,8 @@\n-            Duration expectedTime = Duration.ofMillis(TIMEOUT)\n-                    .multipliedBy((1 << RETRIES) - 1);\n+            Duration minAllowedTime = Duration.ofMillis(TIMEOUT)\n+                    .multipliedBy((1 << RETRIES) - 1)\n+                    .minus(Duration.ofMillis(DNS_CLIENT_MIN_TIMEOUT * RETRIES));\n+            Duration maxAllowedTime = Duration.ofMillis(TIMEOUT)\n+                    .multipliedBy((1 << RETRIES) - 1)\n+                    \/\/ max allowed timeout value is set to 2 * expected timeout\n+                    .multipliedBy(2);\n+\n@@ -104,1 +113,3 @@\n-            DNSTestUtils.debug(\"Expected (ms): \" + expectedTime.toMillis());\n+            String expectedRangeMsg = \"%s - %s\"\n+                    .formatted(minAllowedTime.toMillis(), maxAllowedTime.toMillis());\n+            DNSTestUtils.debug(\"Expected range (ms): \" + expectedRangeMsg);\n@@ -107,4 +118,3 @@\n-            \/\/ not more than 50% greater.\n-            if (elapsedTime.compareTo(expectedTime) >= 0 &&\n-                    elapsedTime.multipliedBy(2)\n-                            .compareTo(expectedTime.multipliedBy(3)) <= 0) {\n+            \/\/ not more than 2 times greater.\n+            if (elapsedTime.compareTo(minAllowedTime) >= 0 &&\n+                elapsedTime.compareTo(maxAllowedTime) <= 0) {\n@@ -115,2 +125,2 @@\n-                    \"Failed: timeout in \" + elapsedTime.toMillis()\n-                            + \" ms, expected\" + expectedTime.toMillis() + \"ms\");\n+                    \"Failed: timeout in \" + elapsedTime.toMillis() +\n+                    \" ms, expected to be in a range (ms): \" + expectedRangeMsg);\n","filename":"test\/jdk\/com\/sun\/jndi\/dns\/ConfigTests\/Timeout.java","additions":25,"deletions":15,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.net.URIBuilder;\n+\n+import javax.naming.CommunicationException;\n+import javax.naming.Context;\n+import javax.naming.directory.InitialDirContext;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.SocketTimeoutException;\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+\/*\n+ * @test\n+ * @bug 8339538\n+ * @summary Tests that DnsClient correctly calculates left timeout in\n+ *          presence of empty datagram packets.\n+ * @library ..\/lib \/test\/lib\n+ * @modules java.base\/sun.security.util\n+ * @run main\/othervm TimeoutWithEmptyDatagrams\n+ *\/\n+\n+public class TimeoutWithEmptyDatagrams extends DNSTestBase {\n+    \/\/ initial timeout = 1\/4 sec\n+    private static final int TIMEOUT = 250;\n+    \/\/ try 5 times per server\n+    private static final int RETRIES = 5;\n+    \/\/ DnsClient retries again with increased timeout if left\n+    \/\/ timeout is less than this value, and max retry attempts\n+    \/\/ is not reached\n+    private static final int DNS_CLIENT_MIN_TIMEOUT = 0;\n+\n+    public TimeoutWithEmptyDatagrams() {\n+        setLocalServer(false);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new TimeoutWithEmptyDatagrams().run(args);\n+    }\n+\n+    \/*\n+     * Tests that we can set the initial UDP timeout interval and the\n+     * number of retries.\n+     *\/\n+    @Override\n+    public void runTest() throws Exception {\n+        \/\/ Create a DatagramSocket and bind it to the loopback address to simulate\n+        \/\/ UDP DNS server that doesn't respond\n+        try (DatagramSocket ds = new DatagramSocket(new InetSocketAddress(\n+                InetAddress.getLoopbackAddress(), 0))) {\n+            CountDownLatch gotClientAddress = new CountDownLatch(1);\n+            AtomicReference<SocketAddress> clientAddress = new AtomicReference<>();\n+            AtomicBoolean stopTestThreads = new AtomicBoolean();\n+\n+            String allQuietUrl = URIBuilder.newBuilder()\n+                    .scheme(\"dns\")\n+                    .loopback()\n+                    .port(ds.getLocalPort())\n+                    .build()\n+                    .toString();\n+\n+            \/\/ Run a virtual thread that receives client request packets and extracts\n+            \/\/ sender address from them.\n+            Thread receiverThread = Thread.ofVirtual().start(() -> {\n+                while (!stopTestThreads.get()) {\n+                    try {\n+                        DatagramPacket packet = new DatagramPacket(new byte[1024], 1024);\n+                        ds.receive(packet);\n+                        System.err.println(\"Got packet from \" + packet.getSocketAddress());\n+                        boolean hasClientAddress = clientAddress.get() != null;\n+                        clientAddress.set(packet.getSocketAddress());\n+                        if (!hasClientAddress) {\n+                            gotClientAddress.countDown();\n+                        }\n+                    } catch (IOException e) {\n+                        if (!stopTestThreads.get()) {\n+                            throw new RuntimeException(e);\n+                        } else {\n+                            return;\n+                        }\n+                    }\n+                }\n+            });\n+\n+            \/\/ Run a virtual thread that will send an empty packets via server socket\n+            \/\/ that should wake up the selector on a client side.\n+            Thread wakeupThread = Thread.ofVirtual().start(() -> {\n+                try {\n+                    long timeout = Math.max(1, TIMEOUT \/ 4);\n+                    \/\/ wait for a first packet on a server socket\n+                    gotClientAddress.await();\n+\n+                    \/\/ Now start sending empty packets until we get a notification\n+                    \/\/ from client part to stop sending\n+                    while (!stopTestThreads.get()) {\n+                        System.err.println(\"Server timeout = \" + timeout);\n+                        TimeUnit.MILLISECONDS.sleep(timeout);\n+                        System.err.println(\"Sending wakeup packet to \" + clientAddress.get());\n+                        var wakeupPacket = new DatagramPacket(new byte[0], 0);\n+                        wakeupPacket.setSocketAddress(clientAddress.get());\n+                        ds.send(wakeupPacket);\n+                        timeout += Math.max(1, timeout \/ 2);\n+                    }\n+                } catch (IOException ioe) {\n+                    throw new RuntimeException(\"Test machinery failure\", ioe);\n+                } catch (InterruptedException e) {\n+                    throw new RuntimeException(\"Interrupted during wakeup packets sending\");\n+                } finally {\n+                    System.err.println(\"Server thread exiting\");\n+                }\n+            });\n+\n+            long startTime = 0;\n+            try {\n+                env().put(Context.PROVIDER_URL, allQuietUrl);\n+                env().put(\"com.sun.jndi.dns.timeout.initial\", String.valueOf(TIMEOUT));\n+                env().put(\"com.sun.jndi.dns.timeout.retries\", String.valueOf(RETRIES));\n+                setContext(new InitialDirContext(env()));\n+\n+                startTime = System.nanoTime();\n+                context().getAttributes(\"\");\n+\n+                \/\/ Any request should fail after timeouts have expired.\n+                throw new RuntimeException(\"Failed: getAttributes succeeded unexpectedly\");\n+            } catch (CommunicationException ce) {\n+                \/\/ We need to catch CommunicationException outside the test framework\n+                \/\/ flow because wakeupThread.join() can take some time that could\n+                \/\/ increase measured timeout\n+                long endTime = System.nanoTime();\n+                Duration elapsedTime = Duration.ofNanos(endTime - startTime);\n+                if (ce.getRootCause() instanceof SocketTimeoutException) {\n+\n+                    Duration minAllowedTime = Duration.ofMillis(TIMEOUT)\n+                            .multipliedBy((1 << RETRIES) - 1)\n+                            .minus(Duration.ofMillis(DNS_CLIENT_MIN_TIMEOUT * RETRIES));\n+                    Duration maxAllowedTime = Duration.ofMillis(TIMEOUT)\n+                            .multipliedBy((1 << RETRIES) - 1)\n+                            \/\/ max allowed timeout value is set to 2 * expected timeout\n+                            .multipliedBy(2);\n+\n+                    DNSTestUtils.debug(\"Elapsed (ms):  \" + elapsedTime.toMillis());\n+                    String expectedRangeMsg = \"%s - %s\"\n+                            .formatted(minAllowedTime.toMillis(), maxAllowedTime.toMillis());\n+                    DNSTestUtils.debug(\"Expected range (ms): \" + expectedRangeMsg);\n+\n+                    \/\/ Check that elapsed time is as long as expected, and\n+                    \/\/ not more than 2 times greater.\n+                    if (elapsedTime.compareTo(minAllowedTime) >= 0 &&\n+                        elapsedTime.compareTo(maxAllowedTime) <= 0) {\n+                        System.out.println(\"elapsed time is as long as expected.\");\n+                    } else {\n+                        throw new RuntimeException(\n+                                \"Failed: timeout in \" + elapsedTime.toMillis() +\n+                                \" ms, expected to be in a range (ms): \" + expectedRangeMsg);\n+                    }\n+                } else {\n+                    throw ce;\n+                }\n+            } finally {\n+                stopTestThreads.set(true);\n+                wakeupThread.join();\n+                ds.close();\n+                receiverThread.join();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jndi\/dns\/ConfigTests\/TimeoutWithEmptyDatagrams.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug     7150256\n+ * @bug     7150256 8338603\n@@ -71,0 +71,1 @@\n+            int operationFailures = 0;\n@@ -72,1 +73,1 @@\n-                printOperation(opInfo[i]);\n+                operationFailures += printOperation(opInfo[i]);\n@@ -75,0 +76,3 @@\n+            if (operationFailures > 0) {\n+                throw new RuntimeException(\"FAILED.  \" + operationFailures + \" operations found with non-standard parameter types.\");\n+            }\n@@ -86,1 +90,6 @@\n-    static void printOperation(MBeanOperationInfo info) {\n+    \/**\n+     * Print an Operation, and check for any non-standard parameter types.\n+     * Return the number of failed parameters, so the caller can signal to fail the test.\n+     *\/\n+    static int printOperation(MBeanOperationInfo info) {\n+        int failures = 0;\n@@ -103,2 +112,10 @@\n-                        System.out.println(\"\\t\\t\\t\"+desc3.getFieldNames()[k]+\"=\"\n-                                           +desc3.getFieldValue(desc3.getFieldNames()[k]));\n+                        String fieldName3 = desc3.getFieldNames()[k];\n+                        Object fieldValue3 = desc3.getFieldValue(fieldName3);\n+                        System.out.print(\"\\t\\t\\t\" + fieldName3 + \"=\" + fieldValue3);\n+                        if (fieldName3.equals(\"dcmd.arg.type\")) {\n+                            if (!isPublicType((String) fieldValue3)) {\n+                                System.out.print(\"\\t** FAILED ** not a standard type\");\n+                                failures++;\n+                            }\n+                        }\n+                        System.out.println();\n@@ -112,0 +129,17 @@\n+        return failures;\n+    }\n+\n+    \/\/ Knowledge of the implementation-dependent types in DiagnosticCommandImpl, seen by applications\/users\n+    \/\/ (see the DiagnosticCommandMBean Descriptor, field \"dcmd.arg.type\").\n+    private static final String [] publicTypes = new String [] { \"INT\", \"STRING\", \"BOOLEAN\", \"STRING SET\", \"MEMORY SIZE\", \"NANOTIME\" };\n+\n+    private static final boolean isPublicType(String typeName) {\n+        if (typeName == null) {\n+            return false;\n+        }\n+        for (String t : publicTypes) {\n+            if (typeName.equals(t)) {\n+                return true;\n+            }\n+        }\n+        return false;\n","filename":"test\/jdk\/com\/sun\/management\/DiagnosticCommandMBean\/DcmdMBeanTest.java","additions":40,"deletions":6,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,422 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6616089\n+ * @summary Displays a dithered Canvas on all available GraphicsConfigurations\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MultiDitherTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Canvas;\n+import java.awt.Choice;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.FontMetrics;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Image;\n+import java.awt.Label;\n+import java.awt.LayoutManager;\n+import java.awt.Panel;\n+import java.awt.TextField;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.image.ColorModel;\n+import java.awt.image.MemoryImageSource;\n+import java.util.List;\n+\n+public class MultiDitherTest extends Panel implements Runnable {\n+    final static int NOOP = 0;\n+    final static int RED = 1;\n+    final static int GREEN = 2;\n+    final static int BLUE = 3;\n+    final static int ALPHA = 4;\n+    final static int SATURATION = 5;\n+    final static String calcString = \"Calculating...\";\n+    static LayoutManager dcLayout = new FlowLayout(FlowLayout.CENTER, 10, 5);\n+    Thread runner;\n+    DitherControls XControls;\n+    DitherControls YControls;\n+    DitherCanvas canvas;\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                Depending on the GraphicsConfiguration, the dithering may be in\n+                color or in grayscale and\/or display at a lower bitdepth.\n+                The number of GraphicsConfigurations will be printed in the\n+                TextArea below as the test is starting up.\n+                Ensure that there are as many Frames created as there are\n+                available GraphicsConfigurations.\n+                Examine each Frame to ensure it displays the dither pattern.\n+                If all Canvases display correctly, the test PASSES.\n+                Otherwise, the test FAILS.\n+                The GC button runs the garbage collector.\n+                This button can be ignored for now.\n+\n+                           \"\"\";\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .build();\n+\n+        EventQueue.invokeAndWait(() -> {\n+            for (Frame frame : MultiDitherTest.initialize()) {\n+                PassFailJFrame.addTestWindow(frame);\n+                frame.setVisible(true);\n+            }\n+        });\n+        passFailJFrame.awaitAndCheck();\n+    }\n+\n+    public MultiDitherTest(GraphicsConfiguration gc) {\n+        String xSpec, ySpec;\n+        int[] xValues = new int[2];\n+        int[] yValues = new int[2];\n+\n+        xSpec = \"red\";\n+        ySpec = \"blue\";\n+        int xMethod = colorMethod(xSpec, xValues);\n+        int yMethod = colorMethod(ySpec, yValues);\n+\n+        setLayout(new BorderLayout());\n+        XControls = new DitherControls(this, xValues[0], xValues[1],\n+                xMethod, false);\n+        YControls = new DitherControls(this, yValues[0], yValues[1],\n+                yMethod, true);\n+        YControls.addRenderButton();\n+        YControls.addGCButton();\n+        add(\"North\", XControls);\n+        add(\"South\", YControls);\n+        add(\"Center\", canvas = new DitherCanvas(gc));\n+    }\n+\n+    private static List<Frame> initialize() {\n+        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        GraphicsDevice[] gds = ge.getScreenDevices();\n+        Frame[] frames = new Frame[0];\n+        System.out.println(gds.length + \" screens detected\");\n+\n+        for (int j = 0; j < gds.length; j++) {\n+\n+            GraphicsDevice gd = gds[j];\n+            GraphicsConfiguration[] gcs = gd.getConfigurations();\n+            frames = new Frame[gcs.length];\n+            System.out.println(gcs.length + \" GraphicsConfigurations available on screen \" + j);\n+            for (int i = 0; i < gcs.length; i++) {\n+                Frame f = new Frame(\"MultiDitherTest \" + (i + 1), gcs[i]);\n+                f.setLayout(new BorderLayout());\n+                f.setLocation(gcs[i].getBounds().x + 100 + (i * 10),\n+                        gcs[i].getBounds().y + 100 + (i * 10));\n+                MultiDitherTest ditherTest = new MultiDitherTest(gcs[i]);\n+                f.add(\"Center\", ditherTest);\n+                f.pack();\n+                f.addWindowListener(new WindowAdapter() {\n+                    public void windowClosing(WindowEvent ev) {\n+                        ev.getWindow().dispose();\n+                    }\n+                });\n+                f.setVisible(true);\n+                ditherTest.start();\n+                frames[i] = f;\n+            }\n+\n+        }\n+        return List.of(frames);\n+    }\n+\n+    int colorMethod(String s, int[] values) {\n+        int method = NOOP;\n+\n+        if (s == null) {\n+            s = \"\";\n+        }\n+\n+        String lower = s.toLowerCase();\n+        if (lower.startsWith(\"red\")) {\n+            method = RED;\n+            lower = lower.substring(3);\n+        } else if (lower.startsWith(\"green\")) {\n+            method = GREEN;\n+            lower = lower.substring(5);\n+        } else if (lower.startsWith(\"blue\")) {\n+            method = BLUE;\n+            lower = lower.substring(4);\n+        } else if (lower.startsWith(\"alpha\")) {\n+            method = ALPHA;\n+            lower = lower.substring(4);\n+        } else if (lower.startsWith(\"saturation\")) {\n+            method = SATURATION;\n+            lower = lower.substring(10);\n+        }\n+\n+        if (method == NOOP) {\n+            values[0] = 0;\n+            values[1] = 0;\n+            return method;\n+        }\n+\n+        int begval = 0;\n+        int endval = 255;\n+\n+        try {\n+            int dash = lower.indexOf('-');\n+            if (dash < 0) {\n+                begval = endval = Integer.parseInt(lower);\n+            } else {\n+                begval = Integer.parseInt(lower.substring(0, dash));\n+                endval = Integer.parseInt(lower.substring(dash + 1));\n+            }\n+        } catch (Exception e) {\n+        }\n+\n+        if (begval < 0) {\n+            begval = 0;\n+        }\n+        if (endval < 0) {\n+            endval = 0;\n+        }\n+        if (begval > 255) {\n+            begval = 255;\n+        }\n+        if (endval > 255) {\n+            endval = 255;\n+        }\n+\n+        values[0] = begval;\n+        values[1] = endval;\n+\n+        return method;\n+    }\n+\n+    public void start() {\n+        runner = new Thread(this);\n+        runner.start();\n+    }\n+\n+    public void stop() {\n+        runner = null;\n+    }\n+\n+    public void destroy() {\n+        remove(XControls);\n+        remove(YControls);\n+        remove(canvas);\n+    }\n+\n+    void applyMethod(int[] c, int method, int step, int total, int[] values) {\n+        if (method == NOOP) {\n+            return;\n+        }\n+        int val = ((total < 2)\n+                ? values[0]\n+                : values[0] + ((values[1] - values[0]) * step \/ (total - 1)));\n+        switch (method) {\n+            case RED:\n+                c[0] = val;\n+                break;\n+            case GREEN:\n+                c[1] = val;\n+                break;\n+            case BLUE:\n+                c[2] = val;\n+                break;\n+            case ALPHA:\n+                c[3] = val;\n+                break;\n+            case SATURATION:\n+                int max = Math.max(Math.max(c[0], c[1]), c[2]);\n+                int min = max * (255 - val) \/ 255;\n+                if (c[0] == 0) c[0] = min;\n+                if (c[1] == 0) c[1] = min;\n+                if (c[2] == 0) c[2] = min;\n+                break;\n+        }\n+    }\n+\n+    public void run() {\n+        canvas.setImage(null);\n+        Image img = calculateImage();\n+        synchronized (this) {\n+            if (img != null && runner == Thread.currentThread()) {\n+                canvas.setImage(img);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Calculates and returns the image.  Halts the calculation and returns\n+     * null if the Application is stopped during the calculation.\n+     *\/\n+    Image calculateImage() {\n+        Thread me = Thread.currentThread();\n+\n+        int width = canvas.getSize().width;\n+        int height = canvas.getSize().height;\n+        int[] xValues = new int[2];\n+        int[] yValues = new int[2];\n+        int xMethod = XControls.getParams(xValues);\n+        int yMethod = YControls.getParams(yValues);\n+        int[] pixels = new int[width * height];\n+        int[] c = new int[4];\n+        int index = 0;\n+\n+        for (int j = 0; j < height; j++) {\n+            for (int i = 0; i < width; i++) {\n+                c[0] = c[1] = c[2] = 0;\n+                c[3] = 255;\n+                if (xMethod < yMethod) {\n+                    applyMethod(c, xMethod, i, width, xValues);\n+                    applyMethod(c, yMethod, j, height, yValues);\n+                } else {\n+                    applyMethod(c, yMethod, j, height, yValues);\n+                    applyMethod(c, xMethod, i, width, xValues);\n+                }\n+                pixels[index++] = ((c[3] << 24) |\n+                        (c[0] << 16) |\n+                        (c[1] << 8) |\n+                        (c[2] << 0));\n+            }\n+            \/\/ Poll once per row to see if we've been told to stop.\n+            if (runner != me) {\n+                return null;\n+            }\n+        }\n+\n+        return createImage(new MemoryImageSource(width, height,\n+                ColorModel.getRGBdefault(), pixels, 0, width));\n+    }\n+\n+    static class DitherCanvas extends Canvas {\n+        Image img;\n+        GraphicsConfiguration mGC;\n+\n+        public DitherCanvas(GraphicsConfiguration gc) {\n+            super(gc);\n+            mGC = gc;\n+        }\n+\n+        public GraphicsConfiguration getGraphicsConfig() {\n+            return mGC;\n+        }\n+\n+        public void paint(Graphics g) {\n+            int w = getSize().width;\n+            int h = getSize().height;\n+            if (img == null) {\n+                super.paint(g);\n+                g.setColor(Color.black);\n+                FontMetrics fm = g.getFontMetrics();\n+                int x = (w - fm.stringWidth(calcString)) \/ 2;\n+                int y = h \/ 2;\n+                g.drawString(calcString, x, y);\n+            } else {\n+                g.drawImage(img, 0, 0, w, h, this);\n+            }\n+        }\n+\n+        public void update(Graphics g) {\n+            paint(g);\n+        }\n+\n+        public Dimension getMinimumSize() {\n+            return new Dimension(20, 20);\n+        }\n+\n+        public Dimension getPreferredSize() {\n+            return new Dimension(200, 200);\n+        }\n+\n+        public Image getImage() {\n+            return img;\n+        }\n+\n+        public void setImage(Image img) {\n+            this.img = img;\n+            paint(getGraphics());\n+        }\n+    }\n+\n+    static class DitherControls extends Panel implements ActionListener {\n+        TextField start;\n+        TextField end;\n+        Button button;\n+        Choice choice;\n+        MultiDitherTest panel;\n+        Button gc;\n+\n+        public DitherControls(MultiDitherTest app, int s, int e, int type,\n+                              boolean vertical) {\n+            panel = app;\n+            setLayout(dcLayout);\n+            add(new Label(vertical ? \"Vertical\" : \"Horizontal\"));\n+            add(choice = new Choice());\n+            choice.addItem(\"Noop\");\n+            choice.addItem(\"Red\");\n+            choice.addItem(\"Green\");\n+            choice.addItem(\"Blue\");\n+            choice.addItem(\"Alpha\");\n+            choice.addItem(\"Saturation\");\n+            choice.select(type);\n+            add(start = new TextField(Integer.toString(s), 4));\n+            add(end = new TextField(Integer.toString(e), 4));\n+        }\n+\n+        public void addRenderButton() {\n+            add(button = new Button(\"New Image\"));\n+            button.addActionListener(this);\n+        }\n+\n+        public void addGCButton() {\n+            add(gc = new Button(\"GC\"));\n+            gc.addActionListener(this);\n+        }\n+\n+        public int getParams(int[] values) {\n+            values[0] = Integer.parseInt(start.getText());\n+            values[1] = Integer.parseInt(end.getText());\n+            return choice.getSelectedIndex();\n+        }\n+\n+        public void actionPerformed(ActionEvent e) {\n+            if (e.getSource() == button) {\n+                panel.start();\n+            } else if (e.getSource() == gc) {\n+                System.gc();\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/awt\/Canvas\/MultiDitherTest.java","additions":422,"deletions":0,"binary":false,"changes":422,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6616089\n+ * @summary Display an image in all available GraphicsConfigurations\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MultiGraphicsTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Canvas;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Image;\n+import java.awt.MediaTracker;\n+import java.awt.Toolkit;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.net.URL;\n+import java.util.List;\n+\n+public class MultiGraphicsTest extends Canvas {\n+    final static String IMAGEFILE = \"duke_404.gif\";\n+    static Image jim;\n+    MediaTracker tracker;\n+    int w, h;\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                This test displays several Windows containing an image,\n+                one Window for each available GraphicsConfiguration.\n+                Depending on the GraphicsConfiguration, images may be\n+                displayed in color or in grayscale and\/or displayed at a\n+                lower bitdepth.\n+                The number of GraphicsConfigurations will be printed below\n+                as the test is starting up.\n+                Ensure that there are as many Windows created as there are\n+                available GraphicsConfigurations.\n+                Examine each Window to ensure it displays Duke_404.\n+                If all Canvases display correctly, the test PASSES.\n+                Otherwise, the test FAILS.\"\n+                \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public MultiGraphicsTest(GraphicsConfiguration gc) {\n+        super(gc);\n+        tracker = new MediaTracker(this);\n+        tracker.addImage(jim, 0);\n+        try {\n+            tracker.waitForAll();\n+        } catch (java.lang.InterruptedException e) {\n+            System.err.println(e);\n+        }\n+        w = jim.getWidth(this);\n+        h = jim.getHeight(this);\n+    }\n+\n+    private static List<Frame> initialize() {\n+        URL imgURL;\n+        imgURL = MultiGraphicsTest.class.getResource(IMAGEFILE);\n+        if (imgURL == null) {\n+            System.err.println(\"Unable to locate \" + IMAGEFILE);\n+            return null;\n+        }\n+        jim = Toolkit.getDefaultToolkit().getImage(imgURL);\n+\n+        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        GraphicsDevice gd = ge.getDefaultScreenDevice();\n+        GraphicsConfiguration[] gc = gd.getConfigurations();\n+        Frame[] frames = new Frame[gc.length];\n+        System.out.println(gc.length + \" available GraphicsConfigurations\");\n+        for (int i = 0; i < gc.length; i++) {\n+            Frame f = new Frame(\"GraphicsTest \" + (i + 1));\n+            f.setLayout(new BorderLayout());\n+            f.setLocation(100 + (i * 10), 100 + (i * 10));\n+            MultiGraphicsTest gcTest = new MultiGraphicsTest(gc[i]);\n+            f.add(\"Center\", gcTest);\n+            f.pack();\n+            f.addWindowListener(new WindowAdapter() {\n+                public void windowClosing(WindowEvent ev) {\n+                    ev.getWindow().setVisible(false);\n+                }\n+            });\n+            frames[i] = f;\n+        }\n+        return List.of(frames);\n+    }\n+\n+    public void paint(Graphics g) {\n+        g.drawImage(jim, 0, 0, w, h, this);\n+    }\n+\n+    public void update(Graphics g) {\n+        paint(g);\n+    }\n+\n+    public Dimension getMinimumSize() {\n+        return new Dimension(w, h);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(w, h);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Canvas\/MultiGraphicsTest.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4250354\n+ * @key headful\n+ * @summary tests that JNI global refs are cleaned up correctly\n+ * @run main\/timeout=600 NoEventsLeakTest\n+ *\/\n+\n+import java.awt.Canvas;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+\n+public class NoEventsLeakTest extends Frame {\n+    static final int nLoopCount = 1000;\n+\n+    private static void initialize() {\n+        NoEventsLeakTest app = new NoEventsLeakTest();\n+        boolean result = app.run();\n+        if (result) {\n+            throw new RuntimeException(\"Memory leak in Component\");\n+        }\n+        System.out.println(\"Test Passed\");\n+    }\n+\n+    public boolean run() {\n+        setSize(10, 10);\n+        addNotify();\n+        for (int i = 0; i < nLoopCount; i++) {\n+            Canvas panel = new TestCanvas();\n+            add(panel, 0);\n+            remove(0);\n+            panel = null;\n+            System.gc();\n+        }\n+        try {\n+            Thread.currentThread().sleep(1000);\n+        } catch (InterruptedException e) {\n+        }\n+        System.gc();\n+        System.out.println(\"Checking\");\n+        return ((TestCanvas.created - TestCanvas.finalized) > 800);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(NoEventsLeakTest::initialize);\n+    }\n+}\n+\n+class TestCanvas extends Canvas {\n+    static int finalized = 0;\n+    static int created = 0;\n+    static final int nLoopPrint = 100;\n+\n+    public TestCanvas() {\n+        if (created % nLoopPrint == 0) {\n+            System.out.println(\"Created \" + getClass() + \" \" + created);\n+        }\n+        created++;\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    protected void finalize() {\n+        try {\n+            super.finalize();\n+            if (finalized % nLoopPrint == 0) {\n+                System.out.println(\"Finalized \" + getClass() + \" \" + finalized);\n+            }\n+            finalized++;\n+        } catch (Throwable t) {\n+            System.out.println(\"Exception in \" + getClass() + \": \" + t);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Canvas\/NoEventsLeakTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/awt\/Canvas\/duke_404.gif","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/awt\/Frame\/MegaIconTest\/duke_404.gif","status":"copied"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6213128\n+ * @key headful\n+ * @summary Tests that choice is releasing input capture when a modal\n+ *          dialog is shown\n+ * @run main ChoiceModalDialogTest\n+ *\/\n+\n+import java.awt.Choice;\n+import java.awt.Dialog;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Robot;\n+import java.awt.TextField;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyAdapter;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+public class ChoiceModalDialogTest {\n+    static Frame f;\n+    static Dialog d;\n+    static volatile boolean keyOK;\n+    static volatile boolean mouseOK;\n+    static TextField tf;\n+    static Choice c;\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot r;\n+        try {\n+            r = new Robot();\n+            r.setAutoDelay(100);\n+            EventQueue.invokeAndWait(() -> {\n+                f = new Frame(\"Frame\");\n+                c = new Choice();\n+                f.setBounds(100, 300, 300, 200);\n+                f.setLayout(new FlowLayout());\n+                tf = new TextField(3);\n+                f.add(tf);\n+\n+                c.add(\"1\");\n+                c.add(\"2\");\n+                c.add(\"3\");\n+                c.add(\"4\");\n+                f.add(c);\n+\n+                tf.addFocusListener(new FocusAdapter() {\n+                    public void focusLost(FocusEvent ev) {\n+                        d = new Dialog(f, \"Dialog\", true);\n+                        d.setBounds(300, 300, 200, 150);\n+                        d.addKeyListener(new KeyAdapter() {\n+                            public void keyPressed(KeyEvent ev) {\n+                                keyOK = true;\n+                            }\n+                        });\n+                        d.addMouseListener(new MouseAdapter() {\n+                            public void mousePressed(MouseEvent ev) {\n+                                mouseOK = true;\n+                            }\n+                        });\n+                        d.setVisible(true);\n+                    }\n+                });\n+\n+                f.setVisible(true);\n+                f.toFront();\n+            });\n+            r.waitForIdle();\n+            r.delay(1000);\n+            EventQueue.invokeAndWait(() -> {\n+                r.mouseMove(tf.getLocationOnScreen().x + tf.getSize().width \/ 2,\n+                        tf.getLocationOnScreen().y + tf.getSize().height \/ 2);\n+            });\n+            r.waitForIdle();\n+            r.delay(500);\n+            EventQueue.invokeAndWait(() -> {\n+                r.mouseMove(c.getLocationOnScreen().x + c.getSize().width - 4,\n+                        c.getLocationOnScreen().y + c.getSize().height \/ 2);\n+                r.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                r.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            });\n+            r.waitForIdle();\n+            r.delay(500);\n+            EventQueue.invokeAndWait(() -> {\n+                r.mouseMove(d.getLocationOnScreen().x + d.getSize().width \/ 2,\n+                        d.getLocationOnScreen().y + d.getSize().height \/ 2);\n+                r.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                r.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+                r.keyPress(KeyEvent.VK_A);\n+                r.keyRelease(KeyEvent.VK_A);\n+            });\n+            r.waitForIdle();\n+            r.delay(500);\n+            if (!mouseOK) {\n+                throw new RuntimeException(\"Test Failed due to Mouse release failure!\");\n+            }\n+            if (!keyOK) {\n+                throw new RuntimeException(\"Test Failed due to Key release failure!\");\n+            }\n+            System.out.println(\"Test Passed!\");\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (d != null) {\n+                    d.dispose();\n+                }\n+                if (f != null) {\n+                    f.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/ChoiceModalDialogTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.WindowEvent;\n+import java.awt.event.WindowAdapter;\n+\n+\/*\n+ * @test\n+ * @bug 4336913\n+ * @summary On Windows, disable parent window controls while modal dialog is being created.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual ClosingParentTest\n+ *\/\n+\n+public class ClosingParentTest {\n+\n+    static String instructions = \"\"\"\n+            When the test starts, you will see a Frame with a Button\n+            titled 'Show modal dialog with delay'. Press this button\n+            and before the modal Dialog is shown, try to close the\n+            Frame using X button or system menu for windowing systems\n+            which don't provide X button in Window decorations. The\n+            delay before Dialog showing is 5 seconds.\n+            If in test output you see message about WINDOW_CLOSING\n+            being dispatched, then test fails. If no such message\n+            is printed, the test passes.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"ClosingParentTest\")\n+                .instructions(instructions)\n+                .testTimeOut(5)\n+                .rows(10)\n+                .columns(35)\n+                .testUI(ClosingParentTest::createGUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Frame createGUI() {\n+        Frame frame = new Frame(\"Main Frame\");\n+        Dialog dialog = new Dialog(frame, true);\n+\n+        Button button = new Button(\"Show modal dialog with delay\");\n+        button.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent e) {\n+                try {\n+                    Thread.currentThread().sleep(5000);\n+                } catch (InterruptedException x) {\n+                    x.printStackTrace();\n+                }\n+\n+                dialog.setVisible(true);\n+            }\n+        });\n+        frame.add(button);\n+        frame.pack();\n+        frame.addWindowListener(new WindowAdapter() {\n+            public void windowClosing(WindowEvent e) {\n+                System.out.println(\"WINDOW_CLOSING dispatched on the frame\");\n+            }\n+        });\n+\n+        dialog.setSize(100, 100);\n+        dialog.addWindowListener(new WindowAdapter() {\n+            public void windowClosing(WindowEvent e) {\n+                dialog.dispose();\n+            }\n+        });\n+\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/ClosingParentTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+\n+\/*\n+ * @test\n+ * @bug 4964237\n+ * @requires (os.family == \"windows\")\n+ * @summary Win: Changing theme changes java dialogs title icon\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DefaultIconTest\n+ *\/\n+\n+public class DefaultIconTest {\n+    static String instructions = \"\"\"\n+                    This test shows frame and two dialogs\n+                    Change windows theme. Resizable dialog should retain default icon\n+                    Non-resizable dialog should retain no icon\n+                    Press PASS if icons look correct, FAIL otherwise\n+                    \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"ShownModalDialogSerializationTest Instructions\")\n+                .instructions(instructions)\n+                .testTimeOut(5)\n+                .rows(10)\n+                .columns(35)\n+                .testUI(DefaultIconTest::createGUIs)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Frame createGUIs() {\n+        Frame f = new Frame(\"DefaultIconTest\");\n+        f.setSize(200, 100);\n+        Dialog d1 = new Dialog(f, \"Resizable Dialog, should show default icon\");\n+        d1.setSize(200, 100);\n+        d1.setVisible(true);\n+        d1.setLocation(0, 150);\n+        Dialog d2 = new Dialog(f, \"Non-resizable dialog, should have no icon\");\n+        d2.setSize(200, 100);\n+        d2.setVisible(true);\n+        d2.setResizable(false);\n+        d2.setLocation(0, 300);\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/DefaultIconTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4255230 4191946\n+ * @summary Tests to verify Dialog inherits background from its owner\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DialogBackgroundTest\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Dialog;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+import java.awt.TextField;\n+import java.awt.Window;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+\n+public class DialogBackgroundTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                Perform the following steps:\n+                1) Select \"New Frame\" from the \"File\" menu of the\n+                   \"TreeCopy Frame #1\" frame.\n+                2) Select \"Configure\" from the \"File\" menu in the\n+                   *new* frame.\n+                   If label text \"This is a label:\" in the appeared\n+                   \"Configuration Dialog\" dialog has a grey background\n+                   test PASSES, otherwise it FAILS\n+                   \"\"\";\n+        TreeCopy treeCopy = new TreeCopy(++TreeCopy.windowCount, null);\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(treeCopy)\n+                .logArea(8)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n+\n+class TreeCopy extends Frame implements ActionListener {\n+    TextField tfRoot;\n+    ConfigDialog configDlg;\n+    MenuItem miConfigure = new MenuItem(\"Configure...\");\n+    MenuItem miNewWindow = new MenuItem(\"New Frame\");\n+    static int windowCount = 0;\n+    Window parent;\n+\n+    public TreeCopy(int windowNum, Window myParent) {\n+        super();\n+        setTitle(\"TreeCopy Frame #\" + windowNum);\n+        MenuBar mb = new MenuBar();\n+        Menu m = new Menu(\"File\");\n+        configDlg = new ConfigDialog(this);\n+        parent = myParent;\n+\n+        m.add(miConfigure);\n+        m.add(miNewWindow);\n+        miConfigure.addActionListener(this);\n+        miNewWindow.addActionListener(this);\n+        mb.add(m);\n+        setMenuBar(mb);\n+        m.addActionListener(this);\n+\n+        tfRoot = new TextField();\n+        tfRoot.setEditable(false);\n+        add(tfRoot);\n+\n+        addWindowListener(new WindowAdapter() {\n+            public void windowClosing(WindowEvent we) {\n+                dispose();\n+            }\n+        });\n+\n+        setSize(200, 100);\n+        setLocationRelativeTo(parent);\n+    }\n+\n+    public void actionPerformed(ActionEvent ae) {\n+        Object source = ae.getSource();\n+\n+        if (source == miConfigure) {\n+            configDlg.setVisible(true);\n+            if (configDlg.getBackground() != configDlg.labelColor)\n+                PassFailJFrame.log(\"FAIL: Test failed!!!\");\n+        } else if (source == miNewWindow) {\n+            new TreeCopy(++windowCount, this).setVisible(true);\n+        }\n+    }\n+}\n+\n+class ConfigDialog extends Dialog implements ActionListener {\n+    public Button okButton;\n+    public Button cancelButton;\n+    public Label l2;\n+    public Color labelColor;\n+\n+    public ConfigDialog(Frame parent) {\n+        super(parent, \"Configuration Dialog\");\n+        okButton = new Button(\"OK\");\n+        cancelButton = new Button(\"Cancel\");\n+        l2 = new Label(\"This is a label:\");\n+\n+        setLayout(new FlowLayout());\n+        add(l2);\n+        add(okButton);\n+        add(cancelButton);\n+\n+        okButton.addActionListener(this);\n+        cancelButton.addActionListener(this);\n+\n+        pack();\n+        labelColor = l2.getBackground();\n+    }\n+\n+    public void actionPerformed(ActionEvent ae) {\n+        dispose();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/DialogBackgroundTest.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.Image;\n+import java.awt.Label;\n+import java.awt.MediaTracker;\n+import java.awt.Toolkit;\n+import java.awt.Window;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @bug 4779641\n+ * @summary Test to verify that Non-resizable dialogs should not show icons\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DialogIconTest\n+ *\/\n+\n+public class DialogIconTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. This is a Windows-only test of Dialog icons\n+                2. You can see a frame with a swing icon and two dialogs that it\n+                   owns. The resizable dialog should have the same icon as the\n+                   frame. The non-resizable dialog should have no icon at all\n+                3. Press PASS if this is true, press FAIL otherwise\n+                 \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static List<Window> initialize() {\n+        Frame f = new Frame(\"Parent frame\");\n+        f.setBounds(50, 50, 200, 200);\n+\n+        Dialog dr = new Dialog(f, \"Resizable Dialog\");\n+        dr.setLocation(100, 100);\n+        dr.add(new Label(\"Should inherit icon from parent\"));\n+        dr.pack();\n+\n+        Dialog dn = new Dialog(f, \"NON Resizable Dialog\");\n+        dn.setLocation(150, 150);\n+        dn.add(new Label(\"Should have no icon\"));\n+        dn.pack();\n+        dn.setResizable(false);\n+\n+        String fileName = System.getProperty(\"test.src\") +\n+                System.getProperty(\"file.separator\") + \"swing.small.gif\";\n+\n+        Image icon = Toolkit.getDefaultToolkit().createImage(fileName);\n+        MediaTracker tracker = new MediaTracker(f);\n+        tracker.addImage(icon, 0);\n+        try {\n+            tracker.waitForAll();\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(\"MediaTracker addImage Interrupted!\");\n+        }\n+        f.setIconImage(icon);\n+        return List.of(f, dn, dr);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/DialogIconTest\/DialogIconTest.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/awt\/Dialog\/DialogIconTest\/swing.small.gif","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/javax\/swing\/JTable\/4170447\/swing.small.gif","status":"copied"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dialog;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.event.ComponentEvent;\n+import java.awt.event.ComponentListener;\n+\n+\/*\n+ * @test\n+ * @bug 4912551\n+ * @summary Checks that with resizable set to false before show()\n+ *          dialog can not be resized.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DialogInitialResizability\n+ *\/\n+\n+public class DialogInitialResizability {\n+    static String instructions = \"\"\"\n+                    When this test is run a dialog will display (setResizable Test).\n+                    This dialog should not be resizable.\n+\n+                    Additionally ensure that there are NO componentResized events in the log section.\n+                    If the above conditions are true, then Press PASS else FAIL.\n+                    \"\"\";\n+\n+    private static final Dimension INITIAL_SIZE = new Dimension(400, 150);\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"DialogInitialResizability\")\n+                .instructions(instructions)\n+                .testTimeOut(5)\n+                .rows((int) instructions.lines().count() + 2)\n+                .columns(40)\n+                .testUI(DialogInitialResizability::createGUI)\n+                .logArea()\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static MyDialog createGUI() {\n+        Frame f = new Frame(\"invisible dialog owner\");\n+\n+        MyDialog ld = new MyDialog(f);\n+        ld.setBounds(100, 100, INITIAL_SIZE.width, INITIAL_SIZE.height);\n+        ld.setResizable(false);\n+\n+        PassFailJFrame.log(\"Dialog isResizable is set to: \" + ld.isResizable());\n+        PassFailJFrame.log(\"Dialog Initial Size \" + ld.getSize());\n+        return ld;\n+    }\n+\n+    private static class MyDialog extends Dialog implements ComponentListener {\n+        public MyDialog(Frame f) {\n+            super(f, \"setResizable test\", false);\n+            this.addComponentListener(this);\n+        }\n+\n+        public void componentResized(ComponentEvent e) {\n+            if (!e.getComponent().getSize().equals(INITIAL_SIZE)) {\n+                PassFailJFrame.log(\"Component Resized. Test Failed!!\");\n+            }\n+        }\n+\n+        public void componentMoved(ComponentEvent e) {\n+        }\n+\n+        public void componentShown(ComponentEvent e) {\n+        }\n+\n+        public void componentHidden(ComponentEvent e) {\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/DialogInitialResizability.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.Dialog;\n+import java.awt.Event;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Window;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @bug 4058370\n+ * @summary Test to verify Modality of Dialog\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DialogModalityTest\n+ *\/\n+\n+public class DialogModalityTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. When the test is running, there will be a Frame, a Modal Dialog\n+                   and a Window that is Modal Dialog's parent.\n+                2. Verify that it is impossible to bring up the menu in Frame before\n+                   closing the Modal Dialog.\n+                \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static List<Window> initialize() {\n+        Frame f = new Frame(\"Parent Frame\");\n+        DialogTest dlg = new DialogTest(f, \"Modal Dialog\");\n+        f.add(new Button(\"push me\"));\n+        f.setSize(200, 200);\n+        f.setLocation(210, 1);\n+        dlg.setBounds(210, 203, 200, 200);\n+        return List.of(f, dlg);\n+    }\n+}\n+\n+class DialogTest extends Dialog {\n+    Button closeButton;\n+    Frame parent;\n+\n+    public DialogTest(Frame parent, String title) {\n+        this(parent, title, true);\n+    }\n+\n+    public DialogTest(Frame parent, String title, boolean modal) {\n+        super(parent, title, modal);\n+        this.parent = parent;\n+        setLayout(new BorderLayout());\n+        Panel buttonPanel = new Panel();\n+        closeButton = new Button(\"Close\");\n+        buttonPanel.add(closeButton);\n+        add(\"Center\", buttonPanel);\n+        pack();\n+    }\n+\n+    public boolean action(Event e, Object arg) {\n+        if (e.target == closeButton) {\n+            Dialog dialog = null;\n+            Component c = (Component) e.target;\n+\n+            while (c != null && !(c instanceof Dialog)) {\n+                c = c.getParent();\n+            }\n+\n+            if (c != null) {\n+                dialog = (Dialog) c;\n+            }\n+\n+            if (dialog == null) {\n+                return false;\n+            }\n+\n+            dialog.setVisible(false);\n+            dialog.dispose();\n+            return true;\n+        }\n+        return false;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/DialogModalityTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Checkbox;\n+import java.awt.Dialog;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.TextArea;\n+import java.awt.event.ComponentEvent;\n+import java.awt.event.ComponentListener;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+import java.lang.Exception;\n+import java.lang.String;\n+import java.lang.System;\n+\n+\/*\n+ * @test\n+ * @bug 4115213\n+ * @summary Test to verify Checks that with resizable set to false,\n+ *          dialog can not be resized\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DialogResizeTest\n+ *\/\n+\n+public class DialogResizeTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. When this test is run a dialog will display (setResizable Test)\n+                   Click on the checkbox to change the dialog resizable state\n+                2. For both dialog resizable states (resizable, non-resizable) try to\n+                   change the size of the dialog. When isResizable is true the dialog\n+                   is resizable. When isResizable is false the dialog is non-resizable\n+                3. If this is the behavior that you observe, the test has passed, Press\n+                   the Pass button. Otherwise the test has failed, Press the Fail button\n+                \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(40)\n+                .testUI(initialize())\n+                .logArea(8)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Dialog initialize() {\n+        Frame f = new Frame(\"Owner Frame\");\n+        MyDialog ld = new MyDialog(f);\n+        ld.setBounds(100, 100, 400, 150);\n+        ld.setResizable(false);\n+        System.out.println(\"isResizable is set to: \" + ld.isResizable());\n+        return ld;\n+    }\n+}\n+\n+class MyDialog extends Dialog implements ItemListener {\n+    String sText = \"Tests java.awt.Dialog.setResizable method\";\n+    TextArea ta = new TextArea(sText, 2, 40, TextArea.SCROLLBARS_NONE);\n+\n+    public MyDialog(Frame f) {\n+\n+        super(f, \"setResizable test\", false);\n+\n+        Panel cbPanel = new Panel();\n+        cbPanel.setLayout(new FlowLayout());\n+\n+        Panel taPanel = new Panel();\n+        taPanel.setLayout(new FlowLayout());\n+        taPanel.add(ta);\n+\n+        Checkbox cb = new Checkbox(\"Check this box to change the dialog's \" +\n+                \"resizable state\", null, isResizable());\n+        cb.setState(false);\n+        cb.addItemListener(this);\n+        cbPanel.add(cb);\n+\n+        add(\"North\", taPanel);\n+        add(\"South\", cbPanel);\n+        pack();\n+    }\n+\n+    public void itemStateChanged(ItemEvent evt) {\n+        setResizable(evt.getStateChange() == ItemEvent.SELECTED);\n+\n+        boolean bResizeState = isResizable();\n+        PassFailJFrame.log(\"isResizable is set to: \" + bResizeState);\n+\n+        if (isResizable()) {\n+            ta.setText(\"dialog is resizable (isResizable = \" + bResizeState + \")\");\n+        } else {\n+            ta.setText(\"dialog is NOT resizable (isResizable = \" + bResizeState + \")\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/DialogResizeTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+\n+\/*\n+ * @test\n+ * @bug 4172302\n+ * @summary Test to make sure non-resizable Dialogs can be resized with the\n+ *          setSize() method.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DialogResizeTest2\n+ *\/\n+\n+public class DialogResizeTest2 {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                This tests the programmatic resizability of non-resizable Dialogs\n+                Even when a Dialog is set to be non-resizable, it should be\n+                programmatically resizable using the setSize() method.\n+\n+                1. Initially the Dialog will be resizable.  Try using the \\\\\"Smaller\\\\\"\n+                   and \\\\\"Larger\\\\\" buttons to verify that the Dialog resizes correctly\n+                2. Then, click the \\\\\"Toggle\\\\\" button to make the Dialog non-resizable\n+                3. Again, verify that clicking the \\\\\"Larger\\\\\" and \\\\\"Smaller\\\\\" buttons\n+                    causes the Dialog to get larger and smaller.  If the Dialog does\n+                    not change size, or does not re-layout correctly, the test FAILS\n+                \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .logArea(8)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Frame initialize() {\n+        Frame frame = new Frame(\"Parent Frame\");\n+        frame.add(new Button(\"Button\"));\n+        frame.setSize(100, 100);\n+        new dlg(frame).setVisible(true);\n+        return frame;\n+    }\n+\n+    static class dlg extends Dialog {\n+        public dlg(Frame f_) {\n+            super(f_, \"Dialog\", false);\n+            setSize(200, 200);\n+            Button bLarger = new Button(\"Larger\");\n+            bLarger.addActionListener(e -> setSize(400, 400));\n+            Button bSmaller = new Button(\"Smaller\");\n+            bSmaller.addActionListener(e -> setSize(200, 100));\n+            Button bCheck = new Button(\"Resizable?\");\n+            bCheck.addActionListener(e -> {\n+                if (isResizable()) {\n+                    PassFailJFrame.log(\"Dialog is resizable\");\n+                } else {\n+                    PassFailJFrame.log(\"Dialog is not resizable\");\n+                }\n+            });\n+            Button bToggle = new Button(\"Toggle\");\n+            bToggle.addActionListener(e -> {\n+                if (isResizable()) {\n+                    setResizable(false);\n+                    PassFailJFrame.log(\"Dialog is now not resizable\");\n+                } else {\n+                    setResizable(true);\n+                    PassFailJFrame.log(\"Dialog is now resizable\");\n+                }\n+            });\n+            setLayout(new GridLayout(1, 4));\n+            add(bSmaller);\n+            add(bLarger);\n+            add(bCheck);\n+            add(bToggle);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/DialogResizeTest2.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.event.WindowListener;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @bug 4058953 4094035\n+ * @summary Test to verify system menu of a dialog on win32\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DialogSystemMenu\n+ *\/\n+\n+public class DialogSystemMenu {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. Check the following on the first dialog window:\n+                    Right-clicking on the title bar\n+                    should bring up a system menu.\n+                    The system menu should not allow any\n+                    of the Maximize, Minimize and\n+                    Restore actions\n+\n+                2. The second dialog should be non-resizable\n+                    and have no application icon.\n+                \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static List<Dialog> initialize() {\n+        Frame frame = new java.awt.Frame(\"Parent Frame\");\n+        String txt = \"\"\"\n+                This is a resizable dialog\n+                Right-clicking on the title bar\n+                should bring up a system menu\n+                The system menu should not\n+                allow any\n+                of the Maximize, Minimize and\n+                Restore actions\n+                \"\"\";\n+        String txt_non = \"\"\"\n+                This is a non-resizable dialog\n+                It should be really non-resizable\n+                and have no application icon\n+                \"\"\";\n+        TestApp resizable = new TestApp(frame, \"Test for 4058953\", txt, true);\n+        resizable.setLocation(0, 0);\n+\n+        TestApp non_resizable = new TestApp(frame, \"Test for 4094035\", txt_non, false);\n+        non_resizable.setLocation(320, 0);\n+        return List.of(resizable, non_resizable);\n+    }\n+}\n+\n+\n+class TestApp extends Dialog implements WindowListener {\n+    public TestApp(java.awt.Frame parent, String title, String txt, boolean resize) {\n+        super(parent, title, false);\n+\n+        java.awt.TextArea ta = new java.awt.TextArea(txt);\n+        ta.setEditable(false);\n+        this.add(ta, \"Center\");\n+        this.addWindowListener(this);\n+        this.setSize(300, 200);\n+        this.setResizable(resize);\n+    }\n+\n+\n+    public void windowOpened(java.awt.event.WindowEvent myEvent) {\n+    }\n+\n+    public void windowClosed(java.awt.event.WindowEvent myEvent) {\n+    }\n+\n+    public void windowIconified(java.awt.event.WindowEvent myEvent) {\n+    }\n+\n+    public void windowDeiconified(java.awt.event.WindowEvent myEvent) {\n+    }\n+\n+    public void windowActivated(java.awt.event.WindowEvent myEvent) {\n+    }\n+\n+    public void windowDeactivated(java.awt.event.WindowEvent myEvent) {\n+    }\n+\n+    public void windowClosing(java.awt.event.WindowEvent myEvent) {\n+        this.dispose();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/DialogSystemMenu\/DialogSystemMenu.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"filename":"test\/jdk\/java\/awt\/Dialog\/DialogSystemMenu\/icon24x24.gif","binary":true,"status":"added"},{"filename":"test\/jdk\/java\/awt\/Dialog\/DialogSystemMenu\/iconone.gif","binary":true,"status":"added"},{"filename":"test\/jdk\/java\/awt\/Dialog\/DialogSystemMenu\/icontwo.gif","binary":true,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4232374\n+ * @summary Tests that dismissing a modal dialog does not enable\n+ *          disabled components\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual EnabledResetTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Dialog;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Window;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+public class EnabledResetTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. Press \"Create Child\" twice to create three windows\n+                   Verify that the parent windows are disabled\n+                2. Press \"Create Modal Dialog\"\n+                   Verify that the parent windows are disabled\n+                3. Press \"enable\"\n+                   Verify that no windows accept mouse events\n+                4. Press \"ok\"\n+                   Verify that the first window is still disabled\n+                   If all the verifications are done, then test is\n+                   PASSED, else test fails.\n+                   \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(new ChildDialog(1, null))\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n+\n+class ChildDialog extends Frame implements ActionListener {\n+    Window parent;\n+    int id;\n+    Button b, c, d;\n+\n+    public ChildDialog(int frameNumber, Window myParent) {\n+        super();\n+        id = frameNumber;\n+        parent = myParent;\n+\n+        setTitle(\"Frame Number \" + id);\n+\n+        b = new Button(\"Dismiss me\");\n+        c = new Button(\"Create Child\");\n+        d = new Button(\"Create Modal Dialog\");\n+\n+        setLayout(new BorderLayout());\n+        add(\"North\", c);\n+        add(\"Center\", d);\n+        add(\"South\", b);\n+        pack();\n+\n+        b.addActionListener(this);\n+        c.addActionListener(this);\n+        d.addActionListener(this);\n+    }\n+\n+    public void setVisible(boolean b) {\n+        if (parent != null) {\n+            if (b) {\n+                parent.setEnabled(false);\n+            } else {\n+                parent.setEnabled(true);\n+                parent.requestFocus();\n+            }\n+        }\n+\n+        super.setVisible(b);\n+    }\n+\n+    public void dispose() {\n+        if (parent != null) {\n+            parent.setEnabled(true);\n+            parent.requestFocus();\n+        }\n+        super.dispose();\n+    }\n+\n+\n+    public void actionPerformed(ActionEvent evt) {\n+        if (evt.getSource() == c) {\n+            (new ChildDialog(id + 1, this)).setVisible(true);\n+        } else if (evt.getSource() == d) {\n+            Dialog D = new Dialog(this, \"Modal Dialog \");\n+            D.setLayout(new FlowLayout());\n+            Button b = new Button(\"ok\");\n+            Button e = new Button(\"enable\");\n+            D.add(b);\n+            D.add(e);\n+            D.setModal(true);\n+            D.pack();\n+            b.addActionListener(this);\n+            e.addActionListener(this);\n+            D.setVisible(true);\n+        } else if (evt.getSource() == b) {\n+            dispose();\n+        } else if (evt.getSource() instanceof Button) {\n+            if (\"ok\".equals(evt.getActionCommand())) {\n+                Button target = (Button) evt.getSource();\n+                Window w = (Window) target.getParent();\n+                w.dispose();\n+            }\n+            if (\"enable\".equals(evt.getActionCommand())) {\n+                parent.setEnabled(true);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/EnabledResetTest.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.FileDialog;\n+import java.awt.Frame;\n+\n+\/*\n+ * @test\n+ * @bug 4177831\n+ * @summary solaris: default FileDialog title is not empty\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FileDialogEmptyTitleTest\n+ *\/\n+\n+public class FileDialogEmptyTitleTest {\n+    static String instructions = \"\"\"\n+            Test passes if title of file dialog is empty,\n+            otherwise test failed.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"FileDialogEmptyTitleTest\")\n+                .instructions(instructions)\n+                .testTimeOut(5)\n+                .rows(10)\n+                .columns(35)\n+                .testUI(FileDialogEmptyTitleTest::createGUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static FileDialog createGUI() {\n+        Frame frame = new Frame(\"invisible dialog owner\");\n+        FileDialog fileDialog = new FileDialog(frame);\n+        return fileDialog;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/FileDialogEmptyTitleTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.FileDialog;\n+import java.awt.Frame;\n+import java.io.File;\n+import java.io.FilenameFilter;\n+\n+\/*\n+ * @test\n+ * @bug 4364256\n+ * @summary Test to File Dialog filter\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FileDialogFilterTest\n+ *\/\n+\n+public class FileDialogFilterTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                   Run the test, make sure a file dialog\n+                   comes up with no crash. If the file dialog\n+                   comes up successfully then press PASS, else FAIL.\n+                \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static FileDialog initialize() {\n+        FileDialog fDlg = new FileDialog(new Frame());\n+        fDlg.addNotify();\n+        fDlg.setFilenameFilter(new MyFilter());\n+        return fDlg;\n+    }\n+}\n+\n+class MyFilter implements FilenameFilter {\n+    public boolean accept(File dir, String name) {\n+        return true;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/FileDialogFilterTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4414105\n+ * @summary Tests that FileDialog returns null when cancelled\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FileDialogGetFileTest\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.FileDialog;\n+import java.awt.Frame;\n+\n+public class FileDialogGetFileTest {\n+    static FileDialog fd;\n+    static Frame frame;\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. Open FileDialog from \"Show File Dialog\" button.\n+                2. Click cancel button without selecting any file\/folder.\n+                3. If FileDialog.getFile return null then test PASSES,\n+                   else test FAILS automatically.\n+                   \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .logArea(4)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Frame initialize() {\n+        frame = new Frame(\"FileDialog GetFile test\");\n+        fd = new FileDialog(frame);\n+        fd.setFile(\"FileDialogGetFileTest.html\");\n+        fd.setBounds(100, 100, 400, 400);\n+        Button showBtn = new Button(\"Show File Dialog\");\n+        frame.add(showBtn);\n+        frame.pack();\n+        showBtn.addActionListener(e -> {\n+            fd.setVisible(true);\n+            if (fd.getFile() != null) {\n+                PassFailJFrame.forceFail(\"Test failed: FileDialog returned non-null value\");\n+            } else {\n+                PassFailJFrame.log(\"Test Passed!\");\n+            }\n+        });\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/FileDialogGetFileTest.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,258 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.FileDialog;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Image;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.image.BufferedImage;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/*\n+ * @test\n+ * @bug 4035189\n+ * @summary Test to verify that PIT File Dialog icon not matching with\n+ *          the new java icon (frame Icon) - PIT build\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FileDialogIconTest\n+ *\/\n+\n+public class FileDialogIconTest {\n+    public static Frame frame;\n+    public static Image image;\n+    public static List<Image> images;\n+    static String fileBase;\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. Select the Image for a Dialog and Frame using either\n+                   Load\/Save\/Just Dialog.\n+                2. Set the Icon Image\/s to Frame and Dialog. Verify that the\n+                   Icon is set for the respective Frame and Dialog.\n+                   If selected Icon is set to Frame and Dialog press PASS\n+                   else FAIL.\n+                                \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .logArea(8)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static void setImagesToFD(java.util.List<Image> listIcon) {\n+        FileDialogIconTest.images = listIcon;\n+    }\n+\n+    public static void setImagesToFrame(java.util.List<Image> listIcon) {\n+        frame.setIconImages(listIcon);\n+    }\n+\n+    public static void setImageToFD(Image img) {\n+        FileDialogIconTest.image = img;\n+    }\n+\n+    public static void setImageToFrame(Image img) {\n+        frame.setIconImage(img);\n+    }\n+\n+    public static Frame initialize() {\n+        frame = new Frame(\"FileDialogIconTest\");\n+        Button setImageButton1 = new Button(\"setIconImageToFrame\");\n+        Button setImageButton2 = new Button(\"setIconImageToDialog\");\n+        Button setImageButton3 = new Button(\"setIconImagesToFrame\");\n+        Button setImageButton4 = new Button(\"setIconImagesToDialog\");\n+        Button setImageButton5 = new Button(\"setIconBufferedImagesToDialog\");\n+        Button setImageButton6 = new Button(\"setIconBufferedImagesToFrame\");\n+\n+        if (System.getProperty(\"test.src\") == null) {\n+            fileBase = \"\";\n+        } else {\n+            fileBase = System.getProperty(\"test.src\") + System.getProperty(\"file.separator\");\n+        }\n+\n+        final String fileName = fileBase + \"loading-msg.gif\";\n+\n+        setImageButton1.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent event) {\n+                try {\n+                    Image image = Toolkit.getDefaultToolkit().getImage(fileName);\n+                    setImageToFrame(image);\n+                    PassFailJFrame.log(\"Loaded image . setting to frame\");\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        });\n+\n+        setImageButton2.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent event) {\n+                try {\n+                    Image image = Toolkit.getDefaultToolkit().getImage(fileName);\n+                    setImageToFD(image);\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        });\n+\n+        setImageButton3.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent event) {\n+                try {\n+                    Image image;\n+                    java.util.List<Image> list = new java.util.ArrayList();\n+                    for (int i = 1; i <= 4; i++) {\n+                        String fileName = fileBase + \"T\" + i + \".gif\";\n+                        image = Toolkit.getDefaultToolkit().getImage(fileName);\n+                        PassFailJFrame.log(\"Loaded image \" + fileName + \". setting to the list for frame\");\n+                        list.add(image);\n+                    }\n+                    setImagesToFrame(list);\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        });\n+\n+\n+        setImageButton4.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent event) {\n+                try {\n+                    Image image;\n+                    List<Image> list = new ArrayList<>();\n+                    for (int i = 1; i <= 4; i++) {\n+                        String fileName = fileBase + \"T\" + i + \".gif\";\n+                        image = Toolkit.getDefaultToolkit().getImage(fileName);\n+                        PassFailJFrame.log(\"Loaded image \" + fileName + \". setting to the list for dialog\");\n+                        list.add(image);\n+                    }\n+                    setImagesToFD(list);\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        });\n+\n+\n+        setImageButton5.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent event) {\n+                List<BufferedImage> list = new ArrayList<>();\n+                try {\n+                    Robot robot = new Robot();\n+                    Rectangle rectangle;\n+                    for (int i = 1; i <= 4; i++) {\n+                        rectangle = new Rectangle(i * 10, i * 10, i * 10 + 40, i * 10 + 40);\n+                        java.awt.image.BufferedImage image = robot.createScreenCapture(rectangle);\n+                        robot.delay(100);\n+                        list.add(image);\n+                    }\n+                } catch (Throwable t) {\n+                    t.printStackTrace();\n+                }\n+                PassFailJFrame.log(\"Captured images and set to the list for dialog\");\n+            }\n+        });\n+\n+        setImageButton6.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent event) {\n+                List<BufferedImage> list = new ArrayList<>();\n+                try {\n+                    Robot robot = new Robot();\n+                    Rectangle rectangle;\n+                    for (int i = 1; i <= 4; i++) {\n+                        rectangle = new Rectangle(i * 10, i * 10, i * 10 + 40, i * 10 + 40);\n+                        java.awt.image.BufferedImage image = robot.createScreenCapture(rectangle);\n+                        robot.delay(100);\n+                        list.add(image);\n+                    }\n+                } catch (Throwable t) {\n+                    t.printStackTrace();\n+                }\n+                PassFailJFrame.log(\"Captured images and set to the list for frame\");\n+            }\n+        });\n+\n+        Button buttonLoad = new Button(\"Load Dialog\");\n+        Button buttonSave = new Button(\"Save Dialog\");\n+        Button buttonSimple = new Button(\"Just Dialog\");\n+        buttonLoad.addActionListener(new MyActionListener(FileDialog.LOAD, \"LOAD\"));\n+        buttonSave.addActionListener(new MyActionListener(FileDialog.SAVE, \"SAVE\"));\n+        buttonSimple.addActionListener(new MyActionListener(-1, \"\"));\n+\n+        frame.setSize(400, 400);\n+        frame.setLayout(new FlowLayout());\n+        frame.add(buttonLoad);\n+        frame.add(buttonSave);\n+        frame.add(buttonSimple);\n+        frame.add(setImageButton1);\n+        frame.add(setImageButton2);\n+        frame.add(setImageButton3);\n+        frame.add(setImageButton4);\n+        frame.pack();\n+        return frame;\n+    }\n+}\n+\n+class MyActionListener implements ActionListener {\n+    int id;\n+    String name;\n+\n+    public MyActionListener(int id, String name) {\n+        this.id = id;\n+        this.name = name;\n+    }\n+\n+    public void actionPerformed(ActionEvent ae) {\n+        try {\n+            FileDialog filedialog;\n+            if (id == -1 && Objects.equals(name, \"\")) {\n+                filedialog = new FileDialog(FileDialogIconTest.frame);\n+            } else {\n+                filedialog = new FileDialog(FileDialogIconTest.frame, name, id);\n+            }\n+            if (FileDialogIconTest.image != null) {\n+                filedialog.setIconImage(FileDialogIconTest.image);\n+            }\n+\n+            if (FileDialogIconTest.images != null) {\n+                filedialog.setIconImages(FileDialogIconTest.images);\n+            }\n+            filedialog.setVisible(true);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/FileDialogIconTest\/FileDialogIconTest.java","additions":258,"deletions":0,"binary":false,"changes":258,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/awt\/Dialog\/FileDialogIconTest\/T1.gif","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/demo\/share\/jfc\/SwingSet2\/resources\/images\/buttons\/b1.gif","status":"copied"},{"patch":"","filename":"test\/jdk\/java\/awt\/Dialog\/FileDialogIconTest\/T2.gif","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/demo\/share\/jfc\/SwingSet2\/resources\/images\/buttons\/b1p.gif","status":"copied"},{"patch":"","filename":"test\/jdk\/java\/awt\/Dialog\/FileDialogIconTest\/T3.gif","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/demo\/share\/jfc\/SwingSet2\/resources\/images\/buttons\/b2.gif","status":"copied"},{"patch":"","filename":"test\/jdk\/java\/awt\/Dialog\/FileDialogIconTest\/T4.gif","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/demo\/share\/jfc\/SwingSet2\/resources\/images\/buttons\/b3.gif","status":"copied"},{"filename":"test\/jdk\/java\/awt\/Dialog\/FileDialogIconTest\/loading-msg.gif","binary":true,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.FileDialog;\n+import java.awt.Frame;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+\/*\n+ * @test\n+ * @bug 4859390\n+ * @requires (os.family == \"windows\")\n+ * @summary Verify that FileDialog matches the look\n+    of the native windows FileDialog\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FileDialogUIUpdate\n+ *\/\n+\n+public class FileDialogUIUpdate extends Frame {\n+    static String instructions = \"\"\"\n+            Click the button to show the FileDialog. Then open the Paint\n+            application (usually found in Program Files->Accessories).\n+            Select File->Open from Paint to display a native Open dialog.\n+            Compare the native dialog to the AWT FileDialog.\n+            Specifically, confirm that the Places Bar icons are along the left side (or\n+            not, if the native dialog doesn't have them), and that the\n+            dialogs are both resizable (or not).\n+            If the file dialogs both look the same press Pass.  If not,\n+            press Fail.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"FileDialogUIUpdate\")\n+                .instructions(instructions)\n+                .testTimeOut(5)\n+                .rows(12)\n+                .columns(35)\n+                .testUI(FileDialogUIUpdate::new)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public FileDialogUIUpdate() {\n+        final FileDialog fd = new FileDialog(new Frame(\"FileDialogUIUpdate frame\"),\n+                \"Open FileDialog\");\n+        Button showButton = new Button(\"Show FileDialog\");\n+        setLayout(new BorderLayout());\n+\n+        fd.setDirectory(\"c:\/\");\n+        showButton.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent e) {\n+                fd.setVisible(true);\n+            }\n+        });\n+\n+        add(showButton);\n+        setSize(200, 200);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/FileDialogUIUpdate.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Checkbox;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Event;\n+import java.awt.FileDialog;\n+import java.awt.Frame;\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.Label;\n+import java.awt.Panel;\n+import java.awt.TextField;\n+import java.io.File;\n+import java.io.FilenameFilter;\n+\n+\/*\n+ * @test\n+ * @bug 4293697 4416433 4417139 4409600\n+ * @summary Test to verify that user filter always gets called on changing the\n+ *          directory in FileDialog\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FileDialogUserFilterTest\n+ *\/\n+\n+public class FileDialogUserFilterTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                        1. Enter a mask into the <filter> field, a directory into\n+                           the <directory> field (or leave the default values).\n+                        2. Then click the <Load> button, file dialog will appear.\n+                           Output of the user filter will be shown in the output\n+                           area. Enter several different directories to the file dialog\n+                           via double-clicking on the directory list. The output\n+                           area should show some filtering output on each directory\n+                           change. If any output was only given on dialog startup,\n+                           the test is FAILED.\n+                        3. Look at the list of files accepted by the filter.\n+                           If some files do not match the filter,\n+                           the test is FAILED.\n+                        4. Open dialog with an empty filter.\n+                           Enter some directories with a lot of files (like \/usr\/bin).\n+                           If dialog crashes the test is FAILED.\n+                           Enter the directory that contain files and other directories.\n+                           If the directories are shown in the files box along with files\n+                           then the test is FAILED.\n+                        5. Click in checkbox 'do not use filter', make it checked.\n+                           Open dialog, enter the directory with some files.\n+                           If no files is shown in the File list box (while you are sure\n+                           there are some files there) the test is FAILED\n+                           Otherwise it is PASSED.\"\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(new DialogFilterTest())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n+\n+class DialogFilterTest extends Frame implements FilenameFilter {\n+    FileDialog fd;\n+    static TextField tfDirectory = new TextField();\n+    static TextField tfFile = new TextField();\n+    static TextField tfFilter = new TextField();\n+    static Checkbox useFilterCheck = new Checkbox(\"do not use filter\");\n+\n+    public DialogFilterTest() {\n+        setTitle(\"File Dialog User Filter test\");\n+        add(\"North\", new Button(\"Load\"));\n+        Panel p = new Panel();\n+        p.setLayout(new GridBagLayout());\n+        addRow(p, new Label(\"directory:\", Label.RIGHT), tfDirectory);\n+        addRow(p, new Label(\"file:\", Label.RIGHT), tfFile);\n+        addRow(p, new Label(\"filter:\", Label.RIGHT), tfFilter);\n+        addRow(p, new Label(\"\"), useFilterCheck);\n+        tfFilter.setText(\".java\");\n+        tfDirectory.setText(\".\");\n+        add(\"Center\", p);\n+        setSize(300, 200);\n+    }\n+\n+    static void addRow(Container cont, Component c1, Component c2) {\n+        GridBagLayout gbl = (GridBagLayout) cont.getLayout();\n+        GridBagConstraints c = new GridBagConstraints();\n+        c.fill = GridBagConstraints.BOTH;\n+        cont.add(c1);\n+        gbl.setConstraints(c1, c);\n+\n+        c.gridwidth = GridBagConstraints.REMAINDER;\n+        c.weightx = 1.0;\n+        cont.add(c2);\n+        gbl.setConstraints(c2, c);\n+    }\n+\n+    public boolean accept(File dir, String name) {\n+        System.out.println(\"File \" + dir + \" String \" + name);\n+        if (fd.getMode() == FileDialog.LOAD) {\n+            return name.lastIndexOf(tfFilter.getText()) > 0;\n+        }\n+        return true;\n+    }\n+\n+    public boolean action(Event evt, Object what) {\n+        boolean load = \"Load\".equals(what);\n+\n+        if (load || \"Save\".equals(what)) {\n+            fd = new FileDialog(new Frame(), null,\n+                    load ? FileDialog.LOAD : FileDialog.SAVE);\n+            fd.setDirectory(tfDirectory.getText());\n+            fd.setFile(tfFile.getText());\n+            if (!useFilterCheck.getState()) {\n+                fd.setFilenameFilter(this);\n+            }\n+            fd.setVisible(true);\n+            tfDirectory.setText(fd.getDirectory());\n+            tfFile.setText(fd.getFile());\n+\n+            return true;\n+        }\n+        return false;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/FileDialogUserFilterTest.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Frame;\n+\n+\/*\n+ * @test\n+ * @bug 4779118\n+ * @summary Tests that FileDialog with wrong initial file name\n+ *          doesn't crash when Open button is pressed.\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FileDialogWrongNameCrash\n+ *\/\n+\n+public class FileDialogWrongNameCrash {\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                (This is Windows only test)\n+                1. You should see a frame 'Frame' with button 'Load'. Press button.\",\n+                2. You should see 'Load file' dialog, select any file and press 'Open'\",\n+                   (not 'Cancel'!!!). If Java doesn't crash - press PASS, else FAIL\n+                    \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame initialize() {\n+        Frame frame = new Frame(\"File Dialog Wrong Name Crash Test\");\n+        Button fileButton = new Button(\"Load\");\n+        fileButton.addActionListener(new java.awt.event.ActionListener() {\n+            public void actionPerformed(java.awt.event.ActionEvent e) {\n+                final java.awt.FileDialog selector =\n+                        new java.awt.FileDialog(frame);\n+                selector.setFile(\"Z:\\\\O2 XDA\\\\LogiTest\\\\\\\\Testcase.xml\");\n+                selector.setVisible(true);\n+            }\n+        });\n+        frame.add(fileButton);\n+        frame.setSize(100, 60);\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/FileDialogWrongNameCrash.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Window;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+\/*\n+ * @test\n+ * @bug 4168481\n+ * @summary Test to verify Dialog getLocation() regression on Solaris\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual GetLocationTest_1\n+ *\/\n+\n+public class GetLocationTest_1 {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. Click in in the blue square and the yellow window should come\n+                   up with the top left by the cursor\n+                2. If you see this correct behavior press PASS. If you see that\n+                   the yellow window location is offset by some inset, press FAIL\n+                   \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .logArea(8)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Dialog initialize() {\n+        Frame f = new Frame(\"Owner Frame\");\n+        ColorComponent blue = new ColorComponent();\n+        blue.setBackground(Color.blue);\n+        blue.setSize(50, 50);\n+\n+        final Dialog dialog = new Dialog(f, \"GetLocation test\");\n+        dialog.setLocation(300, 300);\n+        System.out.println(\"Dialog location = \" + dialog.getLocation());\n+        blue.setLocation(50, 50);\n+        dialog.setLayout(null);\n+        dialog.add(blue);\n+        dialog.setSize(200, 200);\n+\n+        final ColorWindow w = new ColorWindow(f);\n+        w.setSize(50, 50);\n+        w.setBackground(Color.yellow);\n+\n+        blue.addMouseListener(new MouseAdapter() {\n+            public void mousePressed(MouseEvent e) {\n+                PassFailJFrame.log(\"Dialog location = \" + dialog.getLocation());\n+                Point p = e.getPoint();\n+                Component c = e.getComponent();\n+                PassFailJFrame.log(\"Position = \" + p);\n+                convertPointToScreen(p, c);\n+                PassFailJFrame.log(\"Converted to = \" + p);\n+                w.setLocation(p.x, p.y);\n+                w.setVisible(true);\n+            }\n+        });\n+        return dialog;\n+    }\n+\n+    static class ColorComponent extends Component {\n+        public void paint(Graphics g) {\n+            g.setColor(getBackground());\n+            Rectangle bounds = getBounds();\n+            g.fillRect(0, 0, bounds.width, bounds.height);\n+        }\n+    }\n+\n+    static class ColorWindow extends Window {\n+        ColorWindow(Frame f) {\n+            super(f);\n+        }\n+\n+        public void paint(Graphics g) {\n+            g.setColor(getBackground());\n+            Rectangle bounds = getBounds();\n+            g.fillRect(0, 0, bounds.width, bounds.height);\n+        }\n+    }\n+\n+    public static void convertPointToScreen(Point p, Component c) {\n+        do {\n+            Point b = c.getLocation();\n+            PassFailJFrame.log(\"Adding \" + b + \" for \" + c);\n+            p.x += b.x;\n+            p.y += b.y;\n+\n+            if (c instanceof java.awt.Window) {\n+                break;\n+            }\n+            c = c.getParent();\n+        } while (c != null);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/GetLocationTest_1.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Dialog;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Panel;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+\/*\n+ * @test\n+ * @bug 4048664 4065506 4122094 4171979\n+ * @summary Test if Dialog can be successfully hidden, see that no other app\n+ *          comes to front, see if hide + dispose causes assertion failure\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual HideDialogTest\n+ *\/\n+\n+public class HideDialogTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. A Frame should appear with a \"test\" button in it\n+                2. Click on the \"test\" button. A Dialog will appear with a \"dismiss\" button\n+                   and a \"dismiss-with-dispose\" button\n+                3. First, click on the \"dismiss-with-dispose\" button. Verify that\n+                   no assertion failure appears.\n+                4. Now, click on the \"dismiss\" button. The Dialog should go away.\n+                5. Repeat from (2) 10-20 times.\n+                6. When the dialog goes away check that the frame window does not briefly\n+                   get obscured by another app or repaint it's entire area. There should be\n+                   no flicker at all in areas obscured by the dialog. (4065506 4122094)\n+                   If there is the test fails.\n+                7. If the Dialog is successfully hidden each time, the test passed.  If the\n+                   Dialog did not hide, the test failed (4048664).\n+\n+                NOTE: When the dialog does not go away (meaning the bug has manifested itself),\n+                the \"dismiss-with-dispose\" button can be used to get rid of it.\n+                \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(40)\n+                .testUI(new MyFrame())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n+\n+class MyDialog extends Dialog {\n+    public MyDialog(Frame f) {\n+        super(f, \"foobar\", true);\n+        setSize(200, 200);\n+        setLayout(new BorderLayout());\n+        Panel p = new Panel();\n+        p.setLayout(new FlowLayout(FlowLayout.CENTER));\n+        Button okButton;\n+        okButton = new Button(\"dismiss\");\n+        p.add(okButton);\n+        okButton.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent e) {\n+                System.out.println(\"Calling setVisible(false)\");\n+                setVisible(false);\n+            }\n+        });\n+        Button newButton;\n+        p.add(newButton = new Button(\"dismiss-with-dispose\"));\n+        newButton.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent e) {\n+                System.out.println(\"Calling setVisible(false) + dispose()\");\n+                setVisible(false);\n+                dispose();\n+            }\n+        });\n+        add(\"South\", p);\n+        pack();\n+    }\n+}\n+\n+class MyFrame extends Frame implements ActionListener {\n+    public MyFrame() {\n+        super();\n+        setSize(600, 400);\n+        setTitle(\"HideDialogTest\");\n+        setLayout(new BorderLayout());\n+        Panel toolbar = new Panel();\n+        toolbar.setLayout(new FlowLayout(FlowLayout.LEFT));\n+        Button testButton = new Button(\"test\");\n+        testButton.addActionListener(this);\n+        toolbar.add(testButton);\n+        add(\"North\", toolbar);\n+    }\n+\n+    public void actionPerformed(ActionEvent e) {\n+        String s = e.getActionCommand();\n+        if (s.equals(\"test\")) {\n+            System.out.println(\"Begin test\");\n+            MyDialog d = new MyDialog(this);\n+            d.setVisible(true);\n+            System.out.println(\"End test\");\n+        }\n+    }\n+\n+    public void paint(Graphics g) {\n+        for (int i = 0; i < 10; i++) {\n+            g.setColor(Color.red);\n+            g.fillRect(0, 0, 2000, 2000);\n+            g.setColor(Color.blue);\n+            g.fillRect(0, 0, 2000, 2000);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/HideDialogTest.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+\/*\n+ * @test\n+ * @bug 4070085\n+ * @summary Java program locks up X server\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MenuAndModalDialogTest\n+ *\/\n+\n+public class MenuAndModalDialogTest {\n+    static Frame frame;\n+    static String instructions = \"\"\"\n+            1. Bring up the File Menu and leave it up.\n+            2. In a few seconds, the modal dialog will appear.\n+            3. Verify that your system does not lock up when you push the \"OK\" button.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame pf = PassFailJFrame.builder()\n+                .title(\"MenuAndModalDialogTest\")\n+                .instructions(instructions)\n+                .testTimeOut(5)\n+                .rows(10)\n+                .columns(35)\n+                .testUI(MenuAndModalDialogTest::createFrame)\n+                .build();\n+\n+        \/\/ Allow time to pop up the menu\n+        try {\n+            Thread.currentThread().sleep(5000);\n+        } catch (InterruptedException exception) {\n+        }\n+\n+        createDialog();\n+        pf.awaitAndCheck();\n+    }\n+\n+    public static Frame createFrame() {\n+        frame = new Frame(\"MenuAndModalDialogTest frame\");\n+\n+        MenuBar menuBar = new MenuBar();\n+        frame.setMenuBar(menuBar);\n+\n+        Menu file = new Menu(\"File\");\n+        menuBar.add(file);\n+\n+        MenuItem menuItem = new MenuItem(\"A Menu Entry\");\n+        file.add(menuItem);\n+\n+        frame.setSize(200, 200);\n+        frame.setLocationRelativeTo(null);\n+        return frame;\n+    }\n+\n+    public static void createDialog() {\n+        Dialog dialog = new Dialog(frame);\n+\n+        Button button = new Button(\"OK\");\n+        dialog.add(button);\n+        button.addActionListener(\n+                new ActionListener() {\n+                    public void actionPerformed(ActionEvent e) {\n+                        dialog.dispose();\n+                    }\n+                }\n+        );\n+\n+        dialog.setSize(200, 200);\n+        dialog.setModal(true);\n+        dialog.setVisible(true);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/MenuAndModalDialogTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Checkbox;\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+\n+\/*\n+ * @test\n+ * @bug 4078176\n+ * @summary Test to verify Modal dialogs don't act modal if addNotify()\n+ *          is called before setModal(true).\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual ModalDialogTest\n+ *\/\n+\n+public class ModalDialogTest implements ActionListener {\n+    public boolean modal = true;\n+    Button closeBtn = new Button(\"Close me\");\n+    Button createBtn = new Button(\"Create Dialog\");\n+    Button createNewBtn = new Button(\"Create Modal Dialog\");\n+    Button lastBtn = new Button(\"Show Last Dialog\");\n+    Dialog dialog;\n+    Dialog newDialog;\n+    Frame testFrame;\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. Use 'Modal' checkbox to select which dialog you're\n+                   going to create - modal or non-modal.\n+                   (this checkbox affects only new created dialog but\n+                   not existing one)\n+                2. Use 'Create Dialog' button to create a dialog.\n+                   If you have selected 'Modal' checkbox then dialog has to\n+                   be created modal - you can make sure of that clicking\n+                   on any other control (i.e. 'Modal' checkbox) - they\n+                   should not work.\n+                3. Use 'Show Last Dialog' button to bring up last\n+                   created dialog - to make sure that if you show\/hide\n+                   modal dialog several times it stays modal.\n+                4. On the appearing dialog there are two buttons:\n+                   'Close Me' which closes the dialog,\n+                   and 'Create Modal Dialog' which creates one more\n+                   MODAL dialog just to make sure that\n+                   in situation with two modal dialogs all is fine.\n+                5. If created modal dialogs are really modal\n+                   (which means that they blocks the calling app)\n+                   then test is PASSED, otherwise it's FAILED.\"\n+                                 \"\"\";\n+        ModalDialogTest test = new ModalDialogTest();\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(test.initialize())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public Frame initialize() {\n+        testFrame = new Frame(\"Parent Frame\");\n+        Frame frame = new Frame(\"Modal Dialog test\");\n+        Panel panel = new Panel();\n+        panel.setLayout(new BorderLayout());\n+\n+        createBtn.addActionListener(this);\n+        createNewBtn.addActionListener(this);\n+        closeBtn.addActionListener(this);\n+        lastBtn.addActionListener(this);\n+        panel.add(\"Center\", createBtn);\n+        panel.add(\"South\", lastBtn);\n+        Checkbox cb = new Checkbox(\"Modal\", modal);\n+        cb.addItemListener(new ItemListener() {\n+            public void itemStateChanged(ItemEvent e) {\n+                modal = ((Checkbox) e.getSource()).getState();\n+            }\n+        });\n+        panel.add(\"North\", cb);\n+        panel.setSize(200, 100);\n+\n+        frame.add(panel);\n+        frame.pack();\n+        return frame;\n+    }\n+\n+    public void actionPerformed(ActionEvent e) {\n+        if (e.getSource() == createBtn) {\n+            if (dialog != null) {\n+                dialog.dispose();\n+            }\n+            dialog = new Dialog(testFrame, \"Modal Dialog\");\n+            dialog.add(\"North\", closeBtn);\n+            dialog.add(\"South\", createNewBtn);\n+            createBtn.setEnabled(false);\n+            dialog.pack();\n+            dialog.setModal(modal);\n+            dialog.setVisible(true);\n+        } else if (e.getSource() == closeBtn && dialog != null) {\n+            createBtn.setEnabled(true);\n+            dialog.setVisible(false);\n+        } else if (e.getSource() == lastBtn && dialog != null) {\n+            dialog.setVisible(true);\n+        } else if (e.getSource() == createNewBtn && newDialog == null) {\n+            newDialog = new Dialog(testFrame, \"New Modal Dialog\");\n+            Button clsBtn = new Button(\"Close Me\");\n+            clsBtn.addActionListener(new ActionListener() {\n+                public void actionPerformed(ActionEvent e) {\n+                    newDialog.dispose();\n+                    newDialog = null;\n+                }\n+            });\n+            newDialog.add(\"North\", clsBtn);\n+            newDialog.pack();\n+            newDialog.setModal(true);\n+            newDialog.setVisible(true);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/ModalDialogTest.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -0,0 +1,312 @@\n+\/*\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Choice;\n+import java.awt.Dialog;\n+import java.awt.FileDialog;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+import java.awt.List;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Window;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.util.Vector;\n+import java.util.Enumeration;\n+\n+\/*\n+ * @test\n+ * @bug 4110094 4178930 4178390\n+ * @summary Test: Rewrite of Win modal dialogs\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual NestedDialogTest\n+ *\/\n+\n+public class NestedDialogTest {\n+    private static Vector windows = new Vector();\n+    static String instructions = \"\"\"\n+            To solve various race conditions, windows modal dialogs were rewritten. This\n+            test exercises various modal dialog boundary conditions and checks that\n+            previous fixes to modality are incorporated in the rewrite.\n+\n+            Check the following:\n+            - No IllegalMonitorStateException is thrown when a dialog closes\n+\n+            - Open multiple nested dialogs and verify that all other windows\n+            are disabled when modal dialog is active.\n+\n+            - Check that the proper window is activated when a modal dialog closes.\n+\n+            - Close nested dialogs out of order (e.g. close dialog1 before dialog2)\n+            and verify that this works and no deadlock occurs.\n+\n+            - Check that all other windows are disabled when a FileDialog is open.\n+\n+            - Check that the proper window is activated when a FileDialog closes.\n+\n+            - Verify that the active window nevers switches to another application\n+            when closing dialogs, even temporarily.\n+\n+            - Check that choosing Hide always sucessfully hides a dialog. You should\n+            try this multiple times to catch any race conditions.\n+\n+            - Check that the scrollbar on the Choice component in the dialog works, as opposed\n+              to just using drag-scrolling or the cursor keys\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"NestedDialogTest\")\n+                .instructions(instructions)\n+                .testTimeOut(5)\n+                .rows((int) instructions.lines().count() + 2)\n+                .columns(35)\n+                .testUI(NestedDialogTest::createGUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Frame createGUI() {\n+        Frame frame1 = new NestedDialogTestFrame(\"frame0\");\n+        Frame frame2 = new NestedDialogTestFrame(\"frame1\");\n+        frame2.setLocation(100, 100);\n+        return frame1;\n+    }\n+\n+    public static void addWindow(Window window) {\n+        \/\/ System.out.println(\"Pushing window \" + window);\n+        windows.removeElement(window);\n+        windows.addElement(window);\n+    }\n+\n+    public static void removeWindow(Window window) {\n+        \/\/ System.out.println(\"Popping window \" + window);\n+        windows.removeElement(window);\n+    }\n+\n+    public static Window getWindow(int index) {\n+        return (Window) windows.elementAt(index);\n+    }\n+\n+    public static Enumeration enumWindows() {\n+        return windows.elements();\n+    }\n+\n+    public static int getWindowIndex(Window win) {\n+        return windows.indexOf(win);\n+    }\n+}\n+\n+class NestedDialogTestFrame extends Frame {\n+    NestedDialogTestFrame(String name) {\n+        super(name);\n+        setSize(200, 200);\n+        show();\n+\n+        setLayout(new FlowLayout());\n+        Button btnDlg = new Button(\"Dialog...\");\n+        add(btnDlg);\n+        Button btnFileDlg = new Button(\"FileDialog...\");\n+        add(btnFileDlg);\n+\n+        addWindowListener(new WindowAdapter() {\n+            public void windowClosing(WindowEvent ev) {\n+                System.exit(0);\n+            }\n+        });\n+\n+        btnDlg.addActionListener(\n+                new ActionListener() {\n+                    public void actionPerformed(ActionEvent e) {\n+                        Dialog d1 = new SimpleDialog(NestedDialogTestFrame.this, null, true);\n+                        System.out.println(\"Returned from showing dialog: \" + d1);\n+                    }\n+                }\n+        );\n+\n+        btnFileDlg.addActionListener(\n+                new ActionListener() {\n+                    public void actionPerformed(ActionEvent e) {\n+                        FileDialog dlg = new FileDialog(NestedDialogTestFrame.this);\n+                        dlg.show();\n+                    }\n+                }\n+        );\n+\n+        validate();\n+    }\n+\n+    public void show() {\n+        if (!isVisible()) {\n+            NestedDialogTest.addWindow(this);\n+        }\n+        super.show();\n+    }\n+\n+    public void dispose() {\n+        NestedDialogTest.removeWindow(this);\n+        super.dispose();\n+    }\n+}\n+\n+class SimpleDialog extends Dialog {\n+    Button btnNested;\n+    Button btnFileDlg;\n+    Button btnShow;\n+    Button btnHide;\n+    Button btnDispose;\n+    Button btnExit;\n+    List listWins;\n+    Dialog dlgPrev;\n+\n+    public SimpleDialog(Frame frame, Dialog prev, boolean isModal) {\n+        super(frame, \"\", isModal);\n+\n+        dlgPrev = prev;\n+\n+        addWindowListener(new WindowAdapter() {\n+            public void windowActivated(WindowEvent ev) {\n+                populateListWin();\n+            }\n+        });\n+\n+        setTitle(getName());\n+\n+        Panel panelNorth = new Panel();\n+        panelNorth.setLayout(new GridLayout(1, 1));\n+        listWins = new List();\n+        panelNorth.add(listWins);\n+\n+        Panel panelSouth = new Panel();\n+        panelSouth.setLayout(new FlowLayout());\n+        btnNested = new Button(\"Dialog...\");\n+        panelSouth.add(btnNested);\n+        btnFileDlg = new Button(\"FileDialog...\");\n+        panelSouth.add(btnFileDlg);\n+        btnShow = new Button(\"Show\");\n+        panelSouth.add(btnShow);\n+        btnHide = new Button(\"Hide\");\n+        panelSouth.add(btnHide);\n+        btnDispose = new Button(\"Dispose\");\n+        panelSouth.add(btnDispose);\n+\n+        Choice cbox = new Choice();\n+        cbox.add(\"Test1\");\n+        cbox.add(\"Test2\");\n+        cbox.add(\"Test3\");\n+        cbox.add(\"Test4\");\n+        cbox.add(\"Test5\");\n+        cbox.add(\"Test6\");\n+        cbox.add(\"Test7\");\n+        cbox.add(\"Test8\");\n+        cbox.add(\"Test9\");\n+        cbox.add(\"Test10\");\n+        cbox.add(\"Test11\");\n+        panelSouth.add(cbox);\n+\n+        validate();\n+\n+        add(\"Center\", panelNorth);\n+        add(\"South\", panelSouth);\n+\n+        btnNested.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent e) {\n+                Dialog dlg = new SimpleDialog((Frame) getParent(), SimpleDialog.this, true);\n+                System.out.println(\"Returned from showing dialog: \" + dlg);\n+            }\n+        });\n+\n+        btnFileDlg.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent e) {\n+                FileDialog dlg = new FileDialog((Frame) getParent());\n+                dlg.show();\n+            }\n+        });\n+\n+        btnHide.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent e) {\n+                Window wnd = getSelectedWindow();\n+                System.out.println(wnd);\n+                wnd.hide();\n+            }\n+        });\n+\n+        btnShow.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent e) {\n+                getSelectedWindow().show();\n+            }\n+        });\n+\n+        btnDispose.addActionListener(new ActionListener() {\n+            public void actionPerformed(ActionEvent e) {\n+                getSelectedWindow().dispose();\n+                populateListWin();\n+            }\n+        });\n+\n+        pack();\n+        setSize(getSize().width, getSize().height * 2);\n+        if (dlgPrev != null) {\n+            Point pt = dlgPrev.getLocation();\n+            setLocation(pt.x + 30, pt.y + 50);\n+        }\n+        show();\n+    }\n+\n+    private Window getSelectedWindow() {\n+        Window window;\n+        int index = listWins.getSelectedIndex();\n+\n+        window = NestedDialogTest.getWindow(index);\n+        return window;\n+    }\n+\n+    private void populateListWin() {\n+        Enumeration enumWindows = NestedDialogTest.enumWindows();\n+\n+        listWins.removeAll();\n+        while (enumWindows.hasMoreElements()) {\n+            Window win = (Window) enumWindows.nextElement();\n+            listWins.add(win.getName());\n+        }\n+        listWins.select(NestedDialogTest.getWindowIndex(this));\n+    }\n+\n+    public void show() {\n+        if (!isVisible()) {\n+            NestedDialogTest.addWindow(this);\n+        }\n+        super.show();\n+    }\n+\n+    public void dispose() {\n+        NestedDialogTest.removeWindow(this);\n+        super.dispose();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/NestedDialogTest.java","additions":312,"deletions":0,"binary":false,"changes":312,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+import java.awt.Button;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.PrintJob;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+class PrintToFileFrame extends Frame implements ActionListener {\n+    Button nativeDlg = new Button(\"Show print dialog\");\n+\n+    public PrintToFileFrame() {\n+        this.setLayout(new FlowLayout());\n+        add(nativeDlg);\n+        nativeDlg.addActionListener(this);\n+\n+        setSize(300, 300);\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    public void actionPerformed(ActionEvent ae) {\n+        if (System.getSecurityManager() == null) {\n+            throw new RuntimeException(\"Security manager isn't installed.\");\n+        }\n+\n+        try {\n+            System.getSecurityManager().checkPrintJobAccess();\n+            System.out.println(\"checkPrintJobAccess - OK\");\n+        } catch (SecurityException e) {\n+            System.out.println(\"checkPrintJobAccess - ERROR \" + e);\n+        }\n+\n+        PrintJob printJob = getToolkit().getPrintJob(this, null, null);\n+\n+        if (printJob != null) {\n+            System.out.println(\"Print Job: \" + printJob);\n+        } else {\n+            System.out.println(\"Print Job is null.\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/PrintToFileTest\/PrintToFileFrame.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.print.PrinterJob;\n+\n+\/*\n+ * @test\n+ * @bug 6275359\n+ * @summary Test to verify system menu of a dialog on win32\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @compile PrintToFileFrame.java\n+ * @compile PrintToFileGranted.java\n+ * @run main\/manual\/policy=granted\/othervm PrintToFileGranted\n+ *\/\n+\n+public class PrintToFileGranted {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS;\n+        if (isPrintSupport()) {\n+            INSTRUCTIONS = \"\"\"\n+                    1. Click on 'Show file dialog' button A print dialog will come up\n+                    2. If checkbox 'Print to file' is enabled then the test passed\n+                       else the test failed\n+                    3. Close the print dialog before pressing PASS or FAIL buttons\n+                    \"\"\";\n+        } else {\n+            INSTRUCTIONS = \"\"\"\n+                    1. The test requires printer installed in your system,\n+                       but there is no printers found\n+                       Please install one and re-run the test\n+                    \"\"\";\n+        }\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(new PrintToFileFrame())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static boolean isPrintSupport() {\n+        PrinterJob pj = PrinterJob.getPrinterJob();\n+        return pj.getPrintService() != null;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/PrintToFileTest\/PrintToFileGranted.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.print.PrinterJob;\n+\n+\/*\n+ * @test\n+ * @bug 6275359\n+ * @summary Test to verify Printing ignores Security permissions\n+ *          using native dialog\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @compile PrintToFileRevoked.java\n+ * @run main\/manual\/policy=revoked\/othervm PrintToFileRevoked\n+ *\/\n+\n+public class PrintToFileRevoked {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS;\n+        if (isPrintSupport()) {\n+            INSTRUCTIONS = \"\"\"\n+                    1. Click on 'Show file dialog' button A print dialog will come up\n+                    2. If checkbox 'Print to file' is disabled then the test passed\n+                       else the test failed\n+                    3. Close the print dialog before pressing PASS or FAIL buttons\n+                    \"\"\";\n+        } else {\n+            INSTRUCTIONS = \"\"\"\n+                    1. The test requires printer installed in your system,\n+                       but there is no printers found\n+                       Please install one and re-run the test\n+                    \"\"\";\n+        }\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(new PrintToFileFrame())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static boolean isPrintSupport() {\n+        PrinterJob pj = PrinterJob.getPrinterJob();\n+        return pj.getPrintService() != null;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/PrintToFileTest\/PrintToFileRevoked.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+\/* AUTOMATICALLY GENERATED ON Thu Jan 03 15:48:39 PST 2002*\/\n+\/* DO NOT EDIT *\/\n+\n+grant {\n+ permission java.lang.RuntimePermission \"queuePrintJob\";\n+ permission java.util.PropertyPermission \"*\", \"read\";\n+ permission java.io.FilePermission \"<<ALL FILES>>\", \"read\";\n+ permission java.io.FilePermission \"<<ALL FILES>>\", \"write\";\n+ permission java.lang.RuntimePermission \"accessClassInPackage.sun.util.locale.provider\";\n+};\n","filename":"test\/jdk\/java\/awt\/Dialog\/PrintToFileTest\/granted","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+\/* AUTOMATICALLY GENERATED ON Thu Jan 03 15:48:39 PST 2002*\/\n+\/* DO NOT EDIT *\/\n+\n+grant {\n+ permission java.lang.RuntimePermission \"queuePrintJob\";\n+ permission java.util.PropertyPermission \"*\", \"read\";\n+ permission java.lang.RuntimePermission \"accessClassInPackage.sun.util.locale.provider\";\n+};\n+\n","filename":"test\/jdk\/java\/awt\/Dialog\/PrintToFileTest\/revoked","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dialog;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Label;\n+\n+import java.awt.TextArea;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.ObjectOutputStream;\n+\n+\/*\n+ * @test\n+ * @bug 4739757\n+ * @summary REGRESSION: Modal Dialog is not serializable after showing\n+ * @key headful\n+ * @run main ShownModalDialogSerializationTest\n+ *\/\n+\n+public class ShownModalDialogSerializationTest {\n+    static volatile Frame frame;\n+    static volatile Frame outputFrame;\n+    static volatile Dialog dialog;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        EventQueue.invokeLater(ShownModalDialogSerializationTest::createTestUI);\n+\n+        while (dialog == null || !dialog.isShowing()) {\n+            Thread.sleep(500);\n+        }\n+        File file = new File(\"dialog.ser\");\n+        FileOutputStream fos = new FileOutputStream(file);\n+        ObjectOutputStream oos = new ObjectOutputStream(fos);\n+        oos.writeObject(dialog);\n+        oos.flush();\n+        file.delete();\n+\n+        EventQueue.invokeAndWait(ShownModalDialogSerializationTest::deleteTestUI);\n+    }\n+\n+    static void deleteTestUI() {\n+        if (dialog != null) {\n+            dialog.setVisible(false);\n+            dialog.dispose();\n+        }\n+        if (frame != null) {\n+            frame.setVisible(false);\n+            frame.dispose();\n+        }\n+        if (outputFrame != null) {\n+            outputFrame.setVisible(false);\n+            outputFrame.dispose();\n+        }\n+    }\n+\n+    private static void createTestUI() {\n+        outputFrame = new Frame(\"ShownModalDialogSerializationTest\");\n+        TextArea output = new TextArea(40, 50);\n+        outputFrame.add(output);\n+\n+        frame = new Frame(\"invisible dialog owner\");\n+        dialog = new Dialog(frame, \"Dialog for Close\", true);\n+        dialog.add(new Label(\"Close This Dialog\"));\n+        outputFrame.setSize(200, 200);\n+        outputFrame.setVisible(true);\n+        dialog.pack();\n+        dialog.setVisible(true);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/ShownModalDialogSerializationTest.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+import java.awt.Window;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+\n+\/*\n+ * @test\n+ * @bug 4940645\n+ * @summary Test to verify setAlwaysOnTop(true) does\n+ *          work in modal dialog in Windows\n+ * @requires (os.family == \"windows\" | os.family == \"linux\" )\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual TopmostModalDialogTest\n+ *\/\n+\n+public class TopmostModalDialogTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                (This test verifies that modal dialog can be made always on top\n+                This test should only be run on the platforms which support always-on-top windows\n+                Such platforms are: Windows, Linux with GNOME2\/Metacity window manager,\n+                Solaris with GNOME2\/Metacity window manager\n+                If you are not running on any of these platforms, please select 'Pass' to skip testing\n+                If you are unsure on which platform you are running please select 'Pass')\n+\n+                1. After test started you see a frame with \\\\\"Main Frame\\\\\" title\n+                   It contains three buttons. Every button starts one of test stage\n+                   You should test all three stages\n+                2. After you press button to start the stage. It shows modal dialog\n+                   This modal dialog should be always-on-top window\n+                3. Since it's a modal the only way to test this is try to cover it\n+                   using some native window\n+                4. If you will able to cover it be native window - test FAILS, otherwise - PASS\n+\n+                Note: in stages #2 and #3 dialog is initially shown as regular modal dialogs\n+                You will see \\\\\"Let's wait\\\\\" message in the message area below\n+                Please wait until message \\\\\"Let's make it topmost\\\\\" will be printed in the area\n+                After that you can continue testing.\n+                \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .logArea(8)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Frame initialize() {\n+        final Tester tester = new Tester();\n+        Frame frame = new Frame(\"Main Frame\");\n+        frame.setLayout(new GridLayout(3, 1));\n+        for (int i = 0; i < 3; i++) {\n+            Button btn = new Button(\"Stage #\" + i);\n+            frame.add(btn);\n+            btn.addActionListener(tester);\n+        }\n+        frame.pack();\n+        return frame;\n+    }\n+}\n+\n+class Tester implements ActionListener {\n+    public void actionPerformed(ActionEvent e) {\n+        String command = e.getActionCommand();\n+        PassFailJFrame.log(command);\n+        int cmd = Integer.parseInt(command.substring(command.length() - 1));\n+        PassFailJFrame.log(\"\" + cmd);\n+        Dialog dlg = new Dialog(new Frame(\"\"), \"Modal Dialog\", true);\n+        dlg.setBounds(100, 100, 100, 100);\n+        dlg.addWindowListener(new WindowAdapter() {\n+            public void windowClosing(WindowEvent we) {\n+                Window self = we.getWindow();\n+                Window owner = self.getOwner();\n+                if (owner != null) {\n+                    owner.dispose();\n+                } else {\n+                    self.dispose();\n+                }\n+            }\n+        });\n+\n+        switch (cmd) {\n+            case 0:\n+                dlg.setAlwaysOnTop(true);\n+                dlg.setVisible(true);\n+                break;\n+            case 1:\n+                (new Thread(new TopmostMaker(dlg))).start();\n+                dlg.setVisible(true);\n+                break;\n+            case 2:\n+                dlg.setFocusableWindowState(false);\n+                (new Thread(new TopmostMaker(dlg))).start();\n+                dlg.setVisible(true);\n+                break;\n+            default:\n+                PassFailJFrame.log(\"Unsupported operation :(\");\n+        }\n+    }\n+}\n+\n+class TopmostMaker implements Runnable {\n+    final Window wnd;\n+\n+    public TopmostMaker(Window wnd) {\n+        this.wnd = wnd;\n+    }\n+\n+    public void run() {\n+        PassFailJFrame.log(\"Let's wait\");\n+        try {\n+            Thread.sleep(1000);\n+        } catch (InterruptedException ie) {\n+            PassFailJFrame.log(\"Test was interrupted. \" + ie);\n+            ie.printStackTrace();\n+        }\n+        PassFailJFrame.log(\"Let's make it topmost\");\n+        wnd.setAlwaysOnTop(true);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/TopmostModalDialogTest.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4212687\n+ * @summary Verifies that calling EventQueue.push() and EventQueue.pop()\n+ *          does not deadlock.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual PushPopDeadlock\n+ *\/\n+\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+\n+public class PushPopDeadlock {\n+    static int counter = 0;\n+    static Robot robot;\n+    static Frame f;\n+    static Label l;\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+        String INSTRUCTIONS = \"\"\"\n+                Click rapidly in the Frame labeled 'Click Here!'.\n+                The number in the Frame should continue to increase. If the number\n+                stops increasing (remains at a constant value), the test fails.\n+                \"\"\";\n+\n+        PassFailJFrame pfJFrame = PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(PushPopDeadlock::createUI)\n+                .build();\n+        PushPopDeadlock.test();\n+        pfJFrame.awaitAndCheck();\n+    }\n+\n+    public static Frame createUI() {\n+        f = new Frame(\"Click Here!\");\n+        l = new Label(\"Counter: \" + counter);\n+        f.add(l);\n+        f.setSize(200, 200);\n+        return f;\n+    }\n+\n+    public static void test() {\n+        EventQueue q = new EventQueue() {\n+            public void push(EventQueue queue) {\n+                super.push(queue);\n+                pop();\n+            }\n+        };\n+        EventQueue q2 = new EventQueue();\n+\n+        Toolkit.getDefaultToolkit().getSystemEventQueue().push(q);\n+\n+        new Thread(() -> {\n+            while (true) {\n+                robot.delay(500);\n+                l.setText(\"Counter: \" + ++counter);\n+                q.push(q2);\n+                try {\n+                    Thread.currentThread().sleep(500);\n+                } catch (InterruptedException e) {\n+                    return;\n+                }\n+            }\n+        }).start();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/EventQueue\/PushPopDeadlock\/PushPopDeadlock.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4058400\n+ * @summary Tests that calling addNotify on a lightweight component more than\n+ *          once does not break event dispatching for that component.\n+ * @key headful\n+ * @run main MultipleAddNotifyTest\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+public class MultipleAddNotifyTest {\n+    static volatile boolean passFlag;\n+    static volatile int posX;\n+    static volatile int posY;\n+    static Frame f;\n+    static LightComponent l;\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot r;\n+        try {\n+            r = new Robot();\n+            r.setAutoWaitForIdle(true);\n+            passFlag = false;\n+\n+            EventQueue.invokeAndWait(() -> {\n+                f = new Frame(\"Multiple addNotify Test\");\n+                l = new LightComponent();\n+                f.setLayout(new FlowLayout());\n+                l.addMouseListener(new MouseAdapter() {\n+                    @Override\n+                    public void mouseClicked(MouseEvent e) {\n+                        System.out.println(\"Mouse Clicked\");\n+                        passFlag = true;\n+                    }\n+                });\n+                f.add(l);\n+                f.addNotify();\n+                f.addNotify();\n+\n+                if (!l.isVisible()) {\n+                    throw new RuntimeException(\"Test failed. LW Component \" +\n+                            \"not visible.\");\n+                }\n+                f.setSize(200, 200);\n+                f.setLocationRelativeTo(null);\n+                f.setVisible(true);\n+            });\n+            r.waitForIdle();\n+            r.delay(1000);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                posX = f.getX() + l.getWidth() + (l.getWidth() \/ 2);\n+                posY = f.getY() + l.getHeight();\n+            });\n+\n+            r.mouseMove(posX, posY);\n+            r.delay(500);\n+\n+            r.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            r.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            r.delay(500);\n+\n+            if (!passFlag) {\n+                throw new RuntimeException(\"Test failed. MouseClicked event \" +\n+                        \"not working properly.\");\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (f != null) {\n+                    f.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\n+\n+class LightComponent extends Component {\n+    public void paint(Graphics g) {\n+        setSize(100, 100);\n+        Dimension d = getSize();\n+        g.setColor(Color.red);\n+        g.fillRect(0, 0, d.width, d.height);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/LightweightComponent\/MultipleAddNotifyTest\/MultipleAddNotifyTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4476083\n+ * @summary Disabled components do not receive MouseEvent in Popups\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual PopupTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.Frame;\n+\n+import javax.swing.JButton;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPopupMenu;\n+\n+public class PopupTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                PopupMenus should disappear when a disabled component is\n+                clicked.\n+\n+                Step 1. Pop down the popup menu by clicking on it.\n+                Step 2. Click on the disabled component to make the menu\n+                disappear.\n+\n+                If the menu disappears when the disabled component is clicked,\n+                the test passes, otherwise, the test fails.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(35)\n+                .testUI(PopupTest::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createUI() {\n+        Frame f = new Frame(\"Disabled Component in Popup Test\");\n+        f.setLayout(new BorderLayout());\n+\n+        JButton b = new JButton(\"step 1: press me to display menu\");\n+        b.addActionListener(e -> {\n+            JPopupMenu m = new JPopupMenu();\n+            m.add(new JMenuItem(\"item 1\"));\n+            m.add(new JMenuItem(\"item 2\"));\n+            m.add(new JMenuItem(\"item 3\"));\n+            m.add(new JMenuItem(\"item 4\"));\n+            m.add(new JMenuItem(\"item 5\"));\n+            m.add(new JMenuItem(\"item 6\"));\n+            m.show((Component) e.getSource(), 0, 10);\n+        });\n+\n+        JLabel disabled = new JLabel(\"step 2: click me. the menu should be \" +\n+                \"dismissed\");\n+        disabled.setEnabled(false);\n+\n+        JLabel enabled = new JLabel(\"step 3: there is no step 3\");\n+\n+        f.add(BorderLayout.NORTH, b);\n+        f.add(BorderLayout.CENTER, disabled);\n+        f.add(BorderLayout.SOUTH, enabled);\n+        f.setSize(300, 200);\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/LightweightComponent\/PopupTest\/PopupTest.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,455 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4148078\n+ * @summary Repainting problems in scrolled panel\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual PanelRepaint\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Scrollbar;\n+import java.awt.TextField;\n+import java.awt.event.AdjustmentEvent;\n+import java.awt.event.AdjustmentListener;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+\n+public class PanelRepaint extends Panel implements FocusListener {\n+    static ScrollPanel sPanel;\n+    static Panel panel;\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                Using scrollbars or tab keys to scroll the panel and\n+                the panel is messy sometimes, e.g. one row bumps into\n+                another. If all components painted correctly, the test passes.\n+                Otherwise, the test fails.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(35)\n+                .testUI(PanelRepaint::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Frame createUI() {\n+        Frame f = new Frame(\"Panel Repaint Test\");\n+        f.setLayout(new FlowLayout());\n+        f.setSize(620, 288);\n+        PanelRepaint pr = new PanelRepaint();\n+\n+        panel = new Panel();\n+        panel.setLayout(null);\n+        panel.setSize(500, 500);\n+        sPanel = new ScrollPanel(panel);\n+\n+        Button btn = new Button(\"Open\");\n+        pr.addComp(btn);\n+        btn.setBounds(400, 10, 60, 20);\n+        btn.setActionCommand(\"OPEN\");\n+\n+        Button btn1 = new Button(\"Close\");\n+        pr.addComp(btn1);\n+        btn1.setBounds(400, 50, 60, 20);\n+        btn1.setActionCommand(\"CLOSE\");\n+\n+        TextField t1 = new TextField(\"1\");\n+        pr.addComp(t1);\n+        t1.setBounds(10, 10, 100, 20);\n+        TextField t2 = new TextField(\"2\");\n+        pr.addComp(t2);\n+        t2.setBounds(10, 50, 100, 20);\n+        TextField t3 = new TextField(\"3\");\n+        pr.addComp(t3);\n+        t3.setBounds(10, 90, 100, 20);\n+        TextField t4 = new TextField(\"4\");\n+        pr.addComp(t4);\n+        t4.setBounds(10, 130, 100, 20);\n+        TextField t5 = new TextField(\"5\");\n+        pr.addComp(t5);\n+        t5.setBounds(10, 170, 100, 20);\n+        TextField t6 = new TextField(\"6\");\n+        pr.addComp(t6);\n+        t6.setBounds(10, 210, 100, 20);\n+        TextField t7 = new TextField(\"7\");\n+        pr.addComp(t7);\n+        t7.setBounds(10, 250, 100, 20);\n+        TextField t8 = new TextField(\"8\");\n+        pr.addComp(t8);\n+        t8.setBounds(10, 290, 100, 20);\n+        TextField t9 = new TextField(\"9\");\n+        pr.addComp(t9);\n+        t9.setBounds(10, 330, 100, 20);\n+\n+        TextField t11 = new TextField(\"1\");\n+        pr.addComp(t11);\n+        t11.setBounds(120, 10, 100, 20);\n+        TextField t12 = new TextField(\"2\");\n+        pr.addComp(t12);\n+        t12.setBounds(120, 50, 100, 20);\n+        TextField t13 = new TextField(\"3\");\n+        pr.addComp(t13);\n+        t13.setBounds(120, 90, 100, 20);\n+        TextField t14 = new TextField(\"4\");\n+        pr.addComp(t14);\n+        t14.setBounds(120, 130, 100, 20);\n+        TextField t15 = new TextField(\"5\");\n+        pr.addComp(t15);\n+        t15.setBounds(120, 170, 100, 20);\n+        TextField t16 = new TextField(\"6\");\n+        pr.addComp(t16);\n+        t16.setBounds(120, 210, 100, 20);\n+        TextField t17 = new TextField(\"7\");\n+        pr.addComp(t17);\n+        t17.setBounds(120, 250, 100, 20);\n+        TextField t18 = new TextField(\"8\");\n+        pr.addComp(t18);\n+        t18.setBounds(120, 290, 100, 20);\n+        TextField t19 = new TextField(\"9\");\n+        pr.addComp(t19);\n+        t19.setBounds(120, 330, 100, 20);\n+\n+\n+        TextField t21 = new TextField(\"1\");\n+        pr.addComp(t21);\n+        t21.setBounds(240, 10, 100, 20);\n+        TextField t22 = new TextField(\"2\");\n+        pr.addComp(t22);\n+        t22.setBounds(240, 50, 100, 20);\n+        TextField t23 = new TextField(\"3\");\n+        pr.addComp(t23);\n+        t23.setBounds(240, 90, 100, 20);\n+        TextField t24 = new TextField(\"4\");\n+        pr.addComp(t24);\n+        t24.setBounds(240, 130, 100, 20);\n+        TextField t25 = new TextField(\"5\");\n+        pr.addComp(t25);\n+        t25.setBounds(240, 170, 100, 20);\n+        TextField t26 = new TextField(\"6\");\n+        pr.addComp(t26);\n+        t26.setBounds(240, 210, 100, 20);\n+        TextField t27 = new TextField(\"7\");\n+        pr.addComp(t27);\n+        t27.setBounds(240, 250, 100, 20);\n+        TextField t28 = new TextField(\"8\");\n+        pr.addComp(t28);\n+        t28.setBounds(240, 290, 100, 20);\n+        TextField t29 = new TextField(\"9\");\n+        pr.addComp(t29);\n+        t29.setBounds(240, 330, 100, 20);\n+\n+        pr.add(sPanel);\n+        f.add(pr);\n+        sPanel.setBounds(100, 100, 500, 250);\n+        sPanel.doLayout();\n+        return f;\n+    }\n+\n+    public void addComp(Component c) {\n+        panel.add(c);\n+        c.addFocusListener(this);\n+    }\n+\n+    public void focusGained(FocusEvent e) {\n+        sPanel.showComponent(e.getComponent());\n+    }\n+\n+    public void focusLost(FocusEvent e) {\n+    }\n+}\n+\n+class ScrollPanel extends Panel implements AdjustmentListener {\n+    \/**\n+     * Constructor\n+     *\/\n+    public ScrollPanel(Component c) {\n+        setLayout(null);\n+        setBackground(Color.lightGray);\n+        add(hScroll = new Scrollbar(Scrollbar.HORIZONTAL));\n+        add(vScroll = new Scrollbar(Scrollbar.VERTICAL));\n+        add(square = new Panel());\n+        square.setBackground(Color.lightGray);\n+        add(c);\n+    }\n+\n+    \/**\n+     * Scroll up\/down\/left\/right to show the component specified\n+     *\n+     * @param comp is the component to be shown\n+     *\/\n+    public void showComponent(Component comp) {\n+        Component view = getComponent(3);\n+        Rectangle viewRect = view.getBounds();\n+        Rectangle scrollRect = getBounds();\n+        Rectangle rect = comp.getBounds();\n+        while (comp != null) {\n+            Component parent = comp.getParent();\n+            if (parent == null || parent == view) {\n+                break;\n+            }\n+            Point p = parent.getLocation();\n+            rect.x += p.x;\n+            rect.y += p.y;\n+            comp = parent;\n+        }\n+\n+        int i = viewRect.y + rect.y;\n+        int j = (viewRect.y + rect.y + rect.height + ScrollPanel.H_HEIGHT)\n+                - (scrollRect.height);\n+\n+        if (i < 0) {\n+            vertUpdate(i);\n+        } else if (j > 0) {\n+            vertUpdate(j);\n+        }\n+\n+        i = viewRect.x + rect.x;\n+        j = (viewRect.x + rect.x + rect.width + (V_WIDTH * 2)) - (scrollRect.width);\n+\n+        if (i < 0) {\n+            horzUpdate(i);\n+        } else if (j > 0) {\n+            horzUpdate(j);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the panel component of ScrollPanel\n+     *\n+     * @return the panel component of ScrollPanel\n+     *\/\n+    public Component getScrolled() {\n+        return getComponent(3);\n+    }\n+\n+    \/**\n+     * updates the scroll panel vertically with value i passed\n+     *\n+     * @param i the value to be updated with\n+     *\/\n+    public void vertUpdate(int i) {\n+        update(true, vScroll.getValue() + i);\n+    }\n+\n+    \/**\n+     * updates the scroll panel horizontally with value i passed\n+     *\n+     * @param i the value to be updated with\n+     *\/\n+    public void horzUpdate(int i) {\n+        update(false, hScroll.getValue() + i);\n+    }\n+\n+    \/**\n+     * updates the scroll panel vertically if bVert is true else horizontally\n+     *\n+     * @param n is the value\n+     *\/\n+    public void update(boolean bVert, int n) {\n+        if (n < 0) n = 0;\n+        if (bVert) {\n+            if (n > max.height) {\n+                n = max.height;\n+            }\n+            if (offset.y != n) {\n+                offset.y = n;\n+                vScroll.setValue(n);\n+            }\n+        } else {\n+            if (n > max.width) {\n+                n = max.width;\n+            }\n+            if (offset.x != n) {\n+                offset.x = n;\n+                hScroll.setValue(n);\n+            }\n+        }\n+        getScrolled().setLocation(-offset.x, -offset.y);\n+    }\n+\n+    \/**\n+     * Implementation of AdjustmentListener\n+     *\/\n+    public void adjustmentValueChanged(AdjustmentEvent e) {\n+        boolean bVert = e.getSource() == vScroll;\n+        update(bVert, e.getValue());\n+    }\n+\n+    \/**\n+     * Reimplementation of Component Methods\n+     *\/\n+    public void addNotify() {\n+        super.addNotify();\n+        vScroll.addAdjustmentListener(this);\n+        hScroll.addAdjustmentListener(this);\n+    }\n+\n+    public void removeNotify() {\n+        super.removeNotify();\n+        vScroll.removeAdjustmentListener(this);\n+        hScroll.removeAdjustmentListener(this);\n+    }\n+\n+    public void setBounds(int x, int y, int w, int h) {\n+        super.setBounds(x, y, w, h);\n+        doLayout();\n+    }\n+\n+    public void doLayout() {\n+        Component c = getScrolled();\n+        Dimension d = c.getSize();\n+        if (d.width == 0 || d.height == 0) {\n+            d = c.getPreferredSize();\n+        }\n+        vert = 0;\n+        horz = 0;\n+        Dimension m = getSize();\n+        if (d.height > m.height || isScroll(true, m.height - horz, 0, d.height)) {\n+            vert = V_WIDTH;\n+        }\n+        if (d.width + vert > m.width || isScroll(false, m.width - vert, 0, d.width)) {\n+            horz = H_HEIGHT;\n+        }\n+        if (d.height + horz > m.height || isScroll(true, m.height - horz, 0, d.height)) {\n+            vert = V_WIDTH;\n+        }\n+        if (d.width + vert > m.width || isScroll(false, m.width - vert, 0, d.width)) {\n+            horz = H_HEIGHT;\n+        }\n+        if (horz != 0) {\n+            if (m.width <= 0) {\n+                m.width = 1;\n+            }\n+            hScroll.setBounds(0, m.height - H_HEIGHT, m.width - vert, H_HEIGHT);\n+            hScroll.setValues(offset.x, m.width - vert, 0, d.width);\n+            int i = d.width \/ 10;\n+            if (i < 2) {\n+                i = 2;\n+            }\n+            hScroll.setBlockIncrement(i);\n+            i = d.width \/ 50;\n+            if (i < 1) {\n+                i = 1;\n+            }\n+            hScroll.setUnitIncrement(i);\n+            max.width = d.width;\n+            hScroll.setVisible(true);\n+        } else {\n+            offset.x = 0;\n+        }\n+        if (vert != 0) {\n+            if (m.height <= 0) {\n+                m.height = 1;\n+            }\n+            vScroll.setBounds(m.width - V_WIDTH, 0, V_WIDTH, m.height - horz);\n+            vScroll.setValues(offset.y, m.height - horz, 0, d.height);\n+            int i = d.height \/ 10;\n+            if (i < 2) i = 2;\n+            vScroll.setBlockIncrement(i);\n+            i = d.height \/ 50;\n+            if (i < 1) i = 1;\n+            vScroll.setUnitIncrement(i);\n+            max.height = d.height;\n+            vScroll.setVisible(true);\n+        } else {\n+            offset.y = 0;\n+        }\n+        if (horz != 0 && vert != 0) {\n+            square.setBounds(m.width - V_WIDTH, m.height - H_HEIGHT, V_WIDTH, H_HEIGHT);\n+            square.setVisible(true);\n+        } else {\n+            square.setVisible(false);\n+        }\n+        c.setBounds(-offset.x, -offset.y, d.width, d.height);\n+        c.repaint();\n+        updateScroll(true, offset.y);\n+        updateScroll(false, offset.x);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return getScrolled().getPreferredSize();\n+    }\n+\n+    public Dimension getMinimumSize() {\n+        return getScrolled().getMinimumSize();\n+    }\n+\n+    boolean isScroll(boolean bVert, int visible, int min, int max) {\n+        int tot = max - min;\n+        int net = tot - visible;\n+        if (net <= 0) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    void updateScroll(boolean bVert, int n) {\n+        Component c = getScrolled();\n+        Dimension d = c.getSize();\n+        Dimension m = getSize();\n+        m.width -= vert;\n+        m.height -= horz;\n+        if (bVert) {\n+            if (n >= 0 && d.height > m.height) {\n+                if (n + m.height > d.height)\n+                    n = d.height - m.height;\n+            } else\n+                n = 0;\n+            update(true, n);\n+        } else {\n+            if (n >= 0 && d.width > m.width) {\n+                if (n + m.width > d.width)\n+                    n = d.width - m.width;\n+            } else\n+                n = 0;\n+            update(false, n);\n+        }\n+    }\n+\n+    static Scrollbar hScroll;\n+    static Scrollbar vScroll;\n+    static int vert = 0;\n+    static int horz = 0;\n+\n+    static Point offset = new Point();\n+    static Dimension max = new Dimension();\n+    \/\/  ScrollTimer timer;\n+    static Component square;\n+    final static int V_WIDTH = 17;\n+    final static int H_HEIGHT = 17;\n+}\n","filename":"test\/jdk\/java\/awt\/Panel\/PanelRepaint\/PanelRepaint.java","additions":455,"deletions":0,"binary":false,"changes":455,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4147957\n+ * @key headful\n+ * @summary Test to verify setClip with invalid rect changes rect to valid\n+ * @run main IntersectionTest\n+ *\/\n+\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Panel;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+\n+public class IntersectionTest {\n+    public static Frame frame;\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+        try {\n+            robot.setAutoDelay(100);\n+            EventQueue.invokeAndWait(() -> {\n+                TestFrame panel = new TestFrame();\n+                frame = new Frame(\"Rectangle Intersection Test\");\n+                frame.add(panel);\n+\n+                frame.pack();\n+                frame.setVisible(true);\n+            });\n+            robot.waitForIdle();\n+            robot.delay(200);\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\n+\n+class TestFrame extends Panel {\n+    @Override\n+    public void paint(Graphics g) {\n+        Rectangle r1 = new Rectangle(0, 0, 100, 100);\n+        Rectangle r2 = new Rectangle(200, 200, 20, 20);\n+        Rectangle r3 = r1.intersection(r2);\n+        System.out.println(\"intersect:(\" + (int) r3.getX() + \",\" +\n+                (int) r3.getY() + \",\" + (int) r3.getWidth() + \",\" +\n+                (int) r3.getHeight() + \")\");\n+        g.setClip(r3);\n+        Rectangle r4 = g.getClipBounds();\n+        System.out.println(\"getClipBounds:(\" + (int) r4.getX() + \",\" +\n+                (int) r4.getY() + \",\" + (int) r4.getWidth() + \",\" +\n+                (int) r4.getHeight() + \")\");\n+\n+        if ((r4.getWidth() <= 0) || (r4.getHeight() <= 0)) {\n+            System.out.println(\"Test Passed\");\n+        } else {\n+            throw new RuntimeException(\"IntersectionTest failed. \" +\n+                    \"Non-empty clip bounds.\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Rectangle\/IntersectionTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,289 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.Cursor;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceDragEvent;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetContext;\n+import java.awt.dnd.DropTargetDragEvent;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n+\/*\n+ * @test\n+ * @bug 4451328\n+ * @summary tests that a custom drag cursor is not changed\n+           to the default drag cursor\n+ * @key headful\n+ * @run main CustomDragCursorTest\n+ *\/\n+\n+public class CustomDragCursorTest {\n+    private static Frame frame;\n+    private static final DragSourcePanel dragSourcePanel = new DragSourcePanel();\n+    private static final DropTargetPanel dropTargetPanel = new DropTargetPanel();\n+\n+    private static volatile Point srcPoint;\n+    private static volatile Point dstPoint;\n+    private static volatile boolean passed = true;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            Robot robot = new Robot();\n+            EventQueue.invokeAndWait(CustomDragCursorTest::createAndShowUI);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                Point p = dragSourcePanel.getLocationOnScreen();\n+                Dimension d = dragSourcePanel.getSize();\n+                p.translate(d.width \/ 2, d.height \/ 2);\n+                srcPoint = p;\n+\n+                p = dropTargetPanel.getLocationOnScreen();\n+                d = dropTargetPanel.getSize();\n+                p.translate(d.width \/ 2, d.height \/ 2);\n+                dstPoint = p;\n+            });\n+\n+            robot.mouseMove(srcPoint.x, srcPoint.y);\n+            robot.keyPress(KeyEvent.VK_CONTROL);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            for (; !srcPoint.equals(dstPoint);\n+                 srcPoint.translate(sign(dstPoint.x - srcPoint.x),\n+                                    sign(dstPoint.y - srcPoint.y))) {\n+                robot.mouseMove(srcPoint.x, srcPoint.y);\n+                robot.delay(10);\n+            }\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.keyRelease(KeyEvent.VK_CONTROL);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            if (!passed) {\n+                throw new RuntimeException(\"Custom drag cursor changed to default.\");\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createAndShowUI() {\n+        frame = new Frame(\"CustomDragCursorTest\");\n+        frame.setLayout(new GridLayout(2, 1));\n+        frame.add(dragSourcePanel);\n+        frame.add(dropTargetPanel);\n+        frame.setLocationRelativeTo(null);\n+        frame.setSize(300, 400);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void failed() {\n+        passed = false;\n+    }\n+\n+    private static int sign(int n) {\n+        return Integer.compare(n, 0);\n+    }\n+\n+    private static class DragSourceButton extends Button implements Serializable,\n+                                                                    Transferable,\n+                                                                    DragGestureListener,\n+                                                                    DragSourceListener {\n+        private final DataFlavor dataflavor =\n+                new DataFlavor(Button.class, \"DragSourceButton\");\n+        private final Cursor dragCursor = new Cursor(Cursor.HAND_CURSOR);\n+\n+        public DragSourceButton() {\n+            this(\"DragSourceButton\");\n+        }\n+\n+        public DragSourceButton(String str) {\n+            super(str);\n+\n+            DragSource ds = DragSource.getDefaultDragSource();\n+            ds.createDefaultDragGestureRecognizer(this, DnDConstants.ACTION_COPY,\n+                                                  this);\n+        }\n+\n+        public void dragGestureRecognized(DragGestureEvent dge) {\n+            dge.startDrag(dragCursor, this, this);\n+        }\n+\n+        public void dragEnter(DragSourceDragEvent dsde) {\n+            if (!dragCursor.equals(dsde.getDragSourceContext().getCursor())) {\n+                CustomDragCursorTest.failed();\n+            }\n+        }\n+\n+        public void dragExit(DragSourceEvent dse) {\n+            if (!dragCursor.equals(dse.getDragSourceContext().getCursor())) {\n+                CustomDragCursorTest.failed();\n+            }\n+        }\n+\n+        public void dragOver(DragSourceDragEvent dsde) {\n+            if (!dragCursor.equals(dsde.getDragSourceContext().getCursor())) {\n+                CustomDragCursorTest.failed();\n+            }\n+        }\n+\n+        public void dragDropEnd(DragSourceDropEvent dsde) {\n+            if (!dragCursor.equals(dsde.getDragSourceContext().getCursor())) {\n+                CustomDragCursorTest.failed();\n+            }\n+        }\n+\n+        public void dropActionChanged(DragSourceDragEvent dsde) {\n+            if (!dragCursor.equals(dsde.getDragSourceContext().getCursor())) {\n+                CustomDragCursorTest.failed();\n+            }\n+        }\n+\n+        public Object getTransferData(DataFlavor flavor)\n+                throws UnsupportedFlavorException, IOException {\n+\n+            if (!isDataFlavorSupported(flavor)) {\n+                throw new UnsupportedFlavorException(flavor);\n+            }\n+\n+            Object retObj;\n+\n+            ByteArrayOutputStream baoStream = new ByteArrayOutputStream();\n+            ObjectOutputStream ooStream = new ObjectOutputStream(baoStream);\n+            ooStream.writeObject(this);\n+\n+            ByteArrayInputStream baiStream = new ByteArrayInputStream(baoStream.toByteArray());\n+            ObjectInputStream ois = new ObjectInputStream(baiStream);\n+            try {\n+                retObj = ois.readObject();\n+            } catch (ClassNotFoundException e) {\n+                e.printStackTrace();\n+                throw new RuntimeException(e.toString());\n+            }\n+\n+            return retObj;\n+        }\n+\n+        public DataFlavor[] getTransferDataFlavors() {\n+            return new DataFlavor[] { dataflavor };\n+        }\n+\n+        public boolean isDataFlavorSupported(DataFlavor dflavor) {\n+            return dataflavor.equals(dflavor);\n+        }\n+    }\n+\n+    private static class DragSourcePanel extends Panel {\n+\n+        final Dimension preferredDimension = new Dimension(200, 100);\n+\n+        public DragSourcePanel() {\n+            setLayout(new GridLayout(1, 1));\n+            add(new DragSourceButton());\n+        }\n+\n+        public Dimension getPreferredSize() {\n+            return preferredDimension;\n+        }\n+    }\n+\n+    private static class DropTargetPanel extends Panel implements DropTargetListener {\n+\n+        final Dimension preferredDimension = new Dimension(200, 100);\n+\n+        public DropTargetPanel() {\n+            setDropTarget(new DropTarget(this, this));\n+        }\n+\n+        public Dimension getPreferredSize() {\n+            return preferredDimension;\n+        }\n+\n+        public void dragEnter(DropTargetDragEvent dtde) {}\n+\n+        public void dragExit(DropTargetEvent dte) {}\n+\n+        public void dragOver(DropTargetDragEvent dtde) {}\n+\n+        public void dropActionChanged(DropTargetDragEvent dtde) {}\n+\n+        public void drop(DropTargetDropEvent dtde) {\n+            DropTargetContext dtc = dtde.getDropTargetContext();\n+\n+            if ((dtde.getSourceActions() & DnDConstants.ACTION_COPY) != 0) {\n+                dtde.acceptDrop(DnDConstants.ACTION_COPY);\n+            } else {\n+                dtde.rejectDrop();\n+            }\n+\n+            DataFlavor[] dfs = dtde.getCurrentDataFlavors();\n+            Component comp = null;\n+\n+            if(dfs != null && dfs.length >= 1) {\n+                Transferable transfer = dtde.getTransferable();\n+\n+                try {\n+                    comp = (Component)transfer.getTransferData(dfs[0]);\n+                } catch (Throwable e) {\n+                    e.printStackTrace();\n+                    dtc.dropComplete(false);\n+                }\n+            }\n+            dtc.dropComplete(true);\n+            add(comp);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/CustomDragCursorTest.java","additions":289,"deletions":0,"binary":false,"changes":289,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+\n+\/*\n+ * @test\n+ * @bug 4166541 4225247 4297663\n+ * @summary Tests Basic DnD functionality\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DnDAcceptanceTest\n+ *\/\n+\n+public class DnDAcceptanceTest {\n+     private static final String INSTRUCTIONS = \"\"\"\n+            When test runs a Frame which contains a yellow button labeled\n+            \"Drag ME!\" and a RED Panel will appear.\n+\n+            Click on the button and drag to the red panel.\n+            When the mouse enters the red panel\n+            during the drag the panel should turn yellow.\n+\n+            Release the mouse button, panel should turn red again and\n+            a yellow button labeled Drag ME! should appear inside the panel.\n+            You should be able to repeat this operation multiple times.\n+\n+            If above is true press PASS, else press FAIL.\n+            \"\"\";\n+\n+     public static void main(String[] args) throws Exception {\n+         PassFailJFrame.builder()\n+                       .title(\"Test Instructions\")\n+                       .instructions(INSTRUCTIONS)\n+                       .columns(38)\n+                       .testUI(DnDAcceptanceTest::createUI)\n+                       .build()\n+                       .awaitAndCheck();\n+     }\n+\n+     private static Frame createUI() {\n+         Frame frame = new Frame(\"DnDAcceptanceTest\");\n+         Panel mainPanel;\n+         Component dragSource, dropTarget;\n+\n+         frame.setSize(400, 400);\n+         frame.setLayout(new BorderLayout());\n+\n+         mainPanel = new Panel();\n+         mainPanel.setLayout(new BorderLayout());\n+\n+         mainPanel.setBackground(Color.BLACK);\n+\n+         dropTarget = new DnDTarget(Color.RED, Color.YELLOW);\n+         dragSource = new DnDSource(\"Drag ME!\");\n+\n+         mainPanel.add(dragSource, \"North\");\n+         mainPanel.add(dropTarget, \"Center\");\n+         frame.add(mainPanel, BorderLayout.CENTER);\n+         frame.setAlwaysOnTop(true);\n+         return frame;\n+     }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/DnDAcceptanceTest\/DnDAcceptanceTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Container;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.MouseDragGestureRecognizer;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceDragEvent;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.InvalidDnDOperationException;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+class DnDSource extends Button implements Transferable,\n+                                          DragGestureListener,\n+                                          DragSourceListener {\n+    private DataFlavor df;\n+    private transient int dropAction;\n+\n+    DnDSource(String label) {\n+        super(label);\n+        Toolkit.getDefaultToolkit().createDragGestureRecognizer(MouseDragGestureRecognizer.class,\n+                                                                DragSource.getDefaultDragSource(),\n+                                                                this, DnDConstants.ACTION_COPY, this);\n+        setBackground(Color.yellow);\n+        setForeground(Color.blue);\n+        df = new DataFlavor(DnDSource.class, \"DnDSource\");\n+    }\n+\n+    public void dragGestureRecognized(DragGestureEvent dge) {\n+        System.err.println(\"starting Drag\");\n+        try {\n+            dge.startDrag(null, this, this);\n+        } catch (InvalidDnDOperationException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public void dragEnter(DragSourceDragEvent dsde) {\n+        System.err.println(\"[Source] dragEnter\");\n+        dsde.getDragSourceContext().setCursor(DragSource.DefaultCopyDrop);\n+    }\n+\n+    public void dragOver(DragSourceDragEvent dsde) {\n+        System.err.println(\"[Source] dragOver\");\n+        dropAction = dsde.getDropAction();\n+        System.out.println(\"dropAction = \" + dropAction);\n+    }\n+\n+    public void dragGestureChanged(DragSourceDragEvent dsde) {\n+        System.err.println(\"[Source] dragGestureChanged\");\n+        dropAction = dsde.getDropAction();\n+        System.out.println(\"dropAction = \" + dropAction);\n+    }\n+\n+    public void dragExit(DragSourceEvent dsde) {\n+        System.err.println(\"[Source] dragExit\");\n+        dsde.getDragSourceContext().setCursor(null);\n+    }\n+\n+    public void dragDropEnd(DragSourceDropEvent dsde) {\n+        System.err.println(\"[Source] dragDropEnd\");\n+    }\n+\n+    public void dropActionChanged(DragSourceDragEvent dsde) {\n+        System.err.println(\"[Source] dropActionChanged\");\n+        dropAction = dsde.getDropAction();\n+        System.out.println(\"dropAction = \" + dropAction);\n+    }\n+\n+    public DataFlavor[] getTransferDataFlavors() {\n+        return new DataFlavor[] {df};\n+    }\n+\n+    public boolean isDataFlavorSupported(DataFlavor sdf) {\n+        return df.equals(sdf);\n+    }\n+\n+    public Object getTransferData(DataFlavor tdf) throws UnsupportedFlavorException, IOException {\n+\n+        Object copy = null;\n+\n+        if (!df.equals(tdf)) {\n+            throw new UnsupportedFlavorException(tdf);\n+        }\n+        Container parent = getParent();\n+        switch (dropAction) {\n+            case DnDConstants.ACTION_COPY:\n+                try {\n+                    copy = this.clone();\n+                } catch (CloneNotSupportedException e) {\n+                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+                    ObjectOutputStream oos  = new ObjectOutputStream(baos);\n+\n+                    oos.writeObject(this);\n+                    ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n+                    ObjectInputStream ois = new ObjectInputStream(bais);\n+                    try {\n+                        copy = ois.readObject();\n+                    } catch (ClassNotFoundException cnfe) {\n+                        \/\/ do nothing\n+                    }\n+                }\n+\n+                parent.add(this);\n+                return copy;\n+\n+            case DnDConstants.ACTION_MOVE:\n+                synchronized(this) {\n+                    if (parent != null) parent.remove(this);\n+                }\n+                return this;\n+\n+            case DnDConstants.ACTION_LINK:\n+                return this;\n+\n+            default:\n+                \/\/throw new IOException(\"bad operation\");\n+                return this; \/\/ workaround for: 4135456  getDropAction() always return 0\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/DnDAcceptanceTest\/DnDSource.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Panel;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetContext;\n+import java.awt.dnd.DropTargetDragEvent;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.io.IOException;\n+\n+class DnDTarget extends Panel implements DropTargetListener {\n+    Color bgColor;\n+    Color htColor;\n+\n+    DnDTarget(Color bgColor, Color htColor) {\n+        super();\n+        this.bgColor = bgColor;\n+        this.htColor = htColor;\n+        setBackground(bgColor);\n+        setDropTarget(new DropTarget(this, this));\n+    }\n+\n+    public void dragEnter(DropTargetDragEvent e) {\n+        System.err.println(\"[Target] dragEnter\");\n+        e.acceptDrag(DnDConstants.ACTION_COPY);\n+        setBackground(htColor);\n+        repaint();\n+    }\n+\n+    public void dragOver(DropTargetDragEvent e) {\n+        System.err.println(\"[Target] dragOver\");\n+        e.acceptDrag(DnDConstants.ACTION_COPY);\n+    }\n+\n+    public void dragExit(DropTargetEvent e) {\n+        System.err.println(\"[Target] dragExit\");\n+        setBackground(bgColor);\n+        repaint();\n+    }\n+\n+    public void drop(DropTargetDropEvent dtde) {\n+        System.err.println(\"[Target] drop\");\n+        DropTargetContext dtc = dtde.getDropTargetContext();\n+\n+        if ((dtde.getSourceActions() & DnDConstants.ACTION_COPY) != 0) {\n+            dtde.acceptDrop(DnDConstants.ACTION_COPY);\n+        } else {\n+            dtde.rejectDrop();\n+            return;\n+        }\n+\n+        DataFlavor[] dfs = dtde.getCurrentDataFlavors();\n+        if (dfs != null && dfs.length >= 1) {\n+            Transferable transfer = dtde.getTransferable();\n+            Object obj;\n+            try {\n+                obj = transfer.getTransferData(dfs[0]);\n+            } catch (IOException | UnsupportedFlavorException ex) {\n+                System.err.println(ex.getMessage());\n+                dtc.dropComplete(false);\n+                return;\n+            }\n+\n+            if (obj != null) {\n+                Button button;\n+                try {\n+                    button = (Button) obj;\n+                } catch (Exception e) {\n+                    System.err.println(e.getMessage());\n+                    dtc.dropComplete(false);\n+                    return;\n+                }\n+                add(button);\n+                repaint();\n+            }\n+        }\n+        setBackground(bgColor);\n+        invalidate();\n+        validate();\n+        repaint();\n+        dtc.dropComplete(true);\n+    }\n+\n+    public void dropActionChanged(DropTargetDragEvent e) {\n+    System.err.println(\"[Target] dropActionChanged\");\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/DnDAcceptanceTest\/DnDTarget.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,441 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4388802\n+ * @summary tests that clipboard operations during drag-and-drop don't deadlock\n+ * @key headful\n+ * @run main DnDClipboardDeadlockTest\n+ *\/\n+\n+import java.awt.AWTEvent;\n+import java.awt.AWTException;\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.GridLayout;\n+import java.awt.List;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceDragEvent;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetContext;\n+import java.awt.dnd.DropTargetDragEvent;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.MouseEvent;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+\n+public class DnDClipboardDeadlockTest {\n+\n+    public static final int CODE_NOT_RETURNED = -1;\n+    public static final int CODE_OK = 0;\n+    public static final int CODE_FAILURE = 1;\n+\n+    private int returnCode = CODE_NOT_RETURNED;\n+\n+    final Frame frame = new Frame();\n+    Robot robot = null;\n+    Panel panel = null;\n+\n+    public static void main(String[] args) throws Exception {\n+        DnDClipboardDeadlockTest test = new DnDClipboardDeadlockTest();\n+        if (args.length == 4) {\n+            test.run(args);\n+        } else {\n+            test.start();\n+        }\n+    }\n+\n+    public void run(String[] args) throws InterruptedException, AWTException {\n+        try {\n+            if (args.length != 4) {\n+                throw new RuntimeException(\"Incorrect command line arguments.\");\n+            }\n+\n+            int x = Integer.parseInt(args[0]);\n+            int y = Integer.parseInt(args[1]);\n+            int w = Integer.parseInt(args[2]);\n+            int h = Integer.parseInt(args[3]);\n+\n+            Transferable t = new StringSelection(\"TEXT\");\n+            panel = new DragSourcePanel(t);\n+\n+            frame.setTitle(\"DragSource frame\");\n+            frame.setLocation(300, 200);\n+            frame.add(panel);\n+            frame.pack();\n+            frame.setVisible(true);\n+\n+            Util.waitForInit();\n+\n+            Point sourcePoint = panel.getLocationOnScreen();\n+            Dimension d = panel.getSize();\n+            sourcePoint.translate(d.width \/ 2, d.height \/ 2);\n+\n+            Point targetPoint = new Point(x + w \/ 2, y + h \/ 2);\n+\n+            robot = new Robot();\n+\n+            if (!Util.pointInComponent(robot, sourcePoint, panel)) {\n+                throw new RuntimeException(\"WARNING: Cannot locate source panel\");\n+            }\n+\n+            robot.mouseMove(sourcePoint.x, sourcePoint.y);\n+            robot.keyPress(KeyEvent.VK_CONTROL);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            for (; !sourcePoint.equals(targetPoint);\n+                 sourcePoint.translate(sign(targetPoint.x - sourcePoint.x),\n+                         sign(targetPoint.y - sourcePoint.y))) {\n+                robot.mouseMove(sourcePoint.x, sourcePoint.y);\n+                Thread.sleep(10);\n+            }\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.keyRelease(KeyEvent.VK_CONTROL);\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(e);\n+        }\n+    } \/\/ run()\n+\n+    public static int sign(int n) {\n+        return n < 0 ? -1 : n == 0 ? 0 : 1;\n+    }\n+\n+    public void start() {\n+        panel = new DropTargetPanel();\n+\n+        frame.setTitle(\"DropTarget frame\");\n+        frame.setLocation(10, 200);\n+        frame.add(panel);\n+\n+        frame.pack();\n+        frame.setVisible(true);\n+\n+        try {\n+            Util.waitForInit();\n+\n+            Point p = panel.getLocationOnScreen();\n+            Dimension d = panel.getSize();\n+\n+            try {\n+                Robot robot = new Robot();\n+                Point center = new Point(p);\n+                center.translate(d.width \/ 2, d.height \/ 2);\n+                if (!Util.pointInComponent(robot, center, panel)) {\n+                    System.err.println(\"WARNING: Cannot locate target panel\");\n+                    return;\n+                }\n+            } catch (AWTException awte) {\n+                awte.printStackTrace();\n+                return;\n+            }\n+\n+            String javaPath = System.getProperty(\"java.home\", \"\");\n+            String command = javaPath + File.separator + \"bin\" +\n+                    File.separator + \"java -cp \"\n+                    + System.getProperty(\"java.class.path\", \".\")\n+                    + \" DnDClipboardDeadlockTest \" +\n+                    p.x + \" \" + p.y + \" \" + d.width + \" \" + d.height;\n+\n+            Process process = Runtime.getRuntime().exec(command);\n+            returnCode = process.waitFor();\n+\n+            InputStream errorStream = process.getErrorStream();\n+            int count = errorStream.available();\n+            if (count > 0) {\n+                byte[] b = new byte[count];\n+                errorStream.read(b);\n+                System.err.println(\"========= Child VM System.err ========\");\n+                System.err.print(new String(b));\n+                System.err.println(\"======================================\");\n+            }\n+\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+        }\n+        switch (returnCode) {\n+            case CODE_NOT_RETURNED:\n+                System.err.println(\"Child VM: failed to start\");\n+                break;\n+            case CODE_OK:\n+                System.err.println(\"Child VM: normal termination\");\n+                break;\n+            case CODE_FAILURE:\n+                System.err.println(\"Child VM: abnormal termination\");\n+                break;\n+        }\n+        if (returnCode != CODE_OK) {\n+            throw new RuntimeException(\"The test failed.\");\n+        }\n+        if (frame != null) {\n+            frame.dispose();\n+        }\n+    } \/\/ start()\n+} \/\/ class DnDClipboardDeadlockTest\n+\n+class Util implements AWTEventListener {\n+    private static final Toolkit tk = Toolkit.getDefaultToolkit();\n+    private static final Object SYNC_LOCK = new Object();\n+    private Component clickedComponent = null;\n+    private static final int PAINT_TIMEOUT = 10000;\n+    private static final int MOUSE_RELEASE_TIMEOUT = 10000;\n+    private static final Util util = new Util();\n+\n+    static {\n+        tk.addAWTEventListener(util, 0xFFFFFFFF);\n+    }\n+\n+    private void reset() {\n+        clickedComponent = null;\n+    }\n+\n+    public void eventDispatched(AWTEvent e) {\n+        if (e.getID() == MouseEvent.MOUSE_RELEASED) {\n+            clickedComponent = (Component) e.getSource();\n+            synchronized (SYNC_LOCK) {\n+                SYNC_LOCK.notifyAll();\n+            }\n+        }\n+    }\n+\n+    public static boolean pointInComponent(Robot robot, Point p, Component comp)\n+            throws InterruptedException {\n+        return util.isPointInComponent(robot, p, comp);\n+    }\n+\n+    private boolean isPointInComponent(Robot robot, Point p, Component comp)\n+            throws InterruptedException {\n+        tk.sync();\n+        robot.waitForIdle();\n+        reset();\n+        robot.mouseMove(p.x, p.y);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        synchronized (SYNC_LOCK) {\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            SYNC_LOCK.wait(MOUSE_RELEASE_TIMEOUT);\n+        }\n+\n+        Component c = clickedComponent;\n+\n+        while (c != null && c != comp) {\n+            c = c.getParent();\n+        }\n+\n+        return c == comp;\n+    }\n+\n+    public static void waitForInit() throws InterruptedException {\n+        final Frame f = new Frame() {\n+            public void paint(Graphics g) {\n+                dispose();\n+                synchronized (SYNC_LOCK) {\n+                    SYNC_LOCK.notifyAll();\n+                }\n+            }\n+        };\n+        f.setBounds(600, 400, 200, 200);\n+        synchronized (SYNC_LOCK) {\n+            f.setVisible(true);\n+            SYNC_LOCK.wait(PAINT_TIMEOUT);\n+        }\n+        tk.sync();\n+    }\n+}\n+\n+class DragSourceButton extends Button implements Serializable,\n+        DragGestureListener,\n+        DragSourceListener {\n+    static final Clipboard systemClipboard =\n+            Toolkit.getDefaultToolkit().getSystemClipboard();\n+    final Transferable transferable;\n+\n+    public DragSourceButton(Transferable t) {\n+        super(\"DragSourceButton\");\n+\n+        this.transferable = t;\n+        DragSource ds = DragSource.getDefaultDragSource();\n+        ds.createDefaultDragGestureRecognizer(this, DnDConstants.ACTION_COPY,\n+                this);\n+    }\n+\n+    public void dragGestureRecognized(DragGestureEvent dge) {\n+        dge.startDrag(null, transferable, this);\n+    }\n+\n+    public void dragEnter(DragSourceDragEvent dsde) {\n+    }\n+\n+    public void dragExit(DragSourceEvent dse) {\n+    }\n+\n+    public void dragOver(DragSourceDragEvent dsde) {\n+        try {\n+            Transferable t = systemClipboard.getContents(null);\n+            if (t.isDataFlavorSupported(DataFlavor.stringFlavor)) {\n+                String str = (String) t.getTransferData(DataFlavor.stringFlavor);\n+            }\n+            systemClipboard.setContents(new StringSelection(\"SOURCE\"), null);\n+        } catch (IOException ioe) {\n+            ioe.printStackTrace();\n+            if (!ioe.getMessage().equals(\"Owner failed to convert data\")) {\n+                throw new RuntimeException(\"Owner failed to convert data\");\n+            }\n+        } catch (IllegalStateException e) {\n+            \/\/ IllegalStateExceptions do not indicate a bug in this case.\n+            \/\/ They result from concurrent modification of system clipboard\n+            \/\/ contents by the parent and child processes.\n+            \/\/ These exceptions are numerous, so we avoid dumping their\n+            \/\/ backtraces to prevent blocking child process io, which\n+            \/\/ causes test failure on timeout.\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public void dragDropEnd(DragSourceDropEvent dsde) {\n+        System.exit(DnDClipboardDeadlockTest.CODE_OK);\n+    }\n+\n+    public void dropActionChanged(DragSourceDragEvent dsde) {\n+    }\n+}\n+\n+class DragSourcePanel extends Panel {\n+\n+    final Dimension preferredDimension = new Dimension(200, 200);\n+\n+    public DragSourcePanel(Transferable t) {\n+        setLayout(new GridLayout(1, 1));\n+        add(new DragSourceButton(t));\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return preferredDimension;\n+    }\n+}\n+\n+class DropTargetPanel extends Panel implements DropTargetListener {\n+\n+    static final Clipboard systemClipboard =\n+            Toolkit.getDefaultToolkit().getSystemClipboard();\n+    final Dimension preferredDimension = new Dimension(200, 200);\n+\n+    public DropTargetPanel() {\n+        setBackground(Color.green);\n+        setDropTarget(new DropTarget(this, this));\n+        setLayout(new GridLayout(1, 1));\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return preferredDimension;\n+    }\n+\n+    public void dragEnter(DropTargetDragEvent dtde) {\n+        dtde.acceptDrag(DnDConstants.ACTION_COPY);\n+    }\n+\n+    public void dragExit(DropTargetEvent dte) {\n+    }\n+\n+    public void dragOver(DropTargetDragEvent dtde) {\n+        dtde.acceptDrag(DnDConstants.ACTION_COPY);\n+        try {\n+            Transferable t = systemClipboard.getContents(null);\n+            if (t.isDataFlavorSupported(DataFlavor.stringFlavor)) {\n+                String str = (String) t.getTransferData(DataFlavor.stringFlavor);\n+            }\n+            systemClipboard.setContents(new StringSelection(\"TARGET\"), null);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public void drop(DropTargetDropEvent dtde) {\n+        DropTargetContext dtc = dtde.getDropTargetContext();\n+\n+        if ((dtde.getSourceActions() & DnDConstants.ACTION_COPY) != 0) {\n+            dtde.acceptDrop(DnDConstants.ACTION_COPY);\n+        } else {\n+            dtde.rejectDrop();\n+            return;\n+        }\n+\n+        removeAll();\n+        final List list = new List();\n+        add(list);\n+\n+        Transferable t = dtde.getTransferable();\n+        DataFlavor[] dfs = t.getTransferDataFlavors();\n+\n+        for (int i = 0; i < dfs.length; i++) {\n+\n+            DataFlavor flavor = dfs[i];\n+            String str = null;\n+\n+            if (DataFlavor.stringFlavor.equals(flavor)) {\n+                try {\n+                    str = (String) t.getTransferData(flavor);\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+\n+            list.add(str + \":\" + flavor.getMimeType());\n+        }\n+\n+        dtc.dropComplete(true);\n+        validate();\n+    }\n+\n+    public void dropActionChanged(DropTargetDragEvent dtde) {\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/DnDClipboardDeadlockTest.java","additions":441,"deletions":0,"binary":false,"changes":441,"status":"added"},{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4343300\n+ * @summary tests that drag attempt doesn't cause crash when\n+ *          custom cursor is used\n+ * @key headful\n+ * @run main DnDCursorCrashTest\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.Cursor;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+import java.awt.Panel;\n+import java.awt.Robot;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceDragEvent;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetContext;\n+import java.awt.dnd.DropTargetDragEvent;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n+public class DnDCursorCrashTest {\n+    static final Frame frame = new Frame();\n+    static final DragSourcePanel dragSourcePanel = new DragSourcePanel();\n+    static final DropTargetPanel dropTargetPanel = new DropTargetPanel();\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                frame.setTitle(\"DnD Cursor Test Frame\");\n+                frame.setLocation(200, 200);\n+                frame.setLayout(new GridLayout(2, 1));\n+                frame.add(dragSourcePanel);\n+                frame.add(dropTargetPanel);\n+                frame.pack();\n+                frame.setVisible(true);\n+            });\n+\n+            Robot robot = new Robot();\n+            robot.delay(1000);\n+            robot.mouseMove(250, 250);\n+            robot.keyPress(KeyEvent.VK_CONTROL);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            for (int y = 250; y < 350; y += 5) {\n+                robot.mouseMove(250, y);\n+                robot.delay(100);\n+            }\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.keyRelease(KeyEvent.VK_CONTROL);\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(() -> frame.dispose());\n+            }\n+        }\n+    }\n+}\n+\n+class DragSourceButton extends Button implements Serializable,\n+                                                 Transferable,\n+                                                 DragGestureListener,\n+                                                 DragSourceListener {\n+    private final DataFlavor dataflavor =\n+        new DataFlavor(Button.class, \"DragSourceButton\");\n+\n+    public DragSourceButton() {\n+        this(\"DragSourceButton\");\n+    }\n+\n+    public DragSourceButton(String str) {\n+        super(str);\n+\n+        DragSource ds = DragSource.getDefaultDragSource();\n+        ds.createDefaultDragGestureRecognizer(this, DnDConstants.ACTION_COPY,\n+                                              this);\n+    }\n+\n+    public void dragGestureRecognized(DragGestureEvent dge) {\n+        dge.startDrag(new Cursor(Cursor.HAND_CURSOR), this, this);\n+    }\n+\n+    public void dragEnter(DragSourceDragEvent dsde) {}\n+\n+    public void dragExit(DragSourceEvent dse) {}\n+\n+    public void dragOver(DragSourceDragEvent dsde) {}\n+\n+    public void dragDropEnd(DragSourceDropEvent dsde) {}\n+\n+    public void dropActionChanged(DragSourceDragEvent dsde) {}\n+\n+    public Object getTransferData(DataFlavor flavor)\n+      throws UnsupportedFlavorException, IOException {\n+\n+        if (!isDataFlavorSupported(flavor)) {\n+            throw new UnsupportedFlavorException(flavor);\n+        }\n+\n+        Object retObj;\n+\n+        ByteArrayOutputStream baoStream = new ByteArrayOutputStream();\n+        ObjectOutputStream ooStream = new ObjectOutputStream(baoStream);\n+        ooStream.writeObject(this);\n+\n+        ByteArrayInputStream baiStream = new ByteArrayInputStream(baoStream.toByteArray());\n+        ObjectInputStream ois = new ObjectInputStream(baiStream);\n+        try {\n+            retObj = ois.readObject();\n+        } catch (ClassNotFoundException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(e.toString());\n+        }\n+\n+        return retObj;\n+    }\n+\n+    public DataFlavor[] getTransferDataFlavors() {\n+        return new DataFlavor[] { dataflavor };\n+    }\n+\n+    public boolean isDataFlavorSupported(DataFlavor dflavor) {\n+        return dataflavor.equals(dflavor);\n+    }\n+}\n+\n+class DragSourcePanel extends Panel {\n+\n+    final Dimension preferredDimension = new Dimension(200, 100);\n+\n+    public DragSourcePanel() {\n+        setLayout(new GridLayout(1, 1));\n+        add(new DragSourceButton());\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return preferredDimension;\n+    }\n+}\n+\n+class DropTargetPanel extends Panel implements DropTargetListener {\n+\n+    final Dimension preferredDimension = new Dimension(200, 100);\n+\n+    public DropTargetPanel() {\n+        setDropTarget(new DropTarget(this, this));\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return preferredDimension;\n+    }\n+\n+    public void dragEnter(DropTargetDragEvent dtde) {}\n+\n+    public void dragExit(DropTargetEvent dte) {}\n+\n+    public void dragOver(DropTargetDragEvent dtde) {}\n+\n+    public void dropActionChanged(DropTargetDragEvent dtde) {}\n+\n+    public void drop(DropTargetDropEvent dtde) {\n+        DropTargetContext dtc = dtde.getDropTargetContext();\n+\n+        if ((dtde.getSourceActions() & DnDConstants.ACTION_COPY) != 0) {\n+            dtde.acceptDrop(DnDConstants.ACTION_COPY);\n+        } else {\n+            dtde.rejectDrop();\n+        }\n+\n+        DataFlavor[] dfs = dtde.getCurrentDataFlavors();\n+        Component comp = null;\n+\n+        if (dfs != null && dfs.length >= 1) {\n+            Transferable transfer = dtde.getTransferable();\n+\n+            try {\n+                comp = (Component)transfer.getTransferData(dfs[0]);\n+            } catch (Throwable e) {\n+                e.printStackTrace();\n+                dtc.dropComplete(false);\n+            }\n+        }\n+        dtc.dropComplete(true);\n+\n+        add(comp);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/DnDCursorCrashTest.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4357905\n+ * @summary Tests that removal of the focus owner component during\n+ *          drop processing doesn't cause crash\n+ * @key headful\n+ * @run main DnDRemoveFocusOwnerCrashTest\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceDragEvent;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetContext;\n+import java.awt.dnd.DropTargetDragEvent;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.io.Serializable;\n+\n+public class DnDRemoveFocusOwnerCrashTest {\n+    public static final int FRAME_ACTIVATION_TIMEOUT = 1000;\n+    public static Frame frame;\n+    public static Robot robot;\n+    public static DragSourceButton dragSourceButton;\n+    static volatile Point p;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            robot = new Robot();\n+            robot.setAutoWaitForIdle(true);\n+            robot.delay(FRAME_ACTIVATION_TIMEOUT);\n+            EventQueue.invokeAndWait(() -> {\n+                frame = new Frame();\n+                dragSourceButton = new DragSourceButton();\n+                DropTargetPanel dropTargetPanel =\n+                        new DropTargetPanel(dragSourceButton);\n+                frame.add(new Button(\"Test\"));\n+                frame.setTitle(\"Remove Focus Owner Test Frame\");\n+                frame.setLocation(200, 200);\n+                frame.add(dropTargetPanel);\n+                frame.pack();\n+                frame.setVisible(true);\n+            });\n+\n+            robot.waitForIdle();\n+            robot.delay(FRAME_ACTIVATION_TIMEOUT);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                p = dragSourceButton.getLocationOnScreen();\n+                p.translate(10, 10);\n+            });\n+\n+            robot.delay(FRAME_ACTIVATION_TIMEOUT);\n+            robot.mouseMove(p.x, p.y);\n+            robot.delay(FRAME_ACTIVATION_TIMEOUT);\n+            robot.keyPress(KeyEvent.VK_CONTROL);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            for (int dy = 0; dy < 50; dy++) {\n+                robot.mouseMove(p.x, p.y + dy);\n+                robot.delay(10);\n+            }\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.keyRelease(KeyEvent.VK_CONTROL);\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    static class DragSourceButton extends Button implements Serializable,\n+            Transferable,\n+            DragGestureListener,\n+            DragSourceListener {\n+\n+        private static DataFlavor dataflavor;\n+\n+        static {\n+            try {\n+                dataflavor =\n+                        new DataFlavor(DataFlavor.javaJVMLocalObjectMimeType);\n+                dataflavor.setHumanPresentableName(\"Local Object Flavor\");\n+            } catch (ClassNotFoundException e) {\n+                e.printStackTrace();\n+                throw new ExceptionInInitializerError();\n+            }\n+        }\n+\n+        public DragSourceButton() {\n+            this(\"DragSourceButton\");\n+        }\n+\n+        public DragSourceButton(String str) {\n+            super(str);\n+\n+            DragSource ds = DragSource.getDefaultDragSource();\n+            ds.createDefaultDragGestureRecognizer(this, DnDConstants.ACTION_COPY,\n+                    this);\n+        }\n+\n+        public void dragGestureRecognized(DragGestureEvent dge) {\n+            dge.startDrag(null, this, this);\n+        }\n+\n+        public void dragEnter(DragSourceDragEvent dsde) {\n+        }\n+\n+        public void dragExit(DragSourceEvent dse) {\n+        }\n+\n+        public void dragOver(DragSourceDragEvent dsde) {\n+        }\n+\n+        public void dragDropEnd(DragSourceDropEvent dsde) {\n+        }\n+\n+        public void dropActionChanged(DragSourceDragEvent dsde) {\n+        }\n+\n+        public Object getTransferData(DataFlavor flavor)\n+                throws UnsupportedFlavorException {\n+\n+            if (!isDataFlavorSupported(flavor)) {\n+                throw new UnsupportedFlavorException(flavor);\n+            }\n+\n+            return this;\n+        }\n+\n+        public DataFlavor[] getTransferDataFlavors() {\n+            return new DataFlavor[]{dataflavor};\n+        }\n+\n+        public boolean isDataFlavorSupported(DataFlavor dflavor) {\n+            return dataflavor.equals(dflavor);\n+        }\n+    }\n+\n+    static class DropTargetPanel extends Panel implements DropTargetListener {\n+\n+        public DropTargetPanel(DragSourceButton button) {\n+            setLayout(new FlowLayout(FlowLayout.CENTER, 50, 50));\n+            add(button);\n+            setDropTarget(new DropTarget(this, this));\n+        }\n+\n+        public void dragEnter(DropTargetDragEvent dtde) {\n+        }\n+\n+        public void dragExit(DropTargetEvent dte) {\n+        }\n+\n+        public void dragOver(DropTargetDragEvent dtde) {\n+        }\n+\n+        public void dropActionChanged(DropTargetDragEvent dtde) {\n+        }\n+\n+        public void drop(DropTargetDropEvent dtde) {\n+            removeAll();\n+\n+            DropTargetContext dtc = dtde.getDropTargetContext();\n+\n+            if ((dtde.getSourceActions() & DnDConstants.ACTION_COPY) != 0) {\n+                dtde.acceptDrop(DnDConstants.ACTION_COPY);\n+            } else {\n+                dtde.rejectDrop();\n+            }\n+\n+            DataFlavor[] dfs = dtde.getCurrentDataFlavors();\n+            Component comp = null;\n+\n+            if (dfs != null && dfs.length >= 1) {\n+                Transferable transfer = dtde.getTransferable();\n+\n+                try {\n+                    comp = (Component) transfer.getTransferData(dfs[0]);\n+                } catch (Throwable e) {\n+                    e.printStackTrace();\n+                    dtc.dropComplete(false);\n+                }\n+            }\n+            dtc.dropComplete(true);\n+\n+            add(comp);\n+            validate();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/DnDRemoveFocusOwnerCrashTest.java","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6362095\n+ * @summary Tests basic DnD functionality to a wordpad\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DnDToWordpadTest\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Panel;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceDragEvent;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.InvalidDnDOperationException;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import javax.imageio.ImageIO;\n+\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB;\n+\n+public class DnDToWordpadTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                The test window contains a yellow button. Click on the button\n+                to copy image into the clipboard or drag the image.\n+                Paste or drop the image over Wordpad (when the mouse\n+                enters the Wordpad during the drag, the application\n+                should change the cursor to indicate that a copy operation is\n+                about to happen; release the mouse button).\n+                An image of a red rectangle should appear inside the document.\n+                You should be able to repeat this operation multiple times.\n+                Please, click \"Pass\" if above conditions are true,\n+                otherwise click \"Fail\".\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(35)\n+                .testUI(DnDToWordpadTest::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Frame createUI() {\n+        Frame f = new Frame(\"DnD To WordPad Test\");\n+        Panel mainPanel;\n+        Component dragSource;\n+\n+        mainPanel = new Panel();\n+        mainPanel.setLayout(null);\n+\n+        mainPanel.setBackground(Color.black);\n+        try {\n+            dragSource = new DnDSource(\"Drag ME!\");\n+            mainPanel.add(dragSource);\n+            f.add(mainPanel);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+\n+        f.setSize(200, 200);\n+        return f;\n+    }\n+}\n+\n+class DnDSource extends Button implements Transferable,\n+        DragGestureListener,\n+        DragSourceListener {\n+    private DataFlavor m_df;\n+    private transient int m_dropAction;\n+    private Image m_img;\n+\n+    DnDSource(String label) throws IOException {\n+        super(label);\n+\n+        setBackground(Color.yellow);\n+        setForeground(Color.blue);\n+        setSize(200, 120);\n+\n+        m_df = DataFlavor.imageFlavor;\n+\n+        DragSource dragSource = new DragSource();\n+        dragSource.createDefaultDragGestureRecognizer(\n+                this,\n+                DnDConstants.ACTION_COPY_OR_MOVE,\n+                this\n+        );\n+        dragSource.addDragSourceListener(this);\n+\n+        \/\/ Create test gif image to drag\n+        Path p = Path.of(System.getProperty(\"test.classes\", \".\"));\n+        BufferedImage bImg = new BufferedImage(79, 109, TYPE_INT_ARGB);\n+        Graphics2D cg = bImg.createGraphics();\n+        cg.setColor(Color.RED);\n+        cg.fillRect(0, 0, 79, 109);\n+        ImageIO.write(bImg, \"png\", new File(p + java.io.File.separator +\n+                \"DnDSource_Red.gif\"));\n+\n+        m_img = Toolkit.getDefaultToolkit()\n+                .getImage(System.getProperty(\"test.classes\", \".\")\n+                + java.io.File.separator + \"DnDSource_Red.gif\");\n+\n+        addActionListener(\n+                ae -> Toolkit.getDefaultToolkit().getSystemClipboard().setContents(\n+                        (Transferable) DnDSource.this,\n+                        null\n+                )\n+        );\n+    }\n+\n+    public void paint(Graphics g) {\n+        g.drawImage(m_img, 10, 10, null);\n+    }\n+\n+    \/**\n+     * a Drag gesture has been recognized\n+     *\/\n+\n+    public void dragGestureRecognized(DragGestureEvent dge) {\n+        System.err.println(\"starting Drag\");\n+        try {\n+            dge.startDrag(null, this, this);\n+        } catch (InvalidDnDOperationException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    \/**\n+     * as the hotspot enters a platform dependent drop site\n+     *\/\n+\n+    public void dragEnter(DragSourceDragEvent dsde) {\n+        System.err.println(\"[Source] dragEnter\");\n+    }\n+\n+    \/**\n+     * as the hotspot moves over a platform dependent drop site\n+     *\/\n+\n+    public void dragOver(DragSourceDragEvent dsde) {\n+        System.err.println(\"[Source] dragOver\");\n+        m_dropAction = dsde.getDropAction();\n+        System.out.println(\"m_dropAction = \" + m_dropAction);\n+    }\n+\n+    \/**\n+     * as the operation changes\n+     *\/\n+\n+    public void dragGestureChanged(DragSourceDragEvent dsde) {\n+        System.err.println(\"[Source] dragGestureChanged\");\n+        m_dropAction = dsde.getDropAction();\n+        System.out.println(\"m_dropAction = \" + m_dropAction);\n+    }\n+\n+    \/**\n+     * as the hotspot exits a platform dependent drop site\n+     *\/\n+\n+    public void dragExit(DragSourceEvent dsde) {\n+        System.err.println(\"[Source] dragExit\");\n+    }\n+\n+    \/**\n+     * as the operation completes\n+     *\/\n+\n+    public void dragDropEnd(DragSourceDropEvent dsde) {\n+        System.err.println(\"[Source] dragDropEnd\");\n+    }\n+\n+    public void dropActionChanged(DragSourceDragEvent dsde) {\n+        System.err.println(\"[Source] dropActionChanged\");\n+        m_dropAction = dsde.getDropAction();\n+        System.out.println(\"m_dropAction = \" + m_dropAction);\n+    }\n+\n+    public DataFlavor[] getTransferDataFlavors() {\n+        return new DataFlavor[]{m_df};\n+    }\n+\n+    public boolean isDataFlavorSupported(DataFlavor sdf) {\n+        System.err.println(\"[Source] isDataFlavorSupported\" + m_df.equals(sdf));\n+        return m_df.equals(sdf);\n+    }\n+\n+    public Object getTransferData(DataFlavor tdf) throws UnsupportedFlavorException {\n+        if (!m_df.equals(tdf)) {\n+            throw new UnsupportedFlavorException(tdf);\n+        }\n+        System.err.println(\"[Source] Ok\");\n+        return m_img;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/DnDToWordpadTest.java","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4187490\n+ * @summary Verify that Non-ASCII file names can be dragged and dropped\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual NonAsciiFilenames\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetDragEvent;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.io.File;\n+import java.util.AbstractList;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+\n+public class NonAsciiFilenames {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                This test must be run on an OS which does not use ISO 8859-1\n+                as its default encoding.\n+\n+                Open a native file browsing application, such as Windows\n+                Explorer. Try to find a file whose name uses non-ISO 8859-1\n+                characters. Create a file and name it such that it contains\n+                non-ISO 8859-1 characters (For ex. , , , , ). Drag\n+                the file from the native application and drop it on the test\n+                Frame. If the file name appears normally, then the test passes.\n+                If boxes or question marks appear for characters, or if you see\n+                the word \"Error\", then the test fails.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(35)\n+                .testUI(NonAsciiFilenames::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static JFrame createUI() {\n+        JFrame frame = new JFrame();\n+        frame.setTitle(\"DropLabel test\");\n+        frame.getContentPane().add(new DropLabel(\"Drop here\"));\n+        frame.setSize(300, 100);\n+        return frame;\n+    }\n+}\n+\n+class DropLabel extends JLabel implements DropTargetListener {\n+    public DropLabel(String s) {\n+        setText(s);\n+        new DropTarget(this, DnDConstants.ACTION_COPY, this, true);\n+        showDrop(false);\n+    }\n+\n+    private void showDrop(boolean b) {\n+        setForeground(b ? Color.white : Color.black);\n+    }\n+\n+    \/**\n+     * Configure to desired flavor of dropped data.\n+     *\/\n+    private DataFlavor getDesiredFlavor() {\n+        return DataFlavor.javaFileListFlavor;\n+    }\n+\n+    \/**\n+     * Check to make sure that the contains the expected object types.\n+     *\/\n+    private void checkDroppedData(Object data) {\n+        System.out.println(\"Got data: \" + data.getClass().getName());\n+        if (data instanceof AbstractList) {\n+            AbstractList files = (AbstractList) data;\n+            if (((File) files.get(0)).isFile())\n+                setText(((File) files.get(0)).toString());\n+            else\n+                setText(\"Error: not valid file: \" +\n+                        ((File) files.get(0)).toString());\n+        } else {\n+            System.out.println(\"Error: wrong type of data dropped\");\n+        }\n+    }\n+\n+    private boolean isDragOk(DropTargetDragEvent e) {\n+        boolean canDrop = false;\n+        try {\n+            canDrop = e.isDataFlavorSupported(getDesiredFlavor());\n+        } catch (Exception ex) {\n+        }\n+\n+        if (canDrop)\n+            e.acceptDrag(DnDConstants.ACTION_COPY);\n+        else\n+            e.rejectDrag();\n+        showDrop(canDrop);\n+        return canDrop;\n+    }\n+\n+    public void dragEnter(DropTargetDragEvent e) {\n+        isDragOk(e);\n+    }\n+\n+\n+    public void dragOver(DropTargetDragEvent e) {\n+        isDragOk(e);\n+    }\n+\n+    public void dropActionChanged(DropTargetDragEvent e) {\n+        isDragOk(e);\n+    }\n+\n+    public void dragExit(DropTargetEvent e) {\n+        showDrop(false);\n+    }\n+\n+    public void drop(DropTargetDropEvent e) {\n+        try {\n+            e.acceptDrop(DnDConstants.ACTION_COPY);\n+            checkDroppedData(e.getTransferable().\n+                    getTransferData(getDesiredFlavor()));\n+        } catch (Exception err) {\n+        }\n+        e.dropComplete(true);\n+        showDrop(false);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/NonAsciiFilenames.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/awt\/dnd\/URLDragTest\/URLDragTest.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/awt\/dnd\/URLDragTest.java","status":"renamed"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Graphics2D;\n+import java.awt.Rectangle;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+\n+import javax.imageio.ImageIO;\n+\n+\/*\n+ * @test\n+ * @bug 8339974\n+ * @summary Verifies that text draws correctly using scaled and rotated fonts.\n+ *\/\n+public class RotatedScaledFontTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        test(0);\n+        test(1);\n+        test(2);\n+        test(3);\n+        test(4);\n+    }\n+\n+    private static void test(int quadrants) throws Exception {\n+\n+        int size = 2000;\n+        int center = size \/ 2;\n+        Font base = new Font(\"SansSerif\", Font.PLAIN, 10);\n+        BufferedImage image = new BufferedImage(size, size, BufferedImage.TYPE_BYTE_BINARY);\n+        Graphics2D g2d = image.createGraphics();\n+\n+        try {\n+            for (int scale = 1; scale <= 100; scale++) {\n+                AffineTransform at = AffineTransform.getQuadrantRotateInstance(quadrants);\n+                at.scale(scale, scale);\n+                Font font = base.deriveFont(at);\n+                g2d.setColor(Color.WHITE);\n+                g2d.fillRect(0, 0, image.getWidth(), image.getHeight());\n+                g2d.setColor(Color.BLACK);\n+                g2d.setFont(font);\n+                g2d.drawString(\"TEST\", center, center);\n+                Rectangle bounds = findTextBoundingBox(image);\n+                if (bounds == null) {\n+                    saveImage(\"bounds\", image);\n+                    throw new RuntimeException(\"Text missing: scale=\" + scale\n+                        + \", quadrants=\" + quadrants + \", center=\" + center);\n+                }\n+                boolean horizontal = (bounds.width > bounds.height);\n+                boolean expectedHorizontal = (quadrants % 2 == 0);\n+                if (horizontal != expectedHorizontal) {\n+                    saveImage(\"orientation\", image);\n+                    throw new RuntimeException(\"Wrong orientation: scale=\" + scale\n+                        + \", quadrants=\" + quadrants + \", center=\" + center\n+                        + \", bounds=\" + bounds + \", horizontal=\" + horizontal\n+                        + \", expectedHorizontal=\" + expectedHorizontal);\n+                }\n+                if (!roughlyEqual(center, bounds.x, scale) && !roughlyEqual(center, bounds.x + bounds.width, scale)) {\n+                    saveImage(\"xedge\", image);\n+                    throw new RuntimeException(\"No x-edge at center: scale=\" + scale\n+                        + \", quadrants=\" + quadrants + \", center=\" + center\n+                        + \", bounds=\" + bounds);\n+                }\n+                if (!roughlyEqual(center, bounds.y, scale) && !roughlyEqual(center, bounds.y + bounds.height, scale)) {\n+                    saveImage(\"yedge\", image);\n+                    throw new RuntimeException(\"No y-edge at center: scale=\" + scale\n+                        + \", quadrants=\" + quadrants + \", center=\" + center\n+                        + \", bounds=\" + bounds);\n+                }\n+            }\n+        } finally {\n+            g2d.dispose();\n+        }\n+    }\n+\n+    private static Rectangle findTextBoundingBox(BufferedImage image) {\n+        int minX = Integer.MAX_VALUE;\n+        int minY = Integer.MAX_VALUE;\n+        int maxX = Integer.MIN_VALUE;\n+        int maxY = Integer.MIN_VALUE;\n+        int width = image.getWidth();\n+        int height = image.getHeight();\n+        int[] rowPixels = new int[width];\n+        for (int y = 0; y < height; y++) {\n+            image.getRGB(0, y, width, 1, rowPixels, 0, width);\n+            for (int x = 0; x < width; x++) {\n+                boolean white = (rowPixels[x] == -1);\n+                if (!white) {\n+                    if (x < minX) {\n+                        minX = x;\n+                    }\n+                    if (y < minY) {\n+                        minY = y;\n+                    }\n+                    if (x > maxX) {\n+                        maxX = x;\n+                    }\n+                    if (y > maxY) {\n+                        maxY = y;\n+                    }\n+                }\n+            }\n+        }\n+        if (minX != Integer.MAX_VALUE) {\n+            return new Rectangle(minX, minY, maxX - minX, maxY - minY);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static boolean roughlyEqual(int x1, int x2, int scale) {\n+        return Math.abs(x1 - x2) <= Math.ceil(scale \/ 2d) + 1; \/\/ higher scale = higher allowed variance\n+    }\n+\n+    private static void saveImage(String name, BufferedImage image) {\n+        try {\n+            String dir = System.getProperty(\"test.classes\", \".\");\n+            String path = dir + File.separator + name + \".png\";\n+            File file = new File(path);\n+            ImageIO.write(image, \"png\", file);\n+        } catch (Exception e) {\n+            \/\/ we tried, and that's enough\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/font\/FontScaling\/RotatedScaledFontTest.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-        File dir = new File(System.getProperty(\"test.src\", \".\"));\n+        File dir = new File(\".\");\n","filename":"test\/jdk\/java\/io\/FileInputStream\/ReadXBytes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,2 @@\n+    private static final int MAX_RETRIES = 3;\n+\n@@ -136,8 +138,13 @@\n-    private Socket newUdpSocket() throws IOException {\n-        Socket s = null;\n-\n-        try {\n-            s = new Socket(InetAddress.getLoopbackAddress(), 8000, false);\n-        } catch (BindException unexpected) {\n-            System.out.println(\"BindException caught retry Socket creation\");\n-            s = new Socket(InetAddress.getLoopbackAddress(), 8000, false);\n+    private Socket newUdpSocket() throws IOException, InterruptedException {\n+        BindException unexpected = null;\n+        for (int i=0; i < MAX_RETRIES; i++) {\n+            try {\n+                return new Socket(InetAddress.getLoopbackAddress(), 8000, false);\n+            } catch (BindException be) {\n+                unexpected = be;\n+                if (i != MAX_RETRIES - 1) {\n+                    System.out.printf(\"BindException caught: retry Socket creation [%s\/%s]%n\",\n+                            i + 1, MAX_RETRIES);\n+                    Thread.sleep(10 + 10 * i);\n+                }\n+            }\n@@ -145,1 +152,1 @@\n-        return s;\n+        throw unexpected;\n","filename":"test\/jdk\/java\/net\/Socket\/UdpSocket.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import java.net.ProtocolException;\n@@ -364,1 +365,1 @@\n-            assertEquals(IOException.class, testThrowable.getClass());\n+            assertEquals(testThrowable.getClass(), ProtocolException.class);\n","filename":"test\/jdk\/java\/net\/httpclient\/ExpectContinueTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+        if (message.contains(\"connection closed locally\")) return true;\n","filename":"test\/jdk\/java\/net\/httpclient\/ShutdownNow.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.net.ProtocolException;\n@@ -198,1 +199,2 @@\n-        assertEquals(t.getCause().getClass(), IOException.class, \"Expected an IOException but got \" + t.getCause());\n+        assertEquals(t.getCause().getClass(), ProtocolException.class,\n+                \"Expected a ProtocolException but got \" + t.getCause());\n@@ -225,1 +227,4 @@\n-        Http2PushPromiseHeadersExchangeImpl(int streamid, String method, HttpHeaders reqheaders, HttpHeadersBuilder rspheadersBuilder, URI uri, InputStream is, SSLSession sslSession, BodyOutputStream os, Http2TestServerConnection conn, boolean pushAllowed) {\n+        Http2PushPromiseHeadersExchangeImpl(int streamid, String method, HttpHeaders reqheaders,\n+                                            HttpHeadersBuilder rspheadersBuilder, URI uri, InputStream is,\n+                                            SSLSession sslSession, BodyOutputStream os,\n+                                            Http2TestServerConnection conn, boolean pushAllowed) {\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/PushPromiseContinuation.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,0 +244,1 @@\n+        public abstract InetSocketAddress getLocalAddress();\n@@ -306,1 +307,4 @@\n-\n+            @Override\n+            public InetSocketAddress getLocalAddress() {\n+                return exchange.getLocalAddress();\n+            }\n@@ -373,0 +377,4 @@\n+            @Override\n+            public InetSocketAddress getLocalAddress() {\n+                return exchange.getLocalAddress();\n+            }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/common\/HttpServerAdapters.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.httpclient.test.lib.http2;\n+\n+import java.util.function.*;\n+\n+import jdk.internal.net.http.hpack.Encoder;\n+\n+import static java.lang.String.format;\n+import static java.util.Objects.requireNonNull;\n+import static jdk.internal.net.http.hpack.HPACK.Logger.Level.EXTRA;\n+import static jdk.internal.net.http.hpack.HPACK.Logger.Level.NORMAL;\n+\n+public class HpackTestEncoder extends Encoder {\n+\n+    public HpackTestEncoder(int maxCapacity) {\n+        super(maxCapacity);\n+    }\n+\n+    \/**\n+     * Sets up the given header {@code (name, value)} with possibly sensitive\n+     * value.\n+     *\n+     * <p> If the {@code value} is sensitive (think security, secrecy, etc.)\n+     * this encoder will compress it using a special representation\n+     * (see <a href=\"https:\/\/tools.ietf.org\/html\/rfc7541#section-6.2.3\">6.2.3.  Literal Header Field Never Indexed<\/a>).\n+     *\n+     * <p> Fixates {@code name} and {@code value} for the duration of encoding.\n+     *\n+     * @param name\n+     *         the name\n+     * @param value\n+     *         the value\n+     * @param sensitive\n+     *         whether or not the value is sensitive\n+     *\n+     * @throws NullPointerException\n+     *         if any of the arguments are {@code null}\n+     * @throws IllegalStateException\n+     *         if the encoder hasn't fully encoded the previous header, or\n+     *         hasn't yet started to encode it\n+     * @see #header(CharSequence, CharSequence)\n+     * @see DecodingCallback#onDecoded(CharSequence, CharSequence, boolean)\n+     *\/\n+    public void header(CharSequence name,\n+                       CharSequence value,\n+                       boolean sensitive) throws IllegalStateException {\n+        if (sensitive || getMaxCapacity() == 0) {\n+            super.header(name, value, true);\n+        } else {\n+            header(name, value, false, (n,v) -> false);\n+        }\n+    }\n+    \/**\n+     * Sets up the given header {@code (name, value)} with possibly sensitive\n+     * value.\n+     *\n+     * <p> If the {@code value} is sensitive (think security, secrecy, etc.)\n+     * this encoder will compress it using a special representation\n+     * (see <a href=\"https:\/\/tools.ietf.org\/html\/rfc7541#section-6.2.3\">6.2.3.  Literal Header Field Never Indexed<\/a>).\n+     *\n+     * <p> Fixates {@code name} and {@code value} for the duration of encoding.\n+     *\n+     * @param name\n+     *         the name\n+     * @param value\n+     *         the value\n+     * @param insertionPolicy\n+     *         a bipredicate to indicate whether a name value pair\n+     *         should be added to the dynamic table\n+     *\n+     * @throws NullPointerException\n+     *         if any of the arguments are {@code null}\n+     * @throws IllegalStateException\n+     *         if the encoder hasn't fully encoded the previous header, or\n+     *         hasn't yet started to encode it\n+     * @see #header(CharSequence, CharSequence)\n+     * @see DecodingCallback#onDecoded(CharSequence, CharSequence, boolean)\n+     *\/\n+    public void header(CharSequence name,\n+                       CharSequence value,\n+                       BiPredicate<CharSequence, CharSequence> insertionPolicy)\n+            throws IllegalStateException {\n+        header(name, value, false, insertionPolicy);\n+    }\n+\n+    \/**\n+     * Sets up the given header {@code (name, value)} with possibly sensitive\n+     * value.\n+     *\n+     * <p> If the {@code value} is sensitive (think security, secrecy, etc.)\n+     * this encoder will compress it using a special representation\n+     * (see <a href=\"https:\/\/tools.ietf.org\/html\/rfc7541#section-6.2.3\">\n+     *     6.2.3.  Literal Header Field Never Indexed<\/a>).\n+     *\n+     * <p> Fixates {@code name} and {@code value} for the duration of encoding.\n+     *\n+     * @param name\n+     *         the name\n+     * @param value\n+     *         the value\n+     * @param sensitive\n+     *         whether or not the value is sensitive\n+     * @param insertionPolicy\n+     *         a bipredicate to indicate whether a name value pair\n+     *         should be added to the dynamic table\n+     *\n+     * @throws NullPointerException\n+     *         if any of the arguments are {@code null}\n+     * @throws IllegalStateException\n+     *         if the encoder hasn't fully encoded the previous header, or\n+     *         hasn't yet started to encode it\n+     * @see #header(CharSequence, CharSequence)\n+     * @see DecodingCallback#onDecoded(CharSequence, CharSequence, boolean)\n+     *\/\n+    public void header(CharSequence name,\n+                       CharSequence value,\n+                       boolean sensitive,\n+                       BiPredicate<CharSequence, CharSequence> insertionPolicy)\n+            throws IllegalStateException {\n+        if (sensitive == true || getMaxCapacity() == 0 || !insertionPolicy.test(name, value)) {\n+            super.header(name, value, sensitive);\n+            return;\n+        }\n+        var logger = logger();\n+        \/\/ Arguably a good balance between complexity of implementation and\n+        \/\/ efficiency of encoding\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        var t = getHeaderTable();\n+        int index = tableIndexOf(name, value);\n+        if (logger.isLoggable(NORMAL)) {\n+            logger.log(NORMAL, () -> format(\"encoding with indexing ('%s', '%s'): index:%s\",\n+                    name, value, index));\n+        }\n+        if (index > 0) {\n+            indexed(index);\n+        } else {\n+            boolean huffmanValue = isHuffmanBetterFor(value);\n+            if (index < 0) {\n+                literalWithIndexing(-index, value, huffmanValue);\n+            } else {\n+                boolean huffmanName = isHuffmanBetterFor(name);\n+                literalWithIndexing(name, huffmanName, value, huffmanValue);\n+            }\n+        }\n+    }\n+\n+    protected int calculateCapacity(int maxCapacity) {\n+        return maxCapacity;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/HpackTestEncoder.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.List;\n@@ -33,0 +34,1 @@\n+import java.util.function.BiPredicate;\n@@ -35,0 +37,1 @@\n+import jdk.internal.net.http.frame.Http2Frame;\n@@ -56,0 +59,6 @@\n+    default void sendResponseHeaders(int rCode, long responseLength,\n+                                     BiPredicate<CharSequence, CharSequence> insertionPolicy)\n+            throws IOException {\n+        sendResponseHeaders(rCode, responseLength);\n+    }\n+\n@@ -68,0 +77,4 @@\n+    default void sendFrames(List<Http2Frame> frames) throws IOException {\n+        throw new UnsupportedOperationException(\"not implemented\");\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestExchange.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.net.http.frame.Http2Frame;\n@@ -42,0 +43,1 @@\n+import java.util.function.BiPredicate;\n@@ -135,1 +137,0 @@\n-    @Override\n@@ -137,0 +138,6 @@\n+        sendResponseHeaders(rCode, responseLength, (n,v) -> false);\n+    }\n+    @Override\n+    public void sendResponseHeaders(int rCode, long responseLength,\n+                                    BiPredicate<CharSequence, CharSequence> insertionPolicy)\n+            throws IOException {\n@@ -150,1 +157,1 @@\n-                = new ResponseHeaders(headers);\n+                = new ResponseHeaders(headers, insertionPolicy);\n@@ -175,0 +182,5 @@\n+    @Override\n+    public void sendFrames(List<Http2Frame> frames) throws IOException {\n+        conn.sendFrames(frames);\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestExchangeImpl.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.internal.net.http.common.Log;\n+import jdk.internal.net.http.frame.ContinuationFrame;\n@@ -83,0 +85,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -90,0 +93,1 @@\n+import static jdk.internal.net.http.frame.SettingsFrame.DEFAULT_MAX_FRAME_SIZE;\n@@ -108,1 +112,1 @@\n-    volatile Encoder hpackOut;\n+    volatile HpackTestEncoder hpackOut;\n@@ -424,1 +428,3 @@\n-        return clientSettings.getParameter(SettingsFrame.MAX_FRAME_SIZE);\n+        var max = clientSettings.getParameter(SettingsFrame.MAX_FRAME_SIZE);\n+        if (max <= 0) max = DEFAULT_MAX_FRAME_SIZE;\n+        return max;\n@@ -485,1 +491,1 @@\n-        hpackOut = new Encoder(serverSettings.getParameter(HEADER_TABLE_SIZE));\n+        hpackOut = new HpackTestEncoder(serverSettings.getParameter(HEADER_TABLE_SIZE));\n@@ -815,0 +821,8 @@\n+    public void sendFrames(List<Http2Frame> frames) throws IOException {\n+        synchronized (outputQ) {\n+            for (var frame : frames) {\n+                outputQ.put(frame);\n+            }\n+        }\n+    }\n+\n@@ -941,0 +955,2 @@\n+    final ReentrantLock headersLock = new ReentrantLock();\n+\n@@ -943,0 +959,5 @@\n+        return encodeHeaders(headers, (n,v) -> false);\n+    }\n+\n+    public List<ByteBuffer> encodeHeaders(HttpHeaders headers,\n+                                          BiPredicate<CharSequence, CharSequence> insertionPolicy) {\n@@ -947,13 +968,16 @@\n-        for (Map.Entry<String, List<String>> entry : headers.map().entrySet()) {\n-            List<String> values = entry.getValue();\n-            String key = entry.getKey().toLowerCase();\n-            for (String value : values) {\n-                do {\n-                    hpackOut.header(key, value);\n-                    encoded = hpackOut.encode(buf);\n-                    if (!encoded) {\n-                        buf.flip();\n-                        buffers.add(buf);\n-                        buf = getBuffer();\n-                    }\n-                } while (!encoded);\n+        headersLock.lock();\n+        try {\n+            for (Map.Entry<String, List<String>> entry : headers.map().entrySet()) {\n+                List<String> values = entry.getValue();\n+                String key = entry.getKey().toLowerCase();\n+                for (String value : values) {\n+                    hpackOut.header(key, value, insertionPolicy);\n+                    do {\n+                        encoded = hpackOut.encode(buf);\n+                        if (!encoded && !buf.hasRemaining()) {\n+                            buf.flip();\n+                            buffers.add(buf);\n+                            buf = getBuffer();\n+                        }\n+                    } while (!encoded);\n+                }\n@@ -961,0 +985,2 @@\n+        } finally {\n+            headersLock.unlock();\n@@ -973,4 +999,5 @@\n-        for (Map.Entry<String, String> entry : headers) {\n-            String value = entry.getValue();\n-            String key = entry.getKey().toLowerCase();\n-            do {\n+        headersLock.lock();\n+        try {\n+            for (Map.Entry<String, String> entry : headers) {\n+                String value = entry.getValue();\n+                String key = entry.getKey().toLowerCase();\n@@ -978,7 +1005,11 @@\n-                encoded = hpackOut.encode(buf);\n-                if (!encoded) {\n-                    buf.flip();\n-                    buffers.add(buf);\n-                    buf = getBuffer();\n-                }\n-            } while (!encoded);\n+                do {\n+                    encoded = hpackOut.encode(buf);\n+                    if (!encoded && !buf.hasRemaining()) {\n+                        buf.flip();\n+                        buffers.add(buf);\n+                        buf = getBuffer();\n+                    }\n+                } while (!encoded);\n+            }\n+        } finally {\n+            headersLock.unlock();\n@@ -1011,4 +1042,44 @@\n-                if (frame instanceof ResponseHeaders) {\n-                    ResponseHeaders rh = (ResponseHeaders)frame;\n-                    HeadersFrame hf = new HeadersFrame(rh.streamid(), rh.getFlags(), encodeHeaders(rh.headers));\n-                    writeFrame(hf);\n+                if (frame instanceof ResponseHeaders rh) {\n+                    var buffers = encodeHeaders(rh.headers, rh.insertionPolicy);\n+                    int maxFrameSize = Math.min(rh.getMaxFrameSize(), getMaxFrameSize() - 64);\n+                    int next = 0;\n+                    int cont = 0;\n+                    do {\n+                        \/\/ If the total size of headers exceeds the max frame\n+                        \/\/ size we need to split the headers into one\n+                        \/\/ HeadersFrame + N x ContinuationFrames\n+                        int remaining = maxFrameSize;\n+                        var list = new ArrayList<ByteBuffer>(buffers.size());\n+                        for (; next < buffers.size(); next++) {\n+                            var b = buffers.get(next);\n+                            var len = b.remaining();\n+                            if (!b.hasRemaining()) continue;\n+                            if (len <= remaining) {\n+                                remaining -= len;\n+                                list.add(b);\n+                            } else {\n+                                if (next == 0) {\n+                                    list.add(b.slice(b.position(), remaining));\n+                                    b.position(b.position() + remaining);\n+                                    remaining = 0;\n+                                }\n+                                break;\n+                            }\n+                        }\n+                        int flags = rh.getFlags();\n+                        if (next != buffers.size()) {\n+                            flags = flags & ~HeadersFrame.END_HEADERS;\n+                        }\n+                        if (cont > 0)  {\n+                            flags = flags & ~HeadersFrame.END_STREAM;\n+                        }\n+                        HeaderFrame hf = cont == 0\n+                                ? new HeadersFrame(rh.streamid(), flags, list)\n+                                : new ContinuationFrame(rh.streamid(), flags, list);\n+                        if (Log.headers()) {\n+                            \/\/ avoid too much chatter: log only if Log.headers() is enabled\n+                            System.err.println(\"TestServer writing \" + hf);\n+                        }\n+                        writeFrame(hf);\n+                        cont++;\n+                    } while (next < buffers.size());\n@@ -1325,1 +1396,4 @@\n-        HttpHeaders headers;\n+        final HttpHeaders headers;\n+        final BiPredicate<CharSequence, CharSequence> insertionPolicy;\n+\n+        final int maxFrameSize;\n@@ -1328,0 +1402,9 @@\n+            this(headers, (n,v) -> false);\n+        }\n+        public ResponseHeaders(HttpHeaders headers, BiPredicate<CharSequence, CharSequence> insertionPolicy) {\n+            this(headers, insertionPolicy, Integer.MAX_VALUE);\n+        }\n+\n+        public ResponseHeaders(HttpHeaders headers,\n+                               BiPredicate<CharSequence, CharSequence> insertionPolicy,\n+                               int maxFrameSize) {\n@@ -1330,0 +1413,6 @@\n+            this.insertionPolicy = insertionPolicy;\n+            this.maxFrameSize = maxFrameSize;\n+        }\n+\n+        public int getMaxFrameSize() {\n+            return maxFrameSize;\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServerConnection.java","additions":121,"deletions":32,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-        File file = new File(System.getProperty(\"test.src\", \".\"), \"test.dat\");\n+        File file = new File(\".\", \"test.dat\");\n","filename":"test\/jdk\/java\/nio\/MappedByteBuffer\/ForceException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-        Path file = Path.of(System.getProperty(\"test.src\", \".\"), \"junk\");\n+        Path file = Path.of(\".\", \"junk\");\n","filename":"test\/jdk\/java\/nio\/MappedByteBuffer\/ForceViews.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024 Alibaba Group Holding Limited. All Rights Reserved.\n@@ -28,3 +29,3 @@\n- * @library  ..\/.. \/test\/lib\n- * @build jdk.test.lib.Platform\n- * @run main CreationTime\n+ * @library  ..\/.. \/test\/lib \/java\/foreign\n+ * @build jdk.test.lib.Platform NativeTestHelper\n+ * @run main\/othervm\/native --enable-native-access=ALL-UNNAMED CreationTime\n@@ -37,3 +38,3 @@\n- * @library  ..\/.. \/test\/lib\n- * @build jdk.test.lib.Platform\n- * @run main CreationTime .\n+ * @library  ..\/.. \/test\/lib \/java\/foreign\n+ * @build jdk.test.lib.Platform NativeTestHelper\n+ * @run main\/othervm\/native --enable-native-access=ALL-UNNAMED CreationTime .\n@@ -54,2 +55,0 @@\n-    private static final java.io.PrintStream err = System.err;\n-\n@@ -81,8 +80,3 @@\n-            System.out.println(\"creationTime.toMillis() == \" + creationTime.toMillis());\n-            \/\/ If the file system doesn't support birth time, then skip this test\n-            if (creationTime.toMillis() == 0) {\n-                throw new SkippedException(\"birth time not support for: \" + file);\n-            } else {\n-                err.println(\"File creation time reported as: \" + creationTime);\n-                throw new RuntimeException(\"Expected to be close to: \" + now);\n-            }\n+            System.err.println(\"creationTime.toMillis() == \" + creationTime.toMillis());\n+            System.err.println(\"File creation time reported as: \" + creationTime);\n+            throw new RuntimeException(\"Expected to be close to: \" + now);\n@@ -110,1 +104,6 @@\n-            supportsCreationTimeRead = Linker.nativeLinker().defaultLookup().find(\"statx\").isPresent();\n+            try {\n+                supportsCreationTimeRead = CreationTimeHelper.\n+                        linuxIsCreationTimeSupported(file.toAbsolutePath().toString());\n+            } catch (Throwable e) {\n+                supportsCreationTimeRead = false;\n+            }\n@@ -125,1 +124,3 @@\n-            if (!current.equals(creationTime))\n+            if (!current.equals(creationTime)) {\n+                System.err.println(\"current = \" + current);\n+                System.err.println(\"creationTime = \" + creationTime);\n@@ -127,0 +128,1 @@\n+            }\n","filename":"test\/jdk\/java\/nio\/file\/attribute\/BasicFileAttributeView\/CreationTime.java","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2024 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+\n+public class CreationTimeHelper extends NativeTestHelper {\n+\n+    static {\n+        System.loadLibrary(\"CreationTimeHelper\");\n+    }\n+\n+    final static Linker abi = Linker.nativeLinker();\n+    static final SymbolLookup lookup = SymbolLookup.loaderLookup();\n+    final static MethodHandle methodHandle = abi.\n+            downcallHandle(lookup.findOrThrow(\"linuxIsCreationTimeSupported\"),\n+            FunctionDescriptor.of(C_BOOL, C_POINTER));\n+\n+    \/\/ Helper so as to determine birth time support or not on Linux.\n+    \/\/ Support is determined in a two-step process:\n+    \/\/ 1. Determine if `statx` system call is available. If available proceed,\n+    \/\/    otherwise return false.\n+    \/\/ 2. Perform an actual `statx` call on the given file and check for birth\n+    \/\/    time support in the mask returned from the call. This is needed,\n+    \/\/    since some file systems, like nfs\/tmpfs etc., don't support birth\n+    \/\/    time even though the `statx` system call is available.\n+    static boolean linuxIsCreationTimeSupported(String file) throws Throwable {\n+        if (!abi.defaultLookup().find(\"statx\").isPresent()) {\n+            return false;\n+        }\n+        try (var arena = Arena.ofConfined()) {\n+            MemorySegment s = arena.allocateFrom(file);\n+            return (boolean)methodHandle.invokeExact(s);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/attribute\/BasicFileAttributeView\/CreationTimeHelper.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2024 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include \"export.h\"\n+#include <stdbool.h>\n+#if defined(__linux__)\n+#include <stdio.h>\n+#include <string.h>\n+#include <sys\/types.h>\n+#include <sys\/stat.h>\n+#include <dlfcn.h>\n+#ifndef STATX_BASIC_STATS\n+#define STATX_BASIC_STATS 0x000007ffU\n+#endif\n+#ifndef STATX_BTIME\n+#define STATX_BTIME 0x00000800U\n+#endif\n+#ifndef RTLD_DEFAULT\n+#define RTLD_DEFAULT RTLD_LOCAL\n+#endif\n+#ifndef AT_SYMLINK_NOFOLLOW\n+#define AT_SYMLINK_NOFOLLOW 0x100\n+#endif\n+#ifndef AT_FDCWD\n+#define AT_FDCWD -100\n+#endif\n+\n+#ifndef __GLIBC__\n+\/\/ Alpine doesn't know these types, define them\n+typedef unsigned int       __uint32_t;\n+typedef unsigned short     __uint16_t;\n+typedef unsigned long int  __uint64_t;\n+#endif\n+\n+\/*\n+ * Timestamp structure for the timestamps in struct statx.\n+ *\/\n+struct my_statx_timestamp {\n+        int64_t   tv_sec;\n+        __uint32_t  tv_nsec;\n+        int32_t   __reserved;\n+};\n+\n+\/*\n+ * struct statx used by statx system call on >= glibc 2.28\n+ * systems\n+ *\/\n+struct my_statx\n+{\n+  __uint32_t stx_mask;\n+  __uint32_t stx_blksize;\n+  __uint64_t stx_attributes;\n+  __uint32_t stx_nlink;\n+  __uint32_t stx_uid;\n+  __uint32_t stx_gid;\n+  __uint16_t stx_mode;\n+  __uint16_t __statx_pad1[1];\n+  __uint64_t stx_ino;\n+  __uint64_t stx_size;\n+  __uint64_t stx_blocks;\n+  __uint64_t stx_attributes_mask;\n+  struct my_statx_timestamp stx_atime;\n+  struct my_statx_timestamp stx_btime;\n+  struct my_statx_timestamp stx_ctime;\n+  struct my_statx_timestamp stx_mtime;\n+  __uint32_t stx_rdev_major;\n+  __uint32_t stx_rdev_minor;\n+  __uint32_t stx_dev_major;\n+  __uint32_t stx_dev_minor;\n+  __uint64_t __statx_pad2[14];\n+};\n+\n+typedef int statx_func(int dirfd, const char *restrict pathname, int flags,\n+                       unsigned int mask, struct my_statx *restrict statxbuf);\n+\n+static statx_func* my_statx_func = NULL;\n+#endif  \/\/#defined(__linux__)\n+\n+\/\/ static boolean linuxIsCreationTimeSupported(char* file)\n+EXPORT bool linuxIsCreationTimeSupported(char* file) {\n+#if defined(__linux__)\n+    struct my_statx stx = {0};\n+    int ret, atflag = AT_SYMLINK_NOFOLLOW;\n+    unsigned int mask = STATX_BASIC_STATS | STATX_BTIME;\n+\n+    my_statx_func = (statx_func*) dlsym(RTLD_DEFAULT, \"statx\");\n+    if (my_statx_func == NULL) {\n+        return false;\n+    }\n+\n+    if (file == NULL) {\n+        printf(\"input file error!\\n\");\n+        return false;\n+    }\n+\n+    ret = my_statx_func(AT_FDCWD, file, atflag, mask, &stx);\n+    if (ret != 0) {\n+        return false;\n+    }\n+    \/\/ On some systems where statx is available but birth time might still not\n+    \/\/ be supported as it's file system specific. The only reliable way to\n+    \/\/ check for supported or not is looking at the filled in STATX_BTIME bit\n+    \/\/ in the returned statx buffer mask.\n+    if ((stx.stx_mask & STATX_BTIME) != 0)\n+        return true;\n+    return false;\n+#else\n+    return false;\n+#endif\n+}\n","filename":"test\/jdk\/java\/nio\/file\/attribute\/BasicFileAttributeView\/libCreationTimeHelper.c","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -78,1 +78,1 @@\n-        \"N\", \"WET\", \"WET\", \"GMT\", \"WEST\", \"GMT+01:00\",\n+        \"N\", \"WET\", \"WET\", \"Western European Standard Time\", \"WEST\", \"Western European Summer Time\",\n","filename":"test\/jdk\/java\/text\/Format\/DateFormat\/TimeZoneNameTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331446\n+ * @summary Enforce the MAX_ARGUMENT_INDEX(10,000) implementation limit for the\n+ *          ArgumentIndex element in the MessageFormat pattern syntax. This\n+ *          should be checked during construction\/applyPattern\/readObject and should effectively\n+ *          prevent parse\/format from being invoked with values over the limit.\n+ * @run junit MaxArgumentIndexTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.text.MessageFormat;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class MaxArgumentIndexTest {\n+\n+    \/\/ A MessageFormat pattern that contains an ArgumentIndex value\n+    \/\/ which violates this implementation's limit: MAX_ARGUMENT_INDEX(10,000)\n+    \/\/ As this check is exclusive, 10,000 will violate the limit\n+    private static final String VIOLATES_MAX_ARGUMENT_INDEX = \"{10000}\";\n+\n+    \/\/ Check String constructor enforces the limit\n+    @Test\n+    public void constructorTest() {\n+        assertThrows(IllegalArgumentException.class,\n+                () -> new MessageFormat(VIOLATES_MAX_ARGUMENT_INDEX));\n+    }\n+\n+    \/\/ Check String, Locale constructor enforces the limit\n+    @ParameterizedTest\n+    @MethodSource\n+    public void constructorWithLocaleTest(Locale locale) {\n+        assertThrows(IllegalArgumentException.class,\n+                () -> new MessageFormat(VIOLATES_MAX_ARGUMENT_INDEX, locale));\n+    }\n+\n+    \/\/ Provide some basic common locale values\n+    private static Stream<Locale> constructorWithLocaleTest() {\n+        return Stream.of(null, Locale.US, Locale.ROOT);\n+    }\n+\n+    \/\/ Edge case: Test a locale dependent subformat (with null locale) with a\n+    \/\/ violating ArgumentIndex. In this instance, the violating ArgumentIndex\n+    \/\/ will be caught and IAE thrown instead of the NPE\n+    @Test\n+    public void localeDependentSubFormatTest() {\n+        assertThrows(IllegalArgumentException.class,\n+                () -> new MessageFormat(\"{10000,number,short}\", null));\n+        \/\/ For reference\n+        assertThrows(NullPointerException.class,\n+                () -> new MessageFormat(\"{999,number,short}\", null));\n+    }\n+\n+    \/\/ Check that the static format method enforces the limit\n+    @Test\n+    public void staticFormatTest() {\n+        assertThrows(IllegalArgumentException.class,\n+                () -> MessageFormat.format(VIOLATES_MAX_ARGUMENT_INDEX, new Object[]{1}));\n+    }\n+\n+    \/\/ Check that applyPattern(String) enforces the limit\n+    @Test\n+    public void applyPatternTest() {\n+        MessageFormat mf = new MessageFormat(\"\");\n+        assertThrows(IllegalArgumentException.class,\n+                () -> mf.applyPattern(VIOLATES_MAX_ARGUMENT_INDEX));\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/MaxArgumentIndexTest.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331446\n+ * @summary Check correctness of deserialization\n+ * @run junit SerializationTest\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.text.MessageFormat;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class SerializationTest {\n+\n+    \/\/ Ensure basic correctness of serialization round trip\n+    @ParameterizedTest\n+    @MethodSource\n+    public void serializationRoundTrip(MessageFormat expectedMf)\n+            throws IOException, ClassNotFoundException {\n+        byte[] bytes = ser(expectedMf);\n+        MessageFormat actualMf = (MessageFormat) deSer(bytes);\n+        assertEquals(expectedMf, actualMf);\n+    }\n+\n+    \/\/ Various valid MessageFormats\n+    private static Stream<MessageFormat> serializationRoundTrip() {\n+        return Stream.of(\n+                \/\/ basic pattern\n+                new MessageFormat(\"{0} foo\"),\n+                \/\/ Multiple arguments\n+                new MessageFormat(\"{0} {1} foo\"),\n+                \/\/ duplicate arguments\n+                new MessageFormat(\"{0} {0} {1} foo\"),\n+                \/\/ Non-ascending arguments\n+                new MessageFormat(\"{1} {0} foo\"),\n+                \/\/ With locale\n+                new MessageFormat(\"{1} {0} foo\", Locale.UK),\n+                \/\/ With null locale. (NPE not thrown, if no format defined)\n+                new MessageFormat(\"{1} {0} foo\", null),\n+                \/\/ With formats\n+                new MessageFormat(\"{0,number,short} {0} {1,date,long} foo\")\n+        );\n+    }\n+\n+    \/\/ Utility method to serialize\n+    private static byte[] ser(Object obj) throws IOException {\n+        ByteArrayOutputStream byteArrayOutputStream = new\n+                ByteArrayOutputStream();\n+        ObjectOutputStream oos = new\n+                ObjectOutputStream(byteArrayOutputStream);\n+        oos.writeObject(obj);\n+        return byteArrayOutputStream.toByteArray();\n+    }\n+\n+    \/\/ Utility method to deserialize\n+    private static Object deSer(byte[] bytes) throws\n+            IOException, ClassNotFoundException {\n+        ByteArrayInputStream byteArrayInputStream = new\n+                ByteArrayInputStream(bytes);\n+        ObjectInputStream ois = new\n+                ObjectInputStream(byteArrayInputStream);\n+        return ois.readObject();\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/SerializationTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,4 +190,15 @@\n-        Instant expected = Instant.now(Clock.systemUTC());\n-        Instant test = Instant.now();\n-        long diff = Math.abs(test.toEpochMilli() - expected.toEpochMilli());\n-        assertTrue(diff < 100);  \/\/ less than 0.1 secs\n+        long beforeMillis, instantMillis, afterMillis, diff;\n+        int retryRemaining = 5; \/\/ MAX_RETRY_COUNT\n+        do {\n+            beforeMillis = Instant.now(Clock.systemUTC()).toEpochMilli();\n+            instantMillis = Instant.now().toEpochMilli();\n+            afterMillis = Instant.now(Clock.systemUTC()).toEpochMilli();\n+            diff = instantMillis - beforeMillis;\n+            if (instantMillis < beforeMillis || instantMillis > afterMillis) {\n+                throw new RuntimeException(\": Invalid instant: (~\" + instantMillis + \"ms)\"\n+                        + \" when systemUTC in millis is in [\"\n+                        + beforeMillis + \", \"\n+                        + afterMillis + \"]\");\n+            }\n+        } while (diff > 100 && --retryRemaining > 0);  \/\/ retry if diff more than 0.1 sec\n+        assertTrue(retryRemaining > 0);\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/TCKInstant.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,1 @@\n-    public void test_constant_OLD_IDS_POST_2005() {\n+    public void test_constant_OLD_IDS_POST_2024b() {\n@@ -101,3 +101,3 @@\n-        assertEquals(ids.get(\"EST\"), \"-05:00\");\n-        assertEquals(ids.get(\"MST\"), \"-07:00\");\n-        assertEquals(ids.get(\"HST\"), \"-10:00\");\n+        assertEquals(ids.get(\"EST\"), \"America\/Panama\");\n+        assertEquals(ids.get(\"MST\"), \"America\/Phoenix\");\n+        assertEquals(ids.get(\"HST\"), \"Pacific\/Honolulu\");\n@@ -132,1 +132,1 @@\n-    public void test_constant_OLD_IDS_POST_2005_immutable() {\n+    public void test_constant_OLD_IDS_POST_2024b_immutable() {\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/TCKZoneId.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,0 @@\n-        newmap.put(\"HST\", \"HST\");\n","filename":"test\/jdk\/java\/util\/TimeZone\/OldIDMappingTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-tzdata2024a\n+tzdata2024b\n","filename":"test\/jdk\/java\/util\/TimeZone\/TimeZoneData\/VERSION","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -18,0 +18,2 @@\n+Link\tEurope\/Brussels\t\tCET\n+Link\tAmerica\/Chicago\t\tCST6CDT\n@@ -29,0 +31,3 @@\n+Link\tEurope\/Athens\t\tEET\n+Link\tAmerica\/Panama\t\tEST\n+Link\tAmerica\/New_York\tEST5EDT\n@@ -52,0 +57,3 @@\n+Link\tEurope\/Brussels\t\tMET\n+Link\tAmerica\/Phoenix\t\tMST\n+Link\tAmerica\/Denver\t\tMST7MDT\n@@ -215,0 +223,1 @@\n+Link\tAsia\/Ulaanbaatar\tAsia\/Choibalsan\n@@ -229,0 +238,1 @@\n+Link\tEurope\/Lisbon\t\tWET\n@@ -246,0 +256,2 @@\n+Link\tPacific\/Honolulu\tHST\n+Link\tAmerica\/Los_Angeles\tPST8PDT\n","filename":"test\/jdk\/java\/util\/TimeZone\/TimeZoneData\/aliases.txt","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -125,5 +125,0 @@\n-CET CET CEST\n-CST6CDT CST CDT\n-EET EET EEST\n-EST EST\n-EST5EDT EST EDT\n@@ -162,5 +157,0 @@\n-HST HST\n-MET MET MEST\n-MST MST\n-MST7MDT MST MDT\n-PST8PDT PST PDT\n@@ -171,1 +161,0 @@\n-WET WET WEST\n","filename":"test\/jdk\/java\/util\/TimeZone\/TimeZoneData\/displaynames.txt","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4886799\n- * @summary Check that IIOP URLs have \/ior\/ in the path\n- * @author Eamonn McManus\n- *\n- * @run clean IIOPURLTest\n- * @run build IIOPURLTest\n- * @run main IIOPURLTest\n- *\/\n-\n-import javax.management.MBeanServer;\n-import javax.management.MBeanServerConnection;\n-import javax.management.MBeanServerFactory;\n-import javax.management.Notification;\n-import javax.management.NotificationListener;\n-import javax.management.ObjectName;\n-\n-import javax.management.remote.JMXConnector;\n-import javax.management.remote.JMXConnectorFactory;\n-import javax.management.remote.JMXConnectorServer;\n-import javax.management.remote.JMXConnectorServerFactory;\n-import javax.management.remote.JMXServiceURL;\n-\n-public class IIOPURLTest {\n-\n-    public static void main(String[] args) throws Exception {\n-        JMXServiceURL inputAddr =\n-            new JMXServiceURL(\"service:jmx:iiop:\/\/\");\n-        JMXConnectorServer s;\n-        try {\n-            s = JMXConnectorServerFactory.newJMXConnectorServer(inputAddr, null, null);\n-        } catch (java.net.MalformedURLException x) {\n-            try {\n-                Class.forName(\"javax.management.remote.rmi._RMIConnectionImpl_Tie\");\n-                throw new RuntimeException(\"MalformedURLException thrown but iiop appears to be supported\");\n-            } catch (ClassNotFoundException expected) { }\n-            System.out.println(\"IIOP protocol not supported, test skipped\");\n-            return;\n-        }\n-        MBeanServer mbs = MBeanServerFactory.createMBeanServer();\n-        mbs.registerMBean(s, new ObjectName(\"a:b=c\"));\n-        s.start();\n-        JMXServiceURL outputAddr = s.getAddress();\n-        if (!outputAddr.getURLPath().startsWith(\"\/ior\/IOR:\")) {\n-            throw new RuntimeException(\"URL path should start with \\\"\/ior\/IOR:\\\": \" +\n-                                       outputAddr);\n-        }\n-        System.out.println(\"IIOP URL path looks OK: \" + outputAddr);\n-        JMXConnector c = JMXConnectorFactory.connect(outputAddr);\n-        System.out.println(\"Successfully got default domain: \" +\n-                           c.getMBeanServerConnection().getDefaultDomain());\n-        c.close();\n-        s.stop();\n-    }\n-}\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/connection\/IIOPURLTest.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @bug 8043758\n+ * @bug 8043758 8307383\n@@ -39,0 +39,1 @@\n+import java.nio.ByteBuffer;\n@@ -76,2 +77,19 @@\n-            if (ba[ba.length - 1] == (byte)0xFF) {\n-                ba[ba.length - 1] = (byte)0xFE;\n+            \/\/ We will alter the compression method field in order to make the cookie\n+            \/\/ check fail.\n+            ByteBuffer chRec = ByteBuffer.wrap(ba);\n+            \/\/ Skip 59 bytes past the record header (13), the handshake header (12),\n+            \/\/ the protocol version (2), and client random (32)\n+            chRec.position(59);\n+            \/\/ Jump past the session ID\n+            int len = Byte.toUnsignedInt(chRec.get());\n+            chRec.position(chRec.position() + len);\n+            \/\/ Skip the cookie\n+            len = Byte.toUnsignedInt(chRec.get());\n+            chRec.position(chRec.position() + len);\n+            \/\/ Skip past cipher suites\n+            len = Short.toUnsignedInt(chRec.getShort());\n+            chRec.position(chRec.position() + len);\n+            \/\/ Read the data on the compression methods, should be at least 1\n+            len = Byte.toUnsignedInt(chRec.get());\n+            if (len >= 1) {\n+                System.out.println(\"Detected compression methods (count = \" + len + \")\");\n@@ -80,0 +98,1 @@\n+                throw new RuntimeException(\"Got zero length comp methods\");\n@@ -81,0 +100,5 @@\n+            \/\/ alter the first comp method.\n+            int compMethodVal = Byte.toUnsignedInt(chRec.get(chRec.position()));\n+            System.out.println(\"Changing value at position \" + chRec.position() +\n+                    \" from \" + compMethodVal + \" to \" + ++compMethodVal);\n+            chRec.put(chRec.position(), (byte)compMethodVal);\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/InvalidRecords.java","additions":28,"deletions":4,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,9 @@\n-        for (int mfl = 4096; mfl >= 256; mfl \/= 2) {\n+        String testMode = System.getProperty(\"test.mode\", \"norm\");\n+        int mflLen;\n+        if (testMode.equals(\"norm_sni\")) {\n+            mflLen = 512;\n+        } else {\n+            mflLen = 256;\n+        }\n+\n+        for (int mfl = 4096; mfl >= mflLen; mfl \/= 2) {\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/MFLNTest.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Font;\n+import java.awt.Graphics;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import javax.print.Doc;\n+import javax.print.DocFlavor;\n+import javax.print.DocPrintJob;\n+import javax.print.SimpleDoc;\n+import javax.print.StreamPrintService;\n+import javax.print.StreamPrintServiceFactory;\n+import javax.print.event.PrintJobAdapter;\n+import javax.print.event.PrintJobEvent;\n+\n+\/*\n+ * @test\n+ * @bug 8339974\n+ * @summary Verifies that text prints correctly using scaled and rotated fonts.\n+ *\/\n+public class PostScriptRotatedScaledFontTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        test(0);\n+        test(1);\n+        test(2);\n+        test(3);\n+        test(4);\n+    }\n+\n+    private static void test(int quadrants) throws Exception {\n+\n+        DocFlavor flavor = DocFlavor.SERVICE_FORMATTED.PRINTABLE;\n+        String mime = \"application\/postscript\";\n+        StreamPrintServiceFactory[] factories = StreamPrintServiceFactory.lookupStreamPrintServiceFactories(flavor, mime);\n+        if (factories.length == 0) {\n+            throw new RuntimeException(\"Unable to find PostScript print service factory\");\n+        }\n+\n+        StreamPrintServiceFactory factory = factories[0];\n+\n+        \/\/ required to trigger \"text-as-shapes\" code path in\n+        \/\/ PSPathGraphics.drawString(String, float, float, Font, FontRenderContext, float)\n+        \/\/ for *all* text, not just text that uses a transformed font\n+        String shapeText = \"sun.java2d.print.shapetext\";\n+        System.setProperty(shapeText, \"true\");\n+\n+        try {\n+            for (int scale = 1; scale <= 100; scale++) {\n+\n+                ByteArrayOutputStream output = new ByteArrayOutputStream();\n+                StreamPrintService service = factory.getPrintService(output);\n+                DocPrintJob job = service.createPrintJob();\n+\n+                PrintJobMonitor monitor = new PrintJobMonitor();\n+                job.addPrintJobListener(monitor);\n+\n+                Printable printable = new TestPrintable(scale, quadrants);\n+                Doc doc = new SimpleDoc(printable, flavor, null);\n+                job.print(doc, null);\n+                monitor.waitForJobToFinish();\n+\n+                byte[] ps = output.toByteArray();\n+                Rectangle2D.Double bounds = findTextBoundingBox(ps);\n+                if (bounds == null) {\n+                    throw new RuntimeException(\"Text missing: scale=\" + scale\n+                        + \", quadrants=\" + quadrants);\n+                }\n+\n+                boolean horizontal = (bounds.width > bounds.height);\n+                boolean expectedHorizontal = (quadrants % 2 == 0);\n+                if (horizontal != expectedHorizontal) {\n+                    throw new RuntimeException(\"Wrong orientation: scale=\" + scale\n+                        + \", quadrants=\" + quadrants + \", bounds=\" + bounds\n+                        + \", expectedHorizontal=\" + expectedHorizontal\n+                        + \", horizontal=\" + horizontal);\n+                }\n+            }\n+        } finally {\n+            System.clearProperty(shapeText);\n+        }\n+    }\n+\n+    \/\/ very basic, uses moveto (\"x y M\"), lineto (\"x y L\"), and curveto (\"x1 y1 x2 y2 x3 y3 C\")\n+    private static Rectangle2D.Double findTextBoundingBox(byte[] ps) {\n+        double minX = Double.MAX_VALUE;\n+        double minY = Double.MAX_VALUE;\n+        double maxX = Double.MIN_VALUE;\n+        double maxY = Double.MIN_VALUE;\n+        boolean pastPageClip = false;\n+        List< String > lines = new String(ps, StandardCharsets.ISO_8859_1).lines().toList();\n+        for (String line : lines) {\n+            if (!pastPageClip) {\n+                pastPageClip = \"WC\".equals(line);\n+                continue;\n+            }\n+            String[] values = line.split(\" \");\n+            if (values.length == 3 || values.length == 7) {\n+                String cmd = values[values.length - 1];\n+                if (\"M\".equals(cmd) || \"L\".equals(cmd) || \"C\".equals(cmd)) {\n+                    String sx = values[values.length - 3];\n+                    String sy = values[values.length - 2];\n+                    double x = Double.parseDouble(sx);\n+                    double y = Double.parseDouble(sy);\n+                    if (x < minX) {\n+                        minX = x;\n+                    }\n+                    if (y < minY) {\n+                        minY = y;\n+                    }\n+                    if (x > maxX) {\n+                        maxX = x;\n+                    }\n+                    if (y > maxY) {\n+                        maxY = y;\n+                    }\n+                }\n+            }\n+        }\n+        if (minX != Double.MAX_VALUE) {\n+            return new Rectangle2D.Double(minX, minY, maxX - minX, maxY - minY);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static final class TestPrintable implements Printable {\n+        private final int scale;\n+        private final int quadrants;\n+        public TestPrintable(int scale, int quadrants) {\n+            this.scale = scale;\n+            this.quadrants = quadrants;\n+        }\n+        @Override\n+        public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) throws PrinterException {\n+            if (pageIndex > 0) {\n+                return NO_SUCH_PAGE;\n+            }\n+            AffineTransform at = AffineTransform.getQuadrantRotateInstance(quadrants);\n+            at.scale(scale, scale);\n+            Font base = new Font(\"SansSerif\", Font.PLAIN, 10);\n+            Font font = base.deriveFont(at);\n+            graphics.setFont(font);\n+            graphics.drawString(\"TEST\", 300, 300);\n+            return PAGE_EXISTS;\n+        }\n+    }\n+\n+    private static class PrintJobMonitor extends PrintJobAdapter {\n+        private boolean finished;\n+        @Override\n+        public void printJobCanceled(PrintJobEvent pje) {\n+            finished();\n+        }\n+        @Override\n+        public void printJobCompleted(PrintJobEvent pje) {\n+            finished();\n+        }\n+        @Override\n+        public void printJobFailed(PrintJobEvent pje) {\n+            finished();\n+        }\n+        @Override\n+        public void printJobNoMoreEvents(PrintJobEvent pje) {\n+            finished();\n+        }\n+        private synchronized void finished() {\n+            finished = true;\n+            notify();\n+        }\n+        public synchronized void waitForJobToFinish() {\n+            try {\n+                while (!finished) {\n+                    wait();\n+                }\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/print\/PostScriptRotatedScaledFontTest.java","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"},{"patch":"@@ -29,0 +29,2 @@\n+import jtreg.SkippedException;\n+\n@@ -32,1 +34,1 @@\n- * @library \/java\/awt\/regtesthelpers\n+ * @library \/java\/awt\/regtesthelpers \/test\/lib\n@@ -41,0 +43,7 @@\n+\n+        \/\/ ColorChooser UI design is different for GTK L&F.\n+        \/\/ There is no Swatches tab available for GTK L&F, skip the testing.\n+        if (UIManager.getLookAndFeel().getName().contains(\"GTK\")) {\n+            throw new SkippedException(\"Test not applicable for GTK L&F\");\n+        }\n+\n@@ -48,1 +57,0 @@\n-                .rows(5)\n@@ -50,1 +58,0 @@\n-                .testTimeOut(10)\n","filename":"test\/jdk\/javax\/swing\/JColorChooser\/Test4887836.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4587721\n+ * @summary Tests if JFileChooser details view chops off text\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual bug4587721\n+ *\/\n+\n+import java.awt.Font;\n+import java.util.Enumeration;\n+\n+import javax.swing.JFileChooser;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.plaf.FontUIResource;\n+import javax.swing.plaf.metal.MetalLookAndFeel;\n+\n+public class bug4587721 {\n+\n+    public static void main(String[] args) throws Exception {\n+        UIManager.setLookAndFeel(new MetalLookAndFeel());\n+\n+        String instructions = \"\"\"\n+                Click on the Details button in JFileChooser Window.\n+                If the filename text is chopped off by height,\n+                then Press FAIL else Press PASS.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"bug4587721\")\n+                .instructions(instructions)\n+                .columns(40)\n+                .testUI(bug4587721::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static JFileChooser createUI() {\n+        setFonts();\n+        JFileChooser fc = new JFileChooser();\n+        return fc;\n+    }\n+\n+    public static void setFonts() {\n+        UIDefaults defaults = UIManager.getDefaults();\n+        Enumeration keys = defaults.keys();\n+        while (keys.hasMoreElements()) {\n+            Object key = keys.nextElement();\n+            if (defaults.get(key) instanceof Font)\n+                UIManager.put(key, new FontUIResource(new Font(\"Courier\", Font.BOLD, 30)));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/bug4587721.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import javax.swing.JColorChooser;\n+import javax.swing.UIManager;\n+\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @bug 4419255\n+ * @library \/java\/awt\/regtesthelpers \/test\/lib\n+ * @build PassFailJFrame\n+ * @summary Tests if Metal Slider's thumb isn't clipped\n+ * @run main\/manual bug4419255\n+ *\/\n+\n+public class bug4419255 {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ ColorChooser UI design is different for GTK L&F.\n+        \/\/ There is no RGB tab available for GTK L&F, skip the testing.\n+        if (UIManager.getLookAndFeel().getName().contains(\"GTK\")) {\n+            throw new SkippedException(\"Test not applicable for GTK L&F\");\n+        }\n+        String instructions = \"\"\"\n+                Choose RGB tab. If sliders' thumbs are painted correctly\n+                (top is not clipped, black line is visible),\n+                then test passed. Otherwise it failed.\"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"bug4419255\")\n+                .instructions(instructions)\n+                .columns(40)\n+                .testUI(bug4419255::createColorChooser)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static JColorChooser createColorChooser() {\n+        return new JColorChooser(Color.BLUE);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/plaf\/basic\/BasicSliderUI\/bug4419255.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -305,0 +305,19 @@\n+    static void assertSelectFromTwoVectorEquals(byte[] r, byte[] order, byte[] a, byte[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -965,0 +984,12 @@\n+    static final List<IntFunction<byte[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"byte[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<byte[]>>> BYTE_GENERATOR_SELECT_FROM_TRIPLES =\n+        BYTE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -992,0 +1023,6 @@\n+    @DataProvider\n+    public Object[][] byteSelectFromTwoVectorOpProvider() {\n+        return BYTE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5749,0 +5786,18 @@\n+    @Test(dataProvider = \"byteSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, IntFunction<byte[]> fc) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] idx = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector idxv = ByteVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -305,0 +305,19 @@\n+    static void assertSelectFromTwoVectorEquals(byte[] r, byte[] order, byte[] a, byte[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -965,0 +984,12 @@\n+    static final List<IntFunction<byte[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"byte[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<byte[]>>> BYTE_GENERATOR_SELECT_FROM_TRIPLES =\n+        BYTE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -992,0 +1023,6 @@\n+    @DataProvider\n+    public Object[][] byteSelectFromTwoVectorOpProvider() {\n+        return BYTE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5749,0 +5786,18 @@\n+    @Test(dataProvider = \"byteSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, IntFunction<byte[]> fc) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] idx = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector idxv = ByteVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -305,0 +305,19 @@\n+    static void assertSelectFromTwoVectorEquals(byte[] r, byte[] order, byte[] a, byte[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -965,0 +984,12 @@\n+    static final List<IntFunction<byte[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"byte[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<byte[]>>> BYTE_GENERATOR_SELECT_FROM_TRIPLES =\n+        BYTE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -992,0 +1023,6 @@\n+    @DataProvider\n+    public Object[][] byteSelectFromTwoVectorOpProvider() {\n+        return BYTE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5749,0 +5786,18 @@\n+    @Test(dataProvider = \"byteSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, IntFunction<byte[]> fc) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] idx = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector idxv = ByteVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -305,0 +305,19 @@\n+    static void assertSelectFromTwoVectorEquals(byte[] r, byte[] order, byte[] a, byte[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -965,0 +984,12 @@\n+    static final List<IntFunction<byte[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"byte[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<byte[]>>> BYTE_GENERATOR_SELECT_FROM_TRIPLES =\n+        BYTE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -992,0 +1023,6 @@\n+    @DataProvider\n+    public Object[][] byteSelectFromTwoVectorOpProvider() {\n+        return BYTE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5749,0 +5786,18 @@\n+    @Test(dataProvider = \"byteSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, IntFunction<byte[]> fc) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] idx = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector idxv = ByteVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -310,0 +310,19 @@\n+    static void assertSelectFromTwoVectorEquals(byte[] r, byte[] order, byte[] a, byte[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -970,0 +989,12 @@\n+    static final List<IntFunction<byte[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"byte[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<byte[]>>> BYTE_GENERATOR_SELECT_FROM_TRIPLES =\n+        BYTE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -997,0 +1028,6 @@\n+    @DataProvider\n+    public Object[][] byteSelectFromTwoVectorOpProvider() {\n+        return BYTE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5754,0 +5791,18 @@\n+    @Test(dataProvider = \"byteSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, IntFunction<byte[]> fc) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] idx = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector idxv = ByteVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -324,0 +324,19 @@\n+    static void assertSelectFromTwoVectorEquals(double[] r, double[] order, double[] a, double[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1111,0 +1130,12 @@\n+    static final List<IntFunction<double[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"double[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<double[]>>> DOUBLE_GENERATOR_SELECT_FROM_TRIPLES =\n+        DOUBLE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1138,0 +1169,6 @@\n+    @DataProvider\n+    public Object[][] doubleSelectFromTwoVectorOpProvider() {\n+        return DOUBLE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4802,0 +4839,18 @@\n+    @Test(dataProvider = \"doubleSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorDouble128VectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, IntFunction<double[]> fc) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] idx = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector idxv = DoubleVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -324,0 +324,19 @@\n+    static void assertSelectFromTwoVectorEquals(double[] r, double[] order, double[] a, double[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1111,0 +1130,12 @@\n+    static final List<IntFunction<double[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"double[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<double[]>>> DOUBLE_GENERATOR_SELECT_FROM_TRIPLES =\n+        DOUBLE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1138,0 +1169,6 @@\n+    @DataProvider\n+    public Object[][] doubleSelectFromTwoVectorOpProvider() {\n+        return DOUBLE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4802,0 +4839,18 @@\n+    @Test(dataProvider = \"doubleSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorDouble256VectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, IntFunction<double[]> fc) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] idx = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector idxv = DoubleVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -324,0 +324,19 @@\n+    static void assertSelectFromTwoVectorEquals(double[] r, double[] order, double[] a, double[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1111,0 +1130,12 @@\n+    static final List<IntFunction<double[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"double[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<double[]>>> DOUBLE_GENERATOR_SELECT_FROM_TRIPLES =\n+        DOUBLE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1138,0 +1169,6 @@\n+    @DataProvider\n+    public Object[][] doubleSelectFromTwoVectorOpProvider() {\n+        return DOUBLE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4802,0 +4839,18 @@\n+    @Test(dataProvider = \"doubleSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorDouble512VectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, IntFunction<double[]> fc) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] idx = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector idxv = DoubleVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -324,0 +324,19 @@\n+    static void assertSelectFromTwoVectorEquals(double[] r, double[] order, double[] a, double[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1111,0 +1130,12 @@\n+    static final List<IntFunction<double[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"double[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<double[]>>> DOUBLE_GENERATOR_SELECT_FROM_TRIPLES =\n+        DOUBLE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1138,0 +1169,6 @@\n+    @DataProvider\n+    public Object[][] doubleSelectFromTwoVectorOpProvider() {\n+        return DOUBLE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4802,0 +4839,18 @@\n+    @Test(dataProvider = \"doubleSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorDouble64VectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, IntFunction<double[]> fc) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] idx = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector idxv = DoubleVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -329,0 +329,19 @@\n+    static void assertSelectFromTwoVectorEquals(double[] r, double[] order, double[] a, double[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1116,0 +1135,12 @@\n+    static final List<IntFunction<double[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"double[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<double[]>>> DOUBLE_GENERATOR_SELECT_FROM_TRIPLES =\n+        DOUBLE_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1143,0 +1174,6 @@\n+    @DataProvider\n+    public Object[][] doubleSelectFromTwoVectorOpProvider() {\n+        return DOUBLE_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4807,0 +4844,18 @@\n+    @Test(dataProvider = \"doubleSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorDoubleMaxVectorTests(IntFunction<double[]> fa, IntFunction<double[]> fb, IntFunction<double[]> fc) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] idx = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector idxv = DoubleVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -324,0 +324,19 @@\n+    static void assertSelectFromTwoVectorEquals(float[] r, float[] order, float[] a, float[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1122,0 +1141,12 @@\n+    static final List<IntFunction<float[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"float[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<float[]>>> FLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        FLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1149,0 +1180,6 @@\n+    @DataProvider\n+    public Object[][] floatSelectFromTwoVectorOpProvider() {\n+        return FLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4781,0 +4818,18 @@\n+    @Test(dataProvider = \"floatSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorFloat128VectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, IntFunction<float[]> fc) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] idx = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector idxv = FloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -324,0 +324,19 @@\n+    static void assertSelectFromTwoVectorEquals(float[] r, float[] order, float[] a, float[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1122,0 +1141,12 @@\n+    static final List<IntFunction<float[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"float[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<float[]>>> FLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        FLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1149,0 +1180,6 @@\n+    @DataProvider\n+    public Object[][] floatSelectFromTwoVectorOpProvider() {\n+        return FLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4781,0 +4818,18 @@\n+    @Test(dataProvider = \"floatSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorFloat256VectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, IntFunction<float[]> fc) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] idx = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector idxv = FloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -324,0 +324,19 @@\n+    static void assertSelectFromTwoVectorEquals(float[] r, float[] order, float[] a, float[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1122,0 +1141,12 @@\n+    static final List<IntFunction<float[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"float[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<float[]>>> FLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        FLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1149,0 +1180,6 @@\n+    @DataProvider\n+    public Object[][] floatSelectFromTwoVectorOpProvider() {\n+        return FLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4781,0 +4818,18 @@\n+    @Test(dataProvider = \"floatSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorFloat512VectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, IntFunction<float[]> fc) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] idx = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector idxv = FloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -324,0 +324,19 @@\n+    static void assertSelectFromTwoVectorEquals(float[] r, float[] order, float[] a, float[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1122,0 +1141,12 @@\n+    static final List<IntFunction<float[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"float[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<float[]>>> FLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        FLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1149,0 +1180,6 @@\n+    @DataProvider\n+    public Object[][] floatSelectFromTwoVectorOpProvider() {\n+        return FLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4781,0 +4818,18 @@\n+    @Test(dataProvider = \"floatSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorFloat64VectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, IntFunction<float[]> fc) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] idx = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector idxv = FloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -329,0 +329,19 @@\n+    static void assertSelectFromTwoVectorEquals(float[] r, float[] order, float[] a, float[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1127,0 +1146,12 @@\n+    static final List<IntFunction<float[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"float[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<float[]>>> FLOAT_GENERATOR_SELECT_FROM_TRIPLES =\n+        FLOAT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1154,0 +1185,6 @@\n+    @DataProvider\n+    public Object[][] floatSelectFromTwoVectorOpProvider() {\n+        return FLOAT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -4784,0 +4821,18 @@\n+    }\n+\n+    @Test(dataProvider = \"floatSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorFloatMaxVectorTests(IntFunction<float[]> fa, IntFunction<float[]> fb, IntFunction<float[]> fc) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] idx = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector idxv = FloatVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -305,0 +305,19 @@\n+    static void assertSelectFromTwoVectorEquals(int[] r, int[] order, int[] a, int[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -955,0 +974,12 @@\n+    static final List<IntFunction<int[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"int[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<int[]>>> INT_GENERATOR_SELECT_FROM_TRIPLES =\n+        INT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -982,0 +1013,6 @@\n+    @DataProvider\n+    public Object[][] intSelectFromTwoVectorOpProvider() {\n+        return INT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5782,0 +5819,18 @@\n+    @Test(dataProvider = \"intSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, IntFunction<int[]> fc) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] idx = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector idxv = IntVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -305,0 +305,19 @@\n+    static void assertSelectFromTwoVectorEquals(int[] r, int[] order, int[] a, int[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -955,0 +974,12 @@\n+    static final List<IntFunction<int[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"int[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<int[]>>> INT_GENERATOR_SELECT_FROM_TRIPLES =\n+        INT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -982,0 +1013,6 @@\n+    @DataProvider\n+    public Object[][] intSelectFromTwoVectorOpProvider() {\n+        return INT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5782,0 +5819,18 @@\n+    @Test(dataProvider = \"intSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, IntFunction<int[]> fc) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] idx = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector idxv = IntVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -305,0 +305,19 @@\n+    static void assertSelectFromTwoVectorEquals(int[] r, int[] order, int[] a, int[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -955,0 +974,12 @@\n+    static final List<IntFunction<int[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"int[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<int[]>>> INT_GENERATOR_SELECT_FROM_TRIPLES =\n+        INT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -982,0 +1013,6 @@\n+    @DataProvider\n+    public Object[][] intSelectFromTwoVectorOpProvider() {\n+        return INT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5782,0 +5819,18 @@\n+    @Test(dataProvider = \"intSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, IntFunction<int[]> fc) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] idx = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector idxv = IntVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -305,0 +305,19 @@\n+    static void assertSelectFromTwoVectorEquals(int[] r, int[] order, int[] a, int[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -955,0 +974,12 @@\n+    static final List<IntFunction<int[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"int[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<int[]>>> INT_GENERATOR_SELECT_FROM_TRIPLES =\n+        INT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -982,0 +1013,6 @@\n+    @DataProvider\n+    public Object[][] intSelectFromTwoVectorOpProvider() {\n+        return INT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5782,0 +5819,18 @@\n+    @Test(dataProvider = \"intSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, IntFunction<int[]> fc) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] idx = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector idxv = IntVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -310,0 +310,19 @@\n+    static void assertSelectFromTwoVectorEquals(int[] r, int[] order, int[] a, int[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -960,0 +979,12 @@\n+    static final List<IntFunction<int[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"int[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<int[]>>> INT_GENERATOR_SELECT_FROM_TRIPLES =\n+        INT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -987,0 +1018,6 @@\n+    @DataProvider\n+    public Object[][] intSelectFromTwoVectorOpProvider() {\n+        return INT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5787,0 +5824,18 @@\n+    @Test(dataProvider = \"intSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, IntFunction<int[]> fc) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] idx = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector idxv = IntVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -262,0 +262,19 @@\n+    static void assertSelectFromTwoVectorEquals(long[] r, long[] order, long[] a, long[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -945,0 +964,12 @@\n+    static final List<IntFunction<long[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"long[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<long[]>>> LONG_GENERATOR_SELECT_FROM_TRIPLES =\n+        LONG_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -972,0 +1003,6 @@\n+    @DataProvider\n+    public Object[][] longSelectFromTwoVectorOpProvider() {\n+        return LONG_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5668,0 +5705,18 @@\n+    @Test(dataProvider = \"longSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, IntFunction<long[]> fc) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] idx = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector idxv = LongVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -262,0 +262,19 @@\n+    static void assertSelectFromTwoVectorEquals(long[] r, long[] order, long[] a, long[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -945,0 +964,12 @@\n+    static final List<IntFunction<long[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"long[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<long[]>>> LONG_GENERATOR_SELECT_FROM_TRIPLES =\n+        LONG_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -972,0 +1003,6 @@\n+    @DataProvider\n+    public Object[][] longSelectFromTwoVectorOpProvider() {\n+        return LONG_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5668,0 +5705,18 @@\n+    @Test(dataProvider = \"longSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, IntFunction<long[]> fc) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] idx = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector idxv = LongVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -262,0 +262,19 @@\n+    static void assertSelectFromTwoVectorEquals(long[] r, long[] order, long[] a, long[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -945,0 +964,12 @@\n+    static final List<IntFunction<long[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"long[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<long[]>>> LONG_GENERATOR_SELECT_FROM_TRIPLES =\n+        LONG_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -972,0 +1003,6 @@\n+    @DataProvider\n+    public Object[][] longSelectFromTwoVectorOpProvider() {\n+        return LONG_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5668,0 +5705,18 @@\n+    @Test(dataProvider = \"longSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, IntFunction<long[]> fc) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] idx = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector idxv = LongVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -262,0 +262,19 @@\n+    static void assertSelectFromTwoVectorEquals(long[] r, long[] order, long[] a, long[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -945,0 +964,12 @@\n+    static final List<IntFunction<long[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"long[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<long[]>>> LONG_GENERATOR_SELECT_FROM_TRIPLES =\n+        LONG_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -972,0 +1003,6 @@\n+    @DataProvider\n+    public Object[][] longSelectFromTwoVectorOpProvider() {\n+        return LONG_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5668,0 +5705,18 @@\n+    @Test(dataProvider = \"longSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, IntFunction<long[]> fc) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] idx = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector idxv = LongVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -267,0 +267,19 @@\n+    static void assertSelectFromTwoVectorEquals(long[] r, long[] order, long[] a, long[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -950,0 +969,12 @@\n+    static final List<IntFunction<long[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"long[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<long[]>>> LONG_GENERATOR_SELECT_FROM_TRIPLES =\n+        LONG_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -977,0 +1008,6 @@\n+    @DataProvider\n+    public Object[][] longSelectFromTwoVectorOpProvider() {\n+        return LONG_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5673,0 +5710,18 @@\n+    @Test(dataProvider = \"longSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, IntFunction<long[]> fc) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] idx = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector idxv = LongVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -305,0 +305,19 @@\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -955,0 +974,12 @@\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_SELECT_FROM_TRIPLES =\n+        SHORT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -982,0 +1013,6 @@\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return SHORT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5729,0 +5766,18 @@\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector idxv = ShortVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -305,0 +305,19 @@\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -955,0 +974,12 @@\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_SELECT_FROM_TRIPLES =\n+        SHORT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -982,0 +1013,6 @@\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return SHORT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5729,0 +5766,18 @@\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector idxv = ShortVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -305,0 +305,19 @@\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -955,0 +974,12 @@\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_SELECT_FROM_TRIPLES =\n+        SHORT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -982,0 +1013,6 @@\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return SHORT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5729,0 +5766,18 @@\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector idxv = ShortVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -305,0 +305,19 @@\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -955,0 +974,12 @@\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_SELECT_FROM_TRIPLES =\n+        SHORT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -982,0 +1013,6 @@\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return SHORT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5729,0 +5766,18 @@\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector idxv = ShortVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -310,0 +310,19 @@\n+    static void assertSelectFromTwoVectorEquals(short[] r, short[] order, short[] a, short[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -960,0 +979,12 @@\n+    static final List<IntFunction<short[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"short[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_SELECT_FROM_TRIPLES =\n+        SHORT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -987,0 +1018,6 @@\n+    @DataProvider\n+    public Object[][] shortSelectFromTwoVectorOpProvider() {\n+        return SHORT_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -5732,0 +5769,18 @@\n+    }\n+\n+    @Test(dataProvider = \"shortSelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVectorShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] idx = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector idxv = ShortVector.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -300,0 +300,18 @@\n+    @Test(dataProvider = \"$type$SelectFromTwoVectorOpProvider\")\n+    static void SelectFromTwoVector$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb, IntFunction<$type$[]> fc) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] idx = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < idx.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                $abstractvectortype$ idxv = $abstractvectortype$.fromArray(SPECIES, idx, i);\n+                idxv.selectFrom(av, bv).intoArray(r, i);\n+            }\n+        }\n+        assertSelectFromTwoVectorEquals(r, idx, a, b, SPECIES.length());\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -400,0 +400,19 @@\n+    static void assertSelectFromTwoVectorEquals($type$[] r, $type$[] order, $type$[] a, $type$[] b, int vector_len) {\n+        int i = 0, j = 0;\n+        boolean is_exceptional_idx = false;\n+        int idx = 0, wrapped_index = 0, oidx = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    idx = i + j;\n+                    wrapped_index = Math.floorMod((int)order[idx], 2 * vector_len);\n+                    is_exceptional_idx = wrapped_index >= vector_len;\n+                    oidx = is_exceptional_idx ? (wrapped_index - vector_len) : wrapped_index;\n+                    Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[idx], (is_exceptional_idx ? b[i + oidx] : a[i + oidx]), \"at index #\" + idx + \", order = \" + order[idx] + \", a = \" + a[i + oidx] + \", b = \" + b[i + oidx]);\n+        }\n+    }\n+\n@@ -1224,0 +1243,12 @@\n+    static final List<IntFunction<$type$[]>> SELECT_FROM_INDEX_GENERATORS = List.of(\n+            withToString(\"$type$[0..VECLEN*2)\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)(RAND.nextInt()));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<$type$[]>>> $TYPE$_GENERATOR_SELECT_FROM_TRIPLES =\n+        $TYPE$_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SELECT_FROM_INDEX_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n@@ -1251,0 +1282,6 @@\n+    @DataProvider\n+    public Object[][] $type$SelectFromTwoVectorOpProvider() {\n+        return $TYPE$_GENERATOR_SELECT_FROM_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +30,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerBasic.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerCpuMetrics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerMemoryMetrics.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +29,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestGetFreeSwapSpaceSize.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +32,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestLimitsUpdating.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestPidsLimit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestSystemMetrics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +28,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestUseContainerSupport.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8340327\n+ * @modules java.base\/sun.security.ec.ed\n+ *          java.base\/sun.security.ec.point\n+ *          java.base\/sun.security.jca\n+ *          java.base\/sun.security.provider\n+ * @library \/test\/lib\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import sun.security.ec.ed.EdDSAOperations;\n+import sun.security.ec.ed.EdDSAParameters;\n+import sun.security.ec.point.AffinePoint;\n+import sun.security.jca.JCAUtil;\n+import sun.security.provider.NamedKeyFactory;\n+import sun.security.provider.NamedKeyPairGenerator;\n+import sun.security.provider.NamedSignature;\n+\n+import java.security.*;\n+import java.security.spec.EdDSAParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class NamedEdDSA {\n+\n+    public static class ProviderImpl extends Provider {\n+        public ProviderImpl() {\n+            super(\"Named\", \"0\", \"\");\n+            put(\"KeyPairGenerator.EdDSA\", EdDSAKeyPairGenerator.class.getName());\n+            put(\"KeyPairGenerator.Ed25519\", EdDSAKeyPairGenerator.Ed25519.class.getName());\n+            put(\"KeyPairGenerator.Ed448\", EdDSAKeyPairGenerator.Ed448.class.getName());\n+            put(\"KeyFactory.EdDSA\", EdDSAKeyFactory.class.getName());\n+            put(\"KeyFactory.Ed25519\", EdDSAKeyFactory.Ed25519.class.getName());\n+            put(\"KeyFactory.Ed448\", EdDSAKeyFactory.Ed448.class.getName());\n+            put(\"Signature.EdDSA\", EdDSASignature.class.getName());\n+            put(\"Signature.Ed25519\", EdDSASignature.Ed25519.class.getName());\n+            put(\"Signature.Ed448\", EdDSASignature.Ed448.class.getName());\n+        }\n+    }\n+\n+    public static class EdDSASignature extends NamedSignature {\n+        public EdDSASignature() {\n+            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n+        }\n+\n+        protected EdDSASignature(String pname) {\n+            super(\"EdDSA\", pname);\n+        }\n+\n+        public static class Ed25519 extends EdDSASignature {\n+            public Ed25519() {\n+                super(\"Ed25519\");\n+            }\n+        }\n+\n+        public static class Ed448 extends EdDSASignature {\n+            public Ed448() {\n+                super(\"Ed448\");\n+            }\n+        }\n+\n+        @Override\n+        public byte[] implSign(String name, byte[] sk, Object sk2, byte[] msg, SecureRandom sr) throws SignatureException {\n+            return getOps(name).sign(plain, sk, msg);\n+        }\n+\n+        @Override\n+        public boolean implVerify(String name, byte[] pk, Object pk2, byte[] msg, byte[] sig) throws SignatureException {\n+            return getOps(name).verify(plain, (AffinePoint) pk2, pk, msg, sig);\n+        }\n+\n+        @Override\n+        public Object implCheckPublicKey(String name, byte[] pk) throws InvalidKeyException {\n+            return getOps(name).decodeAffinePoint(InvalidKeyException::new, pk);\n+        }\n+    }\n+\n+    public static class EdDSAKeyFactory extends NamedKeyFactory {\n+        public EdDSAKeyFactory() {\n+            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n+        }\n+\n+        protected EdDSAKeyFactory(String pname) {\n+            super(\"EdDSA\", pname);\n+        }\n+\n+        public static class Ed25519 extends EdDSAKeyFactory {\n+            public Ed25519() {\n+                super(\"Ed25519\");\n+            }\n+        }\n+\n+        public static class Ed448 extends EdDSAKeyFactory {\n+            public Ed448() {\n+                super(\"Ed448\");\n+            }\n+        }\n+    }\n+\n+    public static class EdDSAKeyPairGenerator extends NamedKeyPairGenerator {\n+        public EdDSAKeyPairGenerator() {\n+            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n+        }\n+\n+        protected EdDSAKeyPairGenerator(String pname) {\n+            super(\"EdDSA\", pname);\n+        }\n+\n+        public static class Ed25519 extends EdDSAKeyPairGenerator {\n+            public Ed25519() {\n+                super(\"Ed25519\");\n+            }\n+        }\n+\n+        public static class Ed448 extends EdDSAKeyPairGenerator {\n+            public Ed448() {\n+                super(\"Ed448\");\n+            }\n+        }\n+\n+        @Override\n+        public byte[][] implGenerateKeyPair(String pname, SecureRandom sr) {\n+            sr = sr == null ? JCAUtil.getDefSecureRandom() : sr;\n+            var op = getOps(pname);\n+            var sk = op.generatePrivate(sr);\n+            var point = op.computePublic(sk);\n+            byte[] encodedPoint = point.getY().toByteArray();\n+            reverse(encodedPoint);\n+            \/\/ array may be too large or too small, depending on the value\n+            encodedPoint = Arrays.copyOf(encodedPoint, op.getParameters().getKeyLength());\n+            \/\/ set the high-order bit of the encoded point\n+            byte msb = (byte) (point.isXOdd() ? 0x80 : 0);\n+            encodedPoint[encodedPoint.length - 1] |= msb;\n+            return new byte[][] { encodedPoint, sk };\n+        }\n+\n+        private static void swap(byte[] arr, int i, int j) {\n+            byte tmp = arr[i];\n+            arr[i] = arr[j];\n+            arr[j] = tmp;\n+        }\n+\n+        private static void reverse(byte [] arr) {\n+            int i = 0;\n+            int j = arr.length - 1;\n+\n+            while (i < j) {\n+                swap(arr, i, j);\n+                i++;\n+                j--;\n+            }\n+        }\n+    }\n+\n+    private static EdDSAOperations getOps(String pname) {\n+        var op = switch (pname) {\n+            case \"Ed25519\" -> e2;\n+            case \"Ed448\" -> e4;\n+            default -> throw new AssertionError(\"unknown pname \" + pname);\n+        };\n+        return op;\n+    }\n+\n+    static final EdDSAParameterSpec plain = new EdDSAParameterSpec(false);\n+    static final EdDSAOperations e2, e4;\n+    static {\n+        try {\n+            e2 = new EdDSAOperations(EdDSAParameters.getBySize(AssertionError::new, 255));\n+            e4 = new EdDSAOperations(EdDSAParameters.getBySize(AssertionError::new, 448));\n+        } catch (Exception e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        var ps = List.of(new ProviderImpl(), Security.getProvider(\"SunEC\"));\n+        for (var p1 : ps) {\n+            for (var p2 : ps) {\n+                for (var p3 : ps) {\n+                    test(p1, p2, p3);\n+                }\n+            }\n+        }\n+    }\n+\n+    static void test(Provider p1, Provider p2, Provider p3) throws Exception {\n+        System.out.println(p1.getName() + \" \" + p2.getName() + \" \" + p3.getName());\n+        var g = KeyPairGenerator.getInstance(\"EdDSA\", p1);\n+        g.initialize(NamedParameterSpec.ED448);\n+        var kp = g.generateKeyPair();\n+        var s1 = Signature.getInstance(\"EdDSA\", p2);\n+        var s2 = Signature.getInstance(\"EdDSA\", p3);\n+        var f1 = KeyFactory.getInstance(\"EdDSA\", p2);\n+        var f2 = KeyFactory.getInstance(\"EdDSA\", p3);\n+        var sk = (PrivateKey) f1.translateKey(kp.getPrivate());\n+        var pk = (PublicKey) f2.translateKey(kp.getPublic());\n+        \/\/ sign and verify twice to make sure the key is intact\n+        s1.initSign(sk);\n+        var sig1 = s1.sign();\n+        s1.initSign(sk);\n+        var sig2 = s1.sign();\n+        \/\/ EdDSA signing is deterministic\n+        Asserts.assertEqualsByteArray(sig1, sig2);\n+        s2.initVerify(pk);\n+        Asserts.assertTrue(s2.verify(sig1));\n+        s2.initVerify(pk);\n+        Asserts.assertTrue(s2.verify(sig2));\n+        \/\/ No parameters defined\n+        s1.setParameter(null);\n+        Utils.runAndCheckException(() -> s1.setParameter(NamedParameterSpec.ED448),\n+                InvalidAlgorithmParameterException.class);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/NamedEdDSA.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"},{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8340327\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.pkcs\n+ *          java.base\/sun.security.provider\n+ *          java.base\/sun.security.util\n+ * @library \/test\/lib\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.security.SeededSecureRandom;\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.provider.NamedKeyFactory;\n+import sun.security.provider.NamedKeyPairGenerator;\n+import sun.security.util.RawKeySpec;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.security.*;\n+import java.security.spec.*;\n+\n+public class NamedKeyFactoryTest {\n+\n+    private static final SeededSecureRandom RAND = SeededSecureRandom.one();\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.addProvider(new ProviderImpl());\n+\n+        var g = KeyPairGenerator.getInstance(\"sHA\");\n+        var g2 = KeyPairGenerator.getInstance(\"ShA-256\");\n+        var g5 = KeyPairGenerator.getInstance(\"SHa-512\");\n+        var kf = KeyFactory.getInstance(\"ShA\");\n+        var kf2 = KeyFactory.getInstance(\"Sha-256\");\n+        var kf5 = KeyFactory.getInstance(\"Sha-512\");\n+\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g2.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g5.generateKeyPair(), \"SHA\", \"SHA-512\");\n+\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g2.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g5.generateKeyPair(), \"SHA\", \"SHA-512\");\n+\n+        Utils.runAndCheckException(() -> g.initialize(NamedParameterSpec.ED448),\n+                InvalidAlgorithmParameterException.class); \/\/ wrong pname\n+        Utils.runAndCheckException(() -> g.initialize(new NamedParameterSpec(\"SHA-384\")),\n+                InvalidAlgorithmParameterException.class); \/\/ wrong pname\n+\n+        Utils.runAndCheckException(() -> g5.initialize(new NamedParameterSpec(\"SHA-256\")),\n+                InvalidAlgorithmParameterException.class); \/\/ diff pname\n+        g5.initialize(new NamedParameterSpec(\"SHA-512\"));\n+\n+        g.initialize(new NamedParameterSpec(\"sHA-512\"));\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-512\");\n+        g.initialize(new NamedParameterSpec(\"ShA-256\"));\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n+\n+        var pk = new NamedX509Key(\"sHa\", \"ShA-256\", RAND.nBytes(2));\n+        var sk = new NamedPKCS8Key(\"sHa\", \"SHa-256\", RAND.nBytes(2));\n+        checkKey(pk, \"sHa\", \"ShA-256\");\n+        checkKey(sk, \"sHa\", \"SHa-256\");\n+\n+        Asserts.assertEquals(\"X.509\", pk.getFormat());\n+        Asserts.assertEquals(\"PKCS#8\", sk.getFormat());\n+\n+        var pkSpec = kf.getKeySpec(pk, X509EncodedKeySpec.class);\n+        var skSpec = kf.getKeySpec(sk, PKCS8EncodedKeySpec.class);\n+\n+        kf2.getKeySpec(pk, X509EncodedKeySpec.class);\n+        kf2.getKeySpec(sk, PKCS8EncodedKeySpec.class);\n+        Utils.runAndCheckException(() -> kf5.getKeySpec(pk, X509EncodedKeySpec.class),\n+                InvalidKeySpecException.class); \/\/ wrong KF\n+        Utils.runAndCheckException(() -> kf5.getKeySpec(sk, PKCS8EncodedKeySpec.class),\n+                InvalidKeySpecException.class);\n+        Utils.runAndCheckException(() -> kf.getKeySpec(pk, PKCS8EncodedKeySpec.class),\n+                InvalidKeySpecException.class); \/\/ wrong KeySpec\n+        Utils.runAndCheckException(() -> kf.getKeySpec(sk, X509EncodedKeySpec.class),\n+                InvalidKeySpecException.class);\n+\n+        checkKey(kf.generatePublic(pkSpec), \"SHA\", \"SHA-256\");\n+        Utils.runAndCheckException(() -> kf.generatePrivate(pkSpec),\n+                InvalidKeySpecException.class);\n+\n+        checkKey(kf.generatePrivate(skSpec), \"SHA\", \"SHA-256\");\n+        Utils.runAndCheckException(() -> kf.generatePublic(skSpec),\n+                InvalidKeySpecException.class);\n+\n+        checkKey(kf2.generatePrivate(skSpec), \"SHA\", \"SHA-256\");\n+        checkKey(kf2.generatePublic(pkSpec), \"SHA\", \"SHA-256\");\n+\n+        Utils.runAndCheckException(() -> kf5.generatePublic(pkSpec),\n+                InvalidKeySpecException.class); \/\/ wrong KF\n+        Utils.runAndCheckException(() -> kf5.generatePublic(skSpec),\n+                InvalidKeySpecException.class);\n+\n+        \/\/ The private RawKeySpec and unnamed RAW EncodedKeySpec\n+        var prk = kf.getKeySpec(pk, RawKeySpec.class);\n+        Asserts.assertEqualsByteArray(prk.getKeyArr(), pk.getRawBytes());\n+        var prk2 = kf.getKeySpec(pk, EncodedKeySpec.class);\n+        Asserts.assertEquals(\"RAW\", prk2.getFormat());\n+        Asserts.assertEqualsByteArray(prk.getKeyArr(), prk2.getEncoded());\n+\n+        Asserts.assertEqualsByteArray(kf2.generatePublic(prk).getEncoded(), pk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePublic(prk), InvalidKeySpecException.class); \/\/ no pname\n+        Asserts.assertEqualsByteArray(kf2.generatePublic(prk2).getEncoded(), pk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePublic(prk2), InvalidKeySpecException.class); \/\/ no pname\n+\n+        var srk = kf.getKeySpec(sk, RawKeySpec.class);\n+        Asserts.assertEqualsByteArray(srk.getKeyArr(), sk.getRawBytes());\n+        var srk2 = kf.getKeySpec(sk, EncodedKeySpec.class);\n+        Asserts.assertEquals(\"RAW\", srk2.getFormat());\n+        Asserts.assertEqualsByteArray(srk2.getEncoded(), sk.getRawBytes());\n+\n+        Asserts.assertEqualsByteArray(kf2.generatePrivate(srk).getEncoded(), sk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePrivate(srk), InvalidKeySpecException.class); \/\/ no pname\n+        Asserts.assertEqualsByteArray(kf2.generatePrivate(srk2).getEncoded(), sk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePrivate(srk2), InvalidKeySpecException.class); \/\/ no pname\n+\n+        var pk1 = new PublicKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAND.nBytes(2); }\n+        };\n+        var pk2 = new PublicKey() {\n+            public String getAlgorithm() { return \"sHA-256\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAND.nBytes(2); }\n+        };\n+        var pk3 = new PublicKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAND.nBytes(2); }\n+            public AlgorithmParameterSpec getParams() { return new NamedParameterSpec(\"sHA-256\"); }\n+        };\n+\n+        checkKey(kf2.translateKey(pk1), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(pk2), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(pk3), \"SHA\", \"SHA-256\");\n+\n+        Utils.runAndCheckException(() -> kf.translateKey(pk1), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(pk2), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(pk3), InvalidKeyException.class);\n+\n+        var sk1 = new PrivateKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAND.nBytes(2); }\n+        };\n+        var sk2 = new PrivateKey() {\n+            public String getAlgorithm() { return \"sHA-256\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAND.nBytes(2); }\n+        };\n+        var sk3 = new PrivateKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAND.nBytes(2); }\n+            public AlgorithmParameterSpec getParams() { return new NamedParameterSpec(\"sHA-256\"); }\n+        };\n+\n+        checkKey(kf2.translateKey(sk1), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(sk2), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(sk3), \"SHA\", \"SHA-256\");\n+\n+        Utils.runAndCheckException(() -> kf.translateKey(sk1), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(sk2), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(sk3), InvalidKeyException.class);\n+    }\n+\n+    static void checkKeyPair(KeyPair kp, String algName, String toString) {\n+        checkKey(kp.getPrivate(), algName, toString);\n+        checkKey(kp.getPublic(), algName, toString);\n+    }\n+\n+    static void checkKey(Key k, String algName, String pname) {\n+        Asserts.assertEquals(algName, k.getAlgorithm());\n+        Asserts.assertTrue(k.toString().contains(pname));\n+        if (k instanceof AsymmetricKey ak && ak.getParams() instanceof NamedParameterSpec nps) {\n+            Asserts.assertEquals(pname, nps.getName());\n+        }\n+    }\n+\n+    \/\/ Provider\n+\n+    public static class ProviderImpl extends Provider {\n+        public ProviderImpl() {\n+            super(\"P\", \"1\", \"...\");\n+            put(\"KeyFactory.SHA\", KF.class.getName());\n+            put(\"KeyFactory.SHA-256\", KF1.class.getName());\n+            put(\"KeyFactory.SHA-512\", KF2.class.getName());\n+            put(\"KeyPairGenerator.SHA\", KPG.class.getName());\n+            put(\"KeyPairGenerator.SHA-256\", KPG1.class.getName());\n+            put(\"KeyPairGenerator.SHA-512\", KPG2.class.getName());\n+        }\n+    }\n+    public static class KF extends NamedKeyFactory {\n+        public KF() {\n+            super(\"SHA\", \"SHA-256\", \"SHA-512\");\n+        }\n+    }\n+    public static class KF1 extends NamedKeyFactory {\n+        public KF1() {\n+            super(\"SHA\", \"SHA-256\");\n+        }\n+    }\n+    public static class KF2 extends NamedKeyFactory {\n+        public KF2() {\n+            super(\"SHA\", \"SHA-512\");\n+        }\n+    }\n+    public static class KPG extends NamedKeyPairGenerator {\n+        public KPG() {\n+            super(\"SHA\", \"SHA-256\", \"SHA-512\");\n+        }\n+\n+        public KPG(String pname) {\n+            super(\"SHA\", pname);\n+        }\n+\n+        @Override\n+        public byte[][] implGenerateKeyPair(String name, SecureRandom sr) {\n+            var out = new byte[2][];\n+            out[0] = RAND.nBytes(name.endsWith(\"256\") ? 2 : 4);\n+            out[1] = RAND.nBytes(name.endsWith(\"256\") ? 2 : 4);\n+            return out;\n+        }\n+    }\n+    public static class KPG1 extends KPG {\n+        public KPG1() {\n+            super(\"SHA-256\");\n+        }\n+    }\n+    public static class KPG2 extends KPG {\n+        public KPG2() {\n+            super(\"SHA-512\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/NamedKeyFactoryTest.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-                .shouldContain(\"Generating 255 bit XDH key pair and a certificate (Ed25519) issued by <ca> with a validity of 90 days\")\n+                .shouldContain(\"Generating 255 bit X25519 key pair and a certificate (Ed25519) issued by <ca> with a validity of 90 days\")\n@@ -121,1 +121,1 @@\n-                .shouldContain(\"Subject Public Key Algorithm: 255-bit XDH key\")\n+                .shouldContain(\"Subject Public Key Algorithm: 255-bit X25519 key\")\n@@ -153,1 +153,1 @@\n-                .shouldContain(\"Generating 448 bit XDH key pair and a certificate (SHA384withRSA) issued by <ca2> with a validity of 90 days\")\n+                .shouldContain(\"Generating 448 bit X448 key pair and a certificate (SHA384withRSA) issued by <ca2> with a validity of 90 days\")\n@@ -180,1 +180,1 @@\n-                .shouldContain(\"Subject Public Key Algorithm: 448-bit XDH key\")\n+                .shouldContain(\"Subject Public Key Algorithm: 448-bit X448 key\")\n@@ -252,1 +252,1 @@\n-                .shouldContain(\"Generating 255 bit XDH key pair and a certificate (SHA256withDSA) issued by <ca1> with a validity of 90 days\")\n+                .shouldContain(\"Generating 255 bit X25519 key pair and a certificate (SHA256withDSA) issued by <ca1> with a validity of 90 days\")\n@@ -288,1 +288,1 @@\n-                .shouldContain(\"Subject Public Key Algorithm: 255-bit XDH key\")\n+                .shouldContain(\"Subject Public Key Algorithm: 255-bit X25519 key\")\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/GenKeyPairSigner.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -283,1 +283,0 @@\n-\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/TestZoneInfo310.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -96,3 +96,3 @@\n-    static final String[] conflictingIDs = {\n-        \"EST\", \"MST\", \"HST\"\n-    };\n+    static final Map<String, String> conflictingIDs = Map.of(\n+        \"EST\", \"America\/Panama\",\n+        \"MST\", \"America\/Phoenix\");\n@@ -846,4 +846,2 @@\n-                     \/\/ Remove the conflicting IDs from the alias table.\n-                     for (String key : conflictingIDs) {\n-                         aliases.remove(key);\n-                     }\n+                     \/\/ Replace old mappings from `jdk11_backward`\n+                     aliases.putAll(conflictingIDs);\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/ZoneInfoOld.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-        getTzInfo(\"de\", \"DE\");\n@@ -49,1 +48,0 @@\n-\n@@ -59,2 +57,2 @@\n-        if(!euroTz.getDisplayName(false, TimeZone.SHORT, tzLocale).equals(\"MET\"))\n-          throw new RuntimeException(\"Timezone name is incorrect (should be MET)\\n\");\n+        if (!euroTz.getDisplayName(false, TimeZone.SHORT, tzLocale).equals(\"CET\"))\n+            throw new RuntimeException(\"Timezone name is incorrect (should be CET)\\n\");\n@@ -64,2 +62,2 @@\n-        if(!euroTz.getDisplayName(true, TimeZone.SHORT, tzLocale).equals(\"MEST\"))\n-            throw new RuntimeException(\"Summer timezone name is incorrect (should be MEST)\\n\");\n+        if (!euroTz.getDisplayName(true, TimeZone.SHORT, tzLocale).equals(\"CEST\"))\n+            throw new RuntimeException(\"Summer timezone name is incorrect (should be CEST)\\n\");\n","filename":"test\/jdk\/sun\/util\/resources\/TimeZone\/Bug4848242.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,948 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.Runtime.Version;\n+import java.net.URI;\n+import java.nio.file.*;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.*;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import javax.lang.model.util.Types;\n+import javax.tools.*;\n+import javax.tools.JavaFileManager.Location;\n+import com.sun.source.tree.*;\n+import com.sun.source.util.JavacTask;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n+import com.sun.tools.javac.api.JavacTaskImpl;\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.util.Pair;\n+import jtreg.SkippedException;\n+\n+\/*\n+This checker checks the values of the `@since` tag found in the documentation comment for an element against\n+the release in which the element first appeared.\n+The source code containing the documentation comments is read from `src.zip` in the release of JDK used to run the test.\n+The releases used to determine the expected value of `@since` tags are taken from the historical data built into `javac`.\n+\n+The `@since` checker works as a two-step process:\n+In the first step, we process JDKs 9-current, only classfiles,\n+  producing a map `<unique-Element-ID`> => `<version(s)-where-it-was-introduced>`.\n+    - \"version(s)\", because we handle versioning of Preview API, so there may be two versions\n+     (we use a class with two fields for preview and stable),\n+    one when it was introduced as a preview, and one when it went out of preview. More on that below.\n+    - For each Element, we compute the unique ID, look into the map, and if there's nothing,\n+     record the current version as the originating version.\n+    - At the end of this step we have a map of the Real since values\n+\n+In the second step, we look at \"effective\" `@since` tags in the mainline sources, from `src.zip`\n+ (if the test run doesn't have it, we throw a `jtreg.SkippedException`)\n+    - We only check the specific MODULE whose name was passed as an argument in the test.\n+      In that module, we look for unqualified exports and test those packages.\n+    - The `@since` checker verifies that for every API element, the real since value and\n+      the effective since value are the same, and reports an error if they are not.\n+\n+Important note : We only check code written since JDK 9 as the releases used to determine the expected value\n+                 of @since tags are taken from the historical data built into javac which only goes back that far\n+\n+note on rules for Real and effective `@since:\n+\n+Real since value of an API element is computed as the oldest release in which the given API element was introduced.\n+That is:\n+- for modules, packages, classes and interfaces, the release in which the element with the given qualified name was introduced\n+- for constructors, the release in which the constructor with the given VM descriptor was introduced\n+- for methods and fields, the release in which the given method or field with the given VM descriptor became a member\n+  of its enclosing class or interface, whether direct or inherited\n+\n+Effective since value of an API element is computed as follows:\n+- if the given element has a @since tag in its javadoc, it is used\n+- in all other cases, return the effective since value of the enclosing element\n+\n+\n+Special Handling for preview method, as per JEP 12:\n+- When an element is still marked as preview, the `@since` should be the first JDK release where the element was added.\n+- If the element is no longer marked as preview, the `@since` should be the first JDK release where it was no longer preview.\n+\n+note on legacy preview: Until JDK 14, the preview APIs were not marked in any machine-understandable way.\n+                        It was deprecated, and had a comment in the javadoc.\n+                        and the use of `@PreviewFeature` only became standard in JDK 17.\n+                        So the checker has an explicit knowledge of these preview elements.\n+\n+note: The `<unique-Element-ID>` for methods looks like\n+      `method: <erased-return-descriptor> <binary-name-of-enclosing-class>.<method-name>(<ParameterDescriptor>)`.\n+it is somewhat inspired from the VM Method Descriptors. But we use the erased return so that methods\n+that were later generified remain the same.\n+\n+usage: the checker is run from a module specific test\n+        `@run main SinceChecker <moduleName> [--exclude package1,package2 | --exclude package1 package2]`\n+*\/\n+\n+public class SinceChecker {\n+    private final Map<String, Set<String>> LEGACY_PREVIEW_METHODS = new HashMap<>();\n+    private final Map<String, IntroducedIn> classDictionary = new HashMap<>();\n+    private final JavaCompiler tool;\n+    private int errorCount = 0;\n+\n+    \/\/ packages to skip during the test\n+    private static final Set<String> EXCLUDE_LIST = new HashSet<>();\n+\n+    public static class IntroducedIn {\n+        public String introducedPreview;\n+        public String introducedStable;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            throw new IllegalArgumentException(\"Test module not specified\");\n+        }\n+        String moduleName = args[0];\n+        boolean excludeFlag = false;\n+\n+        for (int i = 1; i < args.length; i++) {\n+            if (\"--exclude\".equals(args[i])) {\n+                excludeFlag = true;\n+                continue;\n+            }\n+\n+            if (excludeFlag) {\n+                if (args[i].contains(\",\")) {\n+                    EXCLUDE_LIST.addAll(Arrays.asList(args[i].split(\",\")));\n+                } else {\n+                    EXCLUDE_LIST.add(args[i]);\n+                }\n+            }\n+        }\n+\n+        SinceChecker sinceCheckerTestHelper = new SinceChecker(moduleName);\n+        sinceCheckerTestHelper.checkModule(moduleName);\n+    }\n+\n+    private void error(String message) {\n+        System.err.println(message);\n+        errorCount++;\n+    }\n+\n+    private SinceChecker(String moduleName) throws IOException {\n+        tool = ToolProvider.getSystemJavaCompiler();\n+        for (int i = 9; i <= Runtime.version().feature(); i++) {\n+            DiagnosticListener<? super JavaFileObject> noErrors = d -> {\n+                if (!d.getCode().equals(\"compiler.err.module.not.found\")) {\n+                    error(d.getMessage(null));\n+                }\n+            };\n+            JavacTask ct = (JavacTask) tool.getTask(null,\n+                    null,\n+                    noErrors,\n+                    List.of(\"--add-modules\", moduleName, \"--release\", String.valueOf(i)),\n+                    null,\n+                    Collections.singletonList(SimpleJavaFileObject.forSource(URI.create(\"myfo:\/Test.java\"), \"\")));\n+            ct.analyze();\n+\n+            String version = String.valueOf(i);\n+            Elements elements = ct.getElements();\n+            elements.getModuleElement(\"java.base\"); \/\/ forces module graph to be instantiated\n+            elements.getAllModuleElements().forEach(me ->\n+                    processModuleElement(me, version, ct));\n+        }\n+    }\n+\n+    private void processModuleElement(ModuleElement moduleElement, String releaseVersion, JavacTask ct) {\n+        processElement(moduleElement, moduleElement, ct.getTypes(), releaseVersion);\n+        for (ModuleElement.ExportsDirective ed : ElementFilter.exportsIn(moduleElement.getDirectives())) {\n+            if (ed.getTargetModules() == null) {\n+                processPackageElement(ed.getPackage(), releaseVersion, ct);\n+            }\n+        }\n+    }\n+\n+    private void processPackageElement(PackageElement pe, String releaseVersion, JavacTask ct) {\n+        processElement(pe, pe, ct.getTypes(), releaseVersion);\n+        List<TypeElement> typeElements = ElementFilter.typesIn(pe.getEnclosedElements());\n+        for (TypeElement te : typeElements) {\n+            processClassElement(te, releaseVersion, ct.getTypes(), ct.getElements());\n+        }\n+    }\n+\n+    \/\/\/ JDK documentation only contains public and protected declarations\n+    private boolean isDocumented(Element te) {\n+        Set<Modifier> mod = te.getModifiers();\n+        return mod.contains(Modifier.PUBLIC) || mod.contains(Modifier.PROTECTED);\n+    }\n+\n+    private boolean isMember(Element e) {\n+        var kind = e.getKind();\n+        return kind.isField() || switch (kind) {\n+            case METHOD, CONSTRUCTOR -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    private void processClassElement(TypeElement te, String version, Types types, Elements elements) {\n+        if (!isDocumented(te)) {\n+            return;\n+        }\n+        processElement(te.getEnclosingElement(), te, types, version);\n+        elements.getAllMembers(te).stream()\n+                .filter(this::isDocumented)\n+                .filter(this::isMember)\n+                .forEach(element -> processElement(te, element, types, version));\n+        te.getEnclosedElements().stream()\n+                .filter(element -> element.getKind().isDeclaredType())\n+                .map(TypeElement.class::cast)\n+                .forEach(nestedClass -> processClassElement(nestedClass, version, types, elements));\n+    }\n+\n+    private void processElement(Element explicitOwner, Element element, Types types, String version) {\n+        String uniqueId = getElementName(explicitOwner, element, types);\n+        IntroducedIn introduced = classDictionary.computeIfAbsent(uniqueId, _ -> new IntroducedIn());\n+        if (isPreview(element, uniqueId, version)) {\n+            if (introduced.introducedPreview == null) {\n+                introduced.introducedPreview = version;\n+            }\n+        } else {\n+            if (introduced.introducedStable == null) {\n+                introduced.introducedStable = version;\n+            }\n+        }\n+    }\n+\n+    private boolean isPreview(Element el, String uniqueId, String currentVersion) {\n+        while (el != null) {\n+            Symbol s = (Symbol) el;\n+            if ((s.flags() & Flags.PREVIEW_API) != 0) {\n+                return true;\n+            }\n+            el = el.getEnclosingElement();\n+        }\n+\n+        return LEGACY_PREVIEW_METHODS.getOrDefault(currentVersion, Set.of())\n+                .contains(uniqueId);\n+    }\n+\n+    private void checkModule(String moduleName) throws Exception {\n+        Path home = Paths.get(System.getProperty(\"java.home\"));\n+        Path srcZip = home.resolve(\"lib\").resolve(\"src.zip\");\n+        if (Files.notExists(srcZip)) {\n+            \/\/possibly running over an exploded JDK build, attempt to find a\n+            \/\/co-located full JDK image with src.zip:\n+            Path testJdk = Paths.get(System.getProperty(\"test.jdk\"));\n+            srcZip = testJdk.getParent().resolve(\"images\").resolve(\"jdk\").resolve(\"lib\").resolve(\"src.zip\");\n+        }\n+        if (!Files.isReadable(srcZip)) {\n+            throw new SkippedException(\"Skipping Test because src.zip wasn't found or couldn't be read\");\n+        }\n+        URI uri = URI.create(\"jar:\" + srcZip.toUri());\n+        try (FileSystem zipFO = FileSystems.newFileSystem(uri, Collections.emptyMap())) {\n+            Path root = zipFO.getRootDirectories().iterator().next();\n+            Path moduleDirectory = root.resolve(moduleName);\n+            try (StandardJavaFileManager fm =\n+                         tool.getStandardFileManager(null, null, null)) {\n+                JavacTask ct = (JavacTask) tool.getTask(null,\n+                        fm,\n+                        null,\n+                        List.of(\"--add-modules\", moduleName, \"-d\", \".\"),\n+                        null,\n+                        Collections.singletonList(SimpleJavaFileObject.forSource(URI.create(\"myfo:\/Test.java\"), \"\")));\n+                ct.analyze();\n+                Elements elements = ct.getElements();\n+                elements.getModuleElement(\"java.base\");\n+                try (EffectiveSourceSinceHelper javadocHelper = EffectiveSourceSinceHelper.create(ct, List.of(root), this)) {\n+                    processModuleCheck(elements.getModuleElement(moduleName), ct, moduleDirectory, javadocHelper);\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                    error(\"Initiating javadocHelper Failed \" + e);\n+                }\n+                if (errorCount > 0) {\n+                    throw new Exception(\"The `@since` checker found \" + errorCount + \" problems\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean isExcluded(ModuleElement.ExportsDirective ed ){\n+        return EXCLUDE_LIST.stream().anyMatch(excludePackage ->\n+            ed.getPackage().toString().equals(excludePackage) ||\n+            ed.getPackage().toString().startsWith(excludePackage + \".\"));\n+    }\n+\n+    private void processModuleCheck(ModuleElement moduleElement, JavacTask ct, Path moduleDirectory, EffectiveSourceSinceHelper javadocHelper) {\n+        if (moduleElement == null) {\n+            error(\"Module element: was null because `elements.getModuleElement(moduleName)` returns null.\" +\n+                    \"fixes are needed for this Module\");\n+        }\n+        String moduleVersion = getModuleVersionFromFile(moduleDirectory);\n+        checkModuleOrPackage(javadocHelper, moduleVersion, moduleElement, ct, \"Module: \");\n+        for (ModuleElement.ExportsDirective ed : ElementFilter.exportsIn(moduleElement.getDirectives())) {\n+            if (ed.getTargetModules() == null) {\n+                String packageVersion = getPackageVersionFromFile(moduleDirectory, ed);\n+                if (packageVersion != null && !isExcluded(ed)) {\n+                    checkModuleOrPackage(javadocHelper, packageVersion, ed.getPackage(), ct, \"Package: \");\n+                    analyzePackageCheck(ed.getPackage(), ct, javadocHelper);\n+                } \/\/ Skip the package if packageVersion is null\n+            }\n+        }\n+    }\n+\n+    private void checkModuleOrPackage(EffectiveSourceSinceHelper javadocHelper, String moduleVersion, Element moduleElement, JavacTask ct, String elementCategory) {\n+        String id = getElementName(moduleElement, moduleElement, ct.getTypes());\n+        var elementInfo = classDictionary.get(id);\n+        if (elementInfo == null) {\n+            error(\"Element :\" + id + \" was not mapped\");\n+            return;\n+        }\n+        String version = elementInfo.introducedStable;\n+        if (moduleVersion == null) {\n+            error(\"Unable to retrieve `@since` for \" + elementCategory + id);\n+        } else {\n+            String position = javadocHelper.getElementPosition(id);\n+            checkEquals(position, moduleVersion, version, id);\n+        }\n+    }\n+\n+    private String getModuleVersionFromFile(Path moduleDirectory) {\n+        Path moduleInfoFile = moduleDirectory.resolve(\"module-info.java\");\n+        String version = null;\n+        if (Files.exists(moduleInfoFile)) {\n+            try {\n+                String moduleInfoContent = Files.readString(moduleInfoFile);\n+                var extractedVersion = extractSinceVersionFromText(moduleInfoContent);\n+                if (extractedVersion != null) {\n+                    version = extractedVersion.toString();\n+                }\n+            } catch (IOException e) {\n+                error(\"module-info.java not found or couldn't be opened AND this module has no unqualified exports\");\n+            }\n+        }\n+        return version;\n+    }\n+\n+    private String getPackageVersionFromFile(Path moduleDirectory, ModuleElement.ExportsDirective ed) {\n+        Path pkgInfo = moduleDirectory.resolve(ed.getPackage()\n+                        .getQualifiedName()\n+                        .toString()\n+                        .replace(\".\", File.separator)\n+                )\n+                .resolve(\"package-info.java\");\n+\n+        if (!Files.exists(pkgInfo)) {\n+            return null; \/\/ Skip if the file does not exist\n+        }\n+\n+        String packageTopVersion = null;\n+        try {\n+            String packageContent = Files.readString(pkgInfo);\n+            var extractedVersion = extractSinceVersionFromText(packageContent);\n+            if (extractedVersion != null) {\n+                packageTopVersion = extractedVersion.toString();\n+            } else {\n+                error(ed.getPackage().getQualifiedName() + \": package-info.java exists but doesn't contain @since\");\n+            }\n+        } catch (IOException e) {\n+            error(ed.getPackage().getQualifiedName() + \": package-info.java couldn't be opened\");\n+        }\n+        return packageTopVersion;\n+    }\n+\n+    private void analyzePackageCheck(PackageElement pe, JavacTask ct, EffectiveSourceSinceHelper javadocHelper) {\n+        List<TypeElement> typeElements = ElementFilter.typesIn(pe.getEnclosedElements());\n+        for (TypeElement te : typeElements) {\n+            analyzeClassCheck(te, null, javadocHelper, ct.getTypes(), ct.getElements());\n+        }\n+    }\n+\n+    private boolean isNotCommonRecordMethod(TypeElement te, Element element, Types types) {\n+        var isRecord = te.getKind() == ElementKind.RECORD;\n+        if (!isRecord) {\n+            return true;\n+        }\n+        String uniqueId = getElementName(te, element, types);\n+        boolean isCommonMethod = uniqueId.endsWith(\".toString()\") ||\n+                uniqueId.endsWith(\".hashCode()\") ||\n+                uniqueId.endsWith(\".equals(java.lang.Object)\");\n+        if (isCommonMethod) {\n+            return false;\n+        }\n+        for (var parameter : te.getEnclosedElements()) {\n+            if (parameter.getKind() == ElementKind.RECORD_COMPONENT) {\n+                if (uniqueId.endsWith(String.format(\"%s.%s()\", te.getSimpleName(), parameter.getSimpleName().toString()))) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private void analyzeClassCheck(TypeElement te, String version, EffectiveSourceSinceHelper javadocHelper,\n+                                   Types types, Elements elementUtils) {\n+        String currentjdkVersion = String.valueOf(Runtime.version().feature());\n+        if (!isDocumented(te)) {\n+            return;\n+        }\n+        checkElement(te.getEnclosingElement(), te, types, javadocHelper, version, elementUtils);\n+        te.getEnclosedElements().stream().filter(this::isDocumented)\n+                .filter(this::isMember)\n+                .filter(element -> isNotCommonRecordMethod(te, element, types))\n+                .forEach(element -> checkElement(te, element, types, javadocHelper, version, elementUtils));\n+        te.getEnclosedElements().stream()\n+                .filter(element -> element.getKind().isDeclaredType())\n+                .map(TypeElement.class::cast)\n+                .forEach(nestedClass -> analyzeClassCheck(nestedClass, currentjdkVersion, javadocHelper, types, elementUtils));\n+    }\n+\n+    private void checkElement(Element explicitOwner, Element element, Types types,\n+                              EffectiveSourceSinceHelper javadocHelper, String currentVersion, Elements elementUtils) {\n+        String uniqueId = getElementName(explicitOwner, element, types);\n+\n+        if (element.getKind() == ElementKind.METHOD &&\n+                element.getEnclosingElement().getKind() == ElementKind.ENUM &&\n+                (uniqueId.contains(\".values()\") || uniqueId.contains(\".valueOf(java.lang.String)\"))) {\n+            \/\/mandated enum type methods\n+            return;\n+        }\n+        String sinceVersion = null;\n+        var effectiveSince = javadocHelper.effectiveSinceVersion(explicitOwner, element, types, elementUtils);\n+        if (effectiveSince == null) {\n+            \/\/ Skip the element if the java file doesn't exist in src.zip\n+            return;\n+        }\n+        sinceVersion = effectiveSince.toString();\n+        IntroducedIn mappedVersion = classDictionary.get(uniqueId);\n+        if (mappedVersion == null) {\n+            error(\"Element: \" + uniqueId + \" was not mapped\");\n+            return;\n+        }\n+        String realMappedVersion = null;\n+        try {\n+            realMappedVersion = isPreview(element, uniqueId, currentVersion) ?\n+                    mappedVersion.introducedPreview :\n+                    mappedVersion.introducedStable;\n+        } catch (Exception e) {\n+            error(\"For element \" + element + \"mappedVersion\" + mappedVersion + \" is null \" + e);\n+        }\n+        String position = javadocHelper.getElementPosition(uniqueId);\n+        checkEquals(position, sinceVersion, realMappedVersion, uniqueId);\n+    }\n+\n+    private Version extractSinceVersionFromText(String documentation) {\n+        Pattern pattern = Pattern.compile(\"@since\\\\s+(\\\\d+(?:\\\\.\\\\d+)?)\");\n+        Matcher matcher = pattern.matcher(documentation);\n+        if (matcher.find()) {\n+            String versionString = matcher.group(1);\n+            try {\n+                if (versionString.equals(\"1.0\")) {\n+                    versionString = \"1\"; \/\/ended up being necessary\n+                } else if (versionString.startsWith(\"1.\")) {\n+                    versionString = versionString.substring(2);\n+                }\n+                return Version.parse(versionString);\n+            } catch (NumberFormatException ex) {\n+                error(\"`@since` value that cannot be parsed: \" + versionString);\n+                return null;\n+            }\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private void checkEquals(String prefix, String sinceVersion, String mappedVersion, String name) {\n+        if (sinceVersion == null || mappedVersion == null) {\n+            error(name + \": NULL value for either real or effective `@since` . real\/mapped version is=\"\n+                    + mappedVersion + \" while the `@since` in the source code is= \" + sinceVersion);\n+            return;\n+        }\n+        if (Integer.parseInt(sinceVersion) < 9) {\n+            sinceVersion = \"9\";\n+        }\n+        if (!sinceVersion.equals(mappedVersion)) {\n+            String message = getWrongSinceMessage(prefix, sinceVersion, mappedVersion, name);\n+            error(message);\n+        }\n+    }\n+    private static String getWrongSinceMessage(String prefix, String sinceVersion, String mappedVersion, String elementSimpleName) {\n+        String message;\n+        if (mappedVersion.equals(\"9\")) {\n+            message = elementSimpleName + \": `@since` version is \" + sinceVersion + \" but the element exists before JDK 10\";\n+        } else {\n+            message = elementSimpleName + \": `@since` version: \" + sinceVersion + \"; should be: \" + mappedVersion;\n+        }\n+        return prefix + message;\n+    }\n+\n+    private static String getElementName(Element owner, Element element, Types types) {\n+        String prefix = \"\";\n+        String suffix = \"\";\n+        ElementKind kind = element.getKind();\n+        if (kind.isField()) {\n+            TypeElement te = (TypeElement) owner;\n+            prefix = \"field\";\n+            suffix = \": \" + te.getQualifiedName() + \":\" + element.getSimpleName();\n+        } else if (kind == ElementKind.METHOD || kind == ElementKind.CONSTRUCTOR) {\n+            prefix = \"method\";\n+            TypeElement te = (TypeElement) owner;\n+            ExecutableElement executableElement = (ExecutableElement) element;\n+            String returnType = types.erasure(executableElement.getReturnType()).toString();\n+            String methodName = executableElement.getSimpleName().toString();\n+            String descriptor = executableElement.getParameters().stream()\n+                    .map(p -> types.erasure(p.asType()).toString())\n+                    .collect(Collectors.joining(\",\", \"(\", \")\"));\n+            suffix = \": \" + returnType + \" \" + te.getQualifiedName() + \".\" + methodName + descriptor;\n+        } else if (kind.isDeclaredType()) {\n+            if (kind.isClass()) {\n+                prefix = \"class\";\n+            } else if (kind.isInterface()) {\n+                prefix = \"interface\";\n+            }\n+            suffix = \": \" + ((TypeElement) element).getQualifiedName();\n+        } else if (kind == ElementKind.PACKAGE) {\n+            prefix = \"package\";\n+            suffix = \": \" + ((PackageElement) element).getQualifiedName();\n+        } else if (kind == ElementKind.MODULE) {\n+            prefix = \"module\";\n+            suffix = \": \" + ((ModuleElement) element).getQualifiedName();\n+        }\n+        return prefix + suffix;\n+    }\n+\n+    \/\/these were preview in before the introduction of the @PreviewFeature\n+    {\n+        LEGACY_PREVIEW_METHODS.put(\"9\", Set.of(\n+                \"module: jdk.nio.mapmode\",\n+                \"module: java.transaction.xa\",\n+                \"module: jdk.unsupported.desktop\",\n+                \"module: jdk.jpackage\",\n+                \"module: java.net.http\"\n+        ));\n+        LEGACY_PREVIEW_METHODS.put(\"10\", Set.of(\n+                \"module: jdk.nio.mapmode\",\n+                \"module: java.transaction.xa\",\n+                \"module: java.net.http\",\n+                \"module: jdk.unsupported.desktop\",\n+                \"module: jdk.jpackage\"\n+        ));\n+        LEGACY_PREVIEW_METHODS.put(\"11\", Set.of(\n+                \"module: jdk.nio.mapmode\",\n+                \"module: jdk.jpackage\"\n+        ));\n+        LEGACY_PREVIEW_METHODS.put(\"12\", Set.of(\n+                \"module: jdk.nio.mapmode\",\n+                \"module: jdk.jpackage\",\n+                \"method: com.sun.source.tree.ExpressionTree com.sun.source.tree.BreakTree.getValue()\",\n+                \"method: java.util.List com.sun.source.tree.CaseTree.getExpressions()\",\n+                \"method: com.sun.source.tree.Tree com.sun.source.tree.CaseTree.getBody()\",\n+                \"method: com.sun.source.tree.CaseTree.CaseKind com.sun.source.tree.CaseTree.getCaseKind()\",\n+                \"class: com.sun.source.tree.CaseTree.CaseKind\",\n+                \"field: com.sun.source.tree.CaseTree.CaseKind:STATEMENT\",\n+                \"field: com.sun.source.tree.CaseTree.CaseKind:RULE\",\n+                \"field: com.sun.source.tree.Tree.Kind:SWITCH_EXPRESSION\",\n+                \"interface: com.sun.source.tree.SwitchExpressionTree\",\n+                \"method: com.sun.source.tree.ExpressionTree com.sun.source.tree.SwitchExpressionTree.getExpression()\",\n+                \"method: java.util.List com.sun.source.tree.SwitchExpressionTree.getCases()\",\n+                \"method: java.lang.Object com.sun.source.tree.TreeVisitor.visitSwitchExpression(com.sun.source.tree.SwitchExpressionTree,java.lang.Object)\",\n+                \"method: java.lang.Object com.sun.source.util.TreeScanner.visitSwitchExpression(com.sun.source.tree.SwitchExpressionTree,java.lang.Object)\",\n+                \"method: java.lang.Object com.sun.source.util.SimpleTreeVisitor.visitSwitchExpression(com.sun.source.tree.SwitchExpressionTree,java.lang.Object)\"\n+        ));\n+\n+        LEGACY_PREVIEW_METHODS.put(\"13\", Set.of(\n+                \"module: jdk.nio.mapmode\",\n+                \"module: jdk.jpackage\",\n+                \"method: java.util.List com.sun.source.tree.CaseTree.getExpressions()\",\n+                \"method: com.sun.source.tree.Tree com.sun.source.tree.CaseTree.getBody()\",\n+                \"method: com.sun.source.tree.CaseTree.CaseKind com.sun.source.tree.CaseTree.getCaseKind()\",\n+                \"class: com.sun.source.tree.CaseTree.CaseKind\",\n+                \"field: com.sun.source.tree.CaseTree.CaseKind:STATEMENT\",\n+                \"field: com.sun.source.tree.CaseTree.CaseKind:RULE\",\n+                \"field: com.sun.source.tree.Tree.Kind:SWITCH_EXPRESSION\",\n+                \"interface: com.sun.source.tree.SwitchExpressionTree\",\n+                \"method: com.sun.source.tree.ExpressionTree com.sun.source.tree.SwitchExpressionTree.getExpression()\",\n+                \"method: java.util.List com.sun.source.tree.SwitchExpressionTree.getCases()\",\n+                \"method: java.lang.Object com.sun.source.tree.TreeVisitor.visitSwitchExpression(com.sun.source.tree.SwitchExpressionTree,java.lang.Object)\",\n+                \"method: java.lang.Object com.sun.source.util.TreeScanner.visitSwitchExpression(com.sun.source.tree.SwitchExpressionTree,java.lang.Object)\",\n+                \"method: java.lang.Object com.sun.source.util.SimpleTreeVisitor.visitSwitchExpression(com.sun.source.tree.SwitchExpressionTree,java.lang.Object)\",\n+                \"method: java.lang.String java.lang.String.stripIndent()\",\n+                \"method: java.lang.String java.lang.String.translateEscapes()\",\n+                \"method: java.lang.String java.lang.String.formatted(java.lang.Object[])\",\n+                \"class: javax.swing.plaf.basic.motif.MotifLookAndFeel\",\n+                \"field: com.sun.source.tree.Tree.Kind:YIELD\",\n+                \"interface: com.sun.source.tree.YieldTree\",\n+                \"method: com.sun.source.tree.ExpressionTree com.sun.source.tree.YieldTree.getValue()\",\n+                \"method: java.lang.Object com.sun.source.tree.TreeVisitor.visitYield(com.sun.source.tree.YieldTree,java.lang.Object)\",\n+                \"method: java.lang.Object com.sun.source.util.SimpleTreeVisitor.visitYield(com.sun.source.tree.YieldTree,java.lang.Object)\",\n+                \"method: java.lang.Object com.sun.source.util.TreeScanner.visitYield(com.sun.source.tree.YieldTree,java.lang.Object)\"\n+        ));\n+\n+        LEGACY_PREVIEW_METHODS.put(\"14\", Set.of(\n+                \"module: jdk.jpackage\",\n+                \"class: javax.swing.plaf.basic.motif.MotifLookAndFeel\",\n+                \"field: jdk.jshell.Snippet.SubKind:RECORD_SUBKIND\",\n+                \"class: javax.lang.model.element.RecordComponentElement\",\n+                \"method: javax.lang.model.type.TypeMirror javax.lang.model.element.RecordComponentElement.asType()\",\n+                \"method: java.lang.Object javax.lang.model.element.ElementVisitor.visitRecordComponent(javax.lang.model.element.RecordComponentElement,java.lang.Object)\",\n+                \"class: javax.lang.model.util.ElementScanner14\",\n+                \"class: javax.lang.model.util.AbstractElementVisitor14\",\n+                \"class: javax.lang.model.util.SimpleElementVisitor14\",\n+                \"method: java.lang.Object javax.lang.model.util.ElementKindVisitor6.visitTypeAsRecord(javax.lang.model.element.TypeElement,java.lang.Object)\",\n+                \"class: javax.lang.model.util.ElementKindVisitor14\",\n+                \"method: javax.lang.model.element.RecordComponentElement javax.lang.model.util.Elements.recordComponentFor(javax.lang.model.element.ExecutableElement)\",\n+                \"method: java.util.List javax.lang.model.util.ElementFilter.recordComponentsIn(java.lang.Iterable)\",\n+                \"method: java.util.Set javax.lang.model.util.ElementFilter.recordComponentsIn(java.util.Set)\",\n+                \"method: java.util.List javax.lang.model.element.TypeElement.getRecordComponents()\",\n+                \"field: javax.lang.model.element.ElementKind:RECORD\",\n+                \"field: javax.lang.model.element.ElementKind:RECORD_COMPONENT\",\n+                \"field: javax.lang.model.element.ElementKind:BINDING_VARIABLE\",\n+                \"field: com.sun.source.tree.Tree.Kind:RECORD\",\n+                \"field: sun.reflect.annotation.TypeAnnotation.TypeAnnotationTarget:RECORD_COMPONENT\",\n+                \"class: java.lang.reflect.RecordComponent\",\n+                \"class: java.lang.runtime.ObjectMethods\",\n+                \"field: java.lang.annotation.ElementType:RECORD_COMPONENT\",\n+                \"method: boolean java.lang.Class.isRecord()\",\n+                \"method: java.lang.reflect.RecordComponent[] java.lang.Class.getRecordComponents()\",\n+                \"class: java.lang.Record\",\n+                \"interface: com.sun.source.tree.PatternTree\",\n+                \"field: com.sun.source.tree.Tree.Kind:BINDING_PATTERN\",\n+                \"method: com.sun.source.tree.PatternTree com.sun.source.tree.InstanceOfTree.getPattern()\",\n+                \"interface: com.sun.source.tree.BindingPatternTree\",\n+                \"method: java.lang.Object com.sun.source.tree.TreeVisitor.visitBindingPattern(com.sun.source.tree.BindingPatternTree,java.lang.Object)\"\n+        ));\n+\n+        LEGACY_PREVIEW_METHODS.put(\"15\", Set.of(\n+                \"module: jdk.jpackage\",\n+                \"field: jdk.jshell.Snippet.SubKind:RECORD_SUBKIND\",\n+                \"class: javax.lang.model.element.RecordComponentElement\",\n+                \"method: javax.lang.model.type.TypeMirror javax.lang.model.element.RecordComponentElement.asType()\",\n+                \"method: java.lang.Object javax.lang.model.element.ElementVisitor.visitRecordComponent(javax.lang.model.element.RecordComponentElement,java.lang.Object)\",\n+                \"class: javax.lang.model.util.ElementScanner14\",\n+                \"class: javax.lang.model.util.AbstractElementVisitor14\",\n+                \"class: javax.lang.model.util.SimpleElementVisitor14\",\n+                \"method: java.lang.Object javax.lang.model.util.ElementKindVisitor6.visitTypeAsRecord(javax.lang.model.element.TypeElement,java.lang.Object)\",\n+                \"class: javax.lang.model.util.ElementKindVisitor14\",\n+                \"method: javax.lang.model.element.RecordComponentElement javax.lang.model.util.Elements.recordComponentFor(javax.lang.model.element.ExecutableElement)\",\n+                \"method: java.util.List javax.lang.model.util.ElementFilter.recordComponentsIn(java.lang.Iterable)\",\n+                \"method: java.util.Set javax.lang.model.util.ElementFilter.recordComponentsIn(java.util.Set)\",\n+                \"method: java.util.List javax.lang.model.element.TypeElement.getRecordComponents()\",\n+                \"field: javax.lang.model.element.ElementKind:RECORD\",\n+                \"field: javax.lang.model.element.ElementKind:RECORD_COMPONENT\",\n+                \"field: javax.lang.model.element.ElementKind:BINDING_VARIABLE\",\n+                \"field: com.sun.source.tree.Tree.Kind:RECORD\",\n+                \"field: sun.reflect.annotation.TypeAnnotation.TypeAnnotationTarget:RECORD_COMPONENT\",\n+                \"class: java.lang.reflect.RecordComponent\",\n+                \"class: java.lang.runtime.ObjectMethods\",\n+                \"field: java.lang.annotation.ElementType:RECORD_COMPONENT\",\n+                \"class: java.lang.Record\",\n+                \"method: boolean java.lang.Class.isRecord()\",\n+                \"method: java.lang.reflect.RecordComponent[] java.lang.Class.getRecordComponents()\",\n+                \"field: javax.lang.model.element.Modifier:SEALED\",\n+                \"field: javax.lang.model.element.Modifier:NON_SEALED\",\n+                \"method: javax.lang.model.element.TypeElement:getPermittedSubclasses:()\",\n+                \"method: java.util.List com.sun.source.tree.ClassTree.getPermitsClause()\",\n+                \"method: boolean java.lang.Class.isSealed()\",\n+                \"method: java.lang.constant.ClassDesc[] java.lang.Class.permittedSubclasses()\",\n+                \"interface: com.sun.source.tree.PatternTree\",\n+                \"field: com.sun.source.tree.Tree.Kind:BINDING_PATTERN\",\n+                \"method: com.sun.source.tree.PatternTree com.sun.source.tree.InstanceOfTree.getPattern()\",\n+                \"interface: com.sun.source.tree.BindingPatternTree\",\n+                \"method: java.lang.Object com.sun.source.tree.TreeVisitor.visitBindingPattern(com.sun.source.tree.BindingPatternTree,java.lang.Object)\"\n+        ));\n+\n+        LEGACY_PREVIEW_METHODS.put(\"16\", Set.of(\n+                \"field: jdk.jshell.Snippet.SubKind:RECORD_SUBKIND\",\n+                \"field: javax.lang.model.element.Modifier:SEALED\",\n+                \"field: javax.lang.model.element.Modifier:NON_SEALED\",\n+                \"method: javax.lang.model.element.TypeElement:getPermittedSubclasses:()\",\n+                \"method: java.util.List com.sun.source.tree.ClassTree.getPermitsClause()\",\n+                \"method: boolean java.lang.Class.isSealed()\",\n+                \"method: java.lang.constant.ClassDesc[] java.lang.Class.permittedSubclasses()\"\n+        ));\n+\n+        \/\/ java.lang.foreign existed since JDK 19 and wasn't annotated - went out of preview in JDK 22\n+        LEGACY_PREVIEW_METHODS.put(\"19\", Set.of(\n+                \"package: java.lang.foreign\"\n+        ));\n+        LEGACY_PREVIEW_METHODS.put(\"20\", Set.of(\n+                \"package: java.lang.foreign\"\n+        ));\n+        LEGACY_PREVIEW_METHODS.put(\"21\", Set.of(\n+                \"package: java.lang.foreign\"\n+        ));\n+    }\n+\n+    \/**\n+     * Helper to find javadoc and resolve @inheritDoc and the effective since version.\n+     *\/\n+\n+    private final class EffectiveSourceSinceHelper implements AutoCloseable {\n+        private static final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        private final JavaFileManager baseFileManager;\n+        private final StandardJavaFileManager fm;\n+        private final Set<String> seenLookupElements = new HashSet<>();\n+        private final Map<String, Version> signature2Source = new HashMap<>();\n+        private final Map<String, String> signature2Location = new HashMap<>();\n+\n+        \/**\n+         * Create the helper.\n+         *\n+         * @param mainTask JavacTask from which the further Elements originate\n+         * @param sourceLocations paths where source files should be searched\n+         * @param validator enclosing class of the helper, typically the object invoking this method\n+         * @return a EffectiveSourceSinceHelper\n+         *\/\n+\n+        public static EffectiveSourceSinceHelper create(JavacTask mainTask, Collection<? extends Path> sourceLocations, SinceChecker validator) {\n+            StandardJavaFileManager fm = compiler.getStandardFileManager(null, null, null);\n+            try {\n+                fm.setLocationFromPaths(StandardLocation.MODULE_SOURCE_PATH, sourceLocations);\n+                return validator.new EffectiveSourceSinceHelper(mainTask, fm);\n+            } catch (IOException ex) {\n+                try {\n+                    fm.close();\n+                } catch (IOException closeEx) {\n+                    ex.addSuppressed(closeEx);\n+                }\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        private EffectiveSourceSinceHelper(JavacTask mainTask, StandardJavaFileManager fm) {\n+            this.baseFileManager = ((JavacTaskImpl) mainTask).getContext().get(JavaFileManager.class);\n+            this.fm = fm;\n+        }\n+\n+        public Version effectiveSinceVersion(Element owner, Element element, Types typeUtils, Elements elementUtils) {\n+            String handle = getElementName(owner, element, typeUtils);\n+            Version since = signature2Source.get(handle);\n+\n+            if (since == null) {\n+                try {\n+                    Element lookupElement = switch (element.getKind()) {\n+                        case MODULE, PACKAGE -> element;\n+                        default -> elementUtils.getOutermostTypeElement(element);\n+                    };\n+\n+                    if (lookupElement == null)\n+                        return null;\n+\n+                    String lookupHandle = getElementName(owner, element, typeUtils);\n+\n+                    if (!seenLookupElements.add(lookupHandle)) {\n+                        \/\/we've already processed this top-level, don't try to compute\n+                        \/\/the values again:\n+                        return null;\n+                    }\n+\n+                    Pair<JavacTask, CompilationUnitTree> source = findSource(lookupElement, elementUtils);\n+\n+                    if (source == null)\n+                        return null;\n+\n+                    fillElementCache(source.fst, source.snd, source.fst.getTypes(), source.fst.getElements());\n+                    since = signature2Source.get(handle);\n+\n+                } catch (IOException ex) {\n+                    error(\"JavadocHelper failed for \" + element);\n+                }\n+            }\n+\n+            return since;\n+        }\n+\n+        private String getElementPosition(String signature) {\n+            return signature2Location.getOrDefault(signature, \"\");\n+        }\n+\n+        \/\/where:\n+        private void fillElementCache(JavacTask task, CompilationUnitTree cut, Types typeUtils, Elements elementUtils) {\n+            Trees trees = Trees.instance(task);\n+            String fileName = cut.getSourceFile().getName();\n+\n+            new TreePathScanner<Void, Void>() {\n+                @Override\n+                public Void visitMethod(MethodTree node, Void p) {\n+                    handleDeclaration(node, fileName);\n+                    return null;\n+                }\n+\n+                @Override\n+                public Void visitClass(ClassTree node, Void p) {\n+                    handleDeclaration(node, fileName);\n+                    return super.visitClass(node, p);\n+                }\n+\n+                @Override\n+                public Void visitVariable(VariableTree node, Void p) {\n+                    handleDeclaration(node, fileName);\n+                    return null;\n+                }\n+\n+                @Override\n+                public Void visitModule(ModuleTree node, Void p) {\n+                    handleDeclaration(node, fileName);\n+                    return null;\n+                }\n+\n+                @Override\n+                public Void visitBlock(BlockTree node, Void p) {\n+                    return null;\n+                }\n+\n+                @Override\n+                public Void visitPackage(PackageTree node, Void p) {\n+                    if (cut.getSourceFile().isNameCompatible(\"package-info\", JavaFileObject.Kind.SOURCE)) {\n+                        handleDeclaration(node, fileName);\n+                    }\n+                    return super.visitPackage(node, p);\n+                }\n+\n+                private void handleDeclaration(Tree node, String fileName) {\n+                    Element currentElement = trees.getElement(getCurrentPath());\n+\n+                    if (currentElement != null) {\n+                        long startPosition = trees.getSourcePositions().getStartPosition(cut, node);\n+                        long lineNumber = cut.getLineMap().getLineNumber(startPosition);\n+                        String filePathWithLineNumber = String.format(\"src%s:%s \", fileName, lineNumber);\n+\n+                        signature2Source.put(getElementName(currentElement.getEnclosingElement(), currentElement, typeUtils), computeSinceVersion(currentElement, typeUtils, elementUtils));\n+                        signature2Location.put(getElementName(currentElement.getEnclosingElement(), currentElement, typeUtils), filePathWithLineNumber);\n+                    }\n+                }\n+            }.scan(cut, null);\n+        }\n+\n+        private Version computeSinceVersion(Element element, Types types,\n+                                            Elements elementUtils) {\n+            String docComment = elementUtils.getDocComment(element);\n+            Version version = null;\n+            if (docComment != null) {\n+                version = extractSinceVersionFromText(docComment);\n+            }\n+\n+            if (version != null) {\n+                return version; \/\/explicit @since has an absolute priority\n+            }\n+\n+            if (element.getKind() != ElementKind.MODULE) {\n+                version = effectiveSinceVersion(element.getEnclosingElement().getEnclosingElement(), element.getEnclosingElement(), types, elementUtils);\n+            }\n+\n+            return version;\n+        }\n+\n+        private Pair<JavacTask, CompilationUnitTree> findSource(Element forElement, Elements elementUtils) throws IOException {\n+            String moduleName = elementUtils.getModuleOf(forElement).getQualifiedName().toString();\n+            String binaryName = switch (forElement.getKind()) {\n+                case MODULE -> \"module-info\";\n+                case PACKAGE -> ((QualifiedNameable) forElement).getQualifiedName() + \".package-info\";\n+                default -> elementUtils.getBinaryName((TypeElement) forElement).toString();\n+            };\n+            Location packageLocationForModule = fm.getLocationForModule(StandardLocation.MODULE_SOURCE_PATH, moduleName);\n+            JavaFileObject jfo = fm.getJavaFileForInput(packageLocationForModule,\n+                    binaryName,\n+                    JavaFileObject.Kind.SOURCE);\n+\n+            if (jfo == null)\n+                return null;\n+\n+            List<JavaFileObject> jfos = Arrays.asList(jfo);\n+            JavaFileManager patchFM = moduleName != null\n+                    ? new PatchModuleFileManager(baseFileManager, jfo, moduleName)\n+                    : baseFileManager;\n+            JavacTaskImpl task = (JavacTaskImpl) compiler.getTask(null, patchFM, d -> {\n+            }, null, null, jfos);\n+            Iterable<? extends CompilationUnitTree> cuts = task.parse();\n+\n+            task.enter();\n+\n+            return Pair.of(task, cuts.iterator().next());\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            fm.close();\n+        }\n+\n+        \/**\n+         * Manages files within a patch module.\n+         * Provides custom behavior for handling file locations within a patch module.\n+         * Includes methods to specify module locations, infer module names and determine\n+         * if a location belongs to the patch module path.\n+         *\/\n+        private static final class PatchModuleFileManager\n+                extends ForwardingJavaFileManager<JavaFileManager> {\n+\n+            private final JavaFileObject file;\n+            private final String moduleName;\n+\n+            public PatchModuleFileManager(JavaFileManager fileManager,\n+                                          JavaFileObject file,\n+                                          String moduleName) {\n+                super(fileManager);\n+                this.file = file;\n+                this.moduleName = moduleName;\n+            }\n+\n+            @Override\n+            public Location getLocationForModule(Location location,\n+                                                 JavaFileObject fo) throws IOException {\n+                return fo == file\n+                        ? PATCH_LOCATION\n+                        : super.getLocationForModule(location, fo);\n+            }\n+\n+            @Override\n+            public String inferModuleName(Location location) throws IOException {\n+                return location == PATCH_LOCATION\n+                        ? moduleName\n+                        : super.inferModuleName(location);\n+            }\n+\n+            @Override\n+            public boolean hasLocation(Location location) {\n+                return location == StandardLocation.PATCH_MODULE_PATH ||\n+                        super.hasLocation(location);\n+            }\n+\n+            private static final Location PATCH_LOCATION = new Location() {\n+                @Override\n+                public String getName() {\n+                    return \"PATCH_LOCATION\";\n+                }\n+\n+                @Override\n+                public boolean isOutputLocation() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public boolean isModuleOrientedLocation() {\n+                    return false;\n+                }\n+            };\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/sincechecker\/SinceChecker.java","additions":948,"deletions":0,"binary":false,"changes":948,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331051\n+ * @summary Test for `@since` for java.base module\n+ * @library \/test\/lib\n+ *          \/test\/jdk\/tools\/sincechecker\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.compiler\/com.sun.tools.javac.code\n+ * @run main SinceChecker java.base --exclude java.lang.classfile\n+ *\/\n","filename":"test\/jdk\/tools\/sincechecker\/modules\/java_base\/CheckSince_javaBase.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -134,1 +134,1 @@\n-        map.put(\"docker.support\", this::dockerSupport);\n+        map.put(\"container.support\", this::containerSupport);\n@@ -588,1 +588,1 @@\n-     * A simple check for docker support\n+     * A simple check for container support\n@@ -590,1 +590,1 @@\n-     * @return true if docker is supported in a given environment\n+     * @return true if container is supported in a given environment\n@@ -592,2 +592,2 @@\n-    protected String dockerSupport() {\n-        log(\"Entering dockerSupport()\");\n+    protected String containerSupport() {\n+        log(\"Entering containerSupport()\");\n@@ -597,1 +597,1 @@\n-           \/\/ currently docker testing is only supported for Linux,\n+           \/\/ currently container testing is only supported for Linux,\n@@ -613,1 +613,1 @@\n-        log(\"dockerSupport(): platform check: isSupported = \" + isSupported);\n+        log(\"containerSupport(): platform check: isSupported = \" + isSupported);\n@@ -617,1 +617,1 @@\n-              isSupported = checkProgramSupport(\"checkDockerSupport()\", Container.ENGINE_COMMAND);\n+              isSupported = checkProgramSupport(\"checkContainerSupport()\", Container.ENGINE_COMMAND);\n@@ -623,1 +623,1 @@\n-        log(\"dockerSupport(): returning isSupported = \" + isSupported);\n+        log(\"containerSupport(): returning isSupported = \" + isSupported);\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -800,0 +800,46 @@\n+\n+    @Test\n+    public void testImportModuleNoModules(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          import module java.base;\n+                          public class Test {\n+                              List<String> l;\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> actualErrors = new JavacTask(tb)\n+            .options(\"--release\", \"8\",\n+                     \"-XDshould-stop.at=FLOW\",\n+                     \"-XDdev\",\n+                     \"-XDrawDiagnostics\")\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.FAIL)\n+            .writeAll()\n+            .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expectedErrors = List.of(\n+                \"- compiler.warn.option.obsolete.source: 8\",\n+                \"- compiler.warn.option.obsolete.target: 8\",\n+                \"- compiler.warn.option.obsolete.suppression\",\n+                \"Test.java:2:8: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.module.imports)\",\n+                \"Test.java:2:1: compiler.err.import.module.not.found: java.base\",\n+                \"Test.java:4:5: compiler.err.cant.resolve.location: kindname.class, List, , , (compiler.misc.location: kindname.class, test.Test, null)\",\n+                \"3 errors\",\n+                \"3 warnings\"\n+        );\n+\n+        if (!Objects.equals(expectedErrors, actualErrors)) {\n+            throw new AssertionError(\"Incorrect Output, expected: \" + expectedErrors +\n+                                      \", actual: \" + out);\n+\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/ImportModule.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"","filename":"test\/langtools\/tools\/javac\/generics\/parametricException\/ParametricException.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/tools\/javac\/generics\/ParametricException.java","status":"renamed"},{"patch":"","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/Serial.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/tools\/javac\/warnings\/Serial.java","status":"renamed"},{"patch":"","filename":"test\/langtools\/tools\/javac\/warnings\/Serial\/Serial.out","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/tools\/javac\/warnings\/Serial.out","status":"renamed"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +27,1 @@\n-    \/\/ Use this property to specify docker location on your system.\n+    \/\/ Use this property to specify container runtime location (e.g. docker) on your system.\n@@ -28,1 +29,1 @@\n-    \/\/ that it can be used in VMProps as well which checks docker support\n+    \/\/ that it can be used in VMProps as well which checks container support\n","filename":"test\/lib\/jdk\/test\/lib\/Container.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.ref;\n+\n+import java.lang.ref.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+public class ReferenceClear {\n+\n+    final Reference<Object> soft = new SoftReference<>(new Object());\n+    final Reference<Object> weak = new WeakReference<>(new Object());\n+    final Reference<Object> phantom = new PhantomReference<>(new Object(), null);\n+\n+    @Benchmark\n+    public void soft() {\n+       soft.clear();\n+    }\n+\n+    @Benchmark\n+    public void soft_new(Blackhole bh) {\n+       Object ref = new Object();\n+       bh.consume(ref);\n+       Reference<Object> soft = new SoftReference<>(ref);\n+       soft.clear();\n+    }\n+\n+    @Benchmark\n+    public void weak() {\n+       weak.clear();\n+    }\n+\n+    @Benchmark\n+    public void weak_new(Blackhole bh) {\n+       Object ref = new Object();\n+       bh.consume(ref);\n+       Reference<Object> weak = new WeakReference<>(ref);\n+       weak.clear();\n+    }\n+\n+    @Benchmark\n+    public void phantom() {\n+       phantom.clear();\n+    }\n+\n+    @Benchmark\n+    public void phantom_new(Blackhole bh) {\n+       Object ref = new Object();\n+       bh.consume(ref);\n+       Reference<Object> phantom = new PhantomReference<>(ref, null);\n+       phantom.clear();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ref\/ReferenceClear.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,251 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.Random;\n+import java.util.Arrays;\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class SelectFromBenchmark {\n+    @Param({\"1024\",\"2048\"})\n+    int size;\n+\n+    byte[] byteindex;\n+    byte[] bytesrc1;\n+    byte[] bytesrc2;\n+    byte[] byteres;\n+\n+    short[] shortindex;\n+    short[] shortsrc1;\n+    short[] shortsrc2;\n+    short[] shortres;\n+\n+    int[] intindex;\n+    int[] intsrc1;\n+    int[] intsrc2;\n+    int[] intres;\n+\n+    long[] longindex;\n+    long[] longsrc1;\n+    long[] longsrc2;\n+    long[] longres;\n+\n+    float[] floatindex;\n+    float[] floatsrc1;\n+    float[] floatsrc2;\n+    float[] floatres;\n+\n+    double[] doubleindex;\n+    double[] doublesrc1;\n+    double[] doublesrc2;\n+    double[] doubleres;\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        Random r = new Random(1024);\n+        byteindex = new byte[size];\n+        bytesrc1 = new byte[size];\n+        bytesrc2 = new byte[size];\n+        byteres = new byte[size];\n+\n+        shortindex = new short[size];\n+        shortsrc1 = new short[size];\n+        shortsrc2 = new short[size];\n+        shortres = new short[size];\n+\n+        intindex = new int[size];\n+        intsrc1 = new int[size];\n+        intsrc2 = new int[size];\n+        intres = new int[size];\n+\n+        longindex = new long[size];\n+        longsrc1 = new long[size];\n+        longsrc2 = new long[size];\n+        longres = new long[size];\n+\n+        floatindex = new float[size];\n+        floatsrc1 = new float[size];\n+        floatsrc2 = new float[size];\n+        floatres = new float[size];\n+\n+        doubleindex = new double[size];\n+        doublesrc1 = new double[size];\n+        doublesrc2 = new double[size];\n+        doubleres = new double[size];\n+\n+        Arrays.fill(bytesrc1, (byte)1);\n+        Arrays.fill(bytesrc2, (byte)2);\n+\n+        Arrays.fill(shortsrc1, (short)1);\n+        Arrays.fill(shortsrc2, (short)2);\n+\n+        Arrays.fill(intsrc1, 1);\n+        Arrays.fill(intsrc2, 2);\n+\n+        Arrays.fill(longsrc1, 1);\n+        Arrays.fill(longsrc2, 2);\n+\n+        Arrays.fill(floatsrc1, 1.0f);\n+        Arrays.fill(floatsrc2, 2.0f);\n+\n+        Arrays.fill(doublesrc1, 1.0);\n+        Arrays.fill(doublesrc2, 2.0);\n+\n+        for (int i = 0; i < size; i++) {\n+            byteindex[i] = (byte)((ByteVector.SPECIES_PREFERRED.length() - 1) & i);\n+            shortindex[i] = (short)((ShortVector.SPECIES_PREFERRED.length() - 1) & i);\n+            intindex[i] = (int)((IntVector.SPECIES_PREFERRED.length() - 1) & i);\n+            longindex[i] = (long)((LongVector.SPECIES_PREFERRED.length() - 1) & i);\n+            floatindex[i] = (float)((FloatVector.SPECIES_PREFERRED.length() - 1) & i);\n+            doubleindex[i] = (double)((DoubleVector.SPECIES_PREFERRED.length() - 1) & i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void selectFromByteVector() {\n+        for (int j = 0; j < size; j += ByteVector.SPECIES_PREFERRED.length()) {\n+            ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, byteindex, j)\n+                .selectFrom(ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, bytesrc1, j),\n+                            ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, bytesrc2, j))\n+                .intoArray(byteres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void rearrangeFromByteVector() {\n+        for (int j = 0; j < size; j += ByteVector.SPECIES_PREFERRED.length()) {\n+            ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, bytesrc1, j)\n+                .rearrange(ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, byteindex, j).toShuffle(),\n+                           ByteVector.fromArray(ByteVector.SPECIES_PREFERRED, bytesrc2, j))\n+                .intoArray(byteres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void selectFromShortVector() {\n+        for (int j = 0; j < size; j += ShortVector.SPECIES_PREFERRED.length()) {\n+            ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortindex, j)\n+                .selectFrom(ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortsrc1, j),\n+                            ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortsrc2, j))\n+                .intoArray(shortres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void rearrangeFromShortVector() {\n+        for (int j = 0; j < size; j += ShortVector.SPECIES_PREFERRED.length()) {\n+            ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortsrc1, j)\n+                .rearrange(ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortindex, j).toShuffle(),\n+                           ShortVector.fromArray(ShortVector.SPECIES_PREFERRED, shortsrc2, j))\n+                .intoArray(shortres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void selectFromIntVector() {\n+        for (int j = 0; j < size; j += IntVector.SPECIES_PREFERRED.length()) {\n+            IntVector.fromArray(IntVector.SPECIES_PREFERRED, intindex, j)\n+                .selectFrom(IntVector.fromArray(IntVector.SPECIES_PREFERRED, intsrc1, j),\n+                            IntVector.fromArray(IntVector.SPECIES_PREFERRED, intsrc2, j))\n+                .intoArray(intres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void rearrangeFromIntVector() {\n+        for (int j = 0; j < size; j += IntVector.SPECIES_PREFERRED.length()) {\n+            IntVector.fromArray(IntVector.SPECIES_PREFERRED, intsrc1, j)\n+                .rearrange(IntVector.fromArray(IntVector.SPECIES_PREFERRED, intindex, j).toShuffle(),\n+                           IntVector.fromArray(IntVector.SPECIES_PREFERRED, intsrc2, j))\n+                .intoArray(intres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void selectFromLongVector() {\n+        for (int j = 0; j < size; j += LongVector.SPECIES_PREFERRED.length()) {\n+            LongVector.fromArray(LongVector.SPECIES_PREFERRED, longindex, j)\n+                .selectFrom(LongVector.fromArray(LongVector.SPECIES_PREFERRED, longsrc1, j),\n+                            LongVector.fromArray(LongVector.SPECIES_PREFERRED, longsrc2, j))\n+                .intoArray(longres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void rearrangeFromLongVector() {\n+        for (int j = 0; j < size; j += LongVector.SPECIES_PREFERRED.length()) {\n+            LongVector.fromArray(LongVector.SPECIES_PREFERRED, longsrc1, j)\n+                .rearrange(LongVector.fromArray(LongVector.SPECIES_PREFERRED, longindex, j).toShuffle(),\n+                           LongVector.fromArray(LongVector.SPECIES_PREFERRED, longsrc2, j))\n+                .intoArray(longres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void selectFromFloatVector() {\n+        for (int j = 0; j < size; j += FloatVector.SPECIES_PREFERRED.length()) {\n+            FloatVector.fromArray(FloatVector.SPECIES_PREFERRED, floatindex, j)\n+                .selectFrom(FloatVector.fromArray(FloatVector.SPECIES_PREFERRED, floatsrc1, j),\n+                            FloatVector.fromArray(FloatVector.SPECIES_PREFERRED, floatsrc2, j))\n+                .intoArray(floatres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void rearrangeFromFloatVector() {\n+        for (int j = 0; j < size; j += FloatVector.SPECIES_PREFERRED.length()) {\n+            FloatVector.fromArray(FloatVector.SPECIES_PREFERRED, floatsrc1, j)\n+                .rearrange(FloatVector.fromArray(FloatVector.SPECIES_PREFERRED, floatindex, j).toShuffle(),\n+                           FloatVector.fromArray(FloatVector.SPECIES_PREFERRED, floatsrc2, j))\n+                .intoArray(floatres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void selectFromDoubleVector() {\n+        for (int j = 0; j < size; j += DoubleVector.SPECIES_PREFERRED.length()) {\n+            DoubleVector.fromArray(DoubleVector.SPECIES_PREFERRED, doubleindex, j)\n+                .selectFrom(DoubleVector.fromArray(DoubleVector.SPECIES_PREFERRED, doublesrc1, j),\n+                            DoubleVector.fromArray(DoubleVector.SPECIES_PREFERRED, doublesrc2, j))\n+                .intoArray(doubleres, j);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void rearrangeFromDoubleVector() {\n+        for (int j = 0; j < size; j += DoubleVector.SPECIES_PREFERRED.length()) {\n+            DoubleVector.fromArray(DoubleVector.SPECIES_PREFERRED, doublesrc1, j)\n+                .rearrange(DoubleVector.fromArray(DoubleVector.SPECIES_PREFERRED, doubleindex, j).toShuffle(),\n+                           DoubleVector.fromArray(DoubleVector.SPECIES_PREFERRED, doublesrc2, j))\n+                .intoArray(doubleres, j);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/SelectFromBenchmark.java","additions":251,"deletions":0,"binary":false,"changes":251,"status":"added"}]}