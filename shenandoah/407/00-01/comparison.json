{"files":[{"patch":"@@ -434,1 +434,3 @@\n-  if (active_generation() == nullptr) {\n+  ShenandoahGeneration* const gen = active_generation();\n+\n+  if (gen == nullptr) {\n@@ -441,3 +443,4 @@\n-  assert((active_generation() == (ShenandoahGeneration*) old_generation()) ||\n-         (active_generation() == (ShenandoahGeneration*) young_generation()) ||\n-         (active_generation() == global_generation()), \"Active generation must be old, young, or global\");\n+  assert(gen == (ShenandoahGeneration*)old_generation() ||\n+         gen == (ShenandoahGeneration*)young_generation() ||\n+         gen == (ShenandoahGeneration*)global_generation(),\n+         \"Active generation must be old, young, or global\");\n@@ -446,0 +449,15 @@\n+\n+#ifdef ASSERT\n+  ShenandoahGeneration* const gen_again = active_generation();\n+  \/\/ The following assertion:\n+  \/\/ assert(gen == gen_again, \"Race\");\n+  \/\/ checks that the value of active_generation()\n+  \/\/ doesn't change while executing in this method. However,\n+  \/\/ it won't hold when a ShenandoahGCScope is exited by the\n+  \/\/ ControlThread asynchronously wrt mutators that may be executing\n+  \/\/ executing barriers. This race is benign when we are a mutator\n+  \/\/ thread that sees the active_generation() flicker below.\n+  assert(gen == gen_again || (gen_again == nullptr && Thread::current()->is_Java_thread()),\n+         \"Not a benign race\");\n+#endif\n+\n@@ -452,1 +470,1 @@\n-    return (active_generation() != (ShenandoahGeneration*) old_generation());\n+    return gen != (ShenandoahGeneration*)old_generation();\n@@ -455,1 +473,1 @@\n-    return (active_generation() != (ShenandoahGeneration*) young_generation());\n+    return gen != (ShenandoahGeneration*)young_generation();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"}]}