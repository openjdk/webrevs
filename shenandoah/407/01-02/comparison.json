{"files":[{"patch":"@@ -931,0 +931,4 @@\n+      \/\/ YSR TODO: This needs to be thought through carefully; in many of these\n+      \/\/ cases, it makes more sense to place the state in the closure rather than\n+      \/\/ do the async\/snapshot field split we are doing with _gc_generation() and\n+      \/\/ _active_generation().\n@@ -1054,0 +1058,3 @@\n+  \/\/ We can only toggle concurrent_weak_root_in_progress flag\n+  \/\/ at a safepoint, so that mutators see a consistent\n+  \/\/ value. The flag will be cleared at the next safepoint.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -66,1 +66,5 @@\n-    ShenandoahReferenceProcessor* rp = heap->active_generation()->ref_processor();\n+    \/\/ Do not use active_generation() : we must use the gc_generation() set by\n+    \/\/ ShenandoahGCScope on the ControllerThread's stack; no safepoint may\n+    \/\/ intervene to update active_generation, so we can't\n+    \/\/ assert_generations_reconciled() here.\n+    ShenandoahReferenceProcessor* rp = heap->gc_generation()->ref_processor();\n@@ -114,1 +118,2 @@\n-    ShenandoahReferenceProcessor* rp = heap->active_generation()->ref_processor();\n+    ShenandoahReferenceProcessor* rp = heap->gc_generation()->ref_processor();\n+    heap->assert_generations_reconciled();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+  set_thread();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,13 @@\n+Thread* ShenandoahController::_thread = nullptr;\n+\n+Thread* ShenandoahController::thread() {\n+  assert(_thread != nullptr, \"None started\");\n+  return _thread;\n+}\n+\n+void ShenandoahController::set_thread() {\n+  assert(_thread == nullptr, \"Only once!\");\n+  _thread = Thread::current();\n+  assert(_thread->is_ConcurrentGC_thread(), \"Error\");\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+  static Thread* _thread;\n@@ -57,0 +58,2 @@\n+  static void set_thread();\n+\n@@ -66,0 +69,2 @@\n+  static Thread* thread();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+  set_thread();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -134,1 +134,2 @@\n-    assert(_heap->active_generation()->is_mark_complete(), \"sanity\");\n+    assert(_heap->gc_generation()->is_mark_complete(), \"sanity\");\n+    _heap->assert_generations_reconciled();\n@@ -217,1 +218,2 @@\n-  assert(_heap->active_generation()->is_mark_complete(), \"sanity\");\n+  assert(_heap->gc_generation()->is_mark_complete(), \"sanity\");\n+  _heap->assert_generations_reconciled();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+  heap->set_active_generation();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-  if (active_generation()->is_young() && target_gen == YOUNG_GENERATION) {\n+  if (gc_generation()->is_young() && target_gen == YOUNG_GENERATION) {\n@@ -749,0 +749,1 @@\n+\n@@ -761,1 +762,3 @@\n-    assert(_heap->active_generation()->is_mark_complete(), \"Expected complete marking\");\n+    ShenandoahGeneration* const gc_generation = _heap->gc_generation();\n+    _heap->assert_generations_reconciled();\n+    assert(gc_generation->is_mark_complete(), \"Expected complete marking\");\n@@ -775,1 +778,1 @@\n-          if (_heap->active_generation()->is_global()) {\n+          if (gc_generation->is_global()) {\n@@ -812,1 +815,1 @@\n-    if (!_heap->active_generation()->is_global()) {\n+    if (!gc_generation->is_global()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -561,0 +561,1 @@\n+  _active_generation(nullptr),\n@@ -1575,0 +1576,25 @@\n+void ShenandoahHeap::set_gc_generation(ShenandoahGeneration* generation) {\n+  _gc_generation = generation;\n+  assert(Thread::current() == ShenandoahController::thread() ||\n+         (SafepointSynchronize::is_at_safepoint() && Thread::current()->is_VM_thread()),\n+         \"Unexpected thread or condition\");\n+}\n+\n+\/\/ Active generation may only be set by the VM thread at a safepoint.\n+void ShenandoahHeap::set_active_generation() {\n+  assert(Thread::current()->is_VM_thread(), \"Only the VM Thread\");\n+  assert(SafepointSynchronize::is_at_safepoint(), \"Only at a safepoint!\");\n+  _active_generation = _gc_generation;\n+}\n+\n+#ifndef PRODUCT\n+void ShenandoahHeap::assert_generations_reconciled() {\n+  if (SafepointSynchronize::is_at_safepoint()) {\n+    ShenandoahGeneration* ggen = gc_generation();\n+    ShenandoahGeneration* agen = active_generation();\n+    assert(agen == ggen, \"active_gen(%d) should be reconciled with gc_gen(%d)at safepoint\",\n+           agen->type(), ggen->type());\n+  }\n+}\n+#endif\n+\n@@ -1578,7 +1604,2 @@\n-#ifdef ASSERT\n-  GCCause::Cause prev_cause = gc_cause();\n-  assert(prev_cause == GCCause::_no_gc, \"Over-writing cause\");\n-\n-  ShenandoahGeneration* prev_gen = active_generation();\n-  assert(prev_gen == nullptr, \"Over-writing _gc_generation\");\n-#endif \/\/ ASSERT\n+  assert(gc_cause()  == GCCause::_no_gc, \"Over-writing cause\");\n+  assert(_gc_generation == nullptr, \"Over-writing _gc_generation\");\n@@ -1594,1 +1615,1 @@\n-  assert(active_generation() != nullptr, \"_gc_generation wasn't set\");\n+  assert(_gc_generation != nullptr, \"_gc_generation wasn't set\");\n@@ -1602,0 +1623,1 @@\n+\n@@ -1955,1 +1977,2 @@\n-  active_generation()->ref_processor()->process_references(phase, workers(), false \/* concurrent *\/);\n+  assert_generations_reconciled();\n+  gc_generation()->ref_processor()->process_references(phase, workers(), false \/* concurrent *\/);\n@@ -1987,0 +2010,3 @@\n+  \/\/ Check that if concurrent weak root is set then active_gen isn't null\n+  assert(!is_concurrent_weak_root_in_progress() || active_generation() != nullptr, \"Error\");\n+  assert_generations_reconciled();\n@@ -2280,1 +2306,2 @@\n-    if (active_generation()->contains(r)) {\n+    assert_generations_reconciled();\n+    if (gc_generation()->contains(r)) {\n@@ -2460,1 +2487,1 @@\n-    ShenandoahFinalUpdateRefsUpdateRegionStateClosure cl (active_generation()->complete_marking_context());\n+    ShenandoahFinalUpdateRefsUpdateRegionStateClosure cl (gc_generation()->complete_marking_context());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":38,"deletions":11,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -154,0 +154,3 @@\n+\n+  \/\/ Indicates the generation whose collection is in\n+  \/\/ proress\n@@ -156,0 +159,8 @@\n+  \/\/ This is set and cleared by only the VMThread\n+  \/\/ at each STW pause (safepoint) to the value seen in\n+  \/\/ _gc_generation. This allows the value to be always consistently\n+  \/\/ seen by all mutators as well as all GC worker threads.\n+  \/\/ In that sense, it's a stable snapshot of _gc_generation that is\n+  \/\/ updated at each STW pause associated with a ShenandoahVMOp.\n+  ShenandoahGeneration* _active_generation;\n+\n@@ -161,2 +172,2 @@\n-  ShenandoahGeneration* active_generation() const {\n-    \/\/ last or latest generation might be a better name here.\n+  ShenandoahGeneration* gc_generation() const {\n+    \/\/ value of _gc_generation field, see above\n@@ -166,2 +177,3 @@\n-  void set_gc_generation(ShenandoahGeneration* generation) {\n-    _gc_generation = generation;\n+  ShenandoahGeneration* active_generation() const {\n+    \/\/ value of _active_generation field, see above\n+    return _active_generation;\n@@ -170,0 +182,12 @@\n+  \/\/ Set the _gc_generation field\n+  void set_gc_generation(ShenandoahGeneration* generation);\n+\n+  \/\/ Copy the value in the _gc_generation field into\n+  \/\/ the _active_generation field: can only be called at\n+  \/\/ a safepoint by the VMThread.\n+  void set_active_generation();\n+\n+  \/\/ Some limited sanity checking of the _gc_generation and\n+  \/\/ _active_generation fields\n+  void assert_generations_reconciled() PRODUCT_RETURN;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":28,"deletions":4,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -363,0 +363,1 @@\n+    assert(is_in(obj), \"Otherwise shouldn't return true below\");\n@@ -369,1 +370,1 @@\n-    \/\/ no collection is happening, only expect this to be called\n+    \/\/ no collection is happening: only expect this to be called\n@@ -382,13 +383,2 @@\n-#ifdef ASSERT\n-  ShenandoahGeneration* const gen_again = active_generation();\n-  \/\/ The following assertion:\n-  \/\/ assert(gen == gen_again, \"Race\");\n-  \/\/ checks that the value of active_generation()\n-  \/\/ doesn't change while executing in this method. However,\n-  \/\/ it won't hold when a ShenandoahGCScope is exited by the\n-  \/\/ ControlThread asynchronously wrt mutators that may be executing\n-  \/\/ executing barriers. This race is benign when we are a mutator\n-  \/\/ thread that sees the active_generation() flicker below.\n-  assert(gen == gen_again || (gen_again == nullptr && Thread::current()->is_Java_thread()),\n-         \"Not a benign race\");\n-#endif\n+  \/\/ No flickering!\n+  assert(gen == active_generation(), \"Race?\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -321,1 +321,2 @@\n-  assert(ShenandoahHeap::heap()->active_generation()->is_mark_complete(), \"Marking should be complete here.\");\n+  assert(ShenandoahHeap::heap()->gc_generation()->is_mark_complete(), \"Marking should be complete here.\");\n+  ShenandoahHeap::heap()->assert_generations_reconciled();\n@@ -471,1 +472,2 @@\n-  assert(heap->active_generation()->is_mark_complete(), \"sanity\");\n+  assert(heap->gc_generation()->is_mark_complete(), \"sanity\");\n+  heap->assert_generations_reconciled();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -152,2 +152,6 @@\n-  assert(heap->active_generation()->type() == GENERATION, \"Sanity\");\n-  heap->active_generation()->ref_processor()->set_mark_closure(worker_id, cl);\n+  \/\/ Do not use active_generation() : we must use the gc_generation() set by\n+  \/\/ ShenandoahGCScope on the ControllerThread's stack; no safepoint may\n+  \/\/ intervene to update active_generation, so we can't\n+  \/\/ assert_generations_reconciled() here.\n+  assert(heap->gc_generation()->type() == GENERATION, \"Sanity: %d != %d\", heap->gc_generation()->type(), GENERATION);\n+  heap->gc_generation()->ref_processor()->set_mark_closure(worker_id, cl);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -107,1 +107,2 @@\n-  ShenandoahReferenceProcessor* rp = heap->active_generation()->ref_processor();\n+  ShenandoahReferenceProcessor* rp = heap->gc_generation()->ref_processor();\n+  assert(heap->gc_generation() == heap->active_generation(), \"Should be identical at stw phases\");\n@@ -175,1 +176,3 @@\n-  ShenandoahReferenceProcessor* rp = ShenandoahHeap::heap()->active_generation()->ref_processor();\n+  ShenandoahReferenceProcessor* rp = ShenandoahHeap::heap()->gc_generation()->ref_processor();\n+  assert(ShenandoahHeap::heap()->gc_generation() == ShenandoahHeap::heap()->active_generation(),\n+         \"Should be identical at stw phases\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"logging\/log.hpp\"\n@@ -40,0 +41,1 @@\n+  log_active_generation(\"Prologue\");\n@@ -45,0 +47,1 @@\n+  log_active_generation(\"Epilogue\");\n@@ -48,0 +51,15 @@\n+void VM_ShenandoahOperation::log_active_generation(const char* prefix) {\n+  ShenandoahGeneration* agen = ShenandoahHeap::heap()->active_generation();\n+  ShenandoahGeneration* ggen = ShenandoahHeap::heap()->gc_generation();\n+  log_debug(gc, heap)(\"%s: active_generation is %s, gc_generation is %s\", prefix,\n+                      agen == nullptr ? \"nullptr\" : shenandoah_generation_name(agen->type()),\n+                      ggen == nullptr ? \"nullptr\" : shenandoah_generation_name(ggen->type()));\n+}\n+\n+void VM_ShenandoahOperation::set_active_generation() {\n+  if (evaluate_at_safepoint()) {\n+    assert(SafepointSynchronize::is_at_safepoint(), \"Error??\");\n+    ShenandoahHeap::heap()->set_active_generation();\n+  }\n+}\n+\n@@ -65,0 +83,1 @@\n+  set_active_generation();\n@@ -71,0 +90,1 @@\n+  set_active_generation();\n@@ -77,0 +97,1 @@\n+  set_active_generation();\n@@ -83,0 +104,1 @@\n+  set_active_generation();\n@@ -89,0 +111,1 @@\n+  set_active_generation();\n@@ -95,0 +118,1 @@\n+  set_active_generation();\n@@ -101,0 +125,1 @@\n+  set_active_generation();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+\/\/   - VM_ShenandoahFinalRoots\n@@ -47,1 +48,3 @@\n-  uint         _gc_id;\n+  uint _gc_id;\n+\n+  void set_active_generation();\n@@ -51,0 +54,2 @@\n+\n+  void log_active_generation(const char* prefix);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-      _generation = _heap->active_generation();\n+      _generation = _heap->gc_generation();\n@@ -99,0 +99,1 @@\n+      _heap->assert_generations_reconciled();\n@@ -192,1 +193,1 @@\n-                (obj_reg->is_old() && _heap->active_generation()->is_young()),\n+                (obj_reg->is_old() && _heap->gc_generation()->is_young()),\n@@ -194,0 +195,1 @@\n+          _heap->assert_generations_reconciled();\n@@ -637,1 +639,1 @@\n-      _generation = _heap->active_generation();\n+      _generation = _heap->gc_generation();\n@@ -639,0 +641,1 @@\n+      _heap->assert_generations_reconciled();\n@@ -878,1 +881,1 @@\n-    generation = _heap->active_generation();\n+    generation = _heap->gc_generation();\n@@ -880,0 +883,1 @@\n+    _heap->assert_generations_reconciled();\n@@ -1352,1 +1356,2 @@\n-  if (old_generation->is_mark_complete() || _heap->active_generation()->is_global()) {\n+  _heap->assert_generations_reconciled();\n+  if (old_generation->is_mark_complete() || _heap->gc_generation()->is_global()) {\n@@ -1432,1 +1437,2 @@\n-  if (_heap->old_generation()->is_mark_complete() || _heap->active_generation()->is_global()) {\n+  _heap->assert_generations_reconciled();\n+  if (_heap->old_generation()->is_mark_complete() || _heap->gc_generation()->is_global()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+                    \/\/ \"-XX:+UnlockExperimentalVMOptions\", \"-XX:ShenandoahNoProgressThreshold=12\", \"-XX:+ShowMessageBoxOnError\",\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestThreadFailure.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}