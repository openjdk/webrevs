{"files":[{"patch":"@@ -445,0 +445,1 @@\n+      ShenandoahGCSession session(cause, old_generation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2103,0 +2103,8 @@\n+#ifdef ASSERT\n+  GCCause::Cause prev_cause = gc_cause();\n+  assert(prev_cause == GCCause::_no_gc, \"Over-writing cause\");\n+\n+  ShenandoahGeneration* prev_gen = active_generation();\n+  assert(prev_gen == nullptr, \"Over-writing _gc_generation\");\n+#endif \/\/ ASSERT\n+\n@@ -2110,0 +2118,3 @@\n+  assert(gc_cause() != GCCause::_no_gc, \"cause wasn't set\");\n+  assert(active_generation() != nullptr, \"_gc_generation wasn't set\");\n+\n@@ -2116,0 +2127,1 @@\n+  set_gc_generation(nullptr);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -434,1 +434,3 @@\n-  if (active_generation() == nullptr) {\n+  ShenandoahGeneration* const gen = active_generation();\n+\n+  if (gen == nullptr) {\n@@ -441,3 +443,4 @@\n-  assert((active_generation() == (ShenandoahGeneration*) old_generation()) ||\n-         (active_generation() == (ShenandoahGeneration*) young_generation()) ||\n-         (active_generation() == global_generation()), \"Active generation must be old, young, or global\");\n+  assert(gen == (ShenandoahGeneration*)old_generation() ||\n+         gen == (ShenandoahGeneration*)young_generation() ||\n+         gen == (ShenandoahGeneration*)global_generation(),\n+         \"Active generation must be old, young, or global\");\n@@ -446,0 +449,15 @@\n+\n+#ifdef ASSERT\n+  ShenandoahGeneration* const gen_again = active_generation();\n+  \/\/ The following assertion:\n+  \/\/ assert(gen == gen_again, \"Race\");\n+  \/\/ checks that the value of active_generation()\n+  \/\/ doesn't change while executing in this method. However,\n+  \/\/ it won't hold when a ShenandoahGCScope is exited by the\n+  \/\/ ControlThread asynchronously wrt mutators that may be executing\n+  \/\/ executing barriers. This race is benign when we are a mutator\n+  \/\/ thread that sees the active_generation() flicker below.\n+  assert(gen == gen_again || (gen_again == nullptr && Thread::current()->is_Java_thread()),\n+         \"Not a benign race\");\n+#endif\n+\n@@ -452,1 +470,1 @@\n-    return (active_generation() != (ShenandoahGeneration*) old_generation());\n+    return gen != (ShenandoahGeneration*)old_generation();\n@@ -455,1 +473,1 @@\n-    return (active_generation() != (ShenandoahGeneration*) young_generation());\n+    return gen != (ShenandoahGeneration*)young_generation();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"}]}