{"files":[{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -32,0 +33,1 @@\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n@@ -40,0 +42,32 @@\n+<<<<<<< HEAD\n+=======\n+template<ShenandoahGenerationType GENERATION>\n+class ShenandoahInitMarkRootsClosure : public OopClosure {\n+private:\n+  ShenandoahObjToScanQueue* const _queue;\n+  ShenandoahMarkingContext* const _mark_context;\n+\n+  template <class T>\n+  inline void do_oop_work(T* p);\n+\n+public:\n+  ShenandoahInitMarkRootsClosure(ShenandoahObjToScanQueue* q);\n+\n+  void do_oop(narrowOop* p) { do_oop_work(p); }\n+  void do_oop(oop* p)       { do_oop_work(p); }\n+};\n+\n+template <ShenandoahGenerationType GENERATION>\n+ShenandoahInitMarkRootsClosure<GENERATION>::ShenandoahInitMarkRootsClosure(ShenandoahObjToScanQueue* q) :\n+  _queue(q),\n+  _mark_context(ShenandoahHeap::heap()->marking_context()) {\n+}\n+\n+template <ShenandoahGenerationType GENERATION>\n+template <class T>\n+void ShenandoahInitMarkRootsClosure<GENERATION>::do_oop_work(T* p) {\n+  \/\/ Only called from STW mark, should not be used to bootstrap old generation marking.\n+  ShenandoahMark::mark_through_ref<T, GENERATION>(p, _queue, nullptr, _mark_context, false);\n+}\n+\n+>>>>>>> 3d485ceca843ca17dd70cacb35cda98bbbdd58b5\n@@ -60,2 +94,2 @@\n-ShenandoahSTWMark::ShenandoahSTWMark(bool full_gc) :\n-  ShenandoahMark(),\n+ShenandoahSTWMark::ShenandoahSTWMark(ShenandoahGeneration* generation, bool full_gc) :\n+  ShenandoahMark(generation),\n@@ -63,1 +97,1 @@\n-  _terminator(ShenandoahHeap::heap()->workers()->active_workers(), ShenandoahHeap::heap()->marking_context()->task_queues()),\n+  _terminator(ShenandoahHeap::heap()->workers()->active_workers(), task_queues()),\n@@ -76,1 +110,2 @@\n-  ShenandoahReferenceProcessor* rp = heap->ref_processor();\n+  ShenandoahReferenceProcessor* rp = heap->gc_generation()->ref_processor();\n+  shenandoah_assert_generations_reconciled();\n@@ -95,0 +130,5 @@\n+    if (_generation->is_young()) {\n+      \/\/ But only scan the remembered set for young generation.\n+      _generation->scan_remembered_set(false \/* is_concurrent *\/);\n+    }\n+\n@@ -102,1 +142,1 @@\n-  heap->mark_complete_marking_context();\n+  _generation->set_mark_complete();\n@@ -113,0 +153,1 @@\n+<<<<<<< HEAD\n@@ -116,0 +157,22 @@\n+=======\n+  switch (_generation->type()) {\n+    case NON_GEN: {\n+      ShenandoahInitMarkRootsClosure<NON_GEN> init_mark(task_queues()->queue(worker_id));\n+      _root_scanner.roots_do(&init_mark, worker_id);\n+      break;\n+    }\n+    case GLOBAL: {\n+      ShenandoahInitMarkRootsClosure<GLOBAL> init_mark(task_queues()->queue(worker_id));\n+      _root_scanner.roots_do(&init_mark, worker_id);\n+      break;\n+    }\n+    case YOUNG: {\n+      ShenandoahInitMarkRootsClosure<YOUNG> init_mark(task_queues()->queue(worker_id));\n+      _root_scanner.roots_do(&init_mark, worker_id);\n+      break;\n+    }\n+    case OLD:\n+    default:\n+      ShouldNotReachHere();\n+  }\n+>>>>>>> 3d485ceca843ca17dd70cacb35cda98bbbdd58b5\n@@ -121,1 +184,2 @@\n-  ShenandoahReferenceProcessor* rp = ShenandoahHeap::heap()->ref_processor();\n+  ShenandoahReferenceProcessor* rp = ShenandoahHeap::heap()->gc_generation()->ref_processor();\n+  shenandoah_assert_generations_reconciled();\n@@ -124,1 +188,2 @@\n-  mark_loop(worker_id, &_terminator, rp, NON_GEN, false \/* not cancellable *\/,\n+  mark_loop(worker_id, &_terminator, rp,\n+            _generation->type(), false \/* not cancellable *\/,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":72,"deletions":7,"binary":false,"changes":79,"status":"modified"}]}