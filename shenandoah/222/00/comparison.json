{"files":[{"patch":"@@ -31,1 +31,0 @@\n-#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n@@ -343,22 +342,0 @@\n-  \/\/ Allocation spikes are a characteristic of both the application ahd the JVM configuration.  On the JVM command line,\n-  \/\/ the application developer may want to supply a hint of the nature of spikes that are inherent in the application\n-  \/\/ workload, and this information would normally be independent of heap size (not a percentage thereof).  On the\n-  \/\/ other hand, some allocation spikes are correlated with JVM configuration.  For example, there are allocation\n-  \/\/ spikes at the starts of concurrent marking and evacuation to refresh all local allocation buffers.  The nature\n-  \/\/ of these spikes is determined by LAB min and max sizes and numbers of threads, but also on frequency of GC passes,\n-  \/\/ and on \"periodic\" behavior of these threads  If GC frequency is much higher than the periodic trigger for mutator\n-  \/\/ threads, then many of the mutator threads may be able to \"sit out\" of most GC passes.  Though the thread's stack\n-  \/\/ must be scanned, the thread does not need to refresh its LABs if it sits idle throughout the duration of the GC\n-  \/\/ pass.  The best prediction for this aspect of spikes in allocation patterns is probably recent past history.\n-  \/\/ TODO: and dive deeper into _gc_time_penalties as this may also need to be corrected\n-\n-  \/\/ Check if allocation headroom is still okay. This also factors in:\n-  \/\/   1. Some space to absorb allocation spikes (ShenandoahAllocSpikeFactor)\n-  \/\/   2. Accumulated penalties from Degenerated and Full GC\n-  size_t allocation_headroom = available;\n-  size_t spike_headroom = capacity \/ 100 * ShenandoahAllocSpikeFactor;\n-  size_t penalties      = capacity \/ 100 * _gc_time_penalties;\n-\n-  allocation_headroom -= MIN2(allocation_headroom, penalties);\n-  allocation_headroom -= MIN2(allocation_headroom, spike_headroom);\n-\n@@ -374,1 +351,1 @@\n-                 byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom),\n+                 byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n@@ -386,1 +363,1 @@\n-                   byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom),\n+                   byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n@@ -431,0 +408,10 @@\n+  \/\/ Check if allocation headroom is still okay. This also factors in:\n+  \/\/   1. Some space to absorb allocation spikes (ShenandoahAllocSpikeFactor)\n+  \/\/   2. Accumulated penalties from Degenerated and Full GC\n+  size_t allocation_headroom = available;\n+  size_t spike_headroom = capacity \/ 100 * ShenandoahAllocSpikeFactor;\n+  size_t penalties      = capacity \/ 100 * _gc_time_penalties;\n+\n+  allocation_headroom -= MIN2(allocation_headroom, penalties);\n+  allocation_headroom -= MIN2(allocation_headroom, spike_headroom);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":12,"deletions":25,"binary":false,"changes":37,"status":"modified"}]}