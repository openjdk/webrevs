{"files":[{"patch":"@@ -209,1 +209,1 @@\n-      _old_generation->transition_to(ShenandoahOldGeneration::WAITING_FOR_FILL);\n+      _old_generation->transition_to(ShenandoahOldGeneration::FILLING);\n@@ -211,1 +211,1 @@\n-      _old_generation->transition_to(ShenandoahOldGeneration::IDLE);\n+      _old_generation->transition_to(ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP);\n@@ -221,1 +221,1 @@\n-      _old_generation->transition_to(ShenandoahOldGeneration::WAITING_FOR_FILL);\n+      _old_generation->transition_to(ShenandoahOldGeneration::FILLING);\n@@ -470,1 +470,1 @@\n-    _old_generation->transition_to(ShenandoahOldGeneration::WAITING_FOR_EVAC);\n+    _old_generation->transition_to(ShenandoahOldGeneration::EVACUATING);\n@@ -472,1 +472,1 @@\n-    _old_generation->transition_to(ShenandoahOldGeneration::WAITING_FOR_FILL);\n+    _old_generation->transition_to(ShenandoahOldGeneration::FILLING);\n@@ -474,1 +474,1 @@\n-    _old_generation->transition_to(ShenandoahOldGeneration::IDLE);\n+    _old_generation->transition_to(ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -385,0 +385,2 @@\n+  heap->try_inject_alloc_failure();\n+\n@@ -386,3 +388,4 @@\n-  static const char* msg = \"Concurrent reset\";\n-  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_reset);\n-  EventMark em(\"%s\", msg);\n+  {\n+    static const char* msg = \"Concurrent reset\";\n+    ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_reset);\n+    EventMark em(\"%s\", msg);\n@@ -390,3 +393,5 @@\n-  ShenandoahWorkerScope scope(heap->workers(),\n-                              ShenandoahWorkerPolicy::calc_workers_for_conc_reset(),\n-                              \"concurrent reset\");\n+    ShenandoahWorkerScope scope(heap->workers(),\n+                                ShenandoahWorkerPolicy::calc_workers_for_conc_reset(),\n+                                msg);\n+    op_reset();\n+  }\n@@ -394,2 +399,10 @@\n-  heap->try_inject_alloc_failure();\n-  op_reset();\n+  if (_do_old_gc_bootstrap) {\n+    static const char* msg = \"Concurrent reset (OLD)\";\n+    ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_reset_old);\n+    ShenandoahWorkerScope scope(ShenandoahHeap::heap()->workers(),\n+                                ShenandoahWorkerPolicy::calc_workers_for_conc_reset(),\n+                                msg);\n+    EventMark em(\"%s\", msg);\n+\n+    heap->old_generation()->prepare_gc();\n+  }\n@@ -1269,1 +1282,6 @@\n-    ShenandoahMarkingContext *ctx = heap->complete_marking_context();\n+    \/\/ If the cycle was shortened for having enough immediate garbage, this could be\n+    \/\/ the last GC safepoint before concurrent marking of old resumes. We must be sure\n+    \/\/ that old mark threads don't see any pointers to garbage in the SATB buffers.\n+    if (heap->is_concurrent_old_mark_in_progress()) {\n+      heap->transfer_old_pointers_from_satb();\n+    }\n@@ -1271,0 +1289,1 @@\n+    ShenandoahMarkingContext *ctx = heap->complete_marking_context();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":28,"deletions":9,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -253,0 +253,1 @@\n+        heap->set_unload_classes(false);\n@@ -518,5 +519,0 @@\n-    case ShenandoahOldGeneration::WAITING_FOR_FILL:\n-    case ShenandoahOldGeneration::IDLE: {\n-      assert(!heap->is_concurrent_old_mark_in_progress(), \"Old already in progress\");\n-      assert(old_generation->task_queues()->is_empty(), \"Old mark queues should be empty\");\n-    }\n@@ -524,1 +520,0 @@\n-      _allow_old_preemption.set();\n@@ -526,1 +521,2 @@\n-      old_generation->prepare_gc();\n+      _allow_old_preemption.set();\n+      old_generation->entry_coalesce_and_fill();\n@@ -529,7 +525,0 @@\n-      if (heap->is_prepare_for_old_mark_in_progress()) {\n-        \/\/ Coalescing threads detected the cancellation request and aborted. Stay\n-        \/\/ in this state so control thread may resume the coalescing work.\n-        assert(old_generation->state() == ShenandoahOldGeneration::FILLING, \"Prepare for mark should be in progress\");\n-        assert(heap->cancelled_gc(), \"Preparation for GC is not complete, expected cancellation\");\n-      }\n-\n@@ -547,3 +536,3 @@\n-      \/\/ Coalescing threads completed and nothing was cancelled. it is safe to transition\n-      \/\/ to the bootstrapping state now.\n-      old_generation->transition_to(ShenandoahOldGeneration::BOOTSTRAPPING);\n+      \/\/ Coalescing threads completed and nothing was cancelled. it is safe to transition from this state.\n+      old_generation->transition_to(ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP);\n+      return;\n@@ -551,0 +540,2 @@\n+    case ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP:\n+      old_generation->transition_to(ShenandoahOldGeneration::BOOTSTRAPPING);\n@@ -586,2 +577,1 @@\n-          heap->mmu_tracker()->record_old_marking_increment(old_generation, GCId::current(), true,\n-                                                            heap->collection_set()->has_old_regions());\n+          heap->mmu_tracker()->record_old_marking_increment(true);\n@@ -591,2 +581,1 @@\n-        heap->mmu_tracker()->record_old_marking_increment(old_generation, GCId::current(), false,\n-                                                          heap->collection_set()->has_old_regions());\n+        heap->mmu_tracker()->record_old_marking_increment(false);\n@@ -728,1 +717,1 @@\n-          mmu_tracker->record_mixed(generation, get_gc_id(), mixed_is_done);\n+          mmu_tracker->record_mixed(get_gc_id());\n@@ -730,1 +719,1 @@\n-          mmu_tracker->record_bootstrap(generation, get_gc_id(), heap->collection_set()->has_old_regions());\n+          mmu_tracker->record_bootstrap(get_gc_id());\n@@ -732,1 +721,1 @@\n-          mmu_tracker->record_young(generation, get_gc_id());\n+          mmu_tracker->record_young(get_gc_id());\n@@ -743,1 +732,1 @@\n-        mmu_tracker->record_global(generation, get_gc_id());\n+        mmu_tracker->record_global(get_gc_id());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":14,"deletions":25,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -61,2 +61,1 @@\n-    heap->mmu_tracker()->record_degenerated(_generation, GCId::current(), is_bootstrap_gc,\n-                                            !heap->collection_set()->has_old_regions());\n+    heap->mmu_tracker()->record_degenerated(GCId::current(), is_bootstrap_gc);\n@@ -109,3 +108,3 @@\n-      assert(state == ShenandoahOldGeneration::IDLE\n-             || state == ShenandoahOldGeneration::WAITING_FOR_EVAC\n-             || state == ShenandoahOldGeneration::WAITING_FOR_FILL,\n+      assert(state == ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP\n+             || state == ShenandoahOldGeneration::EVACUATING\n+             || state == ShenandoahOldGeneration::FILLING,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-    heap->mmu_tracker()->record_full(heap->global_generation(), GCId::current());\n+    heap->mmu_tracker()->record_full(GCId::current());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -587,1 +587,0 @@\n-  _prepare_for_old_mark(false),\n@@ -744,1 +743,1 @@\n-  return _old_generation->state() == ShenandoahOldGeneration::WAITING_FOR_EVAC;\n+  return _old_generation->state() == ShenandoahOldGeneration::EVACUATING;\n@@ -1168,1 +1167,1 @@\n-  if (_old_generation->state() == ShenandoahOldGeneration::IDLE) {\n+  if (_old_generation->state() == ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP) {\n@@ -1177,2 +1176,0 @@\n-    \/\/ Stop coalescing undead objects\n-    set_prepare_for_old_mark_in_progress(false);\n@@ -1184,1 +1181,1 @@\n-    _old_generation->transition_to(ShenandoahOldGeneration::IDLE);\n+    _old_generation->transition_to(ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP);\n@@ -2468,4 +2465,2 @@\n-void ShenandoahHeap::set_prepare_for_old_mark_in_progress(bool in_progress) {\n-  \/\/ Unlike other set-gc-state functions, this may happen outside safepoint.\n-  \/\/ Is only set and queried by control thread, so no coherence issues.\n-  _prepare_for_old_mark = in_progress;\n+bool ShenandoahHeap::is_prepare_for_old_mark_in_progress() const {\n+  return old_generation()->state() == ShenandoahOldGeneration::FILLING;\n@@ -2806,0 +2801,1 @@\n+    log_info(gc, remset)(\"Scan remembered set using bitmap: %s\", BOOL_TO_STR(_heap->is_old_bitmap_stable()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -165,3 +165,0 @@\n-  \/\/ true iff we are concurrently coalescing and filling old-gen HeapRegions\n-  bool _prepare_for_old_mark;\n-\n@@ -408,1 +405,1 @@\n-  void set_prepare_for_old_mark_in_progress(bool cond);\n+\n@@ -427,1 +424,1 @@\n-  inline bool is_prepare_for_old_mark_in_progress() const;\n+  bool is_prepare_for_old_mark_in_progress() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -753,4 +753,0 @@\n-inline bool ShenandoahHeap::is_prepare_for_old_mark_in_progress() const {\n-  return _prepare_for_old_mark;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-void ShenandoahMmuTracker::update_utilization(ShenandoahGeneration* generation, size_t gcid, const char *msg) {\n+void ShenandoahMmuTracker::update_utilization(size_t gcid, const char* msg) {\n@@ -112,2 +112,2 @@\n-void ShenandoahMmuTracker::record_young(ShenandoahGeneration* generation, size_t gcid) {\n-  update_utilization(generation, gcid, \"Concurrent Young GC\");\n+void ShenandoahMmuTracker::record_young(size_t gcid) {\n+  update_utilization(gcid, \"Concurrent Young GC\");\n@@ -116,2 +116,2 @@\n-void ShenandoahMmuTracker::record_global(ShenandoahGeneration* generation, size_t gcid) {\n-  update_utilization(generation, gcid, \"Concurrent Global GC\");\n+void ShenandoahMmuTracker::record_global(size_t gcid) {\n+  update_utilization(gcid, \"Concurrent Global GC\");\n@@ -120,1 +120,1 @@\n-void ShenandoahMmuTracker::record_bootstrap(ShenandoahGeneration* generation, size_t gcid, bool candidates_for_mixed) {\n+void ShenandoahMmuTracker::record_bootstrap(size_t gcid) {\n@@ -122,1 +122,1 @@\n-  update_utilization(generation, gcid, \"Concurrent Bootstrap GC\");\n+  update_utilization(gcid, \"Concurrent Bootstrap GC\");\n@@ -125,2 +125,1 @@\n-void ShenandoahMmuTracker::record_old_marking_increment(ShenandoahGeneration* generation, size_t gcid, bool old_marking_done,\n-                                                        bool has_old_candidates) {\n+void ShenandoahMmuTracker::record_old_marking_increment(bool old_marking_done) {\n@@ -140,2 +139,2 @@\n-void ShenandoahMmuTracker::record_mixed(ShenandoahGeneration* generation, size_t gcid, bool is_mixed_done) {\n-  update_utilization(generation, gcid, \"Mixed Concurrent GC\");\n+void ShenandoahMmuTracker::record_mixed(size_t gcid) {\n+  update_utilization(gcid, \"Mixed Concurrent GC\");\n@@ -144,2 +143,1 @@\n-void ShenandoahMmuTracker::record_degenerated(ShenandoahGeneration* generation,\n-                                              size_t gcid, bool is_old_bootstrap, bool is_mixed_done) {\n+void ShenandoahMmuTracker::record_degenerated(size_t gcid, bool is_old_bootstrap) {\n@@ -150,1 +148,1 @@\n-    update_utilization(generation, gcid, \"Degenerated Bootstrap Old GC\");\n+    update_utilization(gcid, \"Degenerated Bootstrap Old GC\");\n@@ -152,1 +150,1 @@\n-    update_utilization(generation, gcid, \"Degenerated Young GC\");\n+    update_utilization(gcid, \"Degenerated Young GC\");\n@@ -156,2 +154,2 @@\n-void ShenandoahMmuTracker::record_full(ShenandoahGeneration* generation, size_t gcid) {\n-  update_utilization(generation, gcid, \"Full GC\");\n+void ShenandoahMmuTracker::record_full(size_t gcid) {\n+  update_utilization(gcid, \"Full GC\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.cpp","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-  void update_utilization(ShenandoahGeneration* generation, size_t gcid, const char* msg);\n+  void update_utilization(size_t gcid, const char* msg);\n@@ -93,7 +93,7 @@\n-  void record_young(ShenandoahGeneration* generation, size_t gcid);\n-  void record_global(ShenandoahGeneration* generation, size_t gcid);\n-  void record_bootstrap(ShenandoahGeneration* generation, size_t gcid, bool has_old_candidates);\n-  void record_old_marking_increment(ShenandoahGeneration* generation, size_t gcid, bool old_marking_done, bool has_old_candidates);\n-  void record_mixed(ShenandoahGeneration* generation, size_t gcid, bool is_mixed_done);\n-  void record_full(ShenandoahGeneration* generation, size_t gcid);\n-  void record_degenerated(ShenandoahGeneration* generation, size_t gcid, bool is_old_boostrap, bool is_mixed_done);\n+  void record_young(size_t gcid);\n+  void record_global(size_t gcid);\n+  void record_bootstrap(size_t gcid);\n+  void record_old_marking_increment(bool old_marking_done);\n+  void record_mixed(size_t gcid);\n+  void record_full(size_t gcid);\n+  void record_degenerated(size_t gcid, bool is_old_boostrap);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-    _state(IDLE),\n+    _state(WAITING_FOR_BOOTSTRAP),\n@@ -236,14 +236,5 @@\n-  \/\/ Make the old generation regions parseable, so they can be safely\n-  \/\/ scanned when looking for objects in memory indicated by dirty cards.\n-  if (entry_coalesce_and_fill()) {\n-    \/\/ Now that we have made the old generation parseable, it is safe to reset the mark bitmap.\n-    static const char* msg = \"Concurrent reset (OLD)\";\n-    ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_reset_old);\n-    ShenandoahWorkerScope scope(ShenandoahHeap::heap()->workers(),\n-                                ShenandoahWorkerPolicy::calc_workers_for_conc_reset(),\n-                                msg);\n-    ShenandoahGeneration::prepare_gc();\n-  }\n-  \/\/ Else, coalesce-and-fill has been preempted and we'll finish that effort in the future.  Do not invoke\n-  \/\/ ShenandoahGeneration::prepare_gc() until coalesce-and-fill is done because it resets the mark bitmap\n-  \/\/ and invokes set_mark_incomplete().  Coalesce-and-fill depends on the mark bitmap.\n+\n+  \/\/ Now that we have made the old generation parsable, it is safe to reset the mark bitmap.\n+  assert(state() != FILLING, \"Cannot reset old without making it parsable\");\n+\n+  ShenandoahGeneration::prepare_gc();\n@@ -268,0 +259,2 @@\n+\/\/ Make the old generation regions parsable, so they can be safely\n+\/\/ scanned when looking for objects in memory indicated by dirty cards.\n@@ -270,1 +263,0 @@\n-  heap->set_prepare_for_old_mark_in_progress(true);\n@@ -288,2 +280,0 @@\n-    \/\/ Remember that we're done with coalesce-and-fill.\n-    heap->set_prepare_for_old_mark_in_progress(false);\n@@ -293,1 +283,3 @@\n-    \/\/ Otherwise, we were preempted before the work was done.\n+    \/\/ Coalesce-and-fill has been preempted. We'll finish that effort in the future.  Do not invoke\n+    \/\/ ShenandoahGeneration::prepare_gc() until coalesce-and-fill is done because it resets the mark bitmap\n+    \/\/ and invokes set_mark_incomplete().  Coalesce-and-fill depends on the mark bitmap.\n@@ -357,6 +349,5 @@\n-    case IDLE:              return \"Idle\";\n-    case FILLING:           return \"Coalescing\";\n-    case BOOTSTRAPPING:     return \"Bootstrapping\";\n-    case MARKING:           return \"Marking\";\n-    case WAITING_FOR_EVAC:  return \"Waiting for evacuation\";\n-    case WAITING_FOR_FILL:  return \"Waiting for fill\";\n+    case WAITING_FOR_BOOTSTRAP: return \"Waiting for Bootstrap\";\n+    case FILLING:               return \"Coalescing\";\n+    case BOOTSTRAPPING:         return \"Bootstrapping\";\n+    case MARKING:               return \"Marking\";\n+    case EVACUATING:            return \"Evacuating\";\n@@ -385,5 +376,12 @@\n-\/\/ parseable _before_ the old generation bitmap is reset. The diagram does not depict\n-\/\/ cancellation of old collections by global or full collections. However, it does\n-\/\/ depict a transition from IDLE to WAITING_FOR_FILL, which is allowed after a global\n-\/\/ cycle ends. Also note that a global collection will cause any evacuation or fill\n-\/\/ candidates to be abandoned, returning the old generation to the idle state.\n+\/\/ parsable _before_ the old generation bitmap is reset. The diagram does not depict\n+\/\/ cancellation of old collections by global or full collections.\n+\/\/\n+\/\/ When a global collection supersedes an old collection, the global mark still\n+\/\/ \"completes\" the old mark bitmap. Subsequent remembered set scans may use the\n+\/\/ old generation mark bitmap, but any uncollected old regions must still be made parsable\n+\/\/ before the next old generation cycle begins. For this reason, a global collection may\n+\/\/ create mixed collection candidates and coalesce and fill candidates and will put\n+\/\/ the old generation in the respective states (EVACUATING or FILLING). After a Full GC,\n+\/\/ the mark bitmaps are all reset, all regions are parsable and the mark context will\n+\/\/ not be \"complete\". After a Full GC, remembered set scans will _not_ use the mark bitmap\n+\/\/ and we expect the old generation to be waiting for bootstrap.\n@@ -391,38 +389,0 @@\n-\/\/           +----------------> +-----------------+\n-\/\/           |   +------------> |      IDLE       |\n-\/\/           |   |   +--------> |                 |\n-\/\/           |   |   |          +-----------------+\n-\/\/           |   |   |            |\n-\/\/           |   |   |            | Begin Old Mark\n-\/\/           |   |   |            v\n-\/\/           |   |   |          +-----------------+     +--------------------+\n-\/\/           |   |   |          |     FILLING     | <-> |      YOUNG GC      |\n-\/\/           |   |   |    +---> |                 |     | (RSet Uses Bitmap) |\n-\/\/           |   |   |    |     +-----------------+     +--------------------+\n-\/\/           |   |   |    |       |\n-\/\/           |   |   |    |       | Reset Bitmap\n-\/\/           |   |   |    |       v\n-\/\/           |   |   |    |     +-----------------+\n-\/\/           |   |   |    |     |    BOOTSTRAP    |\n-\/\/           |   |   |    |     |                 |\n-\/\/           |   |   |    |     +-----------------+\n-\/\/           |   |   |    |       |\n-\/\/           |   |   |    |       | Continue Marking\n-\/\/           |   |   |    |       v\n-\/\/           |   |   |    |     +-----------------+     +----------------------+\n-\/\/           |   |   |    |     |    MARKING      | <-> |       YOUNG GC       |\n-\/\/           |   |   +----|-----|                 |     | (RSet Parses Region) |\n-\/\/           |   |        |     +-----------------+     +----------------------+\n-\/\/           |   |        |       |\n-\/\/           |   |        |       | Has Candidates\n-\/\/           |   |        |       v\n-\/\/           |   |        |     +-----------------+\n-\/\/           |   |        |     |    WAITING FOR  |\n-\/\/           |   +--------|---> |    EVACUATIONS  |\n-\/\/           |            |     +-----------------+\n-\/\/           |            |       |\n-\/\/           |            |       | All Candidates are Pinned\n-\/\/           |            |       v\n-\/\/           |            |     +-----------------+\n-\/\/           |            +---- |    WAITING FOR  |\n-\/\/           +----------------> |    FILLING      |\n@@ -430,0 +390,33 @@\n+\/\/               +------------> |     FILLING     | <---+\n+\/\/               |   +--------> |                 |     |\n+\/\/               |   |          +-----------------+     |\n+\/\/               |   |            |                     |\n+\/\/               |   |            | Filling Complete    | <-> A global collection may\n+\/\/               |   |            v                     |     may move the old generation\n+\/\/               |   |          +-----------------+     |     directly from waiting for\n+\/\/               |   +--------> |     WAITING     |     |     bootstrap to filling or\n+\/\/               |   |    +---- |  FOR BOOTSTRAP  | ----+     evacuating.\n+\/\/               |   |    |     +-----------------+\n+\/\/               |   |    |       |\n+\/\/               |   |    |       | Reset Bitmap\n+\/\/               |   |    |       v\n+\/\/               |   |    |     +-----------------+     +----------------------+\n+\/\/               |   |    |     |    BOOTSTRAP    | <-> |       YOUNG GC       |\n+\/\/               |   |    |     |                 |     | (RSet Parses Region) |\n+\/\/               |   |    |     +-----------------+     +----------------------+\n+\/\/               |   |    |       |\n+\/\/               |   |    |       | Old Marking\n+\/\/               |   |    |       v\n+\/\/               |   |    |     +-----------------+     +----------------------+\n+\/\/               |   |    |     |     MARKING     | <-> |       YOUNG GC       |\n+\/\/               |   +--------- |                 |     | (RSet Parses Region) |\n+\/\/               |        |     +-----------------+     +----------------------+\n+\/\/               |        |       |\n+\/\/               |        |       | Has Evacuation Candidates\n+\/\/               |        |       v\n+\/\/               |        |     +-----------------+     +--------------------+\n+\/\/               |        +---> |    EVACUATING   | <-> |      YOUNG GC      |\n+\/\/               +------------- |                 |     | (RSet Uses Bitmap) |\n+\/\/                              +-----------------+     +--------------------+\n+\/\/\n+\/\/\n@@ -434,7 +427,0 @@\n-    case IDLE:\n-      \/\/ GC cancellation can send us back to IDLE from any state.\n-      assert(!heap->is_concurrent_old_mark_in_progress(), \"Cannot become idle during old mark.\");\n-      assert(_old_heuristics->unprocessed_old_collection_candidates() == 0, \"Cannot become idle with collection candidates\");\n-      assert(!heap->is_prepare_for_old_mark_in_progress(), \"Cannot become idle while making old generation parseable.\");\n-      assert(heap->young_generation()->old_gen_task_queues() == nullptr, \"Cannot become idle when setup for bootstrapping.\");\n-      break;\n@@ -442,2 +428,9 @@\n-      assert(_state == IDLE || _state == WAITING_FOR_FILL, \"Cannot begin filling without first completing evacuations, state is '%s'\", state_name(_state));\n-      assert(heap->is_prepare_for_old_mark_in_progress(), \"Should be preparing for old mark now.\");\n+      assert(_state != BOOTSTRAPPING, \"Cannot beging making old regions parsable after bootstrapping\");\n+      assert(heap->is_old_bitmap_stable(), \"Cannot begin filling without first completing marking, state is '%s'\", state_name(_state));\n+      assert(_old_heuristics->has_coalesce_and_fill_candidates(), \"Cannot begin filling without something to fill.\");\n+      break;\n+    case WAITING_FOR_BOOTSTRAP:\n+      \/\/ GC cancellation can send us back here from any state.\n+      assert(!heap->is_concurrent_old_mark_in_progress(), \"Cannot become ready for bootstrap during old mark.\");\n+      assert(_old_heuristics->unprocessed_old_collection_candidates() == 0, \"Cannot become ready for bootstrap with collection candidates\");\n+      assert(heap->young_generation()->old_gen_task_queues() == nullptr, \"Cannot become ready for bootstrap when still setup for bootstrapping.\");\n@@ -446,1 +439,1 @@\n-      assert(_state == FILLING, \"Cannot reset bitmap without making old regions parseable, state is '%s'\", state_name(_state));\n+      assert(_state == WAITING_FOR_BOOTSTRAP, \"Cannot reset bitmap without making old regions parsable, state is '%s'\", state_name(_state));\n@@ -448,1 +441,1 @@\n-      assert(!heap->is_prepare_for_old_mark_in_progress(), \"Cannot still be making old regions parseable.\");\n+      assert(!heap->is_prepare_for_old_mark_in_progress(), \"Cannot still be making old regions parsable.\");\n@@ -455,2 +448,2 @@\n-    case WAITING_FOR_EVAC:\n-      assert(_state == IDLE || _state == MARKING, \"Cannot have old collection candidates without first marking, state is '%s'\", state_name(_state));\n+    case EVACUATING:\n+      assert(_state == WAITING_FOR_BOOTSTRAP || _state == MARKING, \"Cannot have old collection candidates without first marking, state is '%s'\", state_name(_state));\n@@ -459,4 +452,0 @@\n-    case WAITING_FOR_FILL:\n-      assert(_state == IDLE || _state == MARKING || _state == WAITING_FOR_EVAC, \"Cannot begin filling without first marking or evacuating, state is '%s'\", state_name(_state));\n-      assert(_old_heuristics->has_coalesce_and_fill_candidates(), \"Cannot wait for fill without something to fill.\");\n-      break;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":74,"deletions":85,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-  bool entry_coalesce_and_fill();\n@@ -60,0 +59,1 @@\n+  bool entry_coalesce_and_fill();\n@@ -87,1 +87,1 @@\n-    IDLE, FILLING, BOOTSTRAPPING, MARKING, WAITING_FOR_EVAC, WAITING_FOR_FILL\n+    FILLING, WAITING_FOR_BOOTSTRAP, BOOTSTRAPPING, MARKING, EVACUATING\n@@ -95,1 +95,1 @@\n-  \/\/ During initialization of the JVM, we search for the correct old-gen size by initally performing old-gen\n+  \/\/ During initialization of the JVM, we search for the correct old-gen size by initially performing old-gen\n@@ -98,1 +98,1 @@\n-  \/\/ memory at the end of the first old-gen collection.  Then we trigger again when old-gen growns 12.5%\n+  \/\/ memory at the end of the first old-gen collection.  Then we trigger again when old-gen grows 12.5%\n@@ -135,1 +135,1 @@\n-    return _state == IDLE || _state == WAITING_FOR_FILL;\n+    return _state == WAITING_FOR_BOOTSTRAP;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -109,1 +109,3 @@\n-  _queue_set(queue_set), _old_queue_set(old_queue_set), _rp(rp), _work_list(work_list), _is_concurrent(is_concurrent) {}\n+  _queue_set(queue_set), _old_queue_set(old_queue_set), _rp(rp), _work_list(work_list), _is_concurrent(is_concurrent) {\n+  log_info(gc, remset)(\"Scan remembered set using bitmap: %s\", BOOL_TO_STR(ShenandoahHeap::heap()->is_old_bitmap_stable()));\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -893,0 +893,1 @@\n+  log_info(gc, remset)(\"Scan remembered set using bitmap: %s\", BOOL_TO_STR(heap->is_old_bitmap_stable()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -832,2 +832,2 @@\n-      bool is_marking = (actual & ShenandoahHeap::MARKING)? 1: 0;\n-      bool is_marking_young_or_old = (actual & (ShenandoahHeap::YOUNG_MARKING | ShenandoahHeap::OLD_MARKING))? 1: 0;\n+      bool is_marking = (actual & ShenandoahHeap::MARKING);\n+      bool is_marking_young_or_old = (actual & (ShenandoahHeap::YOUNG_MARKING | ShenandoahHeap::OLD_MARKING));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -609,1 +609,1 @@\n-  notproduct(bool, ShenandoahEnableCardStats, trueInDebug,                  \\\n+  notproduct(bool, ShenandoahEnableCardStats, false,                        \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -361,1 +361,1 @@\n-  EXPECT_EQ(old_generation_state(), ShenandoahOldGeneration::WAITING_FOR_FILL);\n+  EXPECT_EQ(old_generation_state(), ShenandoahOldGeneration::FILLING);\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahOldHeuristic.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}