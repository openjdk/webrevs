{"files":[{"patch":"@@ -121,1 +121,0 @@\n-  Address in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));\n@@ -126,7 +125,3 @@\n-  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n-    __ ldrw(tmp1, in_progress);\n-  } else {\n-    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n-    __ ldrb(tmp1, in_progress);\n-  }\n-  __ cbzw(tmp1, done);\n+  Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n+  __ ldrb(tmp1, gc_state);\n+  __ tbz(tmp1, ShenandoahHeap::MARKING_BITPOS, done);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -116,1 +116,0 @@\n-  Address in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));\n@@ -121,7 +120,4 @@\n-  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n-    __ lwu(tmp1, in_progress);\n-  } else {\n-    assert(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1, \"Assumption\");\n-    __ lbu(tmp1, in_progress);\n-  }\n-  __ beqz(tmp1, done);\n+  Address gc_state(xthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n+  __ lbu(t1, gc_state);\n+  __ test_bit(t1, t1, ShenandoahHeap::MARKING_BITPOS);\n+  __ beqz(t1, done);\n@@ -304,1 +300,1 @@\n-  __ call(target);\n+  __ rt_call(target);\n@@ -707,1 +703,1 @@\n-  __ call(target);\n+  __ rt_call(target);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -277,1 +277,0 @@\n-  Address in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  BasicType flag_type;\n+\n@@ -66,9 +66,1 @@\n-  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n-    flag_type = T_INT;\n-  } else {\n-    guarantee(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1,\n-              \"Assumption\");\n-    \/\/ Use unsigned type T_BOOLEAN here rather than signed T_BYTE since some platforms, eg. ARM,\n-    \/\/ need to use unsigned instructions to use the large offset to load the satb_mark_queue.\n-    flag_type = T_BOOLEAN;\n-  }\n+\n@@ -76,5 +68,5 @@\n-  LIR_Address* mark_active_flag_addr =\n-    new LIR_Address(thrd,\n-                    in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()),\n-                    flag_type);\n-  \/\/ Read the marking-in-progress flag.\n+  LIR_Address* gc_state_addr =\n+          new LIR_Address(thrd,\n+                          in_bytes(ShenandoahThreadLocalData::gc_state_offset()),\n+                          T_BYTE);\n+  \/\/ Read the gc_state flag.\n@@ -82,1 +74,15 @@\n-  __ load(mark_active_flag_addr, flag_val);\n+  __ load(gc_state_addr, flag_val);\n+\n+  \/\/ Create a mask to test if the marking bit is set.\n+  \/\/ TODO: can we directly test if bit is set?\n+  LIR_Opr mask = LIR_OprFact::intConst(ShenandoahHeap::MARKING);\n+  LIR_Opr mask_reg = gen->new_register(T_INT);\n+  __ move(mask, mask_reg);\n+\n+  if (two_operand_lir_form) {\n+    __ logical_and(flag_val, mask_reg, flag_val);\n+  } else {\n+    LIR_Opr masked_flag = gen->new_register(T_INT);\n+    __ logical_and(flag_val, mask_reg, masked_flag);\n+    flag_val = masked_flag;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.cpp","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1108,1 +1108,1 @@\n-    const int marking_offset = in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset());\n+    const int gc_state_offset = in_bytes(ShenandoahThreadLocalData::gc_state_offset());\n@@ -1116,1 +1116,4 @@\n-      if (x == nullptr || x == compile->top()) continue;\n+      if (x == nullptr || x == compile->top()) {\n+        continue;\n+      }\n+\n@@ -1144,1 +1147,1 @@\n-                  && load->in(2)->in(3)->bottom_type()->is_intptr_t()->get_con() == marking_offset) {\n+                  && load->in(2)->in(3)->bottom_type()->is_intptr_t()->get_con() == gc_state_offset) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -467,0 +467,6 @@\n+        \"intpoly_montgomeryMult_P256\",\n+        { { TypeFunc::Parms, ShenandoahLoad },  { TypeFunc::Parms+1, ShenandoahLoad  },   { TypeFunc::Parms+2, ShenandoahStore },\n+          { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },\n+        \"intpoly_assign\",\n+        { { TypeFunc::Parms+1, ShenandoahStore }, { TypeFunc::Parms+2, ShenandoahLoad },  { -1, ShenandoahNone },\n+          { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -144,8 +144,4 @@\n-  \/\/ If the GC was cancelled just before final mark (but after the preceding cancellation check),\n-  \/\/ then the safepoint operation will do nothing and the concurrent mark will still be in progress.\n-  \/\/ In this case it is safe (and necessary) to resume the degenerated cycle from the marking phase.\n-  \/\/\n-  \/\/ On the other hand, if the GC is cancelled after final mark (but before this check), then the\n-  \/\/ final mark safepoint operation will have finished the mark (setting concurrent mark in progress\n-  \/\/ to false). In this case (final mark has completed), we need control to fall past the next\n-  \/\/ cancellation check and resume the degenerated cycle from the evacuation phase.\n+  \/\/ If the GC was cancelled before final mark, nothing happens on the safepoint. We are still\n+  \/\/ in the marking phase and must resume the degenerated cycle from there. If the GC was cancelled\n+  \/\/ after final mark, then we've entered the evacuation phase and must resume the degenerated cycle\n+  \/\/ from that phase.\n@@ -153,10 +149,0 @@\n-    \/\/ If the concurrent mark is still in progress after the final mark safepoint, then the GC has\n-    \/\/ been cancelled. The degenerated cycle must resume from the marking phase. Without this check,\n-    \/\/ the non-generational mode may fall all the way to the end of this collect routine without\n-    \/\/ having done anything (besides mark most of the heap). Without having collected anything, we\n-    \/\/ can expect an 'out of cycle' degenerated GC which will again mark the entire heap. This is\n-    \/\/ not optimal.\n-    \/\/ For the generational mode, we cannot allow this. The generational mode relies on marking\n-    \/\/ (including the final mark) to rebuild portions of the card table. If the generational mode does\n-    \/\/ not complete marking after it has swapped the card tables, the root set on subsequent GCs will\n-    \/\/ be incomplete, heap corruption may follow.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+  \/\/ Returns false if the collection was cancelled, true otherwise.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGC.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2074,1 +2074,1 @@\n-  \/\/ Step 0. Notify policy to disable event recording.\n+  \/\/ Step 0. Notify policy to disable event recording and prevent visiting gc threads during shutdown\n@@ -2339,1 +2339,1 @@\n-      \/\/ We cannot transfer any more regions than will be reclaimed when the existing collection set is recycled, because\n+      \/\/ We cannot transfer any more regions than will be reclaimed when the existing collection set is recycled because\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  _nm(nm), _oops(nullptr), _oops_count(0), _unregistered(false) {\n+  _nm(nm), _oops(nullptr), _oops_count(0), _unregistered(false), _lock(), _ic_lock() {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -264,4 +264,0 @@\n-  static ByteSize satb_mark_queue_active_offset() {\n-    return satb_mark_queue_offset() + SATBMarkQueue::byte_offset_of_active();\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-    ShenandoahReentrantLock* const lock = ShenandoahNMethod::lock_for_nmethod(nm);\n+    ShenandoahReentrantLock* const lock = ShenandoahNMethod::ic_lock_for_nmethod(nm);\n@@ -102,1 +102,1 @@\n-    ShenandoahReentrantLock* const lock = ShenandoahNMethod::lock_for_nmethod(nm);\n+    ShenandoahReentrantLock* const lock = ShenandoahNMethod::ic_lock_for_nmethod(nm);\n@@ -112,1 +112,1 @@\n-    ShenandoahReentrantLock* const lock = ShenandoahNMethod::lock_for_nmethod(nm);\n+    ShenandoahReentrantLock* const lock = ShenandoahNMethod::ic_lock_for_nmethod(nm);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUnload.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,0 +46,3 @@\n+  \/\/ GC thread root traversal likely used OopMapCache a lot, which\n+  \/\/ might have created lots of old entries. Trigger the cleanup now.\n+  OopMapCache::trigger_cleanup();\n@@ -56,1 +59,0 @@\n-  OopMapCache::cleanup_old_entries();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+compiler\/codecache\/CheckLargePages.java 8332654 linux-x64\n@@ -81,0 +82,4 @@\n+compiler\/rangechecks\/TestArrayAccessAboveRCAfterRCCastIIEliminated.java 8332369 generic-all\n+\n+compiler\/codecache\/CodeCacheFullCountTest.java 8332954 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}