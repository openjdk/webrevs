{"files":[{"patch":"@@ -684,8 +684,3 @@\n-    \/\/ The collection set is chosen by prepare_regions_and_collection_set().\n-    \/\/\n-    \/\/ TODO: Under severe memory overload conditions that can be checked here, we may want to limit\n-    \/\/ the inclusion of old-gen candidates within the collection set.  This would allow us to prioritize efforts on\n-    \/\/ evacuating young-gen,  This remediation is most appropriate when old-gen availability is very high (so there\n-    \/\/ are negligible negative impacts from delaying completion of old-gen evacuation) and when young-gen collections\n-    \/\/ are \"under duress\" (as signalled by very low availability of memory within young-gen, indicating that\/ young-gen\n-    \/\/ collections are not triggering frequently enough).\n+    \/\/ The collection set is chosen by prepare_regions_and_collection_set(). Additionally, certain parameters have been\n+    \/\/ established to govern the evacuation efforts that are about to begin.  Refer to comments on reserve members in\n+    \/\/ ShenandoahGeneration and ShenandoahOldGeneration for more detail.\n@@ -694,17 +689,0 @@\n-    \/\/ Upon return from prepare_regions_and_collection_set(), certain parameters have been established to govern the\n-    \/\/ evacuation efforts that are about to begin.  In particular:\n-    \/\/\n-    \/\/ heap->get_promoted_reserve() represents the amount of memory within old-gen's available memory that has\n-    \/\/   been set aside to hold objects promoted from young-gen memory.  This represents an estimated percentage\n-    \/\/   of the live young-gen memory within the collection set.  If there is more data ready to be promoted than\n-    \/\/   can fit within this reserve, the promotion of some objects will be deferred until a subsequent evacuation\n-    \/\/   pass.\n-    \/\/\n-    \/\/ heap->get_old_evac_reserve() represents the amount of memory within old-gen's available memory that has been\n-    \/\/  set aside to hold objects evacuated from the old-gen collection set.\n-    \/\/\n-    \/\/ heap->get_young_evac_reserve() represents the amount of memory within young-gen's available memory that has\n-    \/\/  been set aside to hold objects evacuated from the young-gen collection set.  Conservatively, this value\n-    \/\/  equals the entire amount of live young-gen memory within the collection set, even though some of this memory\n-    \/\/  will likely be promoted.\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":3,"deletions":25,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -879,8 +879,0 @@\n-\n-      \/\/ TODO:\n-      \/\/ if (GC is idle (out of cycle) and mutator allocation fails and there is memory reserved in Collector\n-      \/\/ or OldCollector sets, transfer a region of memory so that we can satisfy the allocation request, and\n-      \/\/ immediately trigger the start of GC.  Is better to satisfy the allocation than to trigger out-of-cycle\n-      \/\/ allocation failure (even if this means we have a little less memory to handle evacuations during the\n-      \/\/ subsequent GC pass).\n-\n@@ -1074,4 +1066,0 @@\n-      \/\/ TODO: Making a PLAB parsable involves placing a filler object in its remnant memory but does not require\n-      \/\/ that the PLAB be disabled for all future purposes.  We may want to introduce a new service to make the\n-      \/\/ PLABs parsable while still allowing the PLAB to serve future allocation requests that arise during the\n-      \/\/ next evacuation pass.\n@@ -1755,3 +1743,0 @@\n-\n-  \/\/ TODO: In the future, we may modify Full GC so that it slides old objects to the end of the heap and young objects to the\n-  \/\/ front of the heap. If this is done, we can always search survivor Collector and OldCollector regions right to left.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -732,5 +732,0 @@\n-\/\/ TODO:\n-\/\/  Consider compacting old-gen objects toward the high end of memory and young-gen objects towards the low-end\n-\/\/  of memory.  As currently implemented, all regions are compacted toward the low-end of memory.  This creates more\n-\/\/  fragmentation of the heap, because old-gen regions get scattered among low-address regions such that it becomes\n-\/\/  more difficult to find contiguous regions for humongous objects.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -99,2 +99,2 @@\n-  \/\/ that the old regions are parseable.\n-  heap->old_generation()->set_parseable(true);\n+  \/\/ that the old regions are parsable.\n+  heap->old_generation()->set_parsable(true);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -736,1 +736,1 @@\n-  old_generation()->set_parseable(true);\n+  old_generation()->set_parsable(true);\n@@ -1068,1 +1068,1 @@\n-  if (!old_generation()->is_parseable()) {\n+  if (!old_generation()->is_parsable()) {\n@@ -1075,1 +1075,1 @@\n-  if (!old_generation()->is_parseable()) {\n+  if (!old_generation()->is_parsable()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1925,1 +1925,1 @@\n-    old_generation()->set_parseable(false);\n+    old_generation()->set_parsable(false);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-    _is_parseable(true),\n+    _is_parsable(true),\n@@ -319,2 +319,1 @@\n-  \/\/ TODO: Should this be region->is_old() instead?\n-  return !region->is_young();\n+  return region->is_old();\n@@ -712,3 +711,3 @@\n-void ShenandoahOldGeneration::set_parseable(bool parseable) {\n-  _is_parseable = parseable;\n-  if (_is_parseable) {\n+void ShenandoahOldGeneration::set_parsable(bool parsable) {\n+  _is_parsable = parsable;\n+  if (_is_parsable) {\n@@ -718,1 +717,1 @@\n-    \/\/ After unloading classes, we have made the old generation regions parseable.\n+    \/\/ After unloading classes, we have made the old generation regions parsable.\n@@ -729,1 +728,1 @@\n-        \/\/ that we would unload classes and make everything parseable. But, we know\n+        \/\/ that we would unload classes and make everything parsable. But, we know\n@@ -731,1 +730,0 @@\n-        \/\/ TODO: It would be nicer if we didn't have to 'correct' this situation.\n@@ -738,1 +736,1 @@\n-        \/\/ state. The full GC will then record that the old regions are parseable\n+        \/\/ state. The full GC will then record that the old regions are parsable\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+  \/\/ If there is more data ready to be promoted than can fit within this reserve, the promotion of some objects will be\n+  \/\/ deferred until a subsequent evacuation pass.\n@@ -84,1 +86,1 @@\n-  bool _is_parseable;\n+  bool _is_parsable;\n@@ -152,2 +154,2 @@\n-  bool is_parseable() const   { return _is_parseable; }\n-  void set_parseable(bool parseable);\n+  bool is_parsable() const   { return _is_parsable; }\n+  void set_parsable(bool parsable);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-bool ShenandoahDirectCardMarkRememberedSet::is_card_dirty(HeapWord *p) const {\n+bool ShenandoahDirectCardMarkRememberedSet::is_card_dirty(HeapWord* p) const {\n@@ -91,1 +91,7 @@\n-void ShenandoahDirectCardMarkRememberedSet::mark_card_as_dirty(HeapWord *p) {\n+bool ShenandoahDirectCardMarkRememberedSet::is_write_card_dirty(HeapWord* p) const {\n+  size_t index = card_index_for_addr(p);\n+  CardValue* bp = &(_card_table->write_byte_map())[index];\n+  return (bp[0] == CardTable::dirty_card_val());\n+}\n+\n+void ShenandoahDirectCardMarkRememberedSet::mark_card_as_dirty(HeapWord* p) {\n@@ -97,1 +103,1 @@\n-void ShenandoahDirectCardMarkRememberedSet::mark_range_as_dirty(HeapWord *p, size_t num_heap_words) {\n+void ShenandoahDirectCardMarkRememberedSet::mark_range_as_dirty(HeapWord* p, size_t num_heap_words) {\n@@ -109,1 +115,1 @@\n-void ShenandoahDirectCardMarkRememberedSet::mark_card_as_clean(HeapWord *p) {\n+void ShenandoahDirectCardMarkRememberedSet::mark_card_as_clean(HeapWord* p) {\n@@ -115,1 +121,1 @@\n-void ShenandoahDirectCardMarkRememberedSet::mark_range_as_clean(HeapWord *p, size_t num_heap_words) {\n+void ShenandoahDirectCardMarkRememberedSet::mark_range_as_clean(HeapWord* p, size_t num_heap_words) {\n@@ -150,1 +156,1 @@\n-  HeapWord *card_start_address = _rs->addr_for_card_index(card_at_start);\n+  HeapWord* card_start_address = _rs->addr_for_card_index(card_at_start);\n@@ -168,1 +174,1 @@\n-  HeapWord *card_start_address = _rs->addr_for_card_index(card_at_start);\n+  HeapWord* card_start_address = _rs->addr_for_card_index(card_at_start);\n@@ -294,1 +300,1 @@\n-size_t ShenandoahScanRemembered::card_index_for_addr(HeapWord *p) {\n+size_t ShenandoahScanRemembered::card_index_for_addr(HeapWord* p) {\n@@ -310,1 +316,1 @@\n-bool ShenandoahScanRemembered::is_card_dirty(HeapWord *p) {\n+bool ShenandoahScanRemembered::is_card_dirty(HeapWord* p) {\n@@ -314,1 +320,1 @@\n-void ShenandoahScanRemembered::mark_card_as_dirty(HeapWord *p) {\n+void ShenandoahScanRemembered::mark_card_as_dirty(HeapWord* p) {\n@@ -318,1 +324,5 @@\n-void ShenandoahScanRemembered::mark_range_as_dirty(HeapWord *p, size_t num_heap_words) {\n+bool ShenandoahScanRemembered::is_write_card_dirty(HeapWord* p) {\n+  return _rs->is_write_card_dirty(p);\n+}\n+\n+void ShenandoahScanRemembered::mark_range_as_dirty(HeapWord* p, size_t num_heap_words) {\n@@ -322,1 +332,1 @@\n-void ShenandoahScanRemembered::mark_card_as_clean(HeapWord *p) {\n+void ShenandoahScanRemembered::mark_card_as_clean(HeapWord* p) {\n@@ -326,1 +336,1 @@\n-void ShenandoahScanRemembered:: mark_range_as_clean(HeapWord *p, size_t num_heap_words) {\n+void ShenandoahScanRemembered:: mark_range_as_clean(HeapWord* p, size_t num_heap_words) {\n@@ -330,1 +340,1 @@\n-void ShenandoahScanRemembered::reset_object_range(HeapWord *from, HeapWord *to) {\n+void ShenandoahScanRemembered::reset_object_range(HeapWord* from, HeapWord* to) {\n@@ -334,1 +344,1 @@\n-void ShenandoahScanRemembered::register_object(HeapWord *addr) {\n+void ShenandoahScanRemembered::register_object(HeapWord* addr) {\n@@ -338,1 +348,1 @@\n-void ShenandoahScanRemembered::register_object_without_lock(HeapWord *addr) {\n+void ShenandoahScanRemembered::register_object_without_lock(HeapWord* addr) {\n@@ -446,1 +456,1 @@\n-void ShenandoahScanRemembered::coalesce_objects(HeapWord *addr, size_t length_in_words) {\n+void ShenandoahScanRemembered::coalesce_objects(HeapWord* addr, size_t length_in_words) {\n@@ -450,1 +460,1 @@\n-void ShenandoahScanRemembered::mark_range_as_empty(HeapWord *addr, size_t length_in_words) {\n+void ShenandoahScanRemembered::mark_range_as_empty(HeapWord* addr, size_t length_in_words) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":28,"deletions":18,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -207,2 +207,2 @@\n-  ShenandoahHeap *_heap;\n-  ShenandoahCardTable *_card_table;\n+  ShenandoahHeap* _heap;\n+  ShenandoahCardTable* _card_table;\n@@ -211,1 +211,1 @@\n-  HeapWord *_whole_heap_base;   \/\/ Points to first HeapWord of data contained within heap memory\n+  HeapWord* _whole_heap_base;   \/\/ Points to first HeapWord of data contained within heap memory\n@@ -218,1 +218,1 @@\n-  ShenandoahDirectCardMarkRememberedSet(ShenandoahCardTable *card_table, size_t total_card_count);\n+  ShenandoahDirectCardMarkRememberedSet(ShenandoahCardTable* card_table, size_t total_card_count);\n@@ -223,2 +223,2 @@\n-  size_t card_index_for_addr(HeapWord *p) const;\n-  HeapWord *addr_for_card_index(size_t card_index) const;\n+  size_t card_index_for_addr(HeapWord* p) const;\n+  HeapWord* addr_for_card_index(size_t card_index) const;\n@@ -235,5 +235,6 @@\n-  inline bool is_card_dirty(HeapWord *p) const;\n-  inline void mark_card_as_dirty(HeapWord *p);\n-  inline void mark_range_as_dirty(HeapWord *p, size_t num_heap_words);\n-  inline void mark_card_as_clean(HeapWord *p);\n-  inline void mark_range_as_clean(HeapWord *p, size_t num_heap_words);\n+  inline bool is_card_dirty(HeapWord* p) const;\n+  inline bool is_write_card_dirty(HeapWord* p) const;\n+  inline void mark_card_as_dirty(HeapWord* p);\n+  inline void mark_range_as_dirty(HeapWord* p, size_t num_heap_words);\n+  inline void mark_card_as_clean(HeapWord* p);\n+  inline void mark_range_as_clean(HeapWord* p, size_t num_heap_words);\n@@ -367,1 +368,1 @@\n-  crossing_info *_object_starts;\n+  crossing_info* _object_starts;\n@@ -392,1 +393,1 @@\n-  inline void clear_objects_in_range(HeapWord *addr, size_t num_words) {\n+  inline void clear_objects_in_range(HeapWord* addr, size_t num_words) {\n@@ -399,1 +400,1 @@\n-  ShenandoahCardCluster(ShenandoahDirectCardMarkRememberedSet *rs) {\n+  ShenandoahCardCluster(ShenandoahDirectCardMarkRememberedSet* rs) {\n@@ -585,1 +586,1 @@\n-  void reset_object_range(HeapWord *from, HeapWord *to);\n+  void reset_object_range(HeapWord* from, HeapWord* to);\n@@ -701,1 +702,1 @@\n-  ShenandoahScanRemembered(ShenandoahDirectCardMarkRememberedSet *rs) {\n+  ShenandoahScanRemembered(ShenandoahDirectCardMarkRememberedSet* rs) {\n@@ -748,14 +749,0 @@\n-  \/\/ TODO:  We really don't want to share all of these APIs with arbitrary consumers of the ShenandoahScanRemembered abstraction.\n-  \/\/ But in the spirit of quick and dirty for the time being, I'm going to go ahead and publish everything for right now.  Some\n-  \/\/ of existing code already depends on having access to these services (because existing code has not been written to honor\n-  \/\/ full abstraction of remembered set scanning.  In the not too distant future, we want to try to make most, if not all, of\n-  \/\/ these services private.  Two problems with publicizing:\n-  \/\/  1. Allowing arbitrary users to reach beneath the hood allows the users to make assumptions about underlying implementation.\n-  \/\/     This will make it more difficult to change underlying implementation at a future time, such as when we eventually experiment\n-  \/\/     with SATB-based implementation of remembered set representation.\n-  \/\/  2. If we carefully control sharing of certain of these services, we can reduce the overhead of synchronization by assuring\n-  \/\/     that all users follow protocols that avoid contention that might require synchronization.  When we publish these APIs, we\n-  \/\/     lose control over who and how the data is accessed.  As a result, we are required to insert more defensive measures into\n-  \/\/     the implementation, including synchronization locks.\n-\n-\n@@ -763,2 +750,2 @@\n-  size_t card_index_for_addr(HeapWord *p);\n-  HeapWord *addr_for_card_index(size_t card_index);\n+  size_t card_index_for_addr(HeapWord* p);\n+  HeapWord* addr_for_card_index(size_t card_index);\n@@ -767,5 +754,6 @@\n-  bool is_card_dirty(HeapWord *p);\n-  void mark_card_as_dirty(HeapWord *p);\n-  void mark_range_as_dirty(HeapWord *p, size_t num_heap_words);\n-  void mark_card_as_clean(HeapWord *p);\n-  void mark_range_as_clean(HeapWord *p, size_t num_heap_words);\n+  bool is_card_dirty(HeapWord* p);\n+  bool is_write_card_dirty(HeapWord* p);\n+  void mark_card_as_dirty(HeapWord* p);\n+  void mark_range_as_dirty(HeapWord* p, size_t num_heap_words);\n+  void mark_card_as_clean(HeapWord* p);\n+  void mark_range_as_clean(HeapWord* p, size_t num_heap_words);\n@@ -777,1 +765,1 @@\n-  size_t cluster_for_addr(HeapWord *addr);\n+  size_t cluster_for_addr(HeapWord* addr);\n@@ -780,4 +768,4 @@\n-  void reset_object_range(HeapWord *from, HeapWord *to);\n-  void register_object(HeapWord *addr);\n-  void register_object_without_lock(HeapWord *addr);\n-  void coalesce_objects(HeapWord *addr, size_t length_in_words);\n+  void reset_object_range(HeapWord* from, HeapWord* to);\n+  void register_object(HeapWord* addr);\n+  void register_object_without_lock(HeapWord* addr);\n+  void coalesce_objects(HeapWord* addr, size_t length_in_words);\n@@ -797,1 +785,1 @@\n-  void mark_range_as_empty(HeapWord *addr, size_t length_in_words);\n+  void mark_range_as_empty(HeapWord* addr, size_t length_in_words);\n@@ -830,2 +818,2 @@\n-  void process_clusters(size_t first_cluster, size_t count, HeapWord *end_of_range, ClosureType *oops,\n-                               bool use_write_table, uint worker_id);\n+  void process_clusters(size_t first_cluster, size_t count, HeapWord* end_of_range, ClosureType* oops,\n+                        bool use_write_table, uint worker_id);\n@@ -835,1 +823,1 @@\n-                                         HeapWord *end_of_range, ClosureType *oops, bool use_write_table);\n+                                  HeapWord* end_of_range, ClosureType* oops, bool use_write_table);\n@@ -839,1 +827,1 @@\n-                                   ClosureType *cl, bool use_write_table, uint worker_id);\n+                            ClosureType* cl, bool use_write_table, uint worker_id);\n@@ -881,1 +869,1 @@\n-  ShenandoahHeapRegion *_r;      \/\/ The region of which this represents a chunk\n+  ShenandoahHeapRegion* _r;      \/\/ The region of which this represents a chunk\n@@ -892,1 +880,1 @@\n-\/\/ will work longer on those chunks.  Meanwhile, other worker will threads repeatedly accept and complete multiple\n+\/\/ will work longer on those chunks.  Meanwhile, other worker threads will repeatedly accept and complete multiple\n@@ -973,1 +961,1 @@\n-  inline bool next(struct ShenandoahRegionChunk *assignment);\n+  inline bool next(struct ShenandoahRegionChunk* assignment);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":38,"deletions":50,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  assert(ShenandoahHeap::heap()->old_generation()->is_parseable(), \"Old generation regions must be parseable for remembered set scan\");\n+  assert(ShenandoahHeap::heap()->old_generation()->is_parsable(), \"Old generation regions must be parsable for remembered set scan\");\n@@ -248,3 +248,0 @@\n-      \/\/ TODO: if an objArray then only use mr, else just iterate over entire object;\n-      \/\/ that would avoid the special treatment of suffix below.\n-\n@@ -358,3 +355,0 @@\n-      \/\/ TODO: ysr : This will be called multiple times with same start_region, but different start_cluster_no.\n-      \/\/ Check that it does the right thing here, and doesn't do redundant work. Also see if the call API\/interface\n-      \/\/ can be simplified.\n@@ -363,8 +357,0 @@\n-      \/\/ TODO: ysr The start_of_range calculated above is discarded and may be calculated again in process_clusters().\n-      \/\/ See if the redundant and wasted calculations can be avoided, and if the call parameters can be cleaned up.\n-      \/\/ It almost sounds like this set of methods needs a working class to stash away some useful info that can be\n-      \/\/ efficiently passed around amongst these methods, as well as related state. Note that we can't use\n-      \/\/ ShenandoahScanRemembered as there seems to be only one instance of that object for the heap which is shared\n-      \/\/ by all workers. Note that there are also task methods which call these which may have per worker storage.\n-      \/\/ We need to be careful however that if the number of workers changes dynamically that state isn't sequestered\n-      \/\/ and become obsolete.\n@@ -376,1 +362,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-  \/\/ TODO: Preserve these stats somewhere for mutator threads.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -123,3 +123,0 @@\n-\n-      \/\/ TODO: We should consider specializing this closure by generation ==\/!= null,\n-      \/\/ to avoid in_generation check on fast path here for non-generational mode.\n@@ -258,8 +255,0 @@\n-    \/\/ We allow for marked or old here for two reasons:\n-    \/\/  1. If this is a young collect, old objects wouldn't be marked. We've\n-    \/\/     recently change the verifier traversal to only follow young objects\n-    \/\/     during a young collect so this _shouldn't_ be necessary.\n-    \/\/  2. At present, we do not clear dead objects from the remembered set.\n-    \/\/     Everything in the remembered set is old (ipso facto), so allowing for\n-    \/\/     'marked_or_old' covers the case of stale objects in rset.\n-    \/\/ TODO: Just use 'is_marked' here.\n@@ -271,1 +260,1 @@\n-        check(ShenandoahAsserts::_safe_all, obj, _heap->marking_context()->is_marked_or_old(obj),\n+        check(ShenandoahAsserts::_safe_all, obj, _heap->marking_context()->is_marked(obj),\n@@ -275,1 +264,1 @@\n-        check(ShenandoahAsserts::_safe_all, obj, _heap->complete_marking_context()->is_marked_or_old(obj),\n+        check(ShenandoahAsserts::_safe_all, obj, _heap->complete_marking_context()->is_marked(obj),\n@@ -280,1 +269,1 @@\n-        check(ShenandoahAsserts::_safe_all, obj, _heap->complete_marking_context()->is_marked_or_old(obj),\n+        check(ShenandoahAsserts::_safe_all, obj, _heap->complete_marking_context()->is_marked(obj),\n@@ -1213,2 +1202,1 @@\n-\/\/ TODO: Why this closure does not visit metadata?\n-class ShenandoahVerifyNoForwared : public BasicOopIterateClosure {\n+class ShenandoahVerifyNoForwarded : public BasicOopIterateClosure {\n@@ -1234,1 +1222,0 @@\n-\/\/ TODO: Why this closure does not visit metadata?\n@@ -1273,1 +1260,1 @@\n-  ShenandoahVerifyNoForwared cl;\n+  ShenandoahVerifyNoForwarded cl;\n@@ -1277,0 +1264,1 @@\n+template<typename Scanner>\n@@ -1279,1 +1267,0 @@\n-  bool                        const _init_mark;\n@@ -1281,1 +1268,2 @@\n-  ShenandoahScanRemembered*   const _scanner;\n+  Scanner*   const _scanner;\n+  const char* _message;\n@@ -1285,2 +1273,1 @@\n-  explicit ShenandoahVerifyRemSetClosure(bool init_mark) :\n-            _init_mark(init_mark),\n+  explicit ShenandoahVerifyRemSetClosure(Scanner* scanner, const char* message) :\n@@ -1288,1 +1275,2 @@\n-            _scanner(_heap->old_generation()->card_scan()) {}\n+            _scanner(scanner),\n+            _message(message) {}\n@@ -1295,9 +1283,3 @@\n-      if (_heap->is_in_young(obj)) {\n-        size_t card_index = _scanner->card_index_for_addr((HeapWord*) p);\n-        if (_init_mark && !_scanner->is_card_dirty(card_index)) {\n-          ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, nullptr,\n-                                           \"Verify init-mark remembered set violation\", \"clean card should be dirty\", __FILE__, __LINE__);\n-        } else if (!_init_mark && !_scanner->is_write_card_dirty(card_index)) {\n-          ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, nullptr,\n-                                           \"Verify init-update-refs remembered set violation\", \"clean card should be dirty\", __FILE__, __LINE__);\n-        }\n+      if (_heap->is_in_young(obj) && !_scanner->is_card_dirty((HeapWord*) p)) {\n+        ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, p, nullptr,\n+                                         _message, \"clean card should be dirty\", __FILE__, __LINE__);\n@@ -1312,4 +1294,7 @@\n-void ShenandoahVerifier::help_verify_region_rem_set(ShenandoahHeapRegion* r, ShenandoahMarkingContext* ctx, HeapWord* from,\n-                                                    HeapWord* top, HeapWord* registration_watermark, const char* message) {\n-  ShenandoahScanRemembered* scanner = ShenandoahGenerationalHeap::heap()->old_generation()->card_scan();\n-  ShenandoahVerifyRemSetClosure check_interesting_pointers(false);\n+ShenandoahMarkingContext* ShenandoahVerifier::get_marking_context_for_old() {\n+  shenandoah_assert_generations_reconciled();\n+  if (_heap->old_generation()->is_mark_complete() || _heap->gc_generation()->is_global()) {\n+    return _heap->complete_marking_context();\n+  }\n+  return nullptr;\n+}\n@@ -1317,0 +1302,5 @@\n+template<typename Scanner>\n+void ShenandoahVerifier::help_verify_region_rem_set(Scanner* scanner, ShenandoahHeapRegion* r, ShenandoahMarkingContext* ctx,\n+                                                    HeapWord* registration_watermark, const char* message) {\n+  ShenandoahVerifyRemSetClosure<Scanner> check_interesting_pointers(scanner, message);\n+  HeapWord* from = r->bottom();\n@@ -1321,1 +1311,0 @@\n-      size_t card_index = scanner->card_index_for_addr(obj_addr);\n@@ -1325,1 +1314,1 @@\n-      if (!scanner->is_write_card_dirty(card_index) || obj->is_objArray()) {\n+      if (!scanner->is_card_dirty(obj_addr) || obj->is_objArray()) {\n@@ -1337,0 +1326,1 @@\n+    HeapWord* top = r->top();\n@@ -1341,1 +1331,0 @@\n-        size_t card_index = scanner->card_index_for_addr(obj_addr);\n@@ -1344,1 +1333,1 @@\n-        if (!scanner->is_write_card_dirty(card_index) || obj->is_objArray()) {\n+        if (!scanner->is_card_dirty(obj_addr) || obj->is_objArray()) {\n@@ -1363,0 +1352,15 @@\n+class ShenandoahWriteTableScanner {\n+private:\n+  ShenandoahScanRemembered* _scanner;\n+public:\n+  explicit ShenandoahWriteTableScanner(ShenandoahScanRemembered* scanner) : _scanner(scanner) {}\n+\n+  bool is_card_dirty(HeapWord* obj_addr) {\n+    return _scanner->is_write_card_dirty(obj_addr);\n+  }\n+\n+  bool verify_registration(HeapWord* obj_addr, ShenandoahMarkingContext* ctx) {\n+    return _scanner->verify_registration(obj_addr, ctx);\n+  }\n+};\n+\n@@ -1369,5 +1373,1 @@\n-  assert(_heap->mode()->is_generational(), \"Only verify remembered set for generational operational modes\");\n-\n-  ShenandoahScanRemembered* scanner = ShenandoahGenerationalHeap::heap()->old_generation()->card_scan();\n-  ShenandoahVerifyRemSetClosure check_interesting_pointers(true);\n-  ShenandoahMarkingContext* ctx;\n+  shenandoah_assert_generational();\n@@ -1375,0 +1375,1 @@\n+  ShenandoahMarkingContext* ctx = get_marking_context_for_old();\n@@ -1376,1 +1377,0 @@\n-  log_debug(gc)(\"Verifying remembered set at %s mark\", old_generation->is_doing_mixed_evacuations() ? \"mixed\" : \"young\");\n@@ -1378,6 +1378,1 @@\n-  shenandoah_assert_generations_reconciled();\n-  if (old_generation->is_mark_complete() || _heap->gc_generation()->is_global()) {\n-    ctx = _heap->complete_marking_context();\n-  } else {\n-    ctx = nullptr;\n-  }\n+  log_debug(gc)(\"Verifying remembered set at %s mark\", old_generation->is_doing_mixed_evacuations() ? \"mixed\" : \"young\");\n@@ -1385,0 +1380,1 @@\n+  ShenandoahScanRemembered* scanner = old_generation->card_scan();\n@@ -1387,4 +1383,0 @@\n-    HeapWord* tams = (ctx != nullptr) ? ctx->top_at_mark_start(r) : nullptr;\n-\n-    \/\/ TODO: Is this replaceable with call to help_verify_region_rem_set?\n-\n@@ -1392,43 +1384,3 @@\n-      HeapWord* obj_addr = r->bottom();\n-      if (r->is_humongous_start()) {\n-        oop obj = cast_to_oop(obj_addr);\n-        if ((ctx == nullptr) || ctx->is_marked(obj)) {\n-          \/\/ For humongous objects, the typical object is an array, so the following checks may be overkill\n-          \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n-          \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n-          if (!scanner->is_card_dirty(obj_addr) || obj->is_objArray()) {\n-            obj->oop_iterate(&check_interesting_pointers);\n-          }\n-          \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n-        }\n-        \/\/ else, this humongous object is not marked so no need to verify its internal pointers\n-        if (!scanner->verify_registration(obj_addr, ctx)) {\n-          ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, nullptr, nullptr,\n-                                           \"Verify init-mark remembered set violation\", \"object not properly registered\", __FILE__, __LINE__);\n-        }\n-      } else if (!r->is_humongous()) {\n-        HeapWord* top = r->top();\n-        while (obj_addr < top) {\n-          oop obj = cast_to_oop(obj_addr);\n-          \/\/ ctx->is_marked() returns true if mark bit set (TAMS not relevant during init mark)\n-          if ((ctx == nullptr) || ctx->is_marked(obj)) {\n-            \/\/ For regular objects (not object arrays), if the card holding the start of the object is dirty,\n-            \/\/ we do not need to verify that cards spanning interesting pointers within this object are dirty.\n-            if (!scanner->is_card_dirty(obj_addr) || obj->is_objArray()) {\n-              obj->oop_iterate(&check_interesting_pointers);\n-            }\n-            \/\/ else, object's start is marked dirty and obj is not an objArray, so any interesting pointers are covered\n-            if (!scanner->verify_registration(obj_addr, ctx)) {\n-              ShenandoahAsserts::print_failure(ShenandoahAsserts::_safe_all, obj, nullptr, nullptr,\n-                                               \"Verify init-mark remembered set violation\", \"object not properly registered\", __FILE__, __LINE__);\n-            }\n-            obj_addr += obj->size();\n-          } else {\n-            \/\/ This object is not live so we don't verify dirty cards contained therein\n-            assert(tams != nullptr, \"If object is not live, ctx and tams should be non-null\");\n-            obj_addr = ctx->get_next_marked_addr(obj_addr, tams);\n-          }\n-        }\n-      } \/\/ else, we ignore humongous continuation region\n-    } \/\/ else, this is not an OLD region so we ignore it\n-  } \/\/ all regions have been processed\n+      help_verify_region_rem_set(scanner, r, ctx, r->end(), \"Verify init-mark remembered set violation\");\n+    }\n+  }\n@@ -1439,1 +1391,1 @@\n-  assert(_heap->mode()->is_generational(), \"Only verify remembered set for generational operational modes\");\n+  shenandoah_assert_generational();\n@@ -1441,0 +1393,1 @@\n+  ShenandoahWriteTableScanner scanner(ShenandoahGenerationalHeap::heap()->old_generation()->card_scan());\n@@ -1444,1 +1397,1 @@\n-      help_verify_region_rem_set(r, nullptr, r->bottom(), r->top(), r->top(), \"Remembered set violation at end of Full GC\");\n+      help_verify_region_rem_set(&scanner, r, nullptr, r->top(), \"Remembered set violation at end of Full GC\");\n@@ -1455,10 +1408,1 @@\n-  assert(_heap->mode()->is_generational(), \"Only verify remembered set for generational operational modes\");\n-\n-  ShenandoahMarkingContext* ctx;\n-\n-  shenandoah_assert_generations_reconciled();\n-  if (_heap->old_generation()->is_mark_complete() || _heap->gc_generation()->is_global()) {\n-    ctx = _heap->complete_marking_context();\n-  } else {\n-    ctx = nullptr;\n-  }\n+  shenandoah_assert_generational();\n@@ -1466,0 +1410,2 @@\n+  ShenandoahMarkingContext* ctx = get_marking_context_for_old();\n+  ShenandoahWriteTableScanner scanner(_heap->old_generation()->card_scan());\n@@ -1469,2 +1415,1 @@\n-      help_verify_region_rem_set(r, ctx, r->bottom(), r->top(), r->get_update_watermark(),\n-                                 \"Remembered set violation at init-update-references\");\n+      help_verify_region_rem_set(&scanner, r, ctx, r->get_update_watermark(), \"Remembered set violation at init-update-references\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":58,"deletions":113,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class ShenandoahMarkingContext;\n@@ -74,2 +75,2 @@\n-    \/\/ inter-generational pointers.\n-    \/\/ TODO: This differs from the previous mode by update-watermark() vs top() end range?\n+    \/\/ inter-generational pointers. Differs from previous verification modes by using top instead\n+    \/\/ of update watermark and not using the marking context.\n@@ -234,2 +235,3 @@\n-   void help_verify_region_rem_set(ShenandoahHeapRegion* r, ShenandoahMarkingContext* ctx,\n-                                    HeapWord* from, HeapWord* top, HeapWord* update_watermark, const char* message);\n+  template<typename Scanner>\n+  void help_verify_region_rem_set(Scanner* scanner, ShenandoahHeapRegion* r, ShenandoahMarkingContext* ctx,\n+                                  HeapWord* update_watermark, const char* message);\n@@ -240,0 +242,2 @@\n+\n+  ShenandoahMarkingContext* get_marking_context_for_old();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,2 +52,1 @@\n-  \/\/ TODO: why not test for equals YOUNG_GENERATION?  As written, returns true for regions that are FREE\n-  return !region->is_old();\n+  return region->is_young();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}